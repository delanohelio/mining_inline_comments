{"pr_number": 2409, "pr_title": "Lobby/GUI work", "pr_createdAt": "2020-11-18T17:13:23Z", "pr_url": "https://github.com/MegaMek/megamek/pull/2409", "timeline": [{"oid": "583fac4e9a1c6ad0049f8618d4fc77e58de2f589", "url": "https://github.com/MegaMek/megamek/commit/583fac4e9a1c6ad0049f8618d4fc77e58de2f589", "message": "Tooltip refactor into its own class", "committedDate": "2020-10-19T14:23:11Z", "type": "commit"}, {"oid": "381e5a2ec4e9c43a5a16b2eb96c436589095b026", "url": "https://github.com/MegaMek/megamek/commit/381e5a2ec4e9c43a5a16b2eb96c436589095b026", "message": "GUIScale and TT Rework, part", "committedDate": "2020-10-31T13:16:30Z", "type": "commit"}, {"oid": "02bee71c158fecb2fa765539de5f6d3f740aa44b", "url": "https://github.com/MegaMek/megamek/commit/02bee71c158fecb2fa765539de5f6d3f740aa44b", "message": "Lobby work, part 2", "committedDate": "2020-11-04T09:47:54Z", "type": "commit"}, {"oid": "e0a67babcade4067fa3102c7b88e0659c72bdcc1", "url": "https://github.com/MegaMek/megamek/commit/e0a67babcade4067fa3102c7b88e0659c72bdcc1", "message": "More Lobby changes", "committedDate": "2020-11-09T15:15:56Z", "type": "commit"}, {"oid": "39deb1b2d32684a2f4e4df64cb3e8def93304211", "url": "https://github.com/MegaMek/megamek/commit/39deb1b2d32684a2f4e4df64cb3e8def93304211", "message": "Further UI scaling", "committedDate": "2020-11-11T09:04:41Z", "type": "commit"}, {"oid": "064cc1daba1fe1e7661d8a4c5e0a9bfbafd06cb5", "url": "https://github.com/MegaMek/megamek/commit/064cc1daba1fe1e7661d8a4c5e0a9bfbafd06cb5", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform\n\nConflicts:\n\tmegamek/src/megamek/client/ui/swing/ChatLounge.java\n\tmegamek/src/megamek/client/ui/swing/CommonSettingsDialog.java\n\tmegamek/src/megamek/client/ui/swing/GUIPreferences.java\n\tmegamek/src/megamek/client/ui/swing/boardview/EntitySprite.java", "committedDate": "2020-11-11T12:31:35Z", "type": "commit"}, {"oid": "383243a1863093c91d4d5a7f37aefa061fd472cc", "url": "https://github.com/MegaMek/megamek/commit/383243a1863093c91d4d5a7f37aefa061fd472cc", "message": "Small Change", "committedDate": "2020-11-11T12:34:54Z", "type": "commit"}, {"oid": "0e3a46646690dd77bbf90b92b18f0f9ed5ef110d", "url": "https://github.com/MegaMek/megamek/commit/0e3a46646690dd77bbf90b92b18f0f9ed5ef110d", "message": "Further scaling, Searchlights etc.", "committedDate": "2020-11-17T16:34:29Z", "type": "commit"}, {"oid": "4bf783e2298bbaba8da2488b628ef525f83d60e3", "url": "https://github.com/MegaMek/megamek/commit/4bf783e2298bbaba8da2488b628ef525f83d60e3", "message": "GameOptions allow hiding unoff and legacy opts", "committedDate": "2020-11-20T18:50:09Z", "type": "commit"}, {"oid": "b0c87c675c070dc1bfaf88c06268a1b1799e65f3", "url": "https://github.com/MegaMek/megamek/commit/b0c87c675c070dc1bfaf88c06268a1b1799e65f3", "message": "Remove Java11isms", "committedDate": "2020-11-20T19:01:39Z", "type": "commit"}, {"oid": "396f96d905875f0473e260afd045d193f49e2dc8", "url": "https://github.com/MegaMek/megamek/commit/396f96d905875f0473e260afd045d193f49e2dc8", "message": "Lobby Mek Table Sorting, correcting loading and unloading and GUI events", "committedDate": "2020-11-25T16:18:33Z", "type": "commit"}, {"oid": "8853a5ace839428f5e6dbbc3b07f8fe57625ab49", "url": "https://github.com/MegaMek/megamek/commit/8853a5ace839428f5e6dbbc3b07f8fe57625ab49", "message": "Extract lobby mektable popup, unit selector correction", "committedDate": "2020-12-01T06:56:04Z", "type": "commit"}, {"oid": "43ab7876c9aa6d9b7c483a52c0f17ea19a715fbb", "url": "https://github.com/MegaMek/megamek/commit/43ab7876c9aa6d9b7c483a52c0f17ea19a715fbb", "message": "Lobby MekTabel popup work", "committedDate": "2020-12-03T11:13:12Z", "type": "commit"}, {"oid": "e40533c481c8c7ad84a21609e8a8b01fc8cf0128", "url": "https://github.com/MegaMek/megamek/commit/e40533c481c8c7ad84a21609e8a8b01fc8cf0128", "message": "Popup changes", "committedDate": "2020-12-04T14:46:41Z", "type": "commit"}, {"oid": "4f5175175a282f66f2e6f36300bcf038899dfd36", "url": "https://github.com/MegaMek/megamek/commit/4f5175175a282f66f2e6f36300bcf038899dfd36", "message": "Player Config dialog and more", "committedDate": "2020-12-15T16:14:50Z", "type": "commit"}, {"oid": "11f25211a43b1b923429bbedf3b1b24b6715d0cc", "url": "https://github.com/MegaMek/megamek/commit/11f25211a43b1b923429bbedf3b1b24b6715d0cc", "message": "Player Settings dialog work", "committedDate": "2020-12-15T20:29:38Z", "type": "commit"}, {"oid": "79b20290b1079026fcbd931f996661e9667c00b7", "url": "https://github.com/MegaMek/megamek/commit/79b20290b1079026fcbd931f996661e9667c00b7", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform\n\nConflicts:\n\tmegamek/i18n/megamek/client/messages.properties\n\tmegamek/src/megamek/client/ui/swing/ChatLounge.java", "committedDate": "2020-12-15T20:34:18Z", "type": "commit"}, {"oid": "6ea219465da010e28570b9d2db3e0db0d1320ddc", "url": "https://github.com/MegaMek/megamek/commit/6ea219465da010e28570b9d2db3e0db0d1320ddc", "message": "After merge correction", "committedDate": "2020-12-15T20:39:42Z", "type": "commit"}, {"oid": "d0c0d6dd2f074227e5241ba490b4ae1ae522e3fb", "url": "https://github.com/MegaMek/megamek/commit/d0c0d6dd2f074227e5241ba490b4ae1ae522e3fb", "message": "Lobby work, ECMTest correction", "committedDate": "2020-12-20T22:03:26Z", "type": "commit"}, {"oid": "912972e6dc06d718e341c18f67920796bea8fac7", "url": "https://github.com/MegaMek/megamek/commit/912972e6dc06d718e341c18f67920796bea8fac7", "message": "Planetary Conditions dialog", "committedDate": "2020-12-25T08:39:31Z", "type": "commit"}, {"oid": "8d2296f9c221e51caabd64f9f52c6f2ff8b1d578", "url": "https://github.com/MegaMek/megamek/commit/8d2296f9c221e51caabd64f9f52c6f2ff8b1d578", "message": "Forgot to stage UnitTooltip", "committedDate": "2020-12-25T08:40:03Z", "type": "commit"}, {"oid": "aa5261fa5a842539f6bf358ede89612eb99dcfce", "url": "https://github.com/MegaMek/megamek/commit/aa5261fa5a842539f6bf358ede89612eb99dcfce", "message": "Adjustments", "committedDate": "2020-12-28T18:51:08Z", "type": "commit"}, {"oid": "982946d2227440619ea9d37a40a46f761ab45547", "url": "https://github.com/MegaMek/megamek/commit/982946d2227440619ea9d37a40a46f761ab45547", "message": "Map Selection, BV Dialog", "committedDate": "2021-01-04T06:27:33Z", "type": "commit"}, {"oid": "0616d6c9df0ec24ed247395efd27fbdd03640950", "url": "https://github.com/MegaMek/megamek/commit/0616d6c9df0ec24ed247395efd27fbdd03640950", "message": "More Map Preview", "committedDate": "2021-01-05T10:02:49Z", "type": "commit"}, {"oid": "7d1d30cb52572fa36f9a3395d22f23f684f20e3d", "url": "https://github.com/MegaMek/megamek/commit/7d1d30cb52572fa36f9a3395d22f23f684f20e3d", "message": "More Lobby Map Assembly Work", "committedDate": "2021-01-10T07:28:56Z", "type": "commit"}, {"oid": "8b3e48a772bfa437e914de0d986170b35eccf777", "url": "https://github.com/MegaMek/megamek/commit/8b3e48a772bfa437e914de0d986170b35eccf777", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform\n\nConflicts:\n\tmegamek/src/megamek/client/ui/swing/ChatLounge.java\n\tmegamek/src/megamek/client/ui/swing/ClientGUI.java\n\tmegamek/src/megamek/client/ui/swing/GUIPreferences.java\n\tmegamek/src/megamek/client/ui/swing/boardview/EntitySprite.java", "committedDate": "2021-01-10T10:31:22Z", "type": "commit"}, {"oid": "0afc750a3575a4f373ee67820c1a213bffa0817d", "url": "https://github.com/MegaMek/megamek/commit/0afc750a3575a4f373ee67820c1a213bffa0817d", "message": "Java11isms removed", "committedDate": "2021-01-10T10:51:04Z", "type": "commit"}, {"oid": "848460d3f341d4922b50618f6b22ef4a9b52dd72", "url": "https://github.com/MegaMek/megamek/commit/848460d3f341d4922b50618f6b22ef4a9b52dd72", "message": "Team Overview, Saving Map Setup, Map UI, Quirks display", "committedDate": "2021-01-20T11:53:18Z", "type": "commit"}, {"oid": "4d24f1fdd01dcb743f7ee01708974dcf4a0879af", "url": "https://github.com/MegaMek/megamek/commit/4d24f1fdd01dcb743f7ee01708974dcf4a0879af", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform\n\nConflicts:\n\tmegamek/src/megamek/client/bot/princess/FireControl.java\n\tmegamek/src/megamek/client/ui/swing/ClientGUI.java\n\tmegamek/src/megamek/client/ui/swing/dialog/MegaMekUnitSelectorDialog.java", "committedDate": "2021-01-20T16:09:31Z", "type": "commit"}, {"oid": "2eccb216d155152bfb67715e9630795313c4dae6", "url": "https://github.com/MegaMek/megamek/commit/2eccb216d155152bfb67715e9630795313c4dae6", "message": "Corrections", "committedDate": "2021-01-20T16:18:02Z", "type": "commit"}, {"oid": "8250c2d17791729e11710287f921f11ea8d4d70f", "url": "https://github.com/MegaMek/megamek/commit/8250c2d17791729e11710287f921f11ea8d4d70f", "message": "C3 config and late deployment on popup, C3 mektable sorting", "committedDate": "2021-01-24T09:29:03Z", "type": "commit"}, {"oid": "b831bcedabf3028e83d4dd401d76f1cdf6cb69a7", "url": "https://github.com/MegaMek/megamek/commit/b831bcedabf3028e83d4dd401d76f1cdf6cb69a7", "message": "Tooltip Ammo display, Random Army Dialog remembers size", "committedDate": "2021-02-03T22:22:39Z", "type": "commit"}, {"oid": "80e8b593fde4ef3423c7531f9270745015f16c28", "url": "https://github.com/MegaMek/megamek/commit/80e8b593fde4ef3423c7531f9270745015f16c28", "message": "Java11ism", "committedDate": "2021-02-03T22:43:00Z", "type": "commit"}, {"oid": "724942f2e88e5d6ea0eca023d8dc1337c6bb635c", "url": "https://github.com/MegaMek/megamek/commit/724942f2e88e5d6ea0eca023d8dc1337c6bb635c", "message": "Forces, Force/C3 Tree View, Saving Force to MUL", "committedDate": "2021-02-08T15:39:26Z", "type": "commit"}, {"oid": "26a146c45e4476f2406bbbc09948b36ac2dccbae", "url": "https://github.com/MegaMek/megamek/commit/26a146c45e4476f2406bbbc09948b36ac2dccbae", "message": "Force Tree display work", "committedDate": "2021-03-04T21:31:53Z", "type": "commit"}, {"oid": "b79fa5d82022e1872cecbc91a699beb026c3e488", "url": "https://github.com/MegaMek/megamek/commit/b79fa5d82022e1872cecbc91a699beb026c3e488", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform\n\nConflicts:\n\tmegamek/src/megamek/client/ui/swing/ClientGUI.java", "committedDate": "2021-03-04T21:35:49Z", "type": "commit"}, {"oid": "cf3eaabb2e79f184e4c3a163f8ce15c3ace88ed5", "url": "https://github.com/MegaMek/megamek/commit/cf3eaabb2e79f184e4c3a163f8ce15c3ace88ed5", "message": "Java9 List.of->Arrays.asList", "committedDate": "2021-03-04T21:42:28Z", "type": "commit"}, {"oid": "ec872b350a1f9431e8d851b3a5bfbcdaf57f461f", "url": "https://github.com/MegaMek/megamek/commit/ec872b350a1f9431e8d851b3a5bfbcdaf57f461f", "message": "Import correction", "committedDate": "2021-03-04T21:52:25Z", "type": "commit"}, {"oid": "7e3cb0b50ba7caedc9e4ce011f803db294e2c41d", "url": "https://github.com/MegaMek/megamek/commit/7e3cb0b50ba7caedc9e4ce011f803db294e2c41d", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform", "committedDate": "2021-03-05T07:11:48Z", "type": "commit"}, {"oid": "2691005927f62c748d1c60374ac5e2001625e7ad", "url": "https://github.com/MegaMek/megamek/commit/2691005927f62c748d1c60374ac5e2001625e7ad", "message": "More force tree and popup work, copy+paste Mek List, formatting", "committedDate": "2021-03-16T17:20:08Z", "type": "commit"}, {"oid": "3960e014670ddad6430f691c9654a90a7ebf0582", "url": "https://github.com/MegaMek/megamek/commit/3960e014670ddad6430f691c9654a90a7ebf0582", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform\n\nConflicts:\n\tmegamek/i18n/megamek/client/messages.properties\n\tmegamek/src/megamek/client/ui/swing/CommonHelpDialog.java", "committedDate": "2021-03-16T18:29:06Z", "type": "commit"}, {"oid": "a56ab4b43643589073b42261baf104360717dead", "url": "https://github.com/MegaMek/megamek/commit/a56ab4b43643589073b42261baf104360717dead", "message": "Forceupdates handling changes, advanced settings NPE", "committedDate": "2021-03-25T19:41:57Z", "type": "commit"}, {"oid": "264c194af5d93ba40829a3bad34e83e1162a263b", "url": "https://github.com/MegaMek/megamek/commit/264c194af5d93ba40829a3bad34e83e1162a263b", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform\n\nConflicts:\n\tmegamek/src/megamek/common/Entity.java", "committedDate": "2021-03-25T19:48:33Z", "type": "commit"}, {"oid": "16b402687395792793eb4701bb483f63f6586f40", "url": "https://github.com/MegaMek/megamek/commit/16b402687395792793eb4701bb483f63f6586f40", "message": "Apply GUI scaling to reports (and warning dialogs)", "committedDate": "2021-03-28T07:40:58Z", "type": "commit"}, {"oid": "dc1894d61ad0d7440c3318785c46e884157b0d64", "url": "https://github.com/MegaMek/megamek/commit/dc1894d61ad0d7440c3318785c46e884157b0d64", "message": "Suggestions from Discord, Player Settings", "committedDate": "2021-04-05T07:26:05Z", "type": "commit"}, {"oid": "b88c5a474aa91029a6ba48957b4148dcd27cdf5d", "url": "https://github.com/MegaMek/megamek/commit/b88c5a474aa91029a6ba48957b4148dcd27cdf5d", "message": "Merge remote-tracking branch 'MM_Master/master' into TooltipReform\n\nConflicts:\n\tmegamek/src/megamek/client/ui/swing/ChatLounge.java\n\tmegamek/src/megamek/common/actions/SearchlightAttackAction.java", "committedDate": "2021-04-05T13:07:38Z", "type": "commit"}, {"oid": "fa0b0ca1b36e2e58e01086ca039ebec860616ad3", "url": "https://github.com/MegaMek/megamek/commit/fa0b0ca1b36e2e58e01086ca039ebec860616ad3", "message": "Make Unit Paste (Ctrl-V) work when the mek table is empty", "committedDate": "2021-04-05T13:30:42Z", "type": "commit"}, {"oid": "212fd07843ee6cfa2dfa34759e06e76f3050c367", "url": "https://github.com/MegaMek/megamek/commit/212fd07843ee6cfa2dfa34759e06e76f3050c367", "message": "Team Overview smaller detached state, player table", "committedDate": "2021-04-07T13:47:08Z", "type": "commit"}, {"oid": "5b676552ab93711b46224b2e1b474bd2c1549e48", "url": "https://github.com/MegaMek/megamek/commit/5b676552ab93711b46224b2e1b474bd2c1549e48", "message": "Corrections", "committedDate": "2021-04-07T14:08:59Z", "type": "commit"}, {"oid": "b6990705cc2918f9cdef935124f8cb9f05fffb8e", "url": "https://github.com/MegaMek/megamek/commit/b6990705cc2918f9cdef935124f8cb9f05fffb8e", "message": "Corrections, Alerts", "committedDate": "2021-04-07T15:51:31Z", "type": "commit"}, {"oid": "436282bf29e8827ee395084aedf5698a61554250", "url": "https://github.com/MegaMek/megamek/commit/436282bf29e8827ee395084aedf5698a61554250", "message": "Corrections, add force to Tooltip", "committedDate": "2021-04-09T06:40:25Z", "type": "commit"}, {"oid": "10d62a97552c6e4017edbb11d566ca11d6954c04", "url": "https://github.com/MegaMek/megamek/commit/10d62a97552c6e4017edbb11d566ca11d6954c04", "message": "Cleanup", "committedDate": "2021-04-11T13:36:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxODUyNQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611318525", "bodyText": "Comment doesn't match method behavior. Also, do we really want to be using exceptions as flow control?", "author": "NickAragua", "createdAt": "2021-04-12T04:23:12Z", "path": "megamek/src/megamek/client/Client.java", "diffHunk": "@@ -1757,4 +1884,18 @@ public void setCurrentHex(IHex hex) {\n     public void setCurrentHex(Coords hex) {\n         currentHex = hex;\n     }\n+    \n+    /** Returns true when the player is a bot added/controlled by this client. */\n+    public boolean isLocalBot(IPlayer player) {\n+        return bots.containsKey(player.getName());\n+    }\n+    \n+    /** Returns true when the player is a bot added/controlled by this client. */", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDM2Mzc0NA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614363744", "bodyText": "I'll change it to simply return null when the given player isn't actually a bot. Saves space. I don't mind but for the sake of clarity: When a method can't return a value that is correct, then why not use an exception? It just means it'll fail clearly when the caller doesn't do the appropriate checks before. In the same case, returning null will likely lead to an NPE, just at another place. I wouldn't know what else to return.", "author": "SJuliez", "createdAt": "2021-04-15T20:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxODUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDM3MDU1NA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614370554", "bodyText": "Looking at it again, in this particular case, I don't think I have a problem with the exception, just the mismatched comment. Maybe include an update to the comment that indicates this throws an exception.", "author": "NickAragua", "createdAt": "2021-04-15T20:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxODUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxODkzMg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611318932", "bodyText": "Is it possible to get some explanation on why somebody would use one of these constructors over the others?", "author": "NickAragua", "createdAt": "2021-04-12T04:24:57Z", "path": "megamek/src/megamek/client/ui/swing/ClientDialog.java", "diffHunk": "@@ -51,6 +53,12 @@ public ClientDialog(JFrame owner, String title, boolean modal) {\n         super(owner, title, modal);\n         this.owner = owner;\n     }\n+    \n+    public ClientDialog(JFrame owner, String title, boolean modal, boolean scale) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxOTE5Mg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611319192", "bodyText": "Sneaky a little extra feature in there. Nice.", "author": "NickAragua", "createdAt": "2021-04-12T04:25:53Z", "path": "megamek/src/megamek/client/ui/swing/ClientGUI.java", "diffHunk": "@@ -709,6 +704,9 @@ public void actionPerformed(ActionEvent event) {\n             case FILE_GAME_SAVE:\n                 saveGame();\n                 break;\n+            case FILE_GAME_QSAVE:\n+                quickSaveGame();", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxOTMzOA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611319338", "bodyText": "I guess there was a better solution. What happens now?", "author": "NickAragua", "createdAt": "2021-04-12T04:26:27Z", "path": "megamek/src/megamek/client/ui/swing/ClientGUI.java", "diffHunk": "@@ -1006,12 +1020,6 @@ void die() {\n         }\n         client.die();\n \n-        // TODO Is there a better solution?", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDM3MjM1Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614372353", "bodyText": "From the former comment:\n// This is required because the ChatLounge adds the listener to the\n// MechSummaryCache that must be removed explicitly.\nI think the call to ((Distractable) component).removeAllListeners(); a few lines above already removes that listener.", "author": "SJuliez", "createdAt": "2021-04-15T20:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxOTMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxOTQ5Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611319493", "bodyText": "This should probably be QuickLoad instead.", "author": "NickAragua", "createdAt": "2021-04-12T04:27:08Z", "path": "megamek/src/megamek/client/ui/swing/CommonMenuBar.java", "diffHunk": "@@ -243,6 +247,16 @@ public CommonMenuBar() {\n         fileGameSave.addActionListener(this);\n         fileGameSave.setActionCommand(ClientGUI.FILE_GAME_SAVE);\n         submenu.add(fileGameSave);\n+        fileGameQSave = new JMenuItem(Messages.getString(\"CommonMenuBar.fileGameQuickSave\")); //$NON-NLS-1$\n+        fileGameQSave.addActionListener(this);\n+        fileGameQSave.setActionCommand(ClientGUI.FILE_GAME_QSAVE);\n+        fileGameQSave.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, InputEvent.CTRL_DOWN_MASK));\n+        submenu.add(fileGameQSave);\n+        fileGameQLoad = new JMenuItem(Messages.getString(\"CommonMenuBar.fileGameQuickSave\")); //$NON-NLS-1$", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDM3Mjg2NQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614372865", "bodyText": "Yes.", "author": "SJuliez", "createdAt": "2021-04-15T20:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxOTQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxOTcyOA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611319728", "bodyText": "Maybe get rid of the commented out code here and on line 980? Or address it somehow otherwise.", "author": "NickAragua", "createdAt": "2021-04-12T04:27:54Z", "path": "megamek/src/megamek/client/ui/swing/CommonMenuBar.java", "diffHunk": "@@ -937,19 +964,19 @@ private synchronized void manageMenu() {\n             viewZoomOut.setEnabled(false);\n             viewKeybindsOverlay.setEnabled(false);\n         }\n+        \n+        fileUnitsPaste.setEnabled(phase == IGame.Phase.PHASE_LOUNGE);\n \n         // If we have a unit list, and if we are in the lounge,\n         // then we can still perform all unit list actions.\n         if (hasUnitList) {\n             fileUnitsOpen.setEnabled(phase == IGame.Phase.PHASE_LOUNGE);\n-            fileUnitsClear.setEnabled(phase == IGame.Phase.PHASE_LOUNGE);\n           //  fileUnitsSave.setEnabled(phase == IGame.Phase.PHASE_LOUNGE);", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDM3ODk5MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614378990", "bodyText": "I think I'll remove these menu items. They are for the lobby only anyway and saving unit lists depends on blind drop options which the menu bar doesnt adress and loading units lists depends on the selected player which the menu bar also doesnt adress. There's big buttons for loading/saving.", "author": "SJuliez", "createdAt": "2021-04-15T20:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMxOTcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMDAxMA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611320010", "bodyText": "Think this one needs the megamek license header.", "author": "NickAragua", "createdAt": "2021-04-12T04:28:59Z", "path": "megamek/src/megamek/client/ui/swing/GameOptionsDialog.java", "diffHunk": "@@ -30,24 +30,9 @@\n import java.awt.event.WindowAdapter;", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMjk2OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611322968", "bodyText": "I'm still amused at the idea of water-based snow in 30C weather.", "author": "NickAragua", "createdAt": "2021-04-12T04:41:42Z", "path": "megamek/src/megamek/client/ui/swing/PlanetaryConditionsDialog.java", "diffHunk": "@@ -20,544 +20,618 @@\n \n package megamek.client.ui.swing;\n \n-import java.awt.GridBagConstraints;\n-import java.awt.GridBagLayout;\n-import java.awt.Insets;\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.FlowLayout;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n-import java.awt.event.WindowAdapter;\n-import java.awt.event.WindowEvent;\n-\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.io.File;\n+\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n import javax.swing.JButton;\n import javax.swing.JCheckBox;\n import javax.swing.JComboBox;\n-import javax.swing.JComponent;\n-import javax.swing.JDialog;\n import javax.swing.JFrame;\n import javax.swing.JLabel;\n-import javax.swing.JOptionPane;\n import javax.swing.JPanel;\n import javax.swing.JTextField;\n import javax.swing.SwingConstants;\n+import javax.swing.border.EmptyBorder;\n \n import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.common.Configuration;\n import megamek.common.PlanetaryConditions;\n+import megamek.common.util.ImageUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+import static megamek.common.PlanetaryConditions.*;\n \n /**\n  * A dialog that allows for customization of planetary conditions\n  *\n  * @author Jay Lawson\n+ * @author Simon\n  * @version\n  */\n-public class PlanetaryConditionsDialog extends JDialog implements\n-        ActionListener {\n+public class PlanetaryConditionsDialog extends ClientDialog {\n \n     private static final long serialVersionUID = -4426594323169113468L;\n+    \n+    /** Creates new PlanetaryConditionsDialog and takes the conditions from the client's Game. */\n+    public PlanetaryConditionsDialog(ClientGUI cl) {\n+        super(cl.frame, Messages.getString(\"PlanetaryConditionsDialog.title\"), true, true);\n+        client = cl;\n+        setupDialog();\n+        update(client.getClient().getGame().getPlanetaryConditions());\n+    }\n+    \n+    /** Creates new PlanetaryConditionsDialog and sets the given conditions. Used for scenarios. */\n+    public PlanetaryConditionsDialog(JFrame frame, PlanetaryConditions conditions) {\n+        super(frame, Messages.getString(\"PlanetaryConditionsDialog.title\"), true, true);\n+        setupDialog();\n+        update(conditions);\n+    }\n+    \n+    /** Sets the dialog visible and returns true if the user pressed the Okay button. */\n+    public boolean showDialog() {\n+        userResponse = false;\n+        setVisible(true);\n+        return userResponse;\n+    }\n \n-    private ClientGUI client;\n-    private JFrame frame;\n-    private PlanetaryConditions conditions;\n-    private int currentWeather;\n+    /** Returns the conditions chosen by the player. */\n     public PlanetaryConditions getConditions() {\n+        setConditions();\n         return conditions;\n     }\n+    \n+    /** Stores the given conditions and updates the dialog fields. */\n+    public void update(PlanetaryConditions planetConditions) {\n+        conditions = (PlanetaryConditions) planetConditions.clone();\n+        refreshValues();\n+        adaptToWeatherAtmo();\n+    }\n+    \n+    // PRIVATE\n \n-    private JLabel labLight = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labLight\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choLight = new JComboBox<String>();\n-    private JLabel labWeather = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWeather\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choWeather = new JComboBox<String>();\n-    private JLabel labWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choWind = new JComboBox<String>();\n-    private JLabel labMinWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labMinWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choMinWind = new JComboBox<String>();\n-    private JLabel labMaxWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labMaxWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> cboWindDirection = new JComboBox<>();\n-    private JLabel labWindDirection = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWindDirection\"), SwingConstants.RIGHT);\n-    private JComboBox<String> choMaxWind = new JComboBox<String>();\n-    private JLabel labAtmosphere = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labAtmosphere\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choFog = new JComboBox<String>();\n-    private JLabel labFog = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labFog\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choAtmosphere = new JComboBox<String>();\n-    private JCheckBox cBlowingSands = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.BlowingSands\"));\n-    private JCheckBox cShiftWindDir = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.shiftWindDir\"));\n-    private JCheckBox cShiftWindStr = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.shiftWindStr\"));\n+    private ClientGUI client;\n+    private PlanetaryConditions conditions;\n+    \n+    private static final int TOOLTIP_WIDTH = 300;\n+    private static final String PCD = \"PlanetaryConditionsDialog.\";\n+    private JLabel labLight = new JLabel(Messages.getString(PCD + \"labLight\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comLight = new JComboBox<String>();\n+    private JLabel labWeather = new TipLabel(Messages.getString(PCD + \"labWeather\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comWeather = new JComboBox<String>();\n+    private JLabel labWind = new TipLabel(Messages.getString(PCD + \"labWind\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comWind = new JComboBox<String>();\n+    private JLabel labMinWind = new JLabel(Messages.getString(PCD + \"labMinWind\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comWindFrom = new JComboBox<String>();\n+    private JLabel labMaxWind = new JLabel(Messages.getString(PCD + \"labMaxWind\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comWindDirection = new JComboBox<>();\n+    private JLabel labWindDirection = new JLabel(Messages.getString(PCD + \"labWindDirection\"), SwingConstants.RIGHT);\n+    private JComboBox<String> comWindTo = new JComboBox<String>();\n+    private JLabel labAtmosphere = new TipLabel(Messages.getString(PCD + \"labAtmosphere\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comFog = new JComboBox<String>();\n+    private JLabel labFog = new TipLabel(Messages.getString(PCD + \"labFog\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comAtmosphere = new JComboBox<String>();\n+    private JLabel labBlowingSands = new TipLabel(Messages.getString(PCD + \"BlowingSands\"), SwingConstants.RIGHT, this);\n+    private JCheckBox chkBlowingSands = new JCheckBox();\n+    private JLabel labShiftWindDir = new JLabel(Messages.getString(PCD + \"shiftWindDir\"), SwingConstants.RIGHT);\n+    private JCheckBox chkShiftWindDir = new JCheckBox();\n+    private JLabel labShiftWindStr = new JLabel(Messages.getString(PCD + \"shiftWindStr\"), SwingConstants.RIGHT);\n+    private JCheckBox chkShiftWindStr = new JCheckBox();\n     private JTextField fldTemp = new JTextField(4);\n-    private JLabel labTemp = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labTemp\"), SwingConstants.RIGHT); //$NON-NLS-1$\n+    private JLabel labTemp = new TipLabel(Messages.getString(PCD + \"labTemp\"), SwingConstants.RIGHT, this); \n     private JTextField fldGrav = new JTextField(4);\n-    private JLabel labGrav = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labGrav\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JCheckBox cEMI = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.EMI\"));\n-    private JCheckBox cTerrainAffected = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.TerrainAffected\"));\n+    private JLabel labGrav = new TipLabel(Messages.getString(PCD + \"labGrav\"), SwingConstants.RIGHT, this);\n+    private JLabel labEMI = new JLabel(Messages.getString(PCD + \"EMI\"), SwingConstants.RIGHT);\n+    private JCheckBox chkEMI = new JCheckBox();\n+    private JLabel labTerrainAffected = new JLabel(Messages.getString(PCD + \"TerrainAffected\"), SwingConstants.RIGHT);\n+    private JCheckBox chkTerrainAffected = new JCheckBox();\n \n-    private JPanel panButtons = new JPanel();\n-    private JButton butOkay = new JButton(Messages.getString(\"Okay\")); //$NON-NLS-1$\n-    private JButton butCancel = new JButton(Messages.getString(\"Cancel\")); //$NON-NLS-1$\n+    private JButton butOkay = new DialogButton(Messages.getString(\"Okay\")); \n+    private JButton butCancel = new DialogButton(Messages.getString(\"Cancel\")); \n \n-    private JPanel panOptions = new JPanel();\n-\n-    /**\n-     * Initialize this dialog.\n-     *\n-     * @param frame\n-     *            - the <code>Frame</code> parent of this dialog.\n-     * @param planetConditions\n-     */\n-    private void init(JFrame frame, PlanetaryConditions planetConditions) {\n-        conditions = (PlanetaryConditions) planetConditions.clone();\n-        this.frame = frame;\n-\n-        setupConditions();\n-        setupButtons();\n-\n-        // layout\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        setLayout(gridbag);\n-\n-        c.insets = new Insets(4, 4, 4, 4);\n-        c.weightx = 1.0;\n-        c.weighty = 1.0;\n-        c.fill = GridBagConstraints.BOTH;\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        gridbag.setConstraints(panOptions, c);\n-        add(panOptions);\n-\n-        c.weightx = 1.0;\n-        c.weighty = 0.0;\n-\n-        gridbag.setConstraints(panButtons, c);\n-        add(panButtons);\n-\n-        addWindowListener(new WindowAdapter() {\n-            @Override\n-            public void windowClosing(WindowEvent e) {\n-                setVisible(false);\n-            }\n-        });\n-\n-        choWeather.addActionListener(e -> {\n-            int weather = choWeather.getSelectedIndex();\n-            if (currentWeather != weather && \n-                    (weather == PlanetaryConditions.WE_LIGHT_HAIL ||\n-                     weather == PlanetaryConditions.WE_HEAVY_HAIL ||\n-                     weather == PlanetaryConditions.WE_LIGHT_SNOW || \n-                     weather == PlanetaryConditions.WE_SLEET ||\n-                     weather == PlanetaryConditions.WE_SNOW_FLURRIES ||\n-                     weather == PlanetaryConditions.WE_HEAVY_SNOW ||\n-                     weather == PlanetaryConditions.WE_ICE_STORM || \n-                     weather == PlanetaryConditions.WE_BLIZZARD ||\n-                     weather == PlanetaryConditions.WE_MOD_SNOW)) {\n-                currentWeather = weather;\n-                conditions.setRunOnce(false);                \n-                updateForm();\n-            }\n-        });\n-\n-        pack();\n-        setSize(getSize().width, Math.max(getSize().height, 400));\n-        setResizable(true);\n-        setLocation(frame.getLocation().x + frame.getSize().width / 2\n-                - getSize().width / 2, frame.getLocation().y\n-                + frame.getSize().height / 2 - getSize().height / 2);\n-\n-    }\n-\n-    /** Creates new PlanetaryConditionsDialog */\n-    public PlanetaryConditionsDialog(ClientGUI client) {\n-        super(client.frame, Messages\n-                .getString(\"PlanetaryConditionsDialog.title\"), true); //$NON-NLS-1$\n-        this.client = client;\n-        init(client.frame, client.getClient().getGame().getPlanetaryConditions());\n+    private boolean userResponse;\n+    \n+    private void setupDialog() {\n+        JPanel mainPanel = new JPanel();\n+        add(mainPanel, BorderLayout.CENTER);\n+        add(buttonPanel(), BorderLayout.PAGE_END);\n+        \n+        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n+        mainPanel.add(headerSection());\n+        mainPanel.add(generalSection());\n+        mainPanel.add(weatherSection());\n+        mainPanel.add(dynamicSection());\n+        mainPanel.add(Box.createVerticalGlue());\n+        \n+        setupCombos();\n     }\n-\n-    public PlanetaryConditionsDialog(JFrame frame, PlanetaryConditions conditions) {\n-        super(frame, Messages\n-                .getString(\"PlanetaryConditionsDialog.title\"), true); //$NON-NLS-1$\n-        init(frame, conditions);\n+    \n+    private JPanel headerSection() {\n+        JPanel result = new FixedYPanel();\n+        result.setAlignmentX(Component.LEFT_ALIGNMENT);\n+        File iconFile = new MegaMekFile(Configuration.widgetsDir(), \"Planetary.png\").getFile();\n+        Image image = ImageUtil.loadImageFromFile(iconFile.toString());\n+        Icon planetIcon = new ImageIcon(image.getScaledInstance(scaleForGUI(40), -1, Image.SCALE_SMOOTH));\n+        JLabel planetLabel = new JLabel(Messages.getString(\"PlanetaryConditionsDialog.title\"), \n+                planetIcon, SwingConstants.CENTER);\n+        planetLabel.setIconTextGap(scaleForGUI(12));\n+        planetLabel.setBorder(new EmptyBorder(15, 0, 10, 0));\n+        result.add(planetLabel);\n+        return result;\n     }\n \n-    private void setupButtons() {\n-        butOkay.addActionListener(this);\n-        butCancel.addActionListener(this);\n-\n-        // layout\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        panButtons.setLayout(gridbag);\n-\n-        c.insets = new Insets(1, 1, 1, 1);\n-        c.weightx = 1.0;\n-        c.weighty = 1.0;\n-        c.fill = GridBagConstraints.VERTICAL;\n-        c.ipadx = 20;\n-        c.ipady = 5;\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(butOkay, c);\n-        panButtons.add(butOkay);\n-\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(butCancel, c);\n-        panButtons.add(butCancel);\n+    private JPanel generalSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.general\");\n+        Content panContent = new Content(new GridLayout(6, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labTemp);\n+        panContent.add(fldTemp);\n+        panContent.add(labGrav);\n+        panContent.add(fldGrav);\n+        panContent.add(labLight);\n+        panContent.add(comLight);\n+        panContent.add(labAtmosphere);\n+        panContent.add(comAtmosphere);\n+        panContent.add(labEMI);\n+        panContent.add(chkEMI);\n+        panContent.add(labTerrainAffected);\n+        panContent.add(chkTerrainAffected);\n+        return result;\n     }\n-\n-    private void setupConditions() {\n-\n-        refreshConditions();\n-\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        panOptions.setLayout(gridbag);\n-\n-        c.fill = GridBagConstraints.BOTH;\n-        c.insets = new Insets(1, 1, 1, 1);\n-        c.weightx = 1.0;\n-        c.weighty = 0.0;\n-        \n-        addLabelControlPair(c, labTemp, fldTemp);\n-        addLabelControlPair(c, labGrav, fldGrav);\n-        addLabelControlPair(c, labLight, choLight);\n-        addLabelControlPair(c, labWeather, choWeather);\n-        addLabelControlPair(c, labWind, choWind);\n-        addLabelControlPair(c, labWindDirection, cboWindDirection);\n-        addLabelControlPair(c, labAtmosphere, choAtmosphere);\n-        addLabelControlPair(c, labFog, choFog);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cBlowingSands, c);\n-        panOptions.add(cBlowingSands);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cShiftWindDir, c);\n-        panOptions.add(cShiftWindDir);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cShiftWindStr, c);\n-        panOptions.add(cShiftWindStr);\n-\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(labMinWind, c);\n-        panOptions.add(labMinWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(choMinWind, c);\n-        panOptions.add(choMinWind);\n-\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(labMaxWind, c);\n-        panOptions.add(labMaxWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(choMaxWind, c);\n-        panOptions.add(choMaxWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cEMI, c);\n-        panOptions.add(cEMI);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cTerrainAffected, c);\n-        panOptions.add(cTerrainAffected);\n-\n+    \n+    private JPanel weatherSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.weather\");\n+        Content panContent = new Content(new GridLayout(5, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labWeather);\n+        panContent.add(comWeather);\n+        panContent.add(labWind);\n+        panContent.add(comWind);\n+        panContent.add(labWindDirection);\n+        panContent.add(comWindDirection);\n+        panContent.add(labFog);\n+        panContent.add(comFog);\n+        panContent.add(labBlowingSands);\n+        panContent.add(chkBlowingSands);\n+        return result;\n     }\n-\n-    /**\n-     * Worker method that adds a label - control pair to the UI (e.g. wind - wind dropdown)\n-     * @param c GridBagConstraints to use\n-     * @param label The label to add\n-     * @param valueControl The textbox or dropdown to add\n-     */\n-    private void addLabelControlPair(GridBagConstraints c, JLabel label, JComponent valueControl) {\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        panOptions.add(label, c);\n-        label.setLabelFor(valueControl);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        panOptions.add(valueControl, c);\n+    \n+    private JPanel dynamicSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.dynamic\");\n+        Content panContent = new Content(new GridLayout(4, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labShiftWindDir);\n+        panContent.add(chkShiftWindDir);\n+        panContent.add(labShiftWindStr);\n+        panContent.add(chkShiftWindStr);\n+        panContent.add(labMinWind);\n+        panContent.add(comWindFrom);\n+        panContent.add(labMaxWind);\n+        panContent.add(comWindTo);\n+        return result;\n     }\n     \n-    public void update(PlanetaryConditions planetConditions) {\n-        conditions = (PlanetaryConditions) planetConditions.clone();\n-        refreshConditions();\n+    private JPanel buttonPanel() {\n+        JPanel result = new JPanel(new FlowLayout());\n+        butOkay.addActionListener(listener);\n+        result.add(butOkay);\n+        result.add(new DialogButton(new CancelAction(this)));\n+        return result;\n     }\n-\n-    private void refreshConditions() {\n-\n-        choLight.removeAllItems();\n+    \n+    /** Fills the dialog comboboxes. */\n+    private void setupCombos() {\n         for (int i = 0; i < PlanetaryConditions.L_SIZE; i++) {\n-            choLight.addItem(PlanetaryConditions.getLightDisplayableName(i));\n+            comLight.addItem(PlanetaryConditions.getLightDisplayableName(i));\n         }\n-        choLight.setSelectedIndex(conditions.getLight());\n-\n-        choWeather.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.WE_SIZE; i++) {\n-            choWeather\n-                    .addItem(PlanetaryConditions.getWeatherDisplayableName(i));\n+            comWeather.addItem(PlanetaryConditions.getWeatherDisplayableName(i));\n         }\n-        choWeather.setSelectedIndex(conditions.getWeather());\n-        currentWeather = conditions.getWeather();\n-\n-        choWind.removeAllItems();\n-        choMinWind.removeAllItems();\n-        choMaxWind.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.WI_SIZE; i++) {\n-            choWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n-            choMinWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n-            choMaxWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWindFrom.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWindTo.addItem(PlanetaryConditions.getWindDisplayableName(i));\n         }\n-        choWind.setSelectedIndex(conditions.getWindStrength());\n-        choMinWind.setSelectedIndex(conditions.getMinWindStrength());\n-        choMaxWind.setSelectedIndex(conditions.getMaxWindStrength());\n-\n-        cboWindDirection.removeAllItems();\n         for(int i = 0; i < PlanetaryConditions.DIR_SIZE; i++) {\n-            cboWindDirection.addItem(PlanetaryConditions.getWindDirDisplayableName(i));\n+            comWindDirection.addItem(PlanetaryConditions.getWindDirDisplayableName(i));\n         }\n-        cboWindDirection.setSelectedIndex(conditions.getWindDirection());\n-\n-        choAtmosphere.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.ATMO_SIZE; i++) {\n-            choAtmosphere.addItem(PlanetaryConditions\n-                    .getAtmosphereDisplayableName(i));\n+            comAtmosphere.addItem(PlanetaryConditions.getAtmosphereDisplayableName(i));\n         }\n-        choAtmosphere.setSelectedIndex(conditions.getAtmosphere());\n-\n-        choFog.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.FOG_SIZE; i++) {\n-            choFog.addItem(PlanetaryConditions.getFogDisplayableName(i));\n+            comFog.addItem(PlanetaryConditions.getFogDisplayableName(i));\n         }\n-        choFog.setSelectedIndex(conditions.getFog());\n-\n-        cBlowingSands.setSelected(conditions.isSandBlowing());\n-\n-        cShiftWindDir.setSelected(conditions.shiftingWindDirection());\n-        cShiftWindStr.setSelected(conditions.shiftingWindStrength());\n+    }\n+    \n+    /** Adds all required listeners for the dialog fields. */\n+    private void addListeners() {\n+        comAtmosphere.addActionListener(listener);\n+        fldTemp.addFocusListener(focusListener);\n+        comLight.addActionListener(listener);\n+        comAtmosphere.addActionListener(listener);\n+        fldGrav.addFocusListener(focusListener);\n+        comWind.addActionListener(listener);\n+        comWeather.addActionListener(listener);\n+        comFog.addActionListener(listener);\n+        chkShiftWindStr.addActionListener(listener);\n+        chkBlowingSands.addActionListener(listener);\n+        comWindFrom.addActionListener(listener);\n+        comWindTo.addActionListener(listener);\n+    }\n+    \n+    /** Removes all listeners from the dialog fields. */\n+    private void removeListeners() {\n+        comAtmosphere.removeActionListener(listener);\n+        fldTemp.removeFocusListener(focusListener);\n+        comLight.removeActionListener(listener);\n+        comAtmosphere.removeActionListener(listener);\n+        fldGrav.removeFocusListener(focusListener);\n+        comWind.removeActionListener(listener);\n+        comWeather.removeActionListener(listener);\n+        comFog.removeActionListener(listener);\n+        chkShiftWindStr.removeActionListener(listener);\n+        chkBlowingSands.removeActionListener(listener);\n+        comWindFrom.removeActionListener(listener);\n+        comWindTo.removeActionListener(listener);\n+    }\n \n+    /** Updates the dialog fields with values from the stored conditions. */\n+    private void refreshValues() {\n+        removeListeners();\n+        comLight.setSelectedIndex(conditions.getLight());\n+        comWeather.setSelectedIndex(conditions.getWeather());\n+        comWind.setSelectedIndex(conditions.getWindStrength());\n+        comWindFrom.setSelectedIndex(conditions.getMinWindStrength());\n+        comWindTo.setSelectedIndex(conditions.getMaxWindStrength());\n+        comWindDirection.setSelectedIndex(conditions.getWindDirection());\n+        comAtmosphere.setSelectedIndex(conditions.getAtmosphere());\n+        comFog.setSelectedIndex(conditions.getFog());\n+        chkBlowingSands.setSelected(conditions.isSandBlowing());\n+        chkShiftWindDir.setSelected(conditions.shiftingWindDirection());\n+        chkShiftWindStr.setSelected(conditions.shiftingWindStrength());\n         fldTemp.setText(Integer.toString(conditions.getTemperature()));\n         fldGrav.setText(Float.toString(conditions.getGravity()));\n-\n-        cEMI.setSelected(conditions.hasEMI());\n-\n-        cTerrainAffected.setSelected(conditions.isTerrainAffected());\n-\n+        chkEMI.setSelected(conditions.hasEMI());\n+        chkTerrainAffected.setSelected(conditions.isTerrainAffected());\n+        addListeners();\n+        refreshWindShift();\n     }\n \n+    /** \n+     * Updates the stored conditions from the dialog fields. \n+     */\n     private void setConditions() {\n-            setConditions(true);\n-    }\n-\n-    private void setConditions(boolean shouldSendToServer) {\n         // make the changes to the planetary conditions\n-        conditions.setLight(choLight.getSelectedIndex());\n-        conditions.setWeather(choWeather.getSelectedIndex());\n-        conditions.setWindStrength(choWind.getSelectedIndex());\n-        conditions.setWindDirection(cboWindDirection.getSelectedIndex());\n-        conditions.setMinWindStrength(choMinWind.getSelectedIndex());\n-        conditions.setMaxWindStrength(choMaxWind.getSelectedIndex());\n-        conditions.setAtmosphere(choAtmosphere.getSelectedIndex());\n-        conditions.setFog(choFog.getSelectedIndex());\n-        conditions.setBlowingSand(cBlowingSands.isSelected());\n-        conditions.setShiftingWindDirection(cShiftWindDir.isSelected());\n-        conditions.setShiftingWindStrength(cShiftWindStr.isSelected());\n+        conditions.setLight(comLight.getSelectedIndex());\n+        conditions.setWeather(comWeather.getSelectedIndex());\n+        conditions.setWindStrength(comWind.getSelectedIndex());\n+        conditions.setWindDirection(comWindDirection.getSelectedIndex());\n+        refreshWindRange();\n+        conditions.setAtmosphere(comAtmosphere.getSelectedIndex());\n+        conditions.setFog(comFog.getSelectedIndex());\n+        conditions.setBlowingSand(chkBlowingSands.isSelected());\n+        conditions.setShiftingWindDirection(chkShiftWindDir.isSelected());\n+        conditions.setShiftingWindStrength(chkShiftWindStr.isSelected());\n         conditions.setTemperature(Integer.parseInt(fldTemp.getText()));\n         conditions.setGravity(Float.parseFloat(fldGrav.getText()));\n-        conditions.setEMI(cEMI.isSelected());\n-        conditions.setTerrainAffected(cTerrainAffected.isSelected());\n-\n-        if (client != null && shouldSendToServer) {\n-            send();\n-        }\n-    }\n-\n-    private void updateForm() {\n-        if (!validateForm()) {\n-            return;\n-        }\n-\n-        setConditions(false);\n-        conditions.alterConditions(conditions);\n-        refreshConditions();\n+        conditions.setEMI(chkEMI.isSelected());\n+        conditions.setTerrainAffected(chkTerrainAffected.isSelected());\n     }\n \n-    private void send() {\n-        client.getClient().sendPlanetaryConditions(conditions);\n-    }\n-\n-    private boolean validateForm() {\n-        // check for reasonable values and some conditionals\n-        int temper = 25;\n+    /** \n+     * Validates the current entries in the dialog. Any conflicting entries are marked\n+     * and a helper tooltip attached. Does not change entries.\n+     */\n+    private boolean validateEntries() {\n+        StringBuilder tempTip = new StringBuilder();\n+        StringBuilder wthrTip = new StringBuilder();\n+        StringBuilder gravTip = new StringBuilder();\n+        StringBuilder windTip = new StringBuilder();\n+        StringBuilder atmoTip = new StringBuilder();\n+        StringBuilder sandTip = new StringBuilder();\n+        int weather = comWeather.getSelectedIndex();\n+        int temp = 0;\n         float grav = (float) 1.0;\n         try {\n-            temper = Integer.parseInt(fldTemp.getText());\n+            temp = Integer.parseInt(fldTemp.getText());\n         } catch (NumberFormatException er) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidTemperature\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.integer\"));\n         }\n+        if ((temp > 200) || (temp < -200)) {\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.tempRange\"));\n+        }\n+        \n+        // Currently, MM does not automatically include the effects of -40, -50 or -60 \u00b0C\n+        // with snowy weather and instead relies on the temperature itself being set correctly.\n+        // I believe that the rules allow a temp of e.g. -5 \u00b0C with snow (and why not?) and\n+        // that the \"includes the effects\" statements are meant to reduce repetition. If the temp\n+        // were fixed to -40 \u00b0C, the text of the rules saying \"cannot be used with temp of 30 \u00b0C \n+        // or more\" would be unnecessary. With the current rules handling, temp has to be set to \n+        // the necessary values. Therefore the following check for 30 \u00b0C is not needed.\n+        //        if (temp >= 30 && requiresLowTemp(weather)) {\n+        //            tempValid = false;\n+        //            wthrValid = false;\n+        //            tempTip.append(\"The Temperature cannot be 30 \u00b0C or more in snowy weather.<BR>\");", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMzIxMw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611323213", "bodyText": "How about vacuum and wind?", "author": "NickAragua", "createdAt": "2021-04-12T04:42:52Z", "path": "megamek/src/megamek/client/ui/swing/PlanetaryConditionsDialog.java", "diffHunk": "@@ -20,544 +20,618 @@\n \n package megamek.client.ui.swing;\n \n-import java.awt.GridBagConstraints;\n-import java.awt.GridBagLayout;\n-import java.awt.Insets;\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.FlowLayout;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n-import java.awt.event.WindowAdapter;\n-import java.awt.event.WindowEvent;\n-\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.io.File;\n+\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n import javax.swing.JButton;\n import javax.swing.JCheckBox;\n import javax.swing.JComboBox;\n-import javax.swing.JComponent;\n-import javax.swing.JDialog;\n import javax.swing.JFrame;\n import javax.swing.JLabel;\n-import javax.swing.JOptionPane;\n import javax.swing.JPanel;\n import javax.swing.JTextField;\n import javax.swing.SwingConstants;\n+import javax.swing.border.EmptyBorder;\n \n import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.common.Configuration;\n import megamek.common.PlanetaryConditions;\n+import megamek.common.util.ImageUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+import static megamek.common.PlanetaryConditions.*;\n \n /**\n  * A dialog that allows for customization of planetary conditions\n  *\n  * @author Jay Lawson\n+ * @author Simon\n  * @version\n  */\n-public class PlanetaryConditionsDialog extends JDialog implements\n-        ActionListener {\n+public class PlanetaryConditionsDialog extends ClientDialog {\n \n     private static final long serialVersionUID = -4426594323169113468L;\n+    \n+    /** Creates new PlanetaryConditionsDialog and takes the conditions from the client's Game. */\n+    public PlanetaryConditionsDialog(ClientGUI cl) {\n+        super(cl.frame, Messages.getString(\"PlanetaryConditionsDialog.title\"), true, true);\n+        client = cl;\n+        setupDialog();\n+        update(client.getClient().getGame().getPlanetaryConditions());\n+    }\n+    \n+    /** Creates new PlanetaryConditionsDialog and sets the given conditions. Used for scenarios. */\n+    public PlanetaryConditionsDialog(JFrame frame, PlanetaryConditions conditions) {\n+        super(frame, Messages.getString(\"PlanetaryConditionsDialog.title\"), true, true);\n+        setupDialog();\n+        update(conditions);\n+    }\n+    \n+    /** Sets the dialog visible and returns true if the user pressed the Okay button. */\n+    public boolean showDialog() {\n+        userResponse = false;\n+        setVisible(true);\n+        return userResponse;\n+    }\n \n-    private ClientGUI client;\n-    private JFrame frame;\n-    private PlanetaryConditions conditions;\n-    private int currentWeather;\n+    /** Returns the conditions chosen by the player. */\n     public PlanetaryConditions getConditions() {\n+        setConditions();\n         return conditions;\n     }\n+    \n+    /** Stores the given conditions and updates the dialog fields. */\n+    public void update(PlanetaryConditions planetConditions) {\n+        conditions = (PlanetaryConditions) planetConditions.clone();\n+        refreshValues();\n+        adaptToWeatherAtmo();\n+    }\n+    \n+    // PRIVATE\n \n-    private JLabel labLight = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labLight\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choLight = new JComboBox<String>();\n-    private JLabel labWeather = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWeather\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choWeather = new JComboBox<String>();\n-    private JLabel labWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choWind = new JComboBox<String>();\n-    private JLabel labMinWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labMinWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choMinWind = new JComboBox<String>();\n-    private JLabel labMaxWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labMaxWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> cboWindDirection = new JComboBox<>();\n-    private JLabel labWindDirection = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWindDirection\"), SwingConstants.RIGHT);\n-    private JComboBox<String> choMaxWind = new JComboBox<String>();\n-    private JLabel labAtmosphere = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labAtmosphere\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choFog = new JComboBox<String>();\n-    private JLabel labFog = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labFog\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choAtmosphere = new JComboBox<String>();\n-    private JCheckBox cBlowingSands = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.BlowingSands\"));\n-    private JCheckBox cShiftWindDir = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.shiftWindDir\"));\n-    private JCheckBox cShiftWindStr = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.shiftWindStr\"));\n+    private ClientGUI client;\n+    private PlanetaryConditions conditions;\n+    \n+    private static final int TOOLTIP_WIDTH = 300;\n+    private static final String PCD = \"PlanetaryConditionsDialog.\";\n+    private JLabel labLight = new JLabel(Messages.getString(PCD + \"labLight\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comLight = new JComboBox<String>();\n+    private JLabel labWeather = new TipLabel(Messages.getString(PCD + \"labWeather\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comWeather = new JComboBox<String>();\n+    private JLabel labWind = new TipLabel(Messages.getString(PCD + \"labWind\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comWind = new JComboBox<String>();\n+    private JLabel labMinWind = new JLabel(Messages.getString(PCD + \"labMinWind\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comWindFrom = new JComboBox<String>();\n+    private JLabel labMaxWind = new JLabel(Messages.getString(PCD + \"labMaxWind\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comWindDirection = new JComboBox<>();\n+    private JLabel labWindDirection = new JLabel(Messages.getString(PCD + \"labWindDirection\"), SwingConstants.RIGHT);\n+    private JComboBox<String> comWindTo = new JComboBox<String>();\n+    private JLabel labAtmosphere = new TipLabel(Messages.getString(PCD + \"labAtmosphere\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comFog = new JComboBox<String>();\n+    private JLabel labFog = new TipLabel(Messages.getString(PCD + \"labFog\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comAtmosphere = new JComboBox<String>();\n+    private JLabel labBlowingSands = new TipLabel(Messages.getString(PCD + \"BlowingSands\"), SwingConstants.RIGHT, this);\n+    private JCheckBox chkBlowingSands = new JCheckBox();\n+    private JLabel labShiftWindDir = new JLabel(Messages.getString(PCD + \"shiftWindDir\"), SwingConstants.RIGHT);\n+    private JCheckBox chkShiftWindDir = new JCheckBox();\n+    private JLabel labShiftWindStr = new JLabel(Messages.getString(PCD + \"shiftWindStr\"), SwingConstants.RIGHT);\n+    private JCheckBox chkShiftWindStr = new JCheckBox();\n     private JTextField fldTemp = new JTextField(4);\n-    private JLabel labTemp = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labTemp\"), SwingConstants.RIGHT); //$NON-NLS-1$\n+    private JLabel labTemp = new TipLabel(Messages.getString(PCD + \"labTemp\"), SwingConstants.RIGHT, this); \n     private JTextField fldGrav = new JTextField(4);\n-    private JLabel labGrav = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labGrav\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JCheckBox cEMI = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.EMI\"));\n-    private JCheckBox cTerrainAffected = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.TerrainAffected\"));\n+    private JLabel labGrav = new TipLabel(Messages.getString(PCD + \"labGrav\"), SwingConstants.RIGHT, this);\n+    private JLabel labEMI = new JLabel(Messages.getString(PCD + \"EMI\"), SwingConstants.RIGHT);\n+    private JCheckBox chkEMI = new JCheckBox();\n+    private JLabel labTerrainAffected = new JLabel(Messages.getString(PCD + \"TerrainAffected\"), SwingConstants.RIGHT);\n+    private JCheckBox chkTerrainAffected = new JCheckBox();\n \n-    private JPanel panButtons = new JPanel();\n-    private JButton butOkay = new JButton(Messages.getString(\"Okay\")); //$NON-NLS-1$\n-    private JButton butCancel = new JButton(Messages.getString(\"Cancel\")); //$NON-NLS-1$\n+    private JButton butOkay = new DialogButton(Messages.getString(\"Okay\")); \n+    private JButton butCancel = new DialogButton(Messages.getString(\"Cancel\")); \n \n-    private JPanel panOptions = new JPanel();\n-\n-    /**\n-     * Initialize this dialog.\n-     *\n-     * @param frame\n-     *            - the <code>Frame</code> parent of this dialog.\n-     * @param planetConditions\n-     */\n-    private void init(JFrame frame, PlanetaryConditions planetConditions) {\n-        conditions = (PlanetaryConditions) planetConditions.clone();\n-        this.frame = frame;\n-\n-        setupConditions();\n-        setupButtons();\n-\n-        // layout\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        setLayout(gridbag);\n-\n-        c.insets = new Insets(4, 4, 4, 4);\n-        c.weightx = 1.0;\n-        c.weighty = 1.0;\n-        c.fill = GridBagConstraints.BOTH;\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        gridbag.setConstraints(panOptions, c);\n-        add(panOptions);\n-\n-        c.weightx = 1.0;\n-        c.weighty = 0.0;\n-\n-        gridbag.setConstraints(panButtons, c);\n-        add(panButtons);\n-\n-        addWindowListener(new WindowAdapter() {\n-            @Override\n-            public void windowClosing(WindowEvent e) {\n-                setVisible(false);\n-            }\n-        });\n-\n-        choWeather.addActionListener(e -> {\n-            int weather = choWeather.getSelectedIndex();\n-            if (currentWeather != weather && \n-                    (weather == PlanetaryConditions.WE_LIGHT_HAIL ||\n-                     weather == PlanetaryConditions.WE_HEAVY_HAIL ||\n-                     weather == PlanetaryConditions.WE_LIGHT_SNOW || \n-                     weather == PlanetaryConditions.WE_SLEET ||\n-                     weather == PlanetaryConditions.WE_SNOW_FLURRIES ||\n-                     weather == PlanetaryConditions.WE_HEAVY_SNOW ||\n-                     weather == PlanetaryConditions.WE_ICE_STORM || \n-                     weather == PlanetaryConditions.WE_BLIZZARD ||\n-                     weather == PlanetaryConditions.WE_MOD_SNOW)) {\n-                currentWeather = weather;\n-                conditions.setRunOnce(false);                \n-                updateForm();\n-            }\n-        });\n-\n-        pack();\n-        setSize(getSize().width, Math.max(getSize().height, 400));\n-        setResizable(true);\n-        setLocation(frame.getLocation().x + frame.getSize().width / 2\n-                - getSize().width / 2, frame.getLocation().y\n-                + frame.getSize().height / 2 - getSize().height / 2);\n-\n-    }\n-\n-    /** Creates new PlanetaryConditionsDialog */\n-    public PlanetaryConditionsDialog(ClientGUI client) {\n-        super(client.frame, Messages\n-                .getString(\"PlanetaryConditionsDialog.title\"), true); //$NON-NLS-1$\n-        this.client = client;\n-        init(client.frame, client.getClient().getGame().getPlanetaryConditions());\n+    private boolean userResponse;\n+    \n+    private void setupDialog() {\n+        JPanel mainPanel = new JPanel();\n+        add(mainPanel, BorderLayout.CENTER);\n+        add(buttonPanel(), BorderLayout.PAGE_END);\n+        \n+        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n+        mainPanel.add(headerSection());\n+        mainPanel.add(generalSection());\n+        mainPanel.add(weatherSection());\n+        mainPanel.add(dynamicSection());\n+        mainPanel.add(Box.createVerticalGlue());\n+        \n+        setupCombos();\n     }\n-\n-    public PlanetaryConditionsDialog(JFrame frame, PlanetaryConditions conditions) {\n-        super(frame, Messages\n-                .getString(\"PlanetaryConditionsDialog.title\"), true); //$NON-NLS-1$\n-        init(frame, conditions);\n+    \n+    private JPanel headerSection() {\n+        JPanel result = new FixedYPanel();\n+        result.setAlignmentX(Component.LEFT_ALIGNMENT);\n+        File iconFile = new MegaMekFile(Configuration.widgetsDir(), \"Planetary.png\").getFile();\n+        Image image = ImageUtil.loadImageFromFile(iconFile.toString());\n+        Icon planetIcon = new ImageIcon(image.getScaledInstance(scaleForGUI(40), -1, Image.SCALE_SMOOTH));\n+        JLabel planetLabel = new JLabel(Messages.getString(\"PlanetaryConditionsDialog.title\"), \n+                planetIcon, SwingConstants.CENTER);\n+        planetLabel.setIconTextGap(scaleForGUI(12));\n+        planetLabel.setBorder(new EmptyBorder(15, 0, 10, 0));\n+        result.add(planetLabel);\n+        return result;\n     }\n \n-    private void setupButtons() {\n-        butOkay.addActionListener(this);\n-        butCancel.addActionListener(this);\n-\n-        // layout\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        panButtons.setLayout(gridbag);\n-\n-        c.insets = new Insets(1, 1, 1, 1);\n-        c.weightx = 1.0;\n-        c.weighty = 1.0;\n-        c.fill = GridBagConstraints.VERTICAL;\n-        c.ipadx = 20;\n-        c.ipady = 5;\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(butOkay, c);\n-        panButtons.add(butOkay);\n-\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(butCancel, c);\n-        panButtons.add(butCancel);\n+    private JPanel generalSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.general\");\n+        Content panContent = new Content(new GridLayout(6, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labTemp);\n+        panContent.add(fldTemp);\n+        panContent.add(labGrav);\n+        panContent.add(fldGrav);\n+        panContent.add(labLight);\n+        panContent.add(comLight);\n+        panContent.add(labAtmosphere);\n+        panContent.add(comAtmosphere);\n+        panContent.add(labEMI);\n+        panContent.add(chkEMI);\n+        panContent.add(labTerrainAffected);\n+        panContent.add(chkTerrainAffected);\n+        return result;\n     }\n-\n-    private void setupConditions() {\n-\n-        refreshConditions();\n-\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        panOptions.setLayout(gridbag);\n-\n-        c.fill = GridBagConstraints.BOTH;\n-        c.insets = new Insets(1, 1, 1, 1);\n-        c.weightx = 1.0;\n-        c.weighty = 0.0;\n-        \n-        addLabelControlPair(c, labTemp, fldTemp);\n-        addLabelControlPair(c, labGrav, fldGrav);\n-        addLabelControlPair(c, labLight, choLight);\n-        addLabelControlPair(c, labWeather, choWeather);\n-        addLabelControlPair(c, labWind, choWind);\n-        addLabelControlPair(c, labWindDirection, cboWindDirection);\n-        addLabelControlPair(c, labAtmosphere, choAtmosphere);\n-        addLabelControlPair(c, labFog, choFog);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cBlowingSands, c);\n-        panOptions.add(cBlowingSands);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cShiftWindDir, c);\n-        panOptions.add(cShiftWindDir);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cShiftWindStr, c);\n-        panOptions.add(cShiftWindStr);\n-\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(labMinWind, c);\n-        panOptions.add(labMinWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(choMinWind, c);\n-        panOptions.add(choMinWind);\n-\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(labMaxWind, c);\n-        panOptions.add(labMaxWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(choMaxWind, c);\n-        panOptions.add(choMaxWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cEMI, c);\n-        panOptions.add(cEMI);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cTerrainAffected, c);\n-        panOptions.add(cTerrainAffected);\n-\n+    \n+    private JPanel weatherSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.weather\");\n+        Content panContent = new Content(new GridLayout(5, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labWeather);\n+        panContent.add(comWeather);\n+        panContent.add(labWind);\n+        panContent.add(comWind);\n+        panContent.add(labWindDirection);\n+        panContent.add(comWindDirection);\n+        panContent.add(labFog);\n+        panContent.add(comFog);\n+        panContent.add(labBlowingSands);\n+        panContent.add(chkBlowingSands);\n+        return result;\n     }\n-\n-    /**\n-     * Worker method that adds a label - control pair to the UI (e.g. wind - wind dropdown)\n-     * @param c GridBagConstraints to use\n-     * @param label The label to add\n-     * @param valueControl The textbox or dropdown to add\n-     */\n-    private void addLabelControlPair(GridBagConstraints c, JLabel label, JComponent valueControl) {\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        panOptions.add(label, c);\n-        label.setLabelFor(valueControl);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        panOptions.add(valueControl, c);\n+    \n+    private JPanel dynamicSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.dynamic\");\n+        Content panContent = new Content(new GridLayout(4, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labShiftWindDir);\n+        panContent.add(chkShiftWindDir);\n+        panContent.add(labShiftWindStr);\n+        panContent.add(chkShiftWindStr);\n+        panContent.add(labMinWind);\n+        panContent.add(comWindFrom);\n+        panContent.add(labMaxWind);\n+        panContent.add(comWindTo);\n+        return result;\n     }\n     \n-    public void update(PlanetaryConditions planetConditions) {\n-        conditions = (PlanetaryConditions) planetConditions.clone();\n-        refreshConditions();\n+    private JPanel buttonPanel() {\n+        JPanel result = new JPanel(new FlowLayout());\n+        butOkay.addActionListener(listener);\n+        result.add(butOkay);\n+        result.add(new DialogButton(new CancelAction(this)));\n+        return result;\n     }\n-\n-    private void refreshConditions() {\n-\n-        choLight.removeAllItems();\n+    \n+    /** Fills the dialog comboboxes. */\n+    private void setupCombos() {\n         for (int i = 0; i < PlanetaryConditions.L_SIZE; i++) {\n-            choLight.addItem(PlanetaryConditions.getLightDisplayableName(i));\n+            comLight.addItem(PlanetaryConditions.getLightDisplayableName(i));\n         }\n-        choLight.setSelectedIndex(conditions.getLight());\n-\n-        choWeather.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.WE_SIZE; i++) {\n-            choWeather\n-                    .addItem(PlanetaryConditions.getWeatherDisplayableName(i));\n+            comWeather.addItem(PlanetaryConditions.getWeatherDisplayableName(i));\n         }\n-        choWeather.setSelectedIndex(conditions.getWeather());\n-        currentWeather = conditions.getWeather();\n-\n-        choWind.removeAllItems();\n-        choMinWind.removeAllItems();\n-        choMaxWind.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.WI_SIZE; i++) {\n-            choWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n-            choMinWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n-            choMaxWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWindFrom.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWindTo.addItem(PlanetaryConditions.getWindDisplayableName(i));\n         }\n-        choWind.setSelectedIndex(conditions.getWindStrength());\n-        choMinWind.setSelectedIndex(conditions.getMinWindStrength());\n-        choMaxWind.setSelectedIndex(conditions.getMaxWindStrength());\n-\n-        cboWindDirection.removeAllItems();\n         for(int i = 0; i < PlanetaryConditions.DIR_SIZE; i++) {\n-            cboWindDirection.addItem(PlanetaryConditions.getWindDirDisplayableName(i));\n+            comWindDirection.addItem(PlanetaryConditions.getWindDirDisplayableName(i));\n         }\n-        cboWindDirection.setSelectedIndex(conditions.getWindDirection());\n-\n-        choAtmosphere.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.ATMO_SIZE; i++) {\n-            choAtmosphere.addItem(PlanetaryConditions\n-                    .getAtmosphereDisplayableName(i));\n+            comAtmosphere.addItem(PlanetaryConditions.getAtmosphereDisplayableName(i));\n         }\n-        choAtmosphere.setSelectedIndex(conditions.getAtmosphere());\n-\n-        choFog.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.FOG_SIZE; i++) {\n-            choFog.addItem(PlanetaryConditions.getFogDisplayableName(i));\n+            comFog.addItem(PlanetaryConditions.getFogDisplayableName(i));\n         }\n-        choFog.setSelectedIndex(conditions.getFog());\n-\n-        cBlowingSands.setSelected(conditions.isSandBlowing());\n-\n-        cShiftWindDir.setSelected(conditions.shiftingWindDirection());\n-        cShiftWindStr.setSelected(conditions.shiftingWindStrength());\n+    }\n+    \n+    /** Adds all required listeners for the dialog fields. */\n+    private void addListeners() {\n+        comAtmosphere.addActionListener(listener);\n+        fldTemp.addFocusListener(focusListener);\n+        comLight.addActionListener(listener);\n+        comAtmosphere.addActionListener(listener);\n+        fldGrav.addFocusListener(focusListener);\n+        comWind.addActionListener(listener);\n+        comWeather.addActionListener(listener);\n+        comFog.addActionListener(listener);\n+        chkShiftWindStr.addActionListener(listener);\n+        chkBlowingSands.addActionListener(listener);\n+        comWindFrom.addActionListener(listener);\n+        comWindTo.addActionListener(listener);\n+    }\n+    \n+    /** Removes all listeners from the dialog fields. */\n+    private void removeListeners() {\n+        comAtmosphere.removeActionListener(listener);\n+        fldTemp.removeFocusListener(focusListener);\n+        comLight.removeActionListener(listener);\n+        comAtmosphere.removeActionListener(listener);\n+        fldGrav.removeFocusListener(focusListener);\n+        comWind.removeActionListener(listener);\n+        comWeather.removeActionListener(listener);\n+        comFog.removeActionListener(listener);\n+        chkShiftWindStr.removeActionListener(listener);\n+        chkBlowingSands.removeActionListener(listener);\n+        comWindFrom.removeActionListener(listener);\n+        comWindTo.removeActionListener(listener);\n+    }\n \n+    /** Updates the dialog fields with values from the stored conditions. */\n+    private void refreshValues() {\n+        removeListeners();\n+        comLight.setSelectedIndex(conditions.getLight());\n+        comWeather.setSelectedIndex(conditions.getWeather());\n+        comWind.setSelectedIndex(conditions.getWindStrength());\n+        comWindFrom.setSelectedIndex(conditions.getMinWindStrength());\n+        comWindTo.setSelectedIndex(conditions.getMaxWindStrength());\n+        comWindDirection.setSelectedIndex(conditions.getWindDirection());\n+        comAtmosphere.setSelectedIndex(conditions.getAtmosphere());\n+        comFog.setSelectedIndex(conditions.getFog());\n+        chkBlowingSands.setSelected(conditions.isSandBlowing());\n+        chkShiftWindDir.setSelected(conditions.shiftingWindDirection());\n+        chkShiftWindStr.setSelected(conditions.shiftingWindStrength());\n         fldTemp.setText(Integer.toString(conditions.getTemperature()));\n         fldGrav.setText(Float.toString(conditions.getGravity()));\n-\n-        cEMI.setSelected(conditions.hasEMI());\n-\n-        cTerrainAffected.setSelected(conditions.isTerrainAffected());\n-\n+        chkEMI.setSelected(conditions.hasEMI());\n+        chkTerrainAffected.setSelected(conditions.isTerrainAffected());\n+        addListeners();\n+        refreshWindShift();\n     }\n \n+    /** \n+     * Updates the stored conditions from the dialog fields. \n+     */\n     private void setConditions() {\n-            setConditions(true);\n-    }\n-\n-    private void setConditions(boolean shouldSendToServer) {\n         // make the changes to the planetary conditions\n-        conditions.setLight(choLight.getSelectedIndex());\n-        conditions.setWeather(choWeather.getSelectedIndex());\n-        conditions.setWindStrength(choWind.getSelectedIndex());\n-        conditions.setWindDirection(cboWindDirection.getSelectedIndex());\n-        conditions.setMinWindStrength(choMinWind.getSelectedIndex());\n-        conditions.setMaxWindStrength(choMaxWind.getSelectedIndex());\n-        conditions.setAtmosphere(choAtmosphere.getSelectedIndex());\n-        conditions.setFog(choFog.getSelectedIndex());\n-        conditions.setBlowingSand(cBlowingSands.isSelected());\n-        conditions.setShiftingWindDirection(cShiftWindDir.isSelected());\n-        conditions.setShiftingWindStrength(cShiftWindStr.isSelected());\n+        conditions.setLight(comLight.getSelectedIndex());\n+        conditions.setWeather(comWeather.getSelectedIndex());\n+        conditions.setWindStrength(comWind.getSelectedIndex());\n+        conditions.setWindDirection(comWindDirection.getSelectedIndex());\n+        refreshWindRange();\n+        conditions.setAtmosphere(comAtmosphere.getSelectedIndex());\n+        conditions.setFog(comFog.getSelectedIndex());\n+        conditions.setBlowingSand(chkBlowingSands.isSelected());\n+        conditions.setShiftingWindDirection(chkShiftWindDir.isSelected());\n+        conditions.setShiftingWindStrength(chkShiftWindStr.isSelected());\n         conditions.setTemperature(Integer.parseInt(fldTemp.getText()));\n         conditions.setGravity(Float.parseFloat(fldGrav.getText()));\n-        conditions.setEMI(cEMI.isSelected());\n-        conditions.setTerrainAffected(cTerrainAffected.isSelected());\n-\n-        if (client != null && shouldSendToServer) {\n-            send();\n-        }\n-    }\n-\n-    private void updateForm() {\n-        if (!validateForm()) {\n-            return;\n-        }\n-\n-        setConditions(false);\n-        conditions.alterConditions(conditions);\n-        refreshConditions();\n+        conditions.setEMI(chkEMI.isSelected());\n+        conditions.setTerrainAffected(chkTerrainAffected.isSelected());\n     }\n \n-    private void send() {\n-        client.getClient().sendPlanetaryConditions(conditions);\n-    }\n-\n-    private boolean validateForm() {\n-        // check for reasonable values and some conditionals\n-        int temper = 25;\n+    /** \n+     * Validates the current entries in the dialog. Any conflicting entries are marked\n+     * and a helper tooltip attached. Does not change entries.\n+     */\n+    private boolean validateEntries() {\n+        StringBuilder tempTip = new StringBuilder();\n+        StringBuilder wthrTip = new StringBuilder();\n+        StringBuilder gravTip = new StringBuilder();\n+        StringBuilder windTip = new StringBuilder();\n+        StringBuilder atmoTip = new StringBuilder();\n+        StringBuilder sandTip = new StringBuilder();\n+        int weather = comWeather.getSelectedIndex();\n+        int temp = 0;\n         float grav = (float) 1.0;\n         try {\n-            temper = Integer.parseInt(fldTemp.getText());\n+            temp = Integer.parseInt(fldTemp.getText());\n         } catch (NumberFormatException er) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidTemperature\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.integer\"));\n         }\n+        if ((temp > 200) || (temp < -200)) {\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.tempRange\"));\n+        }\n+        \n+        // Currently, MM does not automatically include the effects of -40, -50 or -60 \u00b0C\n+        // with snowy weather and instead relies on the temperature itself being set correctly.\n+        // I believe that the rules allow a temp of e.g. -5 \u00b0C with snow (and why not?) and\n+        // that the \"includes the effects\" statements are meant to reduce repetition. If the temp\n+        // were fixed to -40 \u00b0C, the text of the rules saying \"cannot be used with temp of 30 \u00b0C \n+        // or more\" would be unnecessary. With the current rules handling, temp has to be set to \n+        // the necessary values. Therefore the following check for 30 \u00b0C is not needed.\n+        //        if (temp >= 30 && requiresLowTemp(weather)) {\n+        //            tempValid = false;\n+        //            wthrValid = false;\n+        //            tempTip.append(\"The Temperature cannot be 30 \u00b0C or more in snowy weather.<BR>\");\n+        //            wthrTip.append(\"The Temperature cannot be 30 \u00b0C or more in snowy weather.<BR>\");\n+        //        }\n+        \n         try {\n             grav = Float.parseFloat(fldGrav.getText());\n         } catch (NumberFormatException er) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidGravity\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+            gravTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.number\"));\n         }\n-\n-        if ((temper > 200) || (temper < -200)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidTemperature\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+        if ((grav < 0.1) || (grav > 10.0)) {\n+            gravTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.gravRange\"));\n         }\n-\n-        int weather = currentWeather = choWeather.getSelectedIndex();\n-        if (temper >= 30 && (weather == PlanetaryConditions.WE_LIGHT_HAIL ||\n-                weather == PlanetaryConditions.WE_HEAVY_HAIL ||\n-                weather == PlanetaryConditions.WE_LIGHT_SNOW || \n-                weather == PlanetaryConditions.WE_SLEET ||\n-                weather == PlanetaryConditions.WE_SNOW_FLURRIES ||\n-                weather == PlanetaryConditions.WE_HEAVY_SNOW ||\n-                weather == PlanetaryConditions.WE_ICE_STORM || \n-                weather == PlanetaryConditions.WE_BLIZZARD ||\n-                weather == PlanetaryConditions.WE_MOD_SNOW)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                        frame, \n-                        Messages.getString(\"PlanetaryConditionsDialog.EnterValidTemperatureExtreme\"), \n-                        Messages.getString(\"PlanetaryConditionsDialog.NumberFormatError\"), \n-                        JOptionPane.ERROR_MESSAGE);\n-            return false;\n+        \n+        int wind = comWind.getSelectedIndex();\n+        int atmo = comAtmosphere.getSelectedIndex();\n+        \n+        if ((chkBlowingSands.isSelected()) && (wind < WI_MOD_GALE) \n+                && (!chkShiftWindStr.isSelected() \n+                        || (conditions.getMinWindStrength() > WI_MOD_GALE) \n+                        || (conditions.getMaxWindStrength() < WI_MOD_GALE))) {\n+            windTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.sandsLost\"));\n+            sandTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.sandsLost\"));\n         }\n \n-        if ((grav < 0.1) || (grav > 10.0)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidGravity\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+        if ((atmo == ATMO_TRACE) && (wind == WI_LIGHT_GALE)) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDc5Mjg3Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614792873", "bodyText": "Vacuum disables all weather settings, so it doesnt need to be checked there. But it was not actually resetting the weather. Will be corrected.", "author": "SJuliez", "createdAt": "2021-04-16T12:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMzIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMzQ5Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611323496", "bodyText": "Also, for some weather settings what?", "author": "NickAragua", "createdAt": "2021-04-12T04:44:03Z", "path": "megamek/src/megamek/client/ui/swing/PlanetaryConditionsDialog.java", "diffHunk": "@@ -20,544 +20,618 @@\n \n package megamek.client.ui.swing;\n \n-import java.awt.GridBagConstraints;\n-import java.awt.GridBagLayout;\n-import java.awt.Insets;\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.FlowLayout;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n-import java.awt.event.WindowAdapter;\n-import java.awt.event.WindowEvent;\n-\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.io.File;\n+\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n import javax.swing.JButton;\n import javax.swing.JCheckBox;\n import javax.swing.JComboBox;\n-import javax.swing.JComponent;\n-import javax.swing.JDialog;\n import javax.swing.JFrame;\n import javax.swing.JLabel;\n-import javax.swing.JOptionPane;\n import javax.swing.JPanel;\n import javax.swing.JTextField;\n import javax.swing.SwingConstants;\n+import javax.swing.border.EmptyBorder;\n \n import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.common.Configuration;\n import megamek.common.PlanetaryConditions;\n+import megamek.common.util.ImageUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+import static megamek.common.PlanetaryConditions.*;\n \n /**\n  * A dialog that allows for customization of planetary conditions\n  *\n  * @author Jay Lawson\n+ * @author Simon\n  * @version\n  */\n-public class PlanetaryConditionsDialog extends JDialog implements\n-        ActionListener {\n+public class PlanetaryConditionsDialog extends ClientDialog {\n \n     private static final long serialVersionUID = -4426594323169113468L;\n+    \n+    /** Creates new PlanetaryConditionsDialog and takes the conditions from the client's Game. */\n+    public PlanetaryConditionsDialog(ClientGUI cl) {\n+        super(cl.frame, Messages.getString(\"PlanetaryConditionsDialog.title\"), true, true);\n+        client = cl;\n+        setupDialog();\n+        update(client.getClient().getGame().getPlanetaryConditions());\n+    }\n+    \n+    /** Creates new PlanetaryConditionsDialog and sets the given conditions. Used for scenarios. */\n+    public PlanetaryConditionsDialog(JFrame frame, PlanetaryConditions conditions) {\n+        super(frame, Messages.getString(\"PlanetaryConditionsDialog.title\"), true, true);\n+        setupDialog();\n+        update(conditions);\n+    }\n+    \n+    /** Sets the dialog visible and returns true if the user pressed the Okay button. */\n+    public boolean showDialog() {\n+        userResponse = false;\n+        setVisible(true);\n+        return userResponse;\n+    }\n \n-    private ClientGUI client;\n-    private JFrame frame;\n-    private PlanetaryConditions conditions;\n-    private int currentWeather;\n+    /** Returns the conditions chosen by the player. */\n     public PlanetaryConditions getConditions() {\n+        setConditions();\n         return conditions;\n     }\n+    \n+    /** Stores the given conditions and updates the dialog fields. */\n+    public void update(PlanetaryConditions planetConditions) {\n+        conditions = (PlanetaryConditions) planetConditions.clone();\n+        refreshValues();\n+        adaptToWeatherAtmo();\n+    }\n+    \n+    // PRIVATE\n \n-    private JLabel labLight = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labLight\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choLight = new JComboBox<String>();\n-    private JLabel labWeather = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWeather\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choWeather = new JComboBox<String>();\n-    private JLabel labWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choWind = new JComboBox<String>();\n-    private JLabel labMinWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labMinWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choMinWind = new JComboBox<String>();\n-    private JLabel labMaxWind = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labMaxWind\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> cboWindDirection = new JComboBox<>();\n-    private JLabel labWindDirection = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labWindDirection\"), SwingConstants.RIGHT);\n-    private JComboBox<String> choMaxWind = new JComboBox<String>();\n-    private JLabel labAtmosphere = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labAtmosphere\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choFog = new JComboBox<String>();\n-    private JLabel labFog = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labFog\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JComboBox<String> choAtmosphere = new JComboBox<String>();\n-    private JCheckBox cBlowingSands = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.BlowingSands\"));\n-    private JCheckBox cShiftWindDir = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.shiftWindDir\"));\n-    private JCheckBox cShiftWindStr = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.shiftWindStr\"));\n+    private ClientGUI client;\n+    private PlanetaryConditions conditions;\n+    \n+    private static final int TOOLTIP_WIDTH = 300;\n+    private static final String PCD = \"PlanetaryConditionsDialog.\";\n+    private JLabel labLight = new JLabel(Messages.getString(PCD + \"labLight\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comLight = new JComboBox<String>();\n+    private JLabel labWeather = new TipLabel(Messages.getString(PCD + \"labWeather\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comWeather = new JComboBox<String>();\n+    private JLabel labWind = new TipLabel(Messages.getString(PCD + \"labWind\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comWind = new JComboBox<String>();\n+    private JLabel labMinWind = new JLabel(Messages.getString(PCD + \"labMinWind\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comWindFrom = new JComboBox<String>();\n+    private JLabel labMaxWind = new JLabel(Messages.getString(PCD + \"labMaxWind\"), SwingConstants.RIGHT); \n+    private JComboBox<String> comWindDirection = new JComboBox<>();\n+    private JLabel labWindDirection = new JLabel(Messages.getString(PCD + \"labWindDirection\"), SwingConstants.RIGHT);\n+    private JComboBox<String> comWindTo = new JComboBox<String>();\n+    private JLabel labAtmosphere = new TipLabel(Messages.getString(PCD + \"labAtmosphere\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comFog = new JComboBox<String>();\n+    private JLabel labFog = new TipLabel(Messages.getString(PCD + \"labFog\"), SwingConstants.RIGHT, this); \n+    private JComboBox<String> comAtmosphere = new JComboBox<String>();\n+    private JLabel labBlowingSands = new TipLabel(Messages.getString(PCD + \"BlowingSands\"), SwingConstants.RIGHT, this);\n+    private JCheckBox chkBlowingSands = new JCheckBox();\n+    private JLabel labShiftWindDir = new JLabel(Messages.getString(PCD + \"shiftWindDir\"), SwingConstants.RIGHT);\n+    private JCheckBox chkShiftWindDir = new JCheckBox();\n+    private JLabel labShiftWindStr = new JLabel(Messages.getString(PCD + \"shiftWindStr\"), SwingConstants.RIGHT);\n+    private JCheckBox chkShiftWindStr = new JCheckBox();\n     private JTextField fldTemp = new JTextField(4);\n-    private JLabel labTemp = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labTemp\"), SwingConstants.RIGHT); //$NON-NLS-1$\n+    private JLabel labTemp = new TipLabel(Messages.getString(PCD + \"labTemp\"), SwingConstants.RIGHT, this); \n     private JTextField fldGrav = new JTextField(4);\n-    private JLabel labGrav = new JLabel(\n-            Messages.getString(\"PlanetaryConditionsDialog.labGrav\"), SwingConstants.RIGHT); //$NON-NLS-1$\n-    private JCheckBox cEMI = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.EMI\"));\n-    private JCheckBox cTerrainAffected = new JCheckBox(Messages\n-            .getString(\"PlanetaryConditionsDialog.TerrainAffected\"));\n+    private JLabel labGrav = new TipLabel(Messages.getString(PCD + \"labGrav\"), SwingConstants.RIGHT, this);\n+    private JLabel labEMI = new JLabel(Messages.getString(PCD + \"EMI\"), SwingConstants.RIGHT);\n+    private JCheckBox chkEMI = new JCheckBox();\n+    private JLabel labTerrainAffected = new JLabel(Messages.getString(PCD + \"TerrainAffected\"), SwingConstants.RIGHT);\n+    private JCheckBox chkTerrainAffected = new JCheckBox();\n \n-    private JPanel panButtons = new JPanel();\n-    private JButton butOkay = new JButton(Messages.getString(\"Okay\")); //$NON-NLS-1$\n-    private JButton butCancel = new JButton(Messages.getString(\"Cancel\")); //$NON-NLS-1$\n+    private JButton butOkay = new DialogButton(Messages.getString(\"Okay\")); \n+    private JButton butCancel = new DialogButton(Messages.getString(\"Cancel\")); \n \n-    private JPanel panOptions = new JPanel();\n-\n-    /**\n-     * Initialize this dialog.\n-     *\n-     * @param frame\n-     *            - the <code>Frame</code> parent of this dialog.\n-     * @param planetConditions\n-     */\n-    private void init(JFrame frame, PlanetaryConditions planetConditions) {\n-        conditions = (PlanetaryConditions) planetConditions.clone();\n-        this.frame = frame;\n-\n-        setupConditions();\n-        setupButtons();\n-\n-        // layout\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        setLayout(gridbag);\n-\n-        c.insets = new Insets(4, 4, 4, 4);\n-        c.weightx = 1.0;\n-        c.weighty = 1.0;\n-        c.fill = GridBagConstraints.BOTH;\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        gridbag.setConstraints(panOptions, c);\n-        add(panOptions);\n-\n-        c.weightx = 1.0;\n-        c.weighty = 0.0;\n-\n-        gridbag.setConstraints(panButtons, c);\n-        add(panButtons);\n-\n-        addWindowListener(new WindowAdapter() {\n-            @Override\n-            public void windowClosing(WindowEvent e) {\n-                setVisible(false);\n-            }\n-        });\n-\n-        choWeather.addActionListener(e -> {\n-            int weather = choWeather.getSelectedIndex();\n-            if (currentWeather != weather && \n-                    (weather == PlanetaryConditions.WE_LIGHT_HAIL ||\n-                     weather == PlanetaryConditions.WE_HEAVY_HAIL ||\n-                     weather == PlanetaryConditions.WE_LIGHT_SNOW || \n-                     weather == PlanetaryConditions.WE_SLEET ||\n-                     weather == PlanetaryConditions.WE_SNOW_FLURRIES ||\n-                     weather == PlanetaryConditions.WE_HEAVY_SNOW ||\n-                     weather == PlanetaryConditions.WE_ICE_STORM || \n-                     weather == PlanetaryConditions.WE_BLIZZARD ||\n-                     weather == PlanetaryConditions.WE_MOD_SNOW)) {\n-                currentWeather = weather;\n-                conditions.setRunOnce(false);                \n-                updateForm();\n-            }\n-        });\n-\n-        pack();\n-        setSize(getSize().width, Math.max(getSize().height, 400));\n-        setResizable(true);\n-        setLocation(frame.getLocation().x + frame.getSize().width / 2\n-                - getSize().width / 2, frame.getLocation().y\n-                + frame.getSize().height / 2 - getSize().height / 2);\n-\n-    }\n-\n-    /** Creates new PlanetaryConditionsDialog */\n-    public PlanetaryConditionsDialog(ClientGUI client) {\n-        super(client.frame, Messages\n-                .getString(\"PlanetaryConditionsDialog.title\"), true); //$NON-NLS-1$\n-        this.client = client;\n-        init(client.frame, client.getClient().getGame().getPlanetaryConditions());\n+    private boolean userResponse;\n+    \n+    private void setupDialog() {\n+        JPanel mainPanel = new JPanel();\n+        add(mainPanel, BorderLayout.CENTER);\n+        add(buttonPanel(), BorderLayout.PAGE_END);\n+        \n+        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n+        mainPanel.add(headerSection());\n+        mainPanel.add(generalSection());\n+        mainPanel.add(weatherSection());\n+        mainPanel.add(dynamicSection());\n+        mainPanel.add(Box.createVerticalGlue());\n+        \n+        setupCombos();\n     }\n-\n-    public PlanetaryConditionsDialog(JFrame frame, PlanetaryConditions conditions) {\n-        super(frame, Messages\n-                .getString(\"PlanetaryConditionsDialog.title\"), true); //$NON-NLS-1$\n-        init(frame, conditions);\n+    \n+    private JPanel headerSection() {\n+        JPanel result = new FixedYPanel();\n+        result.setAlignmentX(Component.LEFT_ALIGNMENT);\n+        File iconFile = new MegaMekFile(Configuration.widgetsDir(), \"Planetary.png\").getFile();\n+        Image image = ImageUtil.loadImageFromFile(iconFile.toString());\n+        Icon planetIcon = new ImageIcon(image.getScaledInstance(scaleForGUI(40), -1, Image.SCALE_SMOOTH));\n+        JLabel planetLabel = new JLabel(Messages.getString(\"PlanetaryConditionsDialog.title\"), \n+                planetIcon, SwingConstants.CENTER);\n+        planetLabel.setIconTextGap(scaleForGUI(12));\n+        planetLabel.setBorder(new EmptyBorder(15, 0, 10, 0));\n+        result.add(planetLabel);\n+        return result;\n     }\n \n-    private void setupButtons() {\n-        butOkay.addActionListener(this);\n-        butCancel.addActionListener(this);\n-\n-        // layout\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        panButtons.setLayout(gridbag);\n-\n-        c.insets = new Insets(1, 1, 1, 1);\n-        c.weightx = 1.0;\n-        c.weighty = 1.0;\n-        c.fill = GridBagConstraints.VERTICAL;\n-        c.ipadx = 20;\n-        c.ipady = 5;\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(butOkay, c);\n-        panButtons.add(butOkay);\n-\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(butCancel, c);\n-        panButtons.add(butCancel);\n+    private JPanel generalSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.general\");\n+        Content panContent = new Content(new GridLayout(6, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labTemp);\n+        panContent.add(fldTemp);\n+        panContent.add(labGrav);\n+        panContent.add(fldGrav);\n+        panContent.add(labLight);\n+        panContent.add(comLight);\n+        panContent.add(labAtmosphere);\n+        panContent.add(comAtmosphere);\n+        panContent.add(labEMI);\n+        panContent.add(chkEMI);\n+        panContent.add(labTerrainAffected);\n+        panContent.add(chkTerrainAffected);\n+        return result;\n     }\n-\n-    private void setupConditions() {\n-\n-        refreshConditions();\n-\n-        GridBagLayout gridbag = new GridBagLayout();\n-        GridBagConstraints c = new GridBagConstraints();\n-        panOptions.setLayout(gridbag);\n-\n-        c.fill = GridBagConstraints.BOTH;\n-        c.insets = new Insets(1, 1, 1, 1);\n-        c.weightx = 1.0;\n-        c.weighty = 0.0;\n-        \n-        addLabelControlPair(c, labTemp, fldTemp);\n-        addLabelControlPair(c, labGrav, fldGrav);\n-        addLabelControlPair(c, labLight, choLight);\n-        addLabelControlPair(c, labWeather, choWeather);\n-        addLabelControlPair(c, labWind, choWind);\n-        addLabelControlPair(c, labWindDirection, cboWindDirection);\n-        addLabelControlPair(c, labAtmosphere, choAtmosphere);\n-        addLabelControlPair(c, labFog, choFog);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cBlowingSands, c);\n-        panOptions.add(cBlowingSands);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cShiftWindDir, c);\n-        panOptions.add(cShiftWindDir);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cShiftWindStr, c);\n-        panOptions.add(cShiftWindStr);\n-\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(labMinWind, c);\n-        panOptions.add(labMinWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(choMinWind, c);\n-        panOptions.add(choMinWind);\n-\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        gridbag.setConstraints(labMaxWind, c);\n-        panOptions.add(labMaxWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(choMaxWind, c);\n-        panOptions.add(choMaxWind);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cEMI, c);\n-        panOptions.add(cEMI);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        gridbag.setConstraints(cTerrainAffected, c);\n-        panOptions.add(cTerrainAffected);\n-\n+    \n+    private JPanel weatherSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.weather\");\n+        Content panContent = new Content(new GridLayout(5, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labWeather);\n+        panContent.add(comWeather);\n+        panContent.add(labWind);\n+        panContent.add(comWind);\n+        panContent.add(labWindDirection);\n+        panContent.add(comWindDirection);\n+        panContent.add(labFog);\n+        panContent.add(comFog);\n+        panContent.add(labBlowingSands);\n+        panContent.add(chkBlowingSands);\n+        return result;\n     }\n-\n-    /**\n-     * Worker method that adds a label - control pair to the UI (e.g. wind - wind dropdown)\n-     * @param c GridBagConstraints to use\n-     * @param label The label to add\n-     * @param valueControl The textbox or dropdown to add\n-     */\n-    private void addLabelControlPair(GridBagConstraints c, JLabel label, JComponent valueControl) {\n-        c.gridwidth = 1;\n-        c.anchor = GridBagConstraints.EAST;\n-        panOptions.add(label, c);\n-        label.setLabelFor(valueControl);\n-\n-        c.gridwidth = GridBagConstraints.REMAINDER;\n-        c.anchor = GridBagConstraints.WEST;\n-        panOptions.add(valueControl, c);\n+    \n+    private JPanel dynamicSection() {\n+        JPanel result = new OptionPanel(\"PlanetaryConditionsDialog.header.dynamic\");\n+        Content panContent = new Content(new GridLayout(4, 2, 10, 5));\n+        result.add(panContent);\n+        panContent.add(labShiftWindDir);\n+        panContent.add(chkShiftWindDir);\n+        panContent.add(labShiftWindStr);\n+        panContent.add(chkShiftWindStr);\n+        panContent.add(labMinWind);\n+        panContent.add(comWindFrom);\n+        panContent.add(labMaxWind);\n+        panContent.add(comWindTo);\n+        return result;\n     }\n     \n-    public void update(PlanetaryConditions planetConditions) {\n-        conditions = (PlanetaryConditions) planetConditions.clone();\n-        refreshConditions();\n+    private JPanel buttonPanel() {\n+        JPanel result = new JPanel(new FlowLayout());\n+        butOkay.addActionListener(listener);\n+        result.add(butOkay);\n+        result.add(new DialogButton(new CancelAction(this)));\n+        return result;\n     }\n-\n-    private void refreshConditions() {\n-\n-        choLight.removeAllItems();\n+    \n+    /** Fills the dialog comboboxes. */\n+    private void setupCombos() {\n         for (int i = 0; i < PlanetaryConditions.L_SIZE; i++) {\n-            choLight.addItem(PlanetaryConditions.getLightDisplayableName(i));\n+            comLight.addItem(PlanetaryConditions.getLightDisplayableName(i));\n         }\n-        choLight.setSelectedIndex(conditions.getLight());\n-\n-        choWeather.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.WE_SIZE; i++) {\n-            choWeather\n-                    .addItem(PlanetaryConditions.getWeatherDisplayableName(i));\n+            comWeather.addItem(PlanetaryConditions.getWeatherDisplayableName(i));\n         }\n-        choWeather.setSelectedIndex(conditions.getWeather());\n-        currentWeather = conditions.getWeather();\n-\n-        choWind.removeAllItems();\n-        choMinWind.removeAllItems();\n-        choMaxWind.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.WI_SIZE; i++) {\n-            choWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n-            choMinWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n-            choMaxWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWind.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWindFrom.addItem(PlanetaryConditions.getWindDisplayableName(i));\n+            comWindTo.addItem(PlanetaryConditions.getWindDisplayableName(i));\n         }\n-        choWind.setSelectedIndex(conditions.getWindStrength());\n-        choMinWind.setSelectedIndex(conditions.getMinWindStrength());\n-        choMaxWind.setSelectedIndex(conditions.getMaxWindStrength());\n-\n-        cboWindDirection.removeAllItems();\n         for(int i = 0; i < PlanetaryConditions.DIR_SIZE; i++) {\n-            cboWindDirection.addItem(PlanetaryConditions.getWindDirDisplayableName(i));\n+            comWindDirection.addItem(PlanetaryConditions.getWindDirDisplayableName(i));\n         }\n-        cboWindDirection.setSelectedIndex(conditions.getWindDirection());\n-\n-        choAtmosphere.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.ATMO_SIZE; i++) {\n-            choAtmosphere.addItem(PlanetaryConditions\n-                    .getAtmosphereDisplayableName(i));\n+            comAtmosphere.addItem(PlanetaryConditions.getAtmosphereDisplayableName(i));\n         }\n-        choAtmosphere.setSelectedIndex(conditions.getAtmosphere());\n-\n-        choFog.removeAllItems();\n         for (int i = 0; i < PlanetaryConditions.FOG_SIZE; i++) {\n-            choFog.addItem(PlanetaryConditions.getFogDisplayableName(i));\n+            comFog.addItem(PlanetaryConditions.getFogDisplayableName(i));\n         }\n-        choFog.setSelectedIndex(conditions.getFog());\n-\n-        cBlowingSands.setSelected(conditions.isSandBlowing());\n-\n-        cShiftWindDir.setSelected(conditions.shiftingWindDirection());\n-        cShiftWindStr.setSelected(conditions.shiftingWindStrength());\n+    }\n+    \n+    /** Adds all required listeners for the dialog fields. */\n+    private void addListeners() {\n+        comAtmosphere.addActionListener(listener);\n+        fldTemp.addFocusListener(focusListener);\n+        comLight.addActionListener(listener);\n+        comAtmosphere.addActionListener(listener);\n+        fldGrav.addFocusListener(focusListener);\n+        comWind.addActionListener(listener);\n+        comWeather.addActionListener(listener);\n+        comFog.addActionListener(listener);\n+        chkShiftWindStr.addActionListener(listener);\n+        chkBlowingSands.addActionListener(listener);\n+        comWindFrom.addActionListener(listener);\n+        comWindTo.addActionListener(listener);\n+    }\n+    \n+    /** Removes all listeners from the dialog fields. */\n+    private void removeListeners() {\n+        comAtmosphere.removeActionListener(listener);\n+        fldTemp.removeFocusListener(focusListener);\n+        comLight.removeActionListener(listener);\n+        comAtmosphere.removeActionListener(listener);\n+        fldGrav.removeFocusListener(focusListener);\n+        comWind.removeActionListener(listener);\n+        comWeather.removeActionListener(listener);\n+        comFog.removeActionListener(listener);\n+        chkShiftWindStr.removeActionListener(listener);\n+        chkBlowingSands.removeActionListener(listener);\n+        comWindFrom.removeActionListener(listener);\n+        comWindTo.removeActionListener(listener);\n+    }\n \n+    /** Updates the dialog fields with values from the stored conditions. */\n+    private void refreshValues() {\n+        removeListeners();\n+        comLight.setSelectedIndex(conditions.getLight());\n+        comWeather.setSelectedIndex(conditions.getWeather());\n+        comWind.setSelectedIndex(conditions.getWindStrength());\n+        comWindFrom.setSelectedIndex(conditions.getMinWindStrength());\n+        comWindTo.setSelectedIndex(conditions.getMaxWindStrength());\n+        comWindDirection.setSelectedIndex(conditions.getWindDirection());\n+        comAtmosphere.setSelectedIndex(conditions.getAtmosphere());\n+        comFog.setSelectedIndex(conditions.getFog());\n+        chkBlowingSands.setSelected(conditions.isSandBlowing());\n+        chkShiftWindDir.setSelected(conditions.shiftingWindDirection());\n+        chkShiftWindStr.setSelected(conditions.shiftingWindStrength());\n         fldTemp.setText(Integer.toString(conditions.getTemperature()));\n         fldGrav.setText(Float.toString(conditions.getGravity()));\n-\n-        cEMI.setSelected(conditions.hasEMI());\n-\n-        cTerrainAffected.setSelected(conditions.isTerrainAffected());\n-\n+        chkEMI.setSelected(conditions.hasEMI());\n+        chkTerrainAffected.setSelected(conditions.isTerrainAffected());\n+        addListeners();\n+        refreshWindShift();\n     }\n \n+    /** \n+     * Updates the stored conditions from the dialog fields. \n+     */\n     private void setConditions() {\n-            setConditions(true);\n-    }\n-\n-    private void setConditions(boolean shouldSendToServer) {\n         // make the changes to the planetary conditions\n-        conditions.setLight(choLight.getSelectedIndex());\n-        conditions.setWeather(choWeather.getSelectedIndex());\n-        conditions.setWindStrength(choWind.getSelectedIndex());\n-        conditions.setWindDirection(cboWindDirection.getSelectedIndex());\n-        conditions.setMinWindStrength(choMinWind.getSelectedIndex());\n-        conditions.setMaxWindStrength(choMaxWind.getSelectedIndex());\n-        conditions.setAtmosphere(choAtmosphere.getSelectedIndex());\n-        conditions.setFog(choFog.getSelectedIndex());\n-        conditions.setBlowingSand(cBlowingSands.isSelected());\n-        conditions.setShiftingWindDirection(cShiftWindDir.isSelected());\n-        conditions.setShiftingWindStrength(cShiftWindStr.isSelected());\n+        conditions.setLight(comLight.getSelectedIndex());\n+        conditions.setWeather(comWeather.getSelectedIndex());\n+        conditions.setWindStrength(comWind.getSelectedIndex());\n+        conditions.setWindDirection(comWindDirection.getSelectedIndex());\n+        refreshWindRange();\n+        conditions.setAtmosphere(comAtmosphere.getSelectedIndex());\n+        conditions.setFog(comFog.getSelectedIndex());\n+        conditions.setBlowingSand(chkBlowingSands.isSelected());\n+        conditions.setShiftingWindDirection(chkShiftWindDir.isSelected());\n+        conditions.setShiftingWindStrength(chkShiftWindStr.isSelected());\n         conditions.setTemperature(Integer.parseInt(fldTemp.getText()));\n         conditions.setGravity(Float.parseFloat(fldGrav.getText()));\n-        conditions.setEMI(cEMI.isSelected());\n-        conditions.setTerrainAffected(cTerrainAffected.isSelected());\n-\n-        if (client != null && shouldSendToServer) {\n-            send();\n-        }\n-    }\n-\n-    private void updateForm() {\n-        if (!validateForm()) {\n-            return;\n-        }\n-\n-        setConditions(false);\n-        conditions.alterConditions(conditions);\n-        refreshConditions();\n+        conditions.setEMI(chkEMI.isSelected());\n+        conditions.setTerrainAffected(chkTerrainAffected.isSelected());\n     }\n \n-    private void send() {\n-        client.getClient().sendPlanetaryConditions(conditions);\n-    }\n-\n-    private boolean validateForm() {\n-        // check for reasonable values and some conditionals\n-        int temper = 25;\n+    /** \n+     * Validates the current entries in the dialog. Any conflicting entries are marked\n+     * and a helper tooltip attached. Does not change entries.\n+     */\n+    private boolean validateEntries() {\n+        StringBuilder tempTip = new StringBuilder();\n+        StringBuilder wthrTip = new StringBuilder();\n+        StringBuilder gravTip = new StringBuilder();\n+        StringBuilder windTip = new StringBuilder();\n+        StringBuilder atmoTip = new StringBuilder();\n+        StringBuilder sandTip = new StringBuilder();\n+        int weather = comWeather.getSelectedIndex();\n+        int temp = 0;\n         float grav = (float) 1.0;\n         try {\n-            temper = Integer.parseInt(fldTemp.getText());\n+            temp = Integer.parseInt(fldTemp.getText());\n         } catch (NumberFormatException er) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidTemperature\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.integer\"));\n         }\n+        if ((temp > 200) || (temp < -200)) {\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.tempRange\"));\n+        }\n+        \n+        // Currently, MM does not automatically include the effects of -40, -50 or -60 \u00b0C\n+        // with snowy weather and instead relies on the temperature itself being set correctly.\n+        // I believe that the rules allow a temp of e.g. -5 \u00b0C with snow (and why not?) and\n+        // that the \"includes the effects\" statements are meant to reduce repetition. If the temp\n+        // were fixed to -40 \u00b0C, the text of the rules saying \"cannot be used with temp of 30 \u00b0C \n+        // or more\" would be unnecessary. With the current rules handling, temp has to be set to \n+        // the necessary values. Therefore the following check for 30 \u00b0C is not needed.\n+        //        if (temp >= 30 && requiresLowTemp(weather)) {\n+        //            tempValid = false;\n+        //            wthrValid = false;\n+        //            tempTip.append(\"The Temperature cannot be 30 \u00b0C or more in snowy weather.<BR>\");\n+        //            wthrTip.append(\"The Temperature cannot be 30 \u00b0C or more in snowy weather.<BR>\");\n+        //        }\n+        \n         try {\n             grav = Float.parseFloat(fldGrav.getText());\n         } catch (NumberFormatException er) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidGravity\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+            gravTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.number\"));\n         }\n-\n-        if ((temper > 200) || (temper < -200)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidTemperature\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+        if ((grav < 0.1) || (grav > 10.0)) {\n+            gravTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.gravRange\"));\n         }\n-\n-        int weather = currentWeather = choWeather.getSelectedIndex();\n-        if (temper >= 30 && (weather == PlanetaryConditions.WE_LIGHT_HAIL ||\n-                weather == PlanetaryConditions.WE_HEAVY_HAIL ||\n-                weather == PlanetaryConditions.WE_LIGHT_SNOW || \n-                weather == PlanetaryConditions.WE_SLEET ||\n-                weather == PlanetaryConditions.WE_SNOW_FLURRIES ||\n-                weather == PlanetaryConditions.WE_HEAVY_SNOW ||\n-                weather == PlanetaryConditions.WE_ICE_STORM || \n-                weather == PlanetaryConditions.WE_BLIZZARD ||\n-                weather == PlanetaryConditions.WE_MOD_SNOW)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                        frame, \n-                        Messages.getString(\"PlanetaryConditionsDialog.EnterValidTemperatureExtreme\"), \n-                        Messages.getString(\"PlanetaryConditionsDialog.NumberFormatError\"), \n-                        JOptionPane.ERROR_MESSAGE);\n-            return false;\n+        \n+        int wind = comWind.getSelectedIndex();\n+        int atmo = comAtmosphere.getSelectedIndex();\n+        \n+        if ((chkBlowingSands.isSelected()) && (wind < WI_MOD_GALE) \n+                && (!chkShiftWindStr.isSelected() \n+                        || (conditions.getMinWindStrength() > WI_MOD_GALE) \n+                        || (conditions.getMaxWindStrength() < WI_MOD_GALE))) {\n+            windTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.sandsLost\"));\n+            sandTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.sandsLost\"));\n         }\n \n-        if ((grav < 0.1) || (grav > 10.0)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.EnterValidGravity\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.NumberFormatError\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+        if ((atmo == ATMO_TRACE) && (wind == WI_LIGHT_GALE)) {\n+            atmoTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.traceLightGale\"));\n+            windTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.traceLightGale\"));\n         }\n-\n-        //make sure that the minimum and maximum wind conditions fall within the actual\n-        if(choWind.getSelectedIndex() < choMinWind.getSelectedIndex()) {\n-            choMinWind.setSelectedIndex(choWind.getSelectedIndex());\n+        \n+        // The following temperature checks are not exactly what the rules demand, but see the comment above.\n+        if (((weather == WE_LIGHT_SNOW) || (weather == WE_SLEET)\n+                || (weather == WE_LIGHT_HAIL) || (weather == WE_HEAVY_HAIL))\n+                && (temp > -40)) {\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.lightSnowTemp\"));\n+            wthrTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.lightSnowTemp\"));\n         }\n-        if(choWind.getSelectedIndex() > choMaxWind.getSelectedIndex()) {\n-            choMaxWind.setSelectedIndex(choWind.getSelectedIndex());\n+        \n+        if (((weather == WE_HEAVY_SNOW) || (weather == WE_MOD_SNOW)\n+                || (weather == WE_SNOW_FLURRIES))\n+                && (temp > -50)) {\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.modSnowTemp\"));\n+            wthrTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.modSnowTemp\"));\n         }\n-\n-        // can't combine certain wind conditions with certain atmospheres\n-        int wind = choWind.getSelectedIndex();\n-        int atmo = choAtmosphere.getSelectedIndex();\n-        if ((atmo == PlanetaryConditions.ATMO_VACUUM)\n-                && (wind > PlanetaryConditions.WI_NONE)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.VacuumWind\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.Incompatible\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+        \n+        if ((weather == WE_ICE_STORM) && (temp > -60)) {\n+            tempTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.iceStormTemp\"));\n+            wthrTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.iceStormTemp\"));\n         }\n-        if ((atmo == PlanetaryConditions.ATMO_TRACE)\n-                && (wind > PlanetaryConditions.WI_STORM)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.TraceWind\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.Incompatible\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+        \n+        if (chkShiftWindStr.isSelected()) {\n+            if ((comWind.getSelectedIndex() < conditions.getMinWindStrength()) \n+                    || (comWind.getSelectedIndex() > conditions.getMaxWindStrength())) {\n+                windTip.append(Messages.getString(\"PlanetaryConditionsDialog.invalid.windRange\"));\n+            }\n         }\n-        if ((atmo == PlanetaryConditions.ATMO_THIN)\n-                && (wind > PlanetaryConditions.WI_TORNADO_F13)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.ThinWind\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.Incompatible\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+    \n+        refreshWarning(labTemp, tempTip);\n+        refreshWarning(labWeather, wthrTip);\n+        refreshWarning(labAtmosphere, atmoTip);\n+        refreshWarning(labGrav, gravTip);\n+        refreshWarning(labWind, windTip);\n+        refreshWarning(labBlowingSands, sandTip);\n+        \n+        return (tempTip.length() == 0) && (wthrTip.length() == 0) && (atmoTip.length() == 0) \n+                && (sandTip.length() == 0) && (windTip.length() == 0) && (gravTip.length() == 0);\n+    }\n+    \n+    /** \n+     * Marks the given label red and adds the given tooltip text if isValid is false,\n+     * otherwise resets the label color and removes the tooltip. \n+     */\n+    private void refreshWarning(JLabel label, StringBuilder text) {\n+        if (text.length() == 0) {\n+            label.setForeground(null);\n+            label.setToolTipText(null);\n+        } else {\n+            label.setForeground(GUIPreferences.getInstance().getWarningColor());\n+            label.setToolTipText(formatTooltip(text.toString()));\n         }\n-\n-        // can't combine certain weather conditions with certain atmospheres\n-        if ((atmo == PlanetaryConditions.ATMO_VACUUM\n-                || atmo == PlanetaryConditions.ATMO_TRACE\n-                || atmo == PlanetaryConditions.ATMO_THIN)\n-                && (weather > PlanetaryConditions.WE_NONE)) {\n-            JOptionPane\n-                    .showMessageDialog(\n-                            frame,\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.VacuumWeather\"),\n-                            Messages\n-                                    .getString(\"PlanetaryConditionsDialog.Incompatible\"),\n-                            JOptionPane.ERROR_MESSAGE);\n-            return false;\n+    }\n+    \n+    /** \n+     * Updates the enabled state of some fields based on the atmosphere setting. \n+     * Also, for some weather settings,   ", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMzg0MQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611323841", "bodyText": "Why's this commented out, along with the pack() on line 550?", "author": "NickAragua", "createdAt": "2021-04-12T04:45:23Z", "path": "megamek/src/megamek/client/ui/swing/RandomArmyDialog.java", "diffHunk": "@@ -536,20 +537,25 @@ public RandomArmyDialog(ClientGUI cl) {\n         m_pRightPane.add(m_pPreview, CARD_PREVIEW);\n         m_pRightPane.add(m_pForceGen.getRightPanel(), CARD_FORCE_TREE);\n         \n-        m_pSplit = new javax.swing.JSplitPane(javax.swing.JSplitPane.HORIZONTAL_SPLIT,m_pMain, m_pRightPane);\n+        m_pSplit = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, m_pMain, m_pRightPane);\n         m_pSplit.setOneTouchExpandable(false);\n         m_pSplit.setResizeWeight(0.5);\n \n         // construct the main dialog\n         setLayout(new BorderLayout());\n-        this.setPreferredSize(new Dimension(800,500));\n+//        this.setPreferredSize(new Dimension(800,500));", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkxOTU3NA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614919574", "bodyText": "The whole dialog now remembers its position and size, therefore the setpreferredsize and pack are unnecessary. I'll remove the lines.", "author": "SJuliez", "createdAt": "2021-04-16T15:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMzg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMzk0Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611323943", "bodyText": "If we don't need these, how about deleting them?", "author": "NickAragua", "createdAt": "2021-04-12T04:45:43Z", "path": "megamek/src/megamek/client/ui/swing/RandomArmyDialog.java", "diffHunk": "@@ -784,34 +790,51 @@ public void actionPerformed(ActionEvent ev) {\n         }\n     }\n \n-    public void windowActivated(WindowEvent arg0) {\n-        //ignored\n-    }\n-\n-    public void windowClosed(WindowEvent arg0) {\n-        //ignored\n-    }\n-\n-    public void windowClosing(WindowEvent arg0) {\n-        setVisible(false);\n-    }\n-\n-    public void windowDeactivated(WindowEvent arg0) {\n-        //ignored\n-    }\n-\n-    public void windowDeiconified(WindowEvent arg0) {\n-        //ignored\n-    }\n-\n-    public void windowIconified(WindowEvent arg0) {\n-        //ignored\n-    }\n+//    public void windowActivated(WindowEvent arg0) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkyMDY5Nw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614920697", "bodyText": "done.", "author": "SJuliez", "createdAt": "2021-04-16T15:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyMzk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyNjgwMg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611326802", "bodyText": "Where'd all this stuff go?", "author": "NickAragua", "createdAt": "2021-04-12T04:56:40Z", "path": "megamek/src/megamek/client/ui/swing/boardview/EntitySprite.java", "diffHunk": "@@ -718,496 +688,6 @@ public Coords getPosition() {\n         return entity.getPosition();\n     }\n     \n-    private StringBuffer tooltipString;", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkyMDU4OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614920588", "bodyText": "To UnitTooltip", "author": "SJuliez", "createdAt": "2021-04-16T15:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyNjgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyNjg4NQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r611326885", "bodyText": "Commented out pack?", "author": "NickAragua", "createdAt": "2021-04-12T04:56:53Z", "path": "megamek/src/megamek/client/ui/swing/dialog/AbstractUnitSelectorDialog.java", "diffHunk": "@@ -187,7 +187,10 @@ private void setUserPreferences() {\n         ((DefaultRowSorter<?, ?>) tableUnits.getRowSorter()).sort();\n \n         tableUnits.invalidate(); // force re-layout of window\n-        pack();\n+//        pack();", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkyMTYyOQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614921629", "bodyText": "Same as the RandomArmyDialog, this dialog now remembers size&position and the pack had to go to make it work.", "author": "SJuliez", "createdAt": "2021-04-16T15:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTMyNjg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4NTUyNg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612085526", "bodyText": "Commented-out code", "author": "NickAragua", "createdAt": "2021-04-13T02:33:22Z", "path": "megamek/src/megamek/client/ui/swing/dialog/MMConfirmDialog.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*  \r\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \r\n+*  \r\n+* This program is free software; you can redistribute it and/or modify it under  \r\n+* the terms of the GNU General Public License as published by the Free Software  \r\n+* Foundation; either version 2 of the License, or (at your option) any later  \r\n+* version.  \r\n+*  \r\n+* This program is distributed in the hope that it will be useful, but WITHOUT  \r\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+* details.  \r\n+*/ \r\n+package megamek.client.ui.swing.dialog;\r\n+\r\n+import java.awt.BorderLayout;\r\n+import java.awt.Dimension;\r\n+import java.awt.FlowLayout;\r\n+import java.awt.event.*;\r\n+import javax.swing.JButton;\r\n+import javax.swing.JFrame;\r\n+import javax.swing.JLabel;\r\n+import javax.swing.JPanel;\r\n+import javax.swing.border.EmptyBorder;\r\n+\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.ClientDialog;\r\n+import megamek.client.ui.swing.util.UIUtil;\r\n+\r\n+/** \r\n+ * A simple modal confirmation dialog showing a single question and YES\r\n+ * and NO buttons. This dialog will scale with the gui scaling (and I \r\n+ * found no way to do this for JOptionDialog)\r\n+ *  \r\n+ * @author Juliez\r\n+ */\r\n+public class MMConfirmDialog {\r\n+    \r\n+    private final static Dimension MINIMUM_SIZE = new Dimension(400, 180); \r\n+    private final static int BASE_WIDTH = 400;\r\n+\r\n+    /** Shows a modal confirmation dialog with a YES and a NO button. The String title\r\n+     * is shown as the window title. The given message is shown as the question to be confirmed\r\n+     * in the center of the dialog.\r\n+     * \r\n+     * <BR><BR>Returns Response.YES when the user pressed ENTER or selected YES,\r\n+     * Response.NO otherwise.\r\n+     * \r\n+     * <BR><BR>The dialog scales itself with the current GUI scale. It closes when ESC is pressed.\r\n+     */\r\n+    public static boolean confirm(JFrame owner, String title, String message) {\r\n+        ConfirmDialog dialog = new ConfirmDialog(owner, title, message);\r\n+        dialog.center();\r\n+        dialog.setVisible(true);\r\n+        return dialog.userResponse;\r\n+    }\r\n+    \r\n+    // PRIVATE\r\n+    \r\n+    private static class ConfirmDialog extends ClientDialog {\r\n+        \r\n+        private static final long serialVersionUID = -2877691301521648979L;\r\n+\r\n+        private boolean userResponse = false;\r\n+        \r\n+        private JPanel panButtons = new JPanel(new FlowLayout(FlowLayout.CENTER, 20, 10));\r\n+        private JButton butYes = new DialogButton(Messages.getString(\"Yes\"));\r\n+        private JButton butNo = new DialogButton(Messages.getString(\"No\"));\r\n+        \r\n+        public ConfirmDialog(JFrame owner, String title, String message) {\r\n+            super(owner, title, true, true);\r\n+            addWindowListener(new WindowAdapter() {\r\n+                @Override\r\n+                public void windowClosed(WindowEvent e) {\r\n+                    respondNo();\r\n+                    super.windowClosed(e);\r\n+                }\r\n+            });\r\n+            add(panButtons, BorderLayout.PAGE_END);\r\n+            panButtons.add(butYes);\r\n+            panButtons.add(butNo);\r\n+            butYes.addActionListener(e -> respondYes());\r\n+            butNo.addActionListener(e -> respondNo());\r\n+            JLabel lblMain = new JLabel(\"<HTML>\" + message.replace(\"\\n\", \"<BR>\"));\r\n+            lblMain.setVerticalAlignment(JLabel.CENTER);\r\n+            lblMain.setHorizontalAlignment(JLabel.CENTER);\r\n+            lblMain.setBorder(new EmptyBorder(0, 20, 0, 20));\r\n+            add(lblMain, BorderLayout.CENTER);\r\n+            setMinimumSize(UIUtil.scaleForGUI(MINIMUM_SIZE));\r\n+//            setPreferredSize(UIUtil.scaleForGUI(MINIMUM_SIZE));\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4NjY3MQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612086671", "bodyText": "Why would we not add this panel to the main panel?", "author": "NickAragua", "createdAt": "2021-04-13T02:37:15Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkyMzIzNQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614923235", "bodyText": "Its added a few lines below. Just leftovers from moving stuff around. Will delete those lines.", "author": "SJuliez", "createdAt": "2021-04-16T15:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4NjY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4NjkyNw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612086927", "bodyText": "Why would we comment this out?", "author": "NickAragua", "createdAt": "2021-04-13T02:37:58Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);\n+        \n+        // Planetary Conditions and Random Map Settings buttons\n+        FixedYPanel panSettings = new FixedYPanel();\n+        panSettings.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panSettings.add(butConditions);\n+        panSettings.add(butRandomMap);\n+//        panMap.add(panSettings);", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkyMzY1MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614923650", "bodyText": "As above.", "author": "SJuliez", "createdAt": "2021-04-16T15:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4NjkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4ODA4Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612088083", "bodyText": "What's with all the commented out code in this method?", "author": "NickAragua", "createdAt": "2021-04-13T02:42:06Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);\n+        \n+        // Planetary Conditions and Random Map Settings buttons\n+        FixedYPanel panSettings = new FixedYPanel();\n+        panSettings.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panSettings.add(butConditions);\n+        panSettings.add(butRandomMap);\n+//        panMap.add(panSettings);\n+\n+        FixedYPanel panTopRows = new FixedYPanel();\n+        panTopRows.setLayout(new BoxLayout(panTopRows, BoxLayout.PAGE_AXIS));\n+        panTopRows.add(panMapType);\n+        panTopRows.add(panSettings);\n+        \n+        JPanel panHelp = new JPanel(new GridLayout(1,1));\n+        panHelp.add(butHelp);\n+        \n+        FixedYPanel panTopRowsHelp = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 30, 5));\n+        panTopRowsHelp.add(panTopRows);\n+        panTopRowsHelp.add(panHelp);\n+        panMap.add(panTopRowsHelp);\n+        \n+        // Main part: Map Assembly\n+        panMap.add(panGroundMap);\n+\n+    }\n+\n+    /**\n+     * Sets up the ground map selection panel\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void setupMapAssembly() {\n+\n+        panGroundMap = new JPanel(new GridLayout(1, 1));\n+        panGroundMap.setBorder(new EmptyBorder(20, 10, 10, 10));\n+\n+        panMapButtons.setLayout(new BoxLayout(panMapButtons, BoxLayout.PAGE_AXIS));\n+        // Resize the preview buttons when the panel is resized\n+        panMapButtons.addComponentListener(new ComponentAdapter() {\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateMapButtons();\n+            }\n+        });\n+        \n+        panMapWidth.add(lblMapWidth);\n+        panMapWidth.add(butMapShrinkW);\n+        panMapWidth.add(fldMapWidth);\n+        panMapWidth.add(butMapGrowW);\n+        \n+        panMapHeight.add(lblMapHeight);\n+        panMapHeight.add(butMapShrinkH);\n+        panMapHeight.add(fldMapHeight);\n+        panMapHeight.add(butMapGrowH);\n+        \n+        panSpaceBoardWidth.add(lblSpaceBoardWidth);\n+        panSpaceBoardWidth.add(fldSpaceBoardWidth);\n+        panSpaceBoardWidth.setVisible(false);\n+        \n+        panSpaceBoardHeight.add(lblSpaceBoardHeight);\n+        panSpaceBoardHeight.add(fldSpaceBoardHeight);\n+        panSpaceBoardHeight.setVisible(false);\n+        \n+        FixedYPanel bottomPanel = new FixedYPanel();\n+        bottomPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n+        bottomPanel.add(butBoardPreview);\n+        bottomPanel.add(butSaveMapSetup);\n+        bottomPanel.add(butLoadMapSetup);\n+\n+        butBoardPreview.setToolTipText(Messages.getString(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+\n+        // The left side panel including the game map preview\n+        JPanel panMapPreview = new JPanel();\n+        panMapPreview.setLayout(new BoxLayout(panMapPreview, BoxLayout.PAGE_AXIS));\n+        \n+        panMapPreview.add(panMapWidth);\n+        panMapPreview.add(panMapHeight);\n+        panMapPreview.add(panSpaceBoardWidth);\n+        panMapPreview.add(panSpaceBoardHeight);\n+        panMapPreview.add(panMapButtons);\n+        panMapPreview.add(bottomPanel);\n+        \n+        // The right side panel including the list of available boards\n+        comMapSizes = new JComboBox<Comparable>();\n+        refreshMapSizes();\n+\n+        lisBoardsAvailable = new JList<String>(new DefaultListModel<String>());\n+        lisBoardsAvailable.setCellRenderer(new BoardNameRenderer());\n+        lisBoardsAvailable.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n+        lisBoardsAvailable.setVisibleRowCount(-1);\n+        lisBoardsAvailable.setDragEnabled(true);\n+        lisBoardsAvailable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        scrBoardsAvailable = new JScrollPane(lisBoardsAvailable);\n+        refreshBoardsAvailable();\n+        \n+        JPanel panAvail = new JPanel();\n+        panAvail.setLayout(new BoxLayout(panAvail, BoxLayout.PAGE_AXIS));\n+        panAvail.setBorder(new EmptyBorder(0, 20, 0, 0));\n+        panAvail.add(setupAvailTopPanel());\n+        panAvail.add(scrBoardsAvailable);\n+        \n+        // The splitpane holding the left and right side panels\n+        splGroundMap = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panMapPreview, panAvail);\n+        splGroundMap.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+            \n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+        });\n+        panGroundMap.add(splGroundMap);\n+\n+        // setup the board preview window.\n+        boardPreviewW = new ClientDialog(clientgui.frame, \n+                Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"), \n+                false);\n+        boardPreviewW.setLocationRelativeTo(clientgui.frame);\n+\n+        try {\n+            BoardView1 bv = new BoardView1(boardPreviewGame, null, null);\n+            bv.setDisplayInvalidHexInfo(false);\n+            bv.setUseLOSTool(false);\n+            boardPreviewW.add(bv.getComponent(true));\n+            boardPreviewW.setSize(clientgui.frame.getWidth()/2, clientgui.frame.getHeight()/2);\n+            // Most boards will be far too large on the standard zoom\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            boardPreviewW.center();\n+        } catch (IOException e) {\n+            JOptionPane.showMessageDialog(this,\n+                            Messages.getString(\"BoardEditor.CouldntInitialize\") + e,\n+                            Messages.getString(\"BoardEditor.FatalError\"), JOptionPane.ERROR_MESSAGE); \n+        }\n+        refreshMapButtons();\n+    }\n+    \n+    /** \n+     *  Sets up and returns the panel above the available boards list \n+     *  containing the search bar and the map size chooser.  \n+     */\n+    private JPanel setupAvailTopPanel() {\n+        FixedYPanel result = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 20, 2));\n+        result.setBorder(new EmptyBorder(5, 5, 5, 5));\n+        \n+        fldSearch.getDocument().addDocumentListener(new DocumentListener() {\n+            @Override\n+            public void changedUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void removeUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void insertUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+        });\n+        \n+        result.add(lblBoardSize);\n+        result.add(comMapSizes);\n+        result.add(new JLabel(\"    \"));\n+        result.add(lblSearch);\n+        result.add(fldSearch);\n+        result.add(butCancelSearch);\n+\n+        return result;\n+    }\n+    \n+    /** \n+     * Reacts to changes in the available boards search field, showing matching boards\n+     * for the search string when it has at least 3 characters\n+     * and reverting to all boards when the search string is empty.\n+     */\n+    private void updateSearch(String searchString) {\n+        if (searchString.isEmpty()) {\n+            refreshBoardsAvailable();\n+        } else if (searchString.length() > 2) {\n+            refreshBoardsAvailable(getSearchedItems(searchString));\n+        }\n+    }\n+    \n+    /** \n+     * Returns the available boards that match the given search string\n+     * (path or file name contains the search string.) \n+     */\n+    protected List<String> getSearchedItems(String searchString) {\n+        String lowerCaseSearchString = searchString.toLowerCase();\n+        return mapSettings.getBoardsAvailableVector().stream()\n+                .filter(b -> b.toLowerCase().contains(lowerCaseSearchString) && isBoardFile(b))\n+                .collect(Collectors.toList());\n+    }\n+    \n+    /** \n+     * Returns a suitable divider location for the splitpane that contains\n+     * the available boards list and the map preview. The divider location\n+     * gives between 30% and 50% of space to the map preview depending\n+     * on the width of the game map.\n+     */\n+    private double getDividerLocation() {\n+        double base = 0.3;\n+        int width = mapSettings.getBoardWidth() * mapSettings.getMapWidth();\n+        int height = mapSettings.getBoardHeight() * mapSettings.getMapHeight();\n+        int wAspect = Math.max(1, width / height + 1);\n+        return Math.min(base + wAspect * 0.05, 0.5);\n+    }\n+\n+    /** Updates the ground map type chooser (ground/atmosphere map). */\n+    private void refreshMapChoice() {\n+        // refresh UI possibly from a server update\n+        JToggleButton button = butGroundMap;\n+        if (mapSettings.getMedium() == MapSettings.MEDIUM_ATMOSPHERE) {\n+            button = butLowAtmoMap;\n+        } else if (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {\n+            button = butSpaceMap;\n+        }\n+        \n+        if (!button.isSelected()) {\n+            button.removeActionListener(lobbyListener);\n+            button.setSelected(true);\n+            button.addActionListener(lobbyListener);\n+        }\n+    }\n+    \n+    /** Updates the list of available map sizes. */\n+    private void refreshMapSizes() {\n+        int oldSelection = comMapSizes.getSelectedIndex();\n+        mapSizes = clientgui.getClient().getAvailableMapSizes();\n+        comMapSizes.removeActionListener(lobbyListener);\n+        comMapSizes.removeAllItems();\n+        for (BoardDimensions size : mapSizes) {\n+            comMapSizes.addItem(size);\n+        }\n+        comMapSizes.addItem(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        comMapSizes.setSelectedIndex(oldSelection != -1 ? oldSelection : 0);\n+        comMapSizes.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the map assembly UI from the current map settings. Does NOT trigger further\n+     * changes or result in packets to the server. \n+     */\n+    private void refreshMapUI() {\n+        boolean inSpace = mapSettings.getMedium() == MapSettings.MEDIUM_SPACE;\n+        boolean onGround = mapSettings.getMedium() == MapSettings.MEDIUM_GROUND;\n+        boolean customSize = comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        lisBoardsAvailable.setEnabled(!inSpace);\n+        mapIcons.clear();\n+        butConditions.setEnabled(!inSpace);\n+        fldSearch.setEnabled(!inSpace);\n+        butRandomMap.setEnabled(!inSpace);\n+        panMapHeight.setVisible(!inSpace);\n+        panMapWidth.setVisible(!inSpace);\n+        panSpaceBoardWidth.setVisible(inSpace || customSize);\n+        panSpaceBoardHeight.setVisible(inSpace || customSize);\n+        comMapSizes.setEnabled(!inSpace);\n+        lblSearch.setEnabled(!inSpace);\n+        lblBoardSize.setEnabled(!inSpace);\n+        butSaveMapSetup.setEnabled(!inSpace);\n+        butLoadMapSetup.setEnabled(!inSpace);\n+        butMapShrinkW.setEnabled(mapSettings.getMapWidth() > 1);\n+        butMapShrinkH.setEnabled(mapSettings.getMapHeight() > 1);\n+        \n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        if (onGround) {\n+            butGroundMap.setSelected(true);\n+        } else if (inSpace) {\n+            butSpaceMap.setSelected(true);\n+        } else {\n+            butLowAtmoMap.setSelected(true);\n+        }\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        fldMapWidth.setText(Integer.toString(mapSettings.getMapWidth()));\n+        fldMapHeight.setText(Integer.toString(mapSettings.getMapHeight()));\n+        fldSpaceBoardWidth.setText(Integer.toString(mapSettings.getBoardWidth()));\n+        fldSpaceBoardHeight.setText(Integer.toString(mapSettings.getBoardHeight()));\n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+    }\n+\n+    /** \n+     * Refreshes the list of available boards with all available boards plus\n+     * GENERATED. Useful for first setup, when the server transmits new\n+     * map settings and when the text search field is empty.\n+     */\n+    private void refreshBoardsAvailable() {\n+        if (!lisBoardsAvailable.isEnabled()) {\n+            return;\n+        }\n+        lisBoardsAvailable.setFixedCellHeight(-1);\n+        lisBoardsAvailable.setFixedCellWidth(-1);\n+        List<String> availBoards = new ArrayList<>(); \n+        availBoards.add(MapSettings.BOARD_GENERATED);\n+        availBoards.addAll(mapSettings.getBoardsAvailableVector());\n+        refreshBoardsAvailable(availBoards);\n+    }\n+    \n+    /** \n+     * Refreshes the list of available maps with the given list of boards. \n+     */\n+    private void refreshBoardsAvailable(List<String> boardList) {\n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        // Replace the data model (adding the elements one by one to the existing model\n+        // in Java 8 style is sluggish because of event firing)\n+        DefaultListModel<String> newModel = new DefaultListModel<>();\n+        for (String s: boardList) {\n+            newModel.addElement(s);\n+        }\n+        lisBoardsAvailable.setModel(newModel);\n+        lisBoardsAvailable.clearSelection();\n+        lisBoardsAvailable.addListSelectionListener(this);\n+    }\n+    \n+    public boolean isMultipleBoards() {\n+        return mapSettings.getMapHeight() * mapSettings.getMapWidth() > 1;\n+    }\n+    \n+    MapSettings oldMapSettings = MapSettings.getInstance();\n+\n+    /**\n+     * Fills the Map Buttons scroll pane twith the appropriate amount of buttons\n+     * in the appropriate layout\n+     */\n+    private void refreshMapButtons() {\n+        panMapButtons.removeAll();\n+        panMapButtons.setVisible(false);\n+        panMapButtons.add(Box.createVerticalGlue());\n+        Dimension buttonSize = null;\n+\n+        // If buttons are unused, remove their image so that they update when they're used once more\n+        if (mapSettings.getMapHeight() * mapSettings.getMapWidth() < mapButtons.size()) {\n+            for (MapPreviewButton button: mapButtons.subList(mapSettings.getMapHeight() * mapSettings.getMapWidth(), mapButtons.size())) {\n+                button.reset();\n+            }\n+        }\n+\n+        // Add new map preview buttons if the map has grown\n+        while (mapSettings.getMapHeight() * mapSettings.getMapWidth() > mapButtons.size()) {\n+            mapButtons.add(new MapPreviewButton(this));\n+        }\n+\n+        // Re-add the buttons to the panel and update them as necessary\n+        for (int i = 0; i < mapSettings.getMapHeight(); i++) {\n+            JPanel row = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n+            panMapButtons.add(row);\n+            for (int j = 0; j < mapSettings.getMapWidth(); j++) {\n+                int index = i * mapSettings.getMapWidth() + j;\n+                MapPreviewButton button = mapButtons.get(index);\n+                button.setIndex(index);\n+                row.add(button);\n+\n+                // Update the board base image if it's generated and the settings have changed\n+                // or the board name has changed\n+                String boardName = mapSettings.getBoardsSelectedVector().get(index);\n+                if (!button.getBoard().equals(boardName) \n+                        || oldMapSettings.getMedium() != mapSettings.getMedium()\n+                        || (!mapSettings.equalMapGenParameters(oldMapSettings) \n+                                && mapSettings.getMapWidth() == oldMapSettings.getMapWidth()\n+                                && mapSettings.getMapHeight() == oldMapSettings.getMapHeight())) {\n+                    IBoard buttonBoard; \n+                    Image image;\n+                    // Generated and space boards use a generated example\n+                    if (boardName.startsWith(MapSettings.BOARD_GENERATED) \n+                            || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                        buttonBoard = BoardUtilities.generateRandom(mapSettings);\n+                        image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                    } else { \n+                        String boardForImage = boardName;\n+                        // For a surprise board, just use the first board as example\n+                        if (boardName.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                            boardForImage = extractSurpriseMaps(boardName).get(0);\n+                        }\n+                        File boardFile = new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile();\n+                        if (boardFile.exists()) {\n+                            buttonBoard = new Board(16, 17);\n+                            buttonBoard.load(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile());\n+                            StringBuffer errs = new StringBuffer();\n+                            try (InputStream is = new FileInputStream(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile())) {\n+                                buttonBoard.load(is, errs, true);\n+                            } catch (IOException ex) {\n+                                buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            }\n+                            image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                        } else {\n+                            buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            BufferedImage emptyBoardMap = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                            markServerSideBoard(emptyBoardMap);\n+                            image = emptyBoardMap;\n+                        }\n+                    }\n+                    button.setImage(image, boardName);\n+                    buttonSize = optMapButtonSize(image);\n+                }\n+                button.scheduleRescale();\n+            }\n+        }\n+        oldMapSettings = MapSettings.getInstance(mapSettings);\n+        \n+        if (buttonSize != null) {\n+            for (MapPreviewButton button: mapButtons) {\n+                button.setPreviewSize(buttonSize);\n+            }\n+        }\n+        splGroundMap.setDividerLocation(getDividerLocation());\n+\n+        panMapButtons.add(Box.createVerticalGlue());\n+        panMapButtons.setVisible(true);\n+\n+        lblBoardsAvailable.setText(mapSettings.getBoardWidth() + \"x\" + mapSettings.getBoardHeight() + \" \"\n+                + Messages.getString(\"BoardSelectionDialog.mapsAvailable\"));\n+        comMapSizes.removeActionListener(lobbyListener);\n+        int items = comMapSizes.getItemCount();\n+\n+        boolean mapSizeSelected = false;\n+        for (int i = 0; i < (items - 1); i++) {\n+            BoardDimensions size = (BoardDimensions) comMapSizes.getItemAt(i);\n+\n+            if ((size.width() == mapSettings.getBoardWidth()) && (size.height() == mapSettings.getBoardHeight())) {\n+                comMapSizes.setSelectedIndex(i);\n+                mapSizeSelected = true;\n+            }\n+        }\n+        // If we didn't select a size, select the last item: 'Custom Size'\n+        if (!mapSizeSelected) {\n+            comMapSizes.setSelectedIndex(items - 1);\n+        }\n+        comMapSizes.addActionListener(lobbyListener);\n+\n+    }\n+    \n+    private void markServerSideBoard(BufferedImage image) {\n+        Graphics g = image.getGraphics();\n+        GUIPreferences.AntiAliasifSet(g);\n+        int w = image.getWidth();\n+        int h = image.getHeight();\n+        String text = \"Server-side board\";\n+        int fontSize = Math.min(w / 10, UIUtil.scaleForGUI(16));\n+        g.setFont(new Font(\"Dialog\", Font.ITALIC, fontSize));\n+        FontMetrics fm = g.getFontMetrics(g.getFont());\n+        int cx = (w - fm.stringWidth(text)) / 2;\n+        int cy = h / 10 + fm.getAscent();\n+        g.setColor(GUIPreferences.getInstance().getWarningColor());\n+        g.drawString(text, cx, cy);\n+        g.dispose();\n+    }\n+\n+    public void previewGameBoard() {\n+        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);\n+        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];\n+        List<Boolean> rotateBoard = new ArrayList<>();\n+        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings.getMapHeight()); i++) {\n+            sheetBoards[i] = new Board();\n+            String name = mapSettings.getBoardsSelectedVector().get(i);\n+            if (name.startsWith(MapSettings.BOARD_GENERATED) \n+                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);\n+            } else {\n+                if (name.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                    List<String> boardList = extractSurpriseMaps(name);\n+                    int rnd = (int)(Math.random() * boardList.size());\n+                    name = boardList.get(rnd);\n+                }\n+                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name + \".board\").getFile());\n+            }\n+        }\n+\n+        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(), mapSettings.getMapWidth(),\n+                mapSettings.getMapHeight(), sheetBoards, rotateBoard, mapSettings.getMedium());\n+        \n+        boardPreviewGame.setBoard(newBoard);\n+        boardPreviewW.setVisible(true);\n+    }\n+\n+    /**\n+     * Refreshes the game settings with new info from the client\n+     */\n+    private void refreshGameSettings() {\n+        refreshTeams();\n+        refreshDoneButton();\n+    }\n+    \n+    /**\n+     * Refreshes the Mek Table contents \n+     */\n+    public void refreshEntities() {\n+        refreshTree();\n+        refreshMekTable();\n+    }\n+    \n+    private void refreshMekTable() {\n+        List<Integer> enIds = getSelectedEntities().stream().map(e -> e.getId()).collect(toList());\n+        mekModel.clearData();\n+        ArrayList<Entity> allEntities = new ArrayList<Entity>(clientgui.getClient().getEntitiesVector());\n+        Collections.sort(allEntities, activeSorter);\n+\n+        boolean localUnits = false;\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        for (Entity entity : allEntities) {\n+            // Remember if the local player has units.\n+            if (!localUnits && entity.getOwner().equals(localPlayer())) {\n+                localUnits = true;\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_PILOT_ADVANTAGES)) { \n+                entity.getCrew().clearOptions(PilotOptions.LVL3_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.EDGE)) { \n+                entity.getCrew().clearOptions(PilotOptions.EDGE_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_MANEI_DOMINI)) { \n+                entity.getCrew().clearOptions(PilotOptions.MD_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS)) { \n+                entity.clearPartialRepairs();\n+            }\n+            \n+            // Remove some deployment options when a unit is carried\n+            if (entity.getTransportId() != Entity.NONE) { \n+                entity.setHidden(false);\n+                entity.setProne(false);\n+                entity.setHullDown(false);\n+            }\n+            \n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) { \n+                entity.setHidden(false);\n+            }\n+            \n+            // Handle the \"Blind Drop\" option. In blind drop, units must be added\n+            // but they will be obscured in the table. In real blind drop, units\n+            // don't even get added to the table. Teams see their units in any case.\n+            boolean localUnit = entity.getOwner().equals(localPlayer());\n+            boolean teamUnit = !entity.getOwner().isEnemyOf(localPlayer());\n+            boolean realBlindDrop = opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+            if (localUnit || teamUnit || !realBlindDrop) {\n+                mekModel.addUnit(entity);\n+            }\n+        }\n+        // Restore selection\n+        if (!enIds.isEmpty()) {\n+            for (int i = 0; i < mekTable.getRowCount(); i++) {\n+                if (enIds.contains(mekModel.getEntityAt(i).getId())) {\n+                    mekTable.addRowSelectionInterval(i, i);\n+                }\n+            }\n+        }\n+\n+        // Enable the \"Save Unit List...\" button if the local player has units.\n+        clientgui.getMenuBar().setUnitList(localUnits);\n+    }\n+    \n+    /** Adjusts the mektable to compact/normal mode. */\n+    private void toggleCompact() {\n+        setTableRowHeights();\n+        mekModel.refreshCells();\n+        mekForceTreeModel.nodeChanged((TreeNode)mekForceTreeModel.getRoot());\n+        \n+    }\n+\n+    /** Refreshes the player info table. */\n+    private void refreshPlayerTable() {\n+        // Remember the selected players\n+        var selPlayerIds = getselectedPlayers().stream().map(IPlayer::getId).collect(toSet());\n+\n+        // Empty and refill the player table\n+        playerModel.replaceData(game().getPlayersVector());\n+\n+        // re-select the previously selected players, if possible\n+        for (int row = 0; row < playerModel.getRowCount(); row++) {\n+            if (selPlayerIds.contains(playerModel.getPlayerAt(row).getId())) {\n+                tablePlayers.addRowSelectionInterval(row, row);\n+            }\n+        }\n+    }\n+\n+    /** Updates the camo button to displays the camo of the currently selected player. */ \n+    private void refreshCamoButton() {\n+        if ((tablePlayers == null) || (playerModel == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (player != null) {\n+            butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        }\n+    }\n+\n+    /** Sets up the team choice box. */\n+    private void setupTeamCombo() {\n+        for (int i = 0; i < IPlayer.MAX_TEAMS; i++) {\n+            comboTeam.addItem(IPlayer.teamNames[i]);\n+        }\n+    }\n+\n+    /** Updates the team choice combobox to show the selected player's team. */\n+    private void refreshTeams() {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(localPlayer().getTeam());\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the Done button. The label will say the opposite of the\n+     * player's \"done\" status, indicating that clicking it will reverse the\n+     * condition.\n+     */\n+    private void refreshDoneButton(boolean done) {\n+        butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n+    }\n+\n+    /** Refreshes the state of the Done button with the state of the local player. */\n+    private void refreshDoneButton() {\n+        refreshDoneButton(localPlayer().isDone());\n+    }\n+\n+    /**\n+     * Embarks the given carried Entity onto the carrier given as carrierId.\n+     */\n+    void loadOnto(Entity carried, int carrierId, int bayNumber) {\n+        Entity carrier = game().getEntity(carrierId);\n+        if (carrier == null || !isLoadable(carried, carrier)) {\n+            return;\n+        }\n+\n+        // We need to make sure our current bomb choices fit onto the new\n+        // fighter\n+        if (carrier instanceof FighterSquadron) {\n+            FighterSquadron fSquad = (FighterSquadron) carrier;\n+            // We can't use Aero.getBombPoints() because the bombs haven't been\n+            // loaded yet, only selected, so we have to count the choices\n+            int[] bombChoice = fSquad.getBombChoices();\n+            int numLoadedBombs = 0;\n+            for (int i = 0; i < bombChoice.length; i++) {\n+                numLoadedBombs += bombChoice[i];\n+            }\n+            // We can't load all of the squadrons bombs\n+            if (numLoadedBombs > ((IBomber)carried).getMaxBombPoints()) {\n+                JOptionPane.showMessageDialog(clientgui.frame, Messages.getString(\"FighterSquadron.bomberror\"),\n+                        Messages.getString(\"FighterSquadron.error\"), JOptionPane.ERROR_MESSAGE);\n+                return;\n+            }\n+        }\n+        \n+        getLocalClient(carried).sendLoadEntity(carried.getId(), carrierId, bayNumber);\n+        // TODO: it would probably be a good idea \n+        // to disable some settings for loaded units in customMechDialog\n+    }\n+\n+    /** \n+     * Have the given entity disembark if it is carried by another unit.\n+     * Entities that are modified and need an update to be sent to the server\n+     * are added to the given updateCandidates. \n+     */\n+    void disembark(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = game().getEntity(entity.getTransportId());\n+        if (carrier != null) {\n+            carrier.unload(entity);\n+            entity.setTransportId(Entity.NONE);\n+            updateCandidates.add(entity);\n+            updateCandidates.add(carrier);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity disembark if it is carried by a unit of another player.\n+     * Entities that were modified and need an update to be sent to the server\n+     * are added to the given updateCandidate set. \n+     */\n+    void disembarkDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = clientgui.getClient().getGame().getEntity(entity.getTransportId());\n+        if (carrier != null && (ownerOf(entity) != ownerOf(carrier))) {\n+            disembark(entity, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entities offload all the units they are carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadAll(Collection<Entity> entities, Collection<Entity> updateCandidates) {\n+        for (Entity carrier: editableEntities(entities)) {\n+            offloadFrom(carrier, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all the units it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFrom(Entity entity, Collection<Entity> updateCandidates) {\n+        if (isEditable(entity)) {\n+            for (Entity carriedUnit: entity.getLoadedUnits()) {\n+                disembark(carriedUnit, updateCandidates);\n+            } \n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all units of different players it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFromDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        for (Entity carriedUnit: entity.getLoadedUnits()) {\n+            if (ownerOf(carriedUnit) != ownerOf(entity)) {\n+                disembark(carriedUnit, updateCandidates);\n+            }\n+        } \n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. \n+     */\n+    void sendUpdate(Collection<Entity> updateCandidates) {\n+        for (Entity e: editableEntities(updateCandidates)) {\n+            getLocalClient(e).sendUpdateEntity(e);\n+        }\n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. Will separate the units into update\n+     * packets for the local player and any local bots so that the \n+     * server accepts all changes (as the server does not know of\n+     * local bots and rejects updates that are not for the sending client\n+     * or its teammates. \n+     */\n+    void sendUpdates(Collection<Entity> entities) {\n+        List<IPlayer> owners = entities.stream().map(e -> e.getOwner()).distinct().collect(toList());\n+        for (IPlayer owner: owners) {\n+            client().sendUpdateEntity(new ArrayList<Entity>(\n+                    entities.stream().filter(e -> e.getOwner().equals(owner)).collect(toList())));\n+        }\n+    }\n+    \n+    /** \n+     * Disembarks all given entities from any transports they are in. \n+     */\n+    void disembarkAll(Collection<Entity> entities) {\n+        Set<Entity> updateCandidates = new HashSet<>();\n+        entities.stream().filter(e -> isEditable(e)).forEach(e -> disembark(e, updateCandidates));\n+        sendUpdate(updateCandidates);\n+    }\n+\n+    /** \n+     * Returns true when the given entity may be configured by the local player,\n+     * i.e. if it is his own unit or one of his bot's units.\n+     * <P>Note that this is more restrictive than the Server is. The Server\n+     * accepts entity changes also for teammates so that entity updates that \n+     * signal transporting a teammate's unit don't get rejected. I feel that\n+     * configuration other than transporting units should be limited to one's\n+     * own units (and bots) though.\n+     */\n+    boolean isEditable(Entity entity) {\n+        return clientgui.getBots().containsKey(entity.getOwner().getName())\n+                || (entity.getOwnerId() == localPlayer().getId());\n+    }\n+    \n+    /** \n+     * Returns true when the given entity may NOT be configured by the local player,\n+     * i.e. if it is not own unit or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isNotEditable(Entity entity) {\n+        return !isEditable(entity);\n+    }\n+    \n+    /** \n+     * Returns true when all given entities may be configured by the local player,\n+     * i.e. if they are his own units or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isEditable(Collection<Entity> entities) {\n+        return !entities.stream().anyMatch(this::isNotEditable);\n+    }\n+    \n+    /** \n+     * Returns the Client associated with a given entity that may be configured\n+     * by the local player (his own unit or one of his bot's units).\n+     * For a unit that cannot be configured (owned by a remote player) the client\n+     * of the local player is returned.\n+     */\n+    Client getLocalClient(Entity entity) {\n+        if (clientgui.getBots().containsKey(entity.getOwner().getName())) {\n+            return clientgui.getBots().get(entity.getOwner().getName());\n+        } else {\n+            return clientgui.getClient();\n+        }\n+    }\n+\n+    public void configPlayer() {\n+        Client c = getSelectedClient();\n+        if (null == c) {\n+            return;\n+        }\n+        \n+        PlayerSettingsDialog psd = new PlayerSettingsDialog(clientgui, c);\n+        boolean okay = psd.showDialog();\n+        \n+        if (okay) {\n+            IPlayer player = c.getLocalPlayer();\n+            player.setConstantInitBonus(psd.getInit());\n+            player.setNbrMFConventional(psd.getCnvMines());\n+            player.setNbrMFVibra(psd.getVibMines());\n+            player.setNbrMFActive(psd.getActMines());\n+            player.setNbrMFInferno(psd.getInfMines());\n+            var rsg = c.getRandomSkillsGenerator();\n+            rsg.setMethod(psd.getMethod());\n+            rsg.setType(psd.getPilot());\n+            rsg.setLevel(psd.getXP());\n+            rsg.setClose(psd.getForceGP());\n+            \n+            // The deployment position\n+            int startPos = psd.getStartPos();\n+            final GameOptions gOpts = clientgui.getClient().getGame().getOptions();\n+            if (gOpts.booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                    && (startPos >= 1) && (startPos <= 9)) {\n+                startPos += 10;\n+            }\n+            c.getLocalPlayer().setStartingPos(startPos);\n+            c.sendPlayerInfo();\n+            \n+            // If the gameoption set_arty_player_homeedge is set, adjust the player's offboard \n+            // arty units to be behind the newly selected home edge.\n+            OffBoardDirection direction = OffBoardDirection.translateStartPosition(startPos);\n+            if (direction != OffBoardDirection.NONE && \n+                    gOpts.booleanOption(OptionsConstants.BASE_SET_ARTY_PLAYER_HOMEEDGE)) {\n+                for (Entity entity: c.getGame().getPlayerEntities(c.getLocalPlayer(), false)) {\n+                    if (entity.getOffBoardDirection() != OffBoardDirection.NONE) {\n+                        entity.setOffBoard(entity.getOffBoardDistance(), direction);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    \n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechReadoutAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechReadout(entity, index++);\n+        }\n+    } \n+\n+    /** \n+     * Shows the unit summary for the given unit. Moves the dialog a bit depending on index\n+     * so that multiple dialogs dont appear exactly on top of each other. \n+     */\n+    private void mechReadout(Entity entity, int index) {\n+        final ClientDialog dialog = new ClientDialog(clientgui.frame, Messages.getString(\"ChatLounge.quickView\"), false, true);\n+        final int height = 600;\n+        final int width = 500;\n+\n+        MechView mv = new MechView(entity, false);\n+        // The label must want a fixed width to enforce linebreaks on fluff text\n+        JLabel mechSummary = new JLabel(\"<HTML>\" + mv.getMechReadoutHead()\n+        + mv.getMechReadoutBasic() + mv.getMechReadoutLoadout()\n+        + mv.getMechReadoutFluff()) {\n+            private static final long serialVersionUID = 2989361635430008853L;\n+            @Override\n+            public Dimension getPreferredSize() {\n+                return new Dimension(width - 10, super.getPreferredSize().height);\n+            }\n+        };\n+        mechSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(mechSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.center();\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechBVAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechBVDisplay(entity, index++);\n+        }\n+    } \n+    \n+    /**\n+     * @param entity the entity to display the BV Calculation for\n+     */\n+    void mechBVDisplay(Entity entity, int index) {\n+        final JDialog dialog = new ClientDialog(clientgui.frame, \"BV Calculation Display\", false, true);\n+        final int height = 600;\n+        \n+        entity.calculateBattleValue();\n+        JLabel bvSummary = new JLabel(entity.getBVText());\n+        bvSummary.setFont(new Font(\"Dialog\",Font.PLAIN, scaleForGUI(14)));\n+        bvSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(bvSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(bvSummary.getPreferredSize().width + 40, scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /**\n+     * Pop up the dialog to load a mech\n+     */\n+    private void addUnit() {\n+        clientgui.getMechSelectorDialog().updateOptionValues();\n+        clientgui.getMechSelectorDialog().setVisible(true);\n+    }\n+    \n+    private void createArmy() {\n+        clientgui.getRandomArmyDialog().setVisible(true);\n+    }\n+\n+    public void loadRandomSkills() {\n+        clientgui.getRandomSkillDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    public void loadRandomNames() {\n+        clientgui.getRandomNameDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    void changeMapDnD(String board, JButton button) {\n+        if (board.contains(\"\\n\")) {\n+            board = MapSettings.BOARD_SURPRISE + board;\n+        }\n+        mapSettings.getBoardsSelectedVector().set(mapButtons.indexOf(button), board);\n+        clientgui.getClient().sendMapSettings(mapSettings);\n+        if (boardPreviewW.isVisible()) {\n+            previewGameBoard();\n+        }\n+    }\n+    \n+    \n+\n+    //\n+    // GameListener\n+    //\n+    @Override\n+    public void gamePlayerChange(GamePlayerChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshDoneButton();\n+        clientgui.getClient().getGame().setupTeams();\n+        refreshPlayerTable();\n+        refreshPlayerConfig();\n+        refreshCamoButton();\n+        refreshEntities();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gamePhaseChange(GamePhaseChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        \n+        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {\n+            refreshDoneButton();\n+            refreshGameSettings();\n+            refreshPlayerTable();\n+            refreshTeams();\n+            refreshCamoButton();\n+            refreshEntities();\n+            panTeamOverview.refreshData();\n+        }\n+    }\n+\n+    @Override\n+    public void gameEntityNew(GameEntityNewEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameSettingsChange(GameSettingsChangeEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshGameSettings();\n+        // The table sorting may no longer be allowed (e.g. when blind drop was activated)\n+        if (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())) {\n+            nextSorter(unitSorters);\n+            updateTableHeaders();\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        refreshMapSizes();\n+        updateMapSettings(clientgui.getClient().getMapSettings());\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameClientFeedbackRequest(GameCFREvent evt) {\n+        // Do nothing\n+    }\n+\n+    \n+    private ActionListener lobbyListener = new ActionListener() {\n+\n+        @Override\n+        public void actionPerformed(ActionEvent ev) {\n+\n+            // Are we ignoring events?\n+            if (isIgnoringEvents()) {\n+                return;\n+            }\n+            \n+            if (ev.getSource().equals(butAdd)) {\n+                addUnit();\n+                \n+            } else if (ev.getSource().equals(butArmy)) {\n+                createArmy();\n+                \n+            } else if (ev.getSource().equals(butSkills)) {\n+                loadRandomSkills();\n+                \n+            } else if (ev.getSource().equals(butNames)) {\n+                loadRandomNames();\n+                \n+            } else if (ev.getSource().equals(tablePlayers)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(comboTeam)) {\n+                lobbyActions.changeTeam(getselectedPlayers(), comboTeam.getSelectedIndex());\n+                \n+            } else if (ev.getSource().equals(butConfigPlayer)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(butBotSettings)) {\n+                doBotSettings();\n+                \n+            } else if (ev.getSource().equals(butOptions)) {\n+                // Make sure the game options dialog is editable.\n+                if (!clientgui.getGameOptionsDialog().isEditable()) {\n+                    clientgui.getGameOptionsDialog().setEditable(true);\n+                }\n+                // Display the game options dialog.\n+                clientgui.getGameOptionsDialog().update(clientgui.getClient().getGame().getOptions());\n+                clientgui.getGameOptionsDialog().setVisible(true);\n+                \n+            } else if (ev.getSource().equals(butCompact)) {\n+                toggleCompact();\n+                \n+            } else if (ev.getSource().equals(butLoadList)) {\n+                // Allow the player to replace their current\n+                // list of entities with a list from a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));  //$NON-NLS-2$\n+                    return;\n+                }\n+                clientgui.loadListFile(c.getLocalPlayer());\n+                \n+            } else if (ev.getSource().equals(butSaveList)) {\n+                // Allow the player to save their current\n+                // list of entities to a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));\n+                    return;\n+                }\n+                clientgui.saveListFile(c.getGame().getPlayerEntities(c.getLocalPlayer(), false),\n+                        c.getLocalPlayer().getName());\n+                \n+            } else if (ev.getSource().equals(butAddBot)) {\n+                BotConfigDialog bcd = new BotConfigDialog(clientgui.frame);\n+                bcd.setVisible(true);\n+                if (bcd.dialogAborted) {\n+                    return; // user didn't click 'ok', add no bot\n+                }\n+                if (clientgui.getBots().containsKey(bcd.getBotName())) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertExistsBot.title\"),\n+                            Messages.getString(\"ChatLounge.AlertExistsBot.message\"));  //$NON-NLS-2$\n+                } else {\n+                    BotClient c = bcd.getSelectedBot(clientgui.getClient().getHost(), clientgui.getClient().getPort());\n+                    c.setClientGUI(clientgui);\n+                    c.getGame().addGameListener(new BotGUI(c));\n+                    try {\n+                        c.connect();\n+                    } catch (Exception e) {\n+                        clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertBot.title\"),\n+                                Messages.getString(\"ChatLounge.AlertBot.message\"));  //$NON-NLS-2$\n+                    }\n+                    clientgui.getBots().put(bcd.getBotName(), c);\n+                }\n+                \n+            } else if (ev.getSource().equals(butRemoveBot)) {\n+                removeBot();\n+                \n+            } else if (ev.getSource().equals(butShowUnitID)) {\n+                PreferenceManager.getClientPreferences().setShowUnitId(butShowUnitID.isSelected());\n+                mekModel.refreshCells();\n+                repaint();\n+                \n+            } else if (ev.getSource() == butConditions) {\n+                PlanetaryConditionsDialog pcd = new PlanetaryConditionsDialog(clientgui);\n+                boolean userOkay = pcd.showDialog();\n+                if (userOkay) {\n+                    clientgui.getClient().sendPlanetaryConditions(pcd.getConditions());\n+                }\n+                \n+            } else if (ev.getSource() == butRandomMap) {\n+                RandomMapDialog rmd = new RandomMapDialog(clientgui.frame, ChatLounge.this, clientgui.getClient(), mapSettings);\n+                rmd.activateDialog(clientgui.getBoardView().getTilesetManager().getThemes());\n+                \n+            } else if (ev.getSource().equals(butBoardPreview)) {\n+                previewGameBoard();\n+                \n+            } else if (ev.getSource().equals(comMapSizes)) {\n+                if (comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"))) {\n+                    refreshMapUI();\n+                } else if (comMapSizes.getSelectedItem() != null) {\n+                    BoardDimensions size = (BoardDimensions) comMapSizes.getSelectedItem();\n+                    mapSettings.setBoardSize(size.width(), size.height());\n+                    resetAvailBoardSelection = true;\n+                    resetSelectedBoards = true;\n+                    clientgui.getClient().sendMapSettings(mapSettings);\n+                } \n+                \n+            } else if (ev.getSource() == butGroundMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_GROUND);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butSpaceMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_SPACE);\n+                mapSettings.setBoardSize(50, 50);\n+                mapSettings.setMapSize(1, 1);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butLowAtmoMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_ATMOSPHERE);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddX || ev.getSource() == butMapGrowW) {\n+                int newMapWidth = mapSettings.getMapWidth() + 1;\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddY || ev.getSource() == butMapGrowH) {\n+                int newMapHeight = mapSettings.getMapHeight() + 1;\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butSaveMapSetup) {\n+                saveMapSetup();\n+                \n+            } else if (ev.getSource() == butLoadMapSetup) {\n+                loadMapSetup();\n+                \n+            } else if (ev.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+                \n+            } else if (ev.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+                \n+            } else if (ev.getSource() == butMapShrinkW) {\n+                if (mapSettings.getMapWidth() > 1) {\n+                    int newMapWidth = mapSettings.getMapWidth() - 1;\n+                    mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butMapShrinkH) {\n+                if (mapSettings.getMapHeight() > 1) {\n+                    int newMapHeight = mapSettings.getMapHeight() - 1;\n+                    mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butDetach) {\n+                butDetach.setEnabled(false);\n+                panTeam.remove(panTeamOverview);\n+                panTeam.repaint();\n+                panTeamOverview.setDetached(true);\n+                teamOverviewWindow.add(panTeamOverview);\n+                teamOverviewWindow.center();\n+                teamOverviewWindow.setVisible(true);\n+                \n+            } else if (ev.getSource() == butCancelSearch) {\n+                fldSearch.setText(\"\");\n+\n+            } else if (ev.getSource() == butHelp) {\n+                File helpfile = new File(\"docs/Boards Stuff/MapAssemblyHelp.html\");\n+                final JDialog dialog = new ClientDialog(clientgui.frame, \"Map Assembly Help\", true, true);\n+                final int height = 600;\n+                final int width = 600;\n+                \n+                final JEditorPane pane = new JEditorPane();\n+                pane.setName(\"helpPane\");\n+                pane.setEditable(false);\n+                pane.setFont(new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1)));\n+                try {\n+                    pane.setPage(helpfile.toURI().toURL());\n+                    JScrollPane tScroll = new JScrollPane(pane,\n+                            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+                    tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+                    dialog.add(tScroll, BorderLayout.CENTER);\n+                } catch (Exception e) {\n+                    dialog.setTitle(Messages.getString(\"AbstractHelpDialog.noHelp.title\"));\n+                    pane.setText(Messages.getString(\"AbstractHelpDialog.errorReading\") + e.getMessage());\n+                    MegaMek.getLogger().error(e);\n+                }\n+\n+                JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+                button.addActionListener(e -> dialog.setVisible(false));\n+                JPanel okayPanel = new JPanel(new FlowLayout());\n+                okayPanel.add(button);\n+                dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+                Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+                dialog.setPreferredSize(sz);\n+                dialog.setVisible(true);\n+                \n+            } else if (ev.getSource() == butListView) {\n+                scrMekTable.setViewportView(mekTable);\n+                butCollapse.setEnabled(false);\n+                butExpand.setEnabled(false);\n+                \n+            } else if (ev.getSource() == butForceView) {\n+                scrMekTable.setViewportView(mekForceTree);\n+                butCollapse.setEnabled(true);\n+                butExpand.setEnabled(true);\n+                \n+            } else if (ev.getSource() == butCollapse) {\n+                collapseTree();\n+            } else if (ev.getSource() == butExpand) {\n+                expandTree();\n+            } \n+        }\n+    };\n+    \n+    /** Expands the Mek Force Tree fully. */\n+    private void expandTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.expandRow(i);\n+        }\n+    }\n+    \n+    /** Collapses the Mek Force Tree fully. */\n+    private void collapseTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.collapseRow(i);\n+        }\n+    }\n+    \n+    \n+    /** \n+     * Opens a file chooser and saves the current map setup to the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void saveMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.saveMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showSaveDialog(clientgui.frame);\n+        File selectedFile = fc.getSelectedFile();\n+        if (!selectedFile.getName().toLowerCase().endsWith(\".xml\")) {\n+            selectedFile = new File(selectedFile.getPath() + \".xml\");\n+        }\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (selectedFile == null)) {\n+            return;\n+        }\n+        if (selectedFile.exists()) {\n+            String msg = Messages.getString(\"ChatLounge.map.saveMapSetupReplace\", selectedFile.getName());\n+            if (!MMConfirmDialog.confirm(clientgui.frame, \"Confirm replace\", msg)) {\n+                return;\n+            }\n+        }\n+        try(OutputStream os = new FileOutputStream(selectedFile)) {\n+            MapSetup.save(os, mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while saving the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+\n+    /** \n+     * Opens a file chooser and loads a new map setup from the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void loadMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showOpenDialog(clientgui.frame);\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (fc.getSelectedFile() == null)) {\n+            return;\n+        }\n+        if (!fc.getSelectedFile().exists()) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \"File not found.\");\n+            return;\n+        }\n+        try(InputStream os = new FileInputStream(fc.getSelectedFile())) {\n+            MapSetup setup = MapSetup.load(os);\n+            mapSettings.setMapSize(setup.getMapWidth(), setup.getMapHeight());\n+            mapSettings.setBoardSize(setup.getBoardWidth(), setup.getBoardHeight());\n+            mapSettings.setBoardsSelectedVector(setup.getBoards());\n+            clientgui.getClient().sendMapSettings(mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while loading the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+    \n+    private void removeBot() {\n+        Client c = getSelectedClient();\n+        if (!client().bots.containsValue(c)) {\n+//        if ((c == null) || c.equals(clientgui.getClient())) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkyMzc4OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614923789", "bodyText": "Leftovers. Will remove.", "author": "SJuliez", "createdAt": "2021-04-16T15:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4ODA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4ODIyOQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612088229", "bodyText": "I really wish java had a TryParse method or something similar, so we wouldn't have to use exceptions for flow control.", "author": "NickAragua", "createdAt": "2021-04-13T02:42:40Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);\n+        \n+        // Planetary Conditions and Random Map Settings buttons\n+        FixedYPanel panSettings = new FixedYPanel();\n+        panSettings.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panSettings.add(butConditions);\n+        panSettings.add(butRandomMap);\n+//        panMap.add(panSettings);\n+\n+        FixedYPanel panTopRows = new FixedYPanel();\n+        panTopRows.setLayout(new BoxLayout(panTopRows, BoxLayout.PAGE_AXIS));\n+        panTopRows.add(panMapType);\n+        panTopRows.add(panSettings);\n+        \n+        JPanel panHelp = new JPanel(new GridLayout(1,1));\n+        panHelp.add(butHelp);\n+        \n+        FixedYPanel panTopRowsHelp = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 30, 5));\n+        panTopRowsHelp.add(panTopRows);\n+        panTopRowsHelp.add(panHelp);\n+        panMap.add(panTopRowsHelp);\n+        \n+        // Main part: Map Assembly\n+        panMap.add(panGroundMap);\n+\n+    }\n+\n+    /**\n+     * Sets up the ground map selection panel\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void setupMapAssembly() {\n+\n+        panGroundMap = new JPanel(new GridLayout(1, 1));\n+        panGroundMap.setBorder(new EmptyBorder(20, 10, 10, 10));\n+\n+        panMapButtons.setLayout(new BoxLayout(panMapButtons, BoxLayout.PAGE_AXIS));\n+        // Resize the preview buttons when the panel is resized\n+        panMapButtons.addComponentListener(new ComponentAdapter() {\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateMapButtons();\n+            }\n+        });\n+        \n+        panMapWidth.add(lblMapWidth);\n+        panMapWidth.add(butMapShrinkW);\n+        panMapWidth.add(fldMapWidth);\n+        panMapWidth.add(butMapGrowW);\n+        \n+        panMapHeight.add(lblMapHeight);\n+        panMapHeight.add(butMapShrinkH);\n+        panMapHeight.add(fldMapHeight);\n+        panMapHeight.add(butMapGrowH);\n+        \n+        panSpaceBoardWidth.add(lblSpaceBoardWidth);\n+        panSpaceBoardWidth.add(fldSpaceBoardWidth);\n+        panSpaceBoardWidth.setVisible(false);\n+        \n+        panSpaceBoardHeight.add(lblSpaceBoardHeight);\n+        panSpaceBoardHeight.add(fldSpaceBoardHeight);\n+        panSpaceBoardHeight.setVisible(false);\n+        \n+        FixedYPanel bottomPanel = new FixedYPanel();\n+        bottomPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n+        bottomPanel.add(butBoardPreview);\n+        bottomPanel.add(butSaveMapSetup);\n+        bottomPanel.add(butLoadMapSetup);\n+\n+        butBoardPreview.setToolTipText(Messages.getString(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+\n+        // The left side panel including the game map preview\n+        JPanel panMapPreview = new JPanel();\n+        panMapPreview.setLayout(new BoxLayout(panMapPreview, BoxLayout.PAGE_AXIS));\n+        \n+        panMapPreview.add(panMapWidth);\n+        panMapPreview.add(panMapHeight);\n+        panMapPreview.add(panSpaceBoardWidth);\n+        panMapPreview.add(panSpaceBoardHeight);\n+        panMapPreview.add(panMapButtons);\n+        panMapPreview.add(bottomPanel);\n+        \n+        // The right side panel including the list of available boards\n+        comMapSizes = new JComboBox<Comparable>();\n+        refreshMapSizes();\n+\n+        lisBoardsAvailable = new JList<String>(new DefaultListModel<String>());\n+        lisBoardsAvailable.setCellRenderer(new BoardNameRenderer());\n+        lisBoardsAvailable.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n+        lisBoardsAvailable.setVisibleRowCount(-1);\n+        lisBoardsAvailable.setDragEnabled(true);\n+        lisBoardsAvailable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        scrBoardsAvailable = new JScrollPane(lisBoardsAvailable);\n+        refreshBoardsAvailable();\n+        \n+        JPanel panAvail = new JPanel();\n+        panAvail.setLayout(new BoxLayout(panAvail, BoxLayout.PAGE_AXIS));\n+        panAvail.setBorder(new EmptyBorder(0, 20, 0, 0));\n+        panAvail.add(setupAvailTopPanel());\n+        panAvail.add(scrBoardsAvailable);\n+        \n+        // The splitpane holding the left and right side panels\n+        splGroundMap = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panMapPreview, panAvail);\n+        splGroundMap.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+            \n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+        });\n+        panGroundMap.add(splGroundMap);\n+\n+        // setup the board preview window.\n+        boardPreviewW = new ClientDialog(clientgui.frame, \n+                Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"), \n+                false);\n+        boardPreviewW.setLocationRelativeTo(clientgui.frame);\n+\n+        try {\n+            BoardView1 bv = new BoardView1(boardPreviewGame, null, null);\n+            bv.setDisplayInvalidHexInfo(false);\n+            bv.setUseLOSTool(false);\n+            boardPreviewW.add(bv.getComponent(true));\n+            boardPreviewW.setSize(clientgui.frame.getWidth()/2, clientgui.frame.getHeight()/2);\n+            // Most boards will be far too large on the standard zoom\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            boardPreviewW.center();\n+        } catch (IOException e) {\n+            JOptionPane.showMessageDialog(this,\n+                            Messages.getString(\"BoardEditor.CouldntInitialize\") + e,\n+                            Messages.getString(\"BoardEditor.FatalError\"), JOptionPane.ERROR_MESSAGE); \n+        }\n+        refreshMapButtons();\n+    }\n+    \n+    /** \n+     *  Sets up and returns the panel above the available boards list \n+     *  containing the search bar and the map size chooser.  \n+     */\n+    private JPanel setupAvailTopPanel() {\n+        FixedYPanel result = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 20, 2));\n+        result.setBorder(new EmptyBorder(5, 5, 5, 5));\n+        \n+        fldSearch.getDocument().addDocumentListener(new DocumentListener() {\n+            @Override\n+            public void changedUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void removeUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void insertUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+        });\n+        \n+        result.add(lblBoardSize);\n+        result.add(comMapSizes);\n+        result.add(new JLabel(\"    \"));\n+        result.add(lblSearch);\n+        result.add(fldSearch);\n+        result.add(butCancelSearch);\n+\n+        return result;\n+    }\n+    \n+    /** \n+     * Reacts to changes in the available boards search field, showing matching boards\n+     * for the search string when it has at least 3 characters\n+     * and reverting to all boards when the search string is empty.\n+     */\n+    private void updateSearch(String searchString) {\n+        if (searchString.isEmpty()) {\n+            refreshBoardsAvailable();\n+        } else if (searchString.length() > 2) {\n+            refreshBoardsAvailable(getSearchedItems(searchString));\n+        }\n+    }\n+    \n+    /** \n+     * Returns the available boards that match the given search string\n+     * (path or file name contains the search string.) \n+     */\n+    protected List<String> getSearchedItems(String searchString) {\n+        String lowerCaseSearchString = searchString.toLowerCase();\n+        return mapSettings.getBoardsAvailableVector().stream()\n+                .filter(b -> b.toLowerCase().contains(lowerCaseSearchString) && isBoardFile(b))\n+                .collect(Collectors.toList());\n+    }\n+    \n+    /** \n+     * Returns a suitable divider location for the splitpane that contains\n+     * the available boards list and the map preview. The divider location\n+     * gives between 30% and 50% of space to the map preview depending\n+     * on the width of the game map.\n+     */\n+    private double getDividerLocation() {\n+        double base = 0.3;\n+        int width = mapSettings.getBoardWidth() * mapSettings.getMapWidth();\n+        int height = mapSettings.getBoardHeight() * mapSettings.getMapHeight();\n+        int wAspect = Math.max(1, width / height + 1);\n+        return Math.min(base + wAspect * 0.05, 0.5);\n+    }\n+\n+    /** Updates the ground map type chooser (ground/atmosphere map). */\n+    private void refreshMapChoice() {\n+        // refresh UI possibly from a server update\n+        JToggleButton button = butGroundMap;\n+        if (mapSettings.getMedium() == MapSettings.MEDIUM_ATMOSPHERE) {\n+            button = butLowAtmoMap;\n+        } else if (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {\n+            button = butSpaceMap;\n+        }\n+        \n+        if (!button.isSelected()) {\n+            button.removeActionListener(lobbyListener);\n+            button.setSelected(true);\n+            button.addActionListener(lobbyListener);\n+        }\n+    }\n+    \n+    /** Updates the list of available map sizes. */\n+    private void refreshMapSizes() {\n+        int oldSelection = comMapSizes.getSelectedIndex();\n+        mapSizes = clientgui.getClient().getAvailableMapSizes();\n+        comMapSizes.removeActionListener(lobbyListener);\n+        comMapSizes.removeAllItems();\n+        for (BoardDimensions size : mapSizes) {\n+            comMapSizes.addItem(size);\n+        }\n+        comMapSizes.addItem(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        comMapSizes.setSelectedIndex(oldSelection != -1 ? oldSelection : 0);\n+        comMapSizes.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the map assembly UI from the current map settings. Does NOT trigger further\n+     * changes or result in packets to the server. \n+     */\n+    private void refreshMapUI() {\n+        boolean inSpace = mapSettings.getMedium() == MapSettings.MEDIUM_SPACE;\n+        boolean onGround = mapSettings.getMedium() == MapSettings.MEDIUM_GROUND;\n+        boolean customSize = comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        lisBoardsAvailable.setEnabled(!inSpace);\n+        mapIcons.clear();\n+        butConditions.setEnabled(!inSpace);\n+        fldSearch.setEnabled(!inSpace);\n+        butRandomMap.setEnabled(!inSpace);\n+        panMapHeight.setVisible(!inSpace);\n+        panMapWidth.setVisible(!inSpace);\n+        panSpaceBoardWidth.setVisible(inSpace || customSize);\n+        panSpaceBoardHeight.setVisible(inSpace || customSize);\n+        comMapSizes.setEnabled(!inSpace);\n+        lblSearch.setEnabled(!inSpace);\n+        lblBoardSize.setEnabled(!inSpace);\n+        butSaveMapSetup.setEnabled(!inSpace);\n+        butLoadMapSetup.setEnabled(!inSpace);\n+        butMapShrinkW.setEnabled(mapSettings.getMapWidth() > 1);\n+        butMapShrinkH.setEnabled(mapSettings.getMapHeight() > 1);\n+        \n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        if (onGround) {\n+            butGroundMap.setSelected(true);\n+        } else if (inSpace) {\n+            butSpaceMap.setSelected(true);\n+        } else {\n+            butLowAtmoMap.setSelected(true);\n+        }\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        fldMapWidth.setText(Integer.toString(mapSettings.getMapWidth()));\n+        fldMapHeight.setText(Integer.toString(mapSettings.getMapHeight()));\n+        fldSpaceBoardWidth.setText(Integer.toString(mapSettings.getBoardWidth()));\n+        fldSpaceBoardHeight.setText(Integer.toString(mapSettings.getBoardHeight()));\n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+    }\n+\n+    /** \n+     * Refreshes the list of available boards with all available boards plus\n+     * GENERATED. Useful for first setup, when the server transmits new\n+     * map settings and when the text search field is empty.\n+     */\n+    private void refreshBoardsAvailable() {\n+        if (!lisBoardsAvailable.isEnabled()) {\n+            return;\n+        }\n+        lisBoardsAvailable.setFixedCellHeight(-1);\n+        lisBoardsAvailable.setFixedCellWidth(-1);\n+        List<String> availBoards = new ArrayList<>(); \n+        availBoards.add(MapSettings.BOARD_GENERATED);\n+        availBoards.addAll(mapSettings.getBoardsAvailableVector());\n+        refreshBoardsAvailable(availBoards);\n+    }\n+    \n+    /** \n+     * Refreshes the list of available maps with the given list of boards. \n+     */\n+    private void refreshBoardsAvailable(List<String> boardList) {\n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        // Replace the data model (adding the elements one by one to the existing model\n+        // in Java 8 style is sluggish because of event firing)\n+        DefaultListModel<String> newModel = new DefaultListModel<>();\n+        for (String s: boardList) {\n+            newModel.addElement(s);\n+        }\n+        lisBoardsAvailable.setModel(newModel);\n+        lisBoardsAvailable.clearSelection();\n+        lisBoardsAvailable.addListSelectionListener(this);\n+    }\n+    \n+    public boolean isMultipleBoards() {\n+        return mapSettings.getMapHeight() * mapSettings.getMapWidth() > 1;\n+    }\n+    \n+    MapSettings oldMapSettings = MapSettings.getInstance();\n+\n+    /**\n+     * Fills the Map Buttons scroll pane twith the appropriate amount of buttons\n+     * in the appropriate layout\n+     */\n+    private void refreshMapButtons() {\n+        panMapButtons.removeAll();\n+        panMapButtons.setVisible(false);\n+        panMapButtons.add(Box.createVerticalGlue());\n+        Dimension buttonSize = null;\n+\n+        // If buttons are unused, remove their image so that they update when they're used once more\n+        if (mapSettings.getMapHeight() * mapSettings.getMapWidth() < mapButtons.size()) {\n+            for (MapPreviewButton button: mapButtons.subList(mapSettings.getMapHeight() * mapSettings.getMapWidth(), mapButtons.size())) {\n+                button.reset();\n+            }\n+        }\n+\n+        // Add new map preview buttons if the map has grown\n+        while (mapSettings.getMapHeight() * mapSettings.getMapWidth() > mapButtons.size()) {\n+            mapButtons.add(new MapPreviewButton(this));\n+        }\n+\n+        // Re-add the buttons to the panel and update them as necessary\n+        for (int i = 0; i < mapSettings.getMapHeight(); i++) {\n+            JPanel row = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n+            panMapButtons.add(row);\n+            for (int j = 0; j < mapSettings.getMapWidth(); j++) {\n+                int index = i * mapSettings.getMapWidth() + j;\n+                MapPreviewButton button = mapButtons.get(index);\n+                button.setIndex(index);\n+                row.add(button);\n+\n+                // Update the board base image if it's generated and the settings have changed\n+                // or the board name has changed\n+                String boardName = mapSettings.getBoardsSelectedVector().get(index);\n+                if (!button.getBoard().equals(boardName) \n+                        || oldMapSettings.getMedium() != mapSettings.getMedium()\n+                        || (!mapSettings.equalMapGenParameters(oldMapSettings) \n+                                && mapSettings.getMapWidth() == oldMapSettings.getMapWidth()\n+                                && mapSettings.getMapHeight() == oldMapSettings.getMapHeight())) {\n+                    IBoard buttonBoard; \n+                    Image image;\n+                    // Generated and space boards use a generated example\n+                    if (boardName.startsWith(MapSettings.BOARD_GENERATED) \n+                            || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                        buttonBoard = BoardUtilities.generateRandom(mapSettings);\n+                        image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                    } else { \n+                        String boardForImage = boardName;\n+                        // For a surprise board, just use the first board as example\n+                        if (boardName.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                            boardForImage = extractSurpriseMaps(boardName).get(0);\n+                        }\n+                        File boardFile = new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile();\n+                        if (boardFile.exists()) {\n+                            buttonBoard = new Board(16, 17);\n+                            buttonBoard.load(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile());\n+                            StringBuffer errs = new StringBuffer();\n+                            try (InputStream is = new FileInputStream(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile())) {\n+                                buttonBoard.load(is, errs, true);\n+                            } catch (IOException ex) {\n+                                buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            }\n+                            image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                        } else {\n+                            buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            BufferedImage emptyBoardMap = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                            markServerSideBoard(emptyBoardMap);\n+                            image = emptyBoardMap;\n+                        }\n+                    }\n+                    button.setImage(image, boardName);\n+                    buttonSize = optMapButtonSize(image);\n+                }\n+                button.scheduleRescale();\n+            }\n+        }\n+        oldMapSettings = MapSettings.getInstance(mapSettings);\n+        \n+        if (buttonSize != null) {\n+            for (MapPreviewButton button: mapButtons) {\n+                button.setPreviewSize(buttonSize);\n+            }\n+        }\n+        splGroundMap.setDividerLocation(getDividerLocation());\n+\n+        panMapButtons.add(Box.createVerticalGlue());\n+        panMapButtons.setVisible(true);\n+\n+        lblBoardsAvailable.setText(mapSettings.getBoardWidth() + \"x\" + mapSettings.getBoardHeight() + \" \"\n+                + Messages.getString(\"BoardSelectionDialog.mapsAvailable\"));\n+        comMapSizes.removeActionListener(lobbyListener);\n+        int items = comMapSizes.getItemCount();\n+\n+        boolean mapSizeSelected = false;\n+        for (int i = 0; i < (items - 1); i++) {\n+            BoardDimensions size = (BoardDimensions) comMapSizes.getItemAt(i);\n+\n+            if ((size.width() == mapSettings.getBoardWidth()) && (size.height() == mapSettings.getBoardHeight())) {\n+                comMapSizes.setSelectedIndex(i);\n+                mapSizeSelected = true;\n+            }\n+        }\n+        // If we didn't select a size, select the last item: 'Custom Size'\n+        if (!mapSizeSelected) {\n+            comMapSizes.setSelectedIndex(items - 1);\n+        }\n+        comMapSizes.addActionListener(lobbyListener);\n+\n+    }\n+    \n+    private void markServerSideBoard(BufferedImage image) {\n+        Graphics g = image.getGraphics();\n+        GUIPreferences.AntiAliasifSet(g);\n+        int w = image.getWidth();\n+        int h = image.getHeight();\n+        String text = \"Server-side board\";\n+        int fontSize = Math.min(w / 10, UIUtil.scaleForGUI(16));\n+        g.setFont(new Font(\"Dialog\", Font.ITALIC, fontSize));\n+        FontMetrics fm = g.getFontMetrics(g.getFont());\n+        int cx = (w - fm.stringWidth(text)) / 2;\n+        int cy = h / 10 + fm.getAscent();\n+        g.setColor(GUIPreferences.getInstance().getWarningColor());\n+        g.drawString(text, cx, cy);\n+        g.dispose();\n+    }\n+\n+    public void previewGameBoard() {\n+        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);\n+        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];\n+        List<Boolean> rotateBoard = new ArrayList<>();\n+        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings.getMapHeight()); i++) {\n+            sheetBoards[i] = new Board();\n+            String name = mapSettings.getBoardsSelectedVector().get(i);\n+            if (name.startsWith(MapSettings.BOARD_GENERATED) \n+                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);\n+            } else {\n+                if (name.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                    List<String> boardList = extractSurpriseMaps(name);\n+                    int rnd = (int)(Math.random() * boardList.size());\n+                    name = boardList.get(rnd);\n+                }\n+                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name + \".board\").getFile());\n+            }\n+        }\n+\n+        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(), mapSettings.getMapWidth(),\n+                mapSettings.getMapHeight(), sheetBoards, rotateBoard, mapSettings.getMedium());\n+        \n+        boardPreviewGame.setBoard(newBoard);\n+        boardPreviewW.setVisible(true);\n+    }\n+\n+    /**\n+     * Refreshes the game settings with new info from the client\n+     */\n+    private void refreshGameSettings() {\n+        refreshTeams();\n+        refreshDoneButton();\n+    }\n+    \n+    /**\n+     * Refreshes the Mek Table contents \n+     */\n+    public void refreshEntities() {\n+        refreshTree();\n+        refreshMekTable();\n+    }\n+    \n+    private void refreshMekTable() {\n+        List<Integer> enIds = getSelectedEntities().stream().map(e -> e.getId()).collect(toList());\n+        mekModel.clearData();\n+        ArrayList<Entity> allEntities = new ArrayList<Entity>(clientgui.getClient().getEntitiesVector());\n+        Collections.sort(allEntities, activeSorter);\n+\n+        boolean localUnits = false;\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        for (Entity entity : allEntities) {\n+            // Remember if the local player has units.\n+            if (!localUnits && entity.getOwner().equals(localPlayer())) {\n+                localUnits = true;\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_PILOT_ADVANTAGES)) { \n+                entity.getCrew().clearOptions(PilotOptions.LVL3_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.EDGE)) { \n+                entity.getCrew().clearOptions(PilotOptions.EDGE_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_MANEI_DOMINI)) { \n+                entity.getCrew().clearOptions(PilotOptions.MD_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS)) { \n+                entity.clearPartialRepairs();\n+            }\n+            \n+            // Remove some deployment options when a unit is carried\n+            if (entity.getTransportId() != Entity.NONE) { \n+                entity.setHidden(false);\n+                entity.setProne(false);\n+                entity.setHullDown(false);\n+            }\n+            \n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) { \n+                entity.setHidden(false);\n+            }\n+            \n+            // Handle the \"Blind Drop\" option. In blind drop, units must be added\n+            // but they will be obscured in the table. In real blind drop, units\n+            // don't even get added to the table. Teams see their units in any case.\n+            boolean localUnit = entity.getOwner().equals(localPlayer());\n+            boolean teamUnit = !entity.getOwner().isEnemyOf(localPlayer());\n+            boolean realBlindDrop = opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+            if (localUnit || teamUnit || !realBlindDrop) {\n+                mekModel.addUnit(entity);\n+            }\n+        }\n+        // Restore selection\n+        if (!enIds.isEmpty()) {\n+            for (int i = 0; i < mekTable.getRowCount(); i++) {\n+                if (enIds.contains(mekModel.getEntityAt(i).getId())) {\n+                    mekTable.addRowSelectionInterval(i, i);\n+                }\n+            }\n+        }\n+\n+        // Enable the \"Save Unit List...\" button if the local player has units.\n+        clientgui.getMenuBar().setUnitList(localUnits);\n+    }\n+    \n+    /** Adjusts the mektable to compact/normal mode. */\n+    private void toggleCompact() {\n+        setTableRowHeights();\n+        mekModel.refreshCells();\n+        mekForceTreeModel.nodeChanged((TreeNode)mekForceTreeModel.getRoot());\n+        \n+    }\n+\n+    /** Refreshes the player info table. */\n+    private void refreshPlayerTable() {\n+        // Remember the selected players\n+        var selPlayerIds = getselectedPlayers().stream().map(IPlayer::getId).collect(toSet());\n+\n+        // Empty and refill the player table\n+        playerModel.replaceData(game().getPlayersVector());\n+\n+        // re-select the previously selected players, if possible\n+        for (int row = 0; row < playerModel.getRowCount(); row++) {\n+            if (selPlayerIds.contains(playerModel.getPlayerAt(row).getId())) {\n+                tablePlayers.addRowSelectionInterval(row, row);\n+            }\n+        }\n+    }\n+\n+    /** Updates the camo button to displays the camo of the currently selected player. */ \n+    private void refreshCamoButton() {\n+        if ((tablePlayers == null) || (playerModel == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (player != null) {\n+            butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        }\n+    }\n+\n+    /** Sets up the team choice box. */\n+    private void setupTeamCombo() {\n+        for (int i = 0; i < IPlayer.MAX_TEAMS; i++) {\n+            comboTeam.addItem(IPlayer.teamNames[i]);\n+        }\n+    }\n+\n+    /** Updates the team choice combobox to show the selected player's team. */\n+    private void refreshTeams() {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(localPlayer().getTeam());\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the Done button. The label will say the opposite of the\n+     * player's \"done\" status, indicating that clicking it will reverse the\n+     * condition.\n+     */\n+    private void refreshDoneButton(boolean done) {\n+        butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n+    }\n+\n+    /** Refreshes the state of the Done button with the state of the local player. */\n+    private void refreshDoneButton() {\n+        refreshDoneButton(localPlayer().isDone());\n+    }\n+\n+    /**\n+     * Embarks the given carried Entity onto the carrier given as carrierId.\n+     */\n+    void loadOnto(Entity carried, int carrierId, int bayNumber) {\n+        Entity carrier = game().getEntity(carrierId);\n+        if (carrier == null || !isLoadable(carried, carrier)) {\n+            return;\n+        }\n+\n+        // We need to make sure our current bomb choices fit onto the new\n+        // fighter\n+        if (carrier instanceof FighterSquadron) {\n+            FighterSquadron fSquad = (FighterSquadron) carrier;\n+            // We can't use Aero.getBombPoints() because the bombs haven't been\n+            // loaded yet, only selected, so we have to count the choices\n+            int[] bombChoice = fSquad.getBombChoices();\n+            int numLoadedBombs = 0;\n+            for (int i = 0; i < bombChoice.length; i++) {\n+                numLoadedBombs += bombChoice[i];\n+            }\n+            // We can't load all of the squadrons bombs\n+            if (numLoadedBombs > ((IBomber)carried).getMaxBombPoints()) {\n+                JOptionPane.showMessageDialog(clientgui.frame, Messages.getString(\"FighterSquadron.bomberror\"),\n+                        Messages.getString(\"FighterSquadron.error\"), JOptionPane.ERROR_MESSAGE);\n+                return;\n+            }\n+        }\n+        \n+        getLocalClient(carried).sendLoadEntity(carried.getId(), carrierId, bayNumber);\n+        // TODO: it would probably be a good idea \n+        // to disable some settings for loaded units in customMechDialog\n+    }\n+\n+    /** \n+     * Have the given entity disembark if it is carried by another unit.\n+     * Entities that are modified and need an update to be sent to the server\n+     * are added to the given updateCandidates. \n+     */\n+    void disembark(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = game().getEntity(entity.getTransportId());\n+        if (carrier != null) {\n+            carrier.unload(entity);\n+            entity.setTransportId(Entity.NONE);\n+            updateCandidates.add(entity);\n+            updateCandidates.add(carrier);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity disembark if it is carried by a unit of another player.\n+     * Entities that were modified and need an update to be sent to the server\n+     * are added to the given updateCandidate set. \n+     */\n+    void disembarkDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = clientgui.getClient().getGame().getEntity(entity.getTransportId());\n+        if (carrier != null && (ownerOf(entity) != ownerOf(carrier))) {\n+            disembark(entity, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entities offload all the units they are carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadAll(Collection<Entity> entities, Collection<Entity> updateCandidates) {\n+        for (Entity carrier: editableEntities(entities)) {\n+            offloadFrom(carrier, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all the units it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFrom(Entity entity, Collection<Entity> updateCandidates) {\n+        if (isEditable(entity)) {\n+            for (Entity carriedUnit: entity.getLoadedUnits()) {\n+                disembark(carriedUnit, updateCandidates);\n+            } \n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all units of different players it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFromDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        for (Entity carriedUnit: entity.getLoadedUnits()) {\n+            if (ownerOf(carriedUnit) != ownerOf(entity)) {\n+                disembark(carriedUnit, updateCandidates);\n+            }\n+        } \n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. \n+     */\n+    void sendUpdate(Collection<Entity> updateCandidates) {\n+        for (Entity e: editableEntities(updateCandidates)) {\n+            getLocalClient(e).sendUpdateEntity(e);\n+        }\n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. Will separate the units into update\n+     * packets for the local player and any local bots so that the \n+     * server accepts all changes (as the server does not know of\n+     * local bots and rejects updates that are not for the sending client\n+     * or its teammates. \n+     */\n+    void sendUpdates(Collection<Entity> entities) {\n+        List<IPlayer> owners = entities.stream().map(e -> e.getOwner()).distinct().collect(toList());\n+        for (IPlayer owner: owners) {\n+            client().sendUpdateEntity(new ArrayList<Entity>(\n+                    entities.stream().filter(e -> e.getOwner().equals(owner)).collect(toList())));\n+        }\n+    }\n+    \n+    /** \n+     * Disembarks all given entities from any transports they are in. \n+     */\n+    void disembarkAll(Collection<Entity> entities) {\n+        Set<Entity> updateCandidates = new HashSet<>();\n+        entities.stream().filter(e -> isEditable(e)).forEach(e -> disembark(e, updateCandidates));\n+        sendUpdate(updateCandidates);\n+    }\n+\n+    /** \n+     * Returns true when the given entity may be configured by the local player,\n+     * i.e. if it is his own unit or one of his bot's units.\n+     * <P>Note that this is more restrictive than the Server is. The Server\n+     * accepts entity changes also for teammates so that entity updates that \n+     * signal transporting a teammate's unit don't get rejected. I feel that\n+     * configuration other than transporting units should be limited to one's\n+     * own units (and bots) though.\n+     */\n+    boolean isEditable(Entity entity) {\n+        return clientgui.getBots().containsKey(entity.getOwner().getName())\n+                || (entity.getOwnerId() == localPlayer().getId());\n+    }\n+    \n+    /** \n+     * Returns true when the given entity may NOT be configured by the local player,\n+     * i.e. if it is not own unit or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isNotEditable(Entity entity) {\n+        return !isEditable(entity);\n+    }\n+    \n+    /** \n+     * Returns true when all given entities may be configured by the local player,\n+     * i.e. if they are his own units or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isEditable(Collection<Entity> entities) {\n+        return !entities.stream().anyMatch(this::isNotEditable);\n+    }\n+    \n+    /** \n+     * Returns the Client associated with a given entity that may be configured\n+     * by the local player (his own unit or one of his bot's units).\n+     * For a unit that cannot be configured (owned by a remote player) the client\n+     * of the local player is returned.\n+     */\n+    Client getLocalClient(Entity entity) {\n+        if (clientgui.getBots().containsKey(entity.getOwner().getName())) {\n+            return clientgui.getBots().get(entity.getOwner().getName());\n+        } else {\n+            return clientgui.getClient();\n+        }\n+    }\n+\n+    public void configPlayer() {\n+        Client c = getSelectedClient();\n+        if (null == c) {\n+            return;\n+        }\n+        \n+        PlayerSettingsDialog psd = new PlayerSettingsDialog(clientgui, c);\n+        boolean okay = psd.showDialog();\n+        \n+        if (okay) {\n+            IPlayer player = c.getLocalPlayer();\n+            player.setConstantInitBonus(psd.getInit());\n+            player.setNbrMFConventional(psd.getCnvMines());\n+            player.setNbrMFVibra(psd.getVibMines());\n+            player.setNbrMFActive(psd.getActMines());\n+            player.setNbrMFInferno(psd.getInfMines());\n+            var rsg = c.getRandomSkillsGenerator();\n+            rsg.setMethod(psd.getMethod());\n+            rsg.setType(psd.getPilot());\n+            rsg.setLevel(psd.getXP());\n+            rsg.setClose(psd.getForceGP());\n+            \n+            // The deployment position\n+            int startPos = psd.getStartPos();\n+            final GameOptions gOpts = clientgui.getClient().getGame().getOptions();\n+            if (gOpts.booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                    && (startPos >= 1) && (startPos <= 9)) {\n+                startPos += 10;\n+            }\n+            c.getLocalPlayer().setStartingPos(startPos);\n+            c.sendPlayerInfo();\n+            \n+            // If the gameoption set_arty_player_homeedge is set, adjust the player's offboard \n+            // arty units to be behind the newly selected home edge.\n+            OffBoardDirection direction = OffBoardDirection.translateStartPosition(startPos);\n+            if (direction != OffBoardDirection.NONE && \n+                    gOpts.booleanOption(OptionsConstants.BASE_SET_ARTY_PLAYER_HOMEEDGE)) {\n+                for (Entity entity: c.getGame().getPlayerEntities(c.getLocalPlayer(), false)) {\n+                    if (entity.getOffBoardDirection() != OffBoardDirection.NONE) {\n+                        entity.setOffBoard(entity.getOffBoardDistance(), direction);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    \n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechReadoutAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechReadout(entity, index++);\n+        }\n+    } \n+\n+    /** \n+     * Shows the unit summary for the given unit. Moves the dialog a bit depending on index\n+     * so that multiple dialogs dont appear exactly on top of each other. \n+     */\n+    private void mechReadout(Entity entity, int index) {\n+        final ClientDialog dialog = new ClientDialog(clientgui.frame, Messages.getString(\"ChatLounge.quickView\"), false, true);\n+        final int height = 600;\n+        final int width = 500;\n+\n+        MechView mv = new MechView(entity, false);\n+        // The label must want a fixed width to enforce linebreaks on fluff text\n+        JLabel mechSummary = new JLabel(\"<HTML>\" + mv.getMechReadoutHead()\n+        + mv.getMechReadoutBasic() + mv.getMechReadoutLoadout()\n+        + mv.getMechReadoutFluff()) {\n+            private static final long serialVersionUID = 2989361635430008853L;\n+            @Override\n+            public Dimension getPreferredSize() {\n+                return new Dimension(width - 10, super.getPreferredSize().height);\n+            }\n+        };\n+        mechSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(mechSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.center();\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechBVAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechBVDisplay(entity, index++);\n+        }\n+    } \n+    \n+    /**\n+     * @param entity the entity to display the BV Calculation for\n+     */\n+    void mechBVDisplay(Entity entity, int index) {\n+        final JDialog dialog = new ClientDialog(clientgui.frame, \"BV Calculation Display\", false, true);\n+        final int height = 600;\n+        \n+        entity.calculateBattleValue();\n+        JLabel bvSummary = new JLabel(entity.getBVText());\n+        bvSummary.setFont(new Font(\"Dialog\",Font.PLAIN, scaleForGUI(14)));\n+        bvSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(bvSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(bvSummary.getPreferredSize().width + 40, scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /**\n+     * Pop up the dialog to load a mech\n+     */\n+    private void addUnit() {\n+        clientgui.getMechSelectorDialog().updateOptionValues();\n+        clientgui.getMechSelectorDialog().setVisible(true);\n+    }\n+    \n+    private void createArmy() {\n+        clientgui.getRandomArmyDialog().setVisible(true);\n+    }\n+\n+    public void loadRandomSkills() {\n+        clientgui.getRandomSkillDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    public void loadRandomNames() {\n+        clientgui.getRandomNameDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    void changeMapDnD(String board, JButton button) {\n+        if (board.contains(\"\\n\")) {\n+            board = MapSettings.BOARD_SURPRISE + board;\n+        }\n+        mapSettings.getBoardsSelectedVector().set(mapButtons.indexOf(button), board);\n+        clientgui.getClient().sendMapSettings(mapSettings);\n+        if (boardPreviewW.isVisible()) {\n+            previewGameBoard();\n+        }\n+    }\n+    \n+    \n+\n+    //\n+    // GameListener\n+    //\n+    @Override\n+    public void gamePlayerChange(GamePlayerChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshDoneButton();\n+        clientgui.getClient().getGame().setupTeams();\n+        refreshPlayerTable();\n+        refreshPlayerConfig();\n+        refreshCamoButton();\n+        refreshEntities();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gamePhaseChange(GamePhaseChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        \n+        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {\n+            refreshDoneButton();\n+            refreshGameSettings();\n+            refreshPlayerTable();\n+            refreshTeams();\n+            refreshCamoButton();\n+            refreshEntities();\n+            panTeamOverview.refreshData();\n+        }\n+    }\n+\n+    @Override\n+    public void gameEntityNew(GameEntityNewEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameSettingsChange(GameSettingsChangeEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshGameSettings();\n+        // The table sorting may no longer be allowed (e.g. when blind drop was activated)\n+        if (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())) {\n+            nextSorter(unitSorters);\n+            updateTableHeaders();\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        refreshMapSizes();\n+        updateMapSettings(clientgui.getClient().getMapSettings());\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameClientFeedbackRequest(GameCFREvent evt) {\n+        // Do nothing\n+    }\n+\n+    \n+    private ActionListener lobbyListener = new ActionListener() {\n+\n+        @Override\n+        public void actionPerformed(ActionEvent ev) {\n+\n+            // Are we ignoring events?\n+            if (isIgnoringEvents()) {\n+                return;\n+            }\n+            \n+            if (ev.getSource().equals(butAdd)) {\n+                addUnit();\n+                \n+            } else if (ev.getSource().equals(butArmy)) {\n+                createArmy();\n+                \n+            } else if (ev.getSource().equals(butSkills)) {\n+                loadRandomSkills();\n+                \n+            } else if (ev.getSource().equals(butNames)) {\n+                loadRandomNames();\n+                \n+            } else if (ev.getSource().equals(tablePlayers)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(comboTeam)) {\n+                lobbyActions.changeTeam(getselectedPlayers(), comboTeam.getSelectedIndex());\n+                \n+            } else if (ev.getSource().equals(butConfigPlayer)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(butBotSettings)) {\n+                doBotSettings();\n+                \n+            } else if (ev.getSource().equals(butOptions)) {\n+                // Make sure the game options dialog is editable.\n+                if (!clientgui.getGameOptionsDialog().isEditable()) {\n+                    clientgui.getGameOptionsDialog().setEditable(true);\n+                }\n+                // Display the game options dialog.\n+                clientgui.getGameOptionsDialog().update(clientgui.getClient().getGame().getOptions());\n+                clientgui.getGameOptionsDialog().setVisible(true);\n+                \n+            } else if (ev.getSource().equals(butCompact)) {\n+                toggleCompact();\n+                \n+            } else if (ev.getSource().equals(butLoadList)) {\n+                // Allow the player to replace their current\n+                // list of entities with a list from a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));  //$NON-NLS-2$\n+                    return;\n+                }\n+                clientgui.loadListFile(c.getLocalPlayer());\n+                \n+            } else if (ev.getSource().equals(butSaveList)) {\n+                // Allow the player to save their current\n+                // list of entities to a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));\n+                    return;\n+                }\n+                clientgui.saveListFile(c.getGame().getPlayerEntities(c.getLocalPlayer(), false),\n+                        c.getLocalPlayer().getName());\n+                \n+            } else if (ev.getSource().equals(butAddBot)) {\n+                BotConfigDialog bcd = new BotConfigDialog(clientgui.frame);\n+                bcd.setVisible(true);\n+                if (bcd.dialogAborted) {\n+                    return; // user didn't click 'ok', add no bot\n+                }\n+                if (clientgui.getBots().containsKey(bcd.getBotName())) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertExistsBot.title\"),\n+                            Messages.getString(\"ChatLounge.AlertExistsBot.message\"));  //$NON-NLS-2$\n+                } else {\n+                    BotClient c = bcd.getSelectedBot(clientgui.getClient().getHost(), clientgui.getClient().getPort());\n+                    c.setClientGUI(clientgui);\n+                    c.getGame().addGameListener(new BotGUI(c));\n+                    try {\n+                        c.connect();\n+                    } catch (Exception e) {\n+                        clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertBot.title\"),\n+                                Messages.getString(\"ChatLounge.AlertBot.message\"));  //$NON-NLS-2$\n+                    }\n+                    clientgui.getBots().put(bcd.getBotName(), c);\n+                }\n+                \n+            } else if (ev.getSource().equals(butRemoveBot)) {\n+                removeBot();\n+                \n+            } else if (ev.getSource().equals(butShowUnitID)) {\n+                PreferenceManager.getClientPreferences().setShowUnitId(butShowUnitID.isSelected());\n+                mekModel.refreshCells();\n+                repaint();\n+                \n+            } else if (ev.getSource() == butConditions) {\n+                PlanetaryConditionsDialog pcd = new PlanetaryConditionsDialog(clientgui);\n+                boolean userOkay = pcd.showDialog();\n+                if (userOkay) {\n+                    clientgui.getClient().sendPlanetaryConditions(pcd.getConditions());\n+                }\n+                \n+            } else if (ev.getSource() == butRandomMap) {\n+                RandomMapDialog rmd = new RandomMapDialog(clientgui.frame, ChatLounge.this, clientgui.getClient(), mapSettings);\n+                rmd.activateDialog(clientgui.getBoardView().getTilesetManager().getThemes());\n+                \n+            } else if (ev.getSource().equals(butBoardPreview)) {\n+                previewGameBoard();\n+                \n+            } else if (ev.getSource().equals(comMapSizes)) {\n+                if (comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"))) {\n+                    refreshMapUI();\n+                } else if (comMapSizes.getSelectedItem() != null) {\n+                    BoardDimensions size = (BoardDimensions) comMapSizes.getSelectedItem();\n+                    mapSettings.setBoardSize(size.width(), size.height());\n+                    resetAvailBoardSelection = true;\n+                    resetSelectedBoards = true;\n+                    clientgui.getClient().sendMapSettings(mapSettings);\n+                } \n+                \n+            } else if (ev.getSource() == butGroundMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_GROUND);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butSpaceMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_SPACE);\n+                mapSettings.setBoardSize(50, 50);\n+                mapSettings.setMapSize(1, 1);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butLowAtmoMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_ATMOSPHERE);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddX || ev.getSource() == butMapGrowW) {\n+                int newMapWidth = mapSettings.getMapWidth() + 1;\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddY || ev.getSource() == butMapGrowH) {\n+                int newMapHeight = mapSettings.getMapHeight() + 1;\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butSaveMapSetup) {\n+                saveMapSetup();\n+                \n+            } else if (ev.getSource() == butLoadMapSetup) {\n+                loadMapSetup();\n+                \n+            } else if (ev.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+                \n+            } else if (ev.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+                \n+            } else if (ev.getSource() == butMapShrinkW) {\n+                if (mapSettings.getMapWidth() > 1) {\n+                    int newMapWidth = mapSettings.getMapWidth() - 1;\n+                    mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butMapShrinkH) {\n+                if (mapSettings.getMapHeight() > 1) {\n+                    int newMapHeight = mapSettings.getMapHeight() - 1;\n+                    mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butDetach) {\n+                butDetach.setEnabled(false);\n+                panTeam.remove(panTeamOverview);\n+                panTeam.repaint();\n+                panTeamOverview.setDetached(true);\n+                teamOverviewWindow.add(panTeamOverview);\n+                teamOverviewWindow.center();\n+                teamOverviewWindow.setVisible(true);\n+                \n+            } else if (ev.getSource() == butCancelSearch) {\n+                fldSearch.setText(\"\");\n+\n+            } else if (ev.getSource() == butHelp) {\n+                File helpfile = new File(\"docs/Boards Stuff/MapAssemblyHelp.html\");\n+                final JDialog dialog = new ClientDialog(clientgui.frame, \"Map Assembly Help\", true, true);\n+                final int height = 600;\n+                final int width = 600;\n+                \n+                final JEditorPane pane = new JEditorPane();\n+                pane.setName(\"helpPane\");\n+                pane.setEditable(false);\n+                pane.setFont(new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1)));\n+                try {\n+                    pane.setPage(helpfile.toURI().toURL());\n+                    JScrollPane tScroll = new JScrollPane(pane,\n+                            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+                    tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+                    dialog.add(tScroll, BorderLayout.CENTER);\n+                } catch (Exception e) {\n+                    dialog.setTitle(Messages.getString(\"AbstractHelpDialog.noHelp.title\"));\n+                    pane.setText(Messages.getString(\"AbstractHelpDialog.errorReading\") + e.getMessage());\n+                    MegaMek.getLogger().error(e);\n+                }\n+\n+                JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+                button.addActionListener(e -> dialog.setVisible(false));\n+                JPanel okayPanel = new JPanel(new FlowLayout());\n+                okayPanel.add(button);\n+                dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+                Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+                dialog.setPreferredSize(sz);\n+                dialog.setVisible(true);\n+                \n+            } else if (ev.getSource() == butListView) {\n+                scrMekTable.setViewportView(mekTable);\n+                butCollapse.setEnabled(false);\n+                butExpand.setEnabled(false);\n+                \n+            } else if (ev.getSource() == butForceView) {\n+                scrMekTable.setViewportView(mekForceTree);\n+                butCollapse.setEnabled(true);\n+                butExpand.setEnabled(true);\n+                \n+            } else if (ev.getSource() == butCollapse) {\n+                collapseTree();\n+            } else if (ev.getSource() == butExpand) {\n+                expandTree();\n+            } \n+        }\n+    };\n+    \n+    /** Expands the Mek Force Tree fully. */\n+    private void expandTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.expandRow(i);\n+        }\n+    }\n+    \n+    /** Collapses the Mek Force Tree fully. */\n+    private void collapseTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.collapseRow(i);\n+        }\n+    }\n+    \n+    \n+    /** \n+     * Opens a file chooser and saves the current map setup to the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void saveMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.saveMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showSaveDialog(clientgui.frame);\n+        File selectedFile = fc.getSelectedFile();\n+        if (!selectedFile.getName().toLowerCase().endsWith(\".xml\")) {\n+            selectedFile = new File(selectedFile.getPath() + \".xml\");\n+        }\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (selectedFile == null)) {\n+            return;\n+        }\n+        if (selectedFile.exists()) {\n+            String msg = Messages.getString(\"ChatLounge.map.saveMapSetupReplace\", selectedFile.getName());\n+            if (!MMConfirmDialog.confirm(clientgui.frame, \"Confirm replace\", msg)) {\n+                return;\n+            }\n+        }\n+        try(OutputStream os = new FileOutputStream(selectedFile)) {\n+            MapSetup.save(os, mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while saving the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+\n+    /** \n+     * Opens a file chooser and loads a new map setup from the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void loadMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showOpenDialog(clientgui.frame);\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (fc.getSelectedFile() == null)) {\n+            return;\n+        }\n+        if (!fc.getSelectedFile().exists()) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \"File not found.\");\n+            return;\n+        }\n+        try(InputStream os = new FileInputStream(fc.getSelectedFile())) {\n+            MapSetup setup = MapSetup.load(os);\n+            mapSettings.setMapSize(setup.getMapWidth(), setup.getMapHeight());\n+            mapSettings.setBoardSize(setup.getBoardWidth(), setup.getBoardHeight());\n+            mapSettings.setBoardsSelectedVector(setup.getBoards());\n+            clientgui.getClient().sendMapSettings(mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while loading the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+    \n+    private void removeBot() {\n+        Client c = getSelectedClient();\n+        if (!client().bots.containsValue(c)) {\n+//        if ((c == null) || c.equals(clientgui.getClient())) {\n+//            clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+//                    Messages.getString(\"ChatLounge.SelectBo\"));\n+            LobbyErrors.showOnlyOwnBot(clientgui.frame);\n+            return;\n+        }\n+        // Delete units first, which safely disembarks and offloads them\n+        // Don't delete the bot's forces, as that could also delete other players' entitites\n+//        lobbyActions.delete(new ArrayList<>(), game().getPlayerEntities(c.getLocalPlayer(), false), false);\n+        c.die();\n+        clientgui.getBots().remove(c.getName());\n+    }\n+    \n+    private void doBotSettings() {\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        BotClient bot = (BotClient) clientgui.getBots().get(player.getName());\n+        BotConfigDialog bcd = new BotConfigDialog(clientgui.frame, bot);\n+        bcd.setVisible(true);\n+\n+        if (bcd.dialogAborted) {\n+            return; // user didn't click 'ok', add no bot\n+        } else if (bot instanceof Princess) {\n+            ((Princess) bot).setBehaviorSettings(bcd.getBehaviorSettings());\n+            \n+            // bookkeeping:\n+            clientgui.getBots().remove(player.getName());\n+            bot.setName(bcd.getBotName());\n+            clientgui.getBots().put(bot.getName(), bot);\n+            player.setName(bcd.getBotName());\n+            clientgui.chatlounge.refreshPlayerTable();\n+        }\n+    }\n+    \n+    // Put a filter on the files that the user can select the proper file.\n+    FileFilter XMLFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return (f.getPath().toLowerCase().endsWith(\".xml\") || f.isDirectory());\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Map Setup XML files\";\n+        }\n+    };\n+    \n+    private void setManualMapWidth() {\n+        try {\n+            int newMapWidth = Integer.parseInt(fldMapWidth.getText());\n+            if (newMapWidth >= 1 && newMapWidth <= 20) {\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map width", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkyOTExOQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r614929119", "bodyText": "you mean like boolean tryParse(String source, Object resultValue) {}? It would help if Java could handle return tupels. (Or anything else C# added in the last few years :-) )", "author": "SJuliez", "createdAt": "2021-04-16T15:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4ODIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4ODY5MQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612088691", "bodyText": "Can we get these magic strings converted to constants?", "author": "NickAragua", "createdAt": "2021-04-13T02:44:18Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);\n+        \n+        // Planetary Conditions and Random Map Settings buttons\n+        FixedYPanel panSettings = new FixedYPanel();\n+        panSettings.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panSettings.add(butConditions);\n+        panSettings.add(butRandomMap);\n+//        panMap.add(panSettings);\n+\n+        FixedYPanel panTopRows = new FixedYPanel();\n+        panTopRows.setLayout(new BoxLayout(panTopRows, BoxLayout.PAGE_AXIS));\n+        panTopRows.add(panMapType);\n+        panTopRows.add(panSettings);\n+        \n+        JPanel panHelp = new JPanel(new GridLayout(1,1));\n+        panHelp.add(butHelp);\n+        \n+        FixedYPanel panTopRowsHelp = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 30, 5));\n+        panTopRowsHelp.add(panTopRows);\n+        panTopRowsHelp.add(panHelp);\n+        panMap.add(panTopRowsHelp);\n+        \n+        // Main part: Map Assembly\n+        panMap.add(panGroundMap);\n+\n+    }\n+\n+    /**\n+     * Sets up the ground map selection panel\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void setupMapAssembly() {\n+\n+        panGroundMap = new JPanel(new GridLayout(1, 1));\n+        panGroundMap.setBorder(new EmptyBorder(20, 10, 10, 10));\n+\n+        panMapButtons.setLayout(new BoxLayout(panMapButtons, BoxLayout.PAGE_AXIS));\n+        // Resize the preview buttons when the panel is resized\n+        panMapButtons.addComponentListener(new ComponentAdapter() {\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateMapButtons();\n+            }\n+        });\n+        \n+        panMapWidth.add(lblMapWidth);\n+        panMapWidth.add(butMapShrinkW);\n+        panMapWidth.add(fldMapWidth);\n+        panMapWidth.add(butMapGrowW);\n+        \n+        panMapHeight.add(lblMapHeight);\n+        panMapHeight.add(butMapShrinkH);\n+        panMapHeight.add(fldMapHeight);\n+        panMapHeight.add(butMapGrowH);\n+        \n+        panSpaceBoardWidth.add(lblSpaceBoardWidth);\n+        panSpaceBoardWidth.add(fldSpaceBoardWidth);\n+        panSpaceBoardWidth.setVisible(false);\n+        \n+        panSpaceBoardHeight.add(lblSpaceBoardHeight);\n+        panSpaceBoardHeight.add(fldSpaceBoardHeight);\n+        panSpaceBoardHeight.setVisible(false);\n+        \n+        FixedYPanel bottomPanel = new FixedYPanel();\n+        bottomPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n+        bottomPanel.add(butBoardPreview);\n+        bottomPanel.add(butSaveMapSetup);\n+        bottomPanel.add(butLoadMapSetup);\n+\n+        butBoardPreview.setToolTipText(Messages.getString(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+\n+        // The left side panel including the game map preview\n+        JPanel panMapPreview = new JPanel();\n+        panMapPreview.setLayout(new BoxLayout(panMapPreview, BoxLayout.PAGE_AXIS));\n+        \n+        panMapPreview.add(panMapWidth);\n+        panMapPreview.add(panMapHeight);\n+        panMapPreview.add(panSpaceBoardWidth);\n+        panMapPreview.add(panSpaceBoardHeight);\n+        panMapPreview.add(panMapButtons);\n+        panMapPreview.add(bottomPanel);\n+        \n+        // The right side panel including the list of available boards\n+        comMapSizes = new JComboBox<Comparable>();\n+        refreshMapSizes();\n+\n+        lisBoardsAvailable = new JList<String>(new DefaultListModel<String>());\n+        lisBoardsAvailable.setCellRenderer(new BoardNameRenderer());\n+        lisBoardsAvailable.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n+        lisBoardsAvailable.setVisibleRowCount(-1);\n+        lisBoardsAvailable.setDragEnabled(true);\n+        lisBoardsAvailable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        scrBoardsAvailable = new JScrollPane(lisBoardsAvailable);\n+        refreshBoardsAvailable();\n+        \n+        JPanel panAvail = new JPanel();\n+        panAvail.setLayout(new BoxLayout(panAvail, BoxLayout.PAGE_AXIS));\n+        panAvail.setBorder(new EmptyBorder(0, 20, 0, 0));\n+        panAvail.add(setupAvailTopPanel());\n+        panAvail.add(scrBoardsAvailable);\n+        \n+        // The splitpane holding the left and right side panels\n+        splGroundMap = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panMapPreview, panAvail);\n+        splGroundMap.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+            \n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+        });\n+        panGroundMap.add(splGroundMap);\n+\n+        // setup the board preview window.\n+        boardPreviewW = new ClientDialog(clientgui.frame, \n+                Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"), \n+                false);\n+        boardPreviewW.setLocationRelativeTo(clientgui.frame);\n+\n+        try {\n+            BoardView1 bv = new BoardView1(boardPreviewGame, null, null);\n+            bv.setDisplayInvalidHexInfo(false);\n+            bv.setUseLOSTool(false);\n+            boardPreviewW.add(bv.getComponent(true));\n+            boardPreviewW.setSize(clientgui.frame.getWidth()/2, clientgui.frame.getHeight()/2);\n+            // Most boards will be far too large on the standard zoom\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            boardPreviewW.center();\n+        } catch (IOException e) {\n+            JOptionPane.showMessageDialog(this,\n+                            Messages.getString(\"BoardEditor.CouldntInitialize\") + e,\n+                            Messages.getString(\"BoardEditor.FatalError\"), JOptionPane.ERROR_MESSAGE); \n+        }\n+        refreshMapButtons();\n+    }\n+    \n+    /** \n+     *  Sets up and returns the panel above the available boards list \n+     *  containing the search bar and the map size chooser.  \n+     */\n+    private JPanel setupAvailTopPanel() {\n+        FixedYPanel result = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 20, 2));\n+        result.setBorder(new EmptyBorder(5, 5, 5, 5));\n+        \n+        fldSearch.getDocument().addDocumentListener(new DocumentListener() {\n+            @Override\n+            public void changedUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void removeUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void insertUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+        });\n+        \n+        result.add(lblBoardSize);\n+        result.add(comMapSizes);\n+        result.add(new JLabel(\"    \"));\n+        result.add(lblSearch);\n+        result.add(fldSearch);\n+        result.add(butCancelSearch);\n+\n+        return result;\n+    }\n+    \n+    /** \n+     * Reacts to changes in the available boards search field, showing matching boards\n+     * for the search string when it has at least 3 characters\n+     * and reverting to all boards when the search string is empty.\n+     */\n+    private void updateSearch(String searchString) {\n+        if (searchString.isEmpty()) {\n+            refreshBoardsAvailable();\n+        } else if (searchString.length() > 2) {\n+            refreshBoardsAvailable(getSearchedItems(searchString));\n+        }\n+    }\n+    \n+    /** \n+     * Returns the available boards that match the given search string\n+     * (path or file name contains the search string.) \n+     */\n+    protected List<String> getSearchedItems(String searchString) {\n+        String lowerCaseSearchString = searchString.toLowerCase();\n+        return mapSettings.getBoardsAvailableVector().stream()\n+                .filter(b -> b.toLowerCase().contains(lowerCaseSearchString) && isBoardFile(b))\n+                .collect(Collectors.toList());\n+    }\n+    \n+    /** \n+     * Returns a suitable divider location for the splitpane that contains\n+     * the available boards list and the map preview. The divider location\n+     * gives between 30% and 50% of space to the map preview depending\n+     * on the width of the game map.\n+     */\n+    private double getDividerLocation() {\n+        double base = 0.3;\n+        int width = mapSettings.getBoardWidth() * mapSettings.getMapWidth();\n+        int height = mapSettings.getBoardHeight() * mapSettings.getMapHeight();\n+        int wAspect = Math.max(1, width / height + 1);\n+        return Math.min(base + wAspect * 0.05, 0.5);\n+    }\n+\n+    /** Updates the ground map type chooser (ground/atmosphere map). */\n+    private void refreshMapChoice() {\n+        // refresh UI possibly from a server update\n+        JToggleButton button = butGroundMap;\n+        if (mapSettings.getMedium() == MapSettings.MEDIUM_ATMOSPHERE) {\n+            button = butLowAtmoMap;\n+        } else if (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {\n+            button = butSpaceMap;\n+        }\n+        \n+        if (!button.isSelected()) {\n+            button.removeActionListener(lobbyListener);\n+            button.setSelected(true);\n+            button.addActionListener(lobbyListener);\n+        }\n+    }\n+    \n+    /** Updates the list of available map sizes. */\n+    private void refreshMapSizes() {\n+        int oldSelection = comMapSizes.getSelectedIndex();\n+        mapSizes = clientgui.getClient().getAvailableMapSizes();\n+        comMapSizes.removeActionListener(lobbyListener);\n+        comMapSizes.removeAllItems();\n+        for (BoardDimensions size : mapSizes) {\n+            comMapSizes.addItem(size);\n+        }\n+        comMapSizes.addItem(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        comMapSizes.setSelectedIndex(oldSelection != -1 ? oldSelection : 0);\n+        comMapSizes.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the map assembly UI from the current map settings. Does NOT trigger further\n+     * changes or result in packets to the server. \n+     */\n+    private void refreshMapUI() {\n+        boolean inSpace = mapSettings.getMedium() == MapSettings.MEDIUM_SPACE;\n+        boolean onGround = mapSettings.getMedium() == MapSettings.MEDIUM_GROUND;\n+        boolean customSize = comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        lisBoardsAvailable.setEnabled(!inSpace);\n+        mapIcons.clear();\n+        butConditions.setEnabled(!inSpace);\n+        fldSearch.setEnabled(!inSpace);\n+        butRandomMap.setEnabled(!inSpace);\n+        panMapHeight.setVisible(!inSpace);\n+        panMapWidth.setVisible(!inSpace);\n+        panSpaceBoardWidth.setVisible(inSpace || customSize);\n+        panSpaceBoardHeight.setVisible(inSpace || customSize);\n+        comMapSizes.setEnabled(!inSpace);\n+        lblSearch.setEnabled(!inSpace);\n+        lblBoardSize.setEnabled(!inSpace);\n+        butSaveMapSetup.setEnabled(!inSpace);\n+        butLoadMapSetup.setEnabled(!inSpace);\n+        butMapShrinkW.setEnabled(mapSettings.getMapWidth() > 1);\n+        butMapShrinkH.setEnabled(mapSettings.getMapHeight() > 1);\n+        \n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        if (onGround) {\n+            butGroundMap.setSelected(true);\n+        } else if (inSpace) {\n+            butSpaceMap.setSelected(true);\n+        } else {\n+            butLowAtmoMap.setSelected(true);\n+        }\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        fldMapWidth.setText(Integer.toString(mapSettings.getMapWidth()));\n+        fldMapHeight.setText(Integer.toString(mapSettings.getMapHeight()));\n+        fldSpaceBoardWidth.setText(Integer.toString(mapSettings.getBoardWidth()));\n+        fldSpaceBoardHeight.setText(Integer.toString(mapSettings.getBoardHeight()));\n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+    }\n+\n+    /** \n+     * Refreshes the list of available boards with all available boards plus\n+     * GENERATED. Useful for first setup, when the server transmits new\n+     * map settings and when the text search field is empty.\n+     */\n+    private void refreshBoardsAvailable() {\n+        if (!lisBoardsAvailable.isEnabled()) {\n+            return;\n+        }\n+        lisBoardsAvailable.setFixedCellHeight(-1);\n+        lisBoardsAvailable.setFixedCellWidth(-1);\n+        List<String> availBoards = new ArrayList<>(); \n+        availBoards.add(MapSettings.BOARD_GENERATED);\n+        availBoards.addAll(mapSettings.getBoardsAvailableVector());\n+        refreshBoardsAvailable(availBoards);\n+    }\n+    \n+    /** \n+     * Refreshes the list of available maps with the given list of boards. \n+     */\n+    private void refreshBoardsAvailable(List<String> boardList) {\n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        // Replace the data model (adding the elements one by one to the existing model\n+        // in Java 8 style is sluggish because of event firing)\n+        DefaultListModel<String> newModel = new DefaultListModel<>();\n+        for (String s: boardList) {\n+            newModel.addElement(s);\n+        }\n+        lisBoardsAvailable.setModel(newModel);\n+        lisBoardsAvailable.clearSelection();\n+        lisBoardsAvailable.addListSelectionListener(this);\n+    }\n+    \n+    public boolean isMultipleBoards() {\n+        return mapSettings.getMapHeight() * mapSettings.getMapWidth() > 1;\n+    }\n+    \n+    MapSettings oldMapSettings = MapSettings.getInstance();\n+\n+    /**\n+     * Fills the Map Buttons scroll pane twith the appropriate amount of buttons\n+     * in the appropriate layout\n+     */\n+    private void refreshMapButtons() {\n+        panMapButtons.removeAll();\n+        panMapButtons.setVisible(false);\n+        panMapButtons.add(Box.createVerticalGlue());\n+        Dimension buttonSize = null;\n+\n+        // If buttons are unused, remove their image so that they update when they're used once more\n+        if (mapSettings.getMapHeight() * mapSettings.getMapWidth() < mapButtons.size()) {\n+            for (MapPreviewButton button: mapButtons.subList(mapSettings.getMapHeight() * mapSettings.getMapWidth(), mapButtons.size())) {\n+                button.reset();\n+            }\n+        }\n+\n+        // Add new map preview buttons if the map has grown\n+        while (mapSettings.getMapHeight() * mapSettings.getMapWidth() > mapButtons.size()) {\n+            mapButtons.add(new MapPreviewButton(this));\n+        }\n+\n+        // Re-add the buttons to the panel and update them as necessary\n+        for (int i = 0; i < mapSettings.getMapHeight(); i++) {\n+            JPanel row = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n+            panMapButtons.add(row);\n+            for (int j = 0; j < mapSettings.getMapWidth(); j++) {\n+                int index = i * mapSettings.getMapWidth() + j;\n+                MapPreviewButton button = mapButtons.get(index);\n+                button.setIndex(index);\n+                row.add(button);\n+\n+                // Update the board base image if it's generated and the settings have changed\n+                // or the board name has changed\n+                String boardName = mapSettings.getBoardsSelectedVector().get(index);\n+                if (!button.getBoard().equals(boardName) \n+                        || oldMapSettings.getMedium() != mapSettings.getMedium()\n+                        || (!mapSettings.equalMapGenParameters(oldMapSettings) \n+                                && mapSettings.getMapWidth() == oldMapSettings.getMapWidth()\n+                                && mapSettings.getMapHeight() == oldMapSettings.getMapHeight())) {\n+                    IBoard buttonBoard; \n+                    Image image;\n+                    // Generated and space boards use a generated example\n+                    if (boardName.startsWith(MapSettings.BOARD_GENERATED) \n+                            || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                        buttonBoard = BoardUtilities.generateRandom(mapSettings);\n+                        image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                    } else { \n+                        String boardForImage = boardName;\n+                        // For a surprise board, just use the first board as example\n+                        if (boardName.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                            boardForImage = extractSurpriseMaps(boardName).get(0);\n+                        }\n+                        File boardFile = new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile();\n+                        if (boardFile.exists()) {\n+                            buttonBoard = new Board(16, 17);\n+                            buttonBoard.load(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile());\n+                            StringBuffer errs = new StringBuffer();\n+                            try (InputStream is = new FileInputStream(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile())) {\n+                                buttonBoard.load(is, errs, true);\n+                            } catch (IOException ex) {\n+                                buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            }\n+                            image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                        } else {\n+                            buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            BufferedImage emptyBoardMap = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                            markServerSideBoard(emptyBoardMap);\n+                            image = emptyBoardMap;\n+                        }\n+                    }\n+                    button.setImage(image, boardName);\n+                    buttonSize = optMapButtonSize(image);\n+                }\n+                button.scheduleRescale();\n+            }\n+        }\n+        oldMapSettings = MapSettings.getInstance(mapSettings);\n+        \n+        if (buttonSize != null) {\n+            for (MapPreviewButton button: mapButtons) {\n+                button.setPreviewSize(buttonSize);\n+            }\n+        }\n+        splGroundMap.setDividerLocation(getDividerLocation());\n+\n+        panMapButtons.add(Box.createVerticalGlue());\n+        panMapButtons.setVisible(true);\n+\n+        lblBoardsAvailable.setText(mapSettings.getBoardWidth() + \"x\" + mapSettings.getBoardHeight() + \" \"\n+                + Messages.getString(\"BoardSelectionDialog.mapsAvailable\"));\n+        comMapSizes.removeActionListener(lobbyListener);\n+        int items = comMapSizes.getItemCount();\n+\n+        boolean mapSizeSelected = false;\n+        for (int i = 0; i < (items - 1); i++) {\n+            BoardDimensions size = (BoardDimensions) comMapSizes.getItemAt(i);\n+\n+            if ((size.width() == mapSettings.getBoardWidth()) && (size.height() == mapSettings.getBoardHeight())) {\n+                comMapSizes.setSelectedIndex(i);\n+                mapSizeSelected = true;\n+            }\n+        }\n+        // If we didn't select a size, select the last item: 'Custom Size'\n+        if (!mapSizeSelected) {\n+            comMapSizes.setSelectedIndex(items - 1);\n+        }\n+        comMapSizes.addActionListener(lobbyListener);\n+\n+    }\n+    \n+    private void markServerSideBoard(BufferedImage image) {\n+        Graphics g = image.getGraphics();\n+        GUIPreferences.AntiAliasifSet(g);\n+        int w = image.getWidth();\n+        int h = image.getHeight();\n+        String text = \"Server-side board\";\n+        int fontSize = Math.min(w / 10, UIUtil.scaleForGUI(16));\n+        g.setFont(new Font(\"Dialog\", Font.ITALIC, fontSize));\n+        FontMetrics fm = g.getFontMetrics(g.getFont());\n+        int cx = (w - fm.stringWidth(text)) / 2;\n+        int cy = h / 10 + fm.getAscent();\n+        g.setColor(GUIPreferences.getInstance().getWarningColor());\n+        g.drawString(text, cx, cy);\n+        g.dispose();\n+    }\n+\n+    public void previewGameBoard() {\n+        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);\n+        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];\n+        List<Boolean> rotateBoard = new ArrayList<>();\n+        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings.getMapHeight()); i++) {\n+            sheetBoards[i] = new Board();\n+            String name = mapSettings.getBoardsSelectedVector().get(i);\n+            if (name.startsWith(MapSettings.BOARD_GENERATED) \n+                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);\n+            } else {\n+                if (name.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                    List<String> boardList = extractSurpriseMaps(name);\n+                    int rnd = (int)(Math.random() * boardList.size());\n+                    name = boardList.get(rnd);\n+                }\n+                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name + \".board\").getFile());\n+            }\n+        }\n+\n+        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(), mapSettings.getMapWidth(),\n+                mapSettings.getMapHeight(), sheetBoards, rotateBoard, mapSettings.getMedium());\n+        \n+        boardPreviewGame.setBoard(newBoard);\n+        boardPreviewW.setVisible(true);\n+    }\n+\n+    /**\n+     * Refreshes the game settings with new info from the client\n+     */\n+    private void refreshGameSettings() {\n+        refreshTeams();\n+        refreshDoneButton();\n+    }\n+    \n+    /**\n+     * Refreshes the Mek Table contents \n+     */\n+    public void refreshEntities() {\n+        refreshTree();\n+        refreshMekTable();\n+    }\n+    \n+    private void refreshMekTable() {\n+        List<Integer> enIds = getSelectedEntities().stream().map(e -> e.getId()).collect(toList());\n+        mekModel.clearData();\n+        ArrayList<Entity> allEntities = new ArrayList<Entity>(clientgui.getClient().getEntitiesVector());\n+        Collections.sort(allEntities, activeSorter);\n+\n+        boolean localUnits = false;\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        for (Entity entity : allEntities) {\n+            // Remember if the local player has units.\n+            if (!localUnits && entity.getOwner().equals(localPlayer())) {\n+                localUnits = true;\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_PILOT_ADVANTAGES)) { \n+                entity.getCrew().clearOptions(PilotOptions.LVL3_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.EDGE)) { \n+                entity.getCrew().clearOptions(PilotOptions.EDGE_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_MANEI_DOMINI)) { \n+                entity.getCrew().clearOptions(PilotOptions.MD_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS)) { \n+                entity.clearPartialRepairs();\n+            }\n+            \n+            // Remove some deployment options when a unit is carried\n+            if (entity.getTransportId() != Entity.NONE) { \n+                entity.setHidden(false);\n+                entity.setProne(false);\n+                entity.setHullDown(false);\n+            }\n+            \n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) { \n+                entity.setHidden(false);\n+            }\n+            \n+            // Handle the \"Blind Drop\" option. In blind drop, units must be added\n+            // but they will be obscured in the table. In real blind drop, units\n+            // don't even get added to the table. Teams see their units in any case.\n+            boolean localUnit = entity.getOwner().equals(localPlayer());\n+            boolean teamUnit = !entity.getOwner().isEnemyOf(localPlayer());\n+            boolean realBlindDrop = opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+            if (localUnit || teamUnit || !realBlindDrop) {\n+                mekModel.addUnit(entity);\n+            }\n+        }\n+        // Restore selection\n+        if (!enIds.isEmpty()) {\n+            for (int i = 0; i < mekTable.getRowCount(); i++) {\n+                if (enIds.contains(mekModel.getEntityAt(i).getId())) {\n+                    mekTable.addRowSelectionInterval(i, i);\n+                }\n+            }\n+        }\n+\n+        // Enable the \"Save Unit List...\" button if the local player has units.\n+        clientgui.getMenuBar().setUnitList(localUnits);\n+    }\n+    \n+    /** Adjusts the mektable to compact/normal mode. */\n+    private void toggleCompact() {\n+        setTableRowHeights();\n+        mekModel.refreshCells();\n+        mekForceTreeModel.nodeChanged((TreeNode)mekForceTreeModel.getRoot());\n+        \n+    }\n+\n+    /** Refreshes the player info table. */\n+    private void refreshPlayerTable() {\n+        // Remember the selected players\n+        var selPlayerIds = getselectedPlayers().stream().map(IPlayer::getId).collect(toSet());\n+\n+        // Empty and refill the player table\n+        playerModel.replaceData(game().getPlayersVector());\n+\n+        // re-select the previously selected players, if possible\n+        for (int row = 0; row < playerModel.getRowCount(); row++) {\n+            if (selPlayerIds.contains(playerModel.getPlayerAt(row).getId())) {\n+                tablePlayers.addRowSelectionInterval(row, row);\n+            }\n+        }\n+    }\n+\n+    /** Updates the camo button to displays the camo of the currently selected player. */ \n+    private void refreshCamoButton() {\n+        if ((tablePlayers == null) || (playerModel == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (player != null) {\n+            butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        }\n+    }\n+\n+    /** Sets up the team choice box. */\n+    private void setupTeamCombo() {\n+        for (int i = 0; i < IPlayer.MAX_TEAMS; i++) {\n+            comboTeam.addItem(IPlayer.teamNames[i]);\n+        }\n+    }\n+\n+    /** Updates the team choice combobox to show the selected player's team. */\n+    private void refreshTeams() {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(localPlayer().getTeam());\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the Done button. The label will say the opposite of the\n+     * player's \"done\" status, indicating that clicking it will reverse the\n+     * condition.\n+     */\n+    private void refreshDoneButton(boolean done) {\n+        butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n+    }\n+\n+    /** Refreshes the state of the Done button with the state of the local player. */\n+    private void refreshDoneButton() {\n+        refreshDoneButton(localPlayer().isDone());\n+    }\n+\n+    /**\n+     * Embarks the given carried Entity onto the carrier given as carrierId.\n+     */\n+    void loadOnto(Entity carried, int carrierId, int bayNumber) {\n+        Entity carrier = game().getEntity(carrierId);\n+        if (carrier == null || !isLoadable(carried, carrier)) {\n+            return;\n+        }\n+\n+        // We need to make sure our current bomb choices fit onto the new\n+        // fighter\n+        if (carrier instanceof FighterSquadron) {\n+            FighterSquadron fSquad = (FighterSquadron) carrier;\n+            // We can't use Aero.getBombPoints() because the bombs haven't been\n+            // loaded yet, only selected, so we have to count the choices\n+            int[] bombChoice = fSquad.getBombChoices();\n+            int numLoadedBombs = 0;\n+            for (int i = 0; i < bombChoice.length; i++) {\n+                numLoadedBombs += bombChoice[i];\n+            }\n+            // We can't load all of the squadrons bombs\n+            if (numLoadedBombs > ((IBomber)carried).getMaxBombPoints()) {\n+                JOptionPane.showMessageDialog(clientgui.frame, Messages.getString(\"FighterSquadron.bomberror\"),\n+                        Messages.getString(\"FighterSquadron.error\"), JOptionPane.ERROR_MESSAGE);\n+                return;\n+            }\n+        }\n+        \n+        getLocalClient(carried).sendLoadEntity(carried.getId(), carrierId, bayNumber);\n+        // TODO: it would probably be a good idea \n+        // to disable some settings for loaded units in customMechDialog\n+    }\n+\n+    /** \n+     * Have the given entity disembark if it is carried by another unit.\n+     * Entities that are modified and need an update to be sent to the server\n+     * are added to the given updateCandidates. \n+     */\n+    void disembark(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = game().getEntity(entity.getTransportId());\n+        if (carrier != null) {\n+            carrier.unload(entity);\n+            entity.setTransportId(Entity.NONE);\n+            updateCandidates.add(entity);\n+            updateCandidates.add(carrier);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity disembark if it is carried by a unit of another player.\n+     * Entities that were modified and need an update to be sent to the server\n+     * are added to the given updateCandidate set. \n+     */\n+    void disembarkDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = clientgui.getClient().getGame().getEntity(entity.getTransportId());\n+        if (carrier != null && (ownerOf(entity) != ownerOf(carrier))) {\n+            disembark(entity, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entities offload all the units they are carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadAll(Collection<Entity> entities, Collection<Entity> updateCandidates) {\n+        for (Entity carrier: editableEntities(entities)) {\n+            offloadFrom(carrier, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all the units it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFrom(Entity entity, Collection<Entity> updateCandidates) {\n+        if (isEditable(entity)) {\n+            for (Entity carriedUnit: entity.getLoadedUnits()) {\n+                disembark(carriedUnit, updateCandidates);\n+            } \n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all units of different players it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFromDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        for (Entity carriedUnit: entity.getLoadedUnits()) {\n+            if (ownerOf(carriedUnit) != ownerOf(entity)) {\n+                disembark(carriedUnit, updateCandidates);\n+            }\n+        } \n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. \n+     */\n+    void sendUpdate(Collection<Entity> updateCandidates) {\n+        for (Entity e: editableEntities(updateCandidates)) {\n+            getLocalClient(e).sendUpdateEntity(e);\n+        }\n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. Will separate the units into update\n+     * packets for the local player and any local bots so that the \n+     * server accepts all changes (as the server does not know of\n+     * local bots and rejects updates that are not for the sending client\n+     * or its teammates. \n+     */\n+    void sendUpdates(Collection<Entity> entities) {\n+        List<IPlayer> owners = entities.stream().map(e -> e.getOwner()).distinct().collect(toList());\n+        for (IPlayer owner: owners) {\n+            client().sendUpdateEntity(new ArrayList<Entity>(\n+                    entities.stream().filter(e -> e.getOwner().equals(owner)).collect(toList())));\n+        }\n+    }\n+    \n+    /** \n+     * Disembarks all given entities from any transports they are in. \n+     */\n+    void disembarkAll(Collection<Entity> entities) {\n+        Set<Entity> updateCandidates = new HashSet<>();\n+        entities.stream().filter(e -> isEditable(e)).forEach(e -> disembark(e, updateCandidates));\n+        sendUpdate(updateCandidates);\n+    }\n+\n+    /** \n+     * Returns true when the given entity may be configured by the local player,\n+     * i.e. if it is his own unit or one of his bot's units.\n+     * <P>Note that this is more restrictive than the Server is. The Server\n+     * accepts entity changes also for teammates so that entity updates that \n+     * signal transporting a teammate's unit don't get rejected. I feel that\n+     * configuration other than transporting units should be limited to one's\n+     * own units (and bots) though.\n+     */\n+    boolean isEditable(Entity entity) {\n+        return clientgui.getBots().containsKey(entity.getOwner().getName())\n+                || (entity.getOwnerId() == localPlayer().getId());\n+    }\n+    \n+    /** \n+     * Returns true when the given entity may NOT be configured by the local player,\n+     * i.e. if it is not own unit or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isNotEditable(Entity entity) {\n+        return !isEditable(entity);\n+    }\n+    \n+    /** \n+     * Returns true when all given entities may be configured by the local player,\n+     * i.e. if they are his own units or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isEditable(Collection<Entity> entities) {\n+        return !entities.stream().anyMatch(this::isNotEditable);\n+    }\n+    \n+    /** \n+     * Returns the Client associated with a given entity that may be configured\n+     * by the local player (his own unit or one of his bot's units).\n+     * For a unit that cannot be configured (owned by a remote player) the client\n+     * of the local player is returned.\n+     */\n+    Client getLocalClient(Entity entity) {\n+        if (clientgui.getBots().containsKey(entity.getOwner().getName())) {\n+            return clientgui.getBots().get(entity.getOwner().getName());\n+        } else {\n+            return clientgui.getClient();\n+        }\n+    }\n+\n+    public void configPlayer() {\n+        Client c = getSelectedClient();\n+        if (null == c) {\n+            return;\n+        }\n+        \n+        PlayerSettingsDialog psd = new PlayerSettingsDialog(clientgui, c);\n+        boolean okay = psd.showDialog();\n+        \n+        if (okay) {\n+            IPlayer player = c.getLocalPlayer();\n+            player.setConstantInitBonus(psd.getInit());\n+            player.setNbrMFConventional(psd.getCnvMines());\n+            player.setNbrMFVibra(psd.getVibMines());\n+            player.setNbrMFActive(psd.getActMines());\n+            player.setNbrMFInferno(psd.getInfMines());\n+            var rsg = c.getRandomSkillsGenerator();\n+            rsg.setMethod(psd.getMethod());\n+            rsg.setType(psd.getPilot());\n+            rsg.setLevel(psd.getXP());\n+            rsg.setClose(psd.getForceGP());\n+            \n+            // The deployment position\n+            int startPos = psd.getStartPos();\n+            final GameOptions gOpts = clientgui.getClient().getGame().getOptions();\n+            if (gOpts.booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                    && (startPos >= 1) && (startPos <= 9)) {\n+                startPos += 10;\n+            }\n+            c.getLocalPlayer().setStartingPos(startPos);\n+            c.sendPlayerInfo();\n+            \n+            // If the gameoption set_arty_player_homeedge is set, adjust the player's offboard \n+            // arty units to be behind the newly selected home edge.\n+            OffBoardDirection direction = OffBoardDirection.translateStartPosition(startPos);\n+            if (direction != OffBoardDirection.NONE && \n+                    gOpts.booleanOption(OptionsConstants.BASE_SET_ARTY_PLAYER_HOMEEDGE)) {\n+                for (Entity entity: c.getGame().getPlayerEntities(c.getLocalPlayer(), false)) {\n+                    if (entity.getOffBoardDirection() != OffBoardDirection.NONE) {\n+                        entity.setOffBoard(entity.getOffBoardDistance(), direction);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    \n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechReadoutAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechReadout(entity, index++);\n+        }\n+    } \n+\n+    /** \n+     * Shows the unit summary for the given unit. Moves the dialog a bit depending on index\n+     * so that multiple dialogs dont appear exactly on top of each other. \n+     */\n+    private void mechReadout(Entity entity, int index) {\n+        final ClientDialog dialog = new ClientDialog(clientgui.frame, Messages.getString(\"ChatLounge.quickView\"), false, true);\n+        final int height = 600;\n+        final int width = 500;\n+\n+        MechView mv = new MechView(entity, false);\n+        // The label must want a fixed width to enforce linebreaks on fluff text\n+        JLabel mechSummary = new JLabel(\"<HTML>\" + mv.getMechReadoutHead()\n+        + mv.getMechReadoutBasic() + mv.getMechReadoutLoadout()\n+        + mv.getMechReadoutFluff()) {\n+            private static final long serialVersionUID = 2989361635430008853L;\n+            @Override\n+            public Dimension getPreferredSize() {\n+                return new Dimension(width - 10, super.getPreferredSize().height);\n+            }\n+        };\n+        mechSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(mechSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.center();\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechBVAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechBVDisplay(entity, index++);\n+        }\n+    } \n+    \n+    /**\n+     * @param entity the entity to display the BV Calculation for\n+     */\n+    void mechBVDisplay(Entity entity, int index) {\n+        final JDialog dialog = new ClientDialog(clientgui.frame, \"BV Calculation Display\", false, true);\n+        final int height = 600;\n+        \n+        entity.calculateBattleValue();\n+        JLabel bvSummary = new JLabel(entity.getBVText());\n+        bvSummary.setFont(new Font(\"Dialog\",Font.PLAIN, scaleForGUI(14)));\n+        bvSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(bvSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(bvSummary.getPreferredSize().width + 40, scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /**\n+     * Pop up the dialog to load a mech\n+     */\n+    private void addUnit() {\n+        clientgui.getMechSelectorDialog().updateOptionValues();\n+        clientgui.getMechSelectorDialog().setVisible(true);\n+    }\n+    \n+    private void createArmy() {\n+        clientgui.getRandomArmyDialog().setVisible(true);\n+    }\n+\n+    public void loadRandomSkills() {\n+        clientgui.getRandomSkillDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    public void loadRandomNames() {\n+        clientgui.getRandomNameDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    void changeMapDnD(String board, JButton button) {\n+        if (board.contains(\"\\n\")) {\n+            board = MapSettings.BOARD_SURPRISE + board;\n+        }\n+        mapSettings.getBoardsSelectedVector().set(mapButtons.indexOf(button), board);\n+        clientgui.getClient().sendMapSettings(mapSettings);\n+        if (boardPreviewW.isVisible()) {\n+            previewGameBoard();\n+        }\n+    }\n+    \n+    \n+\n+    //\n+    // GameListener\n+    //\n+    @Override\n+    public void gamePlayerChange(GamePlayerChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshDoneButton();\n+        clientgui.getClient().getGame().setupTeams();\n+        refreshPlayerTable();\n+        refreshPlayerConfig();\n+        refreshCamoButton();\n+        refreshEntities();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gamePhaseChange(GamePhaseChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        \n+        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {\n+            refreshDoneButton();\n+            refreshGameSettings();\n+            refreshPlayerTable();\n+            refreshTeams();\n+            refreshCamoButton();\n+            refreshEntities();\n+            panTeamOverview.refreshData();\n+        }\n+    }\n+\n+    @Override\n+    public void gameEntityNew(GameEntityNewEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameSettingsChange(GameSettingsChangeEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshGameSettings();\n+        // The table sorting may no longer be allowed (e.g. when blind drop was activated)\n+        if (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())) {\n+            nextSorter(unitSorters);\n+            updateTableHeaders();\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        refreshMapSizes();\n+        updateMapSettings(clientgui.getClient().getMapSettings());\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameClientFeedbackRequest(GameCFREvent evt) {\n+        // Do nothing\n+    }\n+\n+    \n+    private ActionListener lobbyListener = new ActionListener() {\n+\n+        @Override\n+        public void actionPerformed(ActionEvent ev) {\n+\n+            // Are we ignoring events?\n+            if (isIgnoringEvents()) {\n+                return;\n+            }\n+            \n+            if (ev.getSource().equals(butAdd)) {\n+                addUnit();\n+                \n+            } else if (ev.getSource().equals(butArmy)) {\n+                createArmy();\n+                \n+            } else if (ev.getSource().equals(butSkills)) {\n+                loadRandomSkills();\n+                \n+            } else if (ev.getSource().equals(butNames)) {\n+                loadRandomNames();\n+                \n+            } else if (ev.getSource().equals(tablePlayers)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(comboTeam)) {\n+                lobbyActions.changeTeam(getselectedPlayers(), comboTeam.getSelectedIndex());\n+                \n+            } else if (ev.getSource().equals(butConfigPlayer)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(butBotSettings)) {\n+                doBotSettings();\n+                \n+            } else if (ev.getSource().equals(butOptions)) {\n+                // Make sure the game options dialog is editable.\n+                if (!clientgui.getGameOptionsDialog().isEditable()) {\n+                    clientgui.getGameOptionsDialog().setEditable(true);\n+                }\n+                // Display the game options dialog.\n+                clientgui.getGameOptionsDialog().update(clientgui.getClient().getGame().getOptions());\n+                clientgui.getGameOptionsDialog().setVisible(true);\n+                \n+            } else if (ev.getSource().equals(butCompact)) {\n+                toggleCompact();\n+                \n+            } else if (ev.getSource().equals(butLoadList)) {\n+                // Allow the player to replace their current\n+                // list of entities with a list from a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));  //$NON-NLS-2$\n+                    return;\n+                }\n+                clientgui.loadListFile(c.getLocalPlayer());\n+                \n+            } else if (ev.getSource().equals(butSaveList)) {\n+                // Allow the player to save their current\n+                // list of entities to a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));\n+                    return;\n+                }\n+                clientgui.saveListFile(c.getGame().getPlayerEntities(c.getLocalPlayer(), false),\n+                        c.getLocalPlayer().getName());\n+                \n+            } else if (ev.getSource().equals(butAddBot)) {\n+                BotConfigDialog bcd = new BotConfigDialog(clientgui.frame);\n+                bcd.setVisible(true);\n+                if (bcd.dialogAborted) {\n+                    return; // user didn't click 'ok', add no bot\n+                }\n+                if (clientgui.getBots().containsKey(bcd.getBotName())) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertExistsBot.title\"),\n+                            Messages.getString(\"ChatLounge.AlertExistsBot.message\"));  //$NON-NLS-2$\n+                } else {\n+                    BotClient c = bcd.getSelectedBot(clientgui.getClient().getHost(), clientgui.getClient().getPort());\n+                    c.setClientGUI(clientgui);\n+                    c.getGame().addGameListener(new BotGUI(c));\n+                    try {\n+                        c.connect();\n+                    } catch (Exception e) {\n+                        clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertBot.title\"),\n+                                Messages.getString(\"ChatLounge.AlertBot.message\"));  //$NON-NLS-2$\n+                    }\n+                    clientgui.getBots().put(bcd.getBotName(), c);\n+                }\n+                \n+            } else if (ev.getSource().equals(butRemoveBot)) {\n+                removeBot();\n+                \n+            } else if (ev.getSource().equals(butShowUnitID)) {\n+                PreferenceManager.getClientPreferences().setShowUnitId(butShowUnitID.isSelected());\n+                mekModel.refreshCells();\n+                repaint();\n+                \n+            } else if (ev.getSource() == butConditions) {\n+                PlanetaryConditionsDialog pcd = new PlanetaryConditionsDialog(clientgui);\n+                boolean userOkay = pcd.showDialog();\n+                if (userOkay) {\n+                    clientgui.getClient().sendPlanetaryConditions(pcd.getConditions());\n+                }\n+                \n+            } else if (ev.getSource() == butRandomMap) {\n+                RandomMapDialog rmd = new RandomMapDialog(clientgui.frame, ChatLounge.this, clientgui.getClient(), mapSettings);\n+                rmd.activateDialog(clientgui.getBoardView().getTilesetManager().getThemes());\n+                \n+            } else if (ev.getSource().equals(butBoardPreview)) {\n+                previewGameBoard();\n+                \n+            } else if (ev.getSource().equals(comMapSizes)) {\n+                if (comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"))) {\n+                    refreshMapUI();\n+                } else if (comMapSizes.getSelectedItem() != null) {\n+                    BoardDimensions size = (BoardDimensions) comMapSizes.getSelectedItem();\n+                    mapSettings.setBoardSize(size.width(), size.height());\n+                    resetAvailBoardSelection = true;\n+                    resetSelectedBoards = true;\n+                    clientgui.getClient().sendMapSettings(mapSettings);\n+                } \n+                \n+            } else if (ev.getSource() == butGroundMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_GROUND);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butSpaceMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_SPACE);\n+                mapSettings.setBoardSize(50, 50);\n+                mapSettings.setMapSize(1, 1);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butLowAtmoMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_ATMOSPHERE);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddX || ev.getSource() == butMapGrowW) {\n+                int newMapWidth = mapSettings.getMapWidth() + 1;\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddY || ev.getSource() == butMapGrowH) {\n+                int newMapHeight = mapSettings.getMapHeight() + 1;\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butSaveMapSetup) {\n+                saveMapSetup();\n+                \n+            } else if (ev.getSource() == butLoadMapSetup) {\n+                loadMapSetup();\n+                \n+            } else if (ev.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+                \n+            } else if (ev.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+                \n+            } else if (ev.getSource() == butMapShrinkW) {\n+                if (mapSettings.getMapWidth() > 1) {\n+                    int newMapWidth = mapSettings.getMapWidth() - 1;\n+                    mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butMapShrinkH) {\n+                if (mapSettings.getMapHeight() > 1) {\n+                    int newMapHeight = mapSettings.getMapHeight() - 1;\n+                    mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butDetach) {\n+                butDetach.setEnabled(false);\n+                panTeam.remove(panTeamOverview);\n+                panTeam.repaint();\n+                panTeamOverview.setDetached(true);\n+                teamOverviewWindow.add(panTeamOverview);\n+                teamOverviewWindow.center();\n+                teamOverviewWindow.setVisible(true);\n+                \n+            } else if (ev.getSource() == butCancelSearch) {\n+                fldSearch.setText(\"\");\n+\n+            } else if (ev.getSource() == butHelp) {\n+                File helpfile = new File(\"docs/Boards Stuff/MapAssemblyHelp.html\");\n+                final JDialog dialog = new ClientDialog(clientgui.frame, \"Map Assembly Help\", true, true);\n+                final int height = 600;\n+                final int width = 600;\n+                \n+                final JEditorPane pane = new JEditorPane();\n+                pane.setName(\"helpPane\");\n+                pane.setEditable(false);\n+                pane.setFont(new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1)));\n+                try {\n+                    pane.setPage(helpfile.toURI().toURL());\n+                    JScrollPane tScroll = new JScrollPane(pane,\n+                            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+                    tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+                    dialog.add(tScroll, BorderLayout.CENTER);\n+                } catch (Exception e) {\n+                    dialog.setTitle(Messages.getString(\"AbstractHelpDialog.noHelp.title\"));\n+                    pane.setText(Messages.getString(\"AbstractHelpDialog.errorReading\") + e.getMessage());\n+                    MegaMek.getLogger().error(e);\n+                }\n+\n+                JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+                button.addActionListener(e -> dialog.setVisible(false));\n+                JPanel okayPanel = new JPanel(new FlowLayout());\n+                okayPanel.add(button);\n+                dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+                Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+                dialog.setPreferredSize(sz);\n+                dialog.setVisible(true);\n+                \n+            } else if (ev.getSource() == butListView) {\n+                scrMekTable.setViewportView(mekTable);\n+                butCollapse.setEnabled(false);\n+                butExpand.setEnabled(false);\n+                \n+            } else if (ev.getSource() == butForceView) {\n+                scrMekTable.setViewportView(mekForceTree);\n+                butCollapse.setEnabled(true);\n+                butExpand.setEnabled(true);\n+                \n+            } else if (ev.getSource() == butCollapse) {\n+                collapseTree();\n+            } else if (ev.getSource() == butExpand) {\n+                expandTree();\n+            } \n+        }\n+    };\n+    \n+    /** Expands the Mek Force Tree fully. */\n+    private void expandTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.expandRow(i);\n+        }\n+    }\n+    \n+    /** Collapses the Mek Force Tree fully. */\n+    private void collapseTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.collapseRow(i);\n+        }\n+    }\n+    \n+    \n+    /** \n+     * Opens a file chooser and saves the current map setup to the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void saveMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.saveMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showSaveDialog(clientgui.frame);\n+        File selectedFile = fc.getSelectedFile();\n+        if (!selectedFile.getName().toLowerCase().endsWith(\".xml\")) {\n+            selectedFile = new File(selectedFile.getPath() + \".xml\");\n+        }\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (selectedFile == null)) {\n+            return;\n+        }\n+        if (selectedFile.exists()) {\n+            String msg = Messages.getString(\"ChatLounge.map.saveMapSetupReplace\", selectedFile.getName());\n+            if (!MMConfirmDialog.confirm(clientgui.frame, \"Confirm replace\", msg)) {\n+                return;\n+            }\n+        }\n+        try(OutputStream os = new FileOutputStream(selectedFile)) {\n+            MapSetup.save(os, mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while saving the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+\n+    /** \n+     * Opens a file chooser and loads a new map setup from the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void loadMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showOpenDialog(clientgui.frame);\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (fc.getSelectedFile() == null)) {\n+            return;\n+        }\n+        if (!fc.getSelectedFile().exists()) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \"File not found.\");\n+            return;\n+        }\n+        try(InputStream os = new FileInputStream(fc.getSelectedFile())) {\n+            MapSetup setup = MapSetup.load(os);\n+            mapSettings.setMapSize(setup.getMapWidth(), setup.getMapHeight());\n+            mapSettings.setBoardSize(setup.getBoardWidth(), setup.getBoardHeight());\n+            mapSettings.setBoardsSelectedVector(setup.getBoards());\n+            clientgui.getClient().sendMapSettings(mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while loading the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+    \n+    private void removeBot() {\n+        Client c = getSelectedClient();\n+        if (!client().bots.containsValue(c)) {\n+//        if ((c == null) || c.equals(clientgui.getClient())) {\n+//            clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+//                    Messages.getString(\"ChatLounge.SelectBo\"));\n+            LobbyErrors.showOnlyOwnBot(clientgui.frame);\n+            return;\n+        }\n+        // Delete units first, which safely disembarks and offloads them\n+        // Don't delete the bot's forces, as that could also delete other players' entitites\n+//        lobbyActions.delete(new ArrayList<>(), game().getPlayerEntities(c.getLocalPlayer(), false), false);\n+        c.die();\n+        clientgui.getBots().remove(c.getName());\n+    }\n+    \n+    private void doBotSettings() {\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        BotClient bot = (BotClient) clientgui.getBots().get(player.getName());\n+        BotConfigDialog bcd = new BotConfigDialog(clientgui.frame, bot);\n+        bcd.setVisible(true);\n+\n+        if (bcd.dialogAborted) {\n+            return; // user didn't click 'ok', add no bot\n+        } else if (bot instanceof Princess) {\n+            ((Princess) bot).setBehaviorSettings(bcd.getBehaviorSettings());\n+            \n+            // bookkeeping:\n+            clientgui.getBots().remove(player.getName());\n+            bot.setName(bcd.getBotName());\n+            clientgui.getBots().put(bot.getName(), bot);\n+            player.setName(bcd.getBotName());\n+            clientgui.chatlounge.refreshPlayerTable();\n+        }\n+    }\n+    \n+    // Put a filter on the files that the user can select the proper file.\n+    FileFilter XMLFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return (f.getPath().toLowerCase().endsWith(\".xml\") || f.isDirectory());\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Map Setup XML files\";\n+        }\n+    };\n+    \n+    private void setManualMapWidth() {\n+        try {\n+            int newMapWidth = Integer.parseInt(fldMapWidth.getText());\n+            if (newMapWidth >= 1 && newMapWidth <= 20) {\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map width\n+        }\n+    }\n+    \n+    private void setManualMapHeight() {\n+        try {\n+            int newMapHeight = Integer.parseInt(fldMapHeight.getText());\n+            if (newMapHeight >= 1 && newMapHeight <= 20) {\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map height\n+        }\n+    }\n+    \n+    private void setManualBoardWidth() {\n+        try {\n+            int newBoardWidth = Integer.parseInt(fldSpaceBoardWidth.getText());\n+            if (newBoardWidth >= 5 && newBoardWidth <= 200) {\n+                mapSettings.setBoardSize(newBoardWidth, mapSettings.getBoardHeight());\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board width\n+        }\n+    }\n+    \n+    private void setManualBoardHeight() {\n+        try {\n+            int newBoardHeight = Integer.parseInt(fldSpaceBoardHeight.getText());\n+            if (newBoardHeight >= 5 && newBoardHeight <= 200) {\n+                mapSettings.setBoardSize(mapSettings.getBoardWidth(), newBoardHeight);\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board height\n+        }\n+    }\n+\n+    /**\n+     * Updates to show the map settings that have, presumably, just been sent by\n+     * the server.\n+     */\n+    @Override\n+    public void updateMapSettings(MapSettings newSettings) {\n+        mapSettings = MapSettings.getInstance(newSettings);\n+        refreshMapButtons();\n+        refreshMapChoice();\n+        refreshMapUI();\n+        refreshBoardsAvailable();\n+        updateSearch(fldSearch.getText());\n+        refreshLabels();\n+    }\n+\n+\n+    /**OK Refreshes the Map Summary, Tech Level and Game Year labels. */\n+    private void refreshLabels() {\n+        Font scaledFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1));\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        String txt = Messages.getString(\"ChatLounge.GameYear\"); \n+        txt += opts.intOption(OptionsConstants.ALLOWED_YEAR);\n+        lblGameYear.setText(txt);\n+        lblGameYear.setFont(scaledFont);\n+        lblGameYear.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\"))); \n+        \n+        String tlString = TechConstants.getLevelDisplayableName(TechConstants.T_TECH_UNKNOWN);\n+        IOption tlOpt = opts.getOption(OptionsConstants.ALLOWED_TECHLEVEL);\n+        if (tlOpt != null) {\n+            tlString = tlOpt.stringValue();\n+        }\n+        lblTechLevel.setText(Messages.getString(\"ChatLounge.TechLevel\") + tlString);\n+        lblTechLevel.setFont(scaledFont);\n+        lblTechLevel.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\")));\n+        \n+        txt = Messages.getString(\"ChatLounge.MapSummary\"); \n+        txt += (mapSettings.getBoardWidth() * mapSettings.getMapWidth()) + \" x \" \n+                + (mapSettings.getBoardHeight() * mapSettings.getMapHeight());\n+        if (butGroundMap.isSelected()) {\n+            txt += \" Ground Map\";\n+        } else if (butLowAtmoMap.isSelected()) {\n+            txt += \" Atmospheric Map\";\n+        } else {\n+            txt += \" Space Map\";\n+        }\n+        lblMapSummary.setText(txt);\n+        lblMapSummary.setFont(scaledFont);\n+\n+        StringBuilder selectedMaps = new StringBuilder();\n+        selectedMaps.append(Messages.getString(\"ChatLounge.MapSummarySelectedMaps\"));\n+        for (String map: mapSettings.getBoardsSelectedVector()) {\n+            selectedMaps.append(\"&nbsp;&nbsp;\");\n+            if (map.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                selectedMaps.append(MapSettings.BOARD_SURPRISE);\n+            } else {\n+                selectedMaps.append(map);\n+            }\n+            selectedMaps.append(\"<br>\"); \n+        }\n+        lblMapSummary.setToolTipText(scaleStringForGUI(selectedMaps.toString()));\n+    }\n+    \n+    @Override\n+    public void ready() {\n+        final Client client = clientgui.getClient();\n+        final IGame game = client.getGame();\n+        final GameOptions gOpts = game.getOptions();\n+        \n+        // enforce exclusive deployment zones in double blind\n+        for (IPlayer player: client.getGame().getPlayersVector()) {\n+            if (!isValidStartPos(game, player)) {\n+                clientgui.doAlertDialog(Messages.getString(\"ChatLounge.OverlapDeploy.title\"), \n+                        Messages.getString(\"ChatLounge.OverlapDeploy.msg\"));\n+                return;\n+            }\n+        }\n+\n+        // Make sure player has a commander if Commander killed victory is on\n+        if (gOpts.booleanOption(OptionsConstants.VICTORY_COMMANDER_KILLED)) {\n+            List<String> players = new ArrayList<>();\n+            if ((game.getLiveCommandersOwnedBy(localPlayer()) < 1)\n+                    && (game.getEntitiesOwnedBy(localPlayer()) > 0)) {\n+                players.add(client.getLocalPlayer().getName());\n+            }\n+            for (Client bc : clientgui.getBots().values()) {\n+                if ((game.getLiveCommandersOwnedBy(bc.getLocalPlayer()) < 1)\n+                        && (game.getEntitiesOwnedBy(bc.getLocalPlayer()) > 0)) {\n+                    players.add(bc.getLocalPlayer().getName());\n+                }\n+            }\n+            if (players.size() > 0) {\n+                String title = Messages.getString(\"ChatLounge.noCmdr.title\"); \n+                String msg = Messages.getString(\"ChatLounge.noCmdr.msg\"); \n+                for (String player : players) {\n+                    msg += player + \"\\n\";\n+                }\n+                clientgui.doAlertDialog(title, msg);\n+                return;\n+            }\n+\n+        }\n+\n+        boolean done = !localPlayer().isDone();\n+        client.sendDone(done);\n+        refreshDoneButton(done);\n+        for (Client botClient : clientgui.getBots().values()) {\n+            botClient.sendDone(done);\n+        }\n+    }\n+\n+    Client getSelectedClient() {\n+        if ((tablePlayers == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return null;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (localPlayer().equals(player)) {\n+            return client();\n+        } else if (client().bots.containsKey(player.getName())) {\n+            return client().bots.get(player.getName());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Stop just ignoring events and actually stop listening to them.\n+     */\n+    @Override\n+    public void removeAllListeners() {\n+        clientgui.getClient().getGame().removeGameListener(this);\n+        clientgui.getBoardView().removeBoardViewListener(this);\n+        GUIPreferences.getInstance().removePreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().removePreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().removeListener(mechSummaryCacheListener);\n+        \n+        if (loader != null) {\n+            loader.cancel(true);\n+        }\n+        \n+        tablePlayers.getSelectionModel().removeListSelectionListener(this);\n+        tablePlayers.removeMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        lisBoardsAvailable.removeMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.removeWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.removeMouseListener(mekTableMouseAdapter);\n+        mekForceTree.removeMouseListener(mekForceTreeMouseListener);\n+        mekTable.getTableHeader().removeMouseListener(mekTableHeaderMouseListener);\n+        mekTable.removeKeyListener(mekTableKeyListener);\n+        mekForceTree.removeKeyListener(mekTreeKeyListener);\n+        \n+        butAdd.removeActionListener(lobbyListener);\n+        butAddBot.removeActionListener(lobbyListener);\n+        butArmy.removeActionListener(lobbyListener);\n+        butBoardPreview.removeActionListener(lobbyListener);\n+        butBotSettings.removeActionListener(lobbyListener);\n+        butCompact.removeActionListener(lobbyListener);\n+        butConditions.removeActionListener(lobbyListener);\n+        butConfigPlayer.removeActionListener(lobbyListener);\n+        butLoadList.removeActionListener(lobbyListener);\n+        butNames.removeActionListener(lobbyListener);\n+        butOptions.removeActionListener(lobbyListener);\n+        butRandomMap.removeActionListener(lobbyListener);\n+        butRemoveBot.removeActionListener(lobbyListener);\n+        butSaveList.removeActionListener(lobbyListener);\n+        butShowUnitID.removeActionListener(lobbyListener);\n+        butSkills.removeActionListener(lobbyListener);\n+        butSpaceSize.removeActionListener(lobbyListener);\n+        butCamo.removeActionListener(camoListener);\n+        butAddX.removeActionListener(lobbyListener);\n+        butAddY.removeActionListener(lobbyListener);\n+        butMapGrowW.removeActionListener(lobbyListener);\n+        butMapShrinkW.removeActionListener(lobbyListener);\n+        butMapGrowH.removeActionListener(lobbyListener);\n+        butMapShrinkH.removeActionListener(lobbyListener);\n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        butLoadMapSetup.removeActionListener(lobbyListener);\n+        butSaveMapSetup.removeActionListener(lobbyListener);\n+        butDetach.removeActionListener(lobbyListener);\n+        butCancelSearch.removeActionListener(lobbyListener);\n+        butHelp.removeActionListener(lobbyListener);\n+        butListView.removeActionListener(lobbyListener);\n+        butForceView.removeActionListener(lobbyListener);\n+        butCollapse.removeActionListener(lobbyListener);\n+        butExpand.removeActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        \n+        comboTeam.removeActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Returns true if the given list of entities can be configured as a group.\n+     * This requires that they all have the same owner, and that none of the\n+     * units are being transported. Also, the owner must be the player or one\n+     * of his bots. \n+     */\n+    boolean canConfigureMultipleDeployment(Collection<Entity> entities) {\n+        return haveSingleOwner(entities) \n+                && !containsTransportedUnit(entities)\n+                && canEditAny(entities);\n+    }\n+    \n+    /**\n+     * Returns true if the given collection contains at least one entity\n+     * that the local player can edit, i.e. is his own or belongs to\n+     * one of his bots. Does not check if the units are otherwise configured,\n+     * e.g. transported.\n+     * <P>See also {@link #isEditable(Entity)}\n+     */\n+    boolean canEditAny(Collection<Entity> entities) {\n+        return entities.stream().anyMatch(e -> isEditable(e));\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see all of the given entities.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not on his team.\n+     */\n+    boolean canSeeAll(Collection<Entity> entities) {\n+        if (!game().getOptions().booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                && !game().getOptions().booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP)) {\n+            return true;\n+        }\n+        for (Entity entity: entities) {\n+            if (!entityInLocalTeam(entity)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see the given entity.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not his own.\n+     */\n+    boolean canSee(Entity entity) {\n+        return canSeeAll(Arrays.asList(entity));\n+    }\n+    \n+    boolean entityInLocalTeam(Entity entity) {\n+        return !localPlayer().isEnemyOf(entity.getOwner());\n+    }\n+    \n+\n+    @Override\n+    public void valueChanged(ListSelectionEvent event) {\n+        if (event.getValueIsAdjusting()) {\n+            return;\n+        }\n+        \n+        if (event.getSource().equals(tablePlayers.getSelectionModel())) {\n+            refreshPlayerConfig();\n+        }\n+    }\n+    \n+    /** Adapts the enabled state of the player config UI items to the player selection. */\n+    private void refreshPlayerConfig() {\n+        var selPlayers = getselectedPlayers();\n+        var hasSelection = !selPlayers.isEmpty();\n+        var isSinglePlayer = selPlayers.size() == 1;\n+        var allConfigurable = hasSelection && selPlayers.stream().allMatch(lobbyActions::isSelfOrLocalBot);\n+        var isSingleLocalBot = isSinglePlayer && (getSelectedClient() instanceof BotClient);\n+        comboTeam.setEnabled(allConfigurable);\n+        butLoadList.setEnabled(allConfigurable && isSinglePlayer);\n+        butCamo.setEnabled(allConfigurable && isSinglePlayer);\n+        butConfigPlayer.setEnabled(allConfigurable && isSinglePlayer);\n+        refreshCamoButton();\n+        // Disable the Remove Bot button for the \"player\" of a \"Connect As Bot\" client\n+        butRemoveBot.setEnabled(isSingleLocalBot);\n+        butSaveList.setEnabled(false);\n+        if (isSinglePlayer) {\n+            var selPlayer = theElement(selPlayers);\n+            var hasUnits = !game().getPlayerEntities(selPlayer, false).isEmpty();\n+            butSaveList.setEnabled(hasUnits && unitsVisible(selPlayer));\n+            setTeamSelectedItem(selPlayer.getTeam());\n+        }\n+    }\n+    \n+    /** Sets (without firing events) the team combobox. */\n+    private void setTeamSelectedItem(int team) {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(team);\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+    \n+    /** \n+     * Returns false when any blind-drop option is active and player is not on the local team; \n+     * true otherwise. When true, individual units of the given player should not be shown/saved/etc. \n+     */ \n+    private boolean unitsVisible(IPlayer player) {\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        boolean isBlindDrop = opts.booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                || opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+        return !player.isEnemyOf(localPlayer()) || !isBlindDrop;\n+    }\n+\n+    public class PlayerTableMouseAdapter extends MouseInputAdapter {\n+\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                IPlayer player = playerModel.getPlayerAt(row);\n+                if (player != null) {\n+                    boolean isLocalPlayer = player.equals(localPlayer());\n+                    boolean isLocalBot = clientgui.getBots().get(player.getName()) != null;\n+                    if ((isLocalPlayer || isLocalBot)) {\n+                        configPlayer();\n+                    }\n+                }\n+            }\n+        }\n+        \n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected player,\n+                // clear the selection and select that entity instead\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                if (!tablePlayers.isRowSelected(row)) {\n+                    tablePlayers.changeSelection(row, row, false, false);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            ScalingPopup popup = PlayerTablePopup.playerTablePopup(clientgui, \n+                    playerTableActionListener, getselectedPlayers());\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    private ActionListener playerTableActionListener = new ActionListener() {\n+        \n+        @Override\n+        public void actionPerformed(ActionEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+        \n+            StringTokenizer st = new StringTokenizer(e.getActionCommand(), \"|\");\n+            String command = st.nextToken();\n+            switch (command) {\n+            case \"CONFIG\":", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4OTExNA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612089114", "bodyText": "Is there documentation somewhere that explains what these key combos do?", "author": "NickAragua", "createdAt": "2021-04-13T02:45:49Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);\n+        \n+        // Planetary Conditions and Random Map Settings buttons\n+        FixedYPanel panSettings = new FixedYPanel();\n+        panSettings.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panSettings.add(butConditions);\n+        panSettings.add(butRandomMap);\n+//        panMap.add(panSettings);\n+\n+        FixedYPanel panTopRows = new FixedYPanel();\n+        panTopRows.setLayout(new BoxLayout(panTopRows, BoxLayout.PAGE_AXIS));\n+        panTopRows.add(panMapType);\n+        panTopRows.add(panSettings);\n+        \n+        JPanel panHelp = new JPanel(new GridLayout(1,1));\n+        panHelp.add(butHelp);\n+        \n+        FixedYPanel panTopRowsHelp = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 30, 5));\n+        panTopRowsHelp.add(panTopRows);\n+        panTopRowsHelp.add(panHelp);\n+        panMap.add(panTopRowsHelp);\n+        \n+        // Main part: Map Assembly\n+        panMap.add(panGroundMap);\n+\n+    }\n+\n+    /**\n+     * Sets up the ground map selection panel\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void setupMapAssembly() {\n+\n+        panGroundMap = new JPanel(new GridLayout(1, 1));\n+        panGroundMap.setBorder(new EmptyBorder(20, 10, 10, 10));\n+\n+        panMapButtons.setLayout(new BoxLayout(panMapButtons, BoxLayout.PAGE_AXIS));\n+        // Resize the preview buttons when the panel is resized\n+        panMapButtons.addComponentListener(new ComponentAdapter() {\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateMapButtons();\n+            }\n+        });\n+        \n+        panMapWidth.add(lblMapWidth);\n+        panMapWidth.add(butMapShrinkW);\n+        panMapWidth.add(fldMapWidth);\n+        panMapWidth.add(butMapGrowW);\n+        \n+        panMapHeight.add(lblMapHeight);\n+        panMapHeight.add(butMapShrinkH);\n+        panMapHeight.add(fldMapHeight);\n+        panMapHeight.add(butMapGrowH);\n+        \n+        panSpaceBoardWidth.add(lblSpaceBoardWidth);\n+        panSpaceBoardWidth.add(fldSpaceBoardWidth);\n+        panSpaceBoardWidth.setVisible(false);\n+        \n+        panSpaceBoardHeight.add(lblSpaceBoardHeight);\n+        panSpaceBoardHeight.add(fldSpaceBoardHeight);\n+        panSpaceBoardHeight.setVisible(false);\n+        \n+        FixedYPanel bottomPanel = new FixedYPanel();\n+        bottomPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n+        bottomPanel.add(butBoardPreview);\n+        bottomPanel.add(butSaveMapSetup);\n+        bottomPanel.add(butLoadMapSetup);\n+\n+        butBoardPreview.setToolTipText(Messages.getString(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+\n+        // The left side panel including the game map preview\n+        JPanel panMapPreview = new JPanel();\n+        panMapPreview.setLayout(new BoxLayout(panMapPreview, BoxLayout.PAGE_AXIS));\n+        \n+        panMapPreview.add(panMapWidth);\n+        panMapPreview.add(panMapHeight);\n+        panMapPreview.add(panSpaceBoardWidth);\n+        panMapPreview.add(panSpaceBoardHeight);\n+        panMapPreview.add(panMapButtons);\n+        panMapPreview.add(bottomPanel);\n+        \n+        // The right side panel including the list of available boards\n+        comMapSizes = new JComboBox<Comparable>();\n+        refreshMapSizes();\n+\n+        lisBoardsAvailable = new JList<String>(new DefaultListModel<String>());\n+        lisBoardsAvailable.setCellRenderer(new BoardNameRenderer());\n+        lisBoardsAvailable.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n+        lisBoardsAvailable.setVisibleRowCount(-1);\n+        lisBoardsAvailable.setDragEnabled(true);\n+        lisBoardsAvailable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        scrBoardsAvailable = new JScrollPane(lisBoardsAvailable);\n+        refreshBoardsAvailable();\n+        \n+        JPanel panAvail = new JPanel();\n+        panAvail.setLayout(new BoxLayout(panAvail, BoxLayout.PAGE_AXIS));\n+        panAvail.setBorder(new EmptyBorder(0, 20, 0, 0));\n+        panAvail.add(setupAvailTopPanel());\n+        panAvail.add(scrBoardsAvailable);\n+        \n+        // The splitpane holding the left and right side panels\n+        splGroundMap = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panMapPreview, panAvail);\n+        splGroundMap.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+            \n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+        });\n+        panGroundMap.add(splGroundMap);\n+\n+        // setup the board preview window.\n+        boardPreviewW = new ClientDialog(clientgui.frame, \n+                Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"), \n+                false);\n+        boardPreviewW.setLocationRelativeTo(clientgui.frame);\n+\n+        try {\n+            BoardView1 bv = new BoardView1(boardPreviewGame, null, null);\n+            bv.setDisplayInvalidHexInfo(false);\n+            bv.setUseLOSTool(false);\n+            boardPreviewW.add(bv.getComponent(true));\n+            boardPreviewW.setSize(clientgui.frame.getWidth()/2, clientgui.frame.getHeight()/2);\n+            // Most boards will be far too large on the standard zoom\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            boardPreviewW.center();\n+        } catch (IOException e) {\n+            JOptionPane.showMessageDialog(this,\n+                            Messages.getString(\"BoardEditor.CouldntInitialize\") + e,\n+                            Messages.getString(\"BoardEditor.FatalError\"), JOptionPane.ERROR_MESSAGE); \n+        }\n+        refreshMapButtons();\n+    }\n+    \n+    /** \n+     *  Sets up and returns the panel above the available boards list \n+     *  containing the search bar and the map size chooser.  \n+     */\n+    private JPanel setupAvailTopPanel() {\n+        FixedYPanel result = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 20, 2));\n+        result.setBorder(new EmptyBorder(5, 5, 5, 5));\n+        \n+        fldSearch.getDocument().addDocumentListener(new DocumentListener() {\n+            @Override\n+            public void changedUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void removeUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void insertUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+        });\n+        \n+        result.add(lblBoardSize);\n+        result.add(comMapSizes);\n+        result.add(new JLabel(\"    \"));\n+        result.add(lblSearch);\n+        result.add(fldSearch);\n+        result.add(butCancelSearch);\n+\n+        return result;\n+    }\n+    \n+    /** \n+     * Reacts to changes in the available boards search field, showing matching boards\n+     * for the search string when it has at least 3 characters\n+     * and reverting to all boards when the search string is empty.\n+     */\n+    private void updateSearch(String searchString) {\n+        if (searchString.isEmpty()) {\n+            refreshBoardsAvailable();\n+        } else if (searchString.length() > 2) {\n+            refreshBoardsAvailable(getSearchedItems(searchString));\n+        }\n+    }\n+    \n+    /** \n+     * Returns the available boards that match the given search string\n+     * (path or file name contains the search string.) \n+     */\n+    protected List<String> getSearchedItems(String searchString) {\n+        String lowerCaseSearchString = searchString.toLowerCase();\n+        return mapSettings.getBoardsAvailableVector().stream()\n+                .filter(b -> b.toLowerCase().contains(lowerCaseSearchString) && isBoardFile(b))\n+                .collect(Collectors.toList());\n+    }\n+    \n+    /** \n+     * Returns a suitable divider location for the splitpane that contains\n+     * the available boards list and the map preview. The divider location\n+     * gives between 30% and 50% of space to the map preview depending\n+     * on the width of the game map.\n+     */\n+    private double getDividerLocation() {\n+        double base = 0.3;\n+        int width = mapSettings.getBoardWidth() * mapSettings.getMapWidth();\n+        int height = mapSettings.getBoardHeight() * mapSettings.getMapHeight();\n+        int wAspect = Math.max(1, width / height + 1);\n+        return Math.min(base + wAspect * 0.05, 0.5);\n+    }\n+\n+    /** Updates the ground map type chooser (ground/atmosphere map). */\n+    private void refreshMapChoice() {\n+        // refresh UI possibly from a server update\n+        JToggleButton button = butGroundMap;\n+        if (mapSettings.getMedium() == MapSettings.MEDIUM_ATMOSPHERE) {\n+            button = butLowAtmoMap;\n+        } else if (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {\n+            button = butSpaceMap;\n+        }\n+        \n+        if (!button.isSelected()) {\n+            button.removeActionListener(lobbyListener);\n+            button.setSelected(true);\n+            button.addActionListener(lobbyListener);\n+        }\n+    }\n+    \n+    /** Updates the list of available map sizes. */\n+    private void refreshMapSizes() {\n+        int oldSelection = comMapSizes.getSelectedIndex();\n+        mapSizes = clientgui.getClient().getAvailableMapSizes();\n+        comMapSizes.removeActionListener(lobbyListener);\n+        comMapSizes.removeAllItems();\n+        for (BoardDimensions size : mapSizes) {\n+            comMapSizes.addItem(size);\n+        }\n+        comMapSizes.addItem(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        comMapSizes.setSelectedIndex(oldSelection != -1 ? oldSelection : 0);\n+        comMapSizes.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the map assembly UI from the current map settings. Does NOT trigger further\n+     * changes or result in packets to the server. \n+     */\n+    private void refreshMapUI() {\n+        boolean inSpace = mapSettings.getMedium() == MapSettings.MEDIUM_SPACE;\n+        boolean onGround = mapSettings.getMedium() == MapSettings.MEDIUM_GROUND;\n+        boolean customSize = comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        lisBoardsAvailable.setEnabled(!inSpace);\n+        mapIcons.clear();\n+        butConditions.setEnabled(!inSpace);\n+        fldSearch.setEnabled(!inSpace);\n+        butRandomMap.setEnabled(!inSpace);\n+        panMapHeight.setVisible(!inSpace);\n+        panMapWidth.setVisible(!inSpace);\n+        panSpaceBoardWidth.setVisible(inSpace || customSize);\n+        panSpaceBoardHeight.setVisible(inSpace || customSize);\n+        comMapSizes.setEnabled(!inSpace);\n+        lblSearch.setEnabled(!inSpace);\n+        lblBoardSize.setEnabled(!inSpace);\n+        butSaveMapSetup.setEnabled(!inSpace);\n+        butLoadMapSetup.setEnabled(!inSpace);\n+        butMapShrinkW.setEnabled(mapSettings.getMapWidth() > 1);\n+        butMapShrinkH.setEnabled(mapSettings.getMapHeight() > 1);\n+        \n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        if (onGround) {\n+            butGroundMap.setSelected(true);\n+        } else if (inSpace) {\n+            butSpaceMap.setSelected(true);\n+        } else {\n+            butLowAtmoMap.setSelected(true);\n+        }\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        fldMapWidth.setText(Integer.toString(mapSettings.getMapWidth()));\n+        fldMapHeight.setText(Integer.toString(mapSettings.getMapHeight()));\n+        fldSpaceBoardWidth.setText(Integer.toString(mapSettings.getBoardWidth()));\n+        fldSpaceBoardHeight.setText(Integer.toString(mapSettings.getBoardHeight()));\n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+    }\n+\n+    /** \n+     * Refreshes the list of available boards with all available boards plus\n+     * GENERATED. Useful for first setup, when the server transmits new\n+     * map settings and when the text search field is empty.\n+     */\n+    private void refreshBoardsAvailable() {\n+        if (!lisBoardsAvailable.isEnabled()) {\n+            return;\n+        }\n+        lisBoardsAvailable.setFixedCellHeight(-1);\n+        lisBoardsAvailable.setFixedCellWidth(-1);\n+        List<String> availBoards = new ArrayList<>(); \n+        availBoards.add(MapSettings.BOARD_GENERATED);\n+        availBoards.addAll(mapSettings.getBoardsAvailableVector());\n+        refreshBoardsAvailable(availBoards);\n+    }\n+    \n+    /** \n+     * Refreshes the list of available maps with the given list of boards. \n+     */\n+    private void refreshBoardsAvailable(List<String> boardList) {\n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        // Replace the data model (adding the elements one by one to the existing model\n+        // in Java 8 style is sluggish because of event firing)\n+        DefaultListModel<String> newModel = new DefaultListModel<>();\n+        for (String s: boardList) {\n+            newModel.addElement(s);\n+        }\n+        lisBoardsAvailable.setModel(newModel);\n+        lisBoardsAvailable.clearSelection();\n+        lisBoardsAvailable.addListSelectionListener(this);\n+    }\n+    \n+    public boolean isMultipleBoards() {\n+        return mapSettings.getMapHeight() * mapSettings.getMapWidth() > 1;\n+    }\n+    \n+    MapSettings oldMapSettings = MapSettings.getInstance();\n+\n+    /**\n+     * Fills the Map Buttons scroll pane twith the appropriate amount of buttons\n+     * in the appropriate layout\n+     */\n+    private void refreshMapButtons() {\n+        panMapButtons.removeAll();\n+        panMapButtons.setVisible(false);\n+        panMapButtons.add(Box.createVerticalGlue());\n+        Dimension buttonSize = null;\n+\n+        // If buttons are unused, remove their image so that they update when they're used once more\n+        if (mapSettings.getMapHeight() * mapSettings.getMapWidth() < mapButtons.size()) {\n+            for (MapPreviewButton button: mapButtons.subList(mapSettings.getMapHeight() * mapSettings.getMapWidth(), mapButtons.size())) {\n+                button.reset();\n+            }\n+        }\n+\n+        // Add new map preview buttons if the map has grown\n+        while (mapSettings.getMapHeight() * mapSettings.getMapWidth() > mapButtons.size()) {\n+            mapButtons.add(new MapPreviewButton(this));\n+        }\n+\n+        // Re-add the buttons to the panel and update them as necessary\n+        for (int i = 0; i < mapSettings.getMapHeight(); i++) {\n+            JPanel row = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n+            panMapButtons.add(row);\n+            for (int j = 0; j < mapSettings.getMapWidth(); j++) {\n+                int index = i * mapSettings.getMapWidth() + j;\n+                MapPreviewButton button = mapButtons.get(index);\n+                button.setIndex(index);\n+                row.add(button);\n+\n+                // Update the board base image if it's generated and the settings have changed\n+                // or the board name has changed\n+                String boardName = mapSettings.getBoardsSelectedVector().get(index);\n+                if (!button.getBoard().equals(boardName) \n+                        || oldMapSettings.getMedium() != mapSettings.getMedium()\n+                        || (!mapSettings.equalMapGenParameters(oldMapSettings) \n+                                && mapSettings.getMapWidth() == oldMapSettings.getMapWidth()\n+                                && mapSettings.getMapHeight() == oldMapSettings.getMapHeight())) {\n+                    IBoard buttonBoard; \n+                    Image image;\n+                    // Generated and space boards use a generated example\n+                    if (boardName.startsWith(MapSettings.BOARD_GENERATED) \n+                            || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                        buttonBoard = BoardUtilities.generateRandom(mapSettings);\n+                        image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                    } else { \n+                        String boardForImage = boardName;\n+                        // For a surprise board, just use the first board as example\n+                        if (boardName.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                            boardForImage = extractSurpriseMaps(boardName).get(0);\n+                        }\n+                        File boardFile = new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile();\n+                        if (boardFile.exists()) {\n+                            buttonBoard = new Board(16, 17);\n+                            buttonBoard.load(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile());\n+                            StringBuffer errs = new StringBuffer();\n+                            try (InputStream is = new FileInputStream(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile())) {\n+                                buttonBoard.load(is, errs, true);\n+                            } catch (IOException ex) {\n+                                buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            }\n+                            image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                        } else {\n+                            buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            BufferedImage emptyBoardMap = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                            markServerSideBoard(emptyBoardMap);\n+                            image = emptyBoardMap;\n+                        }\n+                    }\n+                    button.setImage(image, boardName);\n+                    buttonSize = optMapButtonSize(image);\n+                }\n+                button.scheduleRescale();\n+            }\n+        }\n+        oldMapSettings = MapSettings.getInstance(mapSettings);\n+        \n+        if (buttonSize != null) {\n+            for (MapPreviewButton button: mapButtons) {\n+                button.setPreviewSize(buttonSize);\n+            }\n+        }\n+        splGroundMap.setDividerLocation(getDividerLocation());\n+\n+        panMapButtons.add(Box.createVerticalGlue());\n+        panMapButtons.setVisible(true);\n+\n+        lblBoardsAvailable.setText(mapSettings.getBoardWidth() + \"x\" + mapSettings.getBoardHeight() + \" \"\n+                + Messages.getString(\"BoardSelectionDialog.mapsAvailable\"));\n+        comMapSizes.removeActionListener(lobbyListener);\n+        int items = comMapSizes.getItemCount();\n+\n+        boolean mapSizeSelected = false;\n+        for (int i = 0; i < (items - 1); i++) {\n+            BoardDimensions size = (BoardDimensions) comMapSizes.getItemAt(i);\n+\n+            if ((size.width() == mapSettings.getBoardWidth()) && (size.height() == mapSettings.getBoardHeight())) {\n+                comMapSizes.setSelectedIndex(i);\n+                mapSizeSelected = true;\n+            }\n+        }\n+        // If we didn't select a size, select the last item: 'Custom Size'\n+        if (!mapSizeSelected) {\n+            comMapSizes.setSelectedIndex(items - 1);\n+        }\n+        comMapSizes.addActionListener(lobbyListener);\n+\n+    }\n+    \n+    private void markServerSideBoard(BufferedImage image) {\n+        Graphics g = image.getGraphics();\n+        GUIPreferences.AntiAliasifSet(g);\n+        int w = image.getWidth();\n+        int h = image.getHeight();\n+        String text = \"Server-side board\";\n+        int fontSize = Math.min(w / 10, UIUtil.scaleForGUI(16));\n+        g.setFont(new Font(\"Dialog\", Font.ITALIC, fontSize));\n+        FontMetrics fm = g.getFontMetrics(g.getFont());\n+        int cx = (w - fm.stringWidth(text)) / 2;\n+        int cy = h / 10 + fm.getAscent();\n+        g.setColor(GUIPreferences.getInstance().getWarningColor());\n+        g.drawString(text, cx, cy);\n+        g.dispose();\n+    }\n+\n+    public void previewGameBoard() {\n+        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);\n+        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];\n+        List<Boolean> rotateBoard = new ArrayList<>();\n+        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings.getMapHeight()); i++) {\n+            sheetBoards[i] = new Board();\n+            String name = mapSettings.getBoardsSelectedVector().get(i);\n+            if (name.startsWith(MapSettings.BOARD_GENERATED) \n+                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);\n+            } else {\n+                if (name.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                    List<String> boardList = extractSurpriseMaps(name);\n+                    int rnd = (int)(Math.random() * boardList.size());\n+                    name = boardList.get(rnd);\n+                }\n+                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name + \".board\").getFile());\n+            }\n+        }\n+\n+        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(), mapSettings.getMapWidth(),\n+                mapSettings.getMapHeight(), sheetBoards, rotateBoard, mapSettings.getMedium());\n+        \n+        boardPreviewGame.setBoard(newBoard);\n+        boardPreviewW.setVisible(true);\n+    }\n+\n+    /**\n+     * Refreshes the game settings with new info from the client\n+     */\n+    private void refreshGameSettings() {\n+        refreshTeams();\n+        refreshDoneButton();\n+    }\n+    \n+    /**\n+     * Refreshes the Mek Table contents \n+     */\n+    public void refreshEntities() {\n+        refreshTree();\n+        refreshMekTable();\n+    }\n+    \n+    private void refreshMekTable() {\n+        List<Integer> enIds = getSelectedEntities().stream().map(e -> e.getId()).collect(toList());\n+        mekModel.clearData();\n+        ArrayList<Entity> allEntities = new ArrayList<Entity>(clientgui.getClient().getEntitiesVector());\n+        Collections.sort(allEntities, activeSorter);\n+\n+        boolean localUnits = false;\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        for (Entity entity : allEntities) {\n+            // Remember if the local player has units.\n+            if (!localUnits && entity.getOwner().equals(localPlayer())) {\n+                localUnits = true;\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_PILOT_ADVANTAGES)) { \n+                entity.getCrew().clearOptions(PilotOptions.LVL3_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.EDGE)) { \n+                entity.getCrew().clearOptions(PilotOptions.EDGE_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_MANEI_DOMINI)) { \n+                entity.getCrew().clearOptions(PilotOptions.MD_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS)) { \n+                entity.clearPartialRepairs();\n+            }\n+            \n+            // Remove some deployment options when a unit is carried\n+            if (entity.getTransportId() != Entity.NONE) { \n+                entity.setHidden(false);\n+                entity.setProne(false);\n+                entity.setHullDown(false);\n+            }\n+            \n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) { \n+                entity.setHidden(false);\n+            }\n+            \n+            // Handle the \"Blind Drop\" option. In blind drop, units must be added\n+            // but they will be obscured in the table. In real blind drop, units\n+            // don't even get added to the table. Teams see their units in any case.\n+            boolean localUnit = entity.getOwner().equals(localPlayer());\n+            boolean teamUnit = !entity.getOwner().isEnemyOf(localPlayer());\n+            boolean realBlindDrop = opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+            if (localUnit || teamUnit || !realBlindDrop) {\n+                mekModel.addUnit(entity);\n+            }\n+        }\n+        // Restore selection\n+        if (!enIds.isEmpty()) {\n+            for (int i = 0; i < mekTable.getRowCount(); i++) {\n+                if (enIds.contains(mekModel.getEntityAt(i).getId())) {\n+                    mekTable.addRowSelectionInterval(i, i);\n+                }\n+            }\n+        }\n+\n+        // Enable the \"Save Unit List...\" button if the local player has units.\n+        clientgui.getMenuBar().setUnitList(localUnits);\n+    }\n+    \n+    /** Adjusts the mektable to compact/normal mode. */\n+    private void toggleCompact() {\n+        setTableRowHeights();\n+        mekModel.refreshCells();\n+        mekForceTreeModel.nodeChanged((TreeNode)mekForceTreeModel.getRoot());\n+        \n+    }\n+\n+    /** Refreshes the player info table. */\n+    private void refreshPlayerTable() {\n+        // Remember the selected players\n+        var selPlayerIds = getselectedPlayers().stream().map(IPlayer::getId).collect(toSet());\n+\n+        // Empty and refill the player table\n+        playerModel.replaceData(game().getPlayersVector());\n+\n+        // re-select the previously selected players, if possible\n+        for (int row = 0; row < playerModel.getRowCount(); row++) {\n+            if (selPlayerIds.contains(playerModel.getPlayerAt(row).getId())) {\n+                tablePlayers.addRowSelectionInterval(row, row);\n+            }\n+        }\n+    }\n+\n+    /** Updates the camo button to displays the camo of the currently selected player. */ \n+    private void refreshCamoButton() {\n+        if ((tablePlayers == null) || (playerModel == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (player != null) {\n+            butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        }\n+    }\n+\n+    /** Sets up the team choice box. */\n+    private void setupTeamCombo() {\n+        for (int i = 0; i < IPlayer.MAX_TEAMS; i++) {\n+            comboTeam.addItem(IPlayer.teamNames[i]);\n+        }\n+    }\n+\n+    /** Updates the team choice combobox to show the selected player's team. */\n+    private void refreshTeams() {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(localPlayer().getTeam());\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the Done button. The label will say the opposite of the\n+     * player's \"done\" status, indicating that clicking it will reverse the\n+     * condition.\n+     */\n+    private void refreshDoneButton(boolean done) {\n+        butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n+    }\n+\n+    /** Refreshes the state of the Done button with the state of the local player. */\n+    private void refreshDoneButton() {\n+        refreshDoneButton(localPlayer().isDone());\n+    }\n+\n+    /**\n+     * Embarks the given carried Entity onto the carrier given as carrierId.\n+     */\n+    void loadOnto(Entity carried, int carrierId, int bayNumber) {\n+        Entity carrier = game().getEntity(carrierId);\n+        if (carrier == null || !isLoadable(carried, carrier)) {\n+            return;\n+        }\n+\n+        // We need to make sure our current bomb choices fit onto the new\n+        // fighter\n+        if (carrier instanceof FighterSquadron) {\n+            FighterSquadron fSquad = (FighterSquadron) carrier;\n+            // We can't use Aero.getBombPoints() because the bombs haven't been\n+            // loaded yet, only selected, so we have to count the choices\n+            int[] bombChoice = fSquad.getBombChoices();\n+            int numLoadedBombs = 0;\n+            for (int i = 0; i < bombChoice.length; i++) {\n+                numLoadedBombs += bombChoice[i];\n+            }\n+            // We can't load all of the squadrons bombs\n+            if (numLoadedBombs > ((IBomber)carried).getMaxBombPoints()) {\n+                JOptionPane.showMessageDialog(clientgui.frame, Messages.getString(\"FighterSquadron.bomberror\"),\n+                        Messages.getString(\"FighterSquadron.error\"), JOptionPane.ERROR_MESSAGE);\n+                return;\n+            }\n+        }\n+        \n+        getLocalClient(carried).sendLoadEntity(carried.getId(), carrierId, bayNumber);\n+        // TODO: it would probably be a good idea \n+        // to disable some settings for loaded units in customMechDialog\n+    }\n+\n+    /** \n+     * Have the given entity disembark if it is carried by another unit.\n+     * Entities that are modified and need an update to be sent to the server\n+     * are added to the given updateCandidates. \n+     */\n+    void disembark(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = game().getEntity(entity.getTransportId());\n+        if (carrier != null) {\n+            carrier.unload(entity);\n+            entity.setTransportId(Entity.NONE);\n+            updateCandidates.add(entity);\n+            updateCandidates.add(carrier);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity disembark if it is carried by a unit of another player.\n+     * Entities that were modified and need an update to be sent to the server\n+     * are added to the given updateCandidate set. \n+     */\n+    void disembarkDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = clientgui.getClient().getGame().getEntity(entity.getTransportId());\n+        if (carrier != null && (ownerOf(entity) != ownerOf(carrier))) {\n+            disembark(entity, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entities offload all the units they are carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadAll(Collection<Entity> entities, Collection<Entity> updateCandidates) {\n+        for (Entity carrier: editableEntities(entities)) {\n+            offloadFrom(carrier, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all the units it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFrom(Entity entity, Collection<Entity> updateCandidates) {\n+        if (isEditable(entity)) {\n+            for (Entity carriedUnit: entity.getLoadedUnits()) {\n+                disembark(carriedUnit, updateCandidates);\n+            } \n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all units of different players it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFromDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        for (Entity carriedUnit: entity.getLoadedUnits()) {\n+            if (ownerOf(carriedUnit) != ownerOf(entity)) {\n+                disembark(carriedUnit, updateCandidates);\n+            }\n+        } \n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. \n+     */\n+    void sendUpdate(Collection<Entity> updateCandidates) {\n+        for (Entity e: editableEntities(updateCandidates)) {\n+            getLocalClient(e).sendUpdateEntity(e);\n+        }\n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. Will separate the units into update\n+     * packets for the local player and any local bots so that the \n+     * server accepts all changes (as the server does not know of\n+     * local bots and rejects updates that are not for the sending client\n+     * or its teammates. \n+     */\n+    void sendUpdates(Collection<Entity> entities) {\n+        List<IPlayer> owners = entities.stream().map(e -> e.getOwner()).distinct().collect(toList());\n+        for (IPlayer owner: owners) {\n+            client().sendUpdateEntity(new ArrayList<Entity>(\n+                    entities.stream().filter(e -> e.getOwner().equals(owner)).collect(toList())));\n+        }\n+    }\n+    \n+    /** \n+     * Disembarks all given entities from any transports they are in. \n+     */\n+    void disembarkAll(Collection<Entity> entities) {\n+        Set<Entity> updateCandidates = new HashSet<>();\n+        entities.stream().filter(e -> isEditable(e)).forEach(e -> disembark(e, updateCandidates));\n+        sendUpdate(updateCandidates);\n+    }\n+\n+    /** \n+     * Returns true when the given entity may be configured by the local player,\n+     * i.e. if it is his own unit or one of his bot's units.\n+     * <P>Note that this is more restrictive than the Server is. The Server\n+     * accepts entity changes also for teammates so that entity updates that \n+     * signal transporting a teammate's unit don't get rejected. I feel that\n+     * configuration other than transporting units should be limited to one's\n+     * own units (and bots) though.\n+     */\n+    boolean isEditable(Entity entity) {\n+        return clientgui.getBots().containsKey(entity.getOwner().getName())\n+                || (entity.getOwnerId() == localPlayer().getId());\n+    }\n+    \n+    /** \n+     * Returns true when the given entity may NOT be configured by the local player,\n+     * i.e. if it is not own unit or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isNotEditable(Entity entity) {\n+        return !isEditable(entity);\n+    }\n+    \n+    /** \n+     * Returns true when all given entities may be configured by the local player,\n+     * i.e. if they are his own units or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isEditable(Collection<Entity> entities) {\n+        return !entities.stream().anyMatch(this::isNotEditable);\n+    }\n+    \n+    /** \n+     * Returns the Client associated with a given entity that may be configured\n+     * by the local player (his own unit or one of his bot's units).\n+     * For a unit that cannot be configured (owned by a remote player) the client\n+     * of the local player is returned.\n+     */\n+    Client getLocalClient(Entity entity) {\n+        if (clientgui.getBots().containsKey(entity.getOwner().getName())) {\n+            return clientgui.getBots().get(entity.getOwner().getName());\n+        } else {\n+            return clientgui.getClient();\n+        }\n+    }\n+\n+    public void configPlayer() {\n+        Client c = getSelectedClient();\n+        if (null == c) {\n+            return;\n+        }\n+        \n+        PlayerSettingsDialog psd = new PlayerSettingsDialog(clientgui, c);\n+        boolean okay = psd.showDialog();\n+        \n+        if (okay) {\n+            IPlayer player = c.getLocalPlayer();\n+            player.setConstantInitBonus(psd.getInit());\n+            player.setNbrMFConventional(psd.getCnvMines());\n+            player.setNbrMFVibra(psd.getVibMines());\n+            player.setNbrMFActive(psd.getActMines());\n+            player.setNbrMFInferno(psd.getInfMines());\n+            var rsg = c.getRandomSkillsGenerator();\n+            rsg.setMethod(psd.getMethod());\n+            rsg.setType(psd.getPilot());\n+            rsg.setLevel(psd.getXP());\n+            rsg.setClose(psd.getForceGP());\n+            \n+            // The deployment position\n+            int startPos = psd.getStartPos();\n+            final GameOptions gOpts = clientgui.getClient().getGame().getOptions();\n+            if (gOpts.booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                    && (startPos >= 1) && (startPos <= 9)) {\n+                startPos += 10;\n+            }\n+            c.getLocalPlayer().setStartingPos(startPos);\n+            c.sendPlayerInfo();\n+            \n+            // If the gameoption set_arty_player_homeedge is set, adjust the player's offboard \n+            // arty units to be behind the newly selected home edge.\n+            OffBoardDirection direction = OffBoardDirection.translateStartPosition(startPos);\n+            if (direction != OffBoardDirection.NONE && \n+                    gOpts.booleanOption(OptionsConstants.BASE_SET_ARTY_PLAYER_HOMEEDGE)) {\n+                for (Entity entity: c.getGame().getPlayerEntities(c.getLocalPlayer(), false)) {\n+                    if (entity.getOffBoardDirection() != OffBoardDirection.NONE) {\n+                        entity.setOffBoard(entity.getOffBoardDistance(), direction);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    \n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechReadoutAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechReadout(entity, index++);\n+        }\n+    } \n+\n+    /** \n+     * Shows the unit summary for the given unit. Moves the dialog a bit depending on index\n+     * so that multiple dialogs dont appear exactly on top of each other. \n+     */\n+    private void mechReadout(Entity entity, int index) {\n+        final ClientDialog dialog = new ClientDialog(clientgui.frame, Messages.getString(\"ChatLounge.quickView\"), false, true);\n+        final int height = 600;\n+        final int width = 500;\n+\n+        MechView mv = new MechView(entity, false);\n+        // The label must want a fixed width to enforce linebreaks on fluff text\n+        JLabel mechSummary = new JLabel(\"<HTML>\" + mv.getMechReadoutHead()\n+        + mv.getMechReadoutBasic() + mv.getMechReadoutLoadout()\n+        + mv.getMechReadoutFluff()) {\n+            private static final long serialVersionUID = 2989361635430008853L;\n+            @Override\n+            public Dimension getPreferredSize() {\n+                return new Dimension(width - 10, super.getPreferredSize().height);\n+            }\n+        };\n+        mechSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(mechSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.center();\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechBVAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechBVDisplay(entity, index++);\n+        }\n+    } \n+    \n+    /**\n+     * @param entity the entity to display the BV Calculation for\n+     */\n+    void mechBVDisplay(Entity entity, int index) {\n+        final JDialog dialog = new ClientDialog(clientgui.frame, \"BV Calculation Display\", false, true);\n+        final int height = 600;\n+        \n+        entity.calculateBattleValue();\n+        JLabel bvSummary = new JLabel(entity.getBVText());\n+        bvSummary.setFont(new Font(\"Dialog\",Font.PLAIN, scaleForGUI(14)));\n+        bvSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(bvSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(bvSummary.getPreferredSize().width + 40, scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /**\n+     * Pop up the dialog to load a mech\n+     */\n+    private void addUnit() {\n+        clientgui.getMechSelectorDialog().updateOptionValues();\n+        clientgui.getMechSelectorDialog().setVisible(true);\n+    }\n+    \n+    private void createArmy() {\n+        clientgui.getRandomArmyDialog().setVisible(true);\n+    }\n+\n+    public void loadRandomSkills() {\n+        clientgui.getRandomSkillDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    public void loadRandomNames() {\n+        clientgui.getRandomNameDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    void changeMapDnD(String board, JButton button) {\n+        if (board.contains(\"\\n\")) {\n+            board = MapSettings.BOARD_SURPRISE + board;\n+        }\n+        mapSettings.getBoardsSelectedVector().set(mapButtons.indexOf(button), board);\n+        clientgui.getClient().sendMapSettings(mapSettings);\n+        if (boardPreviewW.isVisible()) {\n+            previewGameBoard();\n+        }\n+    }\n+    \n+    \n+\n+    //\n+    // GameListener\n+    //\n+    @Override\n+    public void gamePlayerChange(GamePlayerChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshDoneButton();\n+        clientgui.getClient().getGame().setupTeams();\n+        refreshPlayerTable();\n+        refreshPlayerConfig();\n+        refreshCamoButton();\n+        refreshEntities();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gamePhaseChange(GamePhaseChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        \n+        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {\n+            refreshDoneButton();\n+            refreshGameSettings();\n+            refreshPlayerTable();\n+            refreshTeams();\n+            refreshCamoButton();\n+            refreshEntities();\n+            panTeamOverview.refreshData();\n+        }\n+    }\n+\n+    @Override\n+    public void gameEntityNew(GameEntityNewEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameSettingsChange(GameSettingsChangeEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshGameSettings();\n+        // The table sorting may no longer be allowed (e.g. when blind drop was activated)\n+        if (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())) {\n+            nextSorter(unitSorters);\n+            updateTableHeaders();\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        refreshMapSizes();\n+        updateMapSettings(clientgui.getClient().getMapSettings());\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameClientFeedbackRequest(GameCFREvent evt) {\n+        // Do nothing\n+    }\n+\n+    \n+    private ActionListener lobbyListener = new ActionListener() {\n+\n+        @Override\n+        public void actionPerformed(ActionEvent ev) {\n+\n+            // Are we ignoring events?\n+            if (isIgnoringEvents()) {\n+                return;\n+            }\n+            \n+            if (ev.getSource().equals(butAdd)) {\n+                addUnit();\n+                \n+            } else if (ev.getSource().equals(butArmy)) {\n+                createArmy();\n+                \n+            } else if (ev.getSource().equals(butSkills)) {\n+                loadRandomSkills();\n+                \n+            } else if (ev.getSource().equals(butNames)) {\n+                loadRandomNames();\n+                \n+            } else if (ev.getSource().equals(tablePlayers)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(comboTeam)) {\n+                lobbyActions.changeTeam(getselectedPlayers(), comboTeam.getSelectedIndex());\n+                \n+            } else if (ev.getSource().equals(butConfigPlayer)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(butBotSettings)) {\n+                doBotSettings();\n+                \n+            } else if (ev.getSource().equals(butOptions)) {\n+                // Make sure the game options dialog is editable.\n+                if (!clientgui.getGameOptionsDialog().isEditable()) {\n+                    clientgui.getGameOptionsDialog().setEditable(true);\n+                }\n+                // Display the game options dialog.\n+                clientgui.getGameOptionsDialog().update(clientgui.getClient().getGame().getOptions());\n+                clientgui.getGameOptionsDialog().setVisible(true);\n+                \n+            } else if (ev.getSource().equals(butCompact)) {\n+                toggleCompact();\n+                \n+            } else if (ev.getSource().equals(butLoadList)) {\n+                // Allow the player to replace their current\n+                // list of entities with a list from a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));  //$NON-NLS-2$\n+                    return;\n+                }\n+                clientgui.loadListFile(c.getLocalPlayer());\n+                \n+            } else if (ev.getSource().equals(butSaveList)) {\n+                // Allow the player to save their current\n+                // list of entities to a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));\n+                    return;\n+                }\n+                clientgui.saveListFile(c.getGame().getPlayerEntities(c.getLocalPlayer(), false),\n+                        c.getLocalPlayer().getName());\n+                \n+            } else if (ev.getSource().equals(butAddBot)) {\n+                BotConfigDialog bcd = new BotConfigDialog(clientgui.frame);\n+                bcd.setVisible(true);\n+                if (bcd.dialogAborted) {\n+                    return; // user didn't click 'ok', add no bot\n+                }\n+                if (clientgui.getBots().containsKey(bcd.getBotName())) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertExistsBot.title\"),\n+                            Messages.getString(\"ChatLounge.AlertExistsBot.message\"));  //$NON-NLS-2$\n+                } else {\n+                    BotClient c = bcd.getSelectedBot(clientgui.getClient().getHost(), clientgui.getClient().getPort());\n+                    c.setClientGUI(clientgui);\n+                    c.getGame().addGameListener(new BotGUI(c));\n+                    try {\n+                        c.connect();\n+                    } catch (Exception e) {\n+                        clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertBot.title\"),\n+                                Messages.getString(\"ChatLounge.AlertBot.message\"));  //$NON-NLS-2$\n+                    }\n+                    clientgui.getBots().put(bcd.getBotName(), c);\n+                }\n+                \n+            } else if (ev.getSource().equals(butRemoveBot)) {\n+                removeBot();\n+                \n+            } else if (ev.getSource().equals(butShowUnitID)) {\n+                PreferenceManager.getClientPreferences().setShowUnitId(butShowUnitID.isSelected());\n+                mekModel.refreshCells();\n+                repaint();\n+                \n+            } else if (ev.getSource() == butConditions) {\n+                PlanetaryConditionsDialog pcd = new PlanetaryConditionsDialog(clientgui);\n+                boolean userOkay = pcd.showDialog();\n+                if (userOkay) {\n+                    clientgui.getClient().sendPlanetaryConditions(pcd.getConditions());\n+                }\n+                \n+            } else if (ev.getSource() == butRandomMap) {\n+                RandomMapDialog rmd = new RandomMapDialog(clientgui.frame, ChatLounge.this, clientgui.getClient(), mapSettings);\n+                rmd.activateDialog(clientgui.getBoardView().getTilesetManager().getThemes());\n+                \n+            } else if (ev.getSource().equals(butBoardPreview)) {\n+                previewGameBoard();\n+                \n+            } else if (ev.getSource().equals(comMapSizes)) {\n+                if (comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"))) {\n+                    refreshMapUI();\n+                } else if (comMapSizes.getSelectedItem() != null) {\n+                    BoardDimensions size = (BoardDimensions) comMapSizes.getSelectedItem();\n+                    mapSettings.setBoardSize(size.width(), size.height());\n+                    resetAvailBoardSelection = true;\n+                    resetSelectedBoards = true;\n+                    clientgui.getClient().sendMapSettings(mapSettings);\n+                } \n+                \n+            } else if (ev.getSource() == butGroundMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_GROUND);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butSpaceMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_SPACE);\n+                mapSettings.setBoardSize(50, 50);\n+                mapSettings.setMapSize(1, 1);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butLowAtmoMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_ATMOSPHERE);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddX || ev.getSource() == butMapGrowW) {\n+                int newMapWidth = mapSettings.getMapWidth() + 1;\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddY || ev.getSource() == butMapGrowH) {\n+                int newMapHeight = mapSettings.getMapHeight() + 1;\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butSaveMapSetup) {\n+                saveMapSetup();\n+                \n+            } else if (ev.getSource() == butLoadMapSetup) {\n+                loadMapSetup();\n+                \n+            } else if (ev.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+                \n+            } else if (ev.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+                \n+            } else if (ev.getSource() == butMapShrinkW) {\n+                if (mapSettings.getMapWidth() > 1) {\n+                    int newMapWidth = mapSettings.getMapWidth() - 1;\n+                    mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butMapShrinkH) {\n+                if (mapSettings.getMapHeight() > 1) {\n+                    int newMapHeight = mapSettings.getMapHeight() - 1;\n+                    mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butDetach) {\n+                butDetach.setEnabled(false);\n+                panTeam.remove(panTeamOverview);\n+                panTeam.repaint();\n+                panTeamOverview.setDetached(true);\n+                teamOverviewWindow.add(panTeamOverview);\n+                teamOverviewWindow.center();\n+                teamOverviewWindow.setVisible(true);\n+                \n+            } else if (ev.getSource() == butCancelSearch) {\n+                fldSearch.setText(\"\");\n+\n+            } else if (ev.getSource() == butHelp) {\n+                File helpfile = new File(\"docs/Boards Stuff/MapAssemblyHelp.html\");\n+                final JDialog dialog = new ClientDialog(clientgui.frame, \"Map Assembly Help\", true, true);\n+                final int height = 600;\n+                final int width = 600;\n+                \n+                final JEditorPane pane = new JEditorPane();\n+                pane.setName(\"helpPane\");\n+                pane.setEditable(false);\n+                pane.setFont(new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1)));\n+                try {\n+                    pane.setPage(helpfile.toURI().toURL());\n+                    JScrollPane tScroll = new JScrollPane(pane,\n+                            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+                    tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+                    dialog.add(tScroll, BorderLayout.CENTER);\n+                } catch (Exception e) {\n+                    dialog.setTitle(Messages.getString(\"AbstractHelpDialog.noHelp.title\"));\n+                    pane.setText(Messages.getString(\"AbstractHelpDialog.errorReading\") + e.getMessage());\n+                    MegaMek.getLogger().error(e);\n+                }\n+\n+                JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+                button.addActionListener(e -> dialog.setVisible(false));\n+                JPanel okayPanel = new JPanel(new FlowLayout());\n+                okayPanel.add(button);\n+                dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+                Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+                dialog.setPreferredSize(sz);\n+                dialog.setVisible(true);\n+                \n+            } else if (ev.getSource() == butListView) {\n+                scrMekTable.setViewportView(mekTable);\n+                butCollapse.setEnabled(false);\n+                butExpand.setEnabled(false);\n+                \n+            } else if (ev.getSource() == butForceView) {\n+                scrMekTable.setViewportView(mekForceTree);\n+                butCollapse.setEnabled(true);\n+                butExpand.setEnabled(true);\n+                \n+            } else if (ev.getSource() == butCollapse) {\n+                collapseTree();\n+            } else if (ev.getSource() == butExpand) {\n+                expandTree();\n+            } \n+        }\n+    };\n+    \n+    /** Expands the Mek Force Tree fully. */\n+    private void expandTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.expandRow(i);\n+        }\n+    }\n+    \n+    /** Collapses the Mek Force Tree fully. */\n+    private void collapseTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.collapseRow(i);\n+        }\n+    }\n+    \n+    \n+    /** \n+     * Opens a file chooser and saves the current map setup to the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void saveMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.saveMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showSaveDialog(clientgui.frame);\n+        File selectedFile = fc.getSelectedFile();\n+        if (!selectedFile.getName().toLowerCase().endsWith(\".xml\")) {\n+            selectedFile = new File(selectedFile.getPath() + \".xml\");\n+        }\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (selectedFile == null)) {\n+            return;\n+        }\n+        if (selectedFile.exists()) {\n+            String msg = Messages.getString(\"ChatLounge.map.saveMapSetupReplace\", selectedFile.getName());\n+            if (!MMConfirmDialog.confirm(clientgui.frame, \"Confirm replace\", msg)) {\n+                return;\n+            }\n+        }\n+        try(OutputStream os = new FileOutputStream(selectedFile)) {\n+            MapSetup.save(os, mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while saving the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+\n+    /** \n+     * Opens a file chooser and loads a new map setup from the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void loadMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showOpenDialog(clientgui.frame);\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (fc.getSelectedFile() == null)) {\n+            return;\n+        }\n+        if (!fc.getSelectedFile().exists()) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \"File not found.\");\n+            return;\n+        }\n+        try(InputStream os = new FileInputStream(fc.getSelectedFile())) {\n+            MapSetup setup = MapSetup.load(os);\n+            mapSettings.setMapSize(setup.getMapWidth(), setup.getMapHeight());\n+            mapSettings.setBoardSize(setup.getBoardWidth(), setup.getBoardHeight());\n+            mapSettings.setBoardsSelectedVector(setup.getBoards());\n+            clientgui.getClient().sendMapSettings(mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while loading the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+    \n+    private void removeBot() {\n+        Client c = getSelectedClient();\n+        if (!client().bots.containsValue(c)) {\n+//        if ((c == null) || c.equals(clientgui.getClient())) {\n+//            clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+//                    Messages.getString(\"ChatLounge.SelectBo\"));\n+            LobbyErrors.showOnlyOwnBot(clientgui.frame);\n+            return;\n+        }\n+        // Delete units first, which safely disembarks and offloads them\n+        // Don't delete the bot's forces, as that could also delete other players' entitites\n+//        lobbyActions.delete(new ArrayList<>(), game().getPlayerEntities(c.getLocalPlayer(), false), false);\n+        c.die();\n+        clientgui.getBots().remove(c.getName());\n+    }\n+    \n+    private void doBotSettings() {\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        BotClient bot = (BotClient) clientgui.getBots().get(player.getName());\n+        BotConfigDialog bcd = new BotConfigDialog(clientgui.frame, bot);\n+        bcd.setVisible(true);\n+\n+        if (bcd.dialogAborted) {\n+            return; // user didn't click 'ok', add no bot\n+        } else if (bot instanceof Princess) {\n+            ((Princess) bot).setBehaviorSettings(bcd.getBehaviorSettings());\n+            \n+            // bookkeeping:\n+            clientgui.getBots().remove(player.getName());\n+            bot.setName(bcd.getBotName());\n+            clientgui.getBots().put(bot.getName(), bot);\n+            player.setName(bcd.getBotName());\n+            clientgui.chatlounge.refreshPlayerTable();\n+        }\n+    }\n+    \n+    // Put a filter on the files that the user can select the proper file.\n+    FileFilter XMLFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return (f.getPath().toLowerCase().endsWith(\".xml\") || f.isDirectory());\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Map Setup XML files\";\n+        }\n+    };\n+    \n+    private void setManualMapWidth() {\n+        try {\n+            int newMapWidth = Integer.parseInt(fldMapWidth.getText());\n+            if (newMapWidth >= 1 && newMapWidth <= 20) {\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map width\n+        }\n+    }\n+    \n+    private void setManualMapHeight() {\n+        try {\n+            int newMapHeight = Integer.parseInt(fldMapHeight.getText());\n+            if (newMapHeight >= 1 && newMapHeight <= 20) {\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map height\n+        }\n+    }\n+    \n+    private void setManualBoardWidth() {\n+        try {\n+            int newBoardWidth = Integer.parseInt(fldSpaceBoardWidth.getText());\n+            if (newBoardWidth >= 5 && newBoardWidth <= 200) {\n+                mapSettings.setBoardSize(newBoardWidth, mapSettings.getBoardHeight());\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board width\n+        }\n+    }\n+    \n+    private void setManualBoardHeight() {\n+        try {\n+            int newBoardHeight = Integer.parseInt(fldSpaceBoardHeight.getText());\n+            if (newBoardHeight >= 5 && newBoardHeight <= 200) {\n+                mapSettings.setBoardSize(mapSettings.getBoardWidth(), newBoardHeight);\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board height\n+        }\n+    }\n+\n+    /**\n+     * Updates to show the map settings that have, presumably, just been sent by\n+     * the server.\n+     */\n+    @Override\n+    public void updateMapSettings(MapSettings newSettings) {\n+        mapSettings = MapSettings.getInstance(newSettings);\n+        refreshMapButtons();\n+        refreshMapChoice();\n+        refreshMapUI();\n+        refreshBoardsAvailable();\n+        updateSearch(fldSearch.getText());\n+        refreshLabels();\n+    }\n+\n+\n+    /**OK Refreshes the Map Summary, Tech Level and Game Year labels. */\n+    private void refreshLabels() {\n+        Font scaledFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1));\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        String txt = Messages.getString(\"ChatLounge.GameYear\"); \n+        txt += opts.intOption(OptionsConstants.ALLOWED_YEAR);\n+        lblGameYear.setText(txt);\n+        lblGameYear.setFont(scaledFont);\n+        lblGameYear.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\"))); \n+        \n+        String tlString = TechConstants.getLevelDisplayableName(TechConstants.T_TECH_UNKNOWN);\n+        IOption tlOpt = opts.getOption(OptionsConstants.ALLOWED_TECHLEVEL);\n+        if (tlOpt != null) {\n+            tlString = tlOpt.stringValue();\n+        }\n+        lblTechLevel.setText(Messages.getString(\"ChatLounge.TechLevel\") + tlString);\n+        lblTechLevel.setFont(scaledFont);\n+        lblTechLevel.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\")));\n+        \n+        txt = Messages.getString(\"ChatLounge.MapSummary\"); \n+        txt += (mapSettings.getBoardWidth() * mapSettings.getMapWidth()) + \" x \" \n+                + (mapSettings.getBoardHeight() * mapSettings.getMapHeight());\n+        if (butGroundMap.isSelected()) {\n+            txt += \" Ground Map\";\n+        } else if (butLowAtmoMap.isSelected()) {\n+            txt += \" Atmospheric Map\";\n+        } else {\n+            txt += \" Space Map\";\n+        }\n+        lblMapSummary.setText(txt);\n+        lblMapSummary.setFont(scaledFont);\n+\n+        StringBuilder selectedMaps = new StringBuilder();\n+        selectedMaps.append(Messages.getString(\"ChatLounge.MapSummarySelectedMaps\"));\n+        for (String map: mapSettings.getBoardsSelectedVector()) {\n+            selectedMaps.append(\"&nbsp;&nbsp;\");\n+            if (map.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                selectedMaps.append(MapSettings.BOARD_SURPRISE);\n+            } else {\n+                selectedMaps.append(map);\n+            }\n+            selectedMaps.append(\"<br>\"); \n+        }\n+        lblMapSummary.setToolTipText(scaleStringForGUI(selectedMaps.toString()));\n+    }\n+    \n+    @Override\n+    public void ready() {\n+        final Client client = clientgui.getClient();\n+        final IGame game = client.getGame();\n+        final GameOptions gOpts = game.getOptions();\n+        \n+        // enforce exclusive deployment zones in double blind\n+        for (IPlayer player: client.getGame().getPlayersVector()) {\n+            if (!isValidStartPos(game, player)) {\n+                clientgui.doAlertDialog(Messages.getString(\"ChatLounge.OverlapDeploy.title\"), \n+                        Messages.getString(\"ChatLounge.OverlapDeploy.msg\"));\n+                return;\n+            }\n+        }\n+\n+        // Make sure player has a commander if Commander killed victory is on\n+        if (gOpts.booleanOption(OptionsConstants.VICTORY_COMMANDER_KILLED)) {\n+            List<String> players = new ArrayList<>();\n+            if ((game.getLiveCommandersOwnedBy(localPlayer()) < 1)\n+                    && (game.getEntitiesOwnedBy(localPlayer()) > 0)) {\n+                players.add(client.getLocalPlayer().getName());\n+            }\n+            for (Client bc : clientgui.getBots().values()) {\n+                if ((game.getLiveCommandersOwnedBy(bc.getLocalPlayer()) < 1)\n+                        && (game.getEntitiesOwnedBy(bc.getLocalPlayer()) > 0)) {\n+                    players.add(bc.getLocalPlayer().getName());\n+                }\n+            }\n+            if (players.size() > 0) {\n+                String title = Messages.getString(\"ChatLounge.noCmdr.title\"); \n+                String msg = Messages.getString(\"ChatLounge.noCmdr.msg\"); \n+                for (String player : players) {\n+                    msg += player + \"\\n\";\n+                }\n+                clientgui.doAlertDialog(title, msg);\n+                return;\n+            }\n+\n+        }\n+\n+        boolean done = !localPlayer().isDone();\n+        client.sendDone(done);\n+        refreshDoneButton(done);\n+        for (Client botClient : clientgui.getBots().values()) {\n+            botClient.sendDone(done);\n+        }\n+    }\n+\n+    Client getSelectedClient() {\n+        if ((tablePlayers == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return null;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (localPlayer().equals(player)) {\n+            return client();\n+        } else if (client().bots.containsKey(player.getName())) {\n+            return client().bots.get(player.getName());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Stop just ignoring events and actually stop listening to them.\n+     */\n+    @Override\n+    public void removeAllListeners() {\n+        clientgui.getClient().getGame().removeGameListener(this);\n+        clientgui.getBoardView().removeBoardViewListener(this);\n+        GUIPreferences.getInstance().removePreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().removePreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().removeListener(mechSummaryCacheListener);\n+        \n+        if (loader != null) {\n+            loader.cancel(true);\n+        }\n+        \n+        tablePlayers.getSelectionModel().removeListSelectionListener(this);\n+        tablePlayers.removeMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        lisBoardsAvailable.removeMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.removeWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.removeMouseListener(mekTableMouseAdapter);\n+        mekForceTree.removeMouseListener(mekForceTreeMouseListener);\n+        mekTable.getTableHeader().removeMouseListener(mekTableHeaderMouseListener);\n+        mekTable.removeKeyListener(mekTableKeyListener);\n+        mekForceTree.removeKeyListener(mekTreeKeyListener);\n+        \n+        butAdd.removeActionListener(lobbyListener);\n+        butAddBot.removeActionListener(lobbyListener);\n+        butArmy.removeActionListener(lobbyListener);\n+        butBoardPreview.removeActionListener(lobbyListener);\n+        butBotSettings.removeActionListener(lobbyListener);\n+        butCompact.removeActionListener(lobbyListener);\n+        butConditions.removeActionListener(lobbyListener);\n+        butConfigPlayer.removeActionListener(lobbyListener);\n+        butLoadList.removeActionListener(lobbyListener);\n+        butNames.removeActionListener(lobbyListener);\n+        butOptions.removeActionListener(lobbyListener);\n+        butRandomMap.removeActionListener(lobbyListener);\n+        butRemoveBot.removeActionListener(lobbyListener);\n+        butSaveList.removeActionListener(lobbyListener);\n+        butShowUnitID.removeActionListener(lobbyListener);\n+        butSkills.removeActionListener(lobbyListener);\n+        butSpaceSize.removeActionListener(lobbyListener);\n+        butCamo.removeActionListener(camoListener);\n+        butAddX.removeActionListener(lobbyListener);\n+        butAddY.removeActionListener(lobbyListener);\n+        butMapGrowW.removeActionListener(lobbyListener);\n+        butMapShrinkW.removeActionListener(lobbyListener);\n+        butMapGrowH.removeActionListener(lobbyListener);\n+        butMapShrinkH.removeActionListener(lobbyListener);\n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        butLoadMapSetup.removeActionListener(lobbyListener);\n+        butSaveMapSetup.removeActionListener(lobbyListener);\n+        butDetach.removeActionListener(lobbyListener);\n+        butCancelSearch.removeActionListener(lobbyListener);\n+        butHelp.removeActionListener(lobbyListener);\n+        butListView.removeActionListener(lobbyListener);\n+        butForceView.removeActionListener(lobbyListener);\n+        butCollapse.removeActionListener(lobbyListener);\n+        butExpand.removeActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        \n+        comboTeam.removeActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Returns true if the given list of entities can be configured as a group.\n+     * This requires that they all have the same owner, and that none of the\n+     * units are being transported. Also, the owner must be the player or one\n+     * of his bots. \n+     */\n+    boolean canConfigureMultipleDeployment(Collection<Entity> entities) {\n+        return haveSingleOwner(entities) \n+                && !containsTransportedUnit(entities)\n+                && canEditAny(entities);\n+    }\n+    \n+    /**\n+     * Returns true if the given collection contains at least one entity\n+     * that the local player can edit, i.e. is his own or belongs to\n+     * one of his bots. Does not check if the units are otherwise configured,\n+     * e.g. transported.\n+     * <P>See also {@link #isEditable(Entity)}\n+     */\n+    boolean canEditAny(Collection<Entity> entities) {\n+        return entities.stream().anyMatch(e -> isEditable(e));\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see all of the given entities.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not on his team.\n+     */\n+    boolean canSeeAll(Collection<Entity> entities) {\n+        if (!game().getOptions().booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                && !game().getOptions().booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP)) {\n+            return true;\n+        }\n+        for (Entity entity: entities) {\n+            if (!entityInLocalTeam(entity)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see the given entity.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not his own.\n+     */\n+    boolean canSee(Entity entity) {\n+        return canSeeAll(Arrays.asList(entity));\n+    }\n+    \n+    boolean entityInLocalTeam(Entity entity) {\n+        return !localPlayer().isEnemyOf(entity.getOwner());\n+    }\n+    \n+\n+    @Override\n+    public void valueChanged(ListSelectionEvent event) {\n+        if (event.getValueIsAdjusting()) {\n+            return;\n+        }\n+        \n+        if (event.getSource().equals(tablePlayers.getSelectionModel())) {\n+            refreshPlayerConfig();\n+        }\n+    }\n+    \n+    /** Adapts the enabled state of the player config UI items to the player selection. */\n+    private void refreshPlayerConfig() {\n+        var selPlayers = getselectedPlayers();\n+        var hasSelection = !selPlayers.isEmpty();\n+        var isSinglePlayer = selPlayers.size() == 1;\n+        var allConfigurable = hasSelection && selPlayers.stream().allMatch(lobbyActions::isSelfOrLocalBot);\n+        var isSingleLocalBot = isSinglePlayer && (getSelectedClient() instanceof BotClient);\n+        comboTeam.setEnabled(allConfigurable);\n+        butLoadList.setEnabled(allConfigurable && isSinglePlayer);\n+        butCamo.setEnabled(allConfigurable && isSinglePlayer);\n+        butConfigPlayer.setEnabled(allConfigurable && isSinglePlayer);\n+        refreshCamoButton();\n+        // Disable the Remove Bot button for the \"player\" of a \"Connect As Bot\" client\n+        butRemoveBot.setEnabled(isSingleLocalBot);\n+        butSaveList.setEnabled(false);\n+        if (isSinglePlayer) {\n+            var selPlayer = theElement(selPlayers);\n+            var hasUnits = !game().getPlayerEntities(selPlayer, false).isEmpty();\n+            butSaveList.setEnabled(hasUnits && unitsVisible(selPlayer));\n+            setTeamSelectedItem(selPlayer.getTeam());\n+        }\n+    }\n+    \n+    /** Sets (without firing events) the team combobox. */\n+    private void setTeamSelectedItem(int team) {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(team);\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+    \n+    /** \n+     * Returns false when any blind-drop option is active and player is not on the local team; \n+     * true otherwise. When true, individual units of the given player should not be shown/saved/etc. \n+     */ \n+    private boolean unitsVisible(IPlayer player) {\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        boolean isBlindDrop = opts.booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                || opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+        return !player.isEnemyOf(localPlayer()) || !isBlindDrop;\n+    }\n+\n+    public class PlayerTableMouseAdapter extends MouseInputAdapter {\n+\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                IPlayer player = playerModel.getPlayerAt(row);\n+                if (player != null) {\n+                    boolean isLocalPlayer = player.equals(localPlayer());\n+                    boolean isLocalBot = clientgui.getBots().get(player.getName()) != null;\n+                    if ((isLocalPlayer || isLocalBot)) {\n+                        configPlayer();\n+                    }\n+                }\n+            }\n+        }\n+        \n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected player,\n+                // clear the selection and select that entity instead\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                if (!tablePlayers.isRowSelected(row)) {\n+                    tablePlayers.changeSelection(row, row, false, false);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            ScalingPopup popup = PlayerTablePopup.playerTablePopup(clientgui, \n+                    playerTableActionListener, getselectedPlayers());\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    private ActionListener playerTableActionListener = new ActionListener() {\n+        \n+        @Override\n+        public void actionPerformed(ActionEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+        \n+            StringTokenizer st = new StringTokenizer(e.getActionCommand(), \"|\");\n+            String command = st.nextToken();\n+            switch (command) {\n+            case \"CONFIG\":\n+                configPlayer();\n+                break;\n+\n+            case \"TEAM\":\n+                int newTeam = Integer.parseInt(st.nextToken());\n+                lobbyActions.changeTeam(getselectedPlayers(), newTeam);\n+                break;\n+\n+            case \"BOTREMOVE\":\n+                removeBot();\n+                break;\n+\n+            case \"BOTSETTINGS\":\n+                doBotSettings();\n+                break;\n+                \n+            case \"DEPLOY\":\n+                int startPos = Integer.parseInt(st.nextToken());\n+                if (game().getOptions().booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                        && (startPos >= 1) && (startPos <= 9)) {\n+                    startPos += 10;\n+                }\n+                for (IPlayer player: getselectedPlayers()) {\n+                    if (lobbyActions.isSelfOrLocalBot(player)) {\n+                        if (client().isLocalBot(player)) {\n+                            // must use the bot's own player object:\n+                            client().getBotClient(player).getLocalPlayer().setStartingPos(startPos);\n+                            client().getBotClient(player).sendPlayerInfo();\n+                        } else {\n+                            player.setStartingPos(startPos);\n+                            client().sendPlayerInfo();\n+                        }\n+                    }\n+                }\n+                break;\n+                \n+            }\n+        }\n+    };\n+    \n+    \n+    private ArrayList<IPlayer> getselectedPlayers() {\n+        var result = new ArrayList<IPlayer>(); \n+        for (int row: tablePlayers.getSelectedRows()) {\n+            IPlayer player = playerModel.getPlayerAt(row);\n+            if (player != null) {\n+                result.add(player);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    KeyListener mekTableKeyListener = new KeyAdapter() {\n+\n+        @Override\n+        public void keyPressed(KeyEvent e) {\n+            if (mekTable.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            List<Entity> entities = getSelectedEntities();\n+            int code = e.getKeyCode();\n+            if ((code == KeyEvent.VK_DELETE) || (code == KeyEvent.VK_BACK_SPACE)) {\n+                e.consume();\n+                lobbyActions.delete(new ArrayList<>(), entities, true);\n+            } else if (code == KeyEvent.VK_SPACE) {\n+                e.consume();\n+                mechReadoutAction(entities);\n+            } else if (code == KeyEvent.VK_ENTER) {\n+                e.consume();\n+                if (entities.size() == 1) {\n+                    lobbyActions.customizeMech(entities.get(0));\n+                } else if (canConfigureMultipleDeployment(entities)) {\n+                    lobbyActions.customizeMechs(entities);\n+                }\n+            } else if (code == KeyEvent.VK_C && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                StringSelection stringSelection = new StringSelection(clipboardString(entities));\n+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+                clipboard.setContents(stringSelection, null);\n+                \n+            } else if (code == KeyEvent.VK_V && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                importClipboard(); \n+                \n+            } else if (code == KeyEvent.VK_P) {\n+                e.consume();\n+                System.out.println(game().getEntitiesVector().size() + \" Units\");\n+                game().getEntitiesVector().stream().forEach(System.out::println);\n+                \n+            } else if (code == KeyEvent.VK_F) {\n+                e.consume();\n+                System.out.println(\"Forces: ---\");\n+                System.out.println(game().getForces());\n+            }\n+        }\n+    };\n+    \n+    /** Reads the clipboard and adds units, if it can parse them. */\n+    public void importClipboard() {\n+        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        Transferable contents = clipboard.getContents(null);\n+        boolean hasTransferableText = (contents != null) &&\n+                contents.isDataFlavorSupported(DataFlavor.stringFlavor);\n+        List<Entity> newEntities = new ArrayList<>();\n+        if (hasTransferableText) {\n+            try {\n+                String result = (String)contents.getTransferData(DataFlavor.stringFlavor);\n+                StringTokenizer lines = new StringTokenizer(result, \"\\n\");\n+                while (lines.hasMoreTokens()) {\n+                    String line = lines.nextToken();\n+                    StringTokenizer tabs = new StringTokenizer(line, \"\\t\");\n+                    String unit = \"\";\n+                    if (tabs.hasMoreTokens()) {\n+                        unit = tabs.nextToken();\n+                    }\n+                    if (tabs.hasMoreTokens()) {\n+                        unit += \" \" + tabs.nextToken();\n+                    }\n+                    MechSummary ms = MechSummaryCache.getInstance().getMech(unit);\n+                    if (ms == null) {\n+                        continue;\n+                    }\n+                    Entity newEntity = new MechFileParser(ms.getSourceFile(),\n+                            ms.getEntryName()).getEntity();\n+                    if (newEntity != null) {\n+                        newEntity.setOwner(localPlayer());\n+                        newEntities.add(newEntity);\n+                    }\n+                }\n+            }\n+            catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            if (!newEntities.isEmpty()) {\n+                client().sendAddEntity(newEntities);\n+            }\n+        }\n+    }\n+    \n+    /** Returns a String representing the entities to export to the clipboard. */\n+    private String clipboardString(Collection<Entity> entities) {\n+        StringBuilder result = new StringBuilder();\n+        for (Entity entity: entities) {\n+            // Chassis\n+            result.append(entity.getChassis()).append(\"\\t\");\n+            // Model\n+            result.append(entity.getModel()).append(\"\\t\");\n+            // Weight; format for locale to avoid wrong \",.\" etc.\n+            Locale cl = Locale.getDefault();\n+            NumberFormat numberFormatter = NumberFormat.getNumberInstance(cl);\n+            result.append(numberFormatter.format(entity.getWeight())).append(\"\\t\");\n+            // Pilot name\n+            result.append(entity.getCrew().getName()).append(\"\\t\");\n+            // Crew Skill with text\n+            result.append(CrewSkillSummaryUtil.getSkillNames(entity)).append(\": \")\n+                    .append(entity.getCrew().getSkillsAsString(false)).append(\"\\t\");\n+            // BV without C3 but with pilot (as that gets exported too)\n+            result.append(entity.calculateBattleValue(true, false)).append(\"\\t\");\n+            result.append(\"\\n\");\n+        }\n+        return result.toString();\n+    }\n+    \n+    /** Returns a list of entities selected in the ForceTree. May be empty, but not null. */\n+    private List<Entity> getTreeSelectedEntities() {\n+        TreePath[] selection = mekForceTree.getSelectionPaths();\n+        List<Entity> entities = new ArrayList<>();\n+        if (selection != null) {\n+            for (TreePath path: selection) {\n+                if (path != null) {\n+                    Object selected = path.getLastPathComponent();\n+                    if (selected instanceof Entity) {\n+                        entities.add((Entity) selected);\n+                    }  \n+                }\n+            }\n+        }\n+        return entities;\n+    }\n+    \n+    /** Returns a list of forces selected in the ForceTree. May be empty, but not null. */\n+    private List<Force> getTreeSelectedForces() {\n+        TreePath[] selection = mekForceTree.getSelectionPaths();\n+        List<Force> selForces = new ArrayList<>();\n+        if (selection != null) {\n+            for (TreePath path: selection) {\n+                if (path != null) {\n+                    Object selected = path.getLastPathComponent();\n+                    if (selected instanceof Force) {\n+                        selForces.add((Force) selected);\n+                    } \n+                }\n+            }\n+        }\n+        return selForces;\n+    }\n+    \n+    /** The key listener for the Force Tree. */\n+    KeyListener mekTreeKeyListener = new KeyAdapter() {\n+\n+        @Override\n+        public void keyPressed(KeyEvent e) {\n+            List<Entity> selEntities = getTreeSelectedEntities();\n+            List<Force> selForces = getTreeSelectedForces();\n+            boolean onlyOneEntity = (selEntities.size() == 1) && selForces.isEmpty();\n+            int code = e.getKeyCode();\n+            \n+            if (code == KeyEvent.VK_SPACE) {\n+                e.consume();\n+                mechReadoutAction(selEntities);\n+                \n+            } else if (code == KeyEvent.VK_ENTER && onlyOneEntity) {\n+                e.consume();\n+                lobbyActions.customizeMech(selEntities.get(0));\n+                \n+            } else if (code == KeyEvent.VK_UP && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMwMjkwMg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r615302902", "bodyText": "No. I could add this to the popup with the key shortcut so people will see it.", "author": "SJuliez", "createdAt": "2021-04-17T20:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4OTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4OTE2OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612089169", "bodyText": "Magic strings", "author": "NickAragua", "createdAt": "2021-04-13T02:46:00Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);\n+        \n+        // Planetary Conditions and Random Map Settings buttons\n+        FixedYPanel panSettings = new FixedYPanel();\n+        panSettings.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panSettings.add(butConditions);\n+        panSettings.add(butRandomMap);\n+//        panMap.add(panSettings);\n+\n+        FixedYPanel panTopRows = new FixedYPanel();\n+        panTopRows.setLayout(new BoxLayout(panTopRows, BoxLayout.PAGE_AXIS));\n+        panTopRows.add(panMapType);\n+        panTopRows.add(panSettings);\n+        \n+        JPanel panHelp = new JPanel(new GridLayout(1,1));\n+        panHelp.add(butHelp);\n+        \n+        FixedYPanel panTopRowsHelp = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 30, 5));\n+        panTopRowsHelp.add(panTopRows);\n+        panTopRowsHelp.add(panHelp);\n+        panMap.add(panTopRowsHelp);\n+        \n+        // Main part: Map Assembly\n+        panMap.add(panGroundMap);\n+\n+    }\n+\n+    /**\n+     * Sets up the ground map selection panel\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void setupMapAssembly() {\n+\n+        panGroundMap = new JPanel(new GridLayout(1, 1));\n+        panGroundMap.setBorder(new EmptyBorder(20, 10, 10, 10));\n+\n+        panMapButtons.setLayout(new BoxLayout(panMapButtons, BoxLayout.PAGE_AXIS));\n+        // Resize the preview buttons when the panel is resized\n+        panMapButtons.addComponentListener(new ComponentAdapter() {\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateMapButtons();\n+            }\n+        });\n+        \n+        panMapWidth.add(lblMapWidth);\n+        panMapWidth.add(butMapShrinkW);\n+        panMapWidth.add(fldMapWidth);\n+        panMapWidth.add(butMapGrowW);\n+        \n+        panMapHeight.add(lblMapHeight);\n+        panMapHeight.add(butMapShrinkH);\n+        panMapHeight.add(fldMapHeight);\n+        panMapHeight.add(butMapGrowH);\n+        \n+        panSpaceBoardWidth.add(lblSpaceBoardWidth);\n+        panSpaceBoardWidth.add(fldSpaceBoardWidth);\n+        panSpaceBoardWidth.setVisible(false);\n+        \n+        panSpaceBoardHeight.add(lblSpaceBoardHeight);\n+        panSpaceBoardHeight.add(fldSpaceBoardHeight);\n+        panSpaceBoardHeight.setVisible(false);\n+        \n+        FixedYPanel bottomPanel = new FixedYPanel();\n+        bottomPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n+        bottomPanel.add(butBoardPreview);\n+        bottomPanel.add(butSaveMapSetup);\n+        bottomPanel.add(butLoadMapSetup);\n+\n+        butBoardPreview.setToolTipText(Messages.getString(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+\n+        // The left side panel including the game map preview\n+        JPanel panMapPreview = new JPanel();\n+        panMapPreview.setLayout(new BoxLayout(panMapPreview, BoxLayout.PAGE_AXIS));\n+        \n+        panMapPreview.add(panMapWidth);\n+        panMapPreview.add(panMapHeight);\n+        panMapPreview.add(panSpaceBoardWidth);\n+        panMapPreview.add(panSpaceBoardHeight);\n+        panMapPreview.add(panMapButtons);\n+        panMapPreview.add(bottomPanel);\n+        \n+        // The right side panel including the list of available boards\n+        comMapSizes = new JComboBox<Comparable>();\n+        refreshMapSizes();\n+\n+        lisBoardsAvailable = new JList<String>(new DefaultListModel<String>());\n+        lisBoardsAvailable.setCellRenderer(new BoardNameRenderer());\n+        lisBoardsAvailable.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n+        lisBoardsAvailable.setVisibleRowCount(-1);\n+        lisBoardsAvailable.setDragEnabled(true);\n+        lisBoardsAvailable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        scrBoardsAvailable = new JScrollPane(lisBoardsAvailable);\n+        refreshBoardsAvailable();\n+        \n+        JPanel panAvail = new JPanel();\n+        panAvail.setLayout(new BoxLayout(panAvail, BoxLayout.PAGE_AXIS));\n+        panAvail.setBorder(new EmptyBorder(0, 20, 0, 0));\n+        panAvail.add(setupAvailTopPanel());\n+        panAvail.add(scrBoardsAvailable);\n+        \n+        // The splitpane holding the left and right side panels\n+        splGroundMap = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panMapPreview, panAvail);\n+        splGroundMap.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+            \n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+        });\n+        panGroundMap.add(splGroundMap);\n+\n+        // setup the board preview window.\n+        boardPreviewW = new ClientDialog(clientgui.frame, \n+                Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"), \n+                false);\n+        boardPreviewW.setLocationRelativeTo(clientgui.frame);\n+\n+        try {\n+            BoardView1 bv = new BoardView1(boardPreviewGame, null, null);\n+            bv.setDisplayInvalidHexInfo(false);\n+            bv.setUseLOSTool(false);\n+            boardPreviewW.add(bv.getComponent(true));\n+            boardPreviewW.setSize(clientgui.frame.getWidth()/2, clientgui.frame.getHeight()/2);\n+            // Most boards will be far too large on the standard zoom\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            boardPreviewW.center();\n+        } catch (IOException e) {\n+            JOptionPane.showMessageDialog(this,\n+                            Messages.getString(\"BoardEditor.CouldntInitialize\") + e,\n+                            Messages.getString(\"BoardEditor.FatalError\"), JOptionPane.ERROR_MESSAGE); \n+        }\n+        refreshMapButtons();\n+    }\n+    \n+    /** \n+     *  Sets up and returns the panel above the available boards list \n+     *  containing the search bar and the map size chooser.  \n+     */\n+    private JPanel setupAvailTopPanel() {\n+        FixedYPanel result = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 20, 2));\n+        result.setBorder(new EmptyBorder(5, 5, 5, 5));\n+        \n+        fldSearch.getDocument().addDocumentListener(new DocumentListener() {\n+            @Override\n+            public void changedUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void removeUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void insertUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+        });\n+        \n+        result.add(lblBoardSize);\n+        result.add(comMapSizes);\n+        result.add(new JLabel(\"    \"));\n+        result.add(lblSearch);\n+        result.add(fldSearch);\n+        result.add(butCancelSearch);\n+\n+        return result;\n+    }\n+    \n+    /** \n+     * Reacts to changes in the available boards search field, showing matching boards\n+     * for the search string when it has at least 3 characters\n+     * and reverting to all boards when the search string is empty.\n+     */\n+    private void updateSearch(String searchString) {\n+        if (searchString.isEmpty()) {\n+            refreshBoardsAvailable();\n+        } else if (searchString.length() > 2) {\n+            refreshBoardsAvailable(getSearchedItems(searchString));\n+        }\n+    }\n+    \n+    /** \n+     * Returns the available boards that match the given search string\n+     * (path or file name contains the search string.) \n+     */\n+    protected List<String> getSearchedItems(String searchString) {\n+        String lowerCaseSearchString = searchString.toLowerCase();\n+        return mapSettings.getBoardsAvailableVector().stream()\n+                .filter(b -> b.toLowerCase().contains(lowerCaseSearchString) && isBoardFile(b))\n+                .collect(Collectors.toList());\n+    }\n+    \n+    /** \n+     * Returns a suitable divider location for the splitpane that contains\n+     * the available boards list and the map preview. The divider location\n+     * gives between 30% and 50% of space to the map preview depending\n+     * on the width of the game map.\n+     */\n+    private double getDividerLocation() {\n+        double base = 0.3;\n+        int width = mapSettings.getBoardWidth() * mapSettings.getMapWidth();\n+        int height = mapSettings.getBoardHeight() * mapSettings.getMapHeight();\n+        int wAspect = Math.max(1, width / height + 1);\n+        return Math.min(base + wAspect * 0.05, 0.5);\n+    }\n+\n+    /** Updates the ground map type chooser (ground/atmosphere map). */\n+    private void refreshMapChoice() {\n+        // refresh UI possibly from a server update\n+        JToggleButton button = butGroundMap;\n+        if (mapSettings.getMedium() == MapSettings.MEDIUM_ATMOSPHERE) {\n+            button = butLowAtmoMap;\n+        } else if (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {\n+            button = butSpaceMap;\n+        }\n+        \n+        if (!button.isSelected()) {\n+            button.removeActionListener(lobbyListener);\n+            button.setSelected(true);\n+            button.addActionListener(lobbyListener);\n+        }\n+    }\n+    \n+    /** Updates the list of available map sizes. */\n+    private void refreshMapSizes() {\n+        int oldSelection = comMapSizes.getSelectedIndex();\n+        mapSizes = clientgui.getClient().getAvailableMapSizes();\n+        comMapSizes.removeActionListener(lobbyListener);\n+        comMapSizes.removeAllItems();\n+        for (BoardDimensions size : mapSizes) {\n+            comMapSizes.addItem(size);\n+        }\n+        comMapSizes.addItem(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        comMapSizes.setSelectedIndex(oldSelection != -1 ? oldSelection : 0);\n+        comMapSizes.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the map assembly UI from the current map settings. Does NOT trigger further\n+     * changes or result in packets to the server. \n+     */\n+    private void refreshMapUI() {\n+        boolean inSpace = mapSettings.getMedium() == MapSettings.MEDIUM_SPACE;\n+        boolean onGround = mapSettings.getMedium() == MapSettings.MEDIUM_GROUND;\n+        boolean customSize = comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        lisBoardsAvailable.setEnabled(!inSpace);\n+        mapIcons.clear();\n+        butConditions.setEnabled(!inSpace);\n+        fldSearch.setEnabled(!inSpace);\n+        butRandomMap.setEnabled(!inSpace);\n+        panMapHeight.setVisible(!inSpace);\n+        panMapWidth.setVisible(!inSpace);\n+        panSpaceBoardWidth.setVisible(inSpace || customSize);\n+        panSpaceBoardHeight.setVisible(inSpace || customSize);\n+        comMapSizes.setEnabled(!inSpace);\n+        lblSearch.setEnabled(!inSpace);\n+        lblBoardSize.setEnabled(!inSpace);\n+        butSaveMapSetup.setEnabled(!inSpace);\n+        butLoadMapSetup.setEnabled(!inSpace);\n+        butMapShrinkW.setEnabled(mapSettings.getMapWidth() > 1);\n+        butMapShrinkH.setEnabled(mapSettings.getMapHeight() > 1);\n+        \n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        if (onGround) {\n+            butGroundMap.setSelected(true);\n+        } else if (inSpace) {\n+            butSpaceMap.setSelected(true);\n+        } else {\n+            butLowAtmoMap.setSelected(true);\n+        }\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        fldMapWidth.setText(Integer.toString(mapSettings.getMapWidth()));\n+        fldMapHeight.setText(Integer.toString(mapSettings.getMapHeight()));\n+        fldSpaceBoardWidth.setText(Integer.toString(mapSettings.getBoardWidth()));\n+        fldSpaceBoardHeight.setText(Integer.toString(mapSettings.getBoardHeight()));\n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+    }\n+\n+    /** \n+     * Refreshes the list of available boards with all available boards plus\n+     * GENERATED. Useful for first setup, when the server transmits new\n+     * map settings and when the text search field is empty.\n+     */\n+    private void refreshBoardsAvailable() {\n+        if (!lisBoardsAvailable.isEnabled()) {\n+            return;\n+        }\n+        lisBoardsAvailable.setFixedCellHeight(-1);\n+        lisBoardsAvailable.setFixedCellWidth(-1);\n+        List<String> availBoards = new ArrayList<>(); \n+        availBoards.add(MapSettings.BOARD_GENERATED);\n+        availBoards.addAll(mapSettings.getBoardsAvailableVector());\n+        refreshBoardsAvailable(availBoards);\n+    }\n+    \n+    /** \n+     * Refreshes the list of available maps with the given list of boards. \n+     */\n+    private void refreshBoardsAvailable(List<String> boardList) {\n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        // Replace the data model (adding the elements one by one to the existing model\n+        // in Java 8 style is sluggish because of event firing)\n+        DefaultListModel<String> newModel = new DefaultListModel<>();\n+        for (String s: boardList) {\n+            newModel.addElement(s);\n+        }\n+        lisBoardsAvailable.setModel(newModel);\n+        lisBoardsAvailable.clearSelection();\n+        lisBoardsAvailable.addListSelectionListener(this);\n+    }\n+    \n+    public boolean isMultipleBoards() {\n+        return mapSettings.getMapHeight() * mapSettings.getMapWidth() > 1;\n+    }\n+    \n+    MapSettings oldMapSettings = MapSettings.getInstance();\n+\n+    /**\n+     * Fills the Map Buttons scroll pane twith the appropriate amount of buttons\n+     * in the appropriate layout\n+     */\n+    private void refreshMapButtons() {\n+        panMapButtons.removeAll();\n+        panMapButtons.setVisible(false);\n+        panMapButtons.add(Box.createVerticalGlue());\n+        Dimension buttonSize = null;\n+\n+        // If buttons are unused, remove their image so that they update when they're used once more\n+        if (mapSettings.getMapHeight() * mapSettings.getMapWidth() < mapButtons.size()) {\n+            for (MapPreviewButton button: mapButtons.subList(mapSettings.getMapHeight() * mapSettings.getMapWidth(), mapButtons.size())) {\n+                button.reset();\n+            }\n+        }\n+\n+        // Add new map preview buttons if the map has grown\n+        while (mapSettings.getMapHeight() * mapSettings.getMapWidth() > mapButtons.size()) {\n+            mapButtons.add(new MapPreviewButton(this));\n+        }\n+\n+        // Re-add the buttons to the panel and update them as necessary\n+        for (int i = 0; i < mapSettings.getMapHeight(); i++) {\n+            JPanel row = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n+            panMapButtons.add(row);\n+            for (int j = 0; j < mapSettings.getMapWidth(); j++) {\n+                int index = i * mapSettings.getMapWidth() + j;\n+                MapPreviewButton button = mapButtons.get(index);\n+                button.setIndex(index);\n+                row.add(button);\n+\n+                // Update the board base image if it's generated and the settings have changed\n+                // or the board name has changed\n+                String boardName = mapSettings.getBoardsSelectedVector().get(index);\n+                if (!button.getBoard().equals(boardName) \n+                        || oldMapSettings.getMedium() != mapSettings.getMedium()\n+                        || (!mapSettings.equalMapGenParameters(oldMapSettings) \n+                                && mapSettings.getMapWidth() == oldMapSettings.getMapWidth()\n+                                && mapSettings.getMapHeight() == oldMapSettings.getMapHeight())) {\n+                    IBoard buttonBoard; \n+                    Image image;\n+                    // Generated and space boards use a generated example\n+                    if (boardName.startsWith(MapSettings.BOARD_GENERATED) \n+                            || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                        buttonBoard = BoardUtilities.generateRandom(mapSettings);\n+                        image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                    } else { \n+                        String boardForImage = boardName;\n+                        // For a surprise board, just use the first board as example\n+                        if (boardName.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                            boardForImage = extractSurpriseMaps(boardName).get(0);\n+                        }\n+                        File boardFile = new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile();\n+                        if (boardFile.exists()) {\n+                            buttonBoard = new Board(16, 17);\n+                            buttonBoard.load(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile());\n+                            StringBuffer errs = new StringBuffer();\n+                            try (InputStream is = new FileInputStream(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile())) {\n+                                buttonBoard.load(is, errs, true);\n+                            } catch (IOException ex) {\n+                                buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            }\n+                            image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                        } else {\n+                            buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            BufferedImage emptyBoardMap = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                            markServerSideBoard(emptyBoardMap);\n+                            image = emptyBoardMap;\n+                        }\n+                    }\n+                    button.setImage(image, boardName);\n+                    buttonSize = optMapButtonSize(image);\n+                }\n+                button.scheduleRescale();\n+            }\n+        }\n+        oldMapSettings = MapSettings.getInstance(mapSettings);\n+        \n+        if (buttonSize != null) {\n+            for (MapPreviewButton button: mapButtons) {\n+                button.setPreviewSize(buttonSize);\n+            }\n+        }\n+        splGroundMap.setDividerLocation(getDividerLocation());\n+\n+        panMapButtons.add(Box.createVerticalGlue());\n+        panMapButtons.setVisible(true);\n+\n+        lblBoardsAvailable.setText(mapSettings.getBoardWidth() + \"x\" + mapSettings.getBoardHeight() + \" \"\n+                + Messages.getString(\"BoardSelectionDialog.mapsAvailable\"));\n+        comMapSizes.removeActionListener(lobbyListener);\n+        int items = comMapSizes.getItemCount();\n+\n+        boolean mapSizeSelected = false;\n+        for (int i = 0; i < (items - 1); i++) {\n+            BoardDimensions size = (BoardDimensions) comMapSizes.getItemAt(i);\n+\n+            if ((size.width() == mapSettings.getBoardWidth()) && (size.height() == mapSettings.getBoardHeight())) {\n+                comMapSizes.setSelectedIndex(i);\n+                mapSizeSelected = true;\n+            }\n+        }\n+        // If we didn't select a size, select the last item: 'Custom Size'\n+        if (!mapSizeSelected) {\n+            comMapSizes.setSelectedIndex(items - 1);\n+        }\n+        comMapSizes.addActionListener(lobbyListener);\n+\n+    }\n+    \n+    private void markServerSideBoard(BufferedImage image) {\n+        Graphics g = image.getGraphics();\n+        GUIPreferences.AntiAliasifSet(g);\n+        int w = image.getWidth();\n+        int h = image.getHeight();\n+        String text = \"Server-side board\";\n+        int fontSize = Math.min(w / 10, UIUtil.scaleForGUI(16));\n+        g.setFont(new Font(\"Dialog\", Font.ITALIC, fontSize));\n+        FontMetrics fm = g.getFontMetrics(g.getFont());\n+        int cx = (w - fm.stringWidth(text)) / 2;\n+        int cy = h / 10 + fm.getAscent();\n+        g.setColor(GUIPreferences.getInstance().getWarningColor());\n+        g.drawString(text, cx, cy);\n+        g.dispose();\n+    }\n+\n+    public void previewGameBoard() {\n+        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);\n+        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];\n+        List<Boolean> rotateBoard = new ArrayList<>();\n+        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings.getMapHeight()); i++) {\n+            sheetBoards[i] = new Board();\n+            String name = mapSettings.getBoardsSelectedVector().get(i);\n+            if (name.startsWith(MapSettings.BOARD_GENERATED) \n+                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);\n+            } else {\n+                if (name.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                    List<String> boardList = extractSurpriseMaps(name);\n+                    int rnd = (int)(Math.random() * boardList.size());\n+                    name = boardList.get(rnd);\n+                }\n+                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name + \".board\").getFile());\n+            }\n+        }\n+\n+        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(), mapSettings.getMapWidth(),\n+                mapSettings.getMapHeight(), sheetBoards, rotateBoard, mapSettings.getMedium());\n+        \n+        boardPreviewGame.setBoard(newBoard);\n+        boardPreviewW.setVisible(true);\n+    }\n+\n+    /**\n+     * Refreshes the game settings with new info from the client\n+     */\n+    private void refreshGameSettings() {\n+        refreshTeams();\n+        refreshDoneButton();\n+    }\n+    \n+    /**\n+     * Refreshes the Mek Table contents \n+     */\n+    public void refreshEntities() {\n+        refreshTree();\n+        refreshMekTable();\n+    }\n+    \n+    private void refreshMekTable() {\n+        List<Integer> enIds = getSelectedEntities().stream().map(e -> e.getId()).collect(toList());\n+        mekModel.clearData();\n+        ArrayList<Entity> allEntities = new ArrayList<Entity>(clientgui.getClient().getEntitiesVector());\n+        Collections.sort(allEntities, activeSorter);\n+\n+        boolean localUnits = false;\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        for (Entity entity : allEntities) {\n+            // Remember if the local player has units.\n+            if (!localUnits && entity.getOwner().equals(localPlayer())) {\n+                localUnits = true;\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_PILOT_ADVANTAGES)) { \n+                entity.getCrew().clearOptions(PilotOptions.LVL3_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.EDGE)) { \n+                entity.getCrew().clearOptions(PilotOptions.EDGE_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_MANEI_DOMINI)) { \n+                entity.getCrew().clearOptions(PilotOptions.MD_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS)) { \n+                entity.clearPartialRepairs();\n+            }\n+            \n+            // Remove some deployment options when a unit is carried\n+            if (entity.getTransportId() != Entity.NONE) { \n+                entity.setHidden(false);\n+                entity.setProne(false);\n+                entity.setHullDown(false);\n+            }\n+            \n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) { \n+                entity.setHidden(false);\n+            }\n+            \n+            // Handle the \"Blind Drop\" option. In blind drop, units must be added\n+            // but they will be obscured in the table. In real blind drop, units\n+            // don't even get added to the table. Teams see their units in any case.\n+            boolean localUnit = entity.getOwner().equals(localPlayer());\n+            boolean teamUnit = !entity.getOwner().isEnemyOf(localPlayer());\n+            boolean realBlindDrop = opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+            if (localUnit || teamUnit || !realBlindDrop) {\n+                mekModel.addUnit(entity);\n+            }\n+        }\n+        // Restore selection\n+        if (!enIds.isEmpty()) {\n+            for (int i = 0; i < mekTable.getRowCount(); i++) {\n+                if (enIds.contains(mekModel.getEntityAt(i).getId())) {\n+                    mekTable.addRowSelectionInterval(i, i);\n+                }\n+            }\n+        }\n+\n+        // Enable the \"Save Unit List...\" button if the local player has units.\n+        clientgui.getMenuBar().setUnitList(localUnits);\n+    }\n+    \n+    /** Adjusts the mektable to compact/normal mode. */\n+    private void toggleCompact() {\n+        setTableRowHeights();\n+        mekModel.refreshCells();\n+        mekForceTreeModel.nodeChanged((TreeNode)mekForceTreeModel.getRoot());\n+        \n+    }\n+\n+    /** Refreshes the player info table. */\n+    private void refreshPlayerTable() {\n+        // Remember the selected players\n+        var selPlayerIds = getselectedPlayers().stream().map(IPlayer::getId).collect(toSet());\n+\n+        // Empty and refill the player table\n+        playerModel.replaceData(game().getPlayersVector());\n+\n+        // re-select the previously selected players, if possible\n+        for (int row = 0; row < playerModel.getRowCount(); row++) {\n+            if (selPlayerIds.contains(playerModel.getPlayerAt(row).getId())) {\n+                tablePlayers.addRowSelectionInterval(row, row);\n+            }\n+        }\n+    }\n+\n+    /** Updates the camo button to displays the camo of the currently selected player. */ \n+    private void refreshCamoButton() {\n+        if ((tablePlayers == null) || (playerModel == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (player != null) {\n+            butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        }\n+    }\n+\n+    /** Sets up the team choice box. */\n+    private void setupTeamCombo() {\n+        for (int i = 0; i < IPlayer.MAX_TEAMS; i++) {\n+            comboTeam.addItem(IPlayer.teamNames[i]);\n+        }\n+    }\n+\n+    /** Updates the team choice combobox to show the selected player's team. */\n+    private void refreshTeams() {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(localPlayer().getTeam());\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the Done button. The label will say the opposite of the\n+     * player's \"done\" status, indicating that clicking it will reverse the\n+     * condition.\n+     */\n+    private void refreshDoneButton(boolean done) {\n+        butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n+    }\n+\n+    /** Refreshes the state of the Done button with the state of the local player. */\n+    private void refreshDoneButton() {\n+        refreshDoneButton(localPlayer().isDone());\n+    }\n+\n+    /**\n+     * Embarks the given carried Entity onto the carrier given as carrierId.\n+     */\n+    void loadOnto(Entity carried, int carrierId, int bayNumber) {\n+        Entity carrier = game().getEntity(carrierId);\n+        if (carrier == null || !isLoadable(carried, carrier)) {\n+            return;\n+        }\n+\n+        // We need to make sure our current bomb choices fit onto the new\n+        // fighter\n+        if (carrier instanceof FighterSquadron) {\n+            FighterSquadron fSquad = (FighterSquadron) carrier;\n+            // We can't use Aero.getBombPoints() because the bombs haven't been\n+            // loaded yet, only selected, so we have to count the choices\n+            int[] bombChoice = fSquad.getBombChoices();\n+            int numLoadedBombs = 0;\n+            for (int i = 0; i < bombChoice.length; i++) {\n+                numLoadedBombs += bombChoice[i];\n+            }\n+            // We can't load all of the squadrons bombs\n+            if (numLoadedBombs > ((IBomber)carried).getMaxBombPoints()) {\n+                JOptionPane.showMessageDialog(clientgui.frame, Messages.getString(\"FighterSquadron.bomberror\"),\n+                        Messages.getString(\"FighterSquadron.error\"), JOptionPane.ERROR_MESSAGE);\n+                return;\n+            }\n+        }\n+        \n+        getLocalClient(carried).sendLoadEntity(carried.getId(), carrierId, bayNumber);\n+        // TODO: it would probably be a good idea \n+        // to disable some settings for loaded units in customMechDialog\n+    }\n+\n+    /** \n+     * Have the given entity disembark if it is carried by another unit.\n+     * Entities that are modified and need an update to be sent to the server\n+     * are added to the given updateCandidates. \n+     */\n+    void disembark(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = game().getEntity(entity.getTransportId());\n+        if (carrier != null) {\n+            carrier.unload(entity);\n+            entity.setTransportId(Entity.NONE);\n+            updateCandidates.add(entity);\n+            updateCandidates.add(carrier);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity disembark if it is carried by a unit of another player.\n+     * Entities that were modified and need an update to be sent to the server\n+     * are added to the given updateCandidate set. \n+     */\n+    void disembarkDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = clientgui.getClient().getGame().getEntity(entity.getTransportId());\n+        if (carrier != null && (ownerOf(entity) != ownerOf(carrier))) {\n+            disembark(entity, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entities offload all the units they are carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadAll(Collection<Entity> entities, Collection<Entity> updateCandidates) {\n+        for (Entity carrier: editableEntities(entities)) {\n+            offloadFrom(carrier, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all the units it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFrom(Entity entity, Collection<Entity> updateCandidates) {\n+        if (isEditable(entity)) {\n+            for (Entity carriedUnit: entity.getLoadedUnits()) {\n+                disembark(carriedUnit, updateCandidates);\n+            } \n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all units of different players it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFromDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        for (Entity carriedUnit: entity.getLoadedUnits()) {\n+            if (ownerOf(carriedUnit) != ownerOf(entity)) {\n+                disembark(carriedUnit, updateCandidates);\n+            }\n+        } \n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. \n+     */\n+    void sendUpdate(Collection<Entity> updateCandidates) {\n+        for (Entity e: editableEntities(updateCandidates)) {\n+            getLocalClient(e).sendUpdateEntity(e);\n+        }\n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. Will separate the units into update\n+     * packets for the local player and any local bots so that the \n+     * server accepts all changes (as the server does not know of\n+     * local bots and rejects updates that are not for the sending client\n+     * or its teammates. \n+     */\n+    void sendUpdates(Collection<Entity> entities) {\n+        List<IPlayer> owners = entities.stream().map(e -> e.getOwner()).distinct().collect(toList());\n+        for (IPlayer owner: owners) {\n+            client().sendUpdateEntity(new ArrayList<Entity>(\n+                    entities.stream().filter(e -> e.getOwner().equals(owner)).collect(toList())));\n+        }\n+    }\n+    \n+    /** \n+     * Disembarks all given entities from any transports they are in. \n+     */\n+    void disembarkAll(Collection<Entity> entities) {\n+        Set<Entity> updateCandidates = new HashSet<>();\n+        entities.stream().filter(e -> isEditable(e)).forEach(e -> disembark(e, updateCandidates));\n+        sendUpdate(updateCandidates);\n+    }\n+\n+    /** \n+     * Returns true when the given entity may be configured by the local player,\n+     * i.e. if it is his own unit or one of his bot's units.\n+     * <P>Note that this is more restrictive than the Server is. The Server\n+     * accepts entity changes also for teammates so that entity updates that \n+     * signal transporting a teammate's unit don't get rejected. I feel that\n+     * configuration other than transporting units should be limited to one's\n+     * own units (and bots) though.\n+     */\n+    boolean isEditable(Entity entity) {\n+        return clientgui.getBots().containsKey(entity.getOwner().getName())\n+                || (entity.getOwnerId() == localPlayer().getId());\n+    }\n+    \n+    /** \n+     * Returns true when the given entity may NOT be configured by the local player,\n+     * i.e. if it is not own unit or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isNotEditable(Entity entity) {\n+        return !isEditable(entity);\n+    }\n+    \n+    /** \n+     * Returns true when all given entities may be configured by the local player,\n+     * i.e. if they are his own units or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isEditable(Collection<Entity> entities) {\n+        return !entities.stream().anyMatch(this::isNotEditable);\n+    }\n+    \n+    /** \n+     * Returns the Client associated with a given entity that may be configured\n+     * by the local player (his own unit or one of his bot's units).\n+     * For a unit that cannot be configured (owned by a remote player) the client\n+     * of the local player is returned.\n+     */\n+    Client getLocalClient(Entity entity) {\n+        if (clientgui.getBots().containsKey(entity.getOwner().getName())) {\n+            return clientgui.getBots().get(entity.getOwner().getName());\n+        } else {\n+            return clientgui.getClient();\n+        }\n+    }\n+\n+    public void configPlayer() {\n+        Client c = getSelectedClient();\n+        if (null == c) {\n+            return;\n+        }\n+        \n+        PlayerSettingsDialog psd = new PlayerSettingsDialog(clientgui, c);\n+        boolean okay = psd.showDialog();\n+        \n+        if (okay) {\n+            IPlayer player = c.getLocalPlayer();\n+            player.setConstantInitBonus(psd.getInit());\n+            player.setNbrMFConventional(psd.getCnvMines());\n+            player.setNbrMFVibra(psd.getVibMines());\n+            player.setNbrMFActive(psd.getActMines());\n+            player.setNbrMFInferno(psd.getInfMines());\n+            var rsg = c.getRandomSkillsGenerator();\n+            rsg.setMethod(psd.getMethod());\n+            rsg.setType(psd.getPilot());\n+            rsg.setLevel(psd.getXP());\n+            rsg.setClose(psd.getForceGP());\n+            \n+            // The deployment position\n+            int startPos = psd.getStartPos();\n+            final GameOptions gOpts = clientgui.getClient().getGame().getOptions();\n+            if (gOpts.booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                    && (startPos >= 1) && (startPos <= 9)) {\n+                startPos += 10;\n+            }\n+            c.getLocalPlayer().setStartingPos(startPos);\n+            c.sendPlayerInfo();\n+            \n+            // If the gameoption set_arty_player_homeedge is set, adjust the player's offboard \n+            // arty units to be behind the newly selected home edge.\n+            OffBoardDirection direction = OffBoardDirection.translateStartPosition(startPos);\n+            if (direction != OffBoardDirection.NONE && \n+                    gOpts.booleanOption(OptionsConstants.BASE_SET_ARTY_PLAYER_HOMEEDGE)) {\n+                for (Entity entity: c.getGame().getPlayerEntities(c.getLocalPlayer(), false)) {\n+                    if (entity.getOffBoardDirection() != OffBoardDirection.NONE) {\n+                        entity.setOffBoard(entity.getOffBoardDistance(), direction);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    \n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechReadoutAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechReadout(entity, index++);\n+        }\n+    } \n+\n+    /** \n+     * Shows the unit summary for the given unit. Moves the dialog a bit depending on index\n+     * so that multiple dialogs dont appear exactly on top of each other. \n+     */\n+    private void mechReadout(Entity entity, int index) {\n+        final ClientDialog dialog = new ClientDialog(clientgui.frame, Messages.getString(\"ChatLounge.quickView\"), false, true);\n+        final int height = 600;\n+        final int width = 500;\n+\n+        MechView mv = new MechView(entity, false);\n+        // The label must want a fixed width to enforce linebreaks on fluff text\n+        JLabel mechSummary = new JLabel(\"<HTML>\" + mv.getMechReadoutHead()\n+        + mv.getMechReadoutBasic() + mv.getMechReadoutLoadout()\n+        + mv.getMechReadoutFluff()) {\n+            private static final long serialVersionUID = 2989361635430008853L;\n+            @Override\n+            public Dimension getPreferredSize() {\n+                return new Dimension(width - 10, super.getPreferredSize().height);\n+            }\n+        };\n+        mechSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(mechSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.center();\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechBVAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechBVDisplay(entity, index++);\n+        }\n+    } \n+    \n+    /**\n+     * @param entity the entity to display the BV Calculation for\n+     */\n+    void mechBVDisplay(Entity entity, int index) {\n+        final JDialog dialog = new ClientDialog(clientgui.frame, \"BV Calculation Display\", false, true);\n+        final int height = 600;\n+        \n+        entity.calculateBattleValue();\n+        JLabel bvSummary = new JLabel(entity.getBVText());\n+        bvSummary.setFont(new Font(\"Dialog\",Font.PLAIN, scaleForGUI(14)));\n+        bvSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(bvSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(bvSummary.getPreferredSize().width + 40, scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /**\n+     * Pop up the dialog to load a mech\n+     */\n+    private void addUnit() {\n+        clientgui.getMechSelectorDialog().updateOptionValues();\n+        clientgui.getMechSelectorDialog().setVisible(true);\n+    }\n+    \n+    private void createArmy() {\n+        clientgui.getRandomArmyDialog().setVisible(true);\n+    }\n+\n+    public void loadRandomSkills() {\n+        clientgui.getRandomSkillDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    public void loadRandomNames() {\n+        clientgui.getRandomNameDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    void changeMapDnD(String board, JButton button) {\n+        if (board.contains(\"\\n\")) {\n+            board = MapSettings.BOARD_SURPRISE + board;\n+        }\n+        mapSettings.getBoardsSelectedVector().set(mapButtons.indexOf(button), board);\n+        clientgui.getClient().sendMapSettings(mapSettings);\n+        if (boardPreviewW.isVisible()) {\n+            previewGameBoard();\n+        }\n+    }\n+    \n+    \n+\n+    //\n+    // GameListener\n+    //\n+    @Override\n+    public void gamePlayerChange(GamePlayerChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshDoneButton();\n+        clientgui.getClient().getGame().setupTeams();\n+        refreshPlayerTable();\n+        refreshPlayerConfig();\n+        refreshCamoButton();\n+        refreshEntities();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gamePhaseChange(GamePhaseChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        \n+        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {\n+            refreshDoneButton();\n+            refreshGameSettings();\n+            refreshPlayerTable();\n+            refreshTeams();\n+            refreshCamoButton();\n+            refreshEntities();\n+            panTeamOverview.refreshData();\n+        }\n+    }\n+\n+    @Override\n+    public void gameEntityNew(GameEntityNewEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameSettingsChange(GameSettingsChangeEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshGameSettings();\n+        // The table sorting may no longer be allowed (e.g. when blind drop was activated)\n+        if (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())) {\n+            nextSorter(unitSorters);\n+            updateTableHeaders();\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        refreshMapSizes();\n+        updateMapSettings(clientgui.getClient().getMapSettings());\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameClientFeedbackRequest(GameCFREvent evt) {\n+        // Do nothing\n+    }\n+\n+    \n+    private ActionListener lobbyListener = new ActionListener() {\n+\n+        @Override\n+        public void actionPerformed(ActionEvent ev) {\n+\n+            // Are we ignoring events?\n+            if (isIgnoringEvents()) {\n+                return;\n+            }\n+            \n+            if (ev.getSource().equals(butAdd)) {\n+                addUnit();\n+                \n+            } else if (ev.getSource().equals(butArmy)) {\n+                createArmy();\n+                \n+            } else if (ev.getSource().equals(butSkills)) {\n+                loadRandomSkills();\n+                \n+            } else if (ev.getSource().equals(butNames)) {\n+                loadRandomNames();\n+                \n+            } else if (ev.getSource().equals(tablePlayers)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(comboTeam)) {\n+                lobbyActions.changeTeam(getselectedPlayers(), comboTeam.getSelectedIndex());\n+                \n+            } else if (ev.getSource().equals(butConfigPlayer)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(butBotSettings)) {\n+                doBotSettings();\n+                \n+            } else if (ev.getSource().equals(butOptions)) {\n+                // Make sure the game options dialog is editable.\n+                if (!clientgui.getGameOptionsDialog().isEditable()) {\n+                    clientgui.getGameOptionsDialog().setEditable(true);\n+                }\n+                // Display the game options dialog.\n+                clientgui.getGameOptionsDialog().update(clientgui.getClient().getGame().getOptions());\n+                clientgui.getGameOptionsDialog().setVisible(true);\n+                \n+            } else if (ev.getSource().equals(butCompact)) {\n+                toggleCompact();\n+                \n+            } else if (ev.getSource().equals(butLoadList)) {\n+                // Allow the player to replace their current\n+                // list of entities with a list from a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));  //$NON-NLS-2$\n+                    return;\n+                }\n+                clientgui.loadListFile(c.getLocalPlayer());\n+                \n+            } else if (ev.getSource().equals(butSaveList)) {\n+                // Allow the player to save their current\n+                // list of entities to a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));\n+                    return;\n+                }\n+                clientgui.saveListFile(c.getGame().getPlayerEntities(c.getLocalPlayer(), false),\n+                        c.getLocalPlayer().getName());\n+                \n+            } else if (ev.getSource().equals(butAddBot)) {\n+                BotConfigDialog bcd = new BotConfigDialog(clientgui.frame);\n+                bcd.setVisible(true);\n+                if (bcd.dialogAborted) {\n+                    return; // user didn't click 'ok', add no bot\n+                }\n+                if (clientgui.getBots().containsKey(bcd.getBotName())) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertExistsBot.title\"),\n+                            Messages.getString(\"ChatLounge.AlertExistsBot.message\"));  //$NON-NLS-2$\n+                } else {\n+                    BotClient c = bcd.getSelectedBot(clientgui.getClient().getHost(), clientgui.getClient().getPort());\n+                    c.setClientGUI(clientgui);\n+                    c.getGame().addGameListener(new BotGUI(c));\n+                    try {\n+                        c.connect();\n+                    } catch (Exception e) {\n+                        clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertBot.title\"),\n+                                Messages.getString(\"ChatLounge.AlertBot.message\"));  //$NON-NLS-2$\n+                    }\n+                    clientgui.getBots().put(bcd.getBotName(), c);\n+                }\n+                \n+            } else if (ev.getSource().equals(butRemoveBot)) {\n+                removeBot();\n+                \n+            } else if (ev.getSource().equals(butShowUnitID)) {\n+                PreferenceManager.getClientPreferences().setShowUnitId(butShowUnitID.isSelected());\n+                mekModel.refreshCells();\n+                repaint();\n+                \n+            } else if (ev.getSource() == butConditions) {\n+                PlanetaryConditionsDialog pcd = new PlanetaryConditionsDialog(clientgui);\n+                boolean userOkay = pcd.showDialog();\n+                if (userOkay) {\n+                    clientgui.getClient().sendPlanetaryConditions(pcd.getConditions());\n+                }\n+                \n+            } else if (ev.getSource() == butRandomMap) {\n+                RandomMapDialog rmd = new RandomMapDialog(clientgui.frame, ChatLounge.this, clientgui.getClient(), mapSettings);\n+                rmd.activateDialog(clientgui.getBoardView().getTilesetManager().getThemes());\n+                \n+            } else if (ev.getSource().equals(butBoardPreview)) {\n+                previewGameBoard();\n+                \n+            } else if (ev.getSource().equals(comMapSizes)) {\n+                if (comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"))) {\n+                    refreshMapUI();\n+                } else if (comMapSizes.getSelectedItem() != null) {\n+                    BoardDimensions size = (BoardDimensions) comMapSizes.getSelectedItem();\n+                    mapSettings.setBoardSize(size.width(), size.height());\n+                    resetAvailBoardSelection = true;\n+                    resetSelectedBoards = true;\n+                    clientgui.getClient().sendMapSettings(mapSettings);\n+                } \n+                \n+            } else if (ev.getSource() == butGroundMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_GROUND);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butSpaceMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_SPACE);\n+                mapSettings.setBoardSize(50, 50);\n+                mapSettings.setMapSize(1, 1);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butLowAtmoMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_ATMOSPHERE);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddX || ev.getSource() == butMapGrowW) {\n+                int newMapWidth = mapSettings.getMapWidth() + 1;\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddY || ev.getSource() == butMapGrowH) {\n+                int newMapHeight = mapSettings.getMapHeight() + 1;\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butSaveMapSetup) {\n+                saveMapSetup();\n+                \n+            } else if (ev.getSource() == butLoadMapSetup) {\n+                loadMapSetup();\n+                \n+            } else if (ev.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+                \n+            } else if (ev.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+                \n+            } else if (ev.getSource() == butMapShrinkW) {\n+                if (mapSettings.getMapWidth() > 1) {\n+                    int newMapWidth = mapSettings.getMapWidth() - 1;\n+                    mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butMapShrinkH) {\n+                if (mapSettings.getMapHeight() > 1) {\n+                    int newMapHeight = mapSettings.getMapHeight() - 1;\n+                    mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butDetach) {\n+                butDetach.setEnabled(false);\n+                panTeam.remove(panTeamOverview);\n+                panTeam.repaint();\n+                panTeamOverview.setDetached(true);\n+                teamOverviewWindow.add(panTeamOverview);\n+                teamOverviewWindow.center();\n+                teamOverviewWindow.setVisible(true);\n+                \n+            } else if (ev.getSource() == butCancelSearch) {\n+                fldSearch.setText(\"\");\n+\n+            } else if (ev.getSource() == butHelp) {\n+                File helpfile = new File(\"docs/Boards Stuff/MapAssemblyHelp.html\");\n+                final JDialog dialog = new ClientDialog(clientgui.frame, \"Map Assembly Help\", true, true);\n+                final int height = 600;\n+                final int width = 600;\n+                \n+                final JEditorPane pane = new JEditorPane();\n+                pane.setName(\"helpPane\");\n+                pane.setEditable(false);\n+                pane.setFont(new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1)));\n+                try {\n+                    pane.setPage(helpfile.toURI().toURL());\n+                    JScrollPane tScroll = new JScrollPane(pane,\n+                            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+                    tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+                    dialog.add(tScroll, BorderLayout.CENTER);\n+                } catch (Exception e) {\n+                    dialog.setTitle(Messages.getString(\"AbstractHelpDialog.noHelp.title\"));\n+                    pane.setText(Messages.getString(\"AbstractHelpDialog.errorReading\") + e.getMessage());\n+                    MegaMek.getLogger().error(e);\n+                }\n+\n+                JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+                button.addActionListener(e -> dialog.setVisible(false));\n+                JPanel okayPanel = new JPanel(new FlowLayout());\n+                okayPanel.add(button);\n+                dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+                Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+                dialog.setPreferredSize(sz);\n+                dialog.setVisible(true);\n+                \n+            } else if (ev.getSource() == butListView) {\n+                scrMekTable.setViewportView(mekTable);\n+                butCollapse.setEnabled(false);\n+                butExpand.setEnabled(false);\n+                \n+            } else if (ev.getSource() == butForceView) {\n+                scrMekTable.setViewportView(mekForceTree);\n+                butCollapse.setEnabled(true);\n+                butExpand.setEnabled(true);\n+                \n+            } else if (ev.getSource() == butCollapse) {\n+                collapseTree();\n+            } else if (ev.getSource() == butExpand) {\n+                expandTree();\n+            } \n+        }\n+    };\n+    \n+    /** Expands the Mek Force Tree fully. */\n+    private void expandTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.expandRow(i);\n+        }\n+    }\n+    \n+    /** Collapses the Mek Force Tree fully. */\n+    private void collapseTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.collapseRow(i);\n+        }\n+    }\n+    \n+    \n+    /** \n+     * Opens a file chooser and saves the current map setup to the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void saveMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.saveMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showSaveDialog(clientgui.frame);\n+        File selectedFile = fc.getSelectedFile();\n+        if (!selectedFile.getName().toLowerCase().endsWith(\".xml\")) {\n+            selectedFile = new File(selectedFile.getPath() + \".xml\");\n+        }\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (selectedFile == null)) {\n+            return;\n+        }\n+        if (selectedFile.exists()) {\n+            String msg = Messages.getString(\"ChatLounge.map.saveMapSetupReplace\", selectedFile.getName());\n+            if (!MMConfirmDialog.confirm(clientgui.frame, \"Confirm replace\", msg)) {\n+                return;\n+            }\n+        }\n+        try(OutputStream os = new FileOutputStream(selectedFile)) {\n+            MapSetup.save(os, mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while saving the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+\n+    /** \n+     * Opens a file chooser and loads a new map setup from the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void loadMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showOpenDialog(clientgui.frame);\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (fc.getSelectedFile() == null)) {\n+            return;\n+        }\n+        if (!fc.getSelectedFile().exists()) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \"File not found.\");\n+            return;\n+        }\n+        try(InputStream os = new FileInputStream(fc.getSelectedFile())) {\n+            MapSetup setup = MapSetup.load(os);\n+            mapSettings.setMapSize(setup.getMapWidth(), setup.getMapHeight());\n+            mapSettings.setBoardSize(setup.getBoardWidth(), setup.getBoardHeight());\n+            mapSettings.setBoardsSelectedVector(setup.getBoards());\n+            clientgui.getClient().sendMapSettings(mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while loading the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+    \n+    private void removeBot() {\n+        Client c = getSelectedClient();\n+        if (!client().bots.containsValue(c)) {\n+//        if ((c == null) || c.equals(clientgui.getClient())) {\n+//            clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+//                    Messages.getString(\"ChatLounge.SelectBo\"));\n+            LobbyErrors.showOnlyOwnBot(clientgui.frame);\n+            return;\n+        }\n+        // Delete units first, which safely disembarks and offloads them\n+        // Don't delete the bot's forces, as that could also delete other players' entitites\n+//        lobbyActions.delete(new ArrayList<>(), game().getPlayerEntities(c.getLocalPlayer(), false), false);\n+        c.die();\n+        clientgui.getBots().remove(c.getName());\n+    }\n+    \n+    private void doBotSettings() {\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        BotClient bot = (BotClient) clientgui.getBots().get(player.getName());\n+        BotConfigDialog bcd = new BotConfigDialog(clientgui.frame, bot);\n+        bcd.setVisible(true);\n+\n+        if (bcd.dialogAborted) {\n+            return; // user didn't click 'ok', add no bot\n+        } else if (bot instanceof Princess) {\n+            ((Princess) bot).setBehaviorSettings(bcd.getBehaviorSettings());\n+            \n+            // bookkeeping:\n+            clientgui.getBots().remove(player.getName());\n+            bot.setName(bcd.getBotName());\n+            clientgui.getBots().put(bot.getName(), bot);\n+            player.setName(bcd.getBotName());\n+            clientgui.chatlounge.refreshPlayerTable();\n+        }\n+    }\n+    \n+    // Put a filter on the files that the user can select the proper file.\n+    FileFilter XMLFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return (f.getPath().toLowerCase().endsWith(\".xml\") || f.isDirectory());\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Map Setup XML files\";\n+        }\n+    };\n+    \n+    private void setManualMapWidth() {\n+        try {\n+            int newMapWidth = Integer.parseInt(fldMapWidth.getText());\n+            if (newMapWidth >= 1 && newMapWidth <= 20) {\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map width\n+        }\n+    }\n+    \n+    private void setManualMapHeight() {\n+        try {\n+            int newMapHeight = Integer.parseInt(fldMapHeight.getText());\n+            if (newMapHeight >= 1 && newMapHeight <= 20) {\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map height\n+        }\n+    }\n+    \n+    private void setManualBoardWidth() {\n+        try {\n+            int newBoardWidth = Integer.parseInt(fldSpaceBoardWidth.getText());\n+            if (newBoardWidth >= 5 && newBoardWidth <= 200) {\n+                mapSettings.setBoardSize(newBoardWidth, mapSettings.getBoardHeight());\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board width\n+        }\n+    }\n+    \n+    private void setManualBoardHeight() {\n+        try {\n+            int newBoardHeight = Integer.parseInt(fldSpaceBoardHeight.getText());\n+            if (newBoardHeight >= 5 && newBoardHeight <= 200) {\n+                mapSettings.setBoardSize(mapSettings.getBoardWidth(), newBoardHeight);\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board height\n+        }\n+    }\n+\n+    /**\n+     * Updates to show the map settings that have, presumably, just been sent by\n+     * the server.\n+     */\n+    @Override\n+    public void updateMapSettings(MapSettings newSettings) {\n+        mapSettings = MapSettings.getInstance(newSettings);\n+        refreshMapButtons();\n+        refreshMapChoice();\n+        refreshMapUI();\n+        refreshBoardsAvailable();\n+        updateSearch(fldSearch.getText());\n+        refreshLabels();\n+    }\n+\n+\n+    /**OK Refreshes the Map Summary, Tech Level and Game Year labels. */\n+    private void refreshLabels() {\n+        Font scaledFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1));\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        String txt = Messages.getString(\"ChatLounge.GameYear\"); \n+        txt += opts.intOption(OptionsConstants.ALLOWED_YEAR);\n+        lblGameYear.setText(txt);\n+        lblGameYear.setFont(scaledFont);\n+        lblGameYear.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\"))); \n+        \n+        String tlString = TechConstants.getLevelDisplayableName(TechConstants.T_TECH_UNKNOWN);\n+        IOption tlOpt = opts.getOption(OptionsConstants.ALLOWED_TECHLEVEL);\n+        if (tlOpt != null) {\n+            tlString = tlOpt.stringValue();\n+        }\n+        lblTechLevel.setText(Messages.getString(\"ChatLounge.TechLevel\") + tlString);\n+        lblTechLevel.setFont(scaledFont);\n+        lblTechLevel.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\")));\n+        \n+        txt = Messages.getString(\"ChatLounge.MapSummary\"); \n+        txt += (mapSettings.getBoardWidth() * mapSettings.getMapWidth()) + \" x \" \n+                + (mapSettings.getBoardHeight() * mapSettings.getMapHeight());\n+        if (butGroundMap.isSelected()) {\n+            txt += \" Ground Map\";\n+        } else if (butLowAtmoMap.isSelected()) {\n+            txt += \" Atmospheric Map\";\n+        } else {\n+            txt += \" Space Map\";\n+        }\n+        lblMapSummary.setText(txt);\n+        lblMapSummary.setFont(scaledFont);\n+\n+        StringBuilder selectedMaps = new StringBuilder();\n+        selectedMaps.append(Messages.getString(\"ChatLounge.MapSummarySelectedMaps\"));\n+        for (String map: mapSettings.getBoardsSelectedVector()) {\n+            selectedMaps.append(\"&nbsp;&nbsp;\");\n+            if (map.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                selectedMaps.append(MapSettings.BOARD_SURPRISE);\n+            } else {\n+                selectedMaps.append(map);\n+            }\n+            selectedMaps.append(\"<br>\"); \n+        }\n+        lblMapSummary.setToolTipText(scaleStringForGUI(selectedMaps.toString()));\n+    }\n+    \n+    @Override\n+    public void ready() {\n+        final Client client = clientgui.getClient();\n+        final IGame game = client.getGame();\n+        final GameOptions gOpts = game.getOptions();\n+        \n+        // enforce exclusive deployment zones in double blind\n+        for (IPlayer player: client.getGame().getPlayersVector()) {\n+            if (!isValidStartPos(game, player)) {\n+                clientgui.doAlertDialog(Messages.getString(\"ChatLounge.OverlapDeploy.title\"), \n+                        Messages.getString(\"ChatLounge.OverlapDeploy.msg\"));\n+                return;\n+            }\n+        }\n+\n+        // Make sure player has a commander if Commander killed victory is on\n+        if (gOpts.booleanOption(OptionsConstants.VICTORY_COMMANDER_KILLED)) {\n+            List<String> players = new ArrayList<>();\n+            if ((game.getLiveCommandersOwnedBy(localPlayer()) < 1)\n+                    && (game.getEntitiesOwnedBy(localPlayer()) > 0)) {\n+                players.add(client.getLocalPlayer().getName());\n+            }\n+            for (Client bc : clientgui.getBots().values()) {\n+                if ((game.getLiveCommandersOwnedBy(bc.getLocalPlayer()) < 1)\n+                        && (game.getEntitiesOwnedBy(bc.getLocalPlayer()) > 0)) {\n+                    players.add(bc.getLocalPlayer().getName());\n+                }\n+            }\n+            if (players.size() > 0) {\n+                String title = Messages.getString(\"ChatLounge.noCmdr.title\"); \n+                String msg = Messages.getString(\"ChatLounge.noCmdr.msg\"); \n+                for (String player : players) {\n+                    msg += player + \"\\n\";\n+                }\n+                clientgui.doAlertDialog(title, msg);\n+                return;\n+            }\n+\n+        }\n+\n+        boolean done = !localPlayer().isDone();\n+        client.sendDone(done);\n+        refreshDoneButton(done);\n+        for (Client botClient : clientgui.getBots().values()) {\n+            botClient.sendDone(done);\n+        }\n+    }\n+\n+    Client getSelectedClient() {\n+        if ((tablePlayers == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return null;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (localPlayer().equals(player)) {\n+            return client();\n+        } else if (client().bots.containsKey(player.getName())) {\n+            return client().bots.get(player.getName());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Stop just ignoring events and actually stop listening to them.\n+     */\n+    @Override\n+    public void removeAllListeners() {\n+        clientgui.getClient().getGame().removeGameListener(this);\n+        clientgui.getBoardView().removeBoardViewListener(this);\n+        GUIPreferences.getInstance().removePreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().removePreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().removeListener(mechSummaryCacheListener);\n+        \n+        if (loader != null) {\n+            loader.cancel(true);\n+        }\n+        \n+        tablePlayers.getSelectionModel().removeListSelectionListener(this);\n+        tablePlayers.removeMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        lisBoardsAvailable.removeMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.removeWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.removeMouseListener(mekTableMouseAdapter);\n+        mekForceTree.removeMouseListener(mekForceTreeMouseListener);\n+        mekTable.getTableHeader().removeMouseListener(mekTableHeaderMouseListener);\n+        mekTable.removeKeyListener(mekTableKeyListener);\n+        mekForceTree.removeKeyListener(mekTreeKeyListener);\n+        \n+        butAdd.removeActionListener(lobbyListener);\n+        butAddBot.removeActionListener(lobbyListener);\n+        butArmy.removeActionListener(lobbyListener);\n+        butBoardPreview.removeActionListener(lobbyListener);\n+        butBotSettings.removeActionListener(lobbyListener);\n+        butCompact.removeActionListener(lobbyListener);\n+        butConditions.removeActionListener(lobbyListener);\n+        butConfigPlayer.removeActionListener(lobbyListener);\n+        butLoadList.removeActionListener(lobbyListener);\n+        butNames.removeActionListener(lobbyListener);\n+        butOptions.removeActionListener(lobbyListener);\n+        butRandomMap.removeActionListener(lobbyListener);\n+        butRemoveBot.removeActionListener(lobbyListener);\n+        butSaveList.removeActionListener(lobbyListener);\n+        butShowUnitID.removeActionListener(lobbyListener);\n+        butSkills.removeActionListener(lobbyListener);\n+        butSpaceSize.removeActionListener(lobbyListener);\n+        butCamo.removeActionListener(camoListener);\n+        butAddX.removeActionListener(lobbyListener);\n+        butAddY.removeActionListener(lobbyListener);\n+        butMapGrowW.removeActionListener(lobbyListener);\n+        butMapShrinkW.removeActionListener(lobbyListener);\n+        butMapGrowH.removeActionListener(lobbyListener);\n+        butMapShrinkH.removeActionListener(lobbyListener);\n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        butLoadMapSetup.removeActionListener(lobbyListener);\n+        butSaveMapSetup.removeActionListener(lobbyListener);\n+        butDetach.removeActionListener(lobbyListener);\n+        butCancelSearch.removeActionListener(lobbyListener);\n+        butHelp.removeActionListener(lobbyListener);\n+        butListView.removeActionListener(lobbyListener);\n+        butForceView.removeActionListener(lobbyListener);\n+        butCollapse.removeActionListener(lobbyListener);\n+        butExpand.removeActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        \n+        comboTeam.removeActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Returns true if the given list of entities can be configured as a group.\n+     * This requires that they all have the same owner, and that none of the\n+     * units are being transported. Also, the owner must be the player or one\n+     * of his bots. \n+     */\n+    boolean canConfigureMultipleDeployment(Collection<Entity> entities) {\n+        return haveSingleOwner(entities) \n+                && !containsTransportedUnit(entities)\n+                && canEditAny(entities);\n+    }\n+    \n+    /**\n+     * Returns true if the given collection contains at least one entity\n+     * that the local player can edit, i.e. is his own or belongs to\n+     * one of his bots. Does not check if the units are otherwise configured,\n+     * e.g. transported.\n+     * <P>See also {@link #isEditable(Entity)}\n+     */\n+    boolean canEditAny(Collection<Entity> entities) {\n+        return entities.stream().anyMatch(e -> isEditable(e));\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see all of the given entities.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not on his team.\n+     */\n+    boolean canSeeAll(Collection<Entity> entities) {\n+        if (!game().getOptions().booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                && !game().getOptions().booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP)) {\n+            return true;\n+        }\n+        for (Entity entity: entities) {\n+            if (!entityInLocalTeam(entity)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see the given entity.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not his own.\n+     */\n+    boolean canSee(Entity entity) {\n+        return canSeeAll(Arrays.asList(entity));\n+    }\n+    \n+    boolean entityInLocalTeam(Entity entity) {\n+        return !localPlayer().isEnemyOf(entity.getOwner());\n+    }\n+    \n+\n+    @Override\n+    public void valueChanged(ListSelectionEvent event) {\n+        if (event.getValueIsAdjusting()) {\n+            return;\n+        }\n+        \n+        if (event.getSource().equals(tablePlayers.getSelectionModel())) {\n+            refreshPlayerConfig();\n+        }\n+    }\n+    \n+    /** Adapts the enabled state of the player config UI items to the player selection. */\n+    private void refreshPlayerConfig() {\n+        var selPlayers = getselectedPlayers();\n+        var hasSelection = !selPlayers.isEmpty();\n+        var isSinglePlayer = selPlayers.size() == 1;\n+        var allConfigurable = hasSelection && selPlayers.stream().allMatch(lobbyActions::isSelfOrLocalBot);\n+        var isSingleLocalBot = isSinglePlayer && (getSelectedClient() instanceof BotClient);\n+        comboTeam.setEnabled(allConfigurable);\n+        butLoadList.setEnabled(allConfigurable && isSinglePlayer);\n+        butCamo.setEnabled(allConfigurable && isSinglePlayer);\n+        butConfigPlayer.setEnabled(allConfigurable && isSinglePlayer);\n+        refreshCamoButton();\n+        // Disable the Remove Bot button for the \"player\" of a \"Connect As Bot\" client\n+        butRemoveBot.setEnabled(isSingleLocalBot);\n+        butSaveList.setEnabled(false);\n+        if (isSinglePlayer) {\n+            var selPlayer = theElement(selPlayers);\n+            var hasUnits = !game().getPlayerEntities(selPlayer, false).isEmpty();\n+            butSaveList.setEnabled(hasUnits && unitsVisible(selPlayer));\n+            setTeamSelectedItem(selPlayer.getTeam());\n+        }\n+    }\n+    \n+    /** Sets (without firing events) the team combobox. */\n+    private void setTeamSelectedItem(int team) {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(team);\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+    \n+    /** \n+     * Returns false when any blind-drop option is active and player is not on the local team; \n+     * true otherwise. When true, individual units of the given player should not be shown/saved/etc. \n+     */ \n+    private boolean unitsVisible(IPlayer player) {\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        boolean isBlindDrop = opts.booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                || opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+        return !player.isEnemyOf(localPlayer()) || !isBlindDrop;\n+    }\n+\n+    public class PlayerTableMouseAdapter extends MouseInputAdapter {\n+\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                IPlayer player = playerModel.getPlayerAt(row);\n+                if (player != null) {\n+                    boolean isLocalPlayer = player.equals(localPlayer());\n+                    boolean isLocalBot = clientgui.getBots().get(player.getName()) != null;\n+                    if ((isLocalPlayer || isLocalBot)) {\n+                        configPlayer();\n+                    }\n+                }\n+            }\n+        }\n+        \n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected player,\n+                // clear the selection and select that entity instead\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                if (!tablePlayers.isRowSelected(row)) {\n+                    tablePlayers.changeSelection(row, row, false, false);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            ScalingPopup popup = PlayerTablePopup.playerTablePopup(clientgui, \n+                    playerTableActionListener, getselectedPlayers());\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    private ActionListener playerTableActionListener = new ActionListener() {\n+        \n+        @Override\n+        public void actionPerformed(ActionEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+        \n+            StringTokenizer st = new StringTokenizer(e.getActionCommand(), \"|\");\n+            String command = st.nextToken();\n+            switch (command) {\n+            case \"CONFIG\":\n+                configPlayer();\n+                break;\n+\n+            case \"TEAM\":\n+                int newTeam = Integer.parseInt(st.nextToken());\n+                lobbyActions.changeTeam(getselectedPlayers(), newTeam);\n+                break;\n+\n+            case \"BOTREMOVE\":\n+                removeBot();\n+                break;\n+\n+            case \"BOTSETTINGS\":\n+                doBotSettings();\n+                break;\n+                \n+            case \"DEPLOY\":\n+                int startPos = Integer.parseInt(st.nextToken());\n+                if (game().getOptions().booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                        && (startPos >= 1) && (startPos <= 9)) {\n+                    startPos += 10;\n+                }\n+                for (IPlayer player: getselectedPlayers()) {\n+                    if (lobbyActions.isSelfOrLocalBot(player)) {\n+                        if (client().isLocalBot(player)) {\n+                            // must use the bot's own player object:\n+                            client().getBotClient(player).getLocalPlayer().setStartingPos(startPos);\n+                            client().getBotClient(player).sendPlayerInfo();\n+                        } else {\n+                            player.setStartingPos(startPos);\n+                            client().sendPlayerInfo();\n+                        }\n+                    }\n+                }\n+                break;\n+                \n+            }\n+        }\n+    };\n+    \n+    \n+    private ArrayList<IPlayer> getselectedPlayers() {\n+        var result = new ArrayList<IPlayer>(); \n+        for (int row: tablePlayers.getSelectedRows()) {\n+            IPlayer player = playerModel.getPlayerAt(row);\n+            if (player != null) {\n+                result.add(player);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    KeyListener mekTableKeyListener = new KeyAdapter() {\n+\n+        @Override\n+        public void keyPressed(KeyEvent e) {\n+            if (mekTable.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            List<Entity> entities = getSelectedEntities();\n+            int code = e.getKeyCode();\n+            if ((code == KeyEvent.VK_DELETE) || (code == KeyEvent.VK_BACK_SPACE)) {\n+                e.consume();\n+                lobbyActions.delete(new ArrayList<>(), entities, true);\n+            } else if (code == KeyEvent.VK_SPACE) {\n+                e.consume();\n+                mechReadoutAction(entities);\n+            } else if (code == KeyEvent.VK_ENTER) {\n+                e.consume();\n+                if (entities.size() == 1) {\n+                    lobbyActions.customizeMech(entities.get(0));\n+                } else if (canConfigureMultipleDeployment(entities)) {\n+                    lobbyActions.customizeMechs(entities);\n+                }\n+            } else if (code == KeyEvent.VK_C && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                StringSelection stringSelection = new StringSelection(clipboardString(entities));\n+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+                clipboard.setContents(stringSelection, null);\n+                \n+            } else if (code == KeyEvent.VK_V && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                importClipboard(); \n+                \n+            } else if (code == KeyEvent.VK_P) {\n+                e.consume();\n+                System.out.println(game().getEntitiesVector().size() + \" Units\");\n+                game().getEntitiesVector().stream().forEach(System.out::println);\n+                \n+            } else if (code == KeyEvent.VK_F) {\n+                e.consume();\n+                System.out.println(\"Forces: ---\");\n+                System.out.println(game().getForces());\n+            }\n+        }\n+    };\n+    \n+    /** Reads the clipboard and adds units, if it can parse them. */\n+    public void importClipboard() {\n+        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        Transferable contents = clipboard.getContents(null);\n+        boolean hasTransferableText = (contents != null) &&\n+                contents.isDataFlavorSupported(DataFlavor.stringFlavor);\n+        List<Entity> newEntities = new ArrayList<>();\n+        if (hasTransferableText) {\n+            try {\n+                String result = (String)contents.getTransferData(DataFlavor.stringFlavor);\n+                StringTokenizer lines = new StringTokenizer(result, \"\\n\");\n+                while (lines.hasMoreTokens()) {\n+                    String line = lines.nextToken();\n+                    StringTokenizer tabs = new StringTokenizer(line, \"\\t\");\n+                    String unit = \"\";\n+                    if (tabs.hasMoreTokens()) {\n+                        unit = tabs.nextToken();\n+                    }\n+                    if (tabs.hasMoreTokens()) {\n+                        unit += \" \" + tabs.nextToken();\n+                    }\n+                    MechSummary ms = MechSummaryCache.getInstance().getMech(unit);\n+                    if (ms == null) {\n+                        continue;\n+                    }\n+                    Entity newEntity = new MechFileParser(ms.getSourceFile(),\n+                            ms.getEntryName()).getEntity();\n+                    if (newEntity != null) {\n+                        newEntity.setOwner(localPlayer());\n+                        newEntities.add(newEntity);\n+                    }\n+                }\n+            }\n+            catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            if (!newEntities.isEmpty()) {\n+                client().sendAddEntity(newEntities);\n+            }\n+        }\n+    }\n+    \n+    /** Returns a String representing the entities to export to the clipboard. */\n+    private String clipboardString(Collection<Entity> entities) {\n+        StringBuilder result = new StringBuilder();\n+        for (Entity entity: entities) {\n+            // Chassis\n+            result.append(entity.getChassis()).append(\"\\t\");\n+            // Model\n+            result.append(entity.getModel()).append(\"\\t\");\n+            // Weight; format for locale to avoid wrong \",.\" etc.\n+            Locale cl = Locale.getDefault();\n+            NumberFormat numberFormatter = NumberFormat.getNumberInstance(cl);\n+            result.append(numberFormatter.format(entity.getWeight())).append(\"\\t\");\n+            // Pilot name\n+            result.append(entity.getCrew().getName()).append(\"\\t\");\n+            // Crew Skill with text\n+            result.append(CrewSkillSummaryUtil.getSkillNames(entity)).append(\": \")\n+                    .append(entity.getCrew().getSkillsAsString(false)).append(\"\\t\");\n+            // BV without C3 but with pilot (as that gets exported too)\n+            result.append(entity.calculateBattleValue(true, false)).append(\"\\t\");\n+            result.append(\"\\n\");\n+        }\n+        return result.toString();\n+    }\n+    \n+    /** Returns a list of entities selected in the ForceTree. May be empty, but not null. */\n+    private List<Entity> getTreeSelectedEntities() {\n+        TreePath[] selection = mekForceTree.getSelectionPaths();\n+        List<Entity> entities = new ArrayList<>();\n+        if (selection != null) {\n+            for (TreePath path: selection) {\n+                if (path != null) {\n+                    Object selected = path.getLastPathComponent();\n+                    if (selected instanceof Entity) {\n+                        entities.add((Entity) selected);\n+                    }  \n+                }\n+            }\n+        }\n+        return entities;\n+    }\n+    \n+    /** Returns a list of forces selected in the ForceTree. May be empty, but not null. */\n+    private List<Force> getTreeSelectedForces() {\n+        TreePath[] selection = mekForceTree.getSelectionPaths();\n+        List<Force> selForces = new ArrayList<>();\n+        if (selection != null) {\n+            for (TreePath path: selection) {\n+                if (path != null) {\n+                    Object selected = path.getLastPathComponent();\n+                    if (selected instanceof Force) {\n+                        selForces.add((Force) selected);\n+                    } \n+                }\n+            }\n+        }\n+        return selForces;\n+    }\n+    \n+    /** The key listener for the Force Tree. */\n+    KeyListener mekTreeKeyListener = new KeyAdapter() {\n+\n+        @Override\n+        public void keyPressed(KeyEvent e) {\n+            List<Entity> selEntities = getTreeSelectedEntities();\n+            List<Force> selForces = getTreeSelectedForces();\n+            boolean onlyOneEntity = (selEntities.size() == 1) && selForces.isEmpty();\n+            int code = e.getKeyCode();\n+            \n+            if (code == KeyEvent.VK_SPACE) {\n+                e.consume();\n+                mechReadoutAction(selEntities);\n+                \n+            } else if (code == KeyEvent.VK_ENTER && onlyOneEntity) {\n+                e.consume();\n+                lobbyActions.customizeMech(selEntities.get(0));\n+                \n+            } else if (code == KeyEvent.VK_UP && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                lobbyActions.forceMove(selForces, selEntities, true);\n+                \n+            } else if (code == KeyEvent.VK_DOWN && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                lobbyActions.forceMove(selForces, selEntities, false);\n+                \n+            } else if ((code == KeyEvent.VK_DELETE) || (code == KeyEvent.VK_BACK_SPACE)) {\n+                e.consume();\n+                lobbyActions.delete(selForces, selEntities, true);\n+                \n+            } else if (code == KeyEvent.VK_RIGHT && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                expandTree();\n+                \n+            } else if (code == KeyEvent.VK_LEFT && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                collapseTree();\n+                \n+            } else if (code == KeyEvent.VK_C && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                StringSelection stringSelection = new StringSelection(clipboardString(selEntities));\n+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+                clipboard.setContents(stringSelection, null);\n+                \n+            } else if (code == KeyEvent.VK_V && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                importClipboard();\n+                \n+            } else if (code == KeyEvent.VK_P) {\n+                e.consume();\n+                System.out.println(game().getEntitiesVector().size() + \" Units\");\n+                game().getEntitiesVector().stream().forEach(System.out::println);\n+                \n+            } else if (code == KeyEvent.VK_F) {\n+                e.consume();\n+                System.out.println(\"Forces: ---\");\n+                System.out.println(game().getForces());\n+            }\n+        }\n+    };\n+\n+\n+    public class MapListMouseAdapter extends MouseInputAdapter implements ActionListener {\n+        \n+        @Override\n+        public void actionPerformed(ActionEvent action) {\n+            String[] command = action.getActionCommand().split(\":\");\n+\n+            switch (command[0]) {\n+            case \"BOARD\":", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4OTgwMA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612089800", "bodyText": "Let's convert the ArrayList to a more generic List, unless there's some overriding need for it.", "author": "NickAragua", "createdAt": "2021-04-13T02:48:07Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);\n+        \n+        // Planetary Conditions and Random Map Settings buttons\n+        FixedYPanel panSettings = new FixedYPanel();\n+        panSettings.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panSettings.add(butConditions);\n+        panSettings.add(butRandomMap);\n+//        panMap.add(panSettings);\n+\n+        FixedYPanel panTopRows = new FixedYPanel();\n+        panTopRows.setLayout(new BoxLayout(panTopRows, BoxLayout.PAGE_AXIS));\n+        panTopRows.add(panMapType);\n+        panTopRows.add(panSettings);\n+        \n+        JPanel panHelp = new JPanel(new GridLayout(1,1));\n+        panHelp.add(butHelp);\n+        \n+        FixedYPanel panTopRowsHelp = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 30, 5));\n+        panTopRowsHelp.add(panTopRows);\n+        panTopRowsHelp.add(panHelp);\n+        panMap.add(panTopRowsHelp);\n+        \n+        // Main part: Map Assembly\n+        panMap.add(panGroundMap);\n+\n+    }\n+\n+    /**\n+     * Sets up the ground map selection panel\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void setupMapAssembly() {\n+\n+        panGroundMap = new JPanel(new GridLayout(1, 1));\n+        panGroundMap.setBorder(new EmptyBorder(20, 10, 10, 10));\n+\n+        panMapButtons.setLayout(new BoxLayout(panMapButtons, BoxLayout.PAGE_AXIS));\n+        // Resize the preview buttons when the panel is resized\n+        panMapButtons.addComponentListener(new ComponentAdapter() {\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateMapButtons();\n+            }\n+        });\n+        \n+        panMapWidth.add(lblMapWidth);\n+        panMapWidth.add(butMapShrinkW);\n+        panMapWidth.add(fldMapWidth);\n+        panMapWidth.add(butMapGrowW);\n+        \n+        panMapHeight.add(lblMapHeight);\n+        panMapHeight.add(butMapShrinkH);\n+        panMapHeight.add(fldMapHeight);\n+        panMapHeight.add(butMapGrowH);\n+        \n+        panSpaceBoardWidth.add(lblSpaceBoardWidth);\n+        panSpaceBoardWidth.add(fldSpaceBoardWidth);\n+        panSpaceBoardWidth.setVisible(false);\n+        \n+        panSpaceBoardHeight.add(lblSpaceBoardHeight);\n+        panSpaceBoardHeight.add(fldSpaceBoardHeight);\n+        panSpaceBoardHeight.setVisible(false);\n+        \n+        FixedYPanel bottomPanel = new FixedYPanel();\n+        bottomPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n+        bottomPanel.add(butBoardPreview);\n+        bottomPanel.add(butSaveMapSetup);\n+        bottomPanel.add(butLoadMapSetup);\n+\n+        butBoardPreview.setToolTipText(Messages.getString(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+\n+        // The left side panel including the game map preview\n+        JPanel panMapPreview = new JPanel();\n+        panMapPreview.setLayout(new BoxLayout(panMapPreview, BoxLayout.PAGE_AXIS));\n+        \n+        panMapPreview.add(panMapWidth);\n+        panMapPreview.add(panMapHeight);\n+        panMapPreview.add(panSpaceBoardWidth);\n+        panMapPreview.add(panSpaceBoardHeight);\n+        panMapPreview.add(panMapButtons);\n+        panMapPreview.add(bottomPanel);\n+        \n+        // The right side panel including the list of available boards\n+        comMapSizes = new JComboBox<Comparable>();\n+        refreshMapSizes();\n+\n+        lisBoardsAvailable = new JList<String>(new DefaultListModel<String>());\n+        lisBoardsAvailable.setCellRenderer(new BoardNameRenderer());\n+        lisBoardsAvailable.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n+        lisBoardsAvailable.setVisibleRowCount(-1);\n+        lisBoardsAvailable.setDragEnabled(true);\n+        lisBoardsAvailable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        scrBoardsAvailable = new JScrollPane(lisBoardsAvailable);\n+        refreshBoardsAvailable();\n+        \n+        JPanel panAvail = new JPanel();\n+        panAvail.setLayout(new BoxLayout(panAvail, BoxLayout.PAGE_AXIS));\n+        panAvail.setBorder(new EmptyBorder(0, 20, 0, 0));\n+        panAvail.add(setupAvailTopPanel());\n+        panAvail.add(scrBoardsAvailable);\n+        \n+        // The splitpane holding the left and right side panels\n+        splGroundMap = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panMapPreview, panAvail);\n+        splGroundMap.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+            \n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+        });\n+        panGroundMap.add(splGroundMap);\n+\n+        // setup the board preview window.\n+        boardPreviewW = new ClientDialog(clientgui.frame, \n+                Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"), \n+                false);\n+        boardPreviewW.setLocationRelativeTo(clientgui.frame);\n+\n+        try {\n+            BoardView1 bv = new BoardView1(boardPreviewGame, null, null);\n+            bv.setDisplayInvalidHexInfo(false);\n+            bv.setUseLOSTool(false);\n+            boardPreviewW.add(bv.getComponent(true));\n+            boardPreviewW.setSize(clientgui.frame.getWidth()/2, clientgui.frame.getHeight()/2);\n+            // Most boards will be far too large on the standard zoom\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            boardPreviewW.center();\n+        } catch (IOException e) {\n+            JOptionPane.showMessageDialog(this,\n+                            Messages.getString(\"BoardEditor.CouldntInitialize\") + e,\n+                            Messages.getString(\"BoardEditor.FatalError\"), JOptionPane.ERROR_MESSAGE); \n+        }\n+        refreshMapButtons();\n+    }\n+    \n+    /** \n+     *  Sets up and returns the panel above the available boards list \n+     *  containing the search bar and the map size chooser.  \n+     */\n+    private JPanel setupAvailTopPanel() {\n+        FixedYPanel result = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 20, 2));\n+        result.setBorder(new EmptyBorder(5, 5, 5, 5));\n+        \n+        fldSearch.getDocument().addDocumentListener(new DocumentListener() {\n+            @Override\n+            public void changedUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void removeUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void insertUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+        });\n+        \n+        result.add(lblBoardSize);\n+        result.add(comMapSizes);\n+        result.add(new JLabel(\"    \"));\n+        result.add(lblSearch);\n+        result.add(fldSearch);\n+        result.add(butCancelSearch);\n+\n+        return result;\n+    }\n+    \n+    /** \n+     * Reacts to changes in the available boards search field, showing matching boards\n+     * for the search string when it has at least 3 characters\n+     * and reverting to all boards when the search string is empty.\n+     */\n+    private void updateSearch(String searchString) {\n+        if (searchString.isEmpty()) {\n+            refreshBoardsAvailable();\n+        } else if (searchString.length() > 2) {\n+            refreshBoardsAvailable(getSearchedItems(searchString));\n+        }\n+    }\n+    \n+    /** \n+     * Returns the available boards that match the given search string\n+     * (path or file name contains the search string.) \n+     */\n+    protected List<String> getSearchedItems(String searchString) {\n+        String lowerCaseSearchString = searchString.toLowerCase();\n+        return mapSettings.getBoardsAvailableVector().stream()\n+                .filter(b -> b.toLowerCase().contains(lowerCaseSearchString) && isBoardFile(b))\n+                .collect(Collectors.toList());\n+    }\n+    \n+    /** \n+     * Returns a suitable divider location for the splitpane that contains\n+     * the available boards list and the map preview. The divider location\n+     * gives between 30% and 50% of space to the map preview depending\n+     * on the width of the game map.\n+     */\n+    private double getDividerLocation() {\n+        double base = 0.3;\n+        int width = mapSettings.getBoardWidth() * mapSettings.getMapWidth();\n+        int height = mapSettings.getBoardHeight() * mapSettings.getMapHeight();\n+        int wAspect = Math.max(1, width / height + 1);\n+        return Math.min(base + wAspect * 0.05, 0.5);\n+    }\n+\n+    /** Updates the ground map type chooser (ground/atmosphere map). */\n+    private void refreshMapChoice() {\n+        // refresh UI possibly from a server update\n+        JToggleButton button = butGroundMap;\n+        if (mapSettings.getMedium() == MapSettings.MEDIUM_ATMOSPHERE) {\n+            button = butLowAtmoMap;\n+        } else if (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {\n+            button = butSpaceMap;\n+        }\n+        \n+        if (!button.isSelected()) {\n+            button.removeActionListener(lobbyListener);\n+            button.setSelected(true);\n+            button.addActionListener(lobbyListener);\n+        }\n+    }\n+    \n+    /** Updates the list of available map sizes. */\n+    private void refreshMapSizes() {\n+        int oldSelection = comMapSizes.getSelectedIndex();\n+        mapSizes = clientgui.getClient().getAvailableMapSizes();\n+        comMapSizes.removeActionListener(lobbyListener);\n+        comMapSizes.removeAllItems();\n+        for (BoardDimensions size : mapSizes) {\n+            comMapSizes.addItem(size);\n+        }\n+        comMapSizes.addItem(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        comMapSizes.setSelectedIndex(oldSelection != -1 ? oldSelection : 0);\n+        comMapSizes.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the map assembly UI from the current map settings. Does NOT trigger further\n+     * changes or result in packets to the server. \n+     */\n+    private void refreshMapUI() {\n+        boolean inSpace = mapSettings.getMedium() == MapSettings.MEDIUM_SPACE;\n+        boolean onGround = mapSettings.getMedium() == MapSettings.MEDIUM_GROUND;\n+        boolean customSize = comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        lisBoardsAvailable.setEnabled(!inSpace);\n+        mapIcons.clear();\n+        butConditions.setEnabled(!inSpace);\n+        fldSearch.setEnabled(!inSpace);\n+        butRandomMap.setEnabled(!inSpace);\n+        panMapHeight.setVisible(!inSpace);\n+        panMapWidth.setVisible(!inSpace);\n+        panSpaceBoardWidth.setVisible(inSpace || customSize);\n+        panSpaceBoardHeight.setVisible(inSpace || customSize);\n+        comMapSizes.setEnabled(!inSpace);\n+        lblSearch.setEnabled(!inSpace);\n+        lblBoardSize.setEnabled(!inSpace);\n+        butSaveMapSetup.setEnabled(!inSpace);\n+        butLoadMapSetup.setEnabled(!inSpace);\n+        butMapShrinkW.setEnabled(mapSettings.getMapWidth() > 1);\n+        butMapShrinkH.setEnabled(mapSettings.getMapHeight() > 1);\n+        \n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        if (onGround) {\n+            butGroundMap.setSelected(true);\n+        } else if (inSpace) {\n+            butSpaceMap.setSelected(true);\n+        } else {\n+            butLowAtmoMap.setSelected(true);\n+        }\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        fldMapWidth.setText(Integer.toString(mapSettings.getMapWidth()));\n+        fldMapHeight.setText(Integer.toString(mapSettings.getMapHeight()));\n+        fldSpaceBoardWidth.setText(Integer.toString(mapSettings.getBoardWidth()));\n+        fldSpaceBoardHeight.setText(Integer.toString(mapSettings.getBoardHeight()));\n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+    }\n+\n+    /** \n+     * Refreshes the list of available boards with all available boards plus\n+     * GENERATED. Useful for first setup, when the server transmits new\n+     * map settings and when the text search field is empty.\n+     */\n+    private void refreshBoardsAvailable() {\n+        if (!lisBoardsAvailable.isEnabled()) {\n+            return;\n+        }\n+        lisBoardsAvailable.setFixedCellHeight(-1);\n+        lisBoardsAvailable.setFixedCellWidth(-1);\n+        List<String> availBoards = new ArrayList<>(); \n+        availBoards.add(MapSettings.BOARD_GENERATED);\n+        availBoards.addAll(mapSettings.getBoardsAvailableVector());\n+        refreshBoardsAvailable(availBoards);\n+    }\n+    \n+    /** \n+     * Refreshes the list of available maps with the given list of boards. \n+     */\n+    private void refreshBoardsAvailable(List<String> boardList) {\n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        // Replace the data model (adding the elements one by one to the existing model\n+        // in Java 8 style is sluggish because of event firing)\n+        DefaultListModel<String> newModel = new DefaultListModel<>();\n+        for (String s: boardList) {\n+            newModel.addElement(s);\n+        }\n+        lisBoardsAvailable.setModel(newModel);\n+        lisBoardsAvailable.clearSelection();\n+        lisBoardsAvailable.addListSelectionListener(this);\n+    }\n+    \n+    public boolean isMultipleBoards() {\n+        return mapSettings.getMapHeight() * mapSettings.getMapWidth() > 1;\n+    }\n+    \n+    MapSettings oldMapSettings = MapSettings.getInstance();\n+\n+    /**\n+     * Fills the Map Buttons scroll pane twith the appropriate amount of buttons\n+     * in the appropriate layout\n+     */\n+    private void refreshMapButtons() {\n+        panMapButtons.removeAll();\n+        panMapButtons.setVisible(false);\n+        panMapButtons.add(Box.createVerticalGlue());\n+        Dimension buttonSize = null;\n+\n+        // If buttons are unused, remove their image so that they update when they're used once more\n+        if (mapSettings.getMapHeight() * mapSettings.getMapWidth() < mapButtons.size()) {\n+            for (MapPreviewButton button: mapButtons.subList(mapSettings.getMapHeight() * mapSettings.getMapWidth(), mapButtons.size())) {\n+                button.reset();\n+            }\n+        }\n+\n+        // Add new map preview buttons if the map has grown\n+        while (mapSettings.getMapHeight() * mapSettings.getMapWidth() > mapButtons.size()) {\n+            mapButtons.add(new MapPreviewButton(this));\n+        }\n+\n+        // Re-add the buttons to the panel and update them as necessary\n+        for (int i = 0; i < mapSettings.getMapHeight(); i++) {\n+            JPanel row = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n+            panMapButtons.add(row);\n+            for (int j = 0; j < mapSettings.getMapWidth(); j++) {\n+                int index = i * mapSettings.getMapWidth() + j;\n+                MapPreviewButton button = mapButtons.get(index);\n+                button.setIndex(index);\n+                row.add(button);\n+\n+                // Update the board base image if it's generated and the settings have changed\n+                // or the board name has changed\n+                String boardName = mapSettings.getBoardsSelectedVector().get(index);\n+                if (!button.getBoard().equals(boardName) \n+                        || oldMapSettings.getMedium() != mapSettings.getMedium()\n+                        || (!mapSettings.equalMapGenParameters(oldMapSettings) \n+                                && mapSettings.getMapWidth() == oldMapSettings.getMapWidth()\n+                                && mapSettings.getMapHeight() == oldMapSettings.getMapHeight())) {\n+                    IBoard buttonBoard; \n+                    Image image;\n+                    // Generated and space boards use a generated example\n+                    if (boardName.startsWith(MapSettings.BOARD_GENERATED) \n+                            || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                        buttonBoard = BoardUtilities.generateRandom(mapSettings);\n+                        image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                    } else { \n+                        String boardForImage = boardName;\n+                        // For a surprise board, just use the first board as example\n+                        if (boardName.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                            boardForImage = extractSurpriseMaps(boardName).get(0);\n+                        }\n+                        File boardFile = new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile();\n+                        if (boardFile.exists()) {\n+                            buttonBoard = new Board(16, 17);\n+                            buttonBoard.load(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile());\n+                            StringBuffer errs = new StringBuffer();\n+                            try (InputStream is = new FileInputStream(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile())) {\n+                                buttonBoard.load(is, errs, true);\n+                            } catch (IOException ex) {\n+                                buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            }\n+                            image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                        } else {\n+                            buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            BufferedImage emptyBoardMap = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                            markServerSideBoard(emptyBoardMap);\n+                            image = emptyBoardMap;\n+                        }\n+                    }\n+                    button.setImage(image, boardName);\n+                    buttonSize = optMapButtonSize(image);\n+                }\n+                button.scheduleRescale();\n+            }\n+        }\n+        oldMapSettings = MapSettings.getInstance(mapSettings);\n+        \n+        if (buttonSize != null) {\n+            for (MapPreviewButton button: mapButtons) {\n+                button.setPreviewSize(buttonSize);\n+            }\n+        }\n+        splGroundMap.setDividerLocation(getDividerLocation());\n+\n+        panMapButtons.add(Box.createVerticalGlue());\n+        panMapButtons.setVisible(true);\n+\n+        lblBoardsAvailable.setText(mapSettings.getBoardWidth() + \"x\" + mapSettings.getBoardHeight() + \" \"\n+                + Messages.getString(\"BoardSelectionDialog.mapsAvailable\"));\n+        comMapSizes.removeActionListener(lobbyListener);\n+        int items = comMapSizes.getItemCount();\n+\n+        boolean mapSizeSelected = false;\n+        for (int i = 0; i < (items - 1); i++) {\n+            BoardDimensions size = (BoardDimensions) comMapSizes.getItemAt(i);\n+\n+            if ((size.width() == mapSettings.getBoardWidth()) && (size.height() == mapSettings.getBoardHeight())) {\n+                comMapSizes.setSelectedIndex(i);\n+                mapSizeSelected = true;\n+            }\n+        }\n+        // If we didn't select a size, select the last item: 'Custom Size'\n+        if (!mapSizeSelected) {\n+            comMapSizes.setSelectedIndex(items - 1);\n+        }\n+        comMapSizes.addActionListener(lobbyListener);\n+\n+    }\n+    \n+    private void markServerSideBoard(BufferedImage image) {\n+        Graphics g = image.getGraphics();\n+        GUIPreferences.AntiAliasifSet(g);\n+        int w = image.getWidth();\n+        int h = image.getHeight();\n+        String text = \"Server-side board\";\n+        int fontSize = Math.min(w / 10, UIUtil.scaleForGUI(16));\n+        g.setFont(new Font(\"Dialog\", Font.ITALIC, fontSize));\n+        FontMetrics fm = g.getFontMetrics(g.getFont());\n+        int cx = (w - fm.stringWidth(text)) / 2;\n+        int cy = h / 10 + fm.getAscent();\n+        g.setColor(GUIPreferences.getInstance().getWarningColor());\n+        g.drawString(text, cx, cy);\n+        g.dispose();\n+    }\n+\n+    public void previewGameBoard() {\n+        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);\n+        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];\n+        List<Boolean> rotateBoard = new ArrayList<>();\n+        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings.getMapHeight()); i++) {\n+            sheetBoards[i] = new Board();\n+            String name = mapSettings.getBoardsSelectedVector().get(i);\n+            if (name.startsWith(MapSettings.BOARD_GENERATED) \n+                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);\n+            } else {\n+                if (name.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                    List<String> boardList = extractSurpriseMaps(name);\n+                    int rnd = (int)(Math.random() * boardList.size());\n+                    name = boardList.get(rnd);\n+                }\n+                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name + \".board\").getFile());\n+            }\n+        }\n+\n+        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(), mapSettings.getMapWidth(),\n+                mapSettings.getMapHeight(), sheetBoards, rotateBoard, mapSettings.getMedium());\n+        \n+        boardPreviewGame.setBoard(newBoard);\n+        boardPreviewW.setVisible(true);\n+    }\n+\n+    /**\n+     * Refreshes the game settings with new info from the client\n+     */\n+    private void refreshGameSettings() {\n+        refreshTeams();\n+        refreshDoneButton();\n+    }\n+    \n+    /**\n+     * Refreshes the Mek Table contents \n+     */\n+    public void refreshEntities() {\n+        refreshTree();\n+        refreshMekTable();\n+    }\n+    \n+    private void refreshMekTable() {\n+        List<Integer> enIds = getSelectedEntities().stream().map(e -> e.getId()).collect(toList());\n+        mekModel.clearData();\n+        ArrayList<Entity> allEntities = new ArrayList<Entity>(clientgui.getClient().getEntitiesVector());\n+        Collections.sort(allEntities, activeSorter);\n+\n+        boolean localUnits = false;\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        for (Entity entity : allEntities) {\n+            // Remember if the local player has units.\n+            if (!localUnits && entity.getOwner().equals(localPlayer())) {\n+                localUnits = true;\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_PILOT_ADVANTAGES)) { \n+                entity.getCrew().clearOptions(PilotOptions.LVL3_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.EDGE)) { \n+                entity.getCrew().clearOptions(PilotOptions.EDGE_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_MANEI_DOMINI)) { \n+                entity.getCrew().clearOptions(PilotOptions.MD_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS)) { \n+                entity.clearPartialRepairs();\n+            }\n+            \n+            // Remove some deployment options when a unit is carried\n+            if (entity.getTransportId() != Entity.NONE) { \n+                entity.setHidden(false);\n+                entity.setProne(false);\n+                entity.setHullDown(false);\n+            }\n+            \n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) { \n+                entity.setHidden(false);\n+            }\n+            \n+            // Handle the \"Blind Drop\" option. In blind drop, units must be added\n+            // but they will be obscured in the table. In real blind drop, units\n+            // don't even get added to the table. Teams see their units in any case.\n+            boolean localUnit = entity.getOwner().equals(localPlayer());\n+            boolean teamUnit = !entity.getOwner().isEnemyOf(localPlayer());\n+            boolean realBlindDrop = opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+            if (localUnit || teamUnit || !realBlindDrop) {\n+                mekModel.addUnit(entity);\n+            }\n+        }\n+        // Restore selection\n+        if (!enIds.isEmpty()) {\n+            for (int i = 0; i < mekTable.getRowCount(); i++) {\n+                if (enIds.contains(mekModel.getEntityAt(i).getId())) {\n+                    mekTable.addRowSelectionInterval(i, i);\n+                }\n+            }\n+        }\n+\n+        // Enable the \"Save Unit List...\" button if the local player has units.\n+        clientgui.getMenuBar().setUnitList(localUnits);\n+    }\n+    \n+    /** Adjusts the mektable to compact/normal mode. */\n+    private void toggleCompact() {\n+        setTableRowHeights();\n+        mekModel.refreshCells();\n+        mekForceTreeModel.nodeChanged((TreeNode)mekForceTreeModel.getRoot());\n+        \n+    }\n+\n+    /** Refreshes the player info table. */\n+    private void refreshPlayerTable() {\n+        // Remember the selected players\n+        var selPlayerIds = getselectedPlayers().stream().map(IPlayer::getId).collect(toSet());\n+\n+        // Empty and refill the player table\n+        playerModel.replaceData(game().getPlayersVector());\n+\n+        // re-select the previously selected players, if possible\n+        for (int row = 0; row < playerModel.getRowCount(); row++) {\n+            if (selPlayerIds.contains(playerModel.getPlayerAt(row).getId())) {\n+                tablePlayers.addRowSelectionInterval(row, row);\n+            }\n+        }\n+    }\n+\n+    /** Updates the camo button to displays the camo of the currently selected player. */ \n+    private void refreshCamoButton() {\n+        if ((tablePlayers == null) || (playerModel == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (player != null) {\n+            butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        }\n+    }\n+\n+    /** Sets up the team choice box. */\n+    private void setupTeamCombo() {\n+        for (int i = 0; i < IPlayer.MAX_TEAMS; i++) {\n+            comboTeam.addItem(IPlayer.teamNames[i]);\n+        }\n+    }\n+\n+    /** Updates the team choice combobox to show the selected player's team. */\n+    private void refreshTeams() {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(localPlayer().getTeam());\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the Done button. The label will say the opposite of the\n+     * player's \"done\" status, indicating that clicking it will reverse the\n+     * condition.\n+     */\n+    private void refreshDoneButton(boolean done) {\n+        butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n+    }\n+\n+    /** Refreshes the state of the Done button with the state of the local player. */\n+    private void refreshDoneButton() {\n+        refreshDoneButton(localPlayer().isDone());\n+    }\n+\n+    /**\n+     * Embarks the given carried Entity onto the carrier given as carrierId.\n+     */\n+    void loadOnto(Entity carried, int carrierId, int bayNumber) {\n+        Entity carrier = game().getEntity(carrierId);\n+        if (carrier == null || !isLoadable(carried, carrier)) {\n+            return;\n+        }\n+\n+        // We need to make sure our current bomb choices fit onto the new\n+        // fighter\n+        if (carrier instanceof FighterSquadron) {\n+            FighterSquadron fSquad = (FighterSquadron) carrier;\n+            // We can't use Aero.getBombPoints() because the bombs haven't been\n+            // loaded yet, only selected, so we have to count the choices\n+            int[] bombChoice = fSquad.getBombChoices();\n+            int numLoadedBombs = 0;\n+            for (int i = 0; i < bombChoice.length; i++) {\n+                numLoadedBombs += bombChoice[i];\n+            }\n+            // We can't load all of the squadrons bombs\n+            if (numLoadedBombs > ((IBomber)carried).getMaxBombPoints()) {\n+                JOptionPane.showMessageDialog(clientgui.frame, Messages.getString(\"FighterSquadron.bomberror\"),\n+                        Messages.getString(\"FighterSquadron.error\"), JOptionPane.ERROR_MESSAGE);\n+                return;\n+            }\n+        }\n+        \n+        getLocalClient(carried).sendLoadEntity(carried.getId(), carrierId, bayNumber);\n+        // TODO: it would probably be a good idea \n+        // to disable some settings for loaded units in customMechDialog\n+    }\n+\n+    /** \n+     * Have the given entity disembark if it is carried by another unit.\n+     * Entities that are modified and need an update to be sent to the server\n+     * are added to the given updateCandidates. \n+     */\n+    void disembark(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = game().getEntity(entity.getTransportId());\n+        if (carrier != null) {\n+            carrier.unload(entity);\n+            entity.setTransportId(Entity.NONE);\n+            updateCandidates.add(entity);\n+            updateCandidates.add(carrier);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity disembark if it is carried by a unit of another player.\n+     * Entities that were modified and need an update to be sent to the server\n+     * are added to the given updateCandidate set. \n+     */\n+    void disembarkDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = clientgui.getClient().getGame().getEntity(entity.getTransportId());\n+        if (carrier != null && (ownerOf(entity) != ownerOf(carrier))) {\n+            disembark(entity, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entities offload all the units they are carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadAll(Collection<Entity> entities, Collection<Entity> updateCandidates) {\n+        for (Entity carrier: editableEntities(entities)) {\n+            offloadFrom(carrier, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all the units it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFrom(Entity entity, Collection<Entity> updateCandidates) {\n+        if (isEditable(entity)) {\n+            for (Entity carriedUnit: entity.getLoadedUnits()) {\n+                disembark(carriedUnit, updateCandidates);\n+            } \n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all units of different players it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFromDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        for (Entity carriedUnit: entity.getLoadedUnits()) {\n+            if (ownerOf(carriedUnit) != ownerOf(entity)) {\n+                disembark(carriedUnit, updateCandidates);\n+            }\n+        } \n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. \n+     */\n+    void sendUpdate(Collection<Entity> updateCandidates) {\n+        for (Entity e: editableEntities(updateCandidates)) {\n+            getLocalClient(e).sendUpdateEntity(e);\n+        }\n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. Will separate the units into update\n+     * packets for the local player and any local bots so that the \n+     * server accepts all changes (as the server does not know of\n+     * local bots and rejects updates that are not for the sending client\n+     * or its teammates. \n+     */\n+    void sendUpdates(Collection<Entity> entities) {\n+        List<IPlayer> owners = entities.stream().map(e -> e.getOwner()).distinct().collect(toList());\n+        for (IPlayer owner: owners) {\n+            client().sendUpdateEntity(new ArrayList<Entity>(\n+                    entities.stream().filter(e -> e.getOwner().equals(owner)).collect(toList())));\n+        }\n+    }\n+    \n+    /** \n+     * Disembarks all given entities from any transports they are in. \n+     */\n+    void disembarkAll(Collection<Entity> entities) {\n+        Set<Entity> updateCandidates = new HashSet<>();\n+        entities.stream().filter(e -> isEditable(e)).forEach(e -> disembark(e, updateCandidates));\n+        sendUpdate(updateCandidates);\n+    }\n+\n+    /** \n+     * Returns true when the given entity may be configured by the local player,\n+     * i.e. if it is his own unit or one of his bot's units.\n+     * <P>Note that this is more restrictive than the Server is. The Server\n+     * accepts entity changes also for teammates so that entity updates that \n+     * signal transporting a teammate's unit don't get rejected. I feel that\n+     * configuration other than transporting units should be limited to one's\n+     * own units (and bots) though.\n+     */\n+    boolean isEditable(Entity entity) {\n+        return clientgui.getBots().containsKey(entity.getOwner().getName())\n+                || (entity.getOwnerId() == localPlayer().getId());\n+    }\n+    \n+    /** \n+     * Returns true when the given entity may NOT be configured by the local player,\n+     * i.e. if it is not own unit or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isNotEditable(Entity entity) {\n+        return !isEditable(entity);\n+    }\n+    \n+    /** \n+     * Returns true when all given entities may be configured by the local player,\n+     * i.e. if they are his own units or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isEditable(Collection<Entity> entities) {\n+        return !entities.stream().anyMatch(this::isNotEditable);\n+    }\n+    \n+    /** \n+     * Returns the Client associated with a given entity that may be configured\n+     * by the local player (his own unit or one of his bot's units).\n+     * For a unit that cannot be configured (owned by a remote player) the client\n+     * of the local player is returned.\n+     */\n+    Client getLocalClient(Entity entity) {\n+        if (clientgui.getBots().containsKey(entity.getOwner().getName())) {\n+            return clientgui.getBots().get(entity.getOwner().getName());\n+        } else {\n+            return clientgui.getClient();\n+        }\n+    }\n+\n+    public void configPlayer() {\n+        Client c = getSelectedClient();\n+        if (null == c) {\n+            return;\n+        }\n+        \n+        PlayerSettingsDialog psd = new PlayerSettingsDialog(clientgui, c);\n+        boolean okay = psd.showDialog();\n+        \n+        if (okay) {\n+            IPlayer player = c.getLocalPlayer();\n+            player.setConstantInitBonus(psd.getInit());\n+            player.setNbrMFConventional(psd.getCnvMines());\n+            player.setNbrMFVibra(psd.getVibMines());\n+            player.setNbrMFActive(psd.getActMines());\n+            player.setNbrMFInferno(psd.getInfMines());\n+            var rsg = c.getRandomSkillsGenerator();\n+            rsg.setMethod(psd.getMethod());\n+            rsg.setType(psd.getPilot());\n+            rsg.setLevel(psd.getXP());\n+            rsg.setClose(psd.getForceGP());\n+            \n+            // The deployment position\n+            int startPos = psd.getStartPos();\n+            final GameOptions gOpts = clientgui.getClient().getGame().getOptions();\n+            if (gOpts.booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                    && (startPos >= 1) && (startPos <= 9)) {\n+                startPos += 10;\n+            }\n+            c.getLocalPlayer().setStartingPos(startPos);\n+            c.sendPlayerInfo();\n+            \n+            // If the gameoption set_arty_player_homeedge is set, adjust the player's offboard \n+            // arty units to be behind the newly selected home edge.\n+            OffBoardDirection direction = OffBoardDirection.translateStartPosition(startPos);\n+            if (direction != OffBoardDirection.NONE && \n+                    gOpts.booleanOption(OptionsConstants.BASE_SET_ARTY_PLAYER_HOMEEDGE)) {\n+                for (Entity entity: c.getGame().getPlayerEntities(c.getLocalPlayer(), false)) {\n+                    if (entity.getOffBoardDirection() != OffBoardDirection.NONE) {\n+                        entity.setOffBoard(entity.getOffBoardDistance(), direction);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    \n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechReadoutAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechReadout(entity, index++);\n+        }\n+    } \n+\n+    /** \n+     * Shows the unit summary for the given unit. Moves the dialog a bit depending on index\n+     * so that multiple dialogs dont appear exactly on top of each other. \n+     */\n+    private void mechReadout(Entity entity, int index) {\n+        final ClientDialog dialog = new ClientDialog(clientgui.frame, Messages.getString(\"ChatLounge.quickView\"), false, true);\n+        final int height = 600;\n+        final int width = 500;\n+\n+        MechView mv = new MechView(entity, false);\n+        // The label must want a fixed width to enforce linebreaks on fluff text\n+        JLabel mechSummary = new JLabel(\"<HTML>\" + mv.getMechReadoutHead()\n+        + mv.getMechReadoutBasic() + mv.getMechReadoutLoadout()\n+        + mv.getMechReadoutFluff()) {\n+            private static final long serialVersionUID = 2989361635430008853L;\n+            @Override\n+            public Dimension getPreferredSize() {\n+                return new Dimension(width - 10, super.getPreferredSize().height);\n+            }\n+        };\n+        mechSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(mechSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.center();\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechBVAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechBVDisplay(entity, index++);\n+        }\n+    } \n+    \n+    /**\n+     * @param entity the entity to display the BV Calculation for\n+     */\n+    void mechBVDisplay(Entity entity, int index) {\n+        final JDialog dialog = new ClientDialog(clientgui.frame, \"BV Calculation Display\", false, true);\n+        final int height = 600;\n+        \n+        entity.calculateBattleValue();\n+        JLabel bvSummary = new JLabel(entity.getBVText());\n+        bvSummary.setFont(new Font(\"Dialog\",Font.PLAIN, scaleForGUI(14)));\n+        bvSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(bvSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(bvSummary.getPreferredSize().width + 40, scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /**\n+     * Pop up the dialog to load a mech\n+     */\n+    private void addUnit() {\n+        clientgui.getMechSelectorDialog().updateOptionValues();\n+        clientgui.getMechSelectorDialog().setVisible(true);\n+    }\n+    \n+    private void createArmy() {\n+        clientgui.getRandomArmyDialog().setVisible(true);\n+    }\n+\n+    public void loadRandomSkills() {\n+        clientgui.getRandomSkillDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    public void loadRandomNames() {\n+        clientgui.getRandomNameDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    void changeMapDnD(String board, JButton button) {\n+        if (board.contains(\"\\n\")) {\n+            board = MapSettings.BOARD_SURPRISE + board;\n+        }\n+        mapSettings.getBoardsSelectedVector().set(mapButtons.indexOf(button), board);\n+        clientgui.getClient().sendMapSettings(mapSettings);\n+        if (boardPreviewW.isVisible()) {\n+            previewGameBoard();\n+        }\n+    }\n+    \n+    \n+\n+    //\n+    // GameListener\n+    //\n+    @Override\n+    public void gamePlayerChange(GamePlayerChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshDoneButton();\n+        clientgui.getClient().getGame().setupTeams();\n+        refreshPlayerTable();\n+        refreshPlayerConfig();\n+        refreshCamoButton();\n+        refreshEntities();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gamePhaseChange(GamePhaseChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        \n+        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {\n+            refreshDoneButton();\n+            refreshGameSettings();\n+            refreshPlayerTable();\n+            refreshTeams();\n+            refreshCamoButton();\n+            refreshEntities();\n+            panTeamOverview.refreshData();\n+        }\n+    }\n+\n+    @Override\n+    public void gameEntityNew(GameEntityNewEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameSettingsChange(GameSettingsChangeEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshGameSettings();\n+        // The table sorting may no longer be allowed (e.g. when blind drop was activated)\n+        if (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())) {\n+            nextSorter(unitSorters);\n+            updateTableHeaders();\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        refreshMapSizes();\n+        updateMapSettings(clientgui.getClient().getMapSettings());\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameClientFeedbackRequest(GameCFREvent evt) {\n+        // Do nothing\n+    }\n+\n+    \n+    private ActionListener lobbyListener = new ActionListener() {\n+\n+        @Override\n+        public void actionPerformed(ActionEvent ev) {\n+\n+            // Are we ignoring events?\n+            if (isIgnoringEvents()) {\n+                return;\n+            }\n+            \n+            if (ev.getSource().equals(butAdd)) {\n+                addUnit();\n+                \n+            } else if (ev.getSource().equals(butArmy)) {\n+                createArmy();\n+                \n+            } else if (ev.getSource().equals(butSkills)) {\n+                loadRandomSkills();\n+                \n+            } else if (ev.getSource().equals(butNames)) {\n+                loadRandomNames();\n+                \n+            } else if (ev.getSource().equals(tablePlayers)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(comboTeam)) {\n+                lobbyActions.changeTeam(getselectedPlayers(), comboTeam.getSelectedIndex());\n+                \n+            } else if (ev.getSource().equals(butConfigPlayer)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(butBotSettings)) {\n+                doBotSettings();\n+                \n+            } else if (ev.getSource().equals(butOptions)) {\n+                // Make sure the game options dialog is editable.\n+                if (!clientgui.getGameOptionsDialog().isEditable()) {\n+                    clientgui.getGameOptionsDialog().setEditable(true);\n+                }\n+                // Display the game options dialog.\n+                clientgui.getGameOptionsDialog().update(clientgui.getClient().getGame().getOptions());\n+                clientgui.getGameOptionsDialog().setVisible(true);\n+                \n+            } else if (ev.getSource().equals(butCompact)) {\n+                toggleCompact();\n+                \n+            } else if (ev.getSource().equals(butLoadList)) {\n+                // Allow the player to replace their current\n+                // list of entities with a list from a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));  //$NON-NLS-2$\n+                    return;\n+                }\n+                clientgui.loadListFile(c.getLocalPlayer());\n+                \n+            } else if (ev.getSource().equals(butSaveList)) {\n+                // Allow the player to save their current\n+                // list of entities to a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));\n+                    return;\n+                }\n+                clientgui.saveListFile(c.getGame().getPlayerEntities(c.getLocalPlayer(), false),\n+                        c.getLocalPlayer().getName());\n+                \n+            } else if (ev.getSource().equals(butAddBot)) {\n+                BotConfigDialog bcd = new BotConfigDialog(clientgui.frame);\n+                bcd.setVisible(true);\n+                if (bcd.dialogAborted) {\n+                    return; // user didn't click 'ok', add no bot\n+                }\n+                if (clientgui.getBots().containsKey(bcd.getBotName())) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertExistsBot.title\"),\n+                            Messages.getString(\"ChatLounge.AlertExistsBot.message\"));  //$NON-NLS-2$\n+                } else {\n+                    BotClient c = bcd.getSelectedBot(clientgui.getClient().getHost(), clientgui.getClient().getPort());\n+                    c.setClientGUI(clientgui);\n+                    c.getGame().addGameListener(new BotGUI(c));\n+                    try {\n+                        c.connect();\n+                    } catch (Exception e) {\n+                        clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertBot.title\"),\n+                                Messages.getString(\"ChatLounge.AlertBot.message\"));  //$NON-NLS-2$\n+                    }\n+                    clientgui.getBots().put(bcd.getBotName(), c);\n+                }\n+                \n+            } else if (ev.getSource().equals(butRemoveBot)) {\n+                removeBot();\n+                \n+            } else if (ev.getSource().equals(butShowUnitID)) {\n+                PreferenceManager.getClientPreferences().setShowUnitId(butShowUnitID.isSelected());\n+                mekModel.refreshCells();\n+                repaint();\n+                \n+            } else if (ev.getSource() == butConditions) {\n+                PlanetaryConditionsDialog pcd = new PlanetaryConditionsDialog(clientgui);\n+                boolean userOkay = pcd.showDialog();\n+                if (userOkay) {\n+                    clientgui.getClient().sendPlanetaryConditions(pcd.getConditions());\n+                }\n+                \n+            } else if (ev.getSource() == butRandomMap) {\n+                RandomMapDialog rmd = new RandomMapDialog(clientgui.frame, ChatLounge.this, clientgui.getClient(), mapSettings);\n+                rmd.activateDialog(clientgui.getBoardView().getTilesetManager().getThemes());\n+                \n+            } else if (ev.getSource().equals(butBoardPreview)) {\n+                previewGameBoard();\n+                \n+            } else if (ev.getSource().equals(comMapSizes)) {\n+                if (comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"))) {\n+                    refreshMapUI();\n+                } else if (comMapSizes.getSelectedItem() != null) {\n+                    BoardDimensions size = (BoardDimensions) comMapSizes.getSelectedItem();\n+                    mapSettings.setBoardSize(size.width(), size.height());\n+                    resetAvailBoardSelection = true;\n+                    resetSelectedBoards = true;\n+                    clientgui.getClient().sendMapSettings(mapSettings);\n+                } \n+                \n+            } else if (ev.getSource() == butGroundMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_GROUND);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butSpaceMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_SPACE);\n+                mapSettings.setBoardSize(50, 50);\n+                mapSettings.setMapSize(1, 1);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butLowAtmoMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_ATMOSPHERE);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddX || ev.getSource() == butMapGrowW) {\n+                int newMapWidth = mapSettings.getMapWidth() + 1;\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddY || ev.getSource() == butMapGrowH) {\n+                int newMapHeight = mapSettings.getMapHeight() + 1;\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butSaveMapSetup) {\n+                saveMapSetup();\n+                \n+            } else if (ev.getSource() == butLoadMapSetup) {\n+                loadMapSetup();\n+                \n+            } else if (ev.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+                \n+            } else if (ev.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+                \n+            } else if (ev.getSource() == butMapShrinkW) {\n+                if (mapSettings.getMapWidth() > 1) {\n+                    int newMapWidth = mapSettings.getMapWidth() - 1;\n+                    mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butMapShrinkH) {\n+                if (mapSettings.getMapHeight() > 1) {\n+                    int newMapHeight = mapSettings.getMapHeight() - 1;\n+                    mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butDetach) {\n+                butDetach.setEnabled(false);\n+                panTeam.remove(panTeamOverview);\n+                panTeam.repaint();\n+                panTeamOverview.setDetached(true);\n+                teamOverviewWindow.add(panTeamOverview);\n+                teamOverviewWindow.center();\n+                teamOverviewWindow.setVisible(true);\n+                \n+            } else if (ev.getSource() == butCancelSearch) {\n+                fldSearch.setText(\"\");\n+\n+            } else if (ev.getSource() == butHelp) {\n+                File helpfile = new File(\"docs/Boards Stuff/MapAssemblyHelp.html\");\n+                final JDialog dialog = new ClientDialog(clientgui.frame, \"Map Assembly Help\", true, true);\n+                final int height = 600;\n+                final int width = 600;\n+                \n+                final JEditorPane pane = new JEditorPane();\n+                pane.setName(\"helpPane\");\n+                pane.setEditable(false);\n+                pane.setFont(new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1)));\n+                try {\n+                    pane.setPage(helpfile.toURI().toURL());\n+                    JScrollPane tScroll = new JScrollPane(pane,\n+                            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+                    tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+                    dialog.add(tScroll, BorderLayout.CENTER);\n+                } catch (Exception e) {\n+                    dialog.setTitle(Messages.getString(\"AbstractHelpDialog.noHelp.title\"));\n+                    pane.setText(Messages.getString(\"AbstractHelpDialog.errorReading\") + e.getMessage());\n+                    MegaMek.getLogger().error(e);\n+                }\n+\n+                JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+                button.addActionListener(e -> dialog.setVisible(false));\n+                JPanel okayPanel = new JPanel(new FlowLayout());\n+                okayPanel.add(button);\n+                dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+                Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+                dialog.setPreferredSize(sz);\n+                dialog.setVisible(true);\n+                \n+            } else if (ev.getSource() == butListView) {\n+                scrMekTable.setViewportView(mekTable);\n+                butCollapse.setEnabled(false);\n+                butExpand.setEnabled(false);\n+                \n+            } else if (ev.getSource() == butForceView) {\n+                scrMekTable.setViewportView(mekForceTree);\n+                butCollapse.setEnabled(true);\n+                butExpand.setEnabled(true);\n+                \n+            } else if (ev.getSource() == butCollapse) {\n+                collapseTree();\n+            } else if (ev.getSource() == butExpand) {\n+                expandTree();\n+            } \n+        }\n+    };\n+    \n+    /** Expands the Mek Force Tree fully. */\n+    private void expandTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.expandRow(i);\n+        }\n+    }\n+    \n+    /** Collapses the Mek Force Tree fully. */\n+    private void collapseTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.collapseRow(i);\n+        }\n+    }\n+    \n+    \n+    /** \n+     * Opens a file chooser and saves the current map setup to the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void saveMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.saveMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showSaveDialog(clientgui.frame);\n+        File selectedFile = fc.getSelectedFile();\n+        if (!selectedFile.getName().toLowerCase().endsWith(\".xml\")) {\n+            selectedFile = new File(selectedFile.getPath() + \".xml\");\n+        }\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (selectedFile == null)) {\n+            return;\n+        }\n+        if (selectedFile.exists()) {\n+            String msg = Messages.getString(\"ChatLounge.map.saveMapSetupReplace\", selectedFile.getName());\n+            if (!MMConfirmDialog.confirm(clientgui.frame, \"Confirm replace\", msg)) {\n+                return;\n+            }\n+        }\n+        try(OutputStream os = new FileOutputStream(selectedFile)) {\n+            MapSetup.save(os, mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while saving the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+\n+    /** \n+     * Opens a file chooser and loads a new map setup from the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void loadMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showOpenDialog(clientgui.frame);\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (fc.getSelectedFile() == null)) {\n+            return;\n+        }\n+        if (!fc.getSelectedFile().exists()) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \"File not found.\");\n+            return;\n+        }\n+        try(InputStream os = new FileInputStream(fc.getSelectedFile())) {\n+            MapSetup setup = MapSetup.load(os);\n+            mapSettings.setMapSize(setup.getMapWidth(), setup.getMapHeight());\n+            mapSettings.setBoardSize(setup.getBoardWidth(), setup.getBoardHeight());\n+            mapSettings.setBoardsSelectedVector(setup.getBoards());\n+            clientgui.getClient().sendMapSettings(mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while loading the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+    \n+    private void removeBot() {\n+        Client c = getSelectedClient();\n+        if (!client().bots.containsValue(c)) {\n+//        if ((c == null) || c.equals(clientgui.getClient())) {\n+//            clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+//                    Messages.getString(\"ChatLounge.SelectBo\"));\n+            LobbyErrors.showOnlyOwnBot(clientgui.frame);\n+            return;\n+        }\n+        // Delete units first, which safely disembarks and offloads them\n+        // Don't delete the bot's forces, as that could also delete other players' entitites\n+//        lobbyActions.delete(new ArrayList<>(), game().getPlayerEntities(c.getLocalPlayer(), false), false);\n+        c.die();\n+        clientgui.getBots().remove(c.getName());\n+    }\n+    \n+    private void doBotSettings() {\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        BotClient bot = (BotClient) clientgui.getBots().get(player.getName());\n+        BotConfigDialog bcd = new BotConfigDialog(clientgui.frame, bot);\n+        bcd.setVisible(true);\n+\n+        if (bcd.dialogAborted) {\n+            return; // user didn't click 'ok', add no bot\n+        } else if (bot instanceof Princess) {\n+            ((Princess) bot).setBehaviorSettings(bcd.getBehaviorSettings());\n+            \n+            // bookkeeping:\n+            clientgui.getBots().remove(player.getName());\n+            bot.setName(bcd.getBotName());\n+            clientgui.getBots().put(bot.getName(), bot);\n+            player.setName(bcd.getBotName());\n+            clientgui.chatlounge.refreshPlayerTable();\n+        }\n+    }\n+    \n+    // Put a filter on the files that the user can select the proper file.\n+    FileFilter XMLFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return (f.getPath().toLowerCase().endsWith(\".xml\") || f.isDirectory());\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Map Setup XML files\";\n+        }\n+    };\n+    \n+    private void setManualMapWidth() {\n+        try {\n+            int newMapWidth = Integer.parseInt(fldMapWidth.getText());\n+            if (newMapWidth >= 1 && newMapWidth <= 20) {\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map width\n+        }\n+    }\n+    \n+    private void setManualMapHeight() {\n+        try {\n+            int newMapHeight = Integer.parseInt(fldMapHeight.getText());\n+            if (newMapHeight >= 1 && newMapHeight <= 20) {\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map height\n+        }\n+    }\n+    \n+    private void setManualBoardWidth() {\n+        try {\n+            int newBoardWidth = Integer.parseInt(fldSpaceBoardWidth.getText());\n+            if (newBoardWidth >= 5 && newBoardWidth <= 200) {\n+                mapSettings.setBoardSize(newBoardWidth, mapSettings.getBoardHeight());\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board width\n+        }\n+    }\n+    \n+    private void setManualBoardHeight() {\n+        try {\n+            int newBoardHeight = Integer.parseInt(fldSpaceBoardHeight.getText());\n+            if (newBoardHeight >= 5 && newBoardHeight <= 200) {\n+                mapSettings.setBoardSize(mapSettings.getBoardWidth(), newBoardHeight);\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board height\n+        }\n+    }\n+\n+    /**\n+     * Updates to show the map settings that have, presumably, just been sent by\n+     * the server.\n+     */\n+    @Override\n+    public void updateMapSettings(MapSettings newSettings) {\n+        mapSettings = MapSettings.getInstance(newSettings);\n+        refreshMapButtons();\n+        refreshMapChoice();\n+        refreshMapUI();\n+        refreshBoardsAvailable();\n+        updateSearch(fldSearch.getText());\n+        refreshLabels();\n+    }\n+\n+\n+    /**OK Refreshes the Map Summary, Tech Level and Game Year labels. */\n+    private void refreshLabels() {\n+        Font scaledFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1));\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        String txt = Messages.getString(\"ChatLounge.GameYear\"); \n+        txt += opts.intOption(OptionsConstants.ALLOWED_YEAR);\n+        lblGameYear.setText(txt);\n+        lblGameYear.setFont(scaledFont);\n+        lblGameYear.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\"))); \n+        \n+        String tlString = TechConstants.getLevelDisplayableName(TechConstants.T_TECH_UNKNOWN);\n+        IOption tlOpt = opts.getOption(OptionsConstants.ALLOWED_TECHLEVEL);\n+        if (tlOpt != null) {\n+            tlString = tlOpt.stringValue();\n+        }\n+        lblTechLevel.setText(Messages.getString(\"ChatLounge.TechLevel\") + tlString);\n+        lblTechLevel.setFont(scaledFont);\n+        lblTechLevel.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\")));\n+        \n+        txt = Messages.getString(\"ChatLounge.MapSummary\"); \n+        txt += (mapSettings.getBoardWidth() * mapSettings.getMapWidth()) + \" x \" \n+                + (mapSettings.getBoardHeight() * mapSettings.getMapHeight());\n+        if (butGroundMap.isSelected()) {\n+            txt += \" Ground Map\";\n+        } else if (butLowAtmoMap.isSelected()) {\n+            txt += \" Atmospheric Map\";\n+        } else {\n+            txt += \" Space Map\";\n+        }\n+        lblMapSummary.setText(txt);\n+        lblMapSummary.setFont(scaledFont);\n+\n+        StringBuilder selectedMaps = new StringBuilder();\n+        selectedMaps.append(Messages.getString(\"ChatLounge.MapSummarySelectedMaps\"));\n+        for (String map: mapSettings.getBoardsSelectedVector()) {\n+            selectedMaps.append(\"&nbsp;&nbsp;\");\n+            if (map.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                selectedMaps.append(MapSettings.BOARD_SURPRISE);\n+            } else {\n+                selectedMaps.append(map);\n+            }\n+            selectedMaps.append(\"<br>\"); \n+        }\n+        lblMapSummary.setToolTipText(scaleStringForGUI(selectedMaps.toString()));\n+    }\n+    \n+    @Override\n+    public void ready() {\n+        final Client client = clientgui.getClient();\n+        final IGame game = client.getGame();\n+        final GameOptions gOpts = game.getOptions();\n+        \n+        // enforce exclusive deployment zones in double blind\n+        for (IPlayer player: client.getGame().getPlayersVector()) {\n+            if (!isValidStartPos(game, player)) {\n+                clientgui.doAlertDialog(Messages.getString(\"ChatLounge.OverlapDeploy.title\"), \n+                        Messages.getString(\"ChatLounge.OverlapDeploy.msg\"));\n+                return;\n+            }\n+        }\n+\n+        // Make sure player has a commander if Commander killed victory is on\n+        if (gOpts.booleanOption(OptionsConstants.VICTORY_COMMANDER_KILLED)) {\n+            List<String> players = new ArrayList<>();\n+            if ((game.getLiveCommandersOwnedBy(localPlayer()) < 1)\n+                    && (game.getEntitiesOwnedBy(localPlayer()) > 0)) {\n+                players.add(client.getLocalPlayer().getName());\n+            }\n+            for (Client bc : clientgui.getBots().values()) {\n+                if ((game.getLiveCommandersOwnedBy(bc.getLocalPlayer()) < 1)\n+                        && (game.getEntitiesOwnedBy(bc.getLocalPlayer()) > 0)) {\n+                    players.add(bc.getLocalPlayer().getName());\n+                }\n+            }\n+            if (players.size() > 0) {\n+                String title = Messages.getString(\"ChatLounge.noCmdr.title\"); \n+                String msg = Messages.getString(\"ChatLounge.noCmdr.msg\"); \n+                for (String player : players) {\n+                    msg += player + \"\\n\";\n+                }\n+                clientgui.doAlertDialog(title, msg);\n+                return;\n+            }\n+\n+        }\n+\n+        boolean done = !localPlayer().isDone();\n+        client.sendDone(done);\n+        refreshDoneButton(done);\n+        for (Client botClient : clientgui.getBots().values()) {\n+            botClient.sendDone(done);\n+        }\n+    }\n+\n+    Client getSelectedClient() {\n+        if ((tablePlayers == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return null;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (localPlayer().equals(player)) {\n+            return client();\n+        } else if (client().bots.containsKey(player.getName())) {\n+            return client().bots.get(player.getName());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Stop just ignoring events and actually stop listening to them.\n+     */\n+    @Override\n+    public void removeAllListeners() {\n+        clientgui.getClient().getGame().removeGameListener(this);\n+        clientgui.getBoardView().removeBoardViewListener(this);\n+        GUIPreferences.getInstance().removePreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().removePreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().removeListener(mechSummaryCacheListener);\n+        \n+        if (loader != null) {\n+            loader.cancel(true);\n+        }\n+        \n+        tablePlayers.getSelectionModel().removeListSelectionListener(this);\n+        tablePlayers.removeMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        lisBoardsAvailable.removeMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.removeWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.removeMouseListener(mekTableMouseAdapter);\n+        mekForceTree.removeMouseListener(mekForceTreeMouseListener);\n+        mekTable.getTableHeader().removeMouseListener(mekTableHeaderMouseListener);\n+        mekTable.removeKeyListener(mekTableKeyListener);\n+        mekForceTree.removeKeyListener(mekTreeKeyListener);\n+        \n+        butAdd.removeActionListener(lobbyListener);\n+        butAddBot.removeActionListener(lobbyListener);\n+        butArmy.removeActionListener(lobbyListener);\n+        butBoardPreview.removeActionListener(lobbyListener);\n+        butBotSettings.removeActionListener(lobbyListener);\n+        butCompact.removeActionListener(lobbyListener);\n+        butConditions.removeActionListener(lobbyListener);\n+        butConfigPlayer.removeActionListener(lobbyListener);\n+        butLoadList.removeActionListener(lobbyListener);\n+        butNames.removeActionListener(lobbyListener);\n+        butOptions.removeActionListener(lobbyListener);\n+        butRandomMap.removeActionListener(lobbyListener);\n+        butRemoveBot.removeActionListener(lobbyListener);\n+        butSaveList.removeActionListener(lobbyListener);\n+        butShowUnitID.removeActionListener(lobbyListener);\n+        butSkills.removeActionListener(lobbyListener);\n+        butSpaceSize.removeActionListener(lobbyListener);\n+        butCamo.removeActionListener(camoListener);\n+        butAddX.removeActionListener(lobbyListener);\n+        butAddY.removeActionListener(lobbyListener);\n+        butMapGrowW.removeActionListener(lobbyListener);\n+        butMapShrinkW.removeActionListener(lobbyListener);\n+        butMapGrowH.removeActionListener(lobbyListener);\n+        butMapShrinkH.removeActionListener(lobbyListener);\n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        butLoadMapSetup.removeActionListener(lobbyListener);\n+        butSaveMapSetup.removeActionListener(lobbyListener);\n+        butDetach.removeActionListener(lobbyListener);\n+        butCancelSearch.removeActionListener(lobbyListener);\n+        butHelp.removeActionListener(lobbyListener);\n+        butListView.removeActionListener(lobbyListener);\n+        butForceView.removeActionListener(lobbyListener);\n+        butCollapse.removeActionListener(lobbyListener);\n+        butExpand.removeActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        \n+        comboTeam.removeActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Returns true if the given list of entities can be configured as a group.\n+     * This requires that they all have the same owner, and that none of the\n+     * units are being transported. Also, the owner must be the player or one\n+     * of his bots. \n+     */\n+    boolean canConfigureMultipleDeployment(Collection<Entity> entities) {\n+        return haveSingleOwner(entities) \n+                && !containsTransportedUnit(entities)\n+                && canEditAny(entities);\n+    }\n+    \n+    /**\n+     * Returns true if the given collection contains at least one entity\n+     * that the local player can edit, i.e. is his own or belongs to\n+     * one of his bots. Does not check if the units are otherwise configured,\n+     * e.g. transported.\n+     * <P>See also {@link #isEditable(Entity)}\n+     */\n+    boolean canEditAny(Collection<Entity> entities) {\n+        return entities.stream().anyMatch(e -> isEditable(e));\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see all of the given entities.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not on his team.\n+     */\n+    boolean canSeeAll(Collection<Entity> entities) {\n+        if (!game().getOptions().booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                && !game().getOptions().booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP)) {\n+            return true;\n+        }\n+        for (Entity entity: entities) {\n+            if (!entityInLocalTeam(entity)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see the given entity.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not his own.\n+     */\n+    boolean canSee(Entity entity) {\n+        return canSeeAll(Arrays.asList(entity));\n+    }\n+    \n+    boolean entityInLocalTeam(Entity entity) {\n+        return !localPlayer().isEnemyOf(entity.getOwner());\n+    }\n+    \n+\n+    @Override\n+    public void valueChanged(ListSelectionEvent event) {\n+        if (event.getValueIsAdjusting()) {\n+            return;\n+        }\n+        \n+        if (event.getSource().equals(tablePlayers.getSelectionModel())) {\n+            refreshPlayerConfig();\n+        }\n+    }\n+    \n+    /** Adapts the enabled state of the player config UI items to the player selection. */\n+    private void refreshPlayerConfig() {\n+        var selPlayers = getselectedPlayers();\n+        var hasSelection = !selPlayers.isEmpty();\n+        var isSinglePlayer = selPlayers.size() == 1;\n+        var allConfigurable = hasSelection && selPlayers.stream().allMatch(lobbyActions::isSelfOrLocalBot);\n+        var isSingleLocalBot = isSinglePlayer && (getSelectedClient() instanceof BotClient);\n+        comboTeam.setEnabled(allConfigurable);\n+        butLoadList.setEnabled(allConfigurable && isSinglePlayer);\n+        butCamo.setEnabled(allConfigurable && isSinglePlayer);\n+        butConfigPlayer.setEnabled(allConfigurable && isSinglePlayer);\n+        refreshCamoButton();\n+        // Disable the Remove Bot button for the \"player\" of a \"Connect As Bot\" client\n+        butRemoveBot.setEnabled(isSingleLocalBot);\n+        butSaveList.setEnabled(false);\n+        if (isSinglePlayer) {\n+            var selPlayer = theElement(selPlayers);\n+            var hasUnits = !game().getPlayerEntities(selPlayer, false).isEmpty();\n+            butSaveList.setEnabled(hasUnits && unitsVisible(selPlayer));\n+            setTeamSelectedItem(selPlayer.getTeam());\n+        }\n+    }\n+    \n+    /** Sets (without firing events) the team combobox. */\n+    private void setTeamSelectedItem(int team) {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(team);\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+    \n+    /** \n+     * Returns false when any blind-drop option is active and player is not on the local team; \n+     * true otherwise. When true, individual units of the given player should not be shown/saved/etc. \n+     */ \n+    private boolean unitsVisible(IPlayer player) {\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        boolean isBlindDrop = opts.booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                || opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+        return !player.isEnemyOf(localPlayer()) || !isBlindDrop;\n+    }\n+\n+    public class PlayerTableMouseAdapter extends MouseInputAdapter {\n+\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                IPlayer player = playerModel.getPlayerAt(row);\n+                if (player != null) {\n+                    boolean isLocalPlayer = player.equals(localPlayer());\n+                    boolean isLocalBot = clientgui.getBots().get(player.getName()) != null;\n+                    if ((isLocalPlayer || isLocalBot)) {\n+                        configPlayer();\n+                    }\n+                }\n+            }\n+        }\n+        \n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected player,\n+                // clear the selection and select that entity instead\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                if (!tablePlayers.isRowSelected(row)) {\n+                    tablePlayers.changeSelection(row, row, false, false);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            ScalingPopup popup = PlayerTablePopup.playerTablePopup(clientgui, \n+                    playerTableActionListener, getselectedPlayers());\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    private ActionListener playerTableActionListener = new ActionListener() {\n+        \n+        @Override\n+        public void actionPerformed(ActionEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+        \n+            StringTokenizer st = new StringTokenizer(e.getActionCommand(), \"|\");\n+            String command = st.nextToken();\n+            switch (command) {\n+            case \"CONFIG\":\n+                configPlayer();\n+                break;\n+\n+            case \"TEAM\":\n+                int newTeam = Integer.parseInt(st.nextToken());\n+                lobbyActions.changeTeam(getselectedPlayers(), newTeam);\n+                break;\n+\n+            case \"BOTREMOVE\":\n+                removeBot();\n+                break;\n+\n+            case \"BOTSETTINGS\":\n+                doBotSettings();\n+                break;\n+                \n+            case \"DEPLOY\":\n+                int startPos = Integer.parseInt(st.nextToken());\n+                if (game().getOptions().booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                        && (startPos >= 1) && (startPos <= 9)) {\n+                    startPos += 10;\n+                }\n+                for (IPlayer player: getselectedPlayers()) {\n+                    if (lobbyActions.isSelfOrLocalBot(player)) {\n+                        if (client().isLocalBot(player)) {\n+                            // must use the bot's own player object:\n+                            client().getBotClient(player).getLocalPlayer().setStartingPos(startPos);\n+                            client().getBotClient(player).sendPlayerInfo();\n+                        } else {\n+                            player.setStartingPos(startPos);\n+                            client().sendPlayerInfo();\n+                        }\n+                    }\n+                }\n+                break;\n+                \n+            }\n+        }\n+    };\n+    \n+    \n+    private ArrayList<IPlayer> getselectedPlayers() {\n+        var result = new ArrayList<IPlayer>(); \n+        for (int row: tablePlayers.getSelectedRows()) {\n+            IPlayer player = playerModel.getPlayerAt(row);\n+            if (player != null) {\n+                result.add(player);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    KeyListener mekTableKeyListener = new KeyAdapter() {\n+\n+        @Override\n+        public void keyPressed(KeyEvent e) {\n+            if (mekTable.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            List<Entity> entities = getSelectedEntities();\n+            int code = e.getKeyCode();\n+            if ((code == KeyEvent.VK_DELETE) || (code == KeyEvent.VK_BACK_SPACE)) {\n+                e.consume();\n+                lobbyActions.delete(new ArrayList<>(), entities, true);\n+            } else if (code == KeyEvent.VK_SPACE) {\n+                e.consume();\n+                mechReadoutAction(entities);\n+            } else if (code == KeyEvent.VK_ENTER) {\n+                e.consume();\n+                if (entities.size() == 1) {\n+                    lobbyActions.customizeMech(entities.get(0));\n+                } else if (canConfigureMultipleDeployment(entities)) {\n+                    lobbyActions.customizeMechs(entities);\n+                }\n+            } else if (code == KeyEvent.VK_C && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                StringSelection stringSelection = new StringSelection(clipboardString(entities));\n+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+                clipboard.setContents(stringSelection, null);\n+                \n+            } else if (code == KeyEvent.VK_V && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                importClipboard(); \n+                \n+            } else if (code == KeyEvent.VK_P) {\n+                e.consume();\n+                System.out.println(game().getEntitiesVector().size() + \" Units\");\n+                game().getEntitiesVector().stream().forEach(System.out::println);\n+                \n+            } else if (code == KeyEvent.VK_F) {\n+                e.consume();\n+                System.out.println(\"Forces: ---\");\n+                System.out.println(game().getForces());\n+            }\n+        }\n+    };\n+    \n+    /** Reads the clipboard and adds units, if it can parse them. */\n+    public void importClipboard() {\n+        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        Transferable contents = clipboard.getContents(null);\n+        boolean hasTransferableText = (contents != null) &&\n+                contents.isDataFlavorSupported(DataFlavor.stringFlavor);\n+        List<Entity> newEntities = new ArrayList<>();\n+        if (hasTransferableText) {\n+            try {\n+                String result = (String)contents.getTransferData(DataFlavor.stringFlavor);\n+                StringTokenizer lines = new StringTokenizer(result, \"\\n\");\n+                while (lines.hasMoreTokens()) {\n+                    String line = lines.nextToken();\n+                    StringTokenizer tabs = new StringTokenizer(line, \"\\t\");\n+                    String unit = \"\";\n+                    if (tabs.hasMoreTokens()) {\n+                        unit = tabs.nextToken();\n+                    }\n+                    if (tabs.hasMoreTokens()) {\n+                        unit += \" \" + tabs.nextToken();\n+                    }\n+                    MechSummary ms = MechSummaryCache.getInstance().getMech(unit);\n+                    if (ms == null) {\n+                        continue;\n+                    }\n+                    Entity newEntity = new MechFileParser(ms.getSourceFile(),\n+                            ms.getEntryName()).getEntity();\n+                    if (newEntity != null) {\n+                        newEntity.setOwner(localPlayer());\n+                        newEntities.add(newEntity);\n+                    }\n+                }\n+            }\n+            catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            if (!newEntities.isEmpty()) {\n+                client().sendAddEntity(newEntities);\n+            }\n+        }\n+    }\n+    \n+    /** Returns a String representing the entities to export to the clipboard. */\n+    private String clipboardString(Collection<Entity> entities) {\n+        StringBuilder result = new StringBuilder();\n+        for (Entity entity: entities) {\n+            // Chassis\n+            result.append(entity.getChassis()).append(\"\\t\");\n+            // Model\n+            result.append(entity.getModel()).append(\"\\t\");\n+            // Weight; format for locale to avoid wrong \",.\" etc.\n+            Locale cl = Locale.getDefault();\n+            NumberFormat numberFormatter = NumberFormat.getNumberInstance(cl);\n+            result.append(numberFormatter.format(entity.getWeight())).append(\"\\t\");\n+            // Pilot name\n+            result.append(entity.getCrew().getName()).append(\"\\t\");\n+            // Crew Skill with text\n+            result.append(CrewSkillSummaryUtil.getSkillNames(entity)).append(\": \")\n+                    .append(entity.getCrew().getSkillsAsString(false)).append(\"\\t\");\n+            // BV without C3 but with pilot (as that gets exported too)\n+            result.append(entity.calculateBattleValue(true, false)).append(\"\\t\");\n+            result.append(\"\\n\");\n+        }\n+        return result.toString();\n+    }\n+    \n+    /** Returns a list of entities selected in the ForceTree. May be empty, but not null. */\n+    private List<Entity> getTreeSelectedEntities() {\n+        TreePath[] selection = mekForceTree.getSelectionPaths();\n+        List<Entity> entities = new ArrayList<>();\n+        if (selection != null) {\n+            for (TreePath path: selection) {\n+                if (path != null) {\n+                    Object selected = path.getLastPathComponent();\n+                    if (selected instanceof Entity) {\n+                        entities.add((Entity) selected);\n+                    }  \n+                }\n+            }\n+        }\n+        return entities;\n+    }\n+    \n+    /** Returns a list of forces selected in the ForceTree. May be empty, but not null. */\n+    private List<Force> getTreeSelectedForces() {\n+        TreePath[] selection = mekForceTree.getSelectionPaths();\n+        List<Force> selForces = new ArrayList<>();\n+        if (selection != null) {\n+            for (TreePath path: selection) {\n+                if (path != null) {\n+                    Object selected = path.getLastPathComponent();\n+                    if (selected instanceof Force) {\n+                        selForces.add((Force) selected);\n+                    } \n+                }\n+            }\n+        }\n+        return selForces;\n+    }\n+    \n+    /** The key listener for the Force Tree. */\n+    KeyListener mekTreeKeyListener = new KeyAdapter() {\n+\n+        @Override\n+        public void keyPressed(KeyEvent e) {\n+            List<Entity> selEntities = getTreeSelectedEntities();\n+            List<Force> selForces = getTreeSelectedForces();\n+            boolean onlyOneEntity = (selEntities.size() == 1) && selForces.isEmpty();\n+            int code = e.getKeyCode();\n+            \n+            if (code == KeyEvent.VK_SPACE) {\n+                e.consume();\n+                mechReadoutAction(selEntities);\n+                \n+            } else if (code == KeyEvent.VK_ENTER && onlyOneEntity) {\n+                e.consume();\n+                lobbyActions.customizeMech(selEntities.get(0));\n+                \n+            } else if (code == KeyEvent.VK_UP && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                lobbyActions.forceMove(selForces, selEntities, true);\n+                \n+            } else if (code == KeyEvent.VK_DOWN && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                lobbyActions.forceMove(selForces, selEntities, false);\n+                \n+            } else if ((code == KeyEvent.VK_DELETE) || (code == KeyEvent.VK_BACK_SPACE)) {\n+                e.consume();\n+                lobbyActions.delete(selForces, selEntities, true);\n+                \n+            } else if (code == KeyEvent.VK_RIGHT && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                expandTree();\n+                \n+            } else if (code == KeyEvent.VK_LEFT && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                collapseTree();\n+                \n+            } else if (code == KeyEvent.VK_C && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                StringSelection stringSelection = new StringSelection(clipboardString(selEntities));\n+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+                clipboard.setContents(stringSelection, null);\n+                \n+            } else if (code == KeyEvent.VK_V && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                importClipboard();\n+                \n+            } else if (code == KeyEvent.VK_P) {\n+                e.consume();\n+                System.out.println(game().getEntitiesVector().size() + \" Units\");\n+                game().getEntitiesVector().stream().forEach(System.out::println);\n+                \n+            } else if (code == KeyEvent.VK_F) {\n+                e.consume();\n+                System.out.println(\"Forces: ---\");\n+                System.out.println(game().getForces());\n+            }\n+        }\n+    };\n+\n+\n+    public class MapListMouseAdapter extends MouseInputAdapter implements ActionListener {\n+        \n+        @Override\n+        public void actionPerformed(ActionEvent action) {\n+            String[] command = action.getActionCommand().split(\":\");\n+\n+            switch (command[0]) {\n+            case \"BOARD\":\n+                changeMapDnD(command[2], mapButtons.get(Integer.parseInt(command[1])));\n+                break;\n+\n+            case \"SURPRISE\":\n+                changeMapDnD(command[2], mapButtons.get(Integer.parseInt(command[1])));\n+                break;\n+            }\n+        }\n+\n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger() && lisBoardsAvailable.isEnabled()) {\n+                // If the right mouse button is pressed over an unselected map,\n+                // clear the selection and select that entity instead\n+                int index = lisBoardsAvailable.locationToIndex(e.getPoint());\n+                if (index != -1 && lisBoardsAvailable.getCellBounds(index, index).contains(e.getPoint())) {\n+                    if (!lisBoardsAvailable.isSelectedIndex(index)) {\n+                        lisBoardsAvailable.setSelectedIndex(index);\n+                    }\n+                    showPopup(e);\n+                }\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (lisBoardsAvailable.isSelectionEmpty()) {\n+                return;\n+            }\n+            List<String> boards = lisBoardsAvailable.getSelectedValuesList();\n+            int activeButtons = mapSettings.getMapWidth() * mapSettings.getMapHeight();\n+            ScalingPopup popup = MapListPopup.mapListPopup(boards, activeButtons, this, ChatLounge.this);\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public class MekForceTreeMouseAdapter extends MouseInputAdapter {\n+        \n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = mekForceTree.getRowForLocation(e.getX(), e.getY());\n+                TreePath path = mekForceTree.getPathForRow(row);\n+                if (path != null && path.getLastPathComponent() instanceof Entity) {\n+                    Entity entity = (Entity) path.getLastPathComponent();\n+                    lobbyActions.customizeMech(entity);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected entity,\n+                // clear the selection and select that entity instead\n+                int row = mekForceTree.getRowForLocation(e.getX(), e.getY());\n+                if (!mekForceTree.isRowSelected(row)) {\n+                    mekForceTree.setSelectionRow(row);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            TreePath[] selection = mekForceTree.getSelectionPaths();\n+            List<Entity> entities = new ArrayList<>();\n+            List<Force> selForces = new ArrayList<>();\n+            \n+            if (selection != null) {\n+                for (TreePath path: selection) {\n+                    if (path != null) {\n+                        Object selected = path.getLastPathComponent();\n+                        if (selected instanceof Entity) {\n+                            entities.add((Entity) selected);\n+                        } else if (selected instanceof Force) {\n+                            selForces.add((Force) selected);\n+                        } \n+                    }\n+                }\n+            }\n+            ScalingPopup popup = LobbyMekPopup.getPopup(entities, selForces, new LobbyMekPopupActions(ChatLounge.this), ChatLounge.this);\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+\n+    public class MekTableMouseAdapter extends MouseInputAdapter {\n+\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = mekTable.rowAtPoint(e.getPoint());\n+                Entity entity = mekModel.getEntityAt(row);\n+                if (entity != null && isEditable(entity)) {\n+                    lobbyActions.customizeMech(entity);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected entity,\n+                // clear the selection and select that entity instead\n+                int row = mekTable.rowAtPoint(e.getPoint());\n+                if (!mekTable.isRowSelected(row)) {\n+                    mekTable.changeSelection(row, row, false, false);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (mekTable.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            List<Entity> entities = getSelectedEntities();\n+            ScalingPopup popup = LobbyMekPopup.getPopup(entities, new ArrayList<Force>(), new LobbyMekPopupActions(ChatLounge.this), ChatLounge.this);\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    /** Refreshes the Mek Tree, restoring expansion state and selection. */\n+    private void refreshTree() {\n+        // Refresh the force tree and restore selection/expand status\n+        HashSet<Object> selections = new HashSet<>();\n+        if (!mekForceTree.isSelectionEmpty()) {\n+            for (TreePath path: mekForceTree.getSelectionPaths()) {\n+                Object sel = path.getLastPathComponent();\n+                if (sel instanceof Force || sel instanceof Entity) {\n+                    selections.add(path.getLastPathComponent());\n+                }\n+            }\n+        }\n+        \n+        Forces forces = game().getForces();\n+        List<Integer> expandedForces = new ArrayList<>();\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            TreePath currPath = mekForceTree.getPathForRow(i);\n+            if (mekForceTree.isExpanded(currPath)) {\n+                Object entry = currPath.getLastPathComponent();\n+                if (entry instanceof Force) {\n+                    expandedForces.add(((Force)entry).getId());\n+                }\n+            }\n+            if (selections.contains(currPath)) {\n+                \n+            }\n+        }\n+        \n+        mekForceTree.setUI(null);\n+        try {\n+            mekForceTreeModel.refreshData();\n+        } finally {\n+            mekForceTree.updateUI();\n+        }\n+        for (int id: expandedForces) {\n+            if (!forces.contains(id)) {\n+                continue;\n+            }\n+            mekForceTree.expandPath(getPath(forces.getForce(id)));\n+        }\n+\n+        mekForceTree.clearSelection();\n+        for (Object sel: selections) {\n+            mekForceTree.addSelectionPath(getPath(sel));\n+        }\n+\n+    }\n+    \n+    /** \n+     * Returns a TreePath in the force tree for a possibly outdated entity\n+     * or force. Outdated means a new object of the type was sent by the server\n+     * and has replaced this object. Also works for the game's current objects though. \n+     * Uses the force's/entity's id to get the \n+     * game's real object with the same id. Used to reconstruct the selection\n+     * and expansion state of the force tree after an update.\n+     */\n+    private TreePath getPath(Object outdatedEntry) {\n+        Forces forces = game().getForces();\n+        if (outdatedEntry instanceof Force) {\n+            if (!forces.contains((Force) outdatedEntry)) {\n+                return null;\n+            }\n+            int forceId = ((Force) outdatedEntry).getId();\n+            List<Force> chain = forces.forceChain(forces.getForce(forceId));\n+            Object[] pathObjs = new Object[chain.size() + 1];\n+            int index = 0;\n+            pathObjs[index++] = mekForceTreeModel.getRoot();\n+            for (Force force: chain) {\n+                pathObjs[index++] = force;\n+            }\n+            return new TreePath(pathObjs);\n+        } else if (outdatedEntry instanceof Entity) {\n+            int entityId = ((Entity) outdatedEntry).getId();\n+            if (game().getEntity(entityId) == null) {\n+                return null;\n+            }\n+            List<Force> chain = forces.forceChain(game().getEntity(entityId));\n+            Object[] pathObjs = new Object[chain.size() + 2];\n+            int index = 0;\n+            pathObjs[index++] = mekForceTreeModel.getRoot();\n+            for (Force force: chain) {\n+                pathObjs[index++] = force;\n+            }\n+            pathObjs[index++] = game().getEntity(entityId);\n+            return new TreePath(pathObjs);\n+        } else {\n+            throw new IllegalArgumentException(\"Method requires Entity or Force object.\");\n+        }\n+    }\n+    \n+    /** \n+     * Returns a Collection that contains only those of the given entities\n+     * that the local player can affect, i.e. his units or those of his bots. \n+     * The returned Collection is a new Collection and can be safely altered.\n+     * (The entities are not copies of course.)\n+     * <P>See also {@link #isEditable(Entity)} \n+     */\n+    private Set<Entity> editableEntities(Collection<Entity> entities) {\n+        return entities.stream().filter(e -> isEditable(e)).collect(Collectors.toSet());\n+    }\n+    \n+   \n+    /** \n+     * Returns true if the given carrier and carried can be edited to have the \n+     * carrier transport the given carried entity. That is the case when they \n+     * are teammates and one of the entities can be edited by the local player. \n+     * Note: this method does NOT check if the loading is rules-valid.\n+     * <P>See also {@link #isEditable(Entity)}\n+     */\n+    private boolean isLoadable(Entity carried, Entity carrier) {\n+        return !carrier.getOwner().isEnemyOf(carried.getOwner()) \n+                && (isEditable(carrier) || isEditable(carried));\n+    }\n+\n+\n+    public void load(Collection<Entity> selEntities, String info) {\n+        StringTokenizer stLoad = new StringTokenizer(info, \":\");\n+        int loaderId = Integer.parseInt(stLoad.nextToken());\n+        Entity loader = clientgui.getClient().getEntity(loaderId);\n+        int bayNumber = Integer.parseInt(stLoad.nextToken());\n+        // Remove those entities from the candidates that are already carried by that loader\n+        Collection<Entity> entities = new HashSet<>(selEntities);\n+        entities.removeIf(e -> e.getTransportId() == loaderId);\n+        if (entities.isEmpty()) {\n+            return;\n+        }\n+\n+        // If a unit of the selected units is currently loaded onto another, 2nd unit of the selected\n+        // units, do not continue. The player should unload units first. This would require\n+        // a server update offloading that second unit AND embarking it. Currently not possible\n+        // as a single server update and updates for one unit shouldn't be chained.\n+        Set<Entity> carriers = entities.stream()\n+                .filter(e -> e.getTransportId() != Entity.NONE)\n+                .map(e -> game().getEntity(e.getTransportId())).collect(Collectors.toSet());\n+        if (!Collections.disjoint(entities, carriers)) {\n+            LobbyErrors.showNoDualLoad(clientgui.frame);\n+            return;\n+        }\n+\n+        boolean loadRear = false;\n+        if (stLoad.hasMoreTokens()) {\n+            loadRear = Boolean.parseBoolean(stLoad.nextToken());\n+        }\n+\n+        StringBuilder errorMsg = new StringBuilder();\n+        if (!LobbyUtility.validateLobbyLoad(entities, loader, bayNumber, loadRear, errorMsg)) {\n+            JOptionPane.showMessageDialog(clientgui.frame, errorMsg.toString(), \n+                    Messages.getString(\"LoadingBay.error\"), JOptionPane.ERROR_MESSAGE);\n+            return;\n+        }\n+\n+        for (Entity e : entities) {\n+            if (e.getTransportId() != Entity.NONE) {\n+                Set<Entity> updateCandidates = new HashSet<>();\n+                disembark(e, updateCandidates);\n+                if (!updateCandidates.isEmpty()) {\n+                    Entity formerLoader = game().getEntity(e.getTransportId());\n+                    getLocalClient(formerLoader).sendUpdateEntity(formerLoader);\n+                }\n+            }\n+            loadOnto(e, loaderId, bayNumber);\n+        }\n+    }\n+\n+    @Override\n+    public void preferenceChange(PreferenceChangeEvent e) {\n+        if (e.getName().equals(GUIPreferences.GUI_SCALE)) {\n+            adaptToGUIScale();\n+            \n+        } else if (e.getName().equals(IClientPreferences.SHOW_UNIT_ID)) {\n+            setButUnitIDState();\n+            mekModel.refreshCells();\n+            refreshTree();\n+        }\n+    }\n+    \n+    /** Silently adapts the state of the \"Show IDs\" button to the Client prefs. */\n+    private void setButUnitIDState() {\n+        butShowUnitID.removeActionListener(lobbyListener);\n+        butShowUnitID.setSelected(PreferenceManager.getClientPreferences().getShowUnitId());\n+        butShowUnitID.addActionListener(lobbyListener);\n+    }\n+    \n+    /** Sets the row height of the MekTable according to compact mode and GUI scale */\n+    private void setTableRowHeights() {\n+        int rowbaseHeight = butCompact.isSelected() ? MEKTABLE_ROWHEIGHT_COMPACT : MEKTABLE_ROWHEIGHT_FULL;\n+        mekTable.setRowHeight(UIUtil.scaleForGUI(rowbaseHeight));\n+        rowbaseHeight = butCompact.isSelected() ? MEKTABLE_ROWHEIGHT_COMPACT : MEKTREE_ROWHEIGHT_FULL;\n+        mekForceTree.setRowHeight(UIUtil.scaleForGUI(rowbaseHeight));\n+        tablePlayers.rescale();\n+    }\n+\n+    /** Refreshes the table headers of the MekTable and PlayerTable. */\n+    private void updateTableHeaders() {\n+        // The mek table\n+        JTableHeader header = mekTable.getTableHeader();\n+        TableColumnModel colMod = header.getColumnModel();\n+        for (int i = 0; i < colMod.getColumnCount(); i++) {\n+            TableColumn tabCol = colMod.getColumn(i);\n+            String headerText = mekModel.getColumnName(i);\n+            // Add info about the current sorting\n+            if (activeSorter.getColumnIndex() == i) {\n+                headerText += \"&nbsp;&nbsp;&nbsp;\" + guiScaledFontHTML(uiGray());\n+                if (activeSorter.getSortingDirection() == MekTableSorter.Sorting.ASCENDING) {\n+                    headerText += \"\\u25B4 \";    \n+                } else {\n+                    headerText += \"\\u25BE \";\n+                }\n+                headerText += activeSorter.getDisplayName();\n+            }\n+            tabCol.setHeaderValue(headerText);\n+        }\n+        header.repaint();\n+        \n+        // The player table\n+        header = tablePlayers.getTableHeader();\n+        colMod = header.getColumnModel();\n+        for (int i = 0; i < colMod.getColumnCount(); i++) {\n+            TableColumn tabCol = colMod.getColumn(i);\n+            tabCol.setHeaderValue(playerModel.getColumnName(i));\n+        }\n+        header.repaint();\n+    }\n+\n+    /** Returns the owner of the given entity. Should be used over entity.getowner(). */\n+    private IPlayer ownerOf(Entity entity) {\n+        return clientgui.getClient().getGame().getPlayer(entity.getOwnerId());\n+    }\n+    \n+    /** Sets the column width of the given table column of the MekTable with the value stored in the GUIP. */\n+    private void setColumnWidth(TableColumn column) {\n+        String key;\n+        if (column.getModelIndex() == MekTableModel.COL_PILOT) {\n+            key = GUIPreferences.LOBBY_MEKTABLE_PILOT_WIDTH;\n+        } else if (column.getModelIndex() == MekTableModel.COL_UNIT) {\n+            key = GUIPreferences.LOBBY_MEKTABLE_UNIT_WIDTH;\n+        } else if (column.getModelIndex() == MekTableModel.COL_PLAYER) {\n+            key = GUIPreferences.LOBBY_MEKTABLE_PLAYER_WIDTH;\n+        } else if (column.getModelIndex() == MekTableModel.COL_BV) {\n+            key = GUIPreferences.LOBBY_MEKTABLE_BV_WIDTH;\n+        } else {\n+            return;\n+        }\n+        column.setPreferredWidth(GUIPreferences.getInstance().getInt(key));\n+    }\n+    \n+    /** Adapts the whole Lobby UI (both panels) to the current guiScale. */\n+    private void adaptToGUIScale() {\n+        updateTableHeaders();\n+        setTableRowHeights();\n+        refreshLabels();\n+        refreshCamoButton();\n+        refreshMapButtons();\n+        mekModel.refreshCells();\n+        panTeamOverview.adaptToGUIScale();\n+\n+        Font scaledFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1));\n+        Font scaledBigFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1 + 3));\n+\n+        butCompact.setFont(scaledFont);\n+        butOptions.setFont(scaledBigFont);\n+        butLoadList.setFont(scaledFont);\n+        butSaveList.setFont(scaledFont);\n+        butSkills.setFont(scaledFont);\n+        butNames.setFont(scaledFont);\n+        butAddBot.setFont(scaledFont);\n+        butRemoveBot.setFont(scaledFont);\n+        butConfigPlayer.setFont(scaledFont);\n+        butBotSettings.setFont(scaledFont);\n+        butShowUnitID.setFont(scaledFont);\n+        butConditions.setFont(scaledFont);\n+        butRandomMap.setFont(scaledFont);\n+        butSpaceSize.setFont(scaledFont);\n+        butBoardPreview.setFont(scaledFont);\n+        butAddX.setFont(scaledFont);\n+        butAddY.setFont(scaledFont);\n+        comMapSizes.setFont(scaledFont);\n+        comboTeam.setFont(scaledFont);\n+        lblBoardsAvailable.setFont(scaledFont);\n+        lblMapWidth.setFont(scaledFont);\n+        butMapGrowW.setFont(scaledFont);\n+        butMapShrinkW.setFont(scaledFont);\n+        fldMapWidth.setFont(scaledFont);\n+        lblMapHeight.setFont(scaledFont);\n+        butMapGrowH.setFont(scaledFont);\n+        butMapShrinkH.setFont(scaledFont);\n+        fldMapHeight.setFont(scaledFont);\n+        lblSpaceBoardWidth.setFont(scaledFont);\n+        lblSpaceBoardHeight.setFont(scaledFont);\n+        fldSpaceBoardWidth.setFont(scaledFont);\n+        fldSpaceBoardHeight.setFont(scaledFont);\n+        butGroundMap.setFont(scaledFont);\n+        butLowAtmoMap.setFont(scaledFont);\n+        butHighAtmoMap.setFont(scaledFont);\n+        butSpaceMap.setFont(scaledFont);\n+        lblBoardSize.setFont(scaledFont);\n+        butSaveMapSetup.setFont(scaledFont);\n+        butLoadMapSetup.setFont(scaledFont);\n+        butDetach.setFont(scaledFont);\n+        butCancelSearch.setFont(scaledFont);\n+        butListView.setFont(scaledFont);\n+        butForceView.setFont(scaledFont);\n+        butCollapse.setFont(scaledFont);\n+        butExpand.setFont(scaledFont);\n+        \n+        butAdd.setFont(scaledBigFont);\n+        butArmy.setFont(scaledBigFont);\n+        panTabs.setFont(scaledBigFont);\n+        \n+        lblSearch.setFont(scaledFont);\n+        fldSearch.setFont(scaledFont);\n+        \n+        ((TitledBorder)panUnitInfo.getBorder()).setTitleFont(scaledFont);\n+        ((TitledBorder)panPlayerInfo.getBorder()).setTitleFont(scaledFont);\n+        \n+        int scaledBorder = UIUtil.scaleForGUI(TEAMOVERVIEW_BORDER);\n+        panTeam.setBorder(new EmptyBorder(scaledBorder, scaledBorder, scaledBorder, scaledBorder));\n+\n+        butBoardPreview.setToolTipText(scaleMessageForGUI(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+        butSaveMapSetup.setToolTipText(scaleMessageForGUI(\"ChatLounge.map.saveMapSetupTip\"));\n+        \n+        Font scaledHelpFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1 + 33));\n+        butHelp.setFont(scaledHelpFont);\n+\n+        // Makes a new tooltip appear immediately (rescaled and possibly for a different unit)\n+        ToolTipManager manager = ToolTipManager.sharedInstance();\n+        long time = System.currentTimeMillis() - manager.getInitialDelay() + 1;\n+        Point locationOnScreen = MouseInfo.getPointerInfo().getLocation();\n+        Point locationOnComponent = new Point(locationOnScreen);\n+        SwingUtilities.convertPointFromScreen(locationOnComponent, mekTable);\n+        MouseEvent event = new MouseEvent(mekTable, -1, time, 0, \n+                locationOnComponent.x, locationOnComponent.y, 0, 0, 1, false, 0);\n+        manager.mouseMoved(event);\n+    }\n+    \n+    /** \n+     * Mouse Listener for the table header of the Mek Table.\n+     * Saves column widths of the Mek Table when the mouse button is released. \n+     * Also switches between table sorting types\n+     */\n+    MouseListener mekTableHeaderMouseListener = new MouseAdapter()\n+    {\n+        private void changeSorter(MouseEvent e)\n+        {\n+            // Save table widths\n+            for (int i = 0; i < MekTableModel.N_COL; i++) {\n+                TableColumn column = mekTable.getColumnModel().getColumn(i);\n+                String key;\n+                if (column.getModelIndex() == MekTableModel.COL_PILOT) {\n+                    key = GUIPreferences.LOBBY_MEKTABLE_PILOT_WIDTH;\n+                } else if (column.getModelIndex() == MekTableModel.COL_UNIT) {\n+                    key = GUIPreferences.LOBBY_MEKTABLE_UNIT_WIDTH;\n+                } else if (column.getModelIndex() == MekTableModel.COL_PLAYER) {\n+                    key = GUIPreferences.LOBBY_MEKTABLE_PLAYER_WIDTH;\n+                } else if (column.getModelIndex() == MekTableModel.COL_BV) {\n+                    key = GUIPreferences.LOBBY_MEKTABLE_BV_WIDTH;\n+                } else {\n+                    continue;\n+                }\n+                GUIPreferences.getInstance().setValue(key, column.getWidth());\n+            }\n+            \n+            changeMekTableSorter(e);\n+        }\n+        \n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                e.consume();\n+                sorterPopup(e);\n+            } else {\n+                changeSorter(e);\n+            }\n+        };\n+        \n+        private void sorterPopup(MouseEvent e) {\n+            ScalingPopup popup = new ScalingPopup();\n+            GameOptions opts = clientgui.getClient().getGame().getOptions();\n+            for (MekTableSorter sorter: union(unitSorters, bvSorters)) {\n+                // Offer only allowed sorters and only one sorting direction\n+                if (sorter.isAllowed(opts) && sorter.getSortingDirection() != Sorting.ASCENDING) {\n+                    JMenuItem item = new JMenuItem(sorter.getDisplayName());\n+                    item.addActionListener(mekTableHeaderAListener);\n+                    item.setActionCommand(sorter.getDisplayName());\n+                    popup.add(item);\n+                }\n+            }\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+\n+    };\n+    \n+    /**\n+     * Sets the sorting used in the Mek Table depending on the column header \n+     * that was clicked.  \n+     */ \n+    private void changeMekTableSorter(MouseEvent e) {\n+        int col = mekTable.columnAtPoint(e.getPoint());\n+        MekTableSorter previousSorter = activeSorter;\n+        List<MekTableSorter> sorters;\n+        \n+        // find the right list of sorters (or do nothing, if the column is not sortable)\n+        if (col == MekTableModel.COL_UNIT) {\n+            sorters = unitSorters;\n+        } else if (col == MekTableModel.COL_BV) {\n+            sorters = bvSorters;\n+        } else {\n+            return;\n+        }\n+        \n+        // Select the next allowed sorter and refresh the display if the sorter was changed\n+        nextSorter(sorters);\n+        if (activeSorter != previousSorter) {\n+            refreshMekTable();\n+            updateTableHeaders();\n+        }\n+    }\n+    \n+    /** Selects the next allowed sorter in the given list of sorters. */\n+    private void nextSorter(List<MekTableSorter> sorters) {\n+        // Set the next sorter as active, if this column was already sorted, or\n+        // the first sorter otherwise\n+        int index = sorters.indexOf(activeSorter);\n+        if (index == -1) {\n+            activeSorter = sorters.get(0);\n+        } else {\n+            index = (index + 1) % sorters.size();\n+            activeSorter = sorters.get(index);\n+        }\n+        \n+        // Find an allowed sorter (e.g. blind drop may prohibit some)\n+        int counter = 0; // Endless loop safeguard\n+        while (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())\n+                && ++counter < 100) {\n+            index = (index + 1) % sorters.size();\n+            activeSorter = sorters.get(index);\n+        }\n+    }\n+\n+    /** Returns true when the compact view is active. */ \n+    public boolean isCompact() {\n+        return butCompact.isSelected();\n+    }\n+    \n+    /** \n+     * Returns a list of the selected entities in the Mek table. \n+     * The list may be empty but not null. \n+     */\n+    private ArrayList<Entity> getSelectedEntities() {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTM1NjYxMA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r615356610", "bodyText": "OK done, though I wonder at this practice (I also found it at some Java Practices website). Why stop at List? If I change the method to actually use a Set (which I've done multiple times while doing the lobby stuff) I still have to change the return value and possibly the callers. Isnt it the fault of the caller to not use a Collection whenever possible? If they do, I can return an ArrayList or a HashSet, no problem. Shouldnt the actual practice be to always receive a Collection?", "author": "SJuliez", "createdAt": "2021-04-18T07:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4OTgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc1Njk2Mg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616756962", "bodyText": "The reason I code using List/Set instead of Collection is that both give you more information and functionality while still being generic.\nIf you see a set, you know the values within are unique and that contains is a fast method to use.\nIf you see a list, you know the values within are ordered, sortable, accessible and insertable by index, and searchable by element.\nThe individual implementations within those two are less important, and can thus be genericized out, but just having a collection (especially with list) removes a huge amount of functionality and information for the programmer.\nSo... I'd use collection only if you don't and cannot think of a future reason why to use any list-based functionality and don't care about the duplication state (which... would just be easier to use and return List still to future proof it).", "author": "Windchild292", "createdAt": "2021-04-20T14:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4OTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MDA5Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612090096", "bodyText": "Why bother with this, wouldn't it be empty by default?", "author": "NickAragua", "createdAt": "2021-04-13T02:49:04Z", "path": "megamek/src/megamek/client/ui/swing/lobby/ChatLounge.java", "diffHunk": "@@ -0,0 +1,3628 @@\n+/*\n+ * MegaMek -\n+ * Copyright (C) 2000,2001,2002,2003,2004,2005,2006 Ben Mazur (bmazur@sev.org)\n+ * Copyright \u00a9 2013 Edward Cullen (eddy@obsessedcomputers.co.uk)\n+ * Copyright (c) 2021 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This program is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the Free\n+ * Software Foundation; either version 2 of the License, or (at your option)\n+ * any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * for more details.\n+ */\n+package megamek.client.ui.swing.lobby;\n+\n+import static megamek.client.ui.swing.util.UIUtil.*;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageFilter;\n+import java.awt.image.ImageProducer;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.text.NumberFormat;\n+import java.util.*;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.border.TitledBorder;\n+import javax.swing.event.*;\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.table.*;\n+import javax.swing.tree.*;\n+\n+import megamek.MegaMek;\n+import megamek.client.Client;\n+import megamek.client.generator.RandomNameGenerator;\n+import megamek.client.bot.BotClient;\n+import megamek.client.bot.princess.Princess;\n+import megamek.client.bot.ui.swing.BotGUI;\n+import megamek.client.generator.RandomCallsignGenerator;\n+import megamek.client.ui.Messages;\n+import megamek.client.ui.swing.*;\n+import megamek.client.ui.swing.boardview.BoardView1;\n+import megamek.client.ui.swing.dialog.DialogButton;\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\n+import megamek.client.ui.swing.lobby.PlayerTable.PlayerTableModel;\n+import megamek.client.ui.swing.lobby.sorters.*;\n+import megamek.client.ui.swing.lobby.sorters.MekTableSorter.Sorting;\n+import megamek.client.ui.swing.util.*;\n+import megamek.client.ui.swing.util.UIUtil.FixedYPanel;\n+import megamek.client.ui.swing.widget.SkinSpecification;\n+import megamek.common.*;\n+import megamek.common.event.*;\n+import megamek.common.force.*;\n+import megamek.common.options.*;\n+import megamek.common.preference.*;\n+import megamek.common.util.BoardUtilities;\n+import megamek.common.util.CrewSkillSummaryUtil;\n+import megamek.common.util.fileUtils.MegaMekFile;\n+\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\n+import static megamek.common.util.CollectionUtil.*;\n+import static java.util.stream.Collectors.*;\n+\n+public class ChatLounge extends AbstractPhaseDisplay implements  \n+        ListSelectionListener, IMapSettingsObserver, IPreferenceChangeListener {\n+    private static final long serialVersionUID = 1454736776730903786L;\n+\n+    // UI display control values\n+    static final int MEKTABLE_ROWHEIGHT_COMPACT = 20;\n+    static final int MEKTABLE_ROWHEIGHT_FULL = 65;\n+    static final int MEKTREE_ROWHEIGHT_FULL = 40;\n+    private final static int TEAMOVERVIEW_BORDER = 45;\n+    \n+    private JTabbedPane panTabs = new JTabbedPane();\n+    private JPanel panUnits = new JPanel();\n+    private JPanel panMap = new JPanel();\n+    private JPanel panTeam = new JPanel();\n+    \n+    // Labels\n+    private JLabel lblMapSummary = new JLabel(\"\");\n+    private JLabel lblGameYear = new JLabel(\"\");\n+    private JLabel lblTechLevel = new JLabel(\"\");\n+\n+    // Game Setup\n+    private JButton butOptions = new JButton(Messages.getString(\"ChatLounge.butOptions\"));\n+    private JToggleButton butGroundMap = new JToggleButton(\"Ground Map\");\n+    private JToggleButton butLowAtmoMap = new JToggleButton(\"Low Altitude Map\");\n+    private JToggleButton butHighAtmoMap = new JToggleButton(\"High Altitude Map\");\n+    private JToggleButton butSpaceMap = new JToggleButton(\"Space Map\");\n+    private ButtonGroup grpMap = new ButtonGroup();\n+\n+    /* Unit Configuration Panel */\n+    private FixedYPanel panUnitInfo = new FixedYPanel();\n+    private JButton butAdd = new JButton(Messages.getString(\"ChatLounge.butLoad\"));\n+    private JButton butArmy = new JButton(Messages.getString(\"ChatLounge.butArmy\"));\n+    private JButton butSkills = new JButton(Messages.getString(\"ChatLounge.butSkills\"));\n+    private JButton butNames = new JButton(Messages.getString(\"ChatLounge.butNames\"));\n+    private JButton butLoadList = new JButton(Messages.getString(\"ChatLounge.butLoadList\"));\n+    private JButton butSaveList = new JButton(Messages.getString(\"ChatLounge.butSaveList\"));\n+\n+    /* Unit Table */\n+    private JTable mekTable;\n+    public JScrollPane scrMekTable;\n+    private MMToggleButton butCompact = new MMToggleButton(Messages.getString(\"ChatLounge.butCompact\"));\n+    private MMToggleButton butShowUnitID = new MMToggleButton(Messages.getString(\"ChatLounge.butShowUnitID\"));\n+    private JToggleButton butListView = new JToggleButton(\"Sortable View\");\n+    private JToggleButton butForceView = new JToggleButton(\"Force View\");\n+    private JButton butCollapse = new JButton(\"<<\");\n+    private JButton butExpand = new JButton(\">>\");\n+    private MekTableModel mekModel;\n+    \n+    /* Force Tree */\n+    private MekTreeForceModel mekForceTreeModel;\n+    JTree mekForceTree;\n+    private MekForceTreeMouseAdapter mekForceTreeMouseListener = new MekForceTreeMouseAdapter();\n+\n+    /* Player Configuration Panel */\n+    private FixedYPanel panPlayerInfo;\n+    private JComboBox<String> comboTeam = new JComboBox<String>();\n+    private JButton butCamo = new JButton();\n+    private JButton butAddBot = new JButton(Messages.getString(\"ChatLounge.butAddBot\"));\n+    private JButton butRemoveBot = new JButton(Messages.getString(\"ChatLounge.butRemoveBot\"));\n+    private JButton butBotSettings = new JButton(\"Bot Settings...\");\n+    private JButton butConfigPlayer = new JButton(\"Configure Player...\");\n+    \n+    private MekTableMouseAdapter mekTableMouseAdapter = new MekTableMouseAdapter();\n+    private PlayerTableModel playerModel = new PlayerTableModel();\n+    private PlayerTable tablePlayers = new PlayerTable(playerModel, this);\n+    private JScrollPane scrPlayers = new JScrollPane(tablePlayers);\n+\n+    /* Map Settings Panel */\n+    private JLabel lblMapWidth = new JLabel(\"Map Width:\");\n+    private JButton butMapGrowW = new JButton(\">\");\n+    private JButton butMapShrinkW = new JButton(\"<\");\n+    private JTextField fldMapWidth = new JTextField(3);\n+    private JLabel lblMapHeight = new JLabel(\"Map Height:\");\n+    private JButton butMapGrowH = new JButton(\">\");\n+    private JButton butMapShrinkH = new JButton(\"<\");\n+    private JTextField fldMapHeight = new JTextField(3);\n+    private FixedYPanel panMapHeight = new FixedYPanel();\n+    private FixedYPanel panMapWidth = new FixedYPanel();\n+    \n+    private JLabel lblSpaceBoardWidth = new JLabel(\"Board Width:\");\n+    private JTextField fldSpaceBoardWidth = new JTextField(3);\n+    private JLabel lblSpaceBoardHeight = new JLabel(\"Board Height:\");\n+    private JTextField fldSpaceBoardHeight = new JTextField(3);\n+    private FixedYPanel panSpaceBoardHeight = new FixedYPanel();\n+    private FixedYPanel panSpaceBoardWidth = new FixedYPanel();\n+    \n+    private JLabel lblBoardSize = new JLabel(\"Board Size: \");\n+    private JButton butHelp = new JButton(\" ? \");\n+   \n+    private JButton butConditions = new JButton(Messages.getString(\"ChatLounge.butConditions\")); \n+    private JButton butRandomMap = new JButton(Messages.getString(\"BoardSelectionDialog.GeneratedMapSettings\")); \n+    ArrayList<MapPreviewButton> mapButtons = new ArrayList<>(20);\n+    MapSettings mapSettings;\n+    private JPanel panGroundMap;\n+    @SuppressWarnings(\"rawtypes\")\n+    private JComboBox<Comparable> comMapSizes;\n+    private JButton butBoardPreview = new JButton(Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"));\n+    private JPanel panMapButtons = new JPanel();\n+    private JLabel lblBoardsAvailable = new JLabel();\n+    private JList<String> lisBoardsAvailable;\n+    private JScrollPane scrBoardsAvailable;\n+    private JButton butSpaceSize = new JButton(Messages.getString(\"ChatLounge.MapSize\"));\n+    private Set<BoardDimensions> mapSizes = new TreeSet<>();\n+    boolean resetAvailBoardSelection = false;\n+    boolean resetSelectedBoards = true;\n+    private ClientDialog boardPreviewW;\n+    private Game boardPreviewGame = new Game();\n+    Dimension currentMapButtonSize = new Dimension(0,0);\n+    \n+    private ArrayList<String> invalidBoards = new ArrayList<>();\n+    private ArrayList<String> serverBoards = new ArrayList<>();\n+    \n+    private JSplitPane splGroundMap;\n+    private JLabel lblSearch = new JLabel(\"Search: \");\n+    private JTextField fldSearch = new JTextField(10);\n+    private JButton butCancelSearch = new JButton(\"X\");\n+    \n+    private MekTableSorter activeSorter;\n+    private ArrayList<MekTableSorter> unitSorters = new ArrayList<>();\n+    private ArrayList<MekTableSorter> bvSorters = new ArrayList<>();\n+    \n+    private JButton butAddY = new JButton(\"+\");\n+    private JButton butAddX = new JButton(\"+\");\n+    private JButton butSaveMapSetup = new JButton(Messages.getString(\"ChatLounge.map.saveMapSetup\") + \" *\");\n+    private JButton butLoadMapSetup = new JButton(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+    \n+    /* Team Overview Panel */\n+    private TeamOverviewPanel panTeamOverview;\n+    JButton butDetach = new JButton(\"Detach to Window\");\n+    ClientDialog teamOverviewWindow;\n+        \n+    private ImageLoader loader;\n+    private Map<String, Image> baseImages = new HashMap<>();\n+    \n+    private MapListMouseAdapter mapListMouseListener = new MapListMouseAdapter(); \n+    \n+    LobbyActions lobbyActions = new LobbyActions(this); \n+    \n+    /** Creates a new chat lounge for the clientgui.getClient(). */\n+    public ChatLounge(ClientGUI clientgui) {\n+        super(clientgui, SkinSpecification.UIComponents.ChatLounge.getComp(),\n+                SkinSpecification.UIComponents.ChatLoungeDoneButton.getComp());\n+\n+        setLayout(new BorderLayout());\n+        panTabs.add(\"Select Units\", panUnits); \n+        panTabs.add(\"Select Map\", panMap);\n+        panTabs.add(\"Team Overview\", panTeam); \n+        add(panTabs, BorderLayout.CENTER);\n+        \n+        setupSorters();\n+        setupTeamOverview();\n+        setupPlayerConfig();\n+        refreshGameSettings();\n+        setupEntities();\n+        setupUnitConfig();\n+        setupUnitsPanel();\n+        setupMapPanel();\n+        refreshLabels();\n+        adaptToGUIScale();\n+        setupListeners();\n+    }\n+    \n+    /** Sets up all the listeners that the lobby works with. */\n+    private void setupListeners() {\n+        // Make sure that no listeners are already registered from calling a refresh... method\n+        removeAllListeners();\n+        \n+        GUIPreferences.getInstance().addPreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().addListener(mechSummaryCacheListener);\n+        clientgui.getClient().getGame().addGameListener(this);\n+        clientgui.getBoardView().addBoardViewListener(this);\n+        \n+        loader = new ImageLoader();\n+        loader.execute();\n+\n+        tablePlayers.getSelectionModel().addListSelectionListener(this);\n+        tablePlayers.addMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.addListSelectionListener(this);\n+        lisBoardsAvailable.addMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.addWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.addMouseListener(mekTableMouseAdapter);\n+        mekTable.getTableHeader().addMouseListener(mekTableHeaderMouseListener);\n+        mekTable.addKeyListener(mekTableKeyListener);\n+        \n+        mekForceTree.addKeyListener(mekTreeKeyListener);\n+        mekForceTree.addMouseListener(mekForceTreeMouseListener);\n+        \n+        butAdd.addActionListener(lobbyListener);\n+        butAddBot.addActionListener(lobbyListener);\n+        butArmy.addActionListener(lobbyListener);\n+        butBoardPreview.addActionListener(lobbyListener);\n+        butBotSettings.addActionListener(lobbyListener);\n+        butCompact.addActionListener(lobbyListener);\n+        butConditions.addActionListener(lobbyListener);\n+        butConfigPlayer.addActionListener(lobbyListener);\n+        butLoadList.addActionListener(lobbyListener);\n+        butNames.addActionListener(lobbyListener);\n+        butOptions.addActionListener(lobbyListener);\n+        butRandomMap.addActionListener(lobbyListener);\n+        butRemoveBot.addActionListener(lobbyListener);\n+        butSaveList.addActionListener(lobbyListener);\n+        butShowUnitID.addActionListener(lobbyListener);\n+        butSkills.addActionListener(lobbyListener);\n+        butSpaceSize.addActionListener(lobbyListener);\n+        butCamo.addActionListener(camoListener);\n+        butAddX.addActionListener(lobbyListener);\n+        butAddY.addActionListener(lobbyListener);\n+        butMapGrowW.addActionListener(lobbyListener);\n+        butMapShrinkW.addActionListener(lobbyListener);\n+        butMapGrowH.addActionListener(lobbyListener);\n+        butMapShrinkH.addActionListener(lobbyListener);\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        butLoadMapSetup.addActionListener(lobbyListener);\n+        butSaveMapSetup.addActionListener(lobbyListener);\n+        butDetach.addActionListener(lobbyListener);\n+        butCancelSearch.addActionListener(lobbyListener);\n+        butHelp.addActionListener(lobbyListener);\n+        butListView.addActionListener(lobbyListener);\n+        butForceView.addActionListener(lobbyListener);\n+        butCollapse.addActionListener(lobbyListener);\n+        butExpand.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldMapWidth.addFocusListener(focusListener);\n+        fldMapHeight.addFocusListener(focusListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addFocusListener(focusListener);\n+        fldSpaceBoardHeight.addFocusListener(focusListener);\n+        \n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /** Applies changes to the board and map size when the textfields lose focus. */\n+    FocusListener focusListener = new FocusAdapter() {\n+        \n+        @Override\n+        public void focusLost(FocusEvent e) {\n+            if (e.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+            } else if (e.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+            } else if (e.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+            } else if (e.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+            } \n+        }\n+    }; \n+    \n+    /** Shows the camo chooser and sets the selected camo. */\n+    ActionListener camoListener = e -> {\n+        // Show the CamoChooser for the selected player\n+        if (getSelectedClient() == null) {\n+            return;\n+        }\n+        IPlayer player = getSelectedClient().getLocalPlayer();\n+        CamoChooserDialog ccd = new CamoChooserDialog(clientgui.getFrame(), player.getCamouflage());\n+\n+        // If the dialog was canceled or nothing selected, do nothing\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\n+            return;\n+        }\n+\n+        // Update the player from the camo selection\n+        player.setCamouflage(ccd.getSelectedItem());\n+        butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        getSelectedClient().sendPlayerInfo();\n+    };\n+    \n+    \n+    private void setupTeamOverview() {\n+        panTeamOverview = new TeamOverviewPanel(clientgui);\n+        FixedYPanel panDetach = new FixedYPanel(new FlowLayout(FlowLayout.LEFT));\n+        panDetach.add(butDetach);\n+        \n+        panTeam.setLayout(new BoxLayout(panTeam, BoxLayout.PAGE_AXIS));\n+        panTeam.add(panDetach);\n+        panTeam.add(panTeamOverview);\n+        \n+        // setup (but don't show) the detached team overview window\n+        teamOverviewWindow = new ClientDialog(clientgui.frame, \"Team Overview\", false);\n+        teamOverviewWindow.setSize(clientgui.frame.getWidth() / 2, clientgui.frame.getHeight() / 2);\n+    }\n+    \n+    /** Re-attaches the Team Overview panel to the tab when the detached window is closed. */\n+    WindowListener teamOverviewWindowListener = new WindowAdapter() {\n+        @Override\n+        public void windowClosing(WindowEvent e) {\n+            int i = panTabs.indexOfTab(\"Team Overview\");\n+            Component cp = panTabs.getComponentAt(i);\n+            if (cp instanceof JPanel) {\n+                ((JPanel)cp).add(panTeamOverview);\n+            }\n+            panTeamOverview.setDetached(false);\n+            butDetach.setEnabled(true);\n+            panTabs.repaint();\n+        }\n+    };\n+    \n+    /** Initializes the Mek Table sorting algorithms. */\n+    private void setupSorters() {\n+        unitSorters.add(new PlayerTransportIDSorter(clientgui));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new IDSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new NameSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TypeSorter());\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new PlayerTonnageSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.ASCENDING));\n+        unitSorters.add(new TonnageSorter(MekTableSorter.Sorting.DESCENDING));\n+        unitSorters.add(new C3IDSorter(clientgui));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new PlayerBVSorter(clientgui, MekTableSorter.Sorting.DESCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.ASCENDING));\n+        bvSorters.add(new BVSorter(MekTableSorter.Sorting.DESCENDING));\n+        activeSorter = unitSorters.get(0);\n+    }\n+\n+    /** Enables buttons to allow adding units when the MSC has finished loading. */\n+    private MechSummaryCache.Listener mechSummaryCacheListener = () -> {\n+        butAdd.setEnabled(true);\n+        butArmy.setEnabled(true);\n+        butLoadList.setEnabled(true);\n+    };\n+\n+    /** Sets up the Mek Table and Mek Tree. */\n+    private void setupEntities() {\n+        mekModel = new MekTableModel(clientgui, this);\n+        mekTable = new MekTable(mekModel);\n+        mekTable.getTableHeader().setReorderingAllowed(false);\n+        mekTable.setIntercellSpacing(new Dimension(0, 0));\n+        mekTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        for (int i = 0; i < MekTableModel.N_COL; i++) {\n+            TableColumn column = mekTable.getColumnModel().getColumn(i);\n+            column.setCellRenderer(mekModel.getRenderer());\n+            setColumnWidth(column);\n+        }\n+\n+        mekForceTreeModel = new MekTreeForceModel(this);\n+        mekForceTree = new JTree(mekForceTreeModel);\n+        mekForceTree.setRootVisible(false);\n+        mekForceTree.setDragEnabled(true);\n+        mekForceTree.setTransferHandler(new MekForceTreeTransferHandler(this, mekForceTreeModel));\n+        mekForceTree.setCellRenderer(new MekForceTreeRenderer(this));\n+        mekForceTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);\n+        mekForceTree.setExpandsSelectedPaths(true);\n+        ToolTipManager.sharedInstance().registerComponent(mekForceTree);\n+        \n+        scrMekTable = new JScrollPane(mekTable);\n+        scrMekTable.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+    }\n+\n+    /** Sets up the unit (add unit / add army) panel. */\n+    private void setupUnitConfig() {\n+        RandomNameGenerator.getInstance();\n+        RandomCallsignGenerator.getInstance();\n+\n+        MechSummaryCache mechSummaryCache = MechSummaryCache.getInstance();\n+        boolean mscLoaded = mechSummaryCache.isInitialized();\n+\n+        butLoadList.setActionCommand(\"load_list\"); \n+        butLoadList.setEnabled(mscLoaded);\n+        butSaveList.setActionCommand(\"save_list\"); \n+        butSaveList.setEnabled(false);\n+        butAdd.setEnabled(mscLoaded);\n+        butAdd.setActionCommand(\"load_mech\"); \n+        butArmy.setEnabled(mscLoaded);\n+\n+        panUnitInfo.setBorder(BorderFactory.createTitledBorder(\" Unit Setup \"));\n+        panUnitInfo.setLayout(new BoxLayout(panUnitInfo, BoxLayout.PAGE_AXIS));\n+        JPanel panUnitInfoAdd = new JPanel(new GridLayout(2, 1, 2, 2));\n+        panUnitInfoAdd.setBorder(new EmptyBorder(0, 0, 2, 1));\n+        panUnitInfoAdd.add(butAdd);\n+        panUnitInfoAdd.add(butArmy);\n+\n+        JPanel panUnitInfoGrid = new JPanel(new GridLayout(2, 2, 2, 2));\n+        panUnitInfoGrid.add(butLoadList);\n+        panUnitInfoGrid.add(butSaveList);\n+        panUnitInfoGrid.add(butNames);\n+        \n+        panUnitInfo.add(panUnitInfoAdd);\n+        panUnitInfo.add(panUnitInfoGrid);\n+    }\n+\n+    /** Sets up the player configuration (team, camo) panel with the player list. */\n+    private void setupPlayerConfig() {\n+        scrPlayers.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n+\n+        butAddBot.setActionCommand(\"add_bot\"); \n+        butRemoveBot.setEnabled(false);\n+        butRemoveBot.setActionCommand(\"remove_bot\"); \n+        butBotSettings.setEnabled(false);\n+        butBotSettings.setActionCommand(\"BOTCONFIG\"); \n+        butConfigPlayer.setEnabled(false);\n+        butConfigPlayer.setActionCommand(\"CONFIGURE\"); \n+        setButUnitIDState();\n+        setupTeamCombo();\n+        butCamo.setActionCommand(\"camo\");\n+        refreshCamoButton();\n+        \n+        panPlayerInfo = new FixedYPanel(new GridLayout(1, 2, 2, 2));\n+        panPlayerInfo.setBorder(BorderFactory.createTitledBorder(\"Player Setup\"));\n+        \n+        JPanel panPlayerInfoBts = new JPanel(new GridLayout(4, 1, 2, 2));\n+        panPlayerInfoBts.add(comboTeam);\n+        panPlayerInfoBts.add(butConfigPlayer);\n+        panPlayerInfoBts.add(butAddBot);\n+        panPlayerInfoBts.add(butRemoveBot);\n+        \n+        panPlayerInfo.add(panPlayerInfoBts);\n+        panPlayerInfo.add(butCamo);\n+\n+        refreshPlayerTable();\n+    }\n+\n+    /** Sets up the lobby main panel (units/players). */\n+    private void setupUnitsPanel() {\n+        ButtonGroup viewGroup = new ButtonGroup();\n+        viewGroup.add(butListView);\n+        viewGroup.add(butForceView);\n+        butListView.setSelected(true);\n+        \n+        butCollapse.setEnabled(false);\n+        butExpand.setEnabled(false);\n+        \n+        lblGameYear.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        lblTechLevel.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        butOptions.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        \n+        FixedXPanel leftSide = new FixedXPanel();\n+        leftSide.setLayout(new BoxLayout(leftSide, BoxLayout.PAGE_AXIS));\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(20)));\n+        leftSide.add(butOptions);\n+        leftSide.add(lblGameYear);\n+        leftSide.add(lblTechLevel);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(15)));\n+        leftSide.add(panUnitInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(panPlayerInfo);\n+        leftSide.add(Box.createVerticalStrut(scaleForGUI(5)));\n+        leftSide.add(scrPlayers);\n+        \n+        JPanel topRight = new FixedYPanel();\n+        topRight.add(butListView);\n+        topRight.add(butForceView);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCompact);\n+        topRight.add(butShowUnitID);\n+        topRight.add(Box.createHorizontalStrut(30));\n+        topRight.add(butCollapse);\n+        topRight.add(butExpand);\n+        \n+        JPanel rightSide = new JPanel();\n+        rightSide.setLayout(new BoxLayout(rightSide, BoxLayout.PAGE_AXIS));\n+        rightSide.add(topRight);\n+        rightSide.add(scrMekTable);\n+        \n+        panUnits.setLayout(new BoxLayout(panUnits, BoxLayout.LINE_AXIS));\n+        panUnits.add(leftSide);\n+        panUnits.add(rightSide);\n+    }\n+\n+    private void setupMapPanel() {\n+        mapSettings = MapSettings.getInstance(clientgui.getClient().getMapSettings());\n+        setupMapAssembly();\n+        refreshMapUI();\n+\n+        panMap.setLayout(new BoxLayout(panMap, BoxLayout.PAGE_AXIS));\n+        \n+        // Ground, Atmo, Space Map Buttons\n+        FixedYPanel panMapType = new FixedYPanel();\n+        panMapType.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panMapType.add(butGroundMap);\n+        panMapType.add(butLowAtmoMap);\n+//        panMapType.add(butHighAtmoMap);\n+        panMapType.add(butSpaceMap);\n+        grpMap.add(butGroundMap);\n+        grpMap.add(butLowAtmoMap);\n+        grpMap.add(butHighAtmoMap);\n+        grpMap.add(butSpaceMap);\n+//        panMap.add(panMapType);\n+        \n+        // Planetary Conditions and Random Map Settings buttons\n+        FixedYPanel panSettings = new FixedYPanel();\n+        panSettings.setAlignmentX(JPanel.CENTER_ALIGNMENT);\n+        panSettings.add(butConditions);\n+        panSettings.add(butRandomMap);\n+//        panMap.add(panSettings);\n+\n+        FixedYPanel panTopRows = new FixedYPanel();\n+        panTopRows.setLayout(new BoxLayout(panTopRows, BoxLayout.PAGE_AXIS));\n+        panTopRows.add(panMapType);\n+        panTopRows.add(panSettings);\n+        \n+        JPanel panHelp = new JPanel(new GridLayout(1,1));\n+        panHelp.add(butHelp);\n+        \n+        FixedYPanel panTopRowsHelp = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 30, 5));\n+        panTopRowsHelp.add(panTopRows);\n+        panTopRowsHelp.add(panHelp);\n+        panMap.add(panTopRowsHelp);\n+        \n+        // Main part: Map Assembly\n+        panMap.add(panGroundMap);\n+\n+    }\n+\n+    /**\n+     * Sets up the ground map selection panel\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void setupMapAssembly() {\n+\n+        panGroundMap = new JPanel(new GridLayout(1, 1));\n+        panGroundMap.setBorder(new EmptyBorder(20, 10, 10, 10));\n+\n+        panMapButtons.setLayout(new BoxLayout(panMapButtons, BoxLayout.PAGE_AXIS));\n+        // Resize the preview buttons when the panel is resized\n+        panMapButtons.addComponentListener(new ComponentAdapter() {\n+\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateMapButtons();\n+            }\n+        });\n+        \n+        panMapWidth.add(lblMapWidth);\n+        panMapWidth.add(butMapShrinkW);\n+        panMapWidth.add(fldMapWidth);\n+        panMapWidth.add(butMapGrowW);\n+        \n+        panMapHeight.add(lblMapHeight);\n+        panMapHeight.add(butMapShrinkH);\n+        panMapHeight.add(fldMapHeight);\n+        panMapHeight.add(butMapGrowH);\n+        \n+        panSpaceBoardWidth.add(lblSpaceBoardWidth);\n+        panSpaceBoardWidth.add(fldSpaceBoardWidth);\n+        panSpaceBoardWidth.setVisible(false);\n+        \n+        panSpaceBoardHeight.add(lblSpaceBoardHeight);\n+        panSpaceBoardHeight.add(fldSpaceBoardHeight);\n+        panSpaceBoardHeight.setVisible(false);\n+        \n+        FixedYPanel bottomPanel = new FixedYPanel();\n+        bottomPanel.setBorder(new EmptyBorder(10, 0, 0, 0));\n+        bottomPanel.add(butBoardPreview);\n+        bottomPanel.add(butSaveMapSetup);\n+        bottomPanel.add(butLoadMapSetup);\n+\n+        butBoardPreview.setToolTipText(Messages.getString(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+\n+        // The left side panel including the game map preview\n+        JPanel panMapPreview = new JPanel();\n+        panMapPreview.setLayout(new BoxLayout(panMapPreview, BoxLayout.PAGE_AXIS));\n+        \n+        panMapPreview.add(panMapWidth);\n+        panMapPreview.add(panMapHeight);\n+        panMapPreview.add(panSpaceBoardWidth);\n+        panMapPreview.add(panSpaceBoardHeight);\n+        panMapPreview.add(panMapButtons);\n+        panMapPreview.add(bottomPanel);\n+        \n+        // The right side panel including the list of available boards\n+        comMapSizes = new JComboBox<Comparable>();\n+        refreshMapSizes();\n+\n+        lisBoardsAvailable = new JList<String>(new DefaultListModel<String>());\n+        lisBoardsAvailable.setCellRenderer(new BoardNameRenderer());\n+        lisBoardsAvailable.setLayoutOrientation(JList.HORIZONTAL_WRAP);\n+        lisBoardsAvailable.setVisibleRowCount(-1);\n+        lisBoardsAvailable.setDragEnabled(true);\n+        lisBoardsAvailable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n+        scrBoardsAvailable = new JScrollPane(lisBoardsAvailable);\n+        refreshBoardsAvailable();\n+        \n+        JPanel panAvail = new JPanel();\n+        panAvail.setLayout(new BoxLayout(panAvail, BoxLayout.PAGE_AXIS));\n+        panAvail.setBorder(new EmptyBorder(0, 20, 0, 0));\n+        panAvail.add(setupAvailTopPanel());\n+        panAvail.add(scrBoardsAvailable);\n+        \n+        // The splitpane holding the left and right side panels\n+        splGroundMap = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panMapPreview, panAvail);\n+        splGroundMap.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+            \n+            @Override\n+            public void componentShown(ComponentEvent e) {\n+                splGroundMap.setDividerLocation(getDividerLocation());\n+            }\n+        });\n+        panGroundMap.add(splGroundMap);\n+\n+        // setup the board preview window.\n+        boardPreviewW = new ClientDialog(clientgui.frame, \n+                Messages.getString(\"BoardSelectionDialog.ViewGameBoard\"), \n+                false);\n+        boardPreviewW.setLocationRelativeTo(clientgui.frame);\n+\n+        try {\n+            BoardView1 bv = new BoardView1(boardPreviewGame, null, null);\n+            bv.setDisplayInvalidHexInfo(false);\n+            bv.setUseLOSTool(false);\n+            boardPreviewW.add(bv.getComponent(true));\n+            boardPreviewW.setSize(clientgui.frame.getWidth()/2, clientgui.frame.getHeight()/2);\n+            // Most boards will be far too large on the standard zoom\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            bv.zoomOut();\n+            boardPreviewW.center();\n+        } catch (IOException e) {\n+            JOptionPane.showMessageDialog(this,\n+                            Messages.getString(\"BoardEditor.CouldntInitialize\") + e,\n+                            Messages.getString(\"BoardEditor.FatalError\"), JOptionPane.ERROR_MESSAGE); \n+        }\n+        refreshMapButtons();\n+    }\n+    \n+    /** \n+     *  Sets up and returns the panel above the available boards list \n+     *  containing the search bar and the map size chooser.  \n+     */\n+    private JPanel setupAvailTopPanel() {\n+        FixedYPanel result = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 20, 2));\n+        result.setBorder(new EmptyBorder(5, 5, 5, 5));\n+        \n+        fldSearch.getDocument().addDocumentListener(new DocumentListener() {\n+            @Override\n+            public void changedUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void removeUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+\n+            @Override\n+            public void insertUpdate(DocumentEvent e) {\n+                updateSearch(fldSearch.getText());\n+            }\n+        });\n+        \n+        result.add(lblBoardSize);\n+        result.add(comMapSizes);\n+        result.add(new JLabel(\"    \"));\n+        result.add(lblSearch);\n+        result.add(fldSearch);\n+        result.add(butCancelSearch);\n+\n+        return result;\n+    }\n+    \n+    /** \n+     * Reacts to changes in the available boards search field, showing matching boards\n+     * for the search string when it has at least 3 characters\n+     * and reverting to all boards when the search string is empty.\n+     */\n+    private void updateSearch(String searchString) {\n+        if (searchString.isEmpty()) {\n+            refreshBoardsAvailable();\n+        } else if (searchString.length() > 2) {\n+            refreshBoardsAvailable(getSearchedItems(searchString));\n+        }\n+    }\n+    \n+    /** \n+     * Returns the available boards that match the given search string\n+     * (path or file name contains the search string.) \n+     */\n+    protected List<String> getSearchedItems(String searchString) {\n+        String lowerCaseSearchString = searchString.toLowerCase();\n+        return mapSettings.getBoardsAvailableVector().stream()\n+                .filter(b -> b.toLowerCase().contains(lowerCaseSearchString) && isBoardFile(b))\n+                .collect(Collectors.toList());\n+    }\n+    \n+    /** \n+     * Returns a suitable divider location for the splitpane that contains\n+     * the available boards list and the map preview. The divider location\n+     * gives between 30% and 50% of space to the map preview depending\n+     * on the width of the game map.\n+     */\n+    private double getDividerLocation() {\n+        double base = 0.3;\n+        int width = mapSettings.getBoardWidth() * mapSettings.getMapWidth();\n+        int height = mapSettings.getBoardHeight() * mapSettings.getMapHeight();\n+        int wAspect = Math.max(1, width / height + 1);\n+        return Math.min(base + wAspect * 0.05, 0.5);\n+    }\n+\n+    /** Updates the ground map type chooser (ground/atmosphere map). */\n+    private void refreshMapChoice() {\n+        // refresh UI possibly from a server update\n+        JToggleButton button = butGroundMap;\n+        if (mapSettings.getMedium() == MapSettings.MEDIUM_ATMOSPHERE) {\n+            button = butLowAtmoMap;\n+        } else if (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {\n+            button = butSpaceMap;\n+        }\n+        \n+        if (!button.isSelected()) {\n+            button.removeActionListener(lobbyListener);\n+            button.setSelected(true);\n+            button.addActionListener(lobbyListener);\n+        }\n+    }\n+    \n+    /** Updates the list of available map sizes. */\n+    private void refreshMapSizes() {\n+        int oldSelection = comMapSizes.getSelectedIndex();\n+        mapSizes = clientgui.getClient().getAvailableMapSizes();\n+        comMapSizes.removeActionListener(lobbyListener);\n+        comMapSizes.removeAllItems();\n+        for (BoardDimensions size : mapSizes) {\n+            comMapSizes.addItem(size);\n+        }\n+        comMapSizes.addItem(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        comMapSizes.setSelectedIndex(oldSelection != -1 ? oldSelection : 0);\n+        comMapSizes.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the map assembly UI from the current map settings. Does NOT trigger further\n+     * changes or result in packets to the server. \n+     */\n+    private void refreshMapUI() {\n+        boolean inSpace = mapSettings.getMedium() == MapSettings.MEDIUM_SPACE;\n+        boolean onGround = mapSettings.getMedium() == MapSettings.MEDIUM_GROUND;\n+        boolean customSize = comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"));\n+        lisBoardsAvailable.setEnabled(!inSpace);\n+        mapIcons.clear();\n+        butConditions.setEnabled(!inSpace);\n+        fldSearch.setEnabled(!inSpace);\n+        butRandomMap.setEnabled(!inSpace);\n+        panMapHeight.setVisible(!inSpace);\n+        panMapWidth.setVisible(!inSpace);\n+        panSpaceBoardWidth.setVisible(inSpace || customSize);\n+        panSpaceBoardHeight.setVisible(inSpace || customSize);\n+        comMapSizes.setEnabled(!inSpace);\n+        lblSearch.setEnabled(!inSpace);\n+        lblBoardSize.setEnabled(!inSpace);\n+        butSaveMapSetup.setEnabled(!inSpace);\n+        butLoadMapSetup.setEnabled(!inSpace);\n+        butMapShrinkW.setEnabled(mapSettings.getMapWidth() > 1);\n+        butMapShrinkH.setEnabled(mapSettings.getMapHeight() > 1);\n+        \n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        if (onGround) {\n+            butGroundMap.setSelected(true);\n+        } else if (inSpace) {\n+            butSpaceMap.setSelected(true);\n+        } else {\n+            butLowAtmoMap.setSelected(true);\n+        }\n+        butGroundMap.addActionListener(lobbyListener);\n+        butLowAtmoMap.addActionListener(lobbyListener);\n+        butHighAtmoMap.addActionListener(lobbyListener);\n+        butSpaceMap.addActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        fldMapWidth.setText(Integer.toString(mapSettings.getMapWidth()));\n+        fldMapHeight.setText(Integer.toString(mapSettings.getMapHeight()));\n+        fldSpaceBoardWidth.setText(Integer.toString(mapSettings.getBoardWidth()));\n+        fldSpaceBoardHeight.setText(Integer.toString(mapSettings.getBoardHeight()));\n+        fldMapWidth.addActionListener(lobbyListener);\n+        fldMapHeight.addActionListener(lobbyListener);\n+        fldSpaceBoardWidth.addActionListener(lobbyListener);\n+        fldSpaceBoardHeight.addActionListener(lobbyListener);\n+    }\n+\n+    /** \n+     * Refreshes the list of available boards with all available boards plus\n+     * GENERATED. Useful for first setup, when the server transmits new\n+     * map settings and when the text search field is empty.\n+     */\n+    private void refreshBoardsAvailable() {\n+        if (!lisBoardsAvailable.isEnabled()) {\n+            return;\n+        }\n+        lisBoardsAvailable.setFixedCellHeight(-1);\n+        lisBoardsAvailable.setFixedCellWidth(-1);\n+        List<String> availBoards = new ArrayList<>(); \n+        availBoards.add(MapSettings.BOARD_GENERATED);\n+        availBoards.addAll(mapSettings.getBoardsAvailableVector());\n+        refreshBoardsAvailable(availBoards);\n+    }\n+    \n+    /** \n+     * Refreshes the list of available maps with the given list of boards. \n+     */\n+    private void refreshBoardsAvailable(List<String> boardList) {\n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        // Replace the data model (adding the elements one by one to the existing model\n+        // in Java 8 style is sluggish because of event firing)\n+        DefaultListModel<String> newModel = new DefaultListModel<>();\n+        for (String s: boardList) {\n+            newModel.addElement(s);\n+        }\n+        lisBoardsAvailable.setModel(newModel);\n+        lisBoardsAvailable.clearSelection();\n+        lisBoardsAvailable.addListSelectionListener(this);\n+    }\n+    \n+    public boolean isMultipleBoards() {\n+        return mapSettings.getMapHeight() * mapSettings.getMapWidth() > 1;\n+    }\n+    \n+    MapSettings oldMapSettings = MapSettings.getInstance();\n+\n+    /**\n+     * Fills the Map Buttons scroll pane twith the appropriate amount of buttons\n+     * in the appropriate layout\n+     */\n+    private void refreshMapButtons() {\n+        panMapButtons.removeAll();\n+        panMapButtons.setVisible(false);\n+        panMapButtons.add(Box.createVerticalGlue());\n+        Dimension buttonSize = null;\n+\n+        // If buttons are unused, remove their image so that they update when they're used once more\n+        if (mapSettings.getMapHeight() * mapSettings.getMapWidth() < mapButtons.size()) {\n+            for (MapPreviewButton button: mapButtons.subList(mapSettings.getMapHeight() * mapSettings.getMapWidth(), mapButtons.size())) {\n+                button.reset();\n+            }\n+        }\n+\n+        // Add new map preview buttons if the map has grown\n+        while (mapSettings.getMapHeight() * mapSettings.getMapWidth() > mapButtons.size()) {\n+            mapButtons.add(new MapPreviewButton(this));\n+        }\n+\n+        // Re-add the buttons to the panel and update them as necessary\n+        for (int i = 0; i < mapSettings.getMapHeight(); i++) {\n+            JPanel row = new FixedYPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));\n+            panMapButtons.add(row);\n+            for (int j = 0; j < mapSettings.getMapWidth(); j++) {\n+                int index = i * mapSettings.getMapWidth() + j;\n+                MapPreviewButton button = mapButtons.get(index);\n+                button.setIndex(index);\n+                row.add(button);\n+\n+                // Update the board base image if it's generated and the settings have changed\n+                // or the board name has changed\n+                String boardName = mapSettings.getBoardsSelectedVector().get(index);\n+                if (!button.getBoard().equals(boardName) \n+                        || oldMapSettings.getMedium() != mapSettings.getMedium()\n+                        || (!mapSettings.equalMapGenParameters(oldMapSettings) \n+                                && mapSettings.getMapWidth() == oldMapSettings.getMapWidth()\n+                                && mapSettings.getMapHeight() == oldMapSettings.getMapHeight())) {\n+                    IBoard buttonBoard; \n+                    Image image;\n+                    // Generated and space boards use a generated example\n+                    if (boardName.startsWith(MapSettings.BOARD_GENERATED) \n+                            || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                        buttonBoard = BoardUtilities.generateRandom(mapSettings);\n+                        image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                    } else { \n+                        String boardForImage = boardName;\n+                        // For a surprise board, just use the first board as example\n+                        if (boardName.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                            boardForImage = extractSurpriseMaps(boardName).get(0);\n+                        }\n+                        File boardFile = new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile();\n+                        if (boardFile.exists()) {\n+                            buttonBoard = new Board(16, 17);\n+                            buttonBoard.load(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile());\n+                            StringBuffer errs = new StringBuffer();\n+                            try (InputStream is = new FileInputStream(new MegaMekFile(Configuration.boardsDir(), boardForImage + \".board\").getFile())) {\n+                                buttonBoard.load(is, errs, true);\n+                            } catch (IOException ex) {\n+                                buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            }\n+                            image = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                        } else {\n+                            buttonBoard = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                            BufferedImage emptyBoardMap = MiniMap.getBoardMinimapImageMaxZoom(buttonBoard);\n+                            markServerSideBoard(emptyBoardMap);\n+                            image = emptyBoardMap;\n+                        }\n+                    }\n+                    button.setImage(image, boardName);\n+                    buttonSize = optMapButtonSize(image);\n+                }\n+                button.scheduleRescale();\n+            }\n+        }\n+        oldMapSettings = MapSettings.getInstance(mapSettings);\n+        \n+        if (buttonSize != null) {\n+            for (MapPreviewButton button: mapButtons) {\n+                button.setPreviewSize(buttonSize);\n+            }\n+        }\n+        splGroundMap.setDividerLocation(getDividerLocation());\n+\n+        panMapButtons.add(Box.createVerticalGlue());\n+        panMapButtons.setVisible(true);\n+\n+        lblBoardsAvailable.setText(mapSettings.getBoardWidth() + \"x\" + mapSettings.getBoardHeight() + \" \"\n+                + Messages.getString(\"BoardSelectionDialog.mapsAvailable\"));\n+        comMapSizes.removeActionListener(lobbyListener);\n+        int items = comMapSizes.getItemCount();\n+\n+        boolean mapSizeSelected = false;\n+        for (int i = 0; i < (items - 1); i++) {\n+            BoardDimensions size = (BoardDimensions) comMapSizes.getItemAt(i);\n+\n+            if ((size.width() == mapSettings.getBoardWidth()) && (size.height() == mapSettings.getBoardHeight())) {\n+                comMapSizes.setSelectedIndex(i);\n+                mapSizeSelected = true;\n+            }\n+        }\n+        // If we didn't select a size, select the last item: 'Custom Size'\n+        if (!mapSizeSelected) {\n+            comMapSizes.setSelectedIndex(items - 1);\n+        }\n+        comMapSizes.addActionListener(lobbyListener);\n+\n+    }\n+    \n+    private void markServerSideBoard(BufferedImage image) {\n+        Graphics g = image.getGraphics();\n+        GUIPreferences.AntiAliasifSet(g);\n+        int w = image.getWidth();\n+        int h = image.getHeight();\n+        String text = \"Server-side board\";\n+        int fontSize = Math.min(w / 10, UIUtil.scaleForGUI(16));\n+        g.setFont(new Font(\"Dialog\", Font.ITALIC, fontSize));\n+        FontMetrics fm = g.getFontMetrics(g.getFont());\n+        int cx = (w - fm.stringWidth(text)) / 2;\n+        int cy = h / 10 + fm.getAscent();\n+        g.setColor(GUIPreferences.getInstance().getWarningColor());\n+        g.drawString(text, cx, cy);\n+        g.dispose();\n+    }\n+\n+    public void previewGameBoard() {\n+        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);\n+        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];\n+        List<Boolean> rotateBoard = new ArrayList<>();\n+        for (int i = 0; i < (mapSettings.getMapWidth() * mapSettings.getMapHeight()); i++) {\n+            sheetBoards[i] = new Board();\n+            String name = mapSettings.getBoardsSelectedVector().get(i);\n+            if (name.startsWith(MapSettings.BOARD_GENERATED) \n+                    || (mapSettings.getMedium() == MapSettings.MEDIUM_SPACE)) {\n+                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);\n+            } else {\n+                if (name.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                    List<String> boardList = extractSurpriseMaps(name);\n+                    int rnd = (int)(Math.random() * boardList.size());\n+                    name = boardList.get(rnd);\n+                }\n+                sheetBoards[i].load(new MegaMekFile(Configuration.boardsDir(), name + \".board\").getFile());\n+            }\n+        }\n+\n+        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(), mapSettings.getMapWidth(),\n+                mapSettings.getMapHeight(), sheetBoards, rotateBoard, mapSettings.getMedium());\n+        \n+        boardPreviewGame.setBoard(newBoard);\n+        boardPreviewW.setVisible(true);\n+    }\n+\n+    /**\n+     * Refreshes the game settings with new info from the client\n+     */\n+    private void refreshGameSettings() {\n+        refreshTeams();\n+        refreshDoneButton();\n+    }\n+    \n+    /**\n+     * Refreshes the Mek Table contents \n+     */\n+    public void refreshEntities() {\n+        refreshTree();\n+        refreshMekTable();\n+    }\n+    \n+    private void refreshMekTable() {\n+        List<Integer> enIds = getSelectedEntities().stream().map(e -> e.getId()).collect(toList());\n+        mekModel.clearData();\n+        ArrayList<Entity> allEntities = new ArrayList<Entity>(clientgui.getClient().getEntitiesVector());\n+        Collections.sort(allEntities, activeSorter);\n+\n+        boolean localUnits = false;\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        for (Entity entity : allEntities) {\n+            // Remember if the local player has units.\n+            if (!localUnits && entity.getOwner().equals(localPlayer())) {\n+                localUnits = true;\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_PILOT_ADVANTAGES)) { \n+                entity.getCrew().clearOptions(PilotOptions.LVL3_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.EDGE)) { \n+                entity.getCrew().clearOptions(PilotOptions.EDGE_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.RPG_MANEI_DOMINI)) { \n+                entity.getCrew().clearOptions(PilotOptions.MD_ADVANTAGES);\n+            }\n+\n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_STRATOPS_PARTIALREPAIRS)) { \n+                entity.clearPartialRepairs();\n+            }\n+            \n+            // Remove some deployment options when a unit is carried\n+            if (entity.getTransportId() != Entity.NONE) { \n+                entity.setHidden(false);\n+                entity.setProne(false);\n+                entity.setHullDown(false);\n+            }\n+            \n+            if (!opts.booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) { \n+                entity.setHidden(false);\n+            }\n+            \n+            // Handle the \"Blind Drop\" option. In blind drop, units must be added\n+            // but they will be obscured in the table. In real blind drop, units\n+            // don't even get added to the table. Teams see their units in any case.\n+            boolean localUnit = entity.getOwner().equals(localPlayer());\n+            boolean teamUnit = !entity.getOwner().isEnemyOf(localPlayer());\n+            boolean realBlindDrop = opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+            if (localUnit || teamUnit || !realBlindDrop) {\n+                mekModel.addUnit(entity);\n+            }\n+        }\n+        // Restore selection\n+        if (!enIds.isEmpty()) {\n+            for (int i = 0; i < mekTable.getRowCount(); i++) {\n+                if (enIds.contains(mekModel.getEntityAt(i).getId())) {\n+                    mekTable.addRowSelectionInterval(i, i);\n+                }\n+            }\n+        }\n+\n+        // Enable the \"Save Unit List...\" button if the local player has units.\n+        clientgui.getMenuBar().setUnitList(localUnits);\n+    }\n+    \n+    /** Adjusts the mektable to compact/normal mode. */\n+    private void toggleCompact() {\n+        setTableRowHeights();\n+        mekModel.refreshCells();\n+        mekForceTreeModel.nodeChanged((TreeNode)mekForceTreeModel.getRoot());\n+        \n+    }\n+\n+    /** Refreshes the player info table. */\n+    private void refreshPlayerTable() {\n+        // Remember the selected players\n+        var selPlayerIds = getselectedPlayers().stream().map(IPlayer::getId).collect(toSet());\n+\n+        // Empty and refill the player table\n+        playerModel.replaceData(game().getPlayersVector());\n+\n+        // re-select the previously selected players, if possible\n+        for (int row = 0; row < playerModel.getRowCount(); row++) {\n+            if (selPlayerIds.contains(playerModel.getPlayerAt(row).getId())) {\n+                tablePlayers.addRowSelectionInterval(row, row);\n+            }\n+        }\n+    }\n+\n+    /** Updates the camo button to displays the camo of the currently selected player. */ \n+    private void refreshCamoButton() {\n+        if ((tablePlayers == null) || (playerModel == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (player != null) {\n+            butCamo.setIcon(player.getCamouflage().getImageIcon());\n+        }\n+    }\n+\n+    /** Sets up the team choice box. */\n+    private void setupTeamCombo() {\n+        for (int i = 0; i < IPlayer.MAX_TEAMS; i++) {\n+            comboTeam.addItem(IPlayer.teamNames[i]);\n+        }\n+    }\n+\n+    /** Updates the team choice combobox to show the selected player's team. */\n+    private void refreshTeams() {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(localPlayer().getTeam());\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Refreshes the Done button. The label will say the opposite of the\n+     * player's \"done\" status, indicating that clicking it will reverse the\n+     * condition.\n+     */\n+    private void refreshDoneButton(boolean done) {\n+        butDone.setText(done ? Messages.getString(\"ChatLounge.notDone\") : Messages.getString(\"ChatLounge.imDone\"));\n+    }\n+\n+    /** Refreshes the state of the Done button with the state of the local player. */\n+    private void refreshDoneButton() {\n+        refreshDoneButton(localPlayer().isDone());\n+    }\n+\n+    /**\n+     * Embarks the given carried Entity onto the carrier given as carrierId.\n+     */\n+    void loadOnto(Entity carried, int carrierId, int bayNumber) {\n+        Entity carrier = game().getEntity(carrierId);\n+        if (carrier == null || !isLoadable(carried, carrier)) {\n+            return;\n+        }\n+\n+        // We need to make sure our current bomb choices fit onto the new\n+        // fighter\n+        if (carrier instanceof FighterSquadron) {\n+            FighterSquadron fSquad = (FighterSquadron) carrier;\n+            // We can't use Aero.getBombPoints() because the bombs haven't been\n+            // loaded yet, only selected, so we have to count the choices\n+            int[] bombChoice = fSquad.getBombChoices();\n+            int numLoadedBombs = 0;\n+            for (int i = 0; i < bombChoice.length; i++) {\n+                numLoadedBombs += bombChoice[i];\n+            }\n+            // We can't load all of the squadrons bombs\n+            if (numLoadedBombs > ((IBomber)carried).getMaxBombPoints()) {\n+                JOptionPane.showMessageDialog(clientgui.frame, Messages.getString(\"FighterSquadron.bomberror\"),\n+                        Messages.getString(\"FighterSquadron.error\"), JOptionPane.ERROR_MESSAGE);\n+                return;\n+            }\n+        }\n+        \n+        getLocalClient(carried).sendLoadEntity(carried.getId(), carrierId, bayNumber);\n+        // TODO: it would probably be a good idea \n+        // to disable some settings for loaded units in customMechDialog\n+    }\n+\n+    /** \n+     * Have the given entity disembark if it is carried by another unit.\n+     * Entities that are modified and need an update to be sent to the server\n+     * are added to the given updateCandidates. \n+     */\n+    void disembark(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = game().getEntity(entity.getTransportId());\n+        if (carrier != null) {\n+            carrier.unload(entity);\n+            entity.setTransportId(Entity.NONE);\n+            updateCandidates.add(entity);\n+            updateCandidates.add(carrier);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity disembark if it is carried by a unit of another player.\n+     * Entities that were modified and need an update to be sent to the server\n+     * are added to the given updateCandidate set. \n+     */\n+    void disembarkDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        if (entity.getTransportId() == Entity.NONE) {\n+            return;\n+        }\n+        Entity carrier = clientgui.getClient().getGame().getEntity(entity.getTransportId());\n+        if (carrier != null && (ownerOf(entity) != ownerOf(carrier))) {\n+            disembark(entity, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entities offload all the units they are carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadAll(Collection<Entity> entities, Collection<Entity> updateCandidates) {\n+        for (Entity carrier: editableEntities(entities)) {\n+            offloadFrom(carrier, updateCandidates);\n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all the units it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFrom(Entity entity, Collection<Entity> updateCandidates) {\n+        if (isEditable(entity)) {\n+            for (Entity carriedUnit: entity.getLoadedUnits()) {\n+                disembark(carriedUnit, updateCandidates);\n+            } \n+        }\n+    }\n+    \n+    /** \n+     * Have the given entity offload all units of different players it is carrying.\n+     * Returns a set of entities that need to be sent to the server. \n+     */\n+    void offloadFromDifferentOwner(Entity entity, Collection<Entity> updateCandidates) {\n+        for (Entity carriedUnit: entity.getLoadedUnits()) {\n+            if (ownerOf(carriedUnit) != ownerOf(entity)) {\n+                disembark(carriedUnit, updateCandidates);\n+            }\n+        } \n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. \n+     */\n+    void sendUpdate(Collection<Entity> updateCandidates) {\n+        for (Entity e: editableEntities(updateCandidates)) {\n+            getLocalClient(e).sendUpdateEntity(e);\n+        }\n+    }\n+    \n+    /** \n+     * Sends the entities in the given Collection to the Server. \n+     * Sends only those that can be edited, i.e. the player's own\n+     * or his bots' units. Will separate the units into update\n+     * packets for the local player and any local bots so that the \n+     * server accepts all changes (as the server does not know of\n+     * local bots and rejects updates that are not for the sending client\n+     * or its teammates. \n+     */\n+    void sendUpdates(Collection<Entity> entities) {\n+        List<IPlayer> owners = entities.stream().map(e -> e.getOwner()).distinct().collect(toList());\n+        for (IPlayer owner: owners) {\n+            client().sendUpdateEntity(new ArrayList<Entity>(\n+                    entities.stream().filter(e -> e.getOwner().equals(owner)).collect(toList())));\n+        }\n+    }\n+    \n+    /** \n+     * Disembarks all given entities from any transports they are in. \n+     */\n+    void disembarkAll(Collection<Entity> entities) {\n+        Set<Entity> updateCandidates = new HashSet<>();\n+        entities.stream().filter(e -> isEditable(e)).forEach(e -> disembark(e, updateCandidates));\n+        sendUpdate(updateCandidates);\n+    }\n+\n+    /** \n+     * Returns true when the given entity may be configured by the local player,\n+     * i.e. if it is his own unit or one of his bot's units.\n+     * <P>Note that this is more restrictive than the Server is. The Server\n+     * accepts entity changes also for teammates so that entity updates that \n+     * signal transporting a teammate's unit don't get rejected. I feel that\n+     * configuration other than transporting units should be limited to one's\n+     * own units (and bots) though.\n+     */\n+    boolean isEditable(Entity entity) {\n+        return clientgui.getBots().containsKey(entity.getOwner().getName())\n+                || (entity.getOwnerId() == localPlayer().getId());\n+    }\n+    \n+    /** \n+     * Returns true when the given entity may NOT be configured by the local player,\n+     * i.e. if it is not own unit or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isNotEditable(Entity entity) {\n+        return !isEditable(entity);\n+    }\n+    \n+    /** \n+     * Returns true when all given entities may be configured by the local player,\n+     * i.e. if they are his own units or one of his bot's units.\n+     * @see #isEditable(Entity)\n+     */\n+    boolean isEditable(Collection<Entity> entities) {\n+        return !entities.stream().anyMatch(this::isNotEditable);\n+    }\n+    \n+    /** \n+     * Returns the Client associated with a given entity that may be configured\n+     * by the local player (his own unit or one of his bot's units).\n+     * For a unit that cannot be configured (owned by a remote player) the client\n+     * of the local player is returned.\n+     */\n+    Client getLocalClient(Entity entity) {\n+        if (clientgui.getBots().containsKey(entity.getOwner().getName())) {\n+            return clientgui.getBots().get(entity.getOwner().getName());\n+        } else {\n+            return clientgui.getClient();\n+        }\n+    }\n+\n+    public void configPlayer() {\n+        Client c = getSelectedClient();\n+        if (null == c) {\n+            return;\n+        }\n+        \n+        PlayerSettingsDialog psd = new PlayerSettingsDialog(clientgui, c);\n+        boolean okay = psd.showDialog();\n+        \n+        if (okay) {\n+            IPlayer player = c.getLocalPlayer();\n+            player.setConstantInitBonus(psd.getInit());\n+            player.setNbrMFConventional(psd.getCnvMines());\n+            player.setNbrMFVibra(psd.getVibMines());\n+            player.setNbrMFActive(psd.getActMines());\n+            player.setNbrMFInferno(psd.getInfMines());\n+            var rsg = c.getRandomSkillsGenerator();\n+            rsg.setMethod(psd.getMethod());\n+            rsg.setType(psd.getPilot());\n+            rsg.setLevel(psd.getXP());\n+            rsg.setClose(psd.getForceGP());\n+            \n+            // The deployment position\n+            int startPos = psd.getStartPos();\n+            final GameOptions gOpts = clientgui.getClient().getGame().getOptions();\n+            if (gOpts.booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                    && (startPos >= 1) && (startPos <= 9)) {\n+                startPos += 10;\n+            }\n+            c.getLocalPlayer().setStartingPos(startPos);\n+            c.sendPlayerInfo();\n+            \n+            // If the gameoption set_arty_player_homeedge is set, adjust the player's offboard \n+            // arty units to be behind the newly selected home edge.\n+            OffBoardDirection direction = OffBoardDirection.translateStartPosition(startPos);\n+            if (direction != OffBoardDirection.NONE && \n+                    gOpts.booleanOption(OptionsConstants.BASE_SET_ARTY_PLAYER_HOMEEDGE)) {\n+                for (Entity entity: c.getGame().getPlayerEntities(c.getLocalPlayer(), false)) {\n+                    if (entity.getOffBoardDirection() != OffBoardDirection.NONE) {\n+                        entity.setOffBoard(entity.getOffBoardDistance(), direction);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+    \n+    \n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechReadoutAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechReadout(entity, index++);\n+        }\n+    } \n+\n+    /** \n+     * Shows the unit summary for the given unit. Moves the dialog a bit depending on index\n+     * so that multiple dialogs dont appear exactly on top of each other. \n+     */\n+    private void mechReadout(Entity entity, int index) {\n+        final ClientDialog dialog = new ClientDialog(clientgui.frame, Messages.getString(\"ChatLounge.quickView\"), false, true);\n+        final int height = 600;\n+        final int width = 500;\n+\n+        MechView mv = new MechView(entity, false);\n+        // The label must want a fixed width to enforce linebreaks on fluff text\n+        JLabel mechSummary = new JLabel(\"<HTML>\" + mv.getMechReadoutHead()\n+        + mv.getMechReadoutBasic() + mv.getMechReadoutLoadout()\n+        + mv.getMechReadoutFluff()) {\n+            private static final long serialVersionUID = 2989361635430008853L;\n+            @Override\n+            public Dimension getPreferredSize() {\n+                return new Dimension(width - 10, super.getPreferredSize().height);\n+            }\n+        };\n+        mechSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(mechSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.center();\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /** \n+     * Shows the unit summaries for the given units, but not for hidden units (blind drop)\n+     * and not for more than 10 units at a time (because that's likely a misclick).\n+     */\n+    void mechBVAction(Collection<Entity> entities) {\n+        if (entities.size() > 10) {\n+            LobbyErrors.showTenUnits(clientgui.frame);\n+            return;\n+        }\n+        if (!canSeeAll(entities)) {\n+            LobbyErrors.showCannotViewHidden(clientgui.frame);\n+            return;\n+        }\n+        int index = 0;\n+        for (Entity entity: entities) {\n+            mechBVDisplay(entity, index++);\n+        }\n+    } \n+    \n+    /**\n+     * @param entity the entity to display the BV Calculation for\n+     */\n+    void mechBVDisplay(Entity entity, int index) {\n+        final JDialog dialog = new ClientDialog(clientgui.frame, \"BV Calculation Display\", false, true);\n+        final int height = 600;\n+        \n+        entity.calculateBattleValue();\n+        JLabel bvSummary = new JLabel(entity.getBVText());\n+        bvSummary.setFont(new Font(\"Dialog\",Font.PLAIN, scaleForGUI(14)));\n+        bvSummary.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\n+        JScrollPane tScroll = new JScrollPane(bvSummary,\n+                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+        tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+        dialog.add(tScroll, BorderLayout.CENTER);\n+\n+        JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+        button.addActionListener(e -> dialog.setVisible(false));\n+        JPanel okayPanel = new JPanel(new FlowLayout());\n+        okayPanel.add(button);\n+        dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+        Dimension sz = new Dimension(bvSummary.getPreferredSize().width + 40, scaleForGUI(height));\n+        dialog.setPreferredSize(sz);\n+        dialog.setVisible(true);\n+        dialog.setLocation(dialog.getLocation().x + index * 10, dialog.getLocation().y + index * 10);\n+    }\n+\n+    /**\n+     * Pop up the dialog to load a mech\n+     */\n+    private void addUnit() {\n+        clientgui.getMechSelectorDialog().updateOptionValues();\n+        clientgui.getMechSelectorDialog().setVisible(true);\n+    }\n+    \n+    private void createArmy() {\n+        clientgui.getRandomArmyDialog().setVisible(true);\n+    }\n+\n+    public void loadRandomSkills() {\n+        clientgui.getRandomSkillDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    public void loadRandomNames() {\n+        clientgui.getRandomNameDialog().showDialog(clientgui.getClient().getGame().getEntitiesVector());\n+    }\n+\n+    void changeMapDnD(String board, JButton button) {\n+        if (board.contains(\"\\n\")) {\n+            board = MapSettings.BOARD_SURPRISE + board;\n+        }\n+        mapSettings.getBoardsSelectedVector().set(mapButtons.indexOf(button), board);\n+        clientgui.getClient().sendMapSettings(mapSettings);\n+        if (boardPreviewW.isVisible()) {\n+            previewGameBoard();\n+        }\n+    }\n+    \n+    \n+\n+    //\n+    // GameListener\n+    //\n+    @Override\n+    public void gamePlayerChange(GamePlayerChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshDoneButton();\n+        clientgui.getClient().getGame().setupTeams();\n+        refreshPlayerTable();\n+        refreshPlayerConfig();\n+        refreshCamoButton();\n+        refreshEntities();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gamePhaseChange(GamePhaseChangeEvent e) {\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        \n+        if (clientgui.getClient().getGame().getPhase() == IGame.Phase.PHASE_LOUNGE) {\n+            refreshDoneButton();\n+            refreshGameSettings();\n+            refreshPlayerTable();\n+            refreshTeams();\n+            refreshCamoButton();\n+            refreshEntities();\n+            panTeamOverview.refreshData();\n+        }\n+    }\n+\n+    @Override\n+    public void gameEntityNew(GameEntityNewEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameSettingsChange(GameSettingsChangeEvent e) {\n+        // Are we ignoring events?\n+        if (isIgnoringEvents()) {\n+            return;\n+        }\n+        refreshGameSettings();\n+        // The table sorting may no longer be allowed (e.g. when blind drop was activated)\n+        if (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())) {\n+            nextSorter(unitSorters);\n+            updateTableHeaders();\n+        }\n+        refreshEntities();\n+        refreshPlayerTable();\n+        refreshMapSizes();\n+        updateMapSettings(clientgui.getClient().getMapSettings());\n+        panTeamOverview.refreshData();\n+    }\n+\n+    @Override\n+    public void gameClientFeedbackRequest(GameCFREvent evt) {\n+        // Do nothing\n+    }\n+\n+    \n+    private ActionListener lobbyListener = new ActionListener() {\n+\n+        @Override\n+        public void actionPerformed(ActionEvent ev) {\n+\n+            // Are we ignoring events?\n+            if (isIgnoringEvents()) {\n+                return;\n+            }\n+            \n+            if (ev.getSource().equals(butAdd)) {\n+                addUnit();\n+                \n+            } else if (ev.getSource().equals(butArmy)) {\n+                createArmy();\n+                \n+            } else if (ev.getSource().equals(butSkills)) {\n+                loadRandomSkills();\n+                \n+            } else if (ev.getSource().equals(butNames)) {\n+                loadRandomNames();\n+                \n+            } else if (ev.getSource().equals(tablePlayers)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(comboTeam)) {\n+                lobbyActions.changeTeam(getselectedPlayers(), comboTeam.getSelectedIndex());\n+                \n+            } else if (ev.getSource().equals(butConfigPlayer)) {\n+                configPlayer();\n+                \n+            } else if (ev.getSource().equals(butBotSettings)) {\n+                doBotSettings();\n+                \n+            } else if (ev.getSource().equals(butOptions)) {\n+                // Make sure the game options dialog is editable.\n+                if (!clientgui.getGameOptionsDialog().isEditable()) {\n+                    clientgui.getGameOptionsDialog().setEditable(true);\n+                }\n+                // Display the game options dialog.\n+                clientgui.getGameOptionsDialog().update(clientgui.getClient().getGame().getOptions());\n+                clientgui.getGameOptionsDialog().setVisible(true);\n+                \n+            } else if (ev.getSource().equals(butCompact)) {\n+                toggleCompact();\n+                \n+            } else if (ev.getSource().equals(butLoadList)) {\n+                // Allow the player to replace their current\n+                // list of entities with a list from a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));  //$NON-NLS-2$\n+                    return;\n+                }\n+                clientgui.loadListFile(c.getLocalPlayer());\n+                \n+            } else if (ev.getSource().equals(butSaveList)) {\n+                // Allow the player to save their current\n+                // list of entities to a file.\n+                Client c = getSelectedClient();\n+                if (c == null) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+                            Messages.getString(\"ChatLounge.SelectBotOrPlayer\"));\n+                    return;\n+                }\n+                clientgui.saveListFile(c.getGame().getPlayerEntities(c.getLocalPlayer(), false),\n+                        c.getLocalPlayer().getName());\n+                \n+            } else if (ev.getSource().equals(butAddBot)) {\n+                BotConfigDialog bcd = new BotConfigDialog(clientgui.frame);\n+                bcd.setVisible(true);\n+                if (bcd.dialogAborted) {\n+                    return; // user didn't click 'ok', add no bot\n+                }\n+                if (clientgui.getBots().containsKey(bcd.getBotName())) {\n+                    clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertExistsBot.title\"),\n+                            Messages.getString(\"ChatLounge.AlertExistsBot.message\"));  //$NON-NLS-2$\n+                } else {\n+                    BotClient c = bcd.getSelectedBot(clientgui.getClient().getHost(), clientgui.getClient().getPort());\n+                    c.setClientGUI(clientgui);\n+                    c.getGame().addGameListener(new BotGUI(c));\n+                    try {\n+                        c.connect();\n+                    } catch (Exception e) {\n+                        clientgui.doAlertDialog(Messages.getString(\"ChatLounge.AlertBot.title\"),\n+                                Messages.getString(\"ChatLounge.AlertBot.message\"));  //$NON-NLS-2$\n+                    }\n+                    clientgui.getBots().put(bcd.getBotName(), c);\n+                }\n+                \n+            } else if (ev.getSource().equals(butRemoveBot)) {\n+                removeBot();\n+                \n+            } else if (ev.getSource().equals(butShowUnitID)) {\n+                PreferenceManager.getClientPreferences().setShowUnitId(butShowUnitID.isSelected());\n+                mekModel.refreshCells();\n+                repaint();\n+                \n+            } else if (ev.getSource() == butConditions) {\n+                PlanetaryConditionsDialog pcd = new PlanetaryConditionsDialog(clientgui);\n+                boolean userOkay = pcd.showDialog();\n+                if (userOkay) {\n+                    clientgui.getClient().sendPlanetaryConditions(pcd.getConditions());\n+                }\n+                \n+            } else if (ev.getSource() == butRandomMap) {\n+                RandomMapDialog rmd = new RandomMapDialog(clientgui.frame, ChatLounge.this, clientgui.getClient(), mapSettings);\n+                rmd.activateDialog(clientgui.getBoardView().getTilesetManager().getThemes());\n+                \n+            } else if (ev.getSource().equals(butBoardPreview)) {\n+                previewGameBoard();\n+                \n+            } else if (ev.getSource().equals(comMapSizes)) {\n+                if (comMapSizes.getSelectedItem().equals(Messages.getString(\"ChatLounge.CustomMapSize\"))) {\n+                    refreshMapUI();\n+                } else if (comMapSizes.getSelectedItem() != null) {\n+                    BoardDimensions size = (BoardDimensions) comMapSizes.getSelectedItem();\n+                    mapSettings.setBoardSize(size.width(), size.height());\n+                    resetAvailBoardSelection = true;\n+                    resetSelectedBoards = true;\n+                    clientgui.getClient().sendMapSettings(mapSettings);\n+                } \n+                \n+            } else if (ev.getSource() == butGroundMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_GROUND);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butSpaceMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_SPACE);\n+                mapSettings.setBoardSize(50, 50);\n+                mapSettings.setMapSize(1, 1);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butLowAtmoMap) {\n+                mapSettings.setMedium(MapSettings.MEDIUM_ATMOSPHERE);\n+                refreshMapUI();\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddX || ev.getSource() == butMapGrowW) {\n+                int newMapWidth = mapSettings.getMapWidth() + 1;\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butAddY || ev.getSource() == butMapGrowH) {\n+                int newMapHeight = mapSettings.getMapHeight() + 1;\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+                \n+            } else if (ev.getSource() == butSaveMapSetup) {\n+                saveMapSetup();\n+                \n+            } else if (ev.getSource() == butLoadMapSetup) {\n+                loadMapSetup();\n+                \n+            } else if (ev.getSource() == fldMapWidth) {\n+                setManualMapWidth();\n+                \n+            } else if (ev.getSource() == fldMapHeight) {\n+                setManualMapHeight();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardWidth) {\n+                setManualBoardWidth();\n+                \n+            } else if (ev.getSource() == fldSpaceBoardHeight) {\n+                setManualBoardHeight();\n+                \n+            } else if (ev.getSource() == butMapShrinkW) {\n+                if (mapSettings.getMapWidth() > 1) {\n+                    int newMapWidth = mapSettings.getMapWidth() - 1;\n+                    mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butMapShrinkH) {\n+                if (mapSettings.getMapHeight() > 1) {\n+                    int newMapHeight = mapSettings.getMapHeight() - 1;\n+                    mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                    clientgui.getClient().sendMapDimensions(mapSettings);\n+                }\n+            } else if (ev.getSource() == butDetach) {\n+                butDetach.setEnabled(false);\n+                panTeam.remove(panTeamOverview);\n+                panTeam.repaint();\n+                panTeamOverview.setDetached(true);\n+                teamOverviewWindow.add(panTeamOverview);\n+                teamOverviewWindow.center();\n+                teamOverviewWindow.setVisible(true);\n+                \n+            } else if (ev.getSource() == butCancelSearch) {\n+                fldSearch.setText(\"\");\n+\n+            } else if (ev.getSource() == butHelp) {\n+                File helpfile = new File(\"docs/Boards Stuff/MapAssemblyHelp.html\");\n+                final JDialog dialog = new ClientDialog(clientgui.frame, \"Map Assembly Help\", true, true);\n+                final int height = 600;\n+                final int width = 600;\n+                \n+                final JEditorPane pane = new JEditorPane();\n+                pane.setName(\"helpPane\");\n+                pane.setEditable(false);\n+                pane.setFont(new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1)));\n+                try {\n+                    pane.setPage(helpfile.toURI().toURL());\n+                    JScrollPane tScroll = new JScrollPane(pane,\n+                            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                            JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+                    tScroll.getVerticalScrollBar().setUnitIncrement(16);\n+                    dialog.add(tScroll, BorderLayout.CENTER);\n+                } catch (Exception e) {\n+                    dialog.setTitle(Messages.getString(\"AbstractHelpDialog.noHelp.title\"));\n+                    pane.setText(Messages.getString(\"AbstractHelpDialog.errorReading\") + e.getMessage());\n+                    MegaMek.getLogger().error(e);\n+                }\n+\n+                JButton button = new DialogButton(Messages.getString(\"Okay\"));\n+                button.addActionListener(e -> dialog.setVisible(false));\n+                JPanel okayPanel = new JPanel(new FlowLayout());\n+                okayPanel.add(button);\n+                dialog.add(okayPanel, BorderLayout.PAGE_END);\n+\n+                Dimension sz = new Dimension(scaleForGUI(width), scaleForGUI(height));\n+                dialog.setPreferredSize(sz);\n+                dialog.setVisible(true);\n+                \n+            } else if (ev.getSource() == butListView) {\n+                scrMekTable.setViewportView(mekTable);\n+                butCollapse.setEnabled(false);\n+                butExpand.setEnabled(false);\n+                \n+            } else if (ev.getSource() == butForceView) {\n+                scrMekTable.setViewportView(mekForceTree);\n+                butCollapse.setEnabled(true);\n+                butExpand.setEnabled(true);\n+                \n+            } else if (ev.getSource() == butCollapse) {\n+                collapseTree();\n+            } else if (ev.getSource() == butExpand) {\n+                expandTree();\n+            } \n+        }\n+    };\n+    \n+    /** Expands the Mek Force Tree fully. */\n+    private void expandTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.expandRow(i);\n+        }\n+    }\n+    \n+    /** Collapses the Mek Force Tree fully. */\n+    private void collapseTree() {\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            mekForceTree.collapseRow(i);\n+        }\n+    }\n+    \n+    \n+    /** \n+     * Opens a file chooser and saves the current map setup to the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void saveMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.saveMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showSaveDialog(clientgui.frame);\n+        File selectedFile = fc.getSelectedFile();\n+        if (!selectedFile.getName().toLowerCase().endsWith(\".xml\")) {\n+            selectedFile = new File(selectedFile.getPath() + \".xml\");\n+        }\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (selectedFile == null)) {\n+            return;\n+        }\n+        if (selectedFile.exists()) {\n+            String msg = Messages.getString(\"ChatLounge.map.saveMapSetupReplace\", selectedFile.getName());\n+            if (!MMConfirmDialog.confirm(clientgui.frame, \"Confirm replace\", msg)) {\n+                return;\n+            }\n+        }\n+        try(OutputStream os = new FileOutputStream(selectedFile)) {\n+            MapSetup.save(os, mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while saving the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+\n+    /** \n+     * Opens a file chooser and loads a new map setup from the file,\n+     * if any was chosen.\n+     * @see MapSetup \n+     */\n+    private void loadMapSetup() {\n+        JFileChooser fc = new JFileChooser(Configuration.dataDir() + \"/mapsetup\");\n+        fc.setDialogTitle(Messages.getString(\"ChatLounge.map.loadMapSetup\"));\n+        fc.setMultiSelectionEnabled(false);\n+        fc.setAcceptAllFileFilterUsed(false);\n+        fc.setFileFilter(XMLFileFilter);\n+\n+        int returnVal = fc.showOpenDialog(clientgui.frame);\n+        if ((returnVal != JFileChooser.APPROVE_OPTION) || (fc.getSelectedFile() == null)) {\n+            return;\n+        }\n+        if (!fc.getSelectedFile().exists()) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \"File not found.\");\n+            return;\n+        }\n+        try(InputStream os = new FileInputStream(fc.getSelectedFile())) {\n+            MapSetup setup = MapSetup.load(os);\n+            mapSettings.setMapSize(setup.getMapWidth(), setup.getMapHeight());\n+            mapSettings.setBoardSize(setup.getBoardWidth(), setup.getBoardHeight());\n+            mapSettings.setBoardsSelectedVector(setup.getBoards());\n+            clientgui.getClient().sendMapSettings(mapSettings);\n+        } catch (Exception ex) {\n+            JOptionPane.showMessageDialog(clientgui.frame, \n+                    \"There was a problem while loading the map setup!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n+            MegaMek.getLogger().error(ex);\n+        }\n+    }\n+    \n+    private void removeBot() {\n+        Client c = getSelectedClient();\n+        if (!client().bots.containsValue(c)) {\n+//        if ((c == null) || c.equals(clientgui.getClient())) {\n+//            clientgui.doAlertDialog(Messages.getString(\"ChatLounge.ImproperCommand\"),\n+//                    Messages.getString(\"ChatLounge.SelectBo\"));\n+            LobbyErrors.showOnlyOwnBot(clientgui.frame);\n+            return;\n+        }\n+        // Delete units first, which safely disembarks and offloads them\n+        // Don't delete the bot's forces, as that could also delete other players' entitites\n+//        lobbyActions.delete(new ArrayList<>(), game().getPlayerEntities(c.getLocalPlayer(), false), false);\n+        c.die();\n+        clientgui.getBots().remove(c.getName());\n+    }\n+    \n+    private void doBotSettings() {\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        BotClient bot = (BotClient) clientgui.getBots().get(player.getName());\n+        BotConfigDialog bcd = new BotConfigDialog(clientgui.frame, bot);\n+        bcd.setVisible(true);\n+\n+        if (bcd.dialogAborted) {\n+            return; // user didn't click 'ok', add no bot\n+        } else if (bot instanceof Princess) {\n+            ((Princess) bot).setBehaviorSettings(bcd.getBehaviorSettings());\n+            \n+            // bookkeeping:\n+            clientgui.getBots().remove(player.getName());\n+            bot.setName(bcd.getBotName());\n+            clientgui.getBots().put(bot.getName(), bot);\n+            player.setName(bcd.getBotName());\n+            clientgui.chatlounge.refreshPlayerTable();\n+        }\n+    }\n+    \n+    // Put a filter on the files that the user can select the proper file.\n+    FileFilter XMLFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return (f.getPath().toLowerCase().endsWith(\".xml\") || f.isDirectory());\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Map Setup XML files\";\n+        }\n+    };\n+    \n+    private void setManualMapWidth() {\n+        try {\n+            int newMapWidth = Integer.parseInt(fldMapWidth.getText());\n+            if (newMapWidth >= 1 && newMapWidth <= 20) {\n+                mapSettings.setMapSize(newMapWidth, mapSettings.getMapHeight());\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map width\n+        }\n+    }\n+    \n+    private void setManualMapHeight() {\n+        try {\n+            int newMapHeight = Integer.parseInt(fldMapHeight.getText());\n+            if (newMapHeight >= 1 && newMapHeight <= 20) {\n+                mapSettings.setMapSize(mapSettings.getMapWidth(), newMapHeight);\n+                clientgui.getClient().sendMapDimensions(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new map height\n+        }\n+    }\n+    \n+    private void setManualBoardWidth() {\n+        try {\n+            int newBoardWidth = Integer.parseInt(fldSpaceBoardWidth.getText());\n+            if (newBoardWidth >= 5 && newBoardWidth <= 200) {\n+                mapSettings.setBoardSize(newBoardWidth, mapSettings.getBoardHeight());\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board width\n+        }\n+    }\n+    \n+    private void setManualBoardHeight() {\n+        try {\n+            int newBoardHeight = Integer.parseInt(fldSpaceBoardHeight.getText());\n+            if (newBoardHeight >= 5 && newBoardHeight <= 200) {\n+                mapSettings.setBoardSize(mapSettings.getBoardWidth(), newBoardHeight);\n+                clientgui.getClient().sendMapSettings(mapSettings);\n+            }\n+        } catch (NumberFormatException e) {\n+            // no number, no new board height\n+        }\n+    }\n+\n+    /**\n+     * Updates to show the map settings that have, presumably, just been sent by\n+     * the server.\n+     */\n+    @Override\n+    public void updateMapSettings(MapSettings newSettings) {\n+        mapSettings = MapSettings.getInstance(newSettings);\n+        refreshMapButtons();\n+        refreshMapChoice();\n+        refreshMapUI();\n+        refreshBoardsAvailable();\n+        updateSearch(fldSearch.getText());\n+        refreshLabels();\n+    }\n+\n+\n+    /**OK Refreshes the Map Summary, Tech Level and Game Year labels. */\n+    private void refreshLabels() {\n+        Font scaledFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1));\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        \n+        String txt = Messages.getString(\"ChatLounge.GameYear\"); \n+        txt += opts.intOption(OptionsConstants.ALLOWED_YEAR);\n+        lblGameYear.setText(txt);\n+        lblGameYear.setFont(scaledFont);\n+        lblGameYear.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\"))); \n+        \n+        String tlString = TechConstants.getLevelDisplayableName(TechConstants.T_TECH_UNKNOWN);\n+        IOption tlOpt = opts.getOption(OptionsConstants.ALLOWED_TECHLEVEL);\n+        if (tlOpt != null) {\n+            tlString = tlOpt.stringValue();\n+        }\n+        lblTechLevel.setText(Messages.getString(\"ChatLounge.TechLevel\") + tlString);\n+        lblTechLevel.setFont(scaledFont);\n+        lblTechLevel.setToolTipText(scaleStringForGUI(Messages.getString(\"ChatLounge.tooltip.techYear\")));\n+        \n+        txt = Messages.getString(\"ChatLounge.MapSummary\"); \n+        txt += (mapSettings.getBoardWidth() * mapSettings.getMapWidth()) + \" x \" \n+                + (mapSettings.getBoardHeight() * mapSettings.getMapHeight());\n+        if (butGroundMap.isSelected()) {\n+            txt += \" Ground Map\";\n+        } else if (butLowAtmoMap.isSelected()) {\n+            txt += \" Atmospheric Map\";\n+        } else {\n+            txt += \" Space Map\";\n+        }\n+        lblMapSummary.setText(txt);\n+        lblMapSummary.setFont(scaledFont);\n+\n+        StringBuilder selectedMaps = new StringBuilder();\n+        selectedMaps.append(Messages.getString(\"ChatLounge.MapSummarySelectedMaps\"));\n+        for (String map: mapSettings.getBoardsSelectedVector()) {\n+            selectedMaps.append(\"&nbsp;&nbsp;\");\n+            if (map.startsWith(MapSettings.BOARD_SURPRISE)) {\n+                selectedMaps.append(MapSettings.BOARD_SURPRISE);\n+            } else {\n+                selectedMaps.append(map);\n+            }\n+            selectedMaps.append(\"<br>\"); \n+        }\n+        lblMapSummary.setToolTipText(scaleStringForGUI(selectedMaps.toString()));\n+    }\n+    \n+    @Override\n+    public void ready() {\n+        final Client client = clientgui.getClient();\n+        final IGame game = client.getGame();\n+        final GameOptions gOpts = game.getOptions();\n+        \n+        // enforce exclusive deployment zones in double blind\n+        for (IPlayer player: client.getGame().getPlayersVector()) {\n+            if (!isValidStartPos(game, player)) {\n+                clientgui.doAlertDialog(Messages.getString(\"ChatLounge.OverlapDeploy.title\"), \n+                        Messages.getString(\"ChatLounge.OverlapDeploy.msg\"));\n+                return;\n+            }\n+        }\n+\n+        // Make sure player has a commander if Commander killed victory is on\n+        if (gOpts.booleanOption(OptionsConstants.VICTORY_COMMANDER_KILLED)) {\n+            List<String> players = new ArrayList<>();\n+            if ((game.getLiveCommandersOwnedBy(localPlayer()) < 1)\n+                    && (game.getEntitiesOwnedBy(localPlayer()) > 0)) {\n+                players.add(client.getLocalPlayer().getName());\n+            }\n+            for (Client bc : clientgui.getBots().values()) {\n+                if ((game.getLiveCommandersOwnedBy(bc.getLocalPlayer()) < 1)\n+                        && (game.getEntitiesOwnedBy(bc.getLocalPlayer()) > 0)) {\n+                    players.add(bc.getLocalPlayer().getName());\n+                }\n+            }\n+            if (players.size() > 0) {\n+                String title = Messages.getString(\"ChatLounge.noCmdr.title\"); \n+                String msg = Messages.getString(\"ChatLounge.noCmdr.msg\"); \n+                for (String player : players) {\n+                    msg += player + \"\\n\";\n+                }\n+                clientgui.doAlertDialog(title, msg);\n+                return;\n+            }\n+\n+        }\n+\n+        boolean done = !localPlayer().isDone();\n+        client.sendDone(done);\n+        refreshDoneButton(done);\n+        for (Client botClient : clientgui.getBots().values()) {\n+            botClient.sendDone(done);\n+        }\n+    }\n+\n+    Client getSelectedClient() {\n+        if ((tablePlayers == null) || (tablePlayers.getSelectedRowCount() == 0)) {\n+            return null;\n+        }\n+        IPlayer player = playerModel.getPlayerAt(tablePlayers.getSelectedRow());\n+        if (localPlayer().equals(player)) {\n+            return client();\n+        } else if (client().bots.containsKey(player.getName())) {\n+            return client().bots.get(player.getName());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Stop just ignoring events and actually stop listening to them.\n+     */\n+    @Override\n+    public void removeAllListeners() {\n+        clientgui.getClient().getGame().removeGameListener(this);\n+        clientgui.getBoardView().removeBoardViewListener(this);\n+        GUIPreferences.getInstance().removePreferenceChangeListener(this);\n+        PreferenceManager.getClientPreferences().removePreferenceChangeListener(this);\n+        MechSummaryCache.getInstance().removeListener(mechSummaryCacheListener);\n+        \n+        if (loader != null) {\n+            loader.cancel(true);\n+        }\n+        \n+        tablePlayers.getSelectionModel().removeListSelectionListener(this);\n+        tablePlayers.removeMouseListener(new PlayerTableMouseAdapter());\n+        \n+        lisBoardsAvailable.removeListSelectionListener(this);\n+        lisBoardsAvailable.removeMouseListener(mapListMouseListener);\n+        \n+        teamOverviewWindow.removeWindowListener(teamOverviewWindowListener);\n+        \n+        mekTable.removeMouseListener(mekTableMouseAdapter);\n+        mekForceTree.removeMouseListener(mekForceTreeMouseListener);\n+        mekTable.getTableHeader().removeMouseListener(mekTableHeaderMouseListener);\n+        mekTable.removeKeyListener(mekTableKeyListener);\n+        mekForceTree.removeKeyListener(mekTreeKeyListener);\n+        \n+        butAdd.removeActionListener(lobbyListener);\n+        butAddBot.removeActionListener(lobbyListener);\n+        butArmy.removeActionListener(lobbyListener);\n+        butBoardPreview.removeActionListener(lobbyListener);\n+        butBotSettings.removeActionListener(lobbyListener);\n+        butCompact.removeActionListener(lobbyListener);\n+        butConditions.removeActionListener(lobbyListener);\n+        butConfigPlayer.removeActionListener(lobbyListener);\n+        butLoadList.removeActionListener(lobbyListener);\n+        butNames.removeActionListener(lobbyListener);\n+        butOptions.removeActionListener(lobbyListener);\n+        butRandomMap.removeActionListener(lobbyListener);\n+        butRemoveBot.removeActionListener(lobbyListener);\n+        butSaveList.removeActionListener(lobbyListener);\n+        butShowUnitID.removeActionListener(lobbyListener);\n+        butSkills.removeActionListener(lobbyListener);\n+        butSpaceSize.removeActionListener(lobbyListener);\n+        butCamo.removeActionListener(camoListener);\n+        butAddX.removeActionListener(lobbyListener);\n+        butAddY.removeActionListener(lobbyListener);\n+        butMapGrowW.removeActionListener(lobbyListener);\n+        butMapShrinkW.removeActionListener(lobbyListener);\n+        butMapGrowH.removeActionListener(lobbyListener);\n+        butMapShrinkH.removeActionListener(lobbyListener);\n+        butGroundMap.removeActionListener(lobbyListener);\n+        butLowAtmoMap.removeActionListener(lobbyListener);\n+        butHighAtmoMap.removeActionListener(lobbyListener);\n+        butSpaceMap.removeActionListener(lobbyListener);\n+        butLoadMapSetup.removeActionListener(lobbyListener);\n+        butSaveMapSetup.removeActionListener(lobbyListener);\n+        butDetach.removeActionListener(lobbyListener);\n+        butCancelSearch.removeActionListener(lobbyListener);\n+        butHelp.removeActionListener(lobbyListener);\n+        butListView.removeActionListener(lobbyListener);\n+        butForceView.removeActionListener(lobbyListener);\n+        butCollapse.removeActionListener(lobbyListener);\n+        butExpand.removeActionListener(lobbyListener);\n+        \n+        fldMapWidth.removeActionListener(lobbyListener);\n+        fldMapHeight.removeActionListener(lobbyListener);\n+        fldSpaceBoardWidth.removeActionListener(lobbyListener);\n+        fldSpaceBoardHeight.removeActionListener(lobbyListener);\n+        \n+        comboTeam.removeActionListener(lobbyListener);\n+    }\n+\n+    /**\n+     * Returns true if the given list of entities can be configured as a group.\n+     * This requires that they all have the same owner, and that none of the\n+     * units are being transported. Also, the owner must be the player or one\n+     * of his bots. \n+     */\n+    boolean canConfigureMultipleDeployment(Collection<Entity> entities) {\n+        return haveSingleOwner(entities) \n+                && !containsTransportedUnit(entities)\n+                && canEditAny(entities);\n+    }\n+    \n+    /**\n+     * Returns true if the given collection contains at least one entity\n+     * that the local player can edit, i.e. is his own or belongs to\n+     * one of his bots. Does not check if the units are otherwise configured,\n+     * e.g. transported.\n+     * <P>See also {@link #isEditable(Entity)}\n+     */\n+    boolean canEditAny(Collection<Entity> entities) {\n+        return entities.stream().anyMatch(e -> isEditable(e));\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see all of the given entities.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not on his team.\n+     */\n+    boolean canSeeAll(Collection<Entity> entities) {\n+        if (!game().getOptions().booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                && !game().getOptions().booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP)) {\n+            return true;\n+        }\n+        for (Entity entity: entities) {\n+            if (!entityInLocalTeam(entity)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns true if the local player can see the given entity.\n+     * This is true except when a blind drop option is active and one or more\n+     * of the entities are not his own.\n+     */\n+    boolean canSee(Entity entity) {\n+        return canSeeAll(Arrays.asList(entity));\n+    }\n+    \n+    boolean entityInLocalTeam(Entity entity) {\n+        return !localPlayer().isEnemyOf(entity.getOwner());\n+    }\n+    \n+\n+    @Override\n+    public void valueChanged(ListSelectionEvent event) {\n+        if (event.getValueIsAdjusting()) {\n+            return;\n+        }\n+        \n+        if (event.getSource().equals(tablePlayers.getSelectionModel())) {\n+            refreshPlayerConfig();\n+        }\n+    }\n+    \n+    /** Adapts the enabled state of the player config UI items to the player selection. */\n+    private void refreshPlayerConfig() {\n+        var selPlayers = getselectedPlayers();\n+        var hasSelection = !selPlayers.isEmpty();\n+        var isSinglePlayer = selPlayers.size() == 1;\n+        var allConfigurable = hasSelection && selPlayers.stream().allMatch(lobbyActions::isSelfOrLocalBot);\n+        var isSingleLocalBot = isSinglePlayer && (getSelectedClient() instanceof BotClient);\n+        comboTeam.setEnabled(allConfigurable);\n+        butLoadList.setEnabled(allConfigurable && isSinglePlayer);\n+        butCamo.setEnabled(allConfigurable && isSinglePlayer);\n+        butConfigPlayer.setEnabled(allConfigurable && isSinglePlayer);\n+        refreshCamoButton();\n+        // Disable the Remove Bot button for the \"player\" of a \"Connect As Bot\" client\n+        butRemoveBot.setEnabled(isSingleLocalBot);\n+        butSaveList.setEnabled(false);\n+        if (isSinglePlayer) {\n+            var selPlayer = theElement(selPlayers);\n+            var hasUnits = !game().getPlayerEntities(selPlayer, false).isEmpty();\n+            butSaveList.setEnabled(hasUnits && unitsVisible(selPlayer));\n+            setTeamSelectedItem(selPlayer.getTeam());\n+        }\n+    }\n+    \n+    /** Sets (without firing events) the team combobox. */\n+    private void setTeamSelectedItem(int team) {\n+        comboTeam.removeActionListener(lobbyListener);\n+        comboTeam.setSelectedIndex(team);\n+        comboTeam.addActionListener(lobbyListener);\n+    }\n+    \n+    /** \n+     * Returns false when any blind-drop option is active and player is not on the local team; \n+     * true otherwise. When true, individual units of the given player should not be shown/saved/etc. \n+     */ \n+    private boolean unitsVisible(IPlayer player) {\n+        GameOptions opts = clientgui.getClient().getGame().getOptions();\n+        boolean isBlindDrop = opts.booleanOption(OptionsConstants.BASE_BLIND_DROP)\n+                || opts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\n+        return !player.isEnemyOf(localPlayer()) || !isBlindDrop;\n+    }\n+\n+    public class PlayerTableMouseAdapter extends MouseInputAdapter {\n+\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                IPlayer player = playerModel.getPlayerAt(row);\n+                if (player != null) {\n+                    boolean isLocalPlayer = player.equals(localPlayer());\n+                    boolean isLocalBot = clientgui.getBots().get(player.getName()) != null;\n+                    if ((isLocalPlayer || isLocalBot)) {\n+                        configPlayer();\n+                    }\n+                }\n+            }\n+        }\n+        \n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected player,\n+                // clear the selection and select that entity instead\n+                int row = tablePlayers.rowAtPoint(e.getPoint());\n+                if (!tablePlayers.isRowSelected(row)) {\n+                    tablePlayers.changeSelection(row, row, false, false);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            ScalingPopup popup = PlayerTablePopup.playerTablePopup(clientgui, \n+                    playerTableActionListener, getselectedPlayers());\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    private ActionListener playerTableActionListener = new ActionListener() {\n+        \n+        @Override\n+        public void actionPerformed(ActionEvent e) {\n+            if (tablePlayers.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+        \n+            StringTokenizer st = new StringTokenizer(e.getActionCommand(), \"|\");\n+            String command = st.nextToken();\n+            switch (command) {\n+            case \"CONFIG\":\n+                configPlayer();\n+                break;\n+\n+            case \"TEAM\":\n+                int newTeam = Integer.parseInt(st.nextToken());\n+                lobbyActions.changeTeam(getselectedPlayers(), newTeam);\n+                break;\n+\n+            case \"BOTREMOVE\":\n+                removeBot();\n+                break;\n+\n+            case \"BOTSETTINGS\":\n+                doBotSettings();\n+                break;\n+                \n+            case \"DEPLOY\":\n+                int startPos = Integer.parseInt(st.nextToken());\n+                if (game().getOptions().booleanOption(OptionsConstants.BASE_DEEP_DEPLOYMENT)\n+                        && (startPos >= 1) && (startPos <= 9)) {\n+                    startPos += 10;\n+                }\n+                for (IPlayer player: getselectedPlayers()) {\n+                    if (lobbyActions.isSelfOrLocalBot(player)) {\n+                        if (client().isLocalBot(player)) {\n+                            // must use the bot's own player object:\n+                            client().getBotClient(player).getLocalPlayer().setStartingPos(startPos);\n+                            client().getBotClient(player).sendPlayerInfo();\n+                        } else {\n+                            player.setStartingPos(startPos);\n+                            client().sendPlayerInfo();\n+                        }\n+                    }\n+                }\n+                break;\n+                \n+            }\n+        }\n+    };\n+    \n+    \n+    private ArrayList<IPlayer> getselectedPlayers() {\n+        var result = new ArrayList<IPlayer>(); \n+        for (int row: tablePlayers.getSelectedRows()) {\n+            IPlayer player = playerModel.getPlayerAt(row);\n+            if (player != null) {\n+                result.add(player);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    KeyListener mekTableKeyListener = new KeyAdapter() {\n+\n+        @Override\n+        public void keyPressed(KeyEvent e) {\n+            if (mekTable.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            List<Entity> entities = getSelectedEntities();\n+            int code = e.getKeyCode();\n+            if ((code == KeyEvent.VK_DELETE) || (code == KeyEvent.VK_BACK_SPACE)) {\n+                e.consume();\n+                lobbyActions.delete(new ArrayList<>(), entities, true);\n+            } else if (code == KeyEvent.VK_SPACE) {\n+                e.consume();\n+                mechReadoutAction(entities);\n+            } else if (code == KeyEvent.VK_ENTER) {\n+                e.consume();\n+                if (entities.size() == 1) {\n+                    lobbyActions.customizeMech(entities.get(0));\n+                } else if (canConfigureMultipleDeployment(entities)) {\n+                    lobbyActions.customizeMechs(entities);\n+                }\n+            } else if (code == KeyEvent.VK_C && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                StringSelection stringSelection = new StringSelection(clipboardString(entities));\n+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+                clipboard.setContents(stringSelection, null);\n+                \n+            } else if (code == KeyEvent.VK_V && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                importClipboard(); \n+                \n+            } else if (code == KeyEvent.VK_P) {\n+                e.consume();\n+                System.out.println(game().getEntitiesVector().size() + \" Units\");\n+                game().getEntitiesVector().stream().forEach(System.out::println);\n+                \n+            } else if (code == KeyEvent.VK_F) {\n+                e.consume();\n+                System.out.println(\"Forces: ---\");\n+                System.out.println(game().getForces());\n+            }\n+        }\n+    };\n+    \n+    /** Reads the clipboard and adds units, if it can parse them. */\n+    public void importClipboard() {\n+        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        Transferable contents = clipboard.getContents(null);\n+        boolean hasTransferableText = (contents != null) &&\n+                contents.isDataFlavorSupported(DataFlavor.stringFlavor);\n+        List<Entity> newEntities = new ArrayList<>();\n+        if (hasTransferableText) {\n+            try {\n+                String result = (String)contents.getTransferData(DataFlavor.stringFlavor);\n+                StringTokenizer lines = new StringTokenizer(result, \"\\n\");\n+                while (lines.hasMoreTokens()) {\n+                    String line = lines.nextToken();\n+                    StringTokenizer tabs = new StringTokenizer(line, \"\\t\");\n+                    String unit = \"\";\n+                    if (tabs.hasMoreTokens()) {\n+                        unit = tabs.nextToken();\n+                    }\n+                    if (tabs.hasMoreTokens()) {\n+                        unit += \" \" + tabs.nextToken();\n+                    }\n+                    MechSummary ms = MechSummaryCache.getInstance().getMech(unit);\n+                    if (ms == null) {\n+                        continue;\n+                    }\n+                    Entity newEntity = new MechFileParser(ms.getSourceFile(),\n+                            ms.getEntryName()).getEntity();\n+                    if (newEntity != null) {\n+                        newEntity.setOwner(localPlayer());\n+                        newEntities.add(newEntity);\n+                    }\n+                }\n+            }\n+            catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            if (!newEntities.isEmpty()) {\n+                client().sendAddEntity(newEntities);\n+            }\n+        }\n+    }\n+    \n+    /** Returns a String representing the entities to export to the clipboard. */\n+    private String clipboardString(Collection<Entity> entities) {\n+        StringBuilder result = new StringBuilder();\n+        for (Entity entity: entities) {\n+            // Chassis\n+            result.append(entity.getChassis()).append(\"\\t\");\n+            // Model\n+            result.append(entity.getModel()).append(\"\\t\");\n+            // Weight; format for locale to avoid wrong \",.\" etc.\n+            Locale cl = Locale.getDefault();\n+            NumberFormat numberFormatter = NumberFormat.getNumberInstance(cl);\n+            result.append(numberFormatter.format(entity.getWeight())).append(\"\\t\");\n+            // Pilot name\n+            result.append(entity.getCrew().getName()).append(\"\\t\");\n+            // Crew Skill with text\n+            result.append(CrewSkillSummaryUtil.getSkillNames(entity)).append(\": \")\n+                    .append(entity.getCrew().getSkillsAsString(false)).append(\"\\t\");\n+            // BV without C3 but with pilot (as that gets exported too)\n+            result.append(entity.calculateBattleValue(true, false)).append(\"\\t\");\n+            result.append(\"\\n\");\n+        }\n+        return result.toString();\n+    }\n+    \n+    /** Returns a list of entities selected in the ForceTree. May be empty, but not null. */\n+    private List<Entity> getTreeSelectedEntities() {\n+        TreePath[] selection = mekForceTree.getSelectionPaths();\n+        List<Entity> entities = new ArrayList<>();\n+        if (selection != null) {\n+            for (TreePath path: selection) {\n+                if (path != null) {\n+                    Object selected = path.getLastPathComponent();\n+                    if (selected instanceof Entity) {\n+                        entities.add((Entity) selected);\n+                    }  \n+                }\n+            }\n+        }\n+        return entities;\n+    }\n+    \n+    /** Returns a list of forces selected in the ForceTree. May be empty, but not null. */\n+    private List<Force> getTreeSelectedForces() {\n+        TreePath[] selection = mekForceTree.getSelectionPaths();\n+        List<Force> selForces = new ArrayList<>();\n+        if (selection != null) {\n+            for (TreePath path: selection) {\n+                if (path != null) {\n+                    Object selected = path.getLastPathComponent();\n+                    if (selected instanceof Force) {\n+                        selForces.add((Force) selected);\n+                    } \n+                }\n+            }\n+        }\n+        return selForces;\n+    }\n+    \n+    /** The key listener for the Force Tree. */\n+    KeyListener mekTreeKeyListener = new KeyAdapter() {\n+\n+        @Override\n+        public void keyPressed(KeyEvent e) {\n+            List<Entity> selEntities = getTreeSelectedEntities();\n+            List<Force> selForces = getTreeSelectedForces();\n+            boolean onlyOneEntity = (selEntities.size() == 1) && selForces.isEmpty();\n+            int code = e.getKeyCode();\n+            \n+            if (code == KeyEvent.VK_SPACE) {\n+                e.consume();\n+                mechReadoutAction(selEntities);\n+                \n+            } else if (code == KeyEvent.VK_ENTER && onlyOneEntity) {\n+                e.consume();\n+                lobbyActions.customizeMech(selEntities.get(0));\n+                \n+            } else if (code == KeyEvent.VK_UP && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                lobbyActions.forceMove(selForces, selEntities, true);\n+                \n+            } else if (code == KeyEvent.VK_DOWN && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                lobbyActions.forceMove(selForces, selEntities, false);\n+                \n+            } else if ((code == KeyEvent.VK_DELETE) || (code == KeyEvent.VK_BACK_SPACE)) {\n+                e.consume();\n+                lobbyActions.delete(selForces, selEntities, true);\n+                \n+            } else if (code == KeyEvent.VK_RIGHT && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                expandTree();\n+                \n+            } else if (code == KeyEvent.VK_LEFT && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                collapseTree();\n+                \n+            } else if (code == KeyEvent.VK_C && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                StringSelection stringSelection = new StringSelection(clipboardString(selEntities));\n+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+                clipboard.setContents(stringSelection, null);\n+                \n+            } else if (code == KeyEvent.VK_V && e.getModifiersEx() == InputEvent.CTRL_DOWN_MASK) {\n+                e.consume();\n+                importClipboard();\n+                \n+            } else if (code == KeyEvent.VK_P) {\n+                e.consume();\n+                System.out.println(game().getEntitiesVector().size() + \" Units\");\n+                game().getEntitiesVector().stream().forEach(System.out::println);\n+                \n+            } else if (code == KeyEvent.VK_F) {\n+                e.consume();\n+                System.out.println(\"Forces: ---\");\n+                System.out.println(game().getForces());\n+            }\n+        }\n+    };\n+\n+\n+    public class MapListMouseAdapter extends MouseInputAdapter implements ActionListener {\n+        \n+        @Override\n+        public void actionPerformed(ActionEvent action) {\n+            String[] command = action.getActionCommand().split(\":\");\n+\n+            switch (command[0]) {\n+            case \"BOARD\":\n+                changeMapDnD(command[2], mapButtons.get(Integer.parseInt(command[1])));\n+                break;\n+\n+            case \"SURPRISE\":\n+                changeMapDnD(command[2], mapButtons.get(Integer.parseInt(command[1])));\n+                break;\n+            }\n+        }\n+\n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger() && lisBoardsAvailable.isEnabled()) {\n+                // If the right mouse button is pressed over an unselected map,\n+                // clear the selection and select that entity instead\n+                int index = lisBoardsAvailable.locationToIndex(e.getPoint());\n+                if (index != -1 && lisBoardsAvailable.getCellBounds(index, index).contains(e.getPoint())) {\n+                    if (!lisBoardsAvailable.isSelectedIndex(index)) {\n+                        lisBoardsAvailable.setSelectedIndex(index);\n+                    }\n+                    showPopup(e);\n+                }\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (lisBoardsAvailable.isSelectionEmpty()) {\n+                return;\n+            }\n+            List<String> boards = lisBoardsAvailable.getSelectedValuesList();\n+            int activeButtons = mapSettings.getMapWidth() * mapSettings.getMapHeight();\n+            ScalingPopup popup = MapListPopup.mapListPopup(boards, activeButtons, this, ChatLounge.this);\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public class MekForceTreeMouseAdapter extends MouseInputAdapter {\n+        \n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = mekForceTree.getRowForLocation(e.getX(), e.getY());\n+                TreePath path = mekForceTree.getPathForRow(row);\n+                if (path != null && path.getLastPathComponent() instanceof Entity) {\n+                    Entity entity = (Entity) path.getLastPathComponent();\n+                    lobbyActions.customizeMech(entity);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected entity,\n+                // clear the selection and select that entity instead\n+                int row = mekForceTree.getRowForLocation(e.getX(), e.getY());\n+                if (!mekForceTree.isRowSelected(row)) {\n+                    mekForceTree.setSelectionRow(row);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            TreePath[] selection = mekForceTree.getSelectionPaths();\n+            List<Entity> entities = new ArrayList<>();\n+            List<Force> selForces = new ArrayList<>();\n+            \n+            if (selection != null) {\n+                for (TreePath path: selection) {\n+                    if (path != null) {\n+                        Object selected = path.getLastPathComponent();\n+                        if (selected instanceof Entity) {\n+                            entities.add((Entity) selected);\n+                        } else if (selected instanceof Force) {\n+                            selForces.add((Force) selected);\n+                        } \n+                    }\n+                }\n+            }\n+            ScalingPopup popup = LobbyMekPopup.getPopup(entities, selForces, new LobbyMekPopupActions(ChatLounge.this), ChatLounge.this);\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+\n+    public class MekTableMouseAdapter extends MouseInputAdapter {\n+\n+        @Override\n+        public void mouseClicked(MouseEvent e) {\n+            if (e.getClickCount() == 2) {\n+                int row = mekTable.rowAtPoint(e.getPoint());\n+                Entity entity = mekModel.getEntityAt(row);\n+                if (entity != null && isEditable(entity)) {\n+                    lobbyActions.customizeMech(entity);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                // If the right mouse button is pressed over an unselected entity,\n+                // clear the selection and select that entity instead\n+                int row = mekTable.rowAtPoint(e.getPoint());\n+                if (!mekTable.isRowSelected(row)) {\n+                    mekTable.changeSelection(row, row, false, false);\n+                }\n+                showPopup(e);\n+            }\n+        }\n+\n+        /** Shows the right-click menu on the mek table */\n+        private void showPopup(MouseEvent e) {\n+            if (mekTable.getSelectedRowCount() == 0) {\n+                return;\n+            }\n+            List<Entity> entities = getSelectedEntities();\n+            ScalingPopup popup = LobbyMekPopup.getPopup(entities, new ArrayList<Force>(), new LobbyMekPopupActions(ChatLounge.this), ChatLounge.this);\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+    }\n+    \n+    /** Refreshes the Mek Tree, restoring expansion state and selection. */\n+    private void refreshTree() {\n+        // Refresh the force tree and restore selection/expand status\n+        HashSet<Object> selections = new HashSet<>();\n+        if (!mekForceTree.isSelectionEmpty()) {\n+            for (TreePath path: mekForceTree.getSelectionPaths()) {\n+                Object sel = path.getLastPathComponent();\n+                if (sel instanceof Force || sel instanceof Entity) {\n+                    selections.add(path.getLastPathComponent());\n+                }\n+            }\n+        }\n+        \n+        Forces forces = game().getForces();\n+        List<Integer> expandedForces = new ArrayList<>();\n+        for (int i = 0; i < mekForceTree.getRowCount(); i++) {\n+            TreePath currPath = mekForceTree.getPathForRow(i);\n+            if (mekForceTree.isExpanded(currPath)) {\n+                Object entry = currPath.getLastPathComponent();\n+                if (entry instanceof Force) {\n+                    expandedForces.add(((Force)entry).getId());\n+                }\n+            }\n+            if (selections.contains(currPath)) {\n+                \n+            }\n+        }\n+        \n+        mekForceTree.setUI(null);\n+        try {\n+            mekForceTreeModel.refreshData();\n+        } finally {\n+            mekForceTree.updateUI();\n+        }\n+        for (int id: expandedForces) {\n+            if (!forces.contains(id)) {\n+                continue;\n+            }\n+            mekForceTree.expandPath(getPath(forces.getForce(id)));\n+        }\n+\n+        mekForceTree.clearSelection();\n+        for (Object sel: selections) {\n+            mekForceTree.addSelectionPath(getPath(sel));\n+        }\n+\n+    }\n+    \n+    /** \n+     * Returns a TreePath in the force tree for a possibly outdated entity\n+     * or force. Outdated means a new object of the type was sent by the server\n+     * and has replaced this object. Also works for the game's current objects though. \n+     * Uses the force's/entity's id to get the \n+     * game's real object with the same id. Used to reconstruct the selection\n+     * and expansion state of the force tree after an update.\n+     */\n+    private TreePath getPath(Object outdatedEntry) {\n+        Forces forces = game().getForces();\n+        if (outdatedEntry instanceof Force) {\n+            if (!forces.contains((Force) outdatedEntry)) {\n+                return null;\n+            }\n+            int forceId = ((Force) outdatedEntry).getId();\n+            List<Force> chain = forces.forceChain(forces.getForce(forceId));\n+            Object[] pathObjs = new Object[chain.size() + 1];\n+            int index = 0;\n+            pathObjs[index++] = mekForceTreeModel.getRoot();\n+            for (Force force: chain) {\n+                pathObjs[index++] = force;\n+            }\n+            return new TreePath(pathObjs);\n+        } else if (outdatedEntry instanceof Entity) {\n+            int entityId = ((Entity) outdatedEntry).getId();\n+            if (game().getEntity(entityId) == null) {\n+                return null;\n+            }\n+            List<Force> chain = forces.forceChain(game().getEntity(entityId));\n+            Object[] pathObjs = new Object[chain.size() + 2];\n+            int index = 0;\n+            pathObjs[index++] = mekForceTreeModel.getRoot();\n+            for (Force force: chain) {\n+                pathObjs[index++] = force;\n+            }\n+            pathObjs[index++] = game().getEntity(entityId);\n+            return new TreePath(pathObjs);\n+        } else {\n+            throw new IllegalArgumentException(\"Method requires Entity or Force object.\");\n+        }\n+    }\n+    \n+    /** \n+     * Returns a Collection that contains only those of the given entities\n+     * that the local player can affect, i.e. his units or those of his bots. \n+     * The returned Collection is a new Collection and can be safely altered.\n+     * (The entities are not copies of course.)\n+     * <P>See also {@link #isEditable(Entity)} \n+     */\n+    private Set<Entity> editableEntities(Collection<Entity> entities) {\n+        return entities.stream().filter(e -> isEditable(e)).collect(Collectors.toSet());\n+    }\n+    \n+   \n+    /** \n+     * Returns true if the given carrier and carried can be edited to have the \n+     * carrier transport the given carried entity. That is the case when they \n+     * are teammates and one of the entities can be edited by the local player. \n+     * Note: this method does NOT check if the loading is rules-valid.\n+     * <P>See also {@link #isEditable(Entity)}\n+     */\n+    private boolean isLoadable(Entity carried, Entity carrier) {\n+        return !carrier.getOwner().isEnemyOf(carried.getOwner()) \n+                && (isEditable(carrier) || isEditable(carried));\n+    }\n+\n+\n+    public void load(Collection<Entity> selEntities, String info) {\n+        StringTokenizer stLoad = new StringTokenizer(info, \":\");\n+        int loaderId = Integer.parseInt(stLoad.nextToken());\n+        Entity loader = clientgui.getClient().getEntity(loaderId);\n+        int bayNumber = Integer.parseInt(stLoad.nextToken());\n+        // Remove those entities from the candidates that are already carried by that loader\n+        Collection<Entity> entities = new HashSet<>(selEntities);\n+        entities.removeIf(e -> e.getTransportId() == loaderId);\n+        if (entities.isEmpty()) {\n+            return;\n+        }\n+\n+        // If a unit of the selected units is currently loaded onto another, 2nd unit of the selected\n+        // units, do not continue. The player should unload units first. This would require\n+        // a server update offloading that second unit AND embarking it. Currently not possible\n+        // as a single server update and updates for one unit shouldn't be chained.\n+        Set<Entity> carriers = entities.stream()\n+                .filter(e -> e.getTransportId() != Entity.NONE)\n+                .map(e -> game().getEntity(e.getTransportId())).collect(Collectors.toSet());\n+        if (!Collections.disjoint(entities, carriers)) {\n+            LobbyErrors.showNoDualLoad(clientgui.frame);\n+            return;\n+        }\n+\n+        boolean loadRear = false;\n+        if (stLoad.hasMoreTokens()) {\n+            loadRear = Boolean.parseBoolean(stLoad.nextToken());\n+        }\n+\n+        StringBuilder errorMsg = new StringBuilder();\n+        if (!LobbyUtility.validateLobbyLoad(entities, loader, bayNumber, loadRear, errorMsg)) {\n+            JOptionPane.showMessageDialog(clientgui.frame, errorMsg.toString(), \n+                    Messages.getString(\"LoadingBay.error\"), JOptionPane.ERROR_MESSAGE);\n+            return;\n+        }\n+\n+        for (Entity e : entities) {\n+            if (e.getTransportId() != Entity.NONE) {\n+                Set<Entity> updateCandidates = new HashSet<>();\n+                disembark(e, updateCandidates);\n+                if (!updateCandidates.isEmpty()) {\n+                    Entity formerLoader = game().getEntity(e.getTransportId());\n+                    getLocalClient(formerLoader).sendUpdateEntity(formerLoader);\n+                }\n+            }\n+            loadOnto(e, loaderId, bayNumber);\n+        }\n+    }\n+\n+    @Override\n+    public void preferenceChange(PreferenceChangeEvent e) {\n+        if (e.getName().equals(GUIPreferences.GUI_SCALE)) {\n+            adaptToGUIScale();\n+            \n+        } else if (e.getName().equals(IClientPreferences.SHOW_UNIT_ID)) {\n+            setButUnitIDState();\n+            mekModel.refreshCells();\n+            refreshTree();\n+        }\n+    }\n+    \n+    /** Silently adapts the state of the \"Show IDs\" button to the Client prefs. */\n+    private void setButUnitIDState() {\n+        butShowUnitID.removeActionListener(lobbyListener);\n+        butShowUnitID.setSelected(PreferenceManager.getClientPreferences().getShowUnitId());\n+        butShowUnitID.addActionListener(lobbyListener);\n+    }\n+    \n+    /** Sets the row height of the MekTable according to compact mode and GUI scale */\n+    private void setTableRowHeights() {\n+        int rowbaseHeight = butCompact.isSelected() ? MEKTABLE_ROWHEIGHT_COMPACT : MEKTABLE_ROWHEIGHT_FULL;\n+        mekTable.setRowHeight(UIUtil.scaleForGUI(rowbaseHeight));\n+        rowbaseHeight = butCompact.isSelected() ? MEKTABLE_ROWHEIGHT_COMPACT : MEKTREE_ROWHEIGHT_FULL;\n+        mekForceTree.setRowHeight(UIUtil.scaleForGUI(rowbaseHeight));\n+        tablePlayers.rescale();\n+    }\n+\n+    /** Refreshes the table headers of the MekTable and PlayerTable. */\n+    private void updateTableHeaders() {\n+        // The mek table\n+        JTableHeader header = mekTable.getTableHeader();\n+        TableColumnModel colMod = header.getColumnModel();\n+        for (int i = 0; i < colMod.getColumnCount(); i++) {\n+            TableColumn tabCol = colMod.getColumn(i);\n+            String headerText = mekModel.getColumnName(i);\n+            // Add info about the current sorting\n+            if (activeSorter.getColumnIndex() == i) {\n+                headerText += \"&nbsp;&nbsp;&nbsp;\" + guiScaledFontHTML(uiGray());\n+                if (activeSorter.getSortingDirection() == MekTableSorter.Sorting.ASCENDING) {\n+                    headerText += \"\\u25B4 \";    \n+                } else {\n+                    headerText += \"\\u25BE \";\n+                }\n+                headerText += activeSorter.getDisplayName();\n+            }\n+            tabCol.setHeaderValue(headerText);\n+        }\n+        header.repaint();\n+        \n+        // The player table\n+        header = tablePlayers.getTableHeader();\n+        colMod = header.getColumnModel();\n+        for (int i = 0; i < colMod.getColumnCount(); i++) {\n+            TableColumn tabCol = colMod.getColumn(i);\n+            tabCol.setHeaderValue(playerModel.getColumnName(i));\n+        }\n+        header.repaint();\n+    }\n+\n+    /** Returns the owner of the given entity. Should be used over entity.getowner(). */\n+    private IPlayer ownerOf(Entity entity) {\n+        return clientgui.getClient().getGame().getPlayer(entity.getOwnerId());\n+    }\n+    \n+    /** Sets the column width of the given table column of the MekTable with the value stored in the GUIP. */\n+    private void setColumnWidth(TableColumn column) {\n+        String key;\n+        if (column.getModelIndex() == MekTableModel.COL_PILOT) {\n+            key = GUIPreferences.LOBBY_MEKTABLE_PILOT_WIDTH;\n+        } else if (column.getModelIndex() == MekTableModel.COL_UNIT) {\n+            key = GUIPreferences.LOBBY_MEKTABLE_UNIT_WIDTH;\n+        } else if (column.getModelIndex() == MekTableModel.COL_PLAYER) {\n+            key = GUIPreferences.LOBBY_MEKTABLE_PLAYER_WIDTH;\n+        } else if (column.getModelIndex() == MekTableModel.COL_BV) {\n+            key = GUIPreferences.LOBBY_MEKTABLE_BV_WIDTH;\n+        } else {\n+            return;\n+        }\n+        column.setPreferredWidth(GUIPreferences.getInstance().getInt(key));\n+    }\n+    \n+    /** Adapts the whole Lobby UI (both panels) to the current guiScale. */\n+    private void adaptToGUIScale() {\n+        updateTableHeaders();\n+        setTableRowHeights();\n+        refreshLabels();\n+        refreshCamoButton();\n+        refreshMapButtons();\n+        mekModel.refreshCells();\n+        panTeamOverview.adaptToGUIScale();\n+\n+        Font scaledFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1));\n+        Font scaledBigFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1 + 3));\n+\n+        butCompact.setFont(scaledFont);\n+        butOptions.setFont(scaledBigFont);\n+        butLoadList.setFont(scaledFont);\n+        butSaveList.setFont(scaledFont);\n+        butSkills.setFont(scaledFont);\n+        butNames.setFont(scaledFont);\n+        butAddBot.setFont(scaledFont);\n+        butRemoveBot.setFont(scaledFont);\n+        butConfigPlayer.setFont(scaledFont);\n+        butBotSettings.setFont(scaledFont);\n+        butShowUnitID.setFont(scaledFont);\n+        butConditions.setFont(scaledFont);\n+        butRandomMap.setFont(scaledFont);\n+        butSpaceSize.setFont(scaledFont);\n+        butBoardPreview.setFont(scaledFont);\n+        butAddX.setFont(scaledFont);\n+        butAddY.setFont(scaledFont);\n+        comMapSizes.setFont(scaledFont);\n+        comboTeam.setFont(scaledFont);\n+        lblBoardsAvailable.setFont(scaledFont);\n+        lblMapWidth.setFont(scaledFont);\n+        butMapGrowW.setFont(scaledFont);\n+        butMapShrinkW.setFont(scaledFont);\n+        fldMapWidth.setFont(scaledFont);\n+        lblMapHeight.setFont(scaledFont);\n+        butMapGrowH.setFont(scaledFont);\n+        butMapShrinkH.setFont(scaledFont);\n+        fldMapHeight.setFont(scaledFont);\n+        lblSpaceBoardWidth.setFont(scaledFont);\n+        lblSpaceBoardHeight.setFont(scaledFont);\n+        fldSpaceBoardWidth.setFont(scaledFont);\n+        fldSpaceBoardHeight.setFont(scaledFont);\n+        butGroundMap.setFont(scaledFont);\n+        butLowAtmoMap.setFont(scaledFont);\n+        butHighAtmoMap.setFont(scaledFont);\n+        butSpaceMap.setFont(scaledFont);\n+        lblBoardSize.setFont(scaledFont);\n+        butSaveMapSetup.setFont(scaledFont);\n+        butLoadMapSetup.setFont(scaledFont);\n+        butDetach.setFont(scaledFont);\n+        butCancelSearch.setFont(scaledFont);\n+        butListView.setFont(scaledFont);\n+        butForceView.setFont(scaledFont);\n+        butCollapse.setFont(scaledFont);\n+        butExpand.setFont(scaledFont);\n+        \n+        butAdd.setFont(scaledBigFont);\n+        butArmy.setFont(scaledBigFont);\n+        panTabs.setFont(scaledBigFont);\n+        \n+        lblSearch.setFont(scaledFont);\n+        fldSearch.setFont(scaledFont);\n+        \n+        ((TitledBorder)panUnitInfo.getBorder()).setTitleFont(scaledFont);\n+        ((TitledBorder)panPlayerInfo.getBorder()).setTitleFont(scaledFont);\n+        \n+        int scaledBorder = UIUtil.scaleForGUI(TEAMOVERVIEW_BORDER);\n+        panTeam.setBorder(new EmptyBorder(scaledBorder, scaledBorder, scaledBorder, scaledBorder));\n+\n+        butBoardPreview.setToolTipText(scaleMessageForGUI(\"BoardSelectionDialog.ViewGameBoardTooltip\"));\n+        butSaveMapSetup.setToolTipText(scaleMessageForGUI(\"ChatLounge.map.saveMapSetupTip\"));\n+        \n+        Font scaledHelpFont = new Font(\"Dialog\", Font.PLAIN, UIUtil.scaleForGUI(UIUtil.FONT_SCALE1 + 33));\n+        butHelp.setFont(scaledHelpFont);\n+\n+        // Makes a new tooltip appear immediately (rescaled and possibly for a different unit)\n+        ToolTipManager manager = ToolTipManager.sharedInstance();\n+        long time = System.currentTimeMillis() - manager.getInitialDelay() + 1;\n+        Point locationOnScreen = MouseInfo.getPointerInfo().getLocation();\n+        Point locationOnComponent = new Point(locationOnScreen);\n+        SwingUtilities.convertPointFromScreen(locationOnComponent, mekTable);\n+        MouseEvent event = new MouseEvent(mekTable, -1, time, 0, \n+                locationOnComponent.x, locationOnComponent.y, 0, 0, 1, false, 0);\n+        manager.mouseMoved(event);\n+    }\n+    \n+    /** \n+     * Mouse Listener for the table header of the Mek Table.\n+     * Saves column widths of the Mek Table when the mouse button is released. \n+     * Also switches between table sorting types\n+     */\n+    MouseListener mekTableHeaderMouseListener = new MouseAdapter()\n+    {\n+        private void changeSorter(MouseEvent e)\n+        {\n+            // Save table widths\n+            for (int i = 0; i < MekTableModel.N_COL; i++) {\n+                TableColumn column = mekTable.getColumnModel().getColumn(i);\n+                String key;\n+                if (column.getModelIndex() == MekTableModel.COL_PILOT) {\n+                    key = GUIPreferences.LOBBY_MEKTABLE_PILOT_WIDTH;\n+                } else if (column.getModelIndex() == MekTableModel.COL_UNIT) {\n+                    key = GUIPreferences.LOBBY_MEKTABLE_UNIT_WIDTH;\n+                } else if (column.getModelIndex() == MekTableModel.COL_PLAYER) {\n+                    key = GUIPreferences.LOBBY_MEKTABLE_PLAYER_WIDTH;\n+                } else if (column.getModelIndex() == MekTableModel.COL_BV) {\n+                    key = GUIPreferences.LOBBY_MEKTABLE_BV_WIDTH;\n+                } else {\n+                    continue;\n+                }\n+                GUIPreferences.getInstance().setValue(key, column.getWidth());\n+            }\n+            \n+            changeMekTableSorter(e);\n+        }\n+        \n+        @Override\n+        public void mouseReleased(MouseEvent e) {\n+            if (e.isPopupTrigger()) {\n+                e.consume();\n+                sorterPopup(e);\n+            } else {\n+                changeSorter(e);\n+            }\n+        };\n+        \n+        private void sorterPopup(MouseEvent e) {\n+            ScalingPopup popup = new ScalingPopup();\n+            GameOptions opts = clientgui.getClient().getGame().getOptions();\n+            for (MekTableSorter sorter: union(unitSorters, bvSorters)) {\n+                // Offer only allowed sorters and only one sorting direction\n+                if (sorter.isAllowed(opts) && sorter.getSortingDirection() != Sorting.ASCENDING) {\n+                    JMenuItem item = new JMenuItem(sorter.getDisplayName());\n+                    item.addActionListener(mekTableHeaderAListener);\n+                    item.setActionCommand(sorter.getDisplayName());\n+                    popup.add(item);\n+                }\n+            }\n+            popup.show(e.getComponent(), e.getX(), e.getY());\n+        }\n+\n+    };\n+    \n+    /**\n+     * Sets the sorting used in the Mek Table depending on the column header \n+     * that was clicked.  \n+     */ \n+    private void changeMekTableSorter(MouseEvent e) {\n+        int col = mekTable.columnAtPoint(e.getPoint());\n+        MekTableSorter previousSorter = activeSorter;\n+        List<MekTableSorter> sorters;\n+        \n+        // find the right list of sorters (or do nothing, if the column is not sortable)\n+        if (col == MekTableModel.COL_UNIT) {\n+            sorters = unitSorters;\n+        } else if (col == MekTableModel.COL_BV) {\n+            sorters = bvSorters;\n+        } else {\n+            return;\n+        }\n+        \n+        // Select the next allowed sorter and refresh the display if the sorter was changed\n+        nextSorter(sorters);\n+        if (activeSorter != previousSorter) {\n+            refreshMekTable();\n+            updateTableHeaders();\n+        }\n+    }\n+    \n+    /** Selects the next allowed sorter in the given list of sorters. */\n+    private void nextSorter(List<MekTableSorter> sorters) {\n+        // Set the next sorter as active, if this column was already sorted, or\n+        // the first sorter otherwise\n+        int index = sorters.indexOf(activeSorter);\n+        if (index == -1) {\n+            activeSorter = sorters.get(0);\n+        } else {\n+            index = (index + 1) % sorters.size();\n+            activeSorter = sorters.get(index);\n+        }\n+        \n+        // Find an allowed sorter (e.g. blind drop may prohibit some)\n+        int counter = 0; // Endless loop safeguard\n+        while (!activeSorter.isAllowed(clientgui.getClient().getGame().getOptions())\n+                && ++counter < 100) {\n+            index = (index + 1) % sorters.size();\n+            activeSorter = sorters.get(index);\n+        }\n+    }\n+\n+    /** Returns true when the compact view is active. */ \n+    public boolean isCompact() {\n+        return butCompact.isSelected();\n+    }\n+    \n+    /** \n+     * Returns a list of the selected entities in the Mek table. \n+     * The list may be empty but not null. \n+     */\n+    private ArrayList<Entity> getSelectedEntities() {\n+        ArrayList<Entity> result = new ArrayList<>();\n+        int[] rows = mekTable.getSelectedRows();\n+        for (int i = 0; i < rows.length; i++) {\n+            result.add(mekModel.getEntityAt(rows[i]));\n+        }\n+        return result;\n+    }\n+    \n+    /** Helper method to shorten calls. */\n+    IPlayer localPlayer() {\n+        return clientgui.getClient().getLocalPlayer();\n+    }\n+    \n+    private void redrawMapTable(Image image) {\n+        if (image != null) {\n+            if (lisBoardsAvailable.getFixedCellHeight() != image.getHeight(null) \n+                    || lisBoardsAvailable.getFixedCellWidth() != image.getWidth(null)) {\n+                lisBoardsAvailable.setFixedCellHeight(image.getHeight(null));\n+                lisBoardsAvailable.setFixedCellWidth(image.getWidth(null));\n+            }\n+            lisBoardsAvailable.repaint();\n+        }\n+    }\n+    \n+\n+    class ImageLoader extends SwingWorker<Void, Image> {\n+\n+        private BlockingQueue<String> boards = new LinkedBlockingQueue<String>();\n+\n+        private synchronized void add(String name) {\n+            if (!boards.contains(name)) {\n+                try {\n+                    boards.put(name);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+        \n+        private Image prepareImage(String boardName) {\n+            File boardFile = new MegaMekFile(Configuration.boardsDir(), boardName + \".board\").getFile();\n+            IBoard board;\n+            StringBuffer errs = new StringBuffer();\n+            if (boardFile.exists()) {\n+                board = new Board();\n+                try (InputStream is = new FileInputStream(boardFile)) {\n+                    board.load(is, errs, true);\n+                } catch (IOException ex) {\n+                    board = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+                }\n+            } else {\n+                board = Board.createEmptyBoard(mapSettings.getBoardWidth(), mapSettings.getBoardHeight());\n+            }\n+\n+            // Determine a minimap zoom from the board size and gui scale.\n+            // This is very magic numbers but currently the minimap has only fixed zoom states.\n+            int largerEdge = Math.max(board.getWidth(), board.getHeight());\n+            int zoom = 3;\n+            if (largerEdge < 17) {\n+                zoom = 4;\n+            }\n+            if (largerEdge > 20) {\n+                zoom = 2;\n+            }\n+            if (largerEdge > 30) {\n+                zoom = 1;\n+            }\n+            if (largerEdge > 40) {\n+                zoom = 0;\n+            }\n+            float scale = GUIPreferences.getInstance().getGUIScale();\n+            zoom = (int)(scale*zoom);\n+            if (zoom > 6) {\n+                zoom = 6;\n+            }\n+            if (zoom < 0) {\n+                zoom = 0;\n+            }\n+            BufferedImage bufImage = MiniMap.getBoardMinimapImage(board, zoom);\n+\n+            // Add the board name label and the server-side board label if necessary\n+            String text = LobbyUtility.cleanBoardName(boardName, mapSettings);\n+            Graphics g = bufImage.getGraphics();\n+            if (errs.length() != 0) {\n+                invalidBoards.add(boardName);\n+            }\n+            drawMinimapLabel(text, bufImage.getWidth(), bufImage.getHeight(), g, errs.length() != 0);\n+            if (!boardFile.exists() && !boardName.startsWith(MapSettings.BOARD_GENERATED)) {\n+                serverBoards.add(boardName);\n+                markServerSideBoard(bufImage);\n+            }\n+            g.dispose();\n+\n+            synchronized(baseImages) {\n+                baseImages.put(boardName, bufImage);\n+            }\n+            return bufImage;\n+        }\n+\n+\n+        @Override\n+        protected Void doInBackground() throws Exception {\n+            Image image;\n+            while (!isCancelled()) {\n+                String boardName = boards.poll(1, TimeUnit.SECONDS);\n+                if (boardName != null && !baseImages.containsKey(boardName)) {\n+                    image = prepareImage(boardName);\n+                    ChatLounge.this.redrawMapTable(image);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    Map<String, ImageIcon> mapIcons = new HashMap<String, ImageIcon>();\n+    \n+    /** A renderer for the list of available boards. */\n+    public class BoardNameRenderer extends DefaultListCellRenderer  {\n+        private static final long serialVersionUID = -3218595828938299222L;\n+        \n+        private float oldGUIScale = GUIPreferences.getInstance().getGUIScale();\n+        private Image image;\n+        private ImageIcon icon;\n+        \n+        @Override\n+        public Component getListCellRendererComponent(JList<?> list, Object value, \n+                int index, boolean isSelected, boolean cellHasFocus) {\n+\n+            String board = (String)value;\n+            // For generated boards, add the size to have different images for different sizes\n+            if (board.startsWith(MapSettings.BOARD_GENERATED)) {\n+                board += mapSettings.getBoardSize().toString();\n+            }\n+            \n+            // If the gui scaling has changed, clear out all images, triggering a reload\n+            float currentGUIScale = GUIPreferences.getInstance().getGUIScale();\n+            if (currentGUIScale != oldGUIScale) {\n+                oldGUIScale = currentGUIScale;\n+                mapIcons.clear();\n+                synchronized (baseImages) {\n+                    baseImages.clear();\n+                }\n+            }\n+            \n+            // If an icon is present for the current board, use it\n+            icon = mapIcons.get(board);\n+            if (icon != null) {\n+                setIcon(icon);\n+            } else {\n+                // The icon is not present, see if there's a base image\n+                synchronized (baseImages) {\n+                    image = baseImages.get(board);\n+                }\n+                if (image == null) {\n+                    // There's no base image: trigger loading it and, for now, return the base list's panel\n+                    // The [GENERATED] entry will always land here as well\n+                    loader.add(board);\n+                    setToolTipText(null);\n+                    return super.getListCellRendererComponent(list, new File(board).getName(), index, isSelected, cellHasFocus);\n+                } else {\n+                    // There is a base image: make it into an icon, store it and use it\n+                    if (!lisBoardsAvailable.isEnabled()) {\n+                        ImageFilter filter = new GrayFilter(true, 50);  \n+                        ImageProducer producer = new FilteredImageSource(image.getSource(), filter);  \n+                        image = Toolkit.getDefaultToolkit().createImage(producer); \n+                    }\n+                    icon = new ImageIcon(image);\n+                    \n+                    mapIcons.put(board, icon);\n+                    setIcon(icon);\n+                }\n+            }\n+            \n+            // Found or created an icon; finish the panel\n+            setText(\"\");", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTM1NjA2OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r615356068", "bodyText": "When an icon isn't there, the super renderer result is returned a few lines above. This will set the text, so it has to be reset when an icon is found and used (otherwise, the text of a first list entry will stay present for all subsequently rendered list entries, sorry if that overexplains).", "author": "SJuliez", "createdAt": "2021-04-18T07:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MDA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MjIxNw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612092217", "bodyText": "Magic strings", "author": "NickAragua", "createdAt": "2021-04-13T02:56:21Z", "path": "megamek/src/megamek/client/ui/swing/lobby/LobbyActions.java", "diffHunk": "@@ -0,0 +1,1312 @@\n+/*  \r\n+ * MegaMek - Copyright (C) 2021 - The MegaMek Team  \r\n+ *  \r\n+ * listener program is free software; you can redistribute it and/or modify it under  \r\n+ * the terms of the GNU General Public License as published by the Free Software  \r\n+ * Foundation; either version 2 of the License, or (at your option) any later  \r\n+ * version.  \r\n+ *  \r\n+ * listener program is distributed in the hope that it will be useful, but WITHOUT  \r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+ * details.  \r\n+ */ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import java.awt.Dimension;\r\n+import java.util.*;\r\n+import java.util.Map.Entry;\r\n+import javax.swing.JFrame;\r\n+import javax.swing.JOptionPane;\r\n+\r\n+import megamek.MegaMek;\r\n+import megamek.client.Client;\r\n+import megamek.client.generator.*;\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.*;\r\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\r\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\r\n+import megamek.common.*;\r\n+import megamek.common.enums.Gender;\r\n+import megamek.common.force.Force;\r\n+import megamek.common.force.Forces;\r\n+import megamek.common.icons.Camouflage;\r\n+import megamek.common.options.OptionsConstants;\r\n+import megamek.common.util.CollectionUtil;\r\n+\r\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\r\n+import static java.util.stream.Collectors.*;\r\n+\r\n+/** This class contains the methods that perform entity and force changes from the pop-up menu and elsewhere. */\r\n+public class LobbyActions {\r\n+\r\n+    private final ChatLounge lobby;\r\n+\r\n+    private String cmdSelectedTab = null;   // TODO: required?\r\n+\r\n+    /** This class contains the methods that perform entity and force changes from the pop-up menu and elsewhere. */\r\n+    LobbyActions(ChatLounge cl) {\r\n+        lobby = cl;\r\n+    }\r\n+\r\n+    /** Sets a deployment round for the given entities. Sends an update to the server. */ \r\n+    void applyDeployment(Collection<Entity> entities, int newRound) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.getDeployRound() != newRound) {\r\n+                entity.setDeployRound(newRound);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets starting heat for the given entities. Sends an update to the server. */\r\n+    void applyHeat(Collection<Entity> entities, int heat) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> !e.tracksHeat())) {\r\n+            LobbyErrors.showHeatTracking(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.getHeat() != heat) {\r\n+                entity.heat = heat;\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets/removes hidden deployment for the given entities. Sends an update to the server. */\r\n+    void applyHidden(Collection<Entity> entities, boolean newHidden) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.isHidden() != newHidden) {\r\n+                entity.setHidden(newHidden);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets deploy prone for the given entities. Sends an update to the server. */\r\n+    void applyProne(Collection<Entity> entities, String info) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> e.getUnitType() != UnitType.MEK)) {\r\n+            LobbyErrors.showOnlyMeks(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        boolean goProne = info.equals(\"PRONE\");\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MjUwMQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612092501", "bodyText": "Random?", "author": "NickAragua", "createdAt": "2021-04-13T02:57:14Z", "path": "megamek/src/megamek/client/ui/swing/lobby/LobbyActions.java", "diffHunk": "@@ -0,0 +1,1312 @@\n+/*  \r\n+ * MegaMek - Copyright (C) 2021 - The MegaMek Team  \r\n+ *  \r\n+ * listener program is free software; you can redistribute it and/or modify it under  \r\n+ * the terms of the GNU General Public License as published by the Free Software  \r\n+ * Foundation; either version 2 of the License, or (at your option) any later  \r\n+ * version.  \r\n+ *  \r\n+ * listener program is distributed in the hope that it will be useful, but WITHOUT  \r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+ * details.  \r\n+ */ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import java.awt.Dimension;\r\n+import java.util.*;\r\n+import java.util.Map.Entry;\r\n+import javax.swing.JFrame;\r\n+import javax.swing.JOptionPane;\r\n+\r\n+import megamek.MegaMek;\r\n+import megamek.client.Client;\r\n+import megamek.client.generator.*;\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.*;\r\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\r\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\r\n+import megamek.common.*;\r\n+import megamek.common.enums.Gender;\r\n+import megamek.common.force.Force;\r\n+import megamek.common.force.Forces;\r\n+import megamek.common.icons.Camouflage;\r\n+import megamek.common.options.OptionsConstants;\r\n+import megamek.common.util.CollectionUtil;\r\n+\r\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\r\n+import static java.util.stream.Collectors.*;\r\n+\r\n+/** This class contains the methods that perform entity and force changes from the pop-up menu and elsewhere. */\r\n+public class LobbyActions {\r\n+\r\n+    private final ChatLounge lobby;\r\n+\r\n+    private String cmdSelectedTab = null;   // TODO: required?\r\n+\r\n+    /** This class contains the methods that perform entity and force changes from the pop-up menu and elsewhere. */\r\n+    LobbyActions(ChatLounge cl) {\r\n+        lobby = cl;\r\n+    }\r\n+\r\n+    /** Sets a deployment round for the given entities. Sends an update to the server. */ \r\n+    void applyDeployment(Collection<Entity> entities, int newRound) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.getDeployRound() != newRound) {\r\n+                entity.setDeployRound(newRound);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets starting heat for the given entities. Sends an update to the server. */\r\n+    void applyHeat(Collection<Entity> entities, int heat) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> !e.tracksHeat())) {\r\n+            LobbyErrors.showHeatTracking(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.getHeat() != heat) {\r\n+                entity.heat = heat;\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets/removes hidden deployment for the given entities. Sends an update to the server. */\r\n+    void applyHidden(Collection<Entity> entities, boolean newHidden) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.isHidden() != newHidden) {\r\n+                entity.setHidden(newHidden);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets deploy prone for the given entities. Sends an update to the server. */\r\n+    void applyProne(Collection<Entity> entities, String info) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> e.getUnitType() != UnitType.MEK)) {\r\n+            LobbyErrors.showOnlyMeks(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        boolean goProne = info.equals(\"PRONE\");\r\n+        boolean goHullDown = info.equals(\"HULLDOWN\");\r\n+        boolean stand = !goProne && !goHullDown;\r\n+        for (Entity entity: entities) {\r\n+            if ((goProne && !entity.isProne()) || (goHullDown && !entity.isHullDown())\r\n+                    || (stand && (entity.isProne() || entity.isHullDown()))) {\r\n+                entity.setProne(goProne);\r\n+                entity.setHullDown(goHullDown);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Attaches the given force as a subforce to the given new parent. \r\n+     * Does NOT work for newParentId == NO_FORCE. Use promoteForce to do this.\r\n+     * Does not allow attaching a force to one of its own subforces.\r\n+     */\r\n+    void forceAttach(int forceId, int newParentId) {\r\n+        Forces forces = game().getForces();\r\n+        if (!forces.contains(forceId) || !forces.contains(newParentId)\r\n+                || (forceId == newParentId)) {\r\n+            return;\r\n+        }\r\n+        \r\n+        Force force = forces.getForce(forceId);\r\n+        Force newParent = forces.getForce(newParentId);\r\n+        List<Force> subForces = forces.getFullSubForces(force);\r\n+        IPlayer owner = forces.getOwner(force);\r\n+        IPlayer newParentOwner = forces.getOwner(newParent);\r\n+            \r\n+        if (owner.isEnemyOf(newParentOwner)) {\r\n+            LobbyErrors.showOnlyTeam(frame());;\r\n+            return;\r\n+        }\r\n+        if (subForces.contains(newParent)) {\r\n+            LobbyErrors.showForceNoAttachSubForce(frame());\r\n+            return;\r\n+        }\r\n+        if (!isEditable(force)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        var forceList = new ArrayList<Force>(List.of(force));\r\n+        client().sendForceParent(forceList, newParentId);\r\n+    }\r\n+    \r\n+\r\n+    /**\r\n+     * Makes the given forces top-level, detaching them from any former parents. \r\n+     */\r\n+    void forcePromote(Collection<Integer> forceIds) {\r\n+        var forces = game().getForces();\r\n+        if (forceIds.stream().anyMatch(id -> !forces.contains(id))) {\r\n+            return;\r\n+        }\r\n+        Set<Force> forceList = forceIds.stream().map(id -> forces.getForce(id)).collect(toSet());\r\n+        if (!areForcesEditable(forceList)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        client().sendForceParent(forceList, Force.NO_FORCE);\r\n+    }\r\n+\r\n+    /** Shows the dialog which allows adding pre-existing damage to units. */\r\n+    void configureDamage(Collection<Entity> entities) {\r\n+        if (entities.size() != 1) {\r\n+            LobbyErrors.showSingleUnit(frame(), \"assign damage\");\r\n+            return;\r\n+        }\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Entity entity = CollectionUtil.randomElement(entities);\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTM1NzI3OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r615357279", "bodyText": "Here and at other places, I wanted to receive Collections instead of lists (as discussed above), especially as the order of the selected entities shouldnt play any role. When the collection has only 1 element its still bothersome to get that element, therefore I used that method. Sometimes I used it with multiple entities to find any single one, e.g. to find one owner. I think I'll rename it to anyOneElement or something like that as it really has nothing to do with random.", "author": "SJuliez", "createdAt": "2021-04-18T07:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MzIyNA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612093224", "bodyText": "This method seems familiar, I'm pretty sure I saw it in the ChatLounge class", "author": "NickAragua", "createdAt": "2021-04-13T02:59:27Z", "path": "megamek/src/megamek/client/ui/swing/lobby/LobbyActions.java", "diffHunk": "@@ -0,0 +1,1312 @@\n+/*  \r\n+ * MegaMek - Copyright (C) 2021 - The MegaMek Team  \r\n+ *  \r\n+ * listener program is free software; you can redistribute it and/or modify it under  \r\n+ * the terms of the GNU General Public License as published by the Free Software  \r\n+ * Foundation; either version 2 of the License, or (at your option) any later  \r\n+ * version.  \r\n+ *  \r\n+ * listener program is distributed in the hope that it will be useful, but WITHOUT  \r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+ * details.  \r\n+ */ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import java.awt.Dimension;\r\n+import java.util.*;\r\n+import java.util.Map.Entry;\r\n+import javax.swing.JFrame;\r\n+import javax.swing.JOptionPane;\r\n+\r\n+import megamek.MegaMek;\r\n+import megamek.client.Client;\r\n+import megamek.client.generator.*;\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.*;\r\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\r\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\r\n+import megamek.common.*;\r\n+import megamek.common.enums.Gender;\r\n+import megamek.common.force.Force;\r\n+import megamek.common.force.Forces;\r\n+import megamek.common.icons.Camouflage;\r\n+import megamek.common.options.OptionsConstants;\r\n+import megamek.common.util.CollectionUtil;\r\n+\r\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\r\n+import static java.util.stream.Collectors.*;\r\n+\r\n+/** This class contains the methods that perform entity and force changes from the pop-up menu and elsewhere. */\r\n+public class LobbyActions {\r\n+\r\n+    private final ChatLounge lobby;\r\n+\r\n+    private String cmdSelectedTab = null;   // TODO: required?\r\n+\r\n+    /** This class contains the methods that perform entity and force changes from the pop-up menu and elsewhere. */\r\n+    LobbyActions(ChatLounge cl) {\r\n+        lobby = cl;\r\n+    }\r\n+\r\n+    /** Sets a deployment round for the given entities. Sends an update to the server. */ \r\n+    void applyDeployment(Collection<Entity> entities, int newRound) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.getDeployRound() != newRound) {\r\n+                entity.setDeployRound(newRound);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets starting heat for the given entities. Sends an update to the server. */\r\n+    void applyHeat(Collection<Entity> entities, int heat) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> !e.tracksHeat())) {\r\n+            LobbyErrors.showHeatTracking(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.getHeat() != heat) {\r\n+                entity.heat = heat;\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets/removes hidden deployment for the given entities. Sends an update to the server. */\r\n+    void applyHidden(Collection<Entity> entities, boolean newHidden) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.isHidden() != newHidden) {\r\n+                entity.setHidden(newHidden);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets deploy prone for the given entities. Sends an update to the server. */\r\n+    void applyProne(Collection<Entity> entities, String info) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> e.getUnitType() != UnitType.MEK)) {\r\n+            LobbyErrors.showOnlyMeks(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        boolean goProne = info.equals(\"PRONE\");\r\n+        boolean goHullDown = info.equals(\"HULLDOWN\");\r\n+        boolean stand = !goProne && !goHullDown;\r\n+        for (Entity entity: entities) {\r\n+            if ((goProne && !entity.isProne()) || (goHullDown && !entity.isHullDown())\r\n+                    || (stand && (entity.isProne() || entity.isHullDown()))) {\r\n+                entity.setProne(goProne);\r\n+                entity.setHullDown(goHullDown);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Attaches the given force as a subforce to the given new parent. \r\n+     * Does NOT work for newParentId == NO_FORCE. Use promoteForce to do this.\r\n+     * Does not allow attaching a force to one of its own subforces.\r\n+     */\r\n+    void forceAttach(int forceId, int newParentId) {\r\n+        Forces forces = game().getForces();\r\n+        if (!forces.contains(forceId) || !forces.contains(newParentId)\r\n+                || (forceId == newParentId)) {\r\n+            return;\r\n+        }\r\n+        \r\n+        Force force = forces.getForce(forceId);\r\n+        Force newParent = forces.getForce(newParentId);\r\n+        List<Force> subForces = forces.getFullSubForces(force);\r\n+        IPlayer owner = forces.getOwner(force);\r\n+        IPlayer newParentOwner = forces.getOwner(newParent);\r\n+            \r\n+        if (owner.isEnemyOf(newParentOwner)) {\r\n+            LobbyErrors.showOnlyTeam(frame());;\r\n+            return;\r\n+        }\r\n+        if (subForces.contains(newParent)) {\r\n+            LobbyErrors.showForceNoAttachSubForce(frame());\r\n+            return;\r\n+        }\r\n+        if (!isEditable(force)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        var forceList = new ArrayList<Force>(List.of(force));\r\n+        client().sendForceParent(forceList, newParentId);\r\n+    }\r\n+    \r\n+\r\n+    /**\r\n+     * Makes the given forces top-level, detaching them from any former parents. \r\n+     */\r\n+    void forcePromote(Collection<Integer> forceIds) {\r\n+        var forces = game().getForces();\r\n+        if (forceIds.stream().anyMatch(id -> !forces.contains(id))) {\r\n+            return;\r\n+        }\r\n+        Set<Force> forceList = forceIds.stream().map(id -> forces.getForce(id)).collect(toSet());\r\n+        if (!areForcesEditable(forceList)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        client().sendForceParent(forceList, Force.NO_FORCE);\r\n+    }\r\n+\r\n+    /** Shows the dialog which allows adding pre-existing damage to units. */\r\n+    void configureDamage(Collection<Entity> entities) {\r\n+        if (entities.size() != 1) {\r\n+            LobbyErrors.showSingleUnit(frame(), \"assign damage\");\r\n+            return;\r\n+        }\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Entity entity = CollectionUtil.randomElement(entities);\r\n+        UnitEditorDialog med = new UnitEditorDialog(frame(), entity);\r\n+        med.setVisible(true);\r\n+        sendUpdates(entities);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Moves a force or entity within another force by one position. If up is true,\r\n+     * moves upward, otherwise downward. \r\n+     */\r\n+    void forceMove(Collection<Force> forceList, Collection<Entity> entityList, boolean up) {\r\n+        // May only move a single force or a single entity\r\n+        if (forceList.size() + entityList.size() != 1) {\r\n+            LobbyErrors.showOnlySingleEntityOrForce(frame());\r\n+            return;\r\n+        }\r\n+        if (!entityList.isEmpty() && !validateUpdate(entityList)) {\r\n+            return;\r\n+        }\r\n+        if (!forceList.isEmpty() && !areForcesEditable(forceList)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        var forces = game().getForces();\r\n+        var changedForce = new HashSet<Force>(); \r\n+        if (up) {\r\n+            if (!forceList.isEmpty()) {\r\n+                changedForce.addAll(forces.moveUp(CollectionUtil.randomElement(forceList)));\r\n+            } else if (!entityList.isEmpty()) {\r\n+                changedForce.addAll(forces.moveUp(CollectionUtil.randomElement(entityList)));\r\n+            }\r\n+        } else {\r\n+            if (!forceList.isEmpty()) {\r\n+                changedForce.addAll(forces.moveDown(CollectionUtil.randomElement(forceList)));\r\n+            } else if (!entityList.isEmpty()) {\r\n+                changedForce.addAll(forces.moveDown(CollectionUtil.randomElement(entityList)));\r\n+            }\r\n+        }\r\n+\r\n+        if (!changedForce.isEmpty()) {\r\n+            client().sendUpdateForce(changedForce);\r\n+        }\r\n+    }\r\n+    \r\n+    /** \r\n+     * Displays a CamoChooser to choose an individual camo for the given entities. \r\n+     * The camo will only be applied to units configurable by the local player, \r\n+     * i.e. his own units or those of his bots.\r\n+     */\r\n+    public void individualCamo(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Display the CamoChooser and await the result\r\n+        // The dialog is preset to a random entity's settings\r\n+        Entity entity = CollectionUtil.randomElement(entities);\r\n+        CamoChooserDialog ccd = new CamoChooserDialog(frame(), entity.getOwner().getCamouflage());\r\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Choosing the player camo resets the units to have no individual camo.\r\n+        Camouflage selectedItem = ccd.getSelectedItem();\r\n+        Camouflage ownerCamo = entity.getOwner().getCamouflage();\r\n+        boolean noIndividualCamo = selectedItem.equals(ownerCamo);\r\n+\r\n+        // Update all allowed entities with the camo\r\n+        for (Entity ent: entities) {\r\n+            if (noIndividualCamo) {\r\n+                ent.setCamouflage(ownerCamo);\r\n+            } else {\r\n+                ent.setCamouflage(selectedItem);\r\n+            }\r\n+        }\r\n+        sendUpdates(entities);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure multiple entities at once. Only affects deployment options.\r\n+     */\r\n+    public void customizeMechs(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (!haveSingleOwner(entities)) {\r\n+            LobbyErrors.showSingleOwnerRequired(frame());\r\n+            return;\r\n+        }\r\n+        Entity randomSelected = CollectionUtil.randomElement(entities);\r\n+        String ownerName = randomSelected.getOwner().getName();\r\n+        int ownerId = randomSelected.getOwner().getId();\r\n+\r\n+        boolean editable = client().bots.get(ownerName) != null;\r\n+        Client client;\r\n+        if (editable) {\r\n+            client = client().bots.get(ownerName);\r\n+        } else {\r\n+            editable |= ownerId == localPlayer().getId();\r\n+            client = client();\r\n+        }\r\n+\r\n+        CustomMechDialog cmd = new CustomMechDialog(lobby.getClientgui(), client, new ArrayList<>(entities), editable);\r\n+        cmd.setSize(new Dimension(GUIPreferences.getInstance().getCustomUnitWidth(),\r\n+                GUIPreferences.getInstance().getCustomUnitHeight()));\r\n+        cmd.setTitle(Messages.getString(\"ChatLounge.CustomizeUnits\")); \r\n+        cmd.setVisible(true);\r\n+        GUIPreferences.getInstance().setCustomUnitHeight(cmd.getSize().height);\r\n+        GUIPreferences.getInstance().setCustomUnitWidth(cmd.getSize().width);\r\n+        if (editable && cmd.isOkay()) {\r\n+            // send changes\r\n+            for (Entity entity : entities) {\r\n+                // If a LAM with mechanized BA was changed to non-mech mode, unload the BA.\r\n+                if ((entity instanceof LandAirMech)\r\n+                        && entity.getConversionMode() != LandAirMech.CONV_MODE_MECH) {\r\n+                    for (Entity loadee : entity.getLoadedUnits()) {\r\n+                        entity.unload(loadee);\r\n+                        loadee.setTransportId(Entity.NONE);\r\n+                        client().sendUpdateEntity(loadee);\r\n+                    }\r\n+                }\r\n+\r\n+                client().sendUpdateEntity(entity);\r\n+\r\n+                // Changing state to a transporting unit can update state of\r\n+                // transported units, so update those as well\r\n+                for (Transporter transport : entity.getTransports()) {\r\n+                    for (Entity loaded : transport.getLoadedUnits()) {\r\n+                        client().sendUpdateEntity(loaded);\r\n+                    }\r\n+                }\r\n+\r\n+                // Customizations to a Squadron can effect the fighters\r\n+                if (entity instanceof FighterSquadron) {\r\n+                    entity.getSubEntities().ifPresent(ents -> ents.forEach(client::sendUpdateEntity));\r\n+                }\r\n+            }\r\n+        }\r\n+        if (cmd.isOkay() && (cmd.getStatus() != CustomMechDialog.DONE)) {\r\n+            Entity nextEnt = cmd.getNextEntity(cmd.getStatus() == CustomMechDialog.NEXT);\r\n+            customizeMech(nextEnt);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     *\r\n+     * @param entity\r\n+     */\r\n+    public void customizeMech(Entity entity) {\r\n+        if (!validateUpdate(Arrays.asList(entity))) {\r\n+            return;\r\n+        }\r\n+        boolean editable = client().bots.get(entity.getOwner().getName()) != null;\r\n+        Client c;\r\n+        if (editable) {\r\n+            c = client().bots.get(entity.getOwner().getName());\r\n+        } else {\r\n+            editable |= entity.getOwnerId() == localPlayer().getId();\r\n+            c = client();\r\n+        }\r\n+        // When we customize a single entity's C3 network setting,\r\n+        // **ALL** members of the network may get changed.\r\n+        Entity c3master = entity.getC3Master();\r\n+        ArrayList<Entity> c3members = new ArrayList<>();\r\n+        Iterator<Entity> playerUnits = c.getGame().getPlayerEntities(c.getLocalPlayer(), false).iterator();\r\n+        while (playerUnits.hasNext()) {\r\n+            Entity unit = playerUnits.next();\r\n+            if (!entity.equals(unit) && entity.onSameC3NetworkAs(unit)) {\r\n+                c3members.add(unit);\r\n+            }\r\n+        }\r\n+\r\n+        boolean doneCustomizing = false;\r\n+        while (!doneCustomizing) {\r\n+            // display dialog\r\n+            List<Entity> entities = new ArrayList<>();\r\n+            entities.add(entity);\r\n+            CustomMechDialog cmd = new CustomMechDialog(lobby.getClientgui(), c, entities, editable);\r\n+            cmd.setSize(new Dimension(GUIPreferences.getInstance().getCustomUnitWidth(),\r\n+                    GUIPreferences.getInstance().getCustomUnitHeight()));\r\n+            cmd.refreshOptions();\r\n+            cmd.refreshQuirks();\r\n+            cmd.refreshPartReps();\r\n+            cmd.setTitle(entity.getShortName());\r\n+            if (cmdSelectedTab != null) {\r\n+                cmd.setSelectedTab(cmdSelectedTab);\r\n+            }\r\n+            cmd.setVisible(true);\r\n+            GUIPreferences.getInstance().setCustomUnitHeight(cmd.getSize().height);\r\n+            GUIPreferences.getInstance().setCustomUnitWidth(cmd.getSize().width);\r\n+            cmdSelectedTab = cmd.getSelectedTab();\r\n+            if (editable && cmd.isOkay()) {\r\n+                Set<Entity> updateCandidates = new HashSet<>();\r\n+                updateCandidates.add(entity);\r\n+                // If a LAM with mechanized BA was changed to non-mech mode, unload the BA.\r\n+                if ((entity instanceof LandAirMech)\r\n+                        && entity.getConversionMode() != LandAirMech.CONV_MODE_MECH) {\r\n+                    for (Entity loadee : entity.getLoadedUnits()) {\r\n+                        entity.unload(loadee);\r\n+                        loadee.setTransportId(Entity.NONE);\r\n+                        updateCandidates.add(loadee);\r\n+                    }\r\n+                }\r\n+\r\n+                // Changing state to a transporting unit can update state of\r\n+                // transported units, so update those as well\r\n+                for (Transporter transport : entity.getTransports()) {\r\n+                    for (Entity loaded : transport.getLoadedUnits()) {\r\n+                        updateCandidates.add(loaded);\r\n+                    }\r\n+                }\r\n+\r\n+                // Customizations to a Squadron can effect the fighters\r\n+                if (entity instanceof FighterSquadron) {\r\n+                    entity.getSubEntities().ifPresent(ents -> updateCandidates.addAll(ents));\r\n+                }\r\n+\r\n+                // Do we need to update the members of our C3 network?\r\n+                if (((c3master != null) && !c3master.equals(entity.getC3Master()))\r\n+                        || ((c3master == null) && (entity.getC3Master() != null))) {\r\n+                    for (Entity unit : c3members) {\r\n+                        updateCandidates.add(unit);\r\n+                    }\r\n+                }\r\n+                sendUpdates(updateCandidates);\r\n+            }\r\n+            if (cmd.isOkay() && (cmd.getStatus() != CustomMechDialog.DONE)) {\r\n+                entity = cmd.getNextEntity(cmd.getStatus() == CustomMechDialog.NEXT);\r\n+            } else {\r\n+                doneCustomizing = true;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /** \r\n+     * Sets random skills for the given entities, as far as they can\r\n+     * be configured by the local player. \r\n+     */\r\n+    void setRandomSkills(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        for (Entity e: entities) {\r\n+            Client c = lobby.getLocalClient(e);\r\n+            for (int i = 0; i < e.getCrew().getSlotCount(); i++) {\r\n+                int[] skills = c.getRandomSkillsGenerator().getRandomSkills(e, true);\r\n+                e.getCrew().setGunnery(skills[0], i);\r\n+                e.getCrew().setPiloting(skills[1], i);\r\n+                if (e.getCrew() instanceof LAMPilot) {\r\n+                    skills = c.getRandomSkillsGenerator().getRandomSkills(e, true);\r\n+                    ((LAMPilot) e.getCrew()).setGunneryAero(skills[0]);\r\n+                    ((LAMPilot) e.getCrew()).setPilotingAero(skills[1]);\r\n+                }\r\n+            }\r\n+            e.getCrew().sortRandomSkills();\r\n+        }\r\n+        sendUpdates(entities);\r\n+    }\r\n+\r\n+    /** \r\n+     * Sets random names for the given entities' pilots, as far as they can\r\n+     * be configured by the local player. \r\n+     */\r\n+    void setRandomNames(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        for (Entity e: entities) {\r\n+            for (int i = 0; i < e.getCrew().getSlotCount(); i++) {\r\n+                Gender gender = RandomGenderGenerator.generate();\r\n+                e.getCrew().setGender(gender, i);\r\n+                e.getCrew().setName(RandomNameGenerator.getInstance().generate(gender, e.getOwner().getName()), i);\r\n+            }\r\n+        }\r\n+        sendUpdates(entities);\r\n+    }\r\n+\r\n+    /** \r\n+     * Sets random callsigns for the given entities' pilots, as far as they can\r\n+     * be configured by the local player. \r\n+     */\r\n+    void setRandomCallsigns(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        for (Entity e: entities) {\r\n+            for (int i = 0; i < e.getCrew().getSlotCount(); i++) {\r\n+                e.getCrew().setNickname(RandomCallsignGenerator.getInstance().generate(), i);\r\n+            }\r\n+        }\r\n+        sendUpdates(entities);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Asks for a name and creates a new top-level force of that name. \r\n+     */\r\n+    void forceCreateEmpty() {\r\n+        // Ask for a name\r\n+        String name = JOptionPane.showInputDialog(frame(), \"Choose a force designation\");\r\n+        if ((name == null) || (name.trim().length() == 0)) {\r\n+            return;\r\n+        }\r\n+        client().sendAddForce(Force.createToplevelForce(name, localPlayer()), new ArrayList<Entity>());\r\n+    }\r\n+    \r\n+    /**\r\n+     * Asks for a name and creates a new top-level force of that name with the \r\n+     * selected entities in it. \r\n+     */\r\n+    void forceCreateFrom(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (!areAllied(entities)) {\r\n+            LobbyErrors.showOnlyTeam(frame());\r\n+            return;\r\n+        }\r\n+        // Ask for a name\r\n+        String name = JOptionPane.showInputDialog(frame(), \"Choose a force designation\");\r\n+        if ((name == null) || (name.trim().length() == 0)) {\r\n+            return;\r\n+        }\r\n+        client().sendAddForce(Force.createToplevelForce(name, CollectionUtil.randomElement(entities).getOwner()), entities);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Asks for a name and creates a new subforce of that name for the force given\r\n+     * as the parentId. \r\n+     */\r\n+    void forceCreateSub(int parentId) {\r\n+        // Ask for a name\r\n+        String name = JOptionPane.showInputDialog(frame(), \"Choose a force designation\");\r\n+        if ((name == null) || (name.trim().length() == 0)) {\r\n+            return;\r\n+        }\r\n+        client().sendAddForce(Force.createSubforce(name, game().getForces().getForce(parentId)), new ArrayList<Entity>());\r\n+    }\r\n+    \r\n+    /**\r\n+     * Toggles burst MG fire for the given entities to the state given as burstOn\r\n+     */\r\n+    void toggleBurstMg(Collection<Entity> entities, boolean burstOn) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            for (Mounted m: entity.getWeaponList()) {\r\n+                if (((WeaponType) m.getType()).hasFlag(WeaponType.F_MG)) {\r\n+                    m.setRapidfire(burstOn);\r\n+                    updateCandidates.add(entity);\r\n+                }\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Toggles hot loading LRMs for the given entities to the state given as hotLoadOn\r\n+     */\r\n+    void toggleHotLoad(Collection<Entity> entities, boolean hotLoadOn) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            for (Mounted m: entity.getAmmo()) { \r\n+                // setHotLoad checks the Ammo to see if it can be hotloaded\r\n+                m.setHotLoad(hotLoadOn);\r\n+                // TODO: The following should ideally be part of setHotLoad in Mounted\r\n+                if (hotLoadOn) {\r\n+                    m.setMode(\"HotLoad\");\r\n+                } else if (((EquipmentType)m.getType()).hasModeType(\"HotLoad\")) {\r\n+                    m.setMode(\"\");\r\n+                }\r\n+                updateCandidates.add(entity);\r\n+            };\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    public void load(Collection<Entity> selEntities, String info) {\r\n+        StringTokenizer stLoad = new StringTokenizer(info, \":\");\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTM1NzU2OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r615357569", "bodyText": "Yup, will remove from ChatLounge", "author": "SJuliez", "createdAt": "2021-04-18T07:40:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MzIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MzY1Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612093653", "bodyText": "Gotta ask, is there a reason we're guessing who owns the squadron that a given entity is in? Do we allow entities from multiple players to form squadrons or something?", "author": "NickAragua", "createdAt": "2021-04-13T03:00:51Z", "path": "megamek/src/megamek/client/ui/swing/lobby/LobbyActions.java", "diffHunk": "@@ -0,0 +1,1312 @@\n+/*  \r\n+ * MegaMek - Copyright (C) 2021 - The MegaMek Team  \r\n+ *  \r\n+ * listener program is free software; you can redistribute it and/or modify it under  \r\n+ * the terms of the GNU General Public License as published by the Free Software  \r\n+ * Foundation; either version 2 of the License, or (at your option) any later  \r\n+ * version.  \r\n+ *  \r\n+ * listener program is distributed in the hope that it will be useful, but WITHOUT  \r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+ * details.  \r\n+ */ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import java.awt.Dimension;\r\n+import java.util.*;\r\n+import java.util.Map.Entry;\r\n+import javax.swing.JFrame;\r\n+import javax.swing.JOptionPane;\r\n+\r\n+import megamek.MegaMek;\r\n+import megamek.client.Client;\r\n+import megamek.client.generator.*;\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.*;\r\n+import megamek.client.ui.swing.dialog.MMConfirmDialog;\r\n+import megamek.client.ui.swing.dialog.imageChooser.CamoChooserDialog;\r\n+import megamek.common.*;\r\n+import megamek.common.enums.Gender;\r\n+import megamek.common.force.Force;\r\n+import megamek.common.force.Forces;\r\n+import megamek.common.icons.Camouflage;\r\n+import megamek.common.options.OptionsConstants;\r\n+import megamek.common.util.CollectionUtil;\r\n+\r\n+import static megamek.client.ui.swing.lobby.LobbyUtility.*;\r\n+import static java.util.stream.Collectors.*;\r\n+\r\n+/** This class contains the methods that perform entity and force changes from the pop-up menu and elsewhere. */\r\n+public class LobbyActions {\r\n+\r\n+    private final ChatLounge lobby;\r\n+\r\n+    private String cmdSelectedTab = null;   // TODO: required?\r\n+\r\n+    /** This class contains the methods that perform entity and force changes from the pop-up menu and elsewhere. */\r\n+    LobbyActions(ChatLounge cl) {\r\n+        lobby = cl;\r\n+    }\r\n+\r\n+    /** Sets a deployment round for the given entities. Sends an update to the server. */ \r\n+    void applyDeployment(Collection<Entity> entities, int newRound) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.getDeployRound() != newRound) {\r\n+                entity.setDeployRound(newRound);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets starting heat for the given entities. Sends an update to the server. */\r\n+    void applyHeat(Collection<Entity> entities, int heat) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> !e.tracksHeat())) {\r\n+            LobbyErrors.showHeatTracking(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.getHeat() != heat) {\r\n+                entity.heat = heat;\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets/removes hidden deployment for the given entities. Sends an update to the server. */\r\n+    void applyHidden(Collection<Entity> entities, boolean newHidden) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.isHidden() != newHidden) {\r\n+                entity.setHidden(newHidden);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+\r\n+    /** Sets deploy prone for the given entities. Sends an update to the server. */\r\n+    void applyProne(Collection<Entity> entities, String info) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> e.getUnitType() != UnitType.MEK)) {\r\n+            LobbyErrors.showOnlyMeks(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        boolean goProne = info.equals(\"PRONE\");\r\n+        boolean goHullDown = info.equals(\"HULLDOWN\");\r\n+        boolean stand = !goProne && !goHullDown;\r\n+        for (Entity entity: entities) {\r\n+            if ((goProne && !entity.isProne()) || (goHullDown && !entity.isHullDown())\r\n+                    || (stand && (entity.isProne() || entity.isHullDown()))) {\r\n+                entity.setProne(goProne);\r\n+                entity.setHullDown(goHullDown);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Attaches the given force as a subforce to the given new parent. \r\n+     * Does NOT work for newParentId == NO_FORCE. Use promoteForce to do this.\r\n+     * Does not allow attaching a force to one of its own subforces.\r\n+     */\r\n+    void forceAttach(int forceId, int newParentId) {\r\n+        Forces forces = game().getForces();\r\n+        if (!forces.contains(forceId) || !forces.contains(newParentId)\r\n+                || (forceId == newParentId)) {\r\n+            return;\r\n+        }\r\n+        \r\n+        Force force = forces.getForce(forceId);\r\n+        Force newParent = forces.getForce(newParentId);\r\n+        List<Force> subForces = forces.getFullSubForces(force);\r\n+        IPlayer owner = forces.getOwner(force);\r\n+        IPlayer newParentOwner = forces.getOwner(newParent);\r\n+            \r\n+        if (owner.isEnemyOf(newParentOwner)) {\r\n+            LobbyErrors.showOnlyTeam(frame());;\r\n+            return;\r\n+        }\r\n+        if (subForces.contains(newParent)) {\r\n+            LobbyErrors.showForceNoAttachSubForce(frame());\r\n+            return;\r\n+        }\r\n+        if (!isEditable(force)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        var forceList = new ArrayList<Force>(List.of(force));\r\n+        client().sendForceParent(forceList, newParentId);\r\n+    }\r\n+    \r\n+\r\n+    /**\r\n+     * Makes the given forces top-level, detaching them from any former parents. \r\n+     */\r\n+    void forcePromote(Collection<Integer> forceIds) {\r\n+        var forces = game().getForces();\r\n+        if (forceIds.stream().anyMatch(id -> !forces.contains(id))) {\r\n+            return;\r\n+        }\r\n+        Set<Force> forceList = forceIds.stream().map(id -> forces.getForce(id)).collect(toSet());\r\n+        if (!areForcesEditable(forceList)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        client().sendForceParent(forceList, Force.NO_FORCE);\r\n+    }\r\n+\r\n+    /** Shows the dialog which allows adding pre-existing damage to units. */\r\n+    void configureDamage(Collection<Entity> entities) {\r\n+        if (entities.size() != 1) {\r\n+            LobbyErrors.showSingleUnit(frame(), \"assign damage\");\r\n+            return;\r\n+        }\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Entity entity = CollectionUtil.randomElement(entities);\r\n+        UnitEditorDialog med = new UnitEditorDialog(frame(), entity);\r\n+        med.setVisible(true);\r\n+        sendUpdates(entities);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Moves a force or entity within another force by one position. If up is true,\r\n+     * moves upward, otherwise downward. \r\n+     */\r\n+    void forceMove(Collection<Force> forceList, Collection<Entity> entityList, boolean up) {\r\n+        // May only move a single force or a single entity\r\n+        if (forceList.size() + entityList.size() != 1) {\r\n+            LobbyErrors.showOnlySingleEntityOrForce(frame());\r\n+            return;\r\n+        }\r\n+        if (!entityList.isEmpty() && !validateUpdate(entityList)) {\r\n+            return;\r\n+        }\r\n+        if (!forceList.isEmpty() && !areForcesEditable(forceList)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        var forces = game().getForces();\r\n+        var changedForce = new HashSet<Force>(); \r\n+        if (up) {\r\n+            if (!forceList.isEmpty()) {\r\n+                changedForce.addAll(forces.moveUp(CollectionUtil.randomElement(forceList)));\r\n+            } else if (!entityList.isEmpty()) {\r\n+                changedForce.addAll(forces.moveUp(CollectionUtil.randomElement(entityList)));\r\n+            }\r\n+        } else {\r\n+            if (!forceList.isEmpty()) {\r\n+                changedForce.addAll(forces.moveDown(CollectionUtil.randomElement(forceList)));\r\n+            } else if (!entityList.isEmpty()) {\r\n+                changedForce.addAll(forces.moveDown(CollectionUtil.randomElement(entityList)));\r\n+            }\r\n+        }\r\n+\r\n+        if (!changedForce.isEmpty()) {\r\n+            client().sendUpdateForce(changedForce);\r\n+        }\r\n+    }\r\n+    \r\n+    /** \r\n+     * Displays a CamoChooser to choose an individual camo for the given entities. \r\n+     * The camo will only be applied to units configurable by the local player, \r\n+     * i.e. his own units or those of his bots.\r\n+     */\r\n+    public void individualCamo(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Display the CamoChooser and await the result\r\n+        // The dialog is preset to a random entity's settings\r\n+        Entity entity = CollectionUtil.randomElement(entities);\r\n+        CamoChooserDialog ccd = new CamoChooserDialog(frame(), entity.getOwner().getCamouflage());\r\n+        if ((ccd.showDialog() == JOptionPane.CANCEL_OPTION) || (ccd.getSelectedItem() == null)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Choosing the player camo resets the units to have no individual camo.\r\n+        Camouflage selectedItem = ccd.getSelectedItem();\r\n+        Camouflage ownerCamo = entity.getOwner().getCamouflage();\r\n+        boolean noIndividualCamo = selectedItem.equals(ownerCamo);\r\n+\r\n+        // Update all allowed entities with the camo\r\n+        for (Entity ent: entities) {\r\n+            if (noIndividualCamo) {\r\n+                ent.setCamouflage(ownerCamo);\r\n+            } else {\r\n+                ent.setCamouflage(selectedItem);\r\n+            }\r\n+        }\r\n+        sendUpdates(entities);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configure multiple entities at once. Only affects deployment options.\r\n+     */\r\n+    public void customizeMechs(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (!haveSingleOwner(entities)) {\r\n+            LobbyErrors.showSingleOwnerRequired(frame());\r\n+            return;\r\n+        }\r\n+        Entity randomSelected = CollectionUtil.randomElement(entities);\r\n+        String ownerName = randomSelected.getOwner().getName();\r\n+        int ownerId = randomSelected.getOwner().getId();\r\n+\r\n+        boolean editable = client().bots.get(ownerName) != null;\r\n+        Client client;\r\n+        if (editable) {\r\n+            client = client().bots.get(ownerName);\r\n+        } else {\r\n+            editable |= ownerId == localPlayer().getId();\r\n+            client = client();\r\n+        }\r\n+\r\n+        CustomMechDialog cmd = new CustomMechDialog(lobby.getClientgui(), client, new ArrayList<>(entities), editable);\r\n+        cmd.setSize(new Dimension(GUIPreferences.getInstance().getCustomUnitWidth(),\r\n+                GUIPreferences.getInstance().getCustomUnitHeight()));\r\n+        cmd.setTitle(Messages.getString(\"ChatLounge.CustomizeUnits\")); \r\n+        cmd.setVisible(true);\r\n+        GUIPreferences.getInstance().setCustomUnitHeight(cmd.getSize().height);\r\n+        GUIPreferences.getInstance().setCustomUnitWidth(cmd.getSize().width);\r\n+        if (editable && cmd.isOkay()) {\r\n+            // send changes\r\n+            for (Entity entity : entities) {\r\n+                // If a LAM with mechanized BA was changed to non-mech mode, unload the BA.\r\n+                if ((entity instanceof LandAirMech)\r\n+                        && entity.getConversionMode() != LandAirMech.CONV_MODE_MECH) {\r\n+                    for (Entity loadee : entity.getLoadedUnits()) {\r\n+                        entity.unload(loadee);\r\n+                        loadee.setTransportId(Entity.NONE);\r\n+                        client().sendUpdateEntity(loadee);\r\n+                    }\r\n+                }\r\n+\r\n+                client().sendUpdateEntity(entity);\r\n+\r\n+                // Changing state to a transporting unit can update state of\r\n+                // transported units, so update those as well\r\n+                for (Transporter transport : entity.getTransports()) {\r\n+                    for (Entity loaded : transport.getLoadedUnits()) {\r\n+                        client().sendUpdateEntity(loaded);\r\n+                    }\r\n+                }\r\n+\r\n+                // Customizations to a Squadron can effect the fighters\r\n+                if (entity instanceof FighterSquadron) {\r\n+                    entity.getSubEntities().ifPresent(ents -> ents.forEach(client::sendUpdateEntity));\r\n+                }\r\n+            }\r\n+        }\r\n+        if (cmd.isOkay() && (cmd.getStatus() != CustomMechDialog.DONE)) {\r\n+            Entity nextEnt = cmd.getNextEntity(cmd.getStatus() == CustomMechDialog.NEXT);\r\n+            customizeMech(nextEnt);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     *\r\n+     * @param entity\r\n+     */\r\n+    public void customizeMech(Entity entity) {\r\n+        if (!validateUpdate(Arrays.asList(entity))) {\r\n+            return;\r\n+        }\r\n+        boolean editable = client().bots.get(entity.getOwner().getName()) != null;\r\n+        Client c;\r\n+        if (editable) {\r\n+            c = client().bots.get(entity.getOwner().getName());\r\n+        } else {\r\n+            editable |= entity.getOwnerId() == localPlayer().getId();\r\n+            c = client();\r\n+        }\r\n+        // When we customize a single entity's C3 network setting,\r\n+        // **ALL** members of the network may get changed.\r\n+        Entity c3master = entity.getC3Master();\r\n+        ArrayList<Entity> c3members = new ArrayList<>();\r\n+        Iterator<Entity> playerUnits = c.getGame().getPlayerEntities(c.getLocalPlayer(), false).iterator();\r\n+        while (playerUnits.hasNext()) {\r\n+            Entity unit = playerUnits.next();\r\n+            if (!entity.equals(unit) && entity.onSameC3NetworkAs(unit)) {\r\n+                c3members.add(unit);\r\n+            }\r\n+        }\r\n+\r\n+        boolean doneCustomizing = false;\r\n+        while (!doneCustomizing) {\r\n+            // display dialog\r\n+            List<Entity> entities = new ArrayList<>();\r\n+            entities.add(entity);\r\n+            CustomMechDialog cmd = new CustomMechDialog(lobby.getClientgui(), c, entities, editable);\r\n+            cmd.setSize(new Dimension(GUIPreferences.getInstance().getCustomUnitWidth(),\r\n+                    GUIPreferences.getInstance().getCustomUnitHeight()));\r\n+            cmd.refreshOptions();\r\n+            cmd.refreshQuirks();\r\n+            cmd.refreshPartReps();\r\n+            cmd.setTitle(entity.getShortName());\r\n+            if (cmdSelectedTab != null) {\r\n+                cmd.setSelectedTab(cmdSelectedTab);\r\n+            }\r\n+            cmd.setVisible(true);\r\n+            GUIPreferences.getInstance().setCustomUnitHeight(cmd.getSize().height);\r\n+            GUIPreferences.getInstance().setCustomUnitWidth(cmd.getSize().width);\r\n+            cmdSelectedTab = cmd.getSelectedTab();\r\n+            if (editable && cmd.isOkay()) {\r\n+                Set<Entity> updateCandidates = new HashSet<>();\r\n+                updateCandidates.add(entity);\r\n+                // If a LAM with mechanized BA was changed to non-mech mode, unload the BA.\r\n+                if ((entity instanceof LandAirMech)\r\n+                        && entity.getConversionMode() != LandAirMech.CONV_MODE_MECH) {\r\n+                    for (Entity loadee : entity.getLoadedUnits()) {\r\n+                        entity.unload(loadee);\r\n+                        loadee.setTransportId(Entity.NONE);\r\n+                        updateCandidates.add(loadee);\r\n+                    }\r\n+                }\r\n+\r\n+                // Changing state to a transporting unit can update state of\r\n+                // transported units, so update those as well\r\n+                for (Transporter transport : entity.getTransports()) {\r\n+                    for (Entity loaded : transport.getLoadedUnits()) {\r\n+                        updateCandidates.add(loaded);\r\n+                    }\r\n+                }\r\n+\r\n+                // Customizations to a Squadron can effect the fighters\r\n+                if (entity instanceof FighterSquadron) {\r\n+                    entity.getSubEntities().ifPresent(ents -> updateCandidates.addAll(ents));\r\n+                }\r\n+\r\n+                // Do we need to update the members of our C3 network?\r\n+                if (((c3master != null) && !c3master.equals(entity.getC3Master()))\r\n+                        || ((c3master == null) && (entity.getC3Master() != null))) {\r\n+                    for (Entity unit : c3members) {\r\n+                        updateCandidates.add(unit);\r\n+                    }\r\n+                }\r\n+                sendUpdates(updateCandidates);\r\n+            }\r\n+            if (cmd.isOkay() && (cmd.getStatus() != CustomMechDialog.DONE)) {\r\n+                entity = cmd.getNextEntity(cmd.getStatus() == CustomMechDialog.NEXT);\r\n+            } else {\r\n+                doneCustomizing = true;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /** \r\n+     * Sets random skills for the given entities, as far as they can\r\n+     * be configured by the local player. \r\n+     */\r\n+    void setRandomSkills(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        for (Entity e: entities) {\r\n+            Client c = lobby.getLocalClient(e);\r\n+            for (int i = 0; i < e.getCrew().getSlotCount(); i++) {\r\n+                int[] skills = c.getRandomSkillsGenerator().getRandomSkills(e, true);\r\n+                e.getCrew().setGunnery(skills[0], i);\r\n+                e.getCrew().setPiloting(skills[1], i);\r\n+                if (e.getCrew() instanceof LAMPilot) {\r\n+                    skills = c.getRandomSkillsGenerator().getRandomSkills(e, true);\r\n+                    ((LAMPilot) e.getCrew()).setGunneryAero(skills[0]);\r\n+                    ((LAMPilot) e.getCrew()).setPilotingAero(skills[1]);\r\n+                }\r\n+            }\r\n+            e.getCrew().sortRandomSkills();\r\n+        }\r\n+        sendUpdates(entities);\r\n+    }\r\n+\r\n+    /** \r\n+     * Sets random names for the given entities' pilots, as far as they can\r\n+     * be configured by the local player. \r\n+     */\r\n+    void setRandomNames(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        for (Entity e: entities) {\r\n+            for (int i = 0; i < e.getCrew().getSlotCount(); i++) {\r\n+                Gender gender = RandomGenderGenerator.generate();\r\n+                e.getCrew().setGender(gender, i);\r\n+                e.getCrew().setName(RandomNameGenerator.getInstance().generate(gender, e.getOwner().getName()), i);\r\n+            }\r\n+        }\r\n+        sendUpdates(entities);\r\n+    }\r\n+\r\n+    /** \r\n+     * Sets random callsigns for the given entities' pilots, as far as they can\r\n+     * be configured by the local player. \r\n+     */\r\n+    void setRandomCallsigns(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        for (Entity e: entities) {\r\n+            for (int i = 0; i < e.getCrew().getSlotCount(); i++) {\r\n+                e.getCrew().setNickname(RandomCallsignGenerator.getInstance().generate(), i);\r\n+            }\r\n+        }\r\n+        sendUpdates(entities);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Asks for a name and creates a new top-level force of that name. \r\n+     */\r\n+    void forceCreateEmpty() {\r\n+        // Ask for a name\r\n+        String name = JOptionPane.showInputDialog(frame(), \"Choose a force designation\");\r\n+        if ((name == null) || (name.trim().length() == 0)) {\r\n+            return;\r\n+        }\r\n+        client().sendAddForce(Force.createToplevelForce(name, localPlayer()), new ArrayList<Entity>());\r\n+    }\r\n+    \r\n+    /**\r\n+     * Asks for a name and creates a new top-level force of that name with the \r\n+     * selected entities in it. \r\n+     */\r\n+    void forceCreateFrom(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (!areAllied(entities)) {\r\n+            LobbyErrors.showOnlyTeam(frame());\r\n+            return;\r\n+        }\r\n+        // Ask for a name\r\n+        String name = JOptionPane.showInputDialog(frame(), \"Choose a force designation\");\r\n+        if ((name == null) || (name.trim().length() == 0)) {\r\n+            return;\r\n+        }\r\n+        client().sendAddForce(Force.createToplevelForce(name, CollectionUtil.randomElement(entities).getOwner()), entities);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Asks for a name and creates a new subforce of that name for the force given\r\n+     * as the parentId. \r\n+     */\r\n+    void forceCreateSub(int parentId) {\r\n+        // Ask for a name\r\n+        String name = JOptionPane.showInputDialog(frame(), \"Choose a force designation\");\r\n+        if ((name == null) || (name.trim().length() == 0)) {\r\n+            return;\r\n+        }\r\n+        client().sendAddForce(Force.createSubforce(name, game().getForces().getForce(parentId)), new ArrayList<Entity>());\r\n+    }\r\n+    \r\n+    /**\r\n+     * Toggles burst MG fire for the given entities to the state given as burstOn\r\n+     */\r\n+    void toggleBurstMg(Collection<Entity> entities, boolean burstOn) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            for (Mounted m: entity.getWeaponList()) {\r\n+                if (((WeaponType) m.getType()).hasFlag(WeaponType.F_MG)) {\r\n+                    m.setRapidfire(burstOn);\r\n+                    updateCandidates.add(entity);\r\n+                }\r\n+            }\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Toggles hot loading LRMs for the given entities to the state given as hotLoadOn\r\n+     */\r\n+    void toggleHotLoad(Collection<Entity> entities, boolean hotLoadOn) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            for (Mounted m: entity.getAmmo()) { \r\n+                // setHotLoad checks the Ammo to see if it can be hotloaded\r\n+                m.setHotLoad(hotLoadOn);\r\n+                // TODO: The following should ideally be part of setHotLoad in Mounted\r\n+                if (hotLoadOn) {\r\n+                    m.setMode(\"HotLoad\");\r\n+                } else if (((EquipmentType)m.getType()).hasModeType(\"HotLoad\")) {\r\n+                    m.setMode(\"\");\r\n+                }\r\n+                updateCandidates.add(entity);\r\n+            };\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    public void load(Collection<Entity> selEntities, String info) {\r\n+        StringTokenizer stLoad = new StringTokenizer(info, \":\");\r\n+        int loaderId = Integer.parseInt(stLoad.nextToken());\r\n+        Entity loader = game().getEntity(loaderId);\r\n+        int bayNumber = Integer.parseInt(stLoad.nextToken());\r\n+        // Remove those entities from the candidates that are already carried by that loader\r\n+        Collection<Entity> entities = new HashSet<>(selEntities);\r\n+        entities.removeIf(e -> e.getTransportId() == loaderId);\r\n+        if (entities.isEmpty()) {\r\n+            return;\r\n+        }\r\n+        \r\n+        // If a unit of the selected units is currently loaded onto another, 2nd unit of the selected\r\n+        // units, do not continue. The player should unload units first. This would require\r\n+        // a server update offloading that second unit AND embarking it. Currently not possible\r\n+        // as a single server update and updates for one unit shouldn't be chained.\r\n+        Set<Entity> carriers = entities.stream()\r\n+                .filter(e -> e.getTransportId() != Entity.NONE)\r\n+                .map(e -> game().getEntity(e.getTransportId())).collect(toSet());\r\n+        if (!Collections.disjoint(entities, carriers)) {\r\n+            LobbyErrors.showNoDualLoad(frame());\r\n+            return;\r\n+        }\r\n+        \r\n+        boolean loadRear = false;\r\n+        if (stLoad.hasMoreTokens()) {\r\n+            loadRear = Boolean.parseBoolean(stLoad.nextToken());\r\n+        }\r\n+\r\n+        StringBuilder errorMsg = new StringBuilder();\r\n+        if (!LobbyUtility.validateLobbyLoad(entities, loader, bayNumber, loadRear, errorMsg)) {\r\n+            JOptionPane.showMessageDialog(frame(), errorMsg.toString(), \r\n+                    Messages.getString(\"LoadingBay.error\"), JOptionPane.ERROR_MESSAGE);\r\n+            return;\r\n+        }\r\n+\r\n+        for (Entity e: entities) {\r\n+            if (e.getTransportId() != Entity.NONE) {\r\n+                Entity formerLoader = game().getEntity(e.getTransportId());\r\n+                Set<Entity> updateCandidates = new HashSet<>();\r\n+                lobby.disembark(e, updateCandidates);\r\n+                if (!updateCandidates.isEmpty()) {\r\n+                    lobby.getLocalClient(formerLoader).sendUpdateEntity(formerLoader);\r\n+                }\r\n+            }\r\n+            lobby.loadOnto(e, loaderId, bayNumber);\r\n+        }\r\n+    }\r\n+    \r\n+    /** Asks for a new name for the provided forceId and applies it. */\r\n+    void forceRename(int forceId) {\r\n+        Forces forces = game().getForces();\r\n+        if (!forces.contains(forceId)) {\r\n+            return;\r\n+        }\r\n+        Force force = forces.getForce(forceId); \r\n+        if (!isEditable(force)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        // Ask for a name\r\n+        String name = JOptionPane.showInputDialog(frame(), \"Choose a force designation\");\r\n+        if ((name == null) || (name.trim().length() == 0)) {\r\n+            return;\r\n+        }\r\n+        forces.renameForce(name, forceId);\r\n+        var forceList = new ArrayList<Force>(List.of(force)); // must be mutable\r\n+        client().sendUpdateForce(forceList);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Deletes the given forces and entities. Asks for confirmation if confirm is true. \r\n+     */\r\n+    void delete(Collection<Force> foDelete, Collection<Entity> enDelete, boolean confirm) {\r\n+        Forces forces = game().getForces();\r\n+        // Remove redundant forces = subforces of other forces in the list \r\n+        Set<Force> allSubForces = new HashSet<>();\r\n+        foDelete.stream().forEach(f -> allSubForces.addAll(forces.getFullSubForces(f)));\r\n+        foDelete.removeIf(f -> allSubForces.contains(f));\r\n+        Set<Force> finalFoDelete = new HashSet<>(foDelete);\r\n+        // Remove redundant entities = entities in the given forces\r\n+        Set<Entity> inForces = new HashSet<Entity>();\r\n+        foDelete.stream().map(f -> forces.getFullEntities(f)).forEach(inForces::addAll);\r\n+        enDelete.removeIf(e -> inForces.contains(e));\r\n+        Set<Entity> finalEnDelete = new HashSet<>(enDelete);\r\n+        \r\n+        if (!enDelete.isEmpty() && !validateUpdate(finalEnDelete)) {\r\n+            return;\r\n+        }\r\n+        if (!areForcesEditable(finalFoDelete)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+\r\n+        if (confirm) {\r\n+            int foCount = finalFoDelete.size();\r\n+            int enCount = finalEnDelete.size() + inForces.size();\r\n+            String question = \"Really delete \";\r\n+            if (foCount > 0) {\r\n+                question += (foCount == 1 ? \"one force\" : foCount + \" forces\");\r\n+            }\r\n+            if (enCount > 0) {\r\n+                question += foCount > 0 ? \" and \" : \"\";\r\n+                question += (enCount == 1 ? \"one unit\" : enCount + \" units\");\r\n+            }\r\n+            question += \"?\";\r\n+            if (!MMConfirmDialog.confirm(frame(), \"Delete Units...\", question)) {\r\n+                return;\r\n+            }\r\n+        }\r\n+        \r\n+        // Send a command to remove the forceless entities\r\n+        Set<Client> senders = finalEnDelete.stream().map(this::correctSender).distinct().collect(toSet());\r\n+        for (Client sender: senders) {\r\n+            // Gather the entities for this sending client; \r\n+            // Serialization doesn't like the toList() result, therefore the new ArrayList\r\n+            List<Integer> ids = new ArrayList<Integer>(finalEnDelete.stream()\r\n+                    .filter(e -> correctSender(e).equals(sender))\r\n+                    .map(Entity::getId)\r\n+                    .collect(toList()));\r\n+            sender.sendDeleteEntities(ids);\r\n+        }\r\n+        \r\n+        // Send a command to remove the forces (with entities)\r\n+        senders = finalFoDelete.stream().map(this::correctSender).distinct().collect(toSet());\r\n+        for (Client sender: senders) {\r\n+            List<Force> foList = new ArrayList<>(finalFoDelete.stream()\r\n+                    .filter(f -> correctSender(f).equals(sender))\r\n+                    .collect(toList()));\r\n+            sender.sendDeleteForces(foList);\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Removes the given entities from their force(s), making them force-less.\r\n+     * Entities must have a single owner and be editable (local units or local bot's units)\r\n+     * (Having multiple owners makes sending updates correctly for one's own bots difficult) \r\n+     */\r\n+    void forceRemoveEntity(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        client().sendAddEntitiesToForce(entities, Force.NO_FORCE);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Swaps pilots between the given entity \r\n+     * and another entity of the given id\r\n+     */\r\n+    void swapPilots(Collection<Entity> entities, int targetId) {\r\n+        Entity target = game().getEntity(targetId);\r\n+        if (target == null) {\r\n+            return;\r\n+        }\r\n+        if (entities.size() != 1) {\r\n+            LobbyErrors.showSingleUnit(frame(), \"swap pilots\");\r\n+            return;\r\n+        }\r\n+        Entity selected = CollectionUtil.randomElement(entities);\r\n+        if (!validateUpdate(Arrays.asList(target, selected))) {\r\n+            return;\r\n+        }\r\n+        Crew temp = target.getCrew();\r\n+        target.setCrew(selected.getCrew());\r\n+        selected.setCrew(temp);\r\n+        sendUpdates(Arrays.asList(target, selected));\r\n+    }\r\n+    \r\n+    /** \r\n+     * Disconnects the passed entities from their C3 network, if any.\r\n+     * Due to the way C3 networks are represented in Entity, units\r\n+     * cannot disconnect from a C3 network with an id that is the\r\n+     * entity's own id. \r\n+     */\r\n+    void c3DisconnectFromNetwork(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = performDisconnect(entities);\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Performs a disconnect from C3 networks for the given entities without sending an update. \r\n+     * Returns a set of all affected units. \r\n+     */\r\n+    private HashSet<Entity> performDisconnect(Collection<Entity> entities) {\r\n+        HashSet<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity entity: entities) {\r\n+            if (entity.hasNhC3()) {\r\n+                entity.setC3NetIdSelf();\r\n+                updateCandidates.add(entity);\r\n+            } else if (entity.hasAnyC3System()) {\r\n+                entity.setC3Master(null, true);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        // Also disconnect all units connected *to* that entity\r\n+        for (Entity entity: game().getEntitiesVector()) {\r\n+            if (entities.contains(entity.getC3Master())) {\r\n+                entity.setC3Master(null, true);\r\n+                updateCandidates.add(entity);\r\n+            }\r\n+        }\r\n+        return updateCandidates;\r\n+    }\r\n+    \r\n+    /**  Sets the entities' C3M to act as a Company Master. */\r\n+    void c3SetCompanyMaster(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (!entities.stream().allMatch(e -> e.hasC3M())) {\r\n+            LobbyErrors.showOnlyC3M(frame());\r\n+            return;\r\n+        }\r\n+        entities.stream().forEach(e -> e.setC3Master(e.getId(), true));\r\n+        sendUpdates(entities);\r\n+    }\r\n+    \r\n+    /**  Sets the entities' C3M to act as a Lance Master (aka normal mode). */\r\n+    void c3SetLanceMaster(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (!entities.stream().allMatch(e -> e.hasC3M())) {\r\n+            LobbyErrors.showOnlyC3M(frame());\r\n+            return;\r\n+        }\r\n+        entities.stream().forEach(e -> e.setC3Master(-1, true));\r\n+        sendUpdates(entities);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Connects the passed entities to a nonhierarchic C3 (NC3, C3i or Nova CEWS)\r\n+     * identified by masterID.\r\n+     */\r\n+    void c3JoinNh(Collection<Entity> entities, int masterID, boolean disconnectFirst) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (!areAllied(entities)) {\r\n+            LobbyErrors.showOnlyTeam(frame());\r\n+            return;\r\n+        }\r\n+        Entity master = game().getEntity(masterID);\r\n+        if (!master.hasNhC3() || !entities.stream().allMatch(e -> sameNhC3System(master, e))) {\r\n+            LobbyErrors.showSameC3(frame());\r\n+            return;\r\n+        }\r\n+        if (disconnectFirst) {\r\n+            performDisconnect(entities);\r\n+        }\r\n+        int freeNodes = master.calculateFreeC3Nodes();\r\n+        freeNodes += entities.contains(master) ? 1 : 0;\r\n+        if (entities.size() > freeNodes) {\r\n+            LobbyErrors.showExceedC3Capacity(frame());\r\n+            return;\r\n+        }\r\n+        entities.stream().forEach(e -> e.setC3NetId(master));\r\n+        sendUpdates(entities);\r\n+    }\r\n+\r\n+    /** \r\n+     * Connects the passed entities to a standard C3M\r\n+     * identified by masterID.\r\n+     */\r\n+    void c3Connect(Collection<Entity> entities, int masterID, boolean disconnectFirst) {\r\n+        Entity master = game().getEntity(masterID);\r\n+        // To make it possible to mark a C3S/C3S/C3S/C3M lance and connect it:\r\n+        entities.remove(master);\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (!areAllied(entities)) {\r\n+            LobbyErrors.showOnlyTeam(frame());\r\n+            return;\r\n+        }\r\n+        boolean connectMS = master.isC3IndependentMaster()  && entities.stream().allMatch(e -> e.hasC3S());\r\n+        boolean connectMM = master.isC3CompanyCommander() && entities.stream().allMatch(e -> e.hasC3M());\r\n+        boolean connectSMM = master.hasC3MM() && entities.stream().allMatch(e -> e.hasC3S() || e.hasC3M());\r\n+        if (!connectMM && !connectMS && !connectSMM) {\r\n+            LobbyErrors.showSameC3(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>(entities);\r\n+        if (disconnectFirst) { // this is only true when a C3 lance is formed from SSSM\r\n+            updateCandidates.addAll(performDisconnect(entities));\r\n+            updateCandidates.addAll(performDisconnect(Arrays.asList(master)));\r\n+        }\r\n+        int newC3nodeCount = entities.stream().mapToInt(e -> game().getC3SubNetworkMembers(e).size()).sum();\r\n+        int masC3nodeCount = game().getC3NetworkMembers(master).size();\r\n+        if (newC3nodeCount + masC3nodeCount > Entity.MAX_C3_NODES || entities.size() > master.calculateFreeC3Nodes()) {\r\n+            LobbyErrors.showExceedC3Capacity(frame());\r\n+            return;\r\n+        }\r\n+        entities.stream().forEach(e -> e.setC3Master(master, true));\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Change the given entities' controller to the player with ID newOwnerId.\r\n+     * If the given forceList is not empty, an error message will be shown.\r\n+     */\r\n+    void changeOwner(Collection<Entity> entities, Collection<Force> forceList, int newOwnerId) {\r\n+        if (entities.isEmpty() || game().getPlayer(newOwnerId) == null) {\r\n+            return;\r\n+        } else if (!forceList.isEmpty()) {\r\n+            LobbyErrors.showOnlyEntityOrForce(frame());\r\n+            return;\r\n+        }\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        client().sendChangeOwner(entities, newOwnerId);\r\n+    }\r\n+    \r\n+    /** Change the team of a controlled player (the local player or one of his bots). */\r\n+    void changeTeam(Collection<IPlayer> players, int team) {\r\n+        var toSend = new HashSet<IPlayer>();\r\n+        players.stream()\r\n+            .filter(this::isSelfOrLocalBot)\r\n+            .filter(p -> p.getTeam() != team)\r\n+            .forEach(toSend::add);\r\n+        client().sendChangeTeam(toSend, team);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Add the entities to the force if admissible (the entities must all be editable\r\n+     * by the local player and be allied to the force's owner.\r\n+     */\r\n+    void forceAddEntity(Collection<Entity> entities, int forceId) {\r\n+        Forces forces = game().getForces();\r\n+        if (!validateUpdate(entities) || !forces.contains(forceId)) {\r\n+            return;\r\n+        }\r\n+        var forceOwner = forces.getOwner(forceId);\r\n+        if (entities.stream().anyMatch(e -> e.getOwner().isEnemyOf(forceOwner))) {\r\n+            LobbyErrors.showOnlyTeam(frame());\r\n+            return;\r\n+        }\r\n+        client().sendAddEntitiesToForce(entities, forceId);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Changes the owner of the given forces to a different player without \r\n+     * affecting force structure. \r\n+     * When assigning the force only to an enemy, it would dislodge that force\r\n+     * from its parent and dislodge all units from it and leave it an empty\r\n+     * force for the enemy. That seems useless. Therefore this is restricted\r\n+     * to only assign to team members of the former owner. \r\n+     */\r\n+    void forceAssignOnly(Collection<Force> forceList, int newOwnerId) {\r\n+        IPlayer newOwner = game().getPlayer(newOwnerId);\r\n+        if (newOwner == null) {\r\n+            return;\r\n+        }\r\n+        if (!areForcesEditable(forceList)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        Forces forces = game().getForces();\r\n+        if (forceList.stream().anyMatch(f -> newOwner.isEnemyOf(forces.getOwner(f)))) {\r\n+            LobbyErrors.showOnlyTeammate(frame());\r\n+            return;\r\n+        }\r\n+        List<Force> changedForces = new ArrayList<>();\r\n+        for (Force force: forceList) {\r\n+            changedForces.addAll(forces.assignForceOnly(force, newOwner));\r\n+        }\r\n+        client().sendUpdateForce(changedForces);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Changes the owner of the given forces to a different player together with\r\n+     * all subforces and units.\r\n+     */\r\n+    void forceAssignFull(Collection<Force> forceList, int newOwnerId) {\r\n+        IPlayer newOwner = game().getPlayer(newOwnerId);\r\n+        if (newOwner == null) {\r\n+            return;\r\n+        }\r\n+        if (!areForcesEditable(forceList)) {\r\n+            LobbyErrors.showCannotConfigEnemies(frame());\r\n+            return;\r\n+        }\r\n+        client().sendAssignForceFull(forceList, newOwnerId);\r\n+    }\r\n+    \r\n+    void unloadFromBay(Collection<Entity> entities, int bayId) {\r\n+        if (entities.size() != 1) {\r\n+            LobbyErrors.showSingleUnit(frame(), \"offload from bays\");\r\n+            return;\r\n+        }\r\n+        Entity carrier = CollectionUtil.randomElement(entities);\r\n+        if (!validateUpdate(Arrays.asList(carrier))) {\r\n+            return;\r\n+        }\r\n+        Bay bay = carrier.getBayById(bayId);\r\n+        if (bay == null) {\r\n+            LobbyErrors.showNoSuchBay(frame());\r\n+            return;\r\n+        }\r\n+        Set<Entity> updateCandidates = new HashSet<>();\r\n+        for (Entity loadee : bay.getLoadedUnits()) {\r\n+            lobby.disembark(loadee, updateCandidates);\r\n+        }\r\n+        sendUpdates(updateCandidates);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Creates a fighter squadron from the given list of entities.\r\n+     * Checks if all entities are fighters and if the number of entities\r\n+     * does not exceed squadron capacity. Asks for a squadron name.\r\n+     */\r\n+    void createSquadron(Collection<Entity> entities) {\r\n+        if (!validateUpdate(entities)) {\r\n+            return;\r\n+        }\r\n+        if (entities.stream().anyMatch(e -> !e.isFighter() || e instanceof FighterSquadron)) {\r\n+            LobbyErrors.showOnlyFighter(frame());\r\n+            return;\r\n+        }\r\n+        if (!areAllied(entities)) {\r\n+            LobbyErrors.showLoadOnlyAllied(frame());\r\n+            return;\r\n+        }\r\n+        boolean largeSquadrons = game().getOptions().booleanOption(OptionsConstants.ADVAERORULES_ALLOW_LARGE_SQUADRONS);\r\n+        if ((!largeSquadrons && entities.size() > FighterSquadron.MAX_SIZE) \r\n+                || entities.size() > FighterSquadron.ALTERNATE_MAX_SIZE) {\r\n+            LobbyErrors.showSquadronTooMany(frame());\r\n+        }\r\n+        \r\n+        // Ask for a squadron name\r\n+        String name = JOptionPane.showInputDialog(frame(), \"Choose a squadron designation\");\r\n+        if ((name == null) || (name.trim().length() == 0)) {\r\n+            return;\r\n+        }\r\n+        \r\n+        // Now, actually create the squadron\r\n+        FighterSquadron fs = new FighterSquadron(name);\r\n+        fs.setOwner(createSquadronOwner(entities));\r\n+        List<Integer> fighterIds = new ArrayList<>(entities.stream().map(e -> e.getId()).collect(toList()));\r\n+        correctSender(fs).sendAddSquadron(fs, fighterIds);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a likely owner client; if any of the fighter belongs to the local\r\n+     * player, returns the local player. If not, returns a local bot if any of the\r\n+     * fighters belongs to that; finally, returns the owner of a random one of the \r\n+     * fighters.\r\n+     */\r\n+    private IPlayer createSquadronOwner(Collection<Entity> entities) {\r\n+        if (entities.stream().anyMatch(e -> e.getOwner().equals(localPlayer()))) {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTM1Nzg3MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r615357870", "bodyText": "Yes, loading/squadron/C3/forces are allowed within teams. I didn't want to add an owner dropdown or something for a fighter squadron. Most of the time there'll only be one owner anyway.", "author": "SJuliez", "createdAt": "2021-04-18T07:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MzY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NDA3MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612094070", "bodyText": "Well, I see where all the magic strings come from.", "author": "NickAragua", "createdAt": "2021-04-13T03:02:30Z", "path": "megamek/src/megamek/client/ui/swing/lobby/LobbyMekPopupActions.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*  \r\n+* MegaMek - Copyright (C) 2021 - The MegaMek Team  \r\n+*  \r\n+* This program is free software; you can redistribute it and/or modify it under  \r\n+* the terms of the GNU General Public License as published by the Free Software  \r\n+* Foundation; either version 2 of the License, or (at your option) any later  \r\n+* version.  \r\n+*  \r\n+* This program is distributed in the hope that it will be useful, but WITHOUT  \r\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+* details.  \r\n+*/ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import java.awt.event.ActionEvent;\r\n+import java.awt.event.ActionListener;\r\n+import java.util.HashSet;\r\n+import java.util.Set;\r\n+import java.util.StringTokenizer;\r\n+\r\n+import megamek.common.Entity;\r\n+import megamek.common.QuirksHandler;\r\n+\r\n+/** The ActionListener for the lobby popup menu for both the MekTable and MekTrees. */\r\n+public class LobbyMekPopupActions implements ActionListener {\r\n+\r\n+    private ChatLounge lobby;\r\n+    \r\n+    /** The ActionListener for the lobby popup menu for both the MekTable and MekTrees. */\r\n+    LobbyMekPopupActions(ChatLounge cl) {\r\n+        lobby = cl;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void actionPerformed(ActionEvent e) {\r\n+        StringTokenizer st = new StringTokenizer(e.getActionCommand(), \"|\");\r\n+        String command = st.nextToken();\r\n+        // info need not be an int; loading uses the format \"##:##\"\r\n+        String info = st.nextToken();\r\n+        // The entities list may be empty\r\n+        Set<Entity> entities = LobbyUtility.getEntities(lobby.game(), st.nextToken());\r\n+        \r\n+        switch (command) {\r\n+            \r\n+            // Single entity commands\r\n+        case \"CONFIGURE\":\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NDQ4OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612094488", "bodyText": "Where'd blizzard go?", "author": "NickAragua", "createdAt": "2021-04-13T03:04:08Z", "path": "megamek/src/megamek/server/WeatherProcessor.java", "diffHunk": "@@ -113,7 +113,6 @@ private void resolveWeather() {\n             }\n         }\n         if(((conditions.getWeather() == PlanetaryConditions.WE_HEAVY_SNOW)\n-                || (conditions.getWeather() == PlanetaryConditions.WE_BLIZZARD)", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTM1ODAzMA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r615358030", "bodyText": "Global Warming? I just couldn't find it in the rules anymore.", "author": "SJuliez", "createdAt": "2021-04-18T07:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NDQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NTAxMQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612095011", "bodyText": "In general, I'm kind of concerned that this file will become another disorganized mess like Server.java. I think it'd be better to organize the various methods into different ServerHelper classes, e.g. the board scanning/loading related methods into ServerBoardHelper, etc.", "author": "NickAragua", "createdAt": "2021-04-13T03:06:07Z", "path": "megamek/src/megamek/server/ServerHelper.java", "diffHunk": "@@ -449,4 +441,510 @@ public static void checkAndApplyMagmaCrust(IHex hex, int elevation, Entity entit\n             }\n         }\n     }\n+    \n+    /**\n+     * Returns a list of path names of available boards of the size set in the given\n+     * mapSettings. The path names are minus the '.board' extension and relative to\n+     * the boards data directory.\n+     */\n+    static ArrayList<String> scanForBoards(MapSettings mapSettings) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg2NTg3Mg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616865872", "bodyText": "Yes I hijacked this as my Eclipse continually goes on 10s hibernations when I edit anything in Server. I'll see if I can divide some things out.", "author": "SJuliez", "createdAt": "2021-04-20T16:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NTk2NA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612095964", "bodyText": "We no longer have a need for this once we load the entity's forces?", "author": "NickAragua", "createdAt": "2021-04-13T03:09:05Z", "path": "megamek/src/megamek/server/Server.java", "diffHunk": "@@ -29964,13 +29868,38 @@ public boolean accept(Entity entity) {\n                 }\n             }\n             // Give the unit a spotlight, if it has the spotlight quirk\n-            entity.setExternalSpotlight(entity.hasExternaSpotlight()\n+            entity.setExternalSearchlight(entity.hasExternalSearchlight()\n                     || entity.hasQuirk(OptionsConstants.QUIRK_POS_SEARCHLIGHT));\n             entityIds.add(entity.getId());\n \n             if (game.getPhase() != Phase.PHASE_LOUNGE) {\n                 entity.getOwner().increaseInitialBV(entity.calculateBattleValue(false, false));\n             }\n+            \n+            // Restore forces from MULs or other external sources from the forceString, if any\n+            if (entity.getForceString().length() > 0) {\n+                ArrayList<Force> forceList = Forces.parseForceString(entity);\n+                int realId = Force.NO_FORCE;\n+                boolean topLevel = true;\n+\n+                for (Force force: forceList) {\n+                    if (!forceMapping.containsKey(force.getId())) {\n+                        if (topLevel) {\n+                            realId = game.getForces().addTopLevelForce(force.getName(), entity.getOwner());\n+                        } else {\n+                            Force parent = game.getForces().getForce(realId);\n+                            realId = game.getForces().addSubForce(force.getName(), parent);\n+                        }\n+                        forceMapping.put(force.getId(), realId);\n+                    } else {\n+                        realId = forceMapping.get(force.getId());\n+                    }\n+                    topLevel = false;\n+                }\n+                entity.setForceString(\"\");", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzYzMTA1Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617631056", "bodyText": "Exactly.", "author": "SJuliez", "createdAt": "2021-04-21T15:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NTk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NjIwNg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612096206", "bodyText": "Sounds like a great prank.", "author": "NickAragua", "createdAt": "2021-04-13T03:09:54Z", "path": "megamek/src/megamek/server/Server.java", "diffHunk": "@@ -30435,11 +30467,29 @@ private void receiveEntityAmmoChange(Packet c, int connIndex) {\n     private void receiveEntityDelete(Packet c, int connIndex) {\n         @SuppressWarnings(\"unchecked\")\n         List<Integer> ids = (List<Integer>) c.getObject(0);\n+        \n+        Set<Entity> delEntities = new HashSet<>();\n+        ids.stream().map(id -> game.getEntity(id)).forEach(delEntities::add);\n+        \n+        // Unload units and disconnect any C3 networks\n+        Set<Entity> updateCandidates = new HashSet<>();\n+        updateCandidates.addAll(ServerHelper.lobbyUnload(game, delEntities));\n+        updateCandidates.addAll(ServerHelper.performC3Disconnect(game, delEntities));\n+        \n+        // Units that get deleted must not receive updates\n+        updateCandidates.removeIf(e -> delEntities.contains(e));\n+        if (!updateCandidates.isEmpty()) {\n+            send(ServerHelper.createMultiEntityPacket(updateCandidates));\n+        }\n+        \n+        ArrayList<Force> affectedForces = new ArrayList<>();\n         for (Integer entityId : ids) {\n             final Entity entity = game.getEntity(entityId);\n \n-            // Only allow players to delete their *own* entities.\n-            if ((entity != null) && (entity.getOwner() == getPlayer(connIndex))) {\n+            // Players can delete units of their teammates", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5Njg1Nw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612096857", "bodyText": "Is this really random?", "author": "NickAragua", "createdAt": "2021-04-13T03:12:07Z", "path": "megamek/src/megamek/common/util/CollectionUtil.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*  \r\n+ * MegaMek - Copyright (C) 2021 - The MegaMek Team  \r\n+ *  \r\n+ * listener program is free software; you can redistribute it and/or modify it under  \r\n+ * the terms of the GNU General Public License as published by the Free Software  \r\n+ * Foundation; either version 2 of the License, or (at your option) any later  \r\n+ * version.  \r\n+ *  \r\n+ * listener program is distributed in the hope that it will be useful, but WITHOUT  \r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+ * details.  \r\n+ */ \r\n+package megamek.common.util;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.List;\r\n+\r\n+/** Some utility methods for Collections. */\r\n+public class CollectionUtil {\r\n+\r\n+    /** \r\n+     * Returns a list that is the concatenation of the provided lists. Does NOT\r\n+     * do anything else (e.g. remove duplicate entries). \r\n+     */\r\n+    public static final <T> List<T> union(List<T> c1, List<T> c2) {\r\n+        List<T> result = new ArrayList<T>(c1);\r\n+        result.addAll(c2);\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a random element of the collection or the element if it has only one.\r\n+     * Throws a NoSuchElement exception if it is empty.\r\n+     */\r\n+    public static final <T> T randomElement(Collection<T> collection) {\r\n+        return collection.stream().findFirst().get();\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzYzMTUzMQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617631531", "bodyText": "Renamed.", "author": "SJuliez", "createdAt": "2021-04-21T15:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5Njg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NzM2Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612097363", "bodyText": "I assume that this descriptive building text is contained somewhere else?", "author": "NickAragua", "createdAt": "2021-04-13T03:14:13Z", "path": "megamek/src/megamek/common/Terrains.java", "diffHunk": "@@ -211,38 +211,16 @@ public static String getEditorTooltip(int type) {\n     }\n \n     /**\n+     * Returns a name to be displayed in tooltips. \n+     * Intentionally returns null for terrains that should be treated\n+     * separately such as buildings and for terrains that should not be listed\n+     * such as cliff-tops.\n      * @param type the type of terrain to get the name for\n      * @param level the level of the terrain to get the specific name\n      * @return a displayable name for this terrain (for tooltips)\n      */\n     public static String getDisplayName(int type, int level) {\n         switch (type) {\n-        case (BUILDING):\n-            if (level == 1) {\n-                return \"Light building\";\n-            } else if (level == 2) {\n-                return \"Medium building\";\n-            } else if (level == 3) {\n-                return \"Heavy building\";\n-            } else if (level == 4) {\n-                return \"Hardened Building\";", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzYzNDg0Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617634846", "bodyText": "No, this was not a good change. I'll revert it.", "author": "SJuliez", "createdAt": "2021-04-21T15:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NzM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5NzQ4MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612097480", "bodyText": "Guess I know what happened to blizzard", "author": "NickAragua", "createdAt": "2021-04-13T03:14:40Z", "path": "megamek/src/megamek/common/PlanetaryConditions.java", "diffHunk": "@@ -48,13 +48,14 @@\n     public static final int WE_SNOW_FLURRIES    = 8;\n     public static final int WE_HEAVY_SNOW       = 9;\n     public static final int WE_SLEET            = 10;\n-    public static final int WE_BLIZZARD         = 11;\n-    public static final int WE_ICE_STORM        = 12;\n-    public static final int WE_LIGHT_HAIL       = 13;\n-    public static final int WE_HEAVY_HAIL       = 14;\n+    public static final int WE_ICE_STORM        = 11;\n+    public static final int WE_LIGHT_HAIL       = 12;// NYI\n+    public static final int WE_HEAVY_HAIL       = 13;// NYI\n+    public static final int WE_LIGHTNING_STORM  = 14;// NYI\n+    //  public static final int WE_BLIZZARD         = 11; does not exist anymore", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5ODMwMg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612098302", "bodyText": "I'm having a little trouble understanding the logic in this method.", "author": "NickAragua", "createdAt": "2021-04-13T03:17:23Z", "path": "megamek/src/megamek/common/OffBoardDirection.java", "diffHunk": "@@ -78,4 +78,30 @@ public static OffBoardDirection getOpposite(OffBoardDirection value) {\n             return NONE;\n         }\n     }\n+    \n+    /** \n+     * Returns the OffBoardDirection associated with given the on-board deployment\n+     * position as defined in IStartingPositions.\n+     */\n+    public static OffBoardDirection translateStartPosition(int startPos) {\n+        if (startPos > 10) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxMTY1OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616711658", "bodyText": "I think it might mean modulo ten?", "author": "Windchild292", "createdAt": "2021-04-20T14:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5ODMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzYzNjI1OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617636258", "bodyText": "The deep deployment zones use the numbers of the normal deployment zones +10", "author": "SJuliez", "createdAt": "2021-04-21T15:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5ODMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5OTI4MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612099280", "bodyText": "In the other method, you added conventional fighters to the aero else if, here, they're just removed?", "author": "NickAragua", "createdAt": "2021-04-13T03:20:47Z", "path": "megamek/src/megamek/common/EntityWeightClass.java", "diffHunk": "@@ -252,8 +250,6 @@ public static int getWeightClass(double tonnage, Entity en) {\n                     break;\n                 }\n             }\n-        } else if (en instanceof ConvFighter) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY0MDcwNA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617640704", "bodyText": "ConvFighter is instanceof Aero so the Aero part works for ConvFighters in the second method.", "author": "SJuliez", "createdAt": "2021-04-21T15:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5OTI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4Njk3NA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612886974", "bodyText": "I gotta ask, would it be better to have it be some kind of popup with a spinner or something? This seems pretty unwieldy from a user interaction standpoint.", "author": "NickAragua", "createdAt": "2021-04-14T02:04:46Z", "path": "megamek/src/megamek/client/ui/swing/lobby/LobbyMekPopup.java", "diffHunk": "@@ -0,0 +1,688 @@\n+/*  \r\n+ * MegaMek - Copyright (C) 2020 - The MegaMek Team  \r\n+ *  \r\n+ * listener program is free software; you can redistribute it and/or modify it under  \r\n+ * the terms of the GNU General Public License as published by the Free Software  \r\n+ * Foundation; either version 2 of the License, or (at your option) any later  \r\n+ * version.  \r\n+ *  \r\n+ * listener program is distributed in the hope that it will be useful, but WITHOUT  \r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+ * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+ * details.  \r\n+ */ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import java.awt.event.ActionListener;\r\n+import java.awt.event.KeyEvent;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Set;\r\n+import java.util.stream.Collectors;\r\n+import javax.swing.JMenu;\r\n+import javax.swing.JMenuItem;\r\n+\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.util.MenuScroller;\r\n+import megamek.client.ui.swing.util.ScalingPopup;\r\n+import megamek.client.ui.swing.util.UIUtil;\r\n+import megamek.common.*;\r\n+import megamek.common.force.Force;\r\n+import megamek.common.force.Forces;\r\n+import megamek.common.options.GameOptions;\r\n+import megamek.common.options.OptionsConstants;\r\n+import megamek.common.preference.PreferenceManager;\r\n+\r\n+import static megamek.client.ui.swing.util.UIUtil.*;\r\n+import static megamek.common.util.CollectionUtil.*;\r\n+\r\n+/** Creates the Lobby Mek right-click pop-up menu for both the sortable table and the force tree. */\r\n+class LobbyMekPopup {\r\n+    \r\n+    private static final String NOINFO = \"|-1\";\r\n+    \r\n+    static ScalingPopup getPopup(List<Entity> entities, List<Force> forces,\r\n+            ActionListener listener, ChatLounge lobby) {\r\n+\r\n+        ClientGUI clientGui = lobby.getClientgui();\r\n+        IGame game = lobby.game();\r\n+        GameOptions opts = game.getOptions();\r\n+        \r\n+        boolean optQuirks = opts.booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS);\r\n+        boolean optBurstMG = opts.booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_BURST);\r\n+        boolean optLRMHotLoad = opts.booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HOTLOAD);\r\n+        boolean optCapFighters = opts.booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_CAPITAL_FIGHTER);\r\n+\r\n+        // A set of all selected entities and all entities in selected forces and their subforces\r\n+        Set<Entity> joinedEntities = new HashSet<Entity>(entities);\r\n+        for (Force force: forces) {\r\n+            joinedEntities.addAll(game.getForces().getFullEntities(force));\r\n+        }  \r\n+\r\n+        // Find certain unit features among all units the player can access\r\n+        // Used to hide some menu items entirely like \"Form Squadron\" when there's no fighter in the game\r\n+        HashSet<Entity> accessibleEntities = new HashSet<>(game.getEntitiesVector());\r\n+        accessibleEntities.removeIf(lobby.lobbyActions::isNotEditable);\r\n+        boolean accessibleFighters = accessibleEntities.stream().anyMatch(e -> e.isFighter());\r\n+        boolean accessibleTransportBays = accessibleEntities.stream().anyMatch(e -> !e.getTransportBays().isEmpty());\r\n+        boolean accessibleCarriers = accessibleEntities.stream().anyMatch(e -> !e.getLoadedUnits().isEmpty());\r\n+        boolean accessibleProtomeks = accessibleEntities.stream().anyMatch(e -> e.hasETypeFlag(Entity.ETYPE_PROTOMECH));\r\n+\r\n+        // Find what can be done with the selected entities incl. those in selected forces\r\n+        boolean anyCarrier = joinedEntities.stream().anyMatch(e -> !e.getLoadedUnits().isEmpty());\r\n+        boolean noneEmbarked = joinedEntities.stream().allMatch(e -> e.getTransportId() == Entity.NONE);\r\n+        boolean allProtomeks = joinedEntities.stream().allMatch(e -> e.hasETypeFlag(Entity.ETYPE_PROTOMECH));\r\n+        boolean anyRFMGOn = joinedEntities.stream().anyMatch(e -> hasRapidFireMG(e));\r\n+        boolean anyRFMGOff = joinedEntities.stream().anyMatch(e -> hasNormalFireMG(e));\r\n+        boolean anyHLOn = joinedEntities.stream().anyMatch(e -> hasHotLoaded(e));\r\n+        boolean anyHLOff = joinedEntities.stream().anyMatch(e -> hasNonHotLoaded(e));\r\n+\r\n+        boolean hasjoinedEntities = !joinedEntities.isEmpty();\r\n+        boolean joinedOneEntitySelected = (entities.size() == 1) && forces.isEmpty();\r\n+        boolean canSeeAll = lobby.canSeeAll(joinedEntities);\r\n+        \r\n+        ScalingPopup popup = new ScalingPopup();\r\n+        \r\n+        // All command strings should follow the layout COMMAND|INFO|ID1,ID2,I3...\r\n+        // and use -1 when something is not needed (COMMAND|-1|-1)\r\n+        String eId = \"|\" + (entities.isEmpty() ? \"-1\" : entities.get(0).getId());\r\n+        String eIds = enToken(entities);\r\n+        String seIds = enToken(joinedEntities);\r\n+        \r\n+        popup.add(menuItem(\"View...\", \"VIEW\" + NOINFO + seIds, hasjoinedEntities, listener, KeyEvent.VK_V));\r\n+        popup.add(menuItem(\"View BV Calculation...\", \"BV\" + NOINFO + seIds, hasjoinedEntities, listener, KeyEvent.VK_B));\r\n+        popup.add(ScalingPopup.spacer());\r\n+\r\n+        if (joinedOneEntitySelected) {\r\n+            popup.add(menuItem(\"Configure...\", \"CONFIGURE\" + NOINFO + eId, hasjoinedEntities, listener, KeyEvent.VK_C));\r\n+        } else {\r\n+            popup.add(menuItem(\"Configure...\", \"CONFIGURE_ALL\" + NOINFO + seIds, hasjoinedEntities, listener, KeyEvent.VK_C));\r\n+        }\r\n+        popup.add(menuItem(\"Edit Damage...\", \"DAMAGE\" + NOINFO + seIds, hasjoinedEntities, listener, KeyEvent.VK_E));\r\n+        popup.add(menuItem(\"Set individual camo...\", \"INDI_CAMO\" + NOINFO + seIds, hasjoinedEntities, listener, KeyEvent.VK_I));\r\n+        popup.add(deployMenu(clientGui, hasjoinedEntities, listener, joinedEntities));\r\n+        popup.add(randomizeMenu(hasjoinedEntities, listener, seIds));\r\n+        popup.add(swapPilotMenu(hasjoinedEntities, joinedEntities, clientGui, listener));\r\n+        \r\n+        if (optBurstMG || optLRMHotLoad) {\r\n+            popup.add(equipMenu(anyRFMGOn, anyRFMGOff, anyHLOn, anyHLOff, optLRMHotLoad, optBurstMG, listener, seIds));\r\n+        }\r\n+        \r\n+        if (optQuirks) {\r\n+            popup.add(quirksMenu(!entities.isEmpty() && canSeeAll, listener, eIds));\r\n+        }\r\n+        \r\n+        popup.add(ScalingPopup.spacer());\r\n+        popup.add(changeOwnerMenu(!entities.isEmpty() || !forces.isEmpty(), clientGui, listener, entities, forces));\r\n+        popup.add(loadMenu(clientGui, true, listener, joinedEntities));\r\n+        \r\n+        if (accessibleCarriers) {\r\n+            popup.add(menuItem(\"Disembark / leave from carriers\", \"UNLOAD\" + NOINFO + seIds, !noneEmbarked, listener));\r\n+            popup.add(menuItem(\"Offload all carried units\", \"UNLOADALL\" + NOINFO + seIds, anyCarrier, listener));\r\n+        }\r\n+\r\n+        if (accessibleTransportBays) {\r\n+            popup.add(offloadBayMenu(anyCarrier, joinedEntities, listener));\r\n+        }\r\n+\r\n+        if (accessibleFighters && optCapFighters) {\r\n+            popup.add(squadronMenu(clientGui, true, listener, joinedEntities));\r\n+        }\r\n+\r\n+        if (accessibleProtomeks) {\r\n+            popup.add(protoMenu(clientGui, allProtomeks, listener, joinedEntities));\r\n+        }\r\n+        \r\n+        popup.add(c3Menu(hasjoinedEntities, joinedEntities, clientGui, listener));\r\n+        popup.add(forceMenu(lobby, entities, forces, listener));\r\n+        \r\n+        popup.add(ScalingPopup.spacer());\r\n+        popup.add(menuItem(\"Delete\", \"DELETE|\" + foToken(forces) + seIds, !entities.isEmpty() && forces.isEmpty(), listener, KeyEvent.VK_D));\r\n+        \r\n+        return popup;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Returns the \"Force\" submenu, allowing assignment to forces\r\n+     */\r\n+    private static JMenu forceMenu(ChatLounge lobby, List<Entity> entities, List<Force> forces, ActionListener listener) {\r\n+        JMenu menu = new JMenu(\"Force\");\r\n+        if (!forces.isEmpty() || !entities.isEmpty()) {\r\n+            menu.add(menuItem(\"Create Force from...\", \"FCREATEFROM|\" + foToken(forces) + enToken(entities), true, listener));\r\n+        }\r\n+        menu.add(menuItem(\"Add empty Force...\", \"FCREATETOP\" + NOINFO + NOINFO, true, listener));\r\n+        \r\n+        // If exactly one force is selected, offer force options\r\n+        if ((forces.size() == 1) && entities.isEmpty()) {\r\n+            Force force = forces.get(0);\r\n+            boolean editable = lobby.lobbyActions.isEditable(force);\r\n+            String fId = \"|\" + force.getId();\r\n+            menu.add(menuItem(\"Add Subforce...\", \"FCREATESUB\" + fId + NOINFO, editable, listener));\r\n+            menu.add(menuItem(\"Rename\", \"FRENAME\" + fId + NOINFO, editable, listener));\r\n+            menu.add(menuItem(\"Promote to Top-Level Force\", \"FPROMOTE\" + fId + NOINFO, editable && !force.isTopLevel(), listener));\r\n+        }\r\n+\r\n+        // If entities are selected but no forces, offer entity options\r\n+        if (forces.isEmpty() && !entities.isEmpty() && LobbyUtility.haveSingleOwner(entities)) {\r\n+            // Add to force menu tree\r\n+            JMenu addMenu = new JMenu(\"Add to...\");\r\n+            for (Force force: lobby.game().getForces().getTopLevelForces()) {\r\n+                addMenu.add(forceTreeMenu(force, lobby.game(), enToken(entities), listener));\r\n+            }\r\n+            menu.add(addMenu);\r\n+            menu.add(menuItem(\"Remove from Force\", \"FREMOVE\" + NOINFO + enToken(entities), true, listener));\r\n+        }\r\n+\r\n+        menu.setEnabled(menu.getItemCount() > 0);\r\n+        return menu;\r\n+    }\r\n+    \r\n+    private static JMenuItem forceTreeMenu(Force force, IGame game, String enToken, ActionListener listener) {\r\n+        JMenuItem result;\r\n+        String item = \"<HTML>\" + force.getName() + idString(game, force.getId());\r\n+        if (force.getSubForces().isEmpty()) {\r\n+            result = menuItem(item, \"FADDTO|\" + force.getId() + enToken, true, listener);\r\n+        } else {\r\n+            result = new JMenu(item);\r\n+            for (Integer subForceId: force.getSubForces()) {\r\n+                result.add(forceTreeMenu(game.getForces().getForce(subForceId), game, enToken, listener));\r\n+            }\r\n+        }\r\n+        return result;\r\n+    }\r\n+    \r\n+    static String idString(IGame game, int id) {\r\n+        if (PreferenceManager.getClientPreferences().getShowUnitId()) {\r\n+            return \" <FONT\" + UIUtil.colorString(UIUtil.uiGray()) +\">[\" + id + \"]</FONT>\"; \r\n+        } else {\r\n+            return \"\";\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the \"Load\" submenu, allowing general embarking\r\n+     */\r\n+    private static JMenu loadMenu(ClientGUI cg, boolean enabled, ActionListener listener,\r\n+            Collection<Entity> entities) {\r\n+\r\n+        IGame game = cg.getClient().getGame();\r\n+        JMenu menu = new JMenu(\"Load onto\");\r\n+        if (enabled && !entities.isEmpty()) {\r\n+\r\n+            // Dropship -> Jumpship loading gives free collars info\r\n+            if (entities.stream().allMatch(e -> e instanceof Dropship)) {\r\n+                game.getEntitiesVector().stream()\r\n+                .filter(e -> e instanceof Jumpship)\r\n+                .filter(e -> !entities.contains(e))\r\n+                .filter(e -> canLoadAll(e, entities))\r\n+                .forEach(e -> menu.add(menuItem(\r\n+                        \"<HTML>\" + e.getShortNameRaw() + idString(game, e.getId()) + \" (Free Collars: \" + ((Jumpship)e).getFreeDockingCollars() + \")\", \r\n+                        \"LOAD|\" + e.getId() + \":-1\" + enToken(entities), enabled, listener)));\r\n+            } else if (!entities.stream().anyMatch(e -> e.hasETypeFlag(Entity.ETYPE_PROTOMECH))) {\r\n+                // Standard loading, not protomeks, not dropship -> jumpship\r\n+                game.getEntitiesVector().stream()\r\n+                .filter(e -> !e.isCapitalFighter(true))\r\n+                .filter(e -> !entities.contains(e))\r\n+                .filter(e -> canLoadAll(e, entities))\r\n+                .forEach(e -> menu.add(menuItem(\r\n+                        \"<HTML>\" + e.getShortNameRaw() + idString(game, e.getId()), \r\n+                        \"LOAD|\" + e.getId() + \":-1\" + enToken(entities), enabled, listener)));\r\n+            }\r\n+        }\r\n+        menu.setEnabled(enabled && (menu.getItemCount() > 0));\r\n+        return menu;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the \"Load Protomech\" submenu\r\n+     */\r\n+    private static JMenu protoMenu(ClientGUI cg, boolean enabled, ActionListener listener,\r\n+            Collection<Entity> entities) {\r\n+\r\n+        JMenu menu = new JMenu(\"Load Protomek\");\r\n+        if (enabled && entities.stream().anyMatch(e -> e.hasETypeFlag(Entity.ETYPE_PROTOMECH))) {\r\n+            Entity entity = entities.stream().filter(e -> e.hasETypeFlag(Entity.ETYPE_PROTOMECH)).findAny().get();\r\n+            for (Entity loader: cg.getClient().getGame().getEntitiesVector()) {\r\n+                if (!loader.hasETypeFlag(Entity.ETYPE_MECH) || !loader.canLoad(entity, false)) {\r\n+                    continue;\r\n+                }\r\n+                Transporter front = null;\r\n+                Transporter rear = null;\r\n+                for (Transporter t : loader.getTransports()) {\r\n+                    if (t instanceof ProtomechClampMount) {\r\n+                        if (((ProtomechClampMount) t).isRear()) {\r\n+                            rear = t;\r\n+                        } else {\r\n+                            front = t;\r\n+                        }\r\n+                    }\r\n+                }\r\n+                JMenu loaderMenu = new JMenu(loader.getShortName());\r\n+                if ((front != null) && front.canLoad(entity)\r\n+                        && ((entity.getWeightClass() < EntityWeightClass.WEIGHT_SUPER_HEAVY)\r\n+                                || (rear == null) || rear.getLoadedUnits().isEmpty())) {\r\n+                    loaderMenu.add(menuItem(\"Onto Front\", \"LOAD|\" + loader.getId() + \":0\" + enToken(entities), enabled, listener));\r\n+                }\r\n+                boolean frontUltra = (front != null)\r\n+                        && front.getLoadedUnits().stream()\r\n+                        .anyMatch(l -> l.getWeightClass() == EntityWeightClass.WEIGHT_SUPER_HEAVY);\r\n+                if ((rear != null) && rear.canLoad(entity) && !frontUltra) {\r\n+                    loaderMenu.add(menuItem(\"Onto Rear\", \"LOAD|\" + loader.getId() + \":1\" + enToken(entities), enabled, listener));\r\n+                }\r\n+                if (loaderMenu.getItemCount() > 0) {\r\n+                    menu.add(loaderMenu);\r\n+                }\r\n+            }\r\n+        }\r\n+        menu.setEnabled(enabled && (menu.getItemCount() > 0));\r\n+        return menu;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the \"Fighter Squadron\" submenu, allowing to assign units to or\r\n+     * create a fighter squadron\r\n+     */\r\n+    private static JMenu squadronMenu(ClientGUI cg, boolean enabled, ActionListener listener,\r\n+            Collection<Entity> entities) {\r\n+\r\n+        JMenu menu = new JMenu(\"Fighter Squadrons\");\r\n+        boolean hasFighter = entities.stream().anyMatch(e -> e.isFighter());\r\n+        if (enabled && hasFighter) {\r\n+            menu.add(menuItem(\"Form Fighter Squadron\", \"SQUADRON\" + NOINFO + enToken(entities), enabled, listener));\r\n+\r\n+            // Join [Squadron] menu items\r\n+            cg.getClient().getGame().getEntitiesVector().stream()\r\n+                .filter(e -> e instanceof FighterSquadron)\r\n+                .filter(e -> !entities.contains(e))\r\n+                .filter(e -> canLoadAll(e, entities))\r\n+                .forEach(e -> menu.add(menuItem(\"Join \" + e.getShortName(), \r\n+                        \"LOAD|\" + e.getId() + \":-1\" + enToken(entities), enabled, listener)));\r\n+        }\r\n+        menu.setEnabled(enabled && (menu.getItemCount() > 0));\r\n+        return menu;\r\n+    }\r\n+    \r\n+    /** Returns true when the loader can load all the given entities (under lobby conditions). */\r\n+    private static boolean canLoadAll(Entity loader, Collection<Entity> entities) {\r\n+        return entities.stream().allMatch(e -> loader.canLoad(e, false));\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the \"Deploy\" submenu, allowing late deployment\r\n+     */\r\n+    private static JMenu deployMenu(ClientGUI clientGui, boolean enabled, ActionListener listener, \r\n+            Set<Entity> entities) {\r\n+\r\n+        String eIds = enToken(entities);\r\n+        JMenu menu = new JMenu(\"Deploy\");\r\n+        if (enabled) {\r\n+            // Hidden, Prone, Hull-down\r\n+            if (clientGui.getClient().getGame().getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)) {\r\n+                boolean anyHidden = entities.stream().anyMatch(Entity::isHidden);\r\n+                boolean anyNotHidden = entities.stream().anyMatch(e -> !e.isHidden());\r\n+                menu.add(menuItem(\"Hidden\", \"HIDDEN|HIDE\" + eIds, anyNotHidden, listener));\r\n+                menu.add(menuItem(\"Not Hidden\", \"HIDDEN|NOHIDE\" + eIds, anyHidden, listener));\r\n+                menu.add(ScalingPopup.spacer());\r\n+            }\r\n+\r\n+            menu.add(menuItem(\"Standing\", \"STAND|STAND\" + eIds, enabled, listener));\r\n+            menu.add(menuItem(\"Prone\", \"STAND|PRONE\" + eIds, enabled, listener));\r\n+            if (clientGui.getClient().getGame().getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_HULL_DOWN)) {\r\n+                menu.add(menuItem(\"Hull-Down\", \"STAND|HULLDOWN\" + eIds, enabled, listener));\r\n+            }\r\n+            menu.add(ScalingPopup.spacer());\r\n+\r\n+            // Heat\r\n+            JMenu heatMenu = new JMenu(\"Heat at start\");\r\n+            heatMenu.add(menuItem(\"No heat\", \"HEAT|0\" + eIds, enabled, listener));\r\n+            for (int i = 1; i < 11; i++) {\r\n+                heatMenu.add(menuItem(\"Heat \" + i, \"HEAT|\" + i + eIds, enabled, listener));\r\n+            }\r\n+            JMenu subHeatMenu = new JMenu(\"More heat\");\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY0Nzc5Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617647796", "bodyText": "I didnt think so. Assigning heat should be rare. assigning 7 heat is just a menu entry. And if you really need to assign 22 heat you can do that in that last submenu. Its sure blocky but gets it done. I have to add that personally I dislike any UI item that forces me to click a tiny arrow which is why I avoid Spinners.", "author": "SJuliez", "createdAt": "2021-04-21T15:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4Njk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTY4NzEyMQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r619687121", "bodyText": "Fair enough.", "author": "NickAragua", "createdAt": "2021-04-24T17:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4Njk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4NzQ3Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612887476", "bodyText": "What's being deprecated?", "author": "NickAragua", "createdAt": "2021-04-14T02:06:20Z", "path": "megamek/src/megamek/client/ui/swing/lobby/LobbyUtility.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/*  \r\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \r\n+*  \r\n+* This program is free software; you can redistribute it and/or modify it under  \r\n+* the terms of the GNU General Public License as published by the Free Software  \r\n+* Foundation; either version 2 of the License, or (at your option) any later  \r\n+* version.  \r\n+*  \r\n+* This program is distributed in the hope that it will be useful, but WITHOUT  \r\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+* details.  \r\n+*/ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import java.awt.Color;\r\n+import java.awt.Font;\r\n+import java.awt.FontMetrics;\r\n+import java.awt.Graphics;\r\n+import java.io.File;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.StringTokenizer;\r\n+\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.GUIPreferences;\r\n+import megamek.client.ui.swing.util.UIUtil;\r\n+import megamek.common.BattleArmorHandlesTank;\r\n+import megamek.common.Bay;\r\n+import megamek.common.Entity;\r\n+import megamek.common.FighterSquadron;\r\n+import megamek.common.IGame;\r\n+import megamek.common.IPlayer;\r\n+import megamek.common.MapSettings;\r\n+import megamek.common.TankTrailerHitch;\r\n+import megamek.common.Transporter;\r\n+import megamek.common.force.Force;\r\n+import megamek.common.options.GameOptions;\r\n+import megamek.common.options.OptionsConstants;\r\n+\r\n+/** \r\n+ * This class provides static helper functions for the Lobby aka ChatLounge. \r\n+ * @author Simon\r\n+ *\r\n+ */\r\n+public class LobbyUtility {\r\n+\r\n+    /**\r\n+     * Returns true when the starting position of the given player is valid\r\n+     * in the given game. This is not the case only when the options \"Double Blind\"\r\n+     * and \"Exclusive Starting Positions\" are on and the starting position overlaps\r\n+     * with that of other players, if \"Teams Share Vision\" is off, or enemy players,\r\n+     * if \"Teams Share Vision\" is on.\r\n+     * <P>See also {@link #startPosOverlap(IPlayer, IPlayer)}\r\n+     */\r\n+    static boolean isValidStartPos(IGame game, IPlayer player) {\r\n+        return isValidStartPos(game, player, player.getStartingPos());\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true when the given starting position pos is valid for the given player\r\n+     * in the given game. This is not the case only when the options \"Double Blind\"\r\n+     * and \"Exclusive Starting Positions\" are on and the starting position overlaps\r\n+     * with that of other players, if \"Teams Share Vision\" is off, or enemy players,\r\n+     * if \"Teams Share Vision\" is on.\r\n+     * <P>See also {@link #startPosOverlap(IPlayer, IPlayer)}\r\n+     */\r\n+    static boolean isValidStartPos(IGame game, IPlayer player, int pos) {\r\n+        if (!isExclusiveDeployment(game)) {\r\n+            return true;\r\n+        } else {\r\n+            if (isTeamsShareVision(game)) {\r\n+                return !game.getPlayersVector().stream().filter(p -> p.isEnemyOf(player))\r\n+                        .anyMatch(p -> startPosOverlap(pos, p.getStartingPos()));\r\n+            } else {\r\n+                return !game.getPlayersVector().stream().filter(p -> !p.equals(player))\r\n+                        .anyMatch(p -> startPosOverlap(pos, p.getStartingPos()));\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Returns true when double blind and exclusive deployment are on,\r\n+     * meaning that player's deployment zones may not overlap.\r\n+     */\r\n+    static boolean isExclusiveDeployment(IGame game) {\r\n+        final GameOptions gOpts = game.getOptions();\r\n+        return gOpts.booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)\r\n+                && gOpts.booleanOption(OptionsConstants.BASE_EXCLUSIVE_DB_DEPLOYMENT);\r\n+    }  \r\n+    \r\n+    /**\r\n+     * Returns true when blind drop is on.\r\n+     */\r\n+    static boolean isBlindDrop(IGame game) {\r\n+        final GameOptions gOpts = game.getOptions();\r\n+        return gOpts.booleanOption(OptionsConstants.BASE_BLIND_DROP);\r\n+    } \r\n+    \r\n+    /**\r\n+     * Returns true when real blind drop is on.\r\n+     */\r\n+    static boolean isRealBlindDrop(IGame game) {\r\n+        final GameOptions gOpts = game.getOptions();\r\n+        return gOpts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\r\n+    }  \r\n+    \r\n+    /**\r\n+     * Returns true when teams share vision is on, reagardless of whether\r\n+     * double blind is on.\r\n+     */\r\n+    static boolean isTeamsShareVision(IGame game) {\r\n+        final GameOptions gOpts = game.getOptions();\r\n+        return gOpts.booleanOption(OptionsConstants.ADVANCED_TEAM_VISION);\r\n+    } \r\n+    \r\n+    /** Returns true if the given entities all belong to the same player. */\r\n+    static boolean haveSingleOwner(Collection<Entity> entities) {\r\n+        return entities.stream().mapToInt(e -> e.getOwner().getId()).distinct().count() == 1;\r\n+    }\r\n+    \r\n+    /** Returns true if any of the given entities are embarked (transported by something). */ \r\n+    static boolean containsTransportedUnit(Collection<Entity> entities) {\r\n+        return entities.stream().anyMatch(e -> e.getTransportId() != Entity.NONE);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns true when the given board name does not start with one of the control strings\r\n+     * of MapSettings signalling a random, generated or surprise board. \r\n+     */ \r\n+    @SuppressWarnings(\"deprecation\")\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY0ODcwOQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617648709", "bodyText": "The RANDOM entry. I replaced the functionality with the Surprise method of choosing from a user-defined set of boards instead of all boards. But I havent replaced the RANDOM keyword.", "author": "SJuliez", "createdAt": "2021-04-21T15:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4NzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4ODAwNg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612888006", "bodyText": "This seems not very robust, but may be not worth it to do more \"properly\".", "author": "NickAragua", "createdAt": "2021-04-14T02:07:45Z", "path": "megamek/src/megamek/client/ui/swing/lobby/LobbyUtility.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/*  \r\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \r\n+*  \r\n+* This program is free software; you can redistribute it and/or modify it under  \r\n+* the terms of the GNU General Public License as published by the Free Software  \r\n+* Foundation; either version 2 of the License, or (at your option) any later  \r\n+* version.  \r\n+*  \r\n+* This program is distributed in the hope that it will be useful, but WITHOUT  \r\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+* details.  \r\n+*/ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import java.awt.Color;\r\n+import java.awt.Font;\r\n+import java.awt.FontMetrics;\r\n+import java.awt.Graphics;\r\n+import java.io.File;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.StringTokenizer;\r\n+\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.GUIPreferences;\r\n+import megamek.client.ui.swing.util.UIUtil;\r\n+import megamek.common.BattleArmorHandlesTank;\r\n+import megamek.common.Bay;\r\n+import megamek.common.Entity;\r\n+import megamek.common.FighterSquadron;\r\n+import megamek.common.IGame;\r\n+import megamek.common.IPlayer;\r\n+import megamek.common.MapSettings;\r\n+import megamek.common.TankTrailerHitch;\r\n+import megamek.common.Transporter;\r\n+import megamek.common.force.Force;\r\n+import megamek.common.options.GameOptions;\r\n+import megamek.common.options.OptionsConstants;\r\n+\r\n+/** \r\n+ * This class provides static helper functions for the Lobby aka ChatLounge. \r\n+ * @author Simon\r\n+ *\r\n+ */\r\n+public class LobbyUtility {\r\n+\r\n+    /**\r\n+     * Returns true when the starting position of the given player is valid\r\n+     * in the given game. This is not the case only when the options \"Double Blind\"\r\n+     * and \"Exclusive Starting Positions\" are on and the starting position overlaps\r\n+     * with that of other players, if \"Teams Share Vision\" is off, or enemy players,\r\n+     * if \"Teams Share Vision\" is on.\r\n+     * <P>See also {@link #startPosOverlap(IPlayer, IPlayer)}\r\n+     */\r\n+    static boolean isValidStartPos(IGame game, IPlayer player) {\r\n+        return isValidStartPos(game, player, player.getStartingPos());\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true when the given starting position pos is valid for the given player\r\n+     * in the given game. This is not the case only when the options \"Double Blind\"\r\n+     * and \"Exclusive Starting Positions\" are on and the starting position overlaps\r\n+     * with that of other players, if \"Teams Share Vision\" is off, or enemy players,\r\n+     * if \"Teams Share Vision\" is on.\r\n+     * <P>See also {@link #startPosOverlap(IPlayer, IPlayer)}\r\n+     */\r\n+    static boolean isValidStartPos(IGame game, IPlayer player, int pos) {\r\n+        if (!isExclusiveDeployment(game)) {\r\n+            return true;\r\n+        } else {\r\n+            if (isTeamsShareVision(game)) {\r\n+                return !game.getPlayersVector().stream().filter(p -> p.isEnemyOf(player))\r\n+                        .anyMatch(p -> startPosOverlap(pos, p.getStartingPos()));\r\n+            } else {\r\n+                return !game.getPlayersVector().stream().filter(p -> !p.equals(player))\r\n+                        .anyMatch(p -> startPosOverlap(pos, p.getStartingPos()));\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Returns true when double blind and exclusive deployment are on,\r\n+     * meaning that player's deployment zones may not overlap.\r\n+     */\r\n+    static boolean isExclusiveDeployment(IGame game) {\r\n+        final GameOptions gOpts = game.getOptions();\r\n+        return gOpts.booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)\r\n+                && gOpts.booleanOption(OptionsConstants.BASE_EXCLUSIVE_DB_DEPLOYMENT);\r\n+    }  \r\n+    \r\n+    /**\r\n+     * Returns true when blind drop is on.\r\n+     */\r\n+    static boolean isBlindDrop(IGame game) {\r\n+        final GameOptions gOpts = game.getOptions();\r\n+        return gOpts.booleanOption(OptionsConstants.BASE_BLIND_DROP);\r\n+    } \r\n+    \r\n+    /**\r\n+     * Returns true when real blind drop is on.\r\n+     */\r\n+    static boolean isRealBlindDrop(IGame game) {\r\n+        final GameOptions gOpts = game.getOptions();\r\n+        return gOpts.booleanOption(OptionsConstants.BASE_REAL_BLIND_DROP);\r\n+    }  \r\n+    \r\n+    /**\r\n+     * Returns true when teams share vision is on, reagardless of whether\r\n+     * double blind is on.\r\n+     */\r\n+    static boolean isTeamsShareVision(IGame game) {\r\n+        final GameOptions gOpts = game.getOptions();\r\n+        return gOpts.booleanOption(OptionsConstants.ADVANCED_TEAM_VISION);\r\n+    } \r\n+    \r\n+    /** Returns true if the given entities all belong to the same player. */\r\n+    static boolean haveSingleOwner(Collection<Entity> entities) {\r\n+        return entities.stream().mapToInt(e -> e.getOwner().getId()).distinct().count() == 1;\r\n+    }\r\n+    \r\n+    /** Returns true if any of the given entities are embarked (transported by something). */ \r\n+    static boolean containsTransportedUnit(Collection<Entity> entities) {\r\n+        return entities.stream().anyMatch(e -> e.getTransportId() != Entity.NONE);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns true when the given board name does not start with one of the control strings\r\n+     * of MapSettings signalling a random, generated or surprise board. \r\n+     */ \r\n+    @SuppressWarnings(\"deprecation\")\r\n+    static boolean isBoardFile(String board) {\r\n+        return !board.startsWith(MapSettings.BOARD_GENERATED)\r\n+                && !board.startsWith(MapSettings.BOARD_RANDOM)\r\n+                && !board.startsWith(MapSettings.BOARD_SURPRISE);\r\n+    }\r\n+    \r\n+    /** Returns a formatted and colored tooltip string warning that a board is invalid. */\r\n+    static String invalidBoardTip() {\r\n+        return UIUtil.guiScaledFontHTML(GUIPreferences.getInstance().getWarningColor())\r\n+                + Messages.getString(\"ChatLounge.map.invalidTip\") + \"</FONT>\";\r\n+    }\r\n+    \r\n+    /** \r\n+     * Draws the given text (the board name or special text) as a label on the\r\n+     * lower edge of the image for which the graphics g is given.\r\n+     */\r\n+    static void drawMinimapLabel(String text, int w, int h, Graphics g, boolean invalid) {\r\n+        if (text.length() == 0) {\r\n+            return;\r\n+        }\r\n+        GUIPreferences.AntiAliasifSet(g);\r\n+        // The text size may grow with the width of the image, but no bigger than 16*guiscale\r\n+        // to avoid huge text\r\n+        int fontSize = Math.min(w / 10, UIUtil.scaleForGUI(16));\r\n+        Font font = new Font(\"Dialog\", Font.PLAIN, fontSize);\r\n+        g.setFont(font);\r\n+        FontMetrics fm = g.getFontMetrics(font);\r\n+        int th = fm.getAscent() + fm.getDescent(); // The text height\r\n+        int cx = (w - fm.stringWidth(text)) / 2; // The left edge for centered text\r\n+        // When the text is wider than the image, let the text start close to the left edge \r\n+        cx = Math.max(w / 20, cx);\r\n+        int cy = h - th / 2;\r\n+        Color col = new Color(250, 250, 250, 140);\r\n+        if (text.startsWith(Messages.getString(\"ChatLounge.MapSurprise\"))) {\r\n+            col = new Color(250, 250, 50, 140);\r\n+        } else if (text.startsWith(Messages.getString(\"ChatLounge.MapGenerated\"))) {\r\n+            col = new Color(50, 50, 250, 140);\r\n+        }\r\n+        if (invalid) {\r\n+            col = GUIPreferences.getInstance().getWarningColor();\r\n+        }\r\n+        g.setColor(col);\r\n+        g.fillRoundRect(cx - 3, cy - fm.getAscent(), w - 2 * cx + 6, th, fontSize/2, fontSize/2);\r\n+        // Clip the text to inside the image with a margin of w/20\r\n+        g.setClip(w / 20, 0, w - w / 10, h);\r\n+        g.setColor(Color.BLACK);\r\n+        g.drawString(text, cx, cy);\r\n+        g.setClip(null);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Removes the board size (\"16x17\") and file path from the given board name if it is\r\n+     * a board file. Also, reconstructs the text if it's a surprise map or generated map.\r\n+     */\r\n+    static String cleanBoardName(String boardName, MapSettings mapSettings) {\r\n+        // Remove the file path\r\n+        if (isBoardFile(boardName)) {\r\n+            boardName = new File(boardName).getName();\r\n+        }\r\n+        // Construct the text if it's a surprise map\r\n+        if (boardName.startsWith(MapSettings.BOARD_SURPRISE)) {\r\n+            int numBoards = extractSurpriseMaps(boardName).size();\r\n+            boardName = Messages.getString(\"ChatLounge.MapSurprise\") + \" (\" + numBoards + \" boards)\";\r\n+        }\r\n+        // Construct the text if it's a generated map\r\n+        if (boardName.startsWith(MapSettings.BOARD_GENERATED)) {\r\n+            boardName = Messages.getString(\"ChatLounge.MapGenerated\");\r\n+        }\r\n+        // Remove board sizes (\"16x17\")\r\n+        String boardSize = mapSettings.getBoardWidth() + \"x\" + mapSettings.getBoardHeight();\r\n+        return boardName.replace(boardSize, \"\").trim();\r\n+    }\r\n+    \r\n+    /** \r\n+     * Specialized method that returns a list of board names from the given \r\n+     * boardsString that starts with the prefix for a Surprise board.  \r\n+     */ \r\n+    public static ArrayList<String> extractSurpriseMaps(String boardsString) {\r\n+        if (boardsString.startsWith(MapSettings.BOARD_SURPRISE)) {\r\n+            boardsString = boardsString.substring(MapSettings.BOARD_SURPRISE.length());\r\n+        }\r\n+        String[] boards = boardsString.split(\"\\n\");\r\n+        ArrayList<String> result = new ArrayList<String>();\r\n+        result.addAll(Arrays.asList(boards));\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Converts an id list of the form 1,2,4,12 to a set of corresponding entities.\r\n+     * Ignores entity ids that don't exist. The resulting list may be empty but not null. \r\n+     */ \r\n+    public static HashSet<Entity> getEntities(IGame game, String idList) {\r\n+        StringTokenizer st = new StringTokenizer(idList, \",\");\r\n+        HashSet<Entity> result = new HashSet<>();\r\n+        while (st.hasMoreTokens()) {\r\n+            int id = Integer.parseInt(st.nextToken());\r\n+            Entity entity = game.getEntity(id);\r\n+            if (entity != null) {\r\n+                result.add(entity);\r\n+            }\r\n+        }\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Converts an id list of the form 1,2,4,12 to a set of corresponding forces.\r\n+     * Ignores force ids that don't exist. The resulting list may be empty but not null. \r\n+     */ \r\n+    public static HashSet<Force> getForces(IGame game, String idList) {\r\n+        StringTokenizer st = new StringTokenizer(idList, \",\");\r\n+        HashSet<Force> result = new HashSet<>();\r\n+        while (st.hasMoreTokens()) {\r\n+            int id = Integer.parseInt(st.nextToken());\r\n+            Force force = game.getForces().getForce(id);\r\n+            if (force != null) {\r\n+                result.add(force);\r\n+            }\r\n+        }\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns true if a and b share at least one non-hierarchic C3 system\r\n+     * (C3i, Naval C3, Nova CEWS). Symmetrical (the order of a and b does not matter). \r\n+     */\r\n+    public static boolean sameNhC3System(Entity a, Entity b) {\r\n+        return (a.hasC3i() && b.hasC3i()) \r\n+                || (a.hasNavalC3() && b.hasNavalC3()) \r\n+                || (a.hasNovaCEWS() && b.hasNovaCEWS());\r\n+    }\r\n+    \r\n+    /** Returns the string with some content shortened like Battle Armor -> BA */\r\n+    static String abbreviateUnitName(String unitName) {\r\n+        return unitName\r\n+                .replace(\"(Standard)\", \"\").replace(\"Battle Armor\", \"BA\")\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY1MTI2Nw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617651267", "bodyText": "Yes. This only abbreviates the unit names for compact display. Doesnt need to be successful.", "author": "SJuliez", "createdAt": "2021-04-21T15:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4ODAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4ODYyNQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612888625", "bodyText": "Can you go through some of these and put the standard megamek header on them?", "author": "NickAragua", "createdAt": "2021-04-14T02:08:42Z", "path": "megamek/src/megamek/client/ui/swing/lobby/MekForceTreeCellFormatter.java", "diffHunk": "@@ -0,0 +1,794 @@\n+package megamek.client.ui.swing.lobby;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4ODk1Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612888956", "bodyText": "Do we want to maybe put a cap on this activity then?", "author": "NickAragua", "createdAt": "2021-04-14T02:09:28Z", "path": "megamek/src/megamek/client/ui/swing/lobby/MekForceTreeCellFormatter.java", "diffHunk": "@@ -0,0 +1,794 @@\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import static megamek.client.ui.swing.lobby.MekTableModel.DOT_SPACER;\r\n+import static megamek.client.ui.swing.util.UIUtil.*;\r\n+import static megamek.client.ui.Messages.getString;\r\n+\r\n+import java.awt.Color;\r\n+import java.text.MessageFormat;\r\n+import java.util.ArrayList;\r\n+import megamek.client.Client;\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.GUIPreferences;\r\n+import megamek.common.Aero;\r\n+import megamek.common.Board;\r\n+import megamek.common.Crew;\r\n+import megamek.common.Entity;\r\n+import megamek.common.FighterSquadron;\r\n+import megamek.common.GunEmplacement;\r\n+import megamek.common.IGame;\r\n+import megamek.common.IPlayer;\r\n+import megamek.common.IStartingPositions;\r\n+import megamek.common.Infantry;\r\n+import megamek.common.MapSettings;\r\n+import megamek.common.Mech;\r\n+import megamek.common.Protomech;\r\n+import megamek.common.Tank;\r\n+import megamek.common.UnitType;\r\n+import megamek.common.VTOL;\r\n+import megamek.common.force.Force;\r\n+import megamek.common.options.OptionsConstants;\r\n+import megamek.common.preference.PreferenceManager;\r\n+import megamek.common.util.CollectionUtil;\r\n+\r\n+public class MekForceTreeCellFormatter {\r\n+    \r\n+    /** \r\n+     * Creates and returns the display content of the C3-MekTree cell for the given entity and \r\n+     * for the compact display mode. Assumes that no enemy or blind-drop-hidden units are provided. \r\n+     */\r\n+    static String formatForceCompact(Force force, ChatLounge lobby) {\r\n+        Client client = lobby.getClientgui().getClient();\r\n+        IGame game = client.getGame();\r\n+        IPlayer localPlayer = client.getLocalPlayer();\r\n+        int ownerId = game.getForces().getOwnerId(force);\r\n+        IPlayer owner = game.getPlayer(ownerId);\r\n+        \r\n+        // Get the my / ally / enemy color and desaturate it\r\n+        Color color = GUIPreferences.getInstance().getEnemyUnitColor();\r\n+        if (ownerId == localPlayer.getId()) {\r\n+            color = GUIPreferences.getInstance().getMyUnitColor();\r\n+        } else if (!localPlayer.isEnemyOf(owner)) {\r\n+            color = GUIPreferences.getInstance().getAllyUnitColor();\r\n+        }\r\n+        color = addGray(color, 128).brighter();\r\n+\r\n+        StringBuilder result = new StringBuilder(\"<HTML><NOBR>\");\r\n+        result.append(guiScaledFontHTML(color, 0.2f)).append(\"\");\r\n+        \r\n+        // A top-level / subforce special char\r\n+        if (force.isTopLevel()) {\r\n+            result.append(\"\\u2327&nbsp;&nbsp; \");\r\n+        } else {\r\n+            result.append(\"\\u25E5&nbsp;&nbsp; \");\r\n+        }\r\n+        \r\n+        // Name\r\n+        result.append(\"<B>\").append(force.getName()).append(\"</B></FONT>\");\r\n+        \r\n+        // ID\r\n+        if (PreferenceManager.getClientPreferences().getShowUnitId()) {\r\n+            result.append(guiScaledFontHTML(uiGray(), 0.2f));\r\n+            result.append(\" [\").append(force.getId()).append(\"]</FONT>\");\r\n+        }\r\n+        \r\n+        // Owner\r\n+        if (game.getForces().getOwnerId(force) != client.getLocalPlayerNumber()) {\r\n+            result.append(guiScaledFontHTML(0.2f));\r\n+            result.append(DOT_SPACER).append(\"</FONT>\");\r\n+            result.append(guiScaledFontHTML(owner.getColour().getColour(), 0.2f));\r\n+            result.append(\"\\u2691 \");\r\n+            result.append(owner.getName()).append(\"</FONT>\");\r\n+        }\r\n+        \r\n+        // BV\r\n+        ArrayList<Entity> fullEntities = lobby.game().getForces().getFullEntities(force);\r\n+        result.append(guiScaledFontHTML(color));\r\n+        result.append(DOT_SPACER);\r\n+        int totalBv = fullEntities.stream().filter(e -> !e.isPartOfFighterSquadron()).mapToInt(e -> e.calculateBattleValue()).sum();\r\n+        if (totalBv > 0) {\r\n+            result.append(\"BV \").append(String.format(\"%,d\", totalBv));\r\n+            // Unit Type\r\n+            long unittypes = fullEntities.stream().map(e -> Entity.getEntityMajorTypeName(e.getEntityType())).distinct().count();\r\n+            result.append(guiScaledFontHTML(color));\r\n+            result.append(DOT_SPACER);\r\n+            if (unittypes > 1) {\r\n+                result.append(\" Mixed\");\r\n+            } else if (unittypes == 1) {\r\n+                Entity entity = CollectionUtil.randomElement(fullEntities);\r\n+                result.append(UnitType.getTypeName(entity.getUnitType()));\r\n+            }\r\n+        } else {\r\n+            result.append(\"Empty\");\r\n+        }\r\n+        result.append(\"</FONT>\");\r\n+\r\n+        return result.toString();\r\n+    }\r\n+    \r\n+    /** \r\n+     * Creates and returns the display content of the C3-MekTree cell for the given entity and \r\n+     * for the compact display mode. Assumes that no enemy or blind-drop-hidden units are provided. \r\n+     */\r\n+    static String formatForceFull(Force force, ChatLounge lobby) {\r\n+        Client client = lobby.getClientgui().getClient();\r\n+        IGame game = client.getGame();\r\n+        IPlayer localPlayer = client.getLocalPlayer();\r\n+        int ownerId = game.getForces().getOwnerId(force);\r\n+        IPlayer owner = game.getPlayer(ownerId);\r\n+        \r\n+        // Get the my / ally / enemy color and desaturate it\r\n+        Color color = GUIPreferences.getInstance().getEnemyUnitColor();\r\n+        if (ownerId == localPlayer.getId()) {\r\n+            color = GUIPreferences.getInstance().getMyUnitColor();\r\n+        } else if (!localPlayer.isEnemyOf(owner)) {\r\n+            color = GUIPreferences.getInstance().getAllyUnitColor();\r\n+        }\r\n+        color = addGray(color, 128).brighter();\r\n+        \r\n+        StringBuilder result = new StringBuilder(\"<HTML><NOBR>\");\r\n+        formatSpan(result, color);\r\n+        \r\n+        // A top-level / subforce special char\r\n+        if (force.isTopLevel()) {\r\n+            result.append(\"\\u2327&nbsp;&nbsp; \");\r\n+        } else {\r\n+            result.append(\"\\u25E5&nbsp;&nbsp; \");\r\n+        }\r\n+        \r\n+        // Name\r\n+        result.append(\"<B>\").append(force.getName()).append(\"</B>\");\r\n+        \r\n+        // ID\r\n+        if (PreferenceManager.getClientPreferences().getShowUnitId()) {\r\n+            fullidString(result, force.getId());\r\n+        }\r\n+        \r\n+        // Owner\r\n+        if (game.getForces().getOwnerId(force) != client.getLocalPlayerNumber()) {\r\n+            result.append(DOT_SPACER);\r\n+            formatSpan(result, owner.getColour().getColour());\r\n+            result.append(\"\\u2691 \");\r\n+            result.append(owner.getName()).append(\"</SPAN>\");\r\n+        }\r\n+        \r\n+        // BV\r\n+        // This takes a crazy amount of time when regiments are in the game\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY2NDQ1MQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617664451", "bodyText": "I think it won't help much. \"Crazy\" overstates it. I just found it crazy considering what little info-gathering this code does. With 50+ units in the game, the updates start getting noticeable. With 500 units we're speaking of around a second for an update, but changing something may trigger several updates depending on #players and other things. So things get slow. There's no single thing to change to make it faster, unfortunately. Updating stuff for each player, the icons, the text formatting, the info gathering all works together. Turning this force fluff info off won't change anything for most games and for the few ones with really many units it won't make it super fast.", "author": "SJuliez", "createdAt": "2021-04-21T15:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg4ODk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg5NzcxOA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612897718", "bodyText": "This looks awfully similar to MekForceTreeCellFormatter, is there a way to unify the rendering code?", "author": "NickAragua", "createdAt": "2021-04-14T02:39:16Z", "path": "megamek/src/megamek/client/ui/swing/lobby/MekTableCellFormatter.java", "diffHunk": "@@ -0,0 +1,638 @@\n+/*  \r\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \r\n+*  \r\n+* This program is free software; you can redistribute it and/or modify it under  \r\n+* the terms of the GNU General Public License as published by the Free Software  \r\n+* Foundation; either version 2 of the License, or (at your option) any later  \r\n+* version.  \r\n+*  \r\n+* This program is distributed in the hope that it will be useful, but WITHOUT  \r\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+* details.  \r\n+*/ \r\n+package megamek.client.ui.swing.lobby;\r\n+\r\n+import static megamek.client.ui.swing.util.UIUtil.*;\r\n+\r\n+import java.text.MessageFormat;\r\n+\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.GUIPreferences;\r\n+import megamek.common.Aero;\r\n+import megamek.common.Board;\r\n+import megamek.common.Crew;\r\n+import megamek.common.Entity;\r\n+import megamek.common.FighterSquadron;\r\n+import megamek.common.GunEmplacement;\r\n+import megamek.common.IStartingPositions;\r\n+import megamek.common.Infantry;\r\n+import megamek.common.MapSettings;\r\n+import megamek.common.Mech;\r\n+import megamek.common.Protomech;\r\n+import megamek.common.Tank;\r\n+import megamek.common.VTOL;\r\n+import megamek.common.options.GameOptions;\r\n+import megamek.common.options.OptionsConstants;\r\n+import megamek.common.preference.PreferenceManager;\r\n+import megamek.common.util.CrewSkillSummaryUtil;\r\n+import static megamek.client.ui.swing.lobby.MekTableModel.DOT_SPACER;\r\n+\r\n+public class MekTableCellFormatter {\r\n+    \r\n+    /** \r\n+     * Creates and returns the display content of the Unit column for the given entity and \r\n+     * for the compact display mode. \r\n+     * When blindDrop is true, the unit details are not given.\r\n+     */\r\n+    static String formatUnitCompact(Entity entity, boolean blindDrop, int mapType) {\r\n+        \r\n+        if (blindDrop) {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg5ODU2Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612898566", "bodyText": "Let's clean up the commented out code in here.", "author": "NickAragua", "createdAt": "2021-04-14T02:42:38Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/ForceSorter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import java.util.ArrayList;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+import megamek.common.force.Force;\r\n+\r\n+public class ForceSorter implements MekTableSorter {\r\n+\r\n+private ClientGUI clientGui;\r\n+    \r\n+    /** A Lobby Mek Table sorter that sorts mainly by association to forces. */\r\n+    public ForceSorter(ClientGUI cg) {\r\n+        clientGui = cg;\r\n+    }\r\n+    \r\n+    @Override\r\n+    public String getDisplayName() {\r\n+        return \"Forces\";\r\n+    }\r\n+    \r\n+    @Override\r\n+    public int getColumnIndex() {\r\n+        return MekTableModel.COL_UNIT;\r\n+    }\r\n+\r\n+    @Override\r\n+    public int compare(final Entity a, final Entity b) {\r\n+        final IPlayer p_a = clientGui.getClient().getGame().getPlayer(a.getOwnerId());\r\n+        final IPlayer p_b = clientGui.getClient().getGame().getPlayer(b.getOwnerId());\r\n+        final IPlayer localPlayer = clientGui.getClient().getLocalPlayer();\r\n+        final int localteam = localPlayer.getTeam();\r\n+        final int team_a = p_a.getTeam();\r\n+        final int team_b = p_b.getTeam();\r\n+//        String force_a = a.getForce();\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY2NTkzMw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617665933", "bodyText": "No longer used, deleted.", "author": "SJuliez", "createdAt": "2021-04-21T15:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjg5ODU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjkwODU4MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612908580", "bodyText": "Comment doesn't match method name or behavior.", "author": "NickAragua", "createdAt": "2021-04-14T03:17:54Z", "path": "megamek/src/megamek/client/ui/swing/tooltip/UnitToolTip.java", "diffHunk": "@@ -0,0 +1,870 @@\n+/*  \r\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \r\n+*  \r\n+* This program is free software; you can redistribute it and/or modify it under  \r\n+* the terms of the GNU General Public License as published by the Free Software  \r\n+* Foundation; either version 2 of the License, or (at your option) any later  \r\n+* version.  \r\n+*  \r\n+* This program is distributed in the hope that it will be useful, but WITHOUT  \r\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+* details.  \r\n+*/  \r\n+package megamek.client.ui.swing.tooltip;\r\n+\r\n+import java.awt.Color;\r\n+import java.text.MessageFormat;\r\n+import java.util.ArrayList;\r\n+import java.util.Comparator;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map.Entry;\r\n+import java.util.stream.Collectors;\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.GUIPreferences;\r\n+import megamek.client.ui.swing.util.UIUtil;\r\n+import megamek.common.*;\r\n+import megamek.common.IGame.Phase;\r\n+import megamek.common.annotations.Nullable;\r\n+import megamek.common.options.*;\r\n+import megamek.common.preference.PreferenceManager;\r\n+import megamek.common.weapons.LegAttack;\r\n+import megamek.common.weapons.StopSwarmAttack;\r\n+import megamek.common.weapons.SwarmAttack;\r\n+import megamek.common.weapons.SwarmWeaponAttack;\r\n+\r\n+import static megamek.client.ui.swing.tooltip.TipUtil.*;\r\n+import static megamek.client.ui.swing.util.UIUtil.*;\r\n+\r\n+public final class UnitToolTip {\r\n+    \r\n+    /** The font size reduction for Quirks */\r\n+    final static float TT_SMALLFONT_DELTA = -0.2f;\r\n+    \r\n+    /** Returns the unit tooltip with values that are relevant in the lobby. */\r\n+    public static StringBuilder getEntityTipLobby(Entity entity, IPlayer localPlayer, \r\n+            MapSettings mapSettings) {\r\n+        return getEntityTip(entity, localPlayer, true, mapSettings);\r\n+    }\r\n+    \r\n+    /** Returns the unit tooltip with values that are relevant in-game. */\r\n+    public static StringBuilder getEntityTipGame(Entity entity, IPlayer localPlayer) {\r\n+        return getEntityTip(entity, localPlayer, false, null);\r\n+    }\r\n+\r\n+    // PRIVATE\r\n+    \r\n+    /** Assembles the whole unit tooltip. */\r\n+    private static StringBuilder getEntityTip(Entity entity, IPlayer localPlayer, \r\n+            boolean inLobby, @Nullable MapSettings mapSettings) {\r\n+        \r\n+        // Tooltip info for a sensor blip\r\n+        if (EntityVisibilityUtils.onlyDetectedBySensors(localPlayer, entity)) {\r\n+            return new StringBuilder(Messages.getString(\"BoardView1.sensorReturn\"));\r\n+        }\r\n+\r\n+        StringBuilder result = new StringBuilder();\r\n+        IGame game = entity.getGame();\r\n+        GUIPreferences guip = GUIPreferences.getInstance();\r\n+\r\n+        // Unit Chassis and Player\r\n+        IPlayer owner = game.getPlayer(entity.getOwnerId());\r\n+        result.append(guiScaledFontHTML(entity.getOwner().getColour().getColour()));\r\n+        result.append(addToTT(\"ChassisPlayer\", NOBR, entity.getChassis(), owner.getName()));\r\n+        result.append(UIUtil.guiScaledFontHTML(UIUtil.uiGray()));\r\n+        result.append(MessageFormat.format(\" [ID: {0}] </FONT>\", entity.getId()));\r\n+        result.append(\"</FONT>\");\r\n+\r\n+        // Pilot; in the lounge the pilot is separate so don't add it there\r\n+        if (inLobby && (mapSettings != null)) {\r\n+            result.append(deploymentWarnings(entity, localPlayer, mapSettings));\r\n+            result.append(\"<BR>\");\r\n+        } else {\r\n+            result.append(forceEntry(entity, localPlayer));\r\n+            result.append(inGameValues(entity, localPlayer));\r\n+            result.append(PilotToolTip.getPilotTipShort(entity));\r\n+        }\r\n+        \r\n+        // An empty squadron should not show any info\r\n+        if (entity instanceof FighterSquadron && entity.getLoadedUnits().isEmpty()) {\r\n+            return result;\r\n+        }\r\n+\r\n+        // Static entity values like move capability\r\n+        result.append(guiScaledFontHTML());\r\n+        result.append(entityValues(entity));\r\n+        result.append(\"</FONT>\");\r\n+\r\n+        // Status bar visual representation of armor and IS \r\n+        if (guip.getBoolean(GUIPreferences.SHOW_ARMOR_MINIVIS_TT)) {\r\n+            result.append(scaledHTMLSpacer(3));\r\n+            result.append(addArmorMiniVisToTT(entity));\r\n+        }\r\n+\r\n+        // Weapon List\r\n+        if (guip.getBoolean(GUIPreferences.SHOW_WPS_IN_TT)) {\r\n+            result.append(scaledHTMLSpacer(3));\r\n+            result.append(guiScaledFontHTML());\r\n+            result.append(weaponList(entity));\r\n+            result.append(ecmInfo(entity));\r\n+            result.append(\"</FONT>\");\r\n+        }\r\n+\r\n+        // StratOps quirks, chassis and weapon\r\n+        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_STRATOPS_QUIRKS)) {\r\n+            result.append(scaledHTMLSpacer(3));\r\n+            result.append(guiScaledFontHTML(uiQuirksColor(), TT_SMALLFONT_DELTA));\r\n+            String quirksList = getOptionList(entity.getQuirks().getGroups(), \r\n+                    grp -> entity.countQuirks(grp), inLobby);\r\n+            if (!quirksList.isEmpty()) {\r\n+                result.append(quirksList);\r\n+            }\r\n+            for (Mounted weapon: entity.getWeaponList()) {\r\n+                String wpQuirksList = getOptionList(weapon.getQuirks().getGroups(), \r\n+                        grp -> weapon.countQuirks(), (e) -> weapon.getDesc(), inLobby);\r\n+                if (!wpQuirksList.isEmpty()) {\r\n+                    // Line break after weapon name not useful here\r\n+                    result.append(wpQuirksList.replace(\":</I><BR>\", \":</I>\"));\r\n+                }\r\n+            }\r\n+            result.append(\"</FONT>\");\r\n+        }\r\n+\r\n+        // Partial repairs\r\n+        String partialList = getOptionList(entity.getPartialRepairs().getGroups(), \r\n+                grp -> entity.countPartialRepairs(), inLobby);\r\n+        if (!partialList.isEmpty()) {\r\n+            result.append(scaledHTMLSpacer(3));\r\n+            result.append(guiScaledFontHTML(uiPartialRepairColor(), TT_SMALLFONT_DELTA));\r\n+            result.append(partialList);\r\n+            result.append(\"</FONT>\");\r\n+        }\r\n+        \r\n+        if (!entity.getLoadedUnits().isEmpty()) {\r\n+            result.append(scaledHTMLSpacer(3));\r\n+            result.append(carriedUnits(entity));\r\n+        }\r\n+        \r\n+        if (inLobby && entity.hasAnyC3System()) {\r\n+            result.append(scaledHTMLSpacer(3));\r\n+            result.append(c3Info(entity));\r\n+        }\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** Returns the graphical Armor reprentation. */\r\n+    private static StringBuilder addArmorMiniVisToTT(Entity entity) {\r\n+        GUIPreferences guip = GUIPreferences.getInstance();\r\n+        String armorChar = guip.getString(GUIPreferences.ADVANCED_ARMORMINI_ARMOR_CHAR);\r\n+        if (entity.isCapitalScale()) {\r\n+            armorChar = guip.getString(GUIPreferences.ADVANCED_ARMORMINI_CAP_ARMOR_CHAR);\r\n+        }\r\n+        String internalChar = guip.getString(GUIPreferences.ADVANCED_ARMORMINI_IS_CHAR);\r\n+        Color colorDamaged = guip.getColor(GUIPreferences.ADVANCED_ARMORMINI_COLOR_DAMAGED);\r\n+        StringBuilder result = new StringBuilder();\r\n+        result.append(\"<TABLE CELLSPACING=0 CELLPADDING=0><TBODY>\");\r\n+        for (int loc = 0 ; loc < entity.locations(); loc++) {\r\n+            // do not show locations that do not support/have armor/internals like HULL on Aero\r\n+            if (entity.getOArmor(loc) <= 0 && entity.getOInternal(loc) <= 0 && !entity.hasRearArmor(loc)) {\r\n+                continue;\r\n+            }\r\n+            result.append(\"<TR><TD>\");\r\n+            if (entity.getInternal(loc) == IArmorState.ARMOR_DOOMED ||\r\n+                    entity.getInternal(loc) == IArmorState.ARMOR_DESTROYED) {\r\n+                // Destroyed location\r\n+                result.append(\"</TD><TD></TD><TD>\");\r\n+                result.append(guiScaledFontHTML(TT_SMALLFONT_DELTA));\r\n+                result.append(\"&nbsp;&nbsp;\" + entity.getLocationAbbr(loc)+ \":&nbsp;\");\r\n+                result.append(\"</FONT></TD><TD>\");\r\n+                result.append(guiScaledFontHTML(colorDamaged, TT_SMALLFONT_DELTA));\r\n+                result.append(destroyedLocBar(entity.getOArmor(loc, true)));\r\n+                result.append(\"</FONT>\");\r\n+            } else {\r\n+                // Rear armor\r\n+                if (entity.hasRearArmor(loc)) {\r\n+                    result.append(guiScaledFontHTML(TT_SMALLFONT_DELTA));\r\n+                    result.append(\"&nbsp;&nbsp;\" + entity.getLocationAbbr(loc)+ \"R:&nbsp;\");\r\n+                    result.append(\"</FONT></TD><TD>\");\r\n+                    result.append(intactLocBar(entity.getOArmor(loc, true), entity.getArmor(loc, true), armorChar));\r\n+                    result.append(\"</TD><TD>\");\r\n+                } else {\r\n+                    // No rear armor: empty table cells instead\r\n+                    // At small font sizes, writing one character at the correct font size is \r\n+                    // necessary to prevent the table rows from being spaced non-beautifully\r\n+                    result.append(guiScaledFontHTML(TT_SMALLFONT_DELTA) + \"&nbsp;</FONT></TD><TD>\");\r\n+                    result.append(guiScaledFontHTML(TT_SMALLFONT_DELTA) + \"&nbsp;</FONT></TD><TD>\");\r\n+                }\r\n+                // Front armor\r\n+                result.append(guiScaledFontHTML(TT_SMALLFONT_DELTA));\r\n+                result.append(\"&nbsp;&nbsp;\" + entity.getLocationAbbr(loc)+ \":&nbsp;\");\r\n+                result.append(\"</FONT></TD><TD>\");\r\n+                result.append(intactLocBar(entity.getOInternal(loc), entity.getInternal(loc), internalChar));\r\n+                result.append(intactLocBar(entity.getOArmor(loc), entity.getArmor(loc), armorChar));\r\n+                result.append(\"</TD></TR>\");\r\n+            }\r\n+        }\r\n+        result.append(\"</TBODY></TABLE>\");\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Used for destroyed locations.\r\n+     * Returns a string representing armor or internal structure of the location.\r\n+     * The location has the given orig original Armor/IS. \r\n+     */\r\n+    private static StringBuilder destroyedLocBar(int orig) {\r\n+        GUIPreferences guip = GUIPreferences.getInstance();\r\n+        String destroyedChar = guip.getString(GUIPreferences.ADVANCED_ARMORMINI_DESTROYED_CHAR);\r\n+        return locBar(orig, orig, destroyedChar, true);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Used for intact locations.\r\n+     * Returns a string representing armor or internal structure of the location.\r\n+     * The location has the given orig original Armor/IS. \r\n+     */\r\n+    private static StringBuilder intactLocBar(int orig, int curr, String dChar) {\r\n+        return locBar(orig, curr, dChar, false);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a string representing armor or internal structure of one location.\r\n+     * The location has the given orig original Armor/IS and the given curr current\r\n+     * Armor/IS. The character dChar will be repeated at appropriate colors depending\r\n+     * on the value of curr, orig and the static visUnit which gives the amount of \r\n+     * Armor/IS per single character. \r\n+     */\r\n+    private static StringBuilder locBar(int orig, int curr, String dChar, boolean destroyed) {\r\n+        // Internal Structure can be zero, e.g. in Aero\r\n+        if (orig == 0) {\r\n+            return new StringBuilder(\"\");\r\n+        }\r\n+        \r\n+        StringBuilder result = new StringBuilder();\r\n+        GUIPreferences guip = GUIPreferences.getInstance();\r\n+        Color colorIntact = guip.getColor(GUIPreferences.ADVANCED_ARMORMINI_COLOR_INTACT);\r\n+        Color colorPartialDmg = guip.getColor(GUIPreferences.ADVANCED_ARMORMINI_COLOR_PARTIAL_DMG);\r\n+        Color colorDamaged = guip.getColor(GUIPreferences.ADVANCED_ARMORMINI_COLOR_DAMAGED);\r\n+        int visUnit = guip.getInt(GUIPreferences.ADVANCED_ARMORMINI_UNITS_PER_BLOCK);\r\n+        \r\n+        if (destroyed) {\r\n+            colorIntact = colorDamaged;\r\n+            colorPartialDmg = colorDamaged;\r\n+        }\r\n+        \r\n+        int numPartial = ((curr != orig) && (curr % visUnit) > 0) ? 1 : 0;\r\n+        int numIntact = (curr - 1) / visUnit + 1 - numPartial;\r\n+        int numDmgd = (orig - 1) / visUnit + 1 - numPartial - numIntact;\r\n+        if (numIntact > 0) {\r\n+            result.append(guiScaledFontHTML(colorIntact, TT_SMALLFONT_DELTA));\r\n+            result.append(repeat(dChar, numIntact) + \"</FONT>\");\r\n+        }\r\n+        if (numPartial > 0) {\r\n+            result.append(guiScaledFontHTML(colorPartialDmg, TT_SMALLFONT_DELTA));\r\n+            result.append(repeat(dChar, numPartial) + \"</FONT>\");\r\n+        }\r\n+        if (numDmgd > 0) {\r\n+            result.append(guiScaledFontHTML(colorDamaged, TT_SMALLFONT_DELTA));\r\n+            result.append(repeat(dChar, numDmgd) + \"</FONT>\");\r\n+        }\r\n+        return result;\r\n+    }\r\n+    \r\n+    private static class WeaponInfo {\r\n+        String name;\r\n+        String sortString;\r\n+        String range;\r\n+        int count = 1;\r\n+        boolean isClan;\r\n+        boolean isFiring = false;\r\n+        boolean isHotloaded = false;\r\n+        boolean isRapidFire = false;\r\n+        HashMap<String, Integer> ammos = new HashMap<>();\r\n+        int ammoActiveWeaponCount;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns true if the weapontype should be excluded from the Tooltip. \r\n+     * This is true for C3 computers (only Masters are weapons) and \r\n+     * special Infantry attacks (Swarm Attacks and the like).\r\n+     */ \r\n+    private static boolean isNotTTRelevant(WeaponType wtype) {\r\n+        return wtype.hasFlag(WeaponType.F_C3M) || wtype.hasFlag(WeaponType.F_C3MBS)\r\n+                || wtype instanceof LegAttack || wtype instanceof SwarmAttack\r\n+                || wtype instanceof StopSwarmAttack || wtype instanceof SwarmWeaponAttack;\r\n+    }\r\n+    \r\n+    private static final String RAPIDFIRE = \"|RF|\";\r\n+    \r\n+    /** Returns the assembled weapons with ranges etc. */\r\n+    private static StringBuilder weaponList(Entity entity) {\r\n+        ArrayList<Mounted> weapons = entity.getWeaponList();\r\n+        HashMap<String, WeaponInfo> wpInfos = new HashMap<>();\r\n+        // Gather names, counts, Clan/IS\r\n+        WeaponInfo currentWp;\r\n+        for (Mounted curWp: weapons) {\r\n+            WeaponType wtype = (WeaponType)curWp.getType();\r\n+            if (isNotTTRelevant(wtype)) {\r\n+                continue;\r\n+            }\r\n+            String weapDesc = curWp.getDesc();\r\n+            // Distinguish equal weapons with and without rapid fire\r\n+            if (isRapidFireActive(entity.getGame()) && curWp.isRapidfire()) {\r\n+                weapDesc += RAPIDFIRE;\r\n+            }\r\n+            if (wpInfos.containsKey(weapDesc)) {\r\n+                currentWp = wpInfos.get(weapDesc);\r\n+                currentWp.count++;\r\n+                wpInfos.put(weapDesc, currentWp);\r\n+                if (!curWp.isDestroyed() && wpInfos.containsKey(curWp.getName() + \"Ammo\")) {\r\n+                    WeaponInfo currAmmo = wpInfos.get(curWp.getName() + \"Ammo\");\r\n+                    currAmmo.ammoActiveWeaponCount++;\r\n+                } \r\n+            } else {\r\n+                currentWp = new WeaponInfo();\r\n+                currentWp.name = weapDesc;\r\n+                currentWp.sortString = curWp.getName();\r\n+                // Sort active weapons below destroyed to keep them close to their ammo\r\n+                if (!curWp.isDestroyed()) {\r\n+                    currentWp.sortString += \"1\";\r\n+                }\r\n+                currentWp.isRapidFire = weapDesc.contains(RAPIDFIRE);\r\n+\r\n+                // Create the ranges String\r\n+                int ranges[];\r\n+                if (entity.isAero()) {\r\n+                    ranges = wtype.getATRanges();\r\n+                } else {\r\n+                    ranges = wtype.getRanges(curWp);\r\n+                } \r\n+                String rangeString = \" \\u22EF \";\r\n+                if ((ranges[RangeType.RANGE_MINIMUM] != WeaponType.WEAPON_NA) \r\n+                        && (ranges[RangeType.RANGE_MINIMUM] != 0)) {\r\n+                    rangeString += \"(\" + ranges[RangeType.RANGE_MINIMUM] + \") \";\r\n+                }\r\n+                int maxRange = RangeType.RANGE_LONG;\r\n+                if (entity.getGame().getOptions().booleanOption(\r\n+                        OptionsConstants.ADVCOMBAT_TACOPS_RANGE)) {\r\n+                    maxRange = RangeType.RANGE_EXTREME;\r\n+                }\r\n+                for (int i = RangeType.RANGE_SHORT; i <= maxRange; i++) {\r\n+                    rangeString += ranges[i];\r\n+                    if (i != maxRange) {\r\n+                        rangeString += \"\\u2B1D\";\r\n+                    }\r\n+                }\r\n+                currentWp.range = rangeString;\r\n+                \r\n+                WeaponType wpT = ((WeaponType)curWp.getType());\r\n+                currentWp.isClan = (entity.isClan() && TechConstants.isClan(wpT.getTechLevel(entity.getYear())));\r\n+                wpInfos.put(weapDesc, currentWp);\r\n+\r\n+                // Add ammo info if the weapon has ammo \r\n+                // Check wpInfos for dual entries to avoid displaying ammo twice for non/rapid-fire  \r\n+                if ((wtype.getAmmoType() != AmmoType.T_NA)\r\n+                        && (!wtype.hasFlag(WeaponType.F_ONESHOT) || wtype.hasFlag(WeaponType.F_BA_INDIVIDUAL))\r\n+                        && (wtype.getAmmoType() != AmmoType.T_INFANTRY)) {\r\n+                    \r\n+                    if (wpInfos.containsKey(curWp.getName() + \"Ammo\")) {\r\n+                        if (!curWp.isDestroyed()) {\r\n+                            WeaponInfo currAmmo = wpInfos.get(curWp.getName() + \"Ammo\");\r\n+                            currAmmo.ammoActiveWeaponCount++;\r\n+                        }\r\n+                    } else {\r\n+                        WeaponInfo currAmmo = new WeaponInfo();\r\n+                        currAmmo.sortString = curWp.getName() + \"ZZ\"; // Sort ammo after the weapons\r\n+                        currAmmo.ammoActiveWeaponCount = curWp.isDestroyed() ? 0 : 1;\r\n+                        for (Mounted amounted : entity.getAmmo()) {\r\n+                            boolean canSwitchToAmmo = AmmoType.canSwitchToAmmo(curWp, (AmmoType) amounted.getType());\r\n+                            if (canSwitchToAmmo && !amounted.isDumping()) {\r\n+                                String name = amounted.getName()\r\n+                                        .replace(\"Ammo\", \"\").replace(\"[IS]\", \"\").replace(\"[Clan]\", \"\")\r\n+                                        .replace(\"(Clan)\", \"\").replace(\"[Half]\", \"\").replace(\"Half\", \"\")\r\n+                                        .replace(curWp.getDesc(), \"\").trim();\r\n+                                if (name.length() == 0) {\r\n+                                    name = \"Standard\";\r\n+                                }\r\n+                                if (amounted.isHotLoaded()) {\r\n+                                    name += \" (Hot-Loaded)\";\r\n+                                }\r\n+                                int count = amounted.getUsableShotsLeft();\r\n+                                count += currAmmo.ammos.containsKey(name) ? currAmmo.ammos.get(name) : 0;\r\n+                                currAmmo.ammos.put(name, count);\r\n+                            }\r\n+                        }\r\n+                        wpInfos.put(curWp.getName() + \"Ammo\", currAmmo);\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+        }\r\n+        \r\n+        // Print to Tooltip\r\n+        StringBuilder result = new StringBuilder();\r\n+        boolean subsequentLine = false; \r\n+        // Display sorted by weapon name\r\n+        ArrayList<WeaponInfo> wps = new ArrayList<UnitToolTip.WeaponInfo>(wpInfos.values());\r\n+        wps.sort((w1, w2) -> w1.sortString.compareTo(w2.sortString));\r\n+        int totalWeaponCount = wpInfos.values().stream().mapToInt(wp -> wp.count).sum();\r\n+        boolean hasMultiples = wpInfos.values().stream().mapToInt(wp -> wp.count).anyMatch(c -> c > 1);\r\n+        for (WeaponInfo currentEquip : wps) {\r\n+            // This WeaponInfo is ammo\r\n+            if (!currentEquip.ammos.isEmpty()) {\r\n+                result.append(createAmmoEntry(currentEquip));\r\n+            } else {\r\n+\r\n+            // This WeaponInfo is a weapon\r\n+\r\n+            \r\n+            // Check if weapon is destroyed, text gray and strikethrough if so, remove the \"x \"/\"*\"\r\n+            // Also remove \"+\", means currently selected for firing\r\n+            boolean isDestroyed = false;\r\n+            String nameStr = currentEquip.name;\r\n+            if (nameStr == null) {\r\n+                nameStr = \"NULL Weapon Name!\"; // Happens with Vehicle Flamers! \r\n+            }\r\n+            if (nameStr.startsWith(\"x \")) { \r\n+                nameStr = nameStr.substring(2);\r\n+                isDestroyed = true;\r\n+            }\r\n+\r\n+            if (nameStr.startsWith(\"*\")) { \r\n+                nameStr = nameStr.substring(1);\r\n+                isDestroyed = true;\r\n+            }\r\n+\r\n+            if (nameStr.startsWith(\"+\")) { \r\n+                nameStr = nameStr.substring(1);\r\n+                currentEquip.isFiring = true;\r\n+            }\r\n+            \r\n+            // Remove the rapid fire marker (used only to distinguish weapons set to different modes)\r\n+            nameStr = nameStr.replace(RAPIDFIRE, \"\");\r\n+            nameStr += currentEquip.range;\r\n+\r\n+            result.append(guiScaledFontHTML(uiTTWeaponColor()));\r\n+            if (isDestroyed) {\r\n+                result.append(\"<S>\");\r\n+            }\r\n+\r\n+            String clanStr = currentEquip.isClan ? Messages.getString(\"BoardView1.Tooltip.Clan\") : \"\";\r\n+\r\n+            // when more than 5 weapons are present, they will be grouped\r\n+            // and listed with a multiplier\r\n+            if (totalWeaponCount > 5 && hasMultiples) {\r\n+                result.append(addToTT(\"WeaponN\", subsequentLine, currentEquip.count, clanStr, nameStr));\r\n+                subsequentLine = true;\r\n+            } else { // few weapons: list each weapon separately\r\n+                for (int i = 0; i < currentEquip.count; i++) {\r\n+                    result.append(addToTT(\"Weapon\", subsequentLine, currentEquip.count, clanStr, nameStr));\r\n+                    subsequentLine = true;\r\n+                }\r\n+            }\r\n+            // Weapon destroyed? End strikethrough\r\n+            if (isDestroyed) {\r\n+                result.append(\"</S>\");\r\n+            } else {\r\n+                // Not destroyed\r\n+                // In-game and set to fire this round?\r\n+                if (currentEquip.isFiring) {\r\n+                    result.append(\" \\u22EF<I> (Firing)</I>\");\r\n+                }\r\n+                // TacOps Modifiers\r\n+                if (currentEquip.isHotloaded) {\r\n+                    result.append(\" \\u22EF<I> Hot-loaded</I>\");\r\n+                }\r\n+                if (currentEquip.isRapidFire) {\r\n+                    result.append(\" \\u22EF<I> Rapid-fire</I>\");\r\n+                }\r\n+            }\r\n+            result.append(\"</FONT>\"); \r\n+        }}\r\n+        result.append(\"<BR>\");\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** Returns the ammo line(s) for the ammo of one weapon type. */\r\n+    private static StringBuilder createAmmoEntry(WeaponInfo ammoInfo) {\r\n+        StringBuilder result = new StringBuilder();\r\n+        result.append(guiScaledFontHTML(-0.2f));\r\n+        \r\n+        int totalAmmo = ammoInfo.ammos.values().stream().mapToInt(n -> n).sum();\r\n+        if (totalAmmo == 0 && ammoInfo.ammoActiveWeaponCount > 0) {\r\n+            result.append(\"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Out of Ammo!\");\r\n+        } else {\r\n+            for (Entry<String, Integer> ammo: ammoInfo.ammos.entrySet()) {\r\n+                String ammoName = ammo.getKey().equals(\"Standard\") && ammoInfo.ammos.size() == 1 ? \"\" : ammo.getKey() + \": \";\r\n+                // No entry when no ammo of this type left but some other type left\r\n+                if (ammo.getValue() == 0) {\r\n+                    continue;\r\n+                } \r\n+                \r\n+                result.append(\"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"); \r\n+                if (ammoInfo.ammoActiveWeaponCount > 1) { \r\n+                    // Remaining ammo and multiple weapons using it\r\n+                    result.append(ammoName);\r\n+                    result.append(ammo.getValue() / ammoInfo.ammoActiveWeaponCount).append(\" turns\");\r\n+                    result.append(\" (\" + ammo.getValue() + \" shots)\");\r\n+                } else { \r\n+                    // Remaining ammo and only one weapon using it\r\n+                    result.append(ammoName).append(ammo.getValue()).append(\" shots\");\r\n+                }\r\n+            }\r\n+        }\r\n+        result.append(\"</FONT>\");\r\n+        return result;\r\n+    }\r\n+\r\n+    /** Returns a line showing ECM / ECCM. */\r\n+    private static StringBuilder ecmInfo(Entity entity) {\r\n+        StringBuilder result = new StringBuilder();\r\n+        if (entity.hasActiveECM()) {\r\n+            result.append(\"&nbsp;\").append(ECM_SIGN).append(\" \");\r\n+            result.append(Messages.getString(\"BoardView1.ecmSource\"));\r\n+        }\r\n+        if (entity.hasActiveECCM()) {\r\n+            result.append(\"&nbsp;\").append(ECM_SIGN).append(\" \");\r\n+            result.append(Messages.getString(\"BoardView1.eccmSource\"));\r\n+        }\r\n+        return result;\r\n+    }\r\n+\r\n+    /** Returns values that only are relevant when in-game such as heat. */\r\n+    private static StringBuilder inGameValues(Entity entity, IPlayer localPlayer) {\r\n+        StringBuilder result = new StringBuilder();\r\n+        IGame game = entity.getGame();\r\n+        boolean isGunEmplacement = entity instanceof GunEmplacement;\r\n+        \r\n+        // Coloring and italic to make these transient entries stand out\r\n+        result.append(guiScaledFontHTML(uiLightViolet()) + \"<I>\");\r\n+        \r\n+        // BV Info\r\n+        // Hidden for invisible units when in double blind and hide enemy bv is selected\r\n+        // Also not shown in the lobby as BV is shown there outside the tooltip\r\n+        boolean showEnemyBV = !(game.getOptions().booleanOption(OptionsConstants.ADVANCED_SUPPRESS_DB_BV) &&\r\n+                game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND));\r\n+        boolean isVisible = EntityVisibilityUtils.trackThisEntitiesVisibilityInfo(localPlayer, entity);\r\n+\r\n+        if (isVisible || showEnemyBV) {\r\n+            int currentBV = entity.calculateBattleValue(false, false);\r\n+            int initialBV = entity.getInitialBV();\r\n+            double percentage = (double) currentBV / initialBV;\r\n+            result.append(addToTT(\"BV\", BR, currentBV, initialBV, percentage));\r\n+        }\r\n+\r\n+        // Heat, not shown for units with 999 heat sinks (vehicles)\r\n+        if (entity.getHeatCapacity() != 999) {\r\n+            if (entity.heat == 0) {\r\n+                result.append(guiScaledFontHTML(uiGreen()));\r\n+                result.append(addToTT(\"Heat0\", BR));\r\n+            } else { \r\n+                result.append(guiScaledFontHTML(uiLightRed()));\r\n+                result.append(addToTT(\"Heat\", BR, entity.heat));\r\n+            }\r\n+            result.append(\"</FONT>\");\r\n+        }\r\n+\r\n+        // Actual Movement\r\n+        if (!isGunEmplacement) {\r\n+            // \"Has not yet moved\" only during movement phase\r\n+            if (!entity.isDone() && game.getPhase() == Phase.PHASE_MOVEMENT) {\r\n+                result.append(addToTT(\"NotYetMoved\", BR));\r\n+            } else if ((entity.isDone() && game.getPhase() == Phase.PHASE_MOVEMENT) \r\n+                    || game.getPhase() == Phase.PHASE_FIRING) {\r\n+                int tmm = Compute.getTargetMovementModifier(game, entity.getId()).getValue();\r\n+                if (entity.moved == EntityMovementType.MOVE_NONE) {\r\n+                    result.append(addToTT(\"NoMove\", BR, tmm));\r\n+                } else {\r\n+                    result.append(addToTT(\"MovementF\", BR, entity.getMovementString(entity.moved),\r\n+                            entity.delta_distance, tmm));\r\n+                }\r\n+                // Special Moves\r\n+                if (entity.isEvading()) { \r\n+                    result.append(addToTT(\"Evade\", NOBR));\r\n+                }\r\n+\r\n+                if ((entity instanceof Infantry) && ((Infantry)entity).isTakingCover()) { \r\n+                    result.append(addToTT(\"TakingCover\", NOBR));\r\n+                }\r\n+\r\n+                if (entity.isCharging()) { \r\n+                    result.append(addToTT(\"Charging\", BR));\r\n+                }\r\n+\r\n+                if (entity.isMakingDfa()) { \r\n+                    result.append(addToTT(\"DFA\", NOBR));\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        // Velocity, Altitude, Elevation\r\n+        if (entity.isAero()) {\r\n+            result.append(guiScaledFontHTML(uiLightViolet()));\r\n+            Aero aero = (Aero) entity;\r\n+            result.append(addToTT(\"AeroVelAlt\", BR, aero.getCurrentVelocity(), aero.getAltitude()));\r\n+            result.append(\"</FONT>\");\r\n+        } else if (entity.getElevation() != 0) {\r\n+            result.append(guiScaledFontHTML(uiLightViolet()));\r\n+            result.append(addToTT(\"Elev\", BR, entity.getElevation()));\r\n+            result.append(\"</FONT>\");\r\n+        }\r\n+\r\n+        // Gun Emplacement Status\r\n+        if (isGunEmplacement) {\r\n+            GunEmplacement emp = (GunEmplacement) entity; \r\n+            if (emp.isTurret() && emp.isTurretLocked(emp.getLocTurret())) {\r\n+                result.append(guiScaledFontHTML(GUIPreferences.getInstance().getWarningColor()));\r\n+                result.append(addToTT(\"TurretLocked\", BR));\r\n+                result.append(\"</FONT>\");\r\n+            }\r\n+        }\r\n+\r\n+        // Unit Immobile\r\n+        if (!isGunEmplacement && (entity.isImmobile())) {\r\n+            result.append(guiScaledFontHTML(GUIPreferences.getInstance().getWarningColor()));\r\n+            result.append(addToTT(\"Immobile\", BR));\r\n+            result.append(\"</FONT>\");\r\n+        }\r\n+\r\n+        if (entity.isHiddenActivating()) {\r\n+            result.append(addToTT(\"HiddenActivating\", BR,\r\n+                    IGame.Phase.getDisplayableName(entity.getHiddenActivationPhase())));\r\n+        } else if (entity.isHidden()) {\r\n+            result.append(addToTT(\"Hidden\", BR));\r\n+        }\r\n+\r\n+        // Jammed by ECM - don't know how to replicate this correctly from the boardview\r\n+        //      if (isAffectedByECM()) {\r\n+        //          addToTT(\"Jammed\", BR);\r\n+        //      }\r\n+\r\n+        // Swarmed\r\n+        if (entity.getSwarmAttackerId() != Entity.NONE) {\r\n+            result.append(addToTT(\"Swarmed\", BR, game.getEntity(entity.getSwarmAttackerId()).getDisplayName()));\r\n+        }\r\n+\r\n+        // Spotting\r\n+        if (entity.isSpotting()) {\r\n+            result.append(addToTT(\"Spotting\", BR, game.getEntity(entity.getSpotTargetId()).getDisplayName()));\r\n+        }\r\n+\r\n+        // If Double Blind, add information about who sees this Entity\r\n+        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)) {\r\n+            StringBuffer playerList = new StringBuffer();\r\n+            boolean teamVision = game.getOptions().booleanOption(\r\n+                    OptionsConstants.ADVANCED_TEAM_VISION);\r\n+            for (IPlayer player : entity.getWhoCanSee()) {\r\n+                if (player.isEnemyOf(entity.getOwner()) || !teamVision) {\r\n+                    playerList.append(player.getName());\r\n+                    playerList.append(\", \");\r\n+                }\r\n+            }\r\n+            if (playerList.length() > 1) {\r\n+                playerList.delete(playerList.length() - 2, playerList.length());\r\n+                result.append(addToTT(\"SeenBy\", BR, playerList.toString()));\r\n+            }            \r\n+        }\r\n+\r\n+        // If sensors, display what sensors this unit is using\r\n+        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)\r\n+                || game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)) {\r\n+            result.append(addToTT(\"Sensors\", BR, entity.getSensorDesc()));\r\n+        }\r\n+\r\n+        // Towing\r\n+        if (entity.getAllTowedUnits().size() > 0) {\r\n+            String unitList = entity.getAllTowedUnits().stream()\r\n+                    .map(id -> entity.getGame().getEntity(id).getShortName())\r\n+                    .collect(Collectors.joining(\", \"));\r\n+            if (unitList.length() > 1) {\r\n+                result.append(addToTT(\"Towing\", BR, unitList));\r\n+            }\r\n+        }\r\n+        result.append(\"</I></FONT>\");\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** Returns unit values that are relevant in-game and in the lobby such as movement ability. */\r\n+    private static StringBuilder entityValues(Entity entity) {\r\n+        StringBuilder result = new StringBuilder();\r\n+        boolean isGunEmplacement = entity instanceof GunEmplacement;\r\n+        // Unit movement ability\r\n+        if (isGunEmplacement) {\r\n+            result.append(addToTT(\"Immobile\", NOBR));\r\n+        } else {\r\n+            result.append(addToTT(\"Movement\", NOBR, entity.getWalkMP(), entity.getRunMPasString()));\r\n+            if (entity.getJumpMP() > 0) {\r\n+                result.append(\"/\" + entity.getJumpMP());\r\n+            }\r\n+            if (entity instanceof Tank) {\r\n+                result.append(DOT_SPACER + entity.getMovementModeAsString());\r\n+            }\r\n+        }\r\n+        \r\n+        // Infantry specialization like SCUBA\r\n+        if (entity instanceof Infantry) {\r\n+            Infantry inf = (Infantry) entity;\r\n+            int spec = inf.getSpecializations();\r\n+            if (spec > 0) {\r\n+                result.append(addToTT(\"InfSpec\", BR, Infantry.getSpecializationName(spec)));\r\n+            }\r\n+        }\r\n+\r\n+        // Armor and Internals\r\n+        result.append(addToTT(\"ArmorInternals\", BR, entity.getTotalArmor(), entity.getTotalInternal()));\r\n+        if (entity.isCapitalScale()) {\r\n+            addToTT(\"ArmorCapital\", BR);\r\n+        }\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** Returns warnings about problems that should be solved before deploying. */\r\n+    private static StringBuilder deploymentWarnings(Entity entity, IPlayer localPlayer,\r\n+            MapSettings mapSettings) {\r\n+        StringBuilder result = new StringBuilder();\r\n+        // Critical (red) warnings\r\n+        result.append(guiScaledFontHTML(GUIPreferences.getInstance().getWarningColor())); \r\n+        if (entity.getGame().getPlanetaryConditions().whyDoomed(entity, entity.getGame()) != null) {\r\n+            result.append(\"<BR>Cannot survive \" + entity.getGame().getPlanetaryConditions().whyDoomed(entity, entity.getGame()));\r\n+        }\r\n+        if (entity.doomedInAtmosphere() && mapSettings.getMedium() == MapSettings.MEDIUM_ATMOSPHERE) {\r\n+            result.append(\"<BR>Cannot survive on a low/high atmosphere map!\");\r\n+        }\r\n+        if (entity.doomedOnGround() && mapSettings.getMedium() == MapSettings.MEDIUM_GROUND) {\r\n+            result.append(\"<BR>Cannot survive on a ground map!\");\r\n+        }\r\n+        if  (entity.doomedInSpace() && mapSettings.getMedium() == MapSettings.MEDIUM_SPACE) {\r\n+            result.append(\"<BR>Cannot survive in space!\");\r\n+        }\r\n+        result.append(\"</FONT>\");\r\n+        \r\n+        // Non-critical (yellow) warnings\r\n+        result.append(guiScaledFontHTML(uiYellow())); \r\n+        if (((entity.hasC3i() || entity.hasNavalC3()) && (entity.calculateFreeC3Nodes() == 5))\r\n+                || ((entity.getC3Master() == null) && entity.hasC3S())\r\n+                || (entity.hasNovaCEWS() && (entity.calculateFreeC3Nodes() == 2))) {\r\n+            result.append(\"<BR>Unconnected C3 Computer\");\r\n+        }\r\n+        \r\n+        // Non-critical (yellow) warnings\r\n+        if (entity instanceof FighterSquadron && entity.getLoadedUnits().isEmpty()) {\r\n+            result.append(\"<BR>This Fighter Squadron is empty\");\r\n+        }\r\n+        result.append(\"</FONT>\");\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** Returns a list of units loaded onto this unit. */\r\n+    private static StringBuilder carriedUnits(Entity entity) {\r\n+        StringBuilder result = new StringBuilder();\r\n+        \r\n+        result.append(guiScaledFontHTML());\r\n+        if (entity instanceof FighterSquadron) {\r\n+            result.append(\"Fighters:\");\r\n+        } else {\r\n+            result.append(\"Carried Units:\");\r\n+        }\r\n+        for (Entity carried: entity.getLoadedUnits()) {\r\n+            result.append(\"<BR>&nbsp;&nbsp;\").append(carried.getShortNameRaw());\r\n+            if (PreferenceManager.getClientPreferences().getShowUnitId()) {\r\n+                result.append(\" [\" + carried.getId() + \"]\");\r\n+            }\r\n+\r\n+        }\r\n+        result.append(\"</FONT>\");\r\n+        return result;\r\n+    }\r\n+    \r\n+    /** Returns a list of units loaded onto this unit. */\r\n+    private static StringBuilder forceEntry(Entity entity, IPlayer localPlayer) {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjkwOTc0Nw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r612909747", "bodyText": "What's this do?", "author": "NickAragua", "createdAt": "2021-04-14T03:22:09Z", "path": "megamek/src/megamek/client/ui/swing/util/UIUtil.java", "diffHunk": "@@ -0,0 +1,735 @@\n+/*  \r\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team  \r\n+*  \r\n+* This program is free software; you can redistribute it and/or modify it under  \r\n+* the terms of the GNU General Public License as published by the Free Software  \r\n+* Foundation; either version 2 of the License, or (at your option) any later  \r\n+* version.  \r\n+*  \r\n+* This program is distributed in the hope that it will be useful, but WITHOUT  \r\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  \r\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more  \r\n+* details.  \r\n+*/ \r\n+package megamek.client.ui.swing.util;\r\n+\r\n+import java.awt.Color;\r\n+import java.awt.Component;\r\n+import java.awt.Container;\r\n+import java.awt.Dimension;\r\n+import java.awt.Font;\r\n+import java.awt.GridLayout;\r\n+import java.awt.Insets;\r\n+import java.awt.LayoutManager;\r\n+import java.awt.Point;\r\n+import java.awt.event.ActionListener;\r\n+import java.awt.event.MouseEvent;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+\r\n+import javax.swing.BorderFactory;\r\n+import javax.swing.BoxLayout;\r\n+import javax.swing.JButton;\r\n+import javax.swing.JCheckBox;\r\n+import javax.swing.JComboBox;\r\n+import javax.swing.JComponent;\r\n+import javax.swing.JDialog;\r\n+import javax.swing.JLabel;\r\n+import javax.swing.JMenu;\r\n+import javax.swing.JMenuItem;\r\n+import javax.swing.JPanel;\r\n+import javax.swing.JPopupMenu;\r\n+import javax.swing.JRadioButton;\r\n+import javax.swing.JScrollPane;\r\n+import javax.swing.JSlider;\r\n+import javax.swing.JSpinner;\r\n+import javax.swing.JTabbedPane;\r\n+import javax.swing.JTextArea;\r\n+import javax.swing.JTextField;\r\n+import javax.swing.JTextPane;\r\n+import javax.swing.JToggleButton;\r\n+import javax.swing.JToolTip;\r\n+import javax.swing.JViewport;\r\n+import javax.swing.UIManager;\r\n+import javax.swing.border.Border;\r\n+import javax.swing.border.EmptyBorder;\r\n+import javax.swing.border.TitledBorder;\r\n+\r\n+import megamek.client.ui.Messages;\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.GUIPreferences;\r\n+import megamek.common.IPlayer;\r\n+\r\n+public final class UIUtil {\r\n+    \r\n+    /** The style = font-size: xx value corresponding to a GUI scale of 1 */\r\n+    public final static int FONT_SCALE1 = 14;\r\n+    public final static String ECM_SIGN = \" \\u24BA \";\r\n+    public final static String LOADED_SIGN = \" \\u26DF \";\r\n+    public final static String UNCONNECTED_SIGN = \" \\u26AC\";\r\n+    public final static String CONNECTED_SIGN = \" \\u26AF \";\r\n+    public final static String WARNING_SIGN = \" \\u26A0 \";\r\n+    public final static String QUIRKS_SIGN = \" \\u24E0 \";\r\n+    public static final String DOT_SPACER = \" \\u2B1D \";\r\n+    \r\n+    public static String repeat(String str, int count) {\r\n+        StringBuilder result = new StringBuilder();\r\n+        for (int i = 0; i < count; i++) {\r\n+            result.append(str);\r\n+        }\r\n+        return result.toString();\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns an HTML FONT tag setting the font face to Dialog \r\n+     * and the font size according to GUIScale. \r\n+     */\r\n+    public static String guiScaledFontHTML() {\r\n+        return \"<FONT FACE=Dialog \" + sizeString() + \">\";\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns an HTML FONT tag setting the color to the given col,\r\n+     * the font face to Dialog and the font size according to GUIScale. \r\n+     */\r\n+    public static String guiScaledFontHTML(Color col) {\r\n+        return \"<FONT FACE=Dialog \" + sizeString() + colorString(col) + \">\";\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns an HTML FONT tag setting the font face to Dialog \r\n+     * and the font size according to GUIScale. \r\n+     */\r\n+    public static String guiScaledFontHTML(float deltaScale) {\r\n+        return \"<FONT FACE=Dialog \" + sizeString(deltaScale) + \">\";\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns an HTML FONT tag setting the color to the given col,\r\n+     * the font face to Dialog and the font size according to GUIScale. \r\n+     */\r\n+    public static String guiScaledFontHTML(Color col, float deltaScale) {\r\n+        return \"<FONT FACE=Dialog \" + sizeString(deltaScale) + colorString(col) + \">\";\r\n+    }\r\n+    \r\n+    /** Returns the yellow and gui-scaled warning sign. */\r\n+    public static String warningSign() {\r\n+        return guiScaledFontHTML(uiYellow()) + WARNING_SIGN + \"</FONT>\";\r\n+    }\r\n+    \r\n+    /** Returns the (usually) red and gui-scaled warning sign. */\r\n+    public static String criticalSign() {\r\n+        return guiScaledFontHTML(GUIPreferences.getInstance().getWarningColor()) + WARNING_SIGN + \"</FONT>\";\r\n+    }\r\n+    \r\n+    /** \r\n+     * Helper method to place Strings in lines according to length. The Strings\r\n+     * in origList will be added to one line with separator sep between them as \r\n+     * long as the total length does not exceed maxLength. If it exceeds maxLength, \r\n+     * a new line is begun. All lines but the last will end with sep if sepAtEnd is true. \r\n+     */\r\n+    public static ArrayList<String> arrangeInLines(List<String> origList, int maxLength, \r\n+            String sep, boolean sepAtEnd) {\r\n+        \r\n+        ArrayList<String> result = new ArrayList<>();\r\n+        if (origList == null || origList.isEmpty()) {\r\n+            return result;\r\n+        }\r\n+        String currLine = \"\";\r\n+        for (String curr: origList) {\r\n+            // Skip empty strings to avoid double separators\r\n+            if (curr.isEmpty()) {\r\n+                continue;\r\n+            }\r\n+            \r\n+            if (currLine.isEmpty()) {\r\n+                // No entry in this line yet\r\n+                currLine = curr;\r\n+            } else if (currLine.length() + curr.length() + sep.length() <= maxLength) {\r\n+                // This line can hold another string\r\n+                currLine += sep + curr;\r\n+            } else {\r\n+                // This line cannot hold another string\r\n+                currLine += sepAtEnd ? sep : \"\";\r\n+                result.add(currLine);\r\n+                currLine = curr;\r\n+            }\r\n+        }\r\n+        if (!currLine.isEmpty()) {\r\n+            // Add the last unfinished line\r\n+            result.add(currLine);\r\n+        } else if (sepAtEnd) {\r\n+            // Remove the last unnecessary sep if there were no more Strings\r\n+            String lastLine = result.get(result.size() - 1);\r\n+            String newLine = lastLine.substring(0, lastLine.length() - sep.length());\r\n+            result.remove(result.size() - 1);\r\n+            result.add(newLine);\r\n+        }\r\n+        return result;\r\n+    }\r\n+    \r\n+    public static ArrayList<String> arrangeInLines(int maxLength, \r\n+            String sep, boolean sepAtEnd, String... origList) {\r\n+        \r\n+        return arrangeInLines(Arrays.asList(origList), maxLength, sep, sepAtEnd);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a UIManager Color that can be used as an alternate row color in a table\r\n+     * to offset each other row.\r\n+     */\r\n+    public static Color alternateTableBGColor() {\r\n+        Color result = UIManager.getColor(\"Table.alternateRowColor\");\r\n+        if (result != null) {\r\n+            return result;\r\n+        }\r\n+        result = UIManager.getColor(\"controlHighlight\");\r\n+        if (result != null) {\r\n+            return result;\r\n+        }\r\n+        result = UIManager.getColor(\"Table.background\");\r\n+        if (result != null) {\r\n+            return result;\r\n+        }\r\n+        // The really last fallback position\r\n+        return uiGray();\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns the Color associated with either enemies, allies or \r\n+     * oneself from the GUIPreferences depending on the relation\r\n+     * of the given player1 and player2. \r\n+     */\r\n+    public static Color teamColor(IPlayer player1, IPlayer player2) {\r\n+        if (player1.getId() == player2.getId()) {\r\n+            return GUIPreferences.getInstance().getMyUnitColor();\r\n+        } else if (player1.isEnemyOf(player2)) {\r\n+            return GUIPreferences.getInstance().getEnemyUnitColor();\r\n+        } else {\r\n+            return GUIPreferences.getInstance().getAllyUnitColor();\r\n+        }\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a green color suitable as a text color. The supplied\r\n+     * color depends on the UI look and feel and will be lighter for a \r\n+     * dark UI LAF than for a light UI LAF.\r\n+     */\r\n+    public static Color uiGreen() {\r\n+        return uiBgBrightness() > 130 ? LIGHTUI_GREEN : DARKUI_GREEN;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a gray color suitable as a text color. The supplied\r\n+     * color depends on the UI look and feel and will be lighter for a \r\n+     * dark UI LAF than for a light UI LAF.\r\n+     */\r\n+    public static Color uiGray() {\r\n+        return uiBgBrightness() > 130 ? LIGHTUI_GRAY : DARKUI_GRAY;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a light blue color suitable as a text color. The supplied\r\n+     * color depends on the UI look and feel and will be lighter for a \r\n+     * dark UI LAF than for a light UI LAF.\r\n+     */\r\n+    public static Color uiLightBlue() {\r\n+        return uiBgBrightness() > 130 ? LIGHTUI_LIGHTBLUE : DARKUI_LIGHTBLUE;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a light red color suitable as a text color. The supplied\r\n+     * color depends on the UI look and feel and will be lighter for a \r\n+     * dark UI LAF than for a light UI LAF.\r\n+     */\r\n+    public static Color uiLightRed() {\r\n+        return uiBgBrightness() > 130 ? LIGHTUI_LIGHTRED : DARKUI_LIGHTRED;\r\n+    }\r\n+\r\n+    /** \r\n+     * Returns a light violet color suitable as a text color. The supplied\r\n+     * color depends on the UI look and feel and will be lighter for a \r\n+     * dark UI LAF than for a light UI LAF.\r\n+     */\r\n+    public static Color uiLightViolet() {\r\n+        return uiBgBrightness() > 130 ? LIGHTUI_LIGHTVIOLET : DARKUI_LIGHTVIOLET;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a light green color suitable as a text color. The supplied\r\n+     * color depends on the UI look and feel and will be lighter for a \r\n+     * dark UI LAF than for a light UI LAF.\r\n+     */\r\n+    public static Color uiLightGreen() {\r\n+        return uiBgBrightness() > 130 ? LIGHTUI_LIGHTGREEN : DARKUI_LIGHTGREEN;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a light red color suitable as a text color. The supplied\r\n+     * color depends on the UI look and feel and will be lighter for a \r\n+     * dark UI LAF than for a light UI LAF.\r\n+     */\r\n+    public static Color uiYellow() {\r\n+        return uiBgBrightness() > 130 ? LIGHTUI_YELLOW : DARKUI_YELLOW;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a color for the UI display of Quirks/Advantages. Different \r\n+     * colors will be supplied for a dark and for a light UI look-and-feel.\r\n+     */\r\n+    public static Color uiQuirksColor() {\r\n+        return uiBgBrightness() > 130 ? LIGHTUI_LIGHTCYAN : DARKUI_LIGHTCYAN;\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a color for the UI display of Partial Repairs. Different \r\n+     * colors will be supplied for a dark and for a light UI look-and-feel.\r\n+     */\r\n+    public static Color uiPartialRepairColor() {\r\n+        return uiLightRed();\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a color for the UI display of C3 Info. Different \r\n+     * colors will be supplied for a dark and for a light UI look-and-feel.\r\n+     */\r\n+    public static Color uiC3Color() {\r\n+        return uiLightViolet();\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a color for the UI display of C3 Info. Different \r\n+     * colors will be supplied for a dark and for a light UI look-and-feel.\r\n+     */\r\n+    public static Color uiNickColor() {\r\n+        return uiLightGreen();\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a color for the UI display of C3 Info. Different \r\n+     * colors will be supplied for a dark and for a light UI look-and-feel.\r\n+     */\r\n+    public static Color uiTTWeaponColor() {\r\n+        return uiLightBlue();\r\n+    }\r\n+    \r\n+    public static int scaleForGUI(int value) {\r\n+        return Math.round(scaleForGUI((float)value));\r\n+    }\r\n+    \r\n+    public static float scaleForGUI(float value) {\r\n+        return GUIPreferences.getInstance().getGUIScale() * value;\r\n+    }\r\n+    \r\n+    public static Dimension scaleForGUI(Dimension dim) {\r\n+        float scale = GUIPreferences.getInstance().getGUIScale();\r\n+        return new Dimension((int)(scale * dim.width), (int)(scale * dim.height));\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns the provided color with its alpha value set to the provided alpha.\r\n+     * alpha should be from 0 to 255 with 0 meaning transparent. \r\n+     */\r\n+    public static Color addAlpha(Color color, int alpha) {\r\n+        Objects.requireNonNull(color);\r\n+        if (alpha < 0 || alpha > 255) {\r\n+            throw new IllegalArgumentException(\"Alpha value out of range: \" + alpha);\r\n+        }\r\n+        return new Color(color.getRed(), color.getGreen(), color.getBlue(), alpha);\r\n+    }\r\n+    \r\n+    /** \r\n+     * Returns a grayed-out version of the given color. gray should be from 0 to 255\r\n+     * with 255 meaning completely gray. Does not change the brightness, nor alpha. \r\n+     */\r\n+    public static Color addGray(Color color, int gray) {\r\n+        Objects.requireNonNull(color);\r\n+        if (gray < 0 || gray > 255) {\r\n+            throw new IllegalArgumentException(\"Gray value out of range: \" + gray);\r\n+        }\r\n+        int mid = (color.getRed() + color.getGreen() + color.getBlue()) * gray / 3;\r\n+        int red = (color.getRed() * (255 - gray) + mid) / 255;\r\n+        int green = (color.getGreen() * (255 - gray) + mid) / 255;\r\n+        int blue = (color.getBlue() * (255 - gray) + mid) / 255;\r\n+        return new Color(red, green, blue, color.getAlpha());\r\n+    }\r\n+    \r\n+    /** Returns the given String str enclosed in HTML tags and with a font tag according to the guiScale. */ \r\n+    public static String scaleStringForGUI(String str) {\r\n+        return \"<HTML>\" + UIUtil.guiScaledFontHTML() + str + \"</FONT></HTML>\";\r\n+    }\r\n+    \r\n+    /** Returns the given String str enclosed in HTML tags and with a font tag according to the guiScale. */ \r\n+    public static String scaleMessageForGUI(String str) {\r\n+        return \"<HTML>\" + UIUtil.guiScaledFontHTML() + Messages.getString(str) + \"</FONT></HTML>\";\r\n+    }\r\n+    \r\n+    public static void adjustDialog(Container contentPane) {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY2NzUzMA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r617667530", "bodyText": "This applies the current gui scale to a dialog by setting fonts and adjusting EmptyBorders. This works kinda well with simple dialogs (the host game dialog, for example).", "author": "SJuliez", "createdAt": "2021-04-21T15:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjkwOTc0Nw=="}], "type": "inlineReview"}, {"oid": "1532a196c038a51c2252651ef02ed6e74f3b4a65", "url": "https://github.com/MegaMek/megamek/commit/1532a196c038a51c2252651ef02ed6e74f3b4a65", "message": "Review Changes pt. 1", "committedDate": "2021-04-17T16:43:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcwOTY5NQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616709695", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            output.write(indentStr(indentLvl+1) + \"<Force force=\\\"\");\n          \n          \n            \n                            output.write(indentStr(indentLvl + 1) + \"<Force force=\\\"\");", "author": "Windchild292", "createdAt": "2021-04-20T13:58:06Z", "path": "megamek/src/megamek/common/EntityListFile.java", "diffHunk": "@@ -1102,6 +1103,19 @@ private static void writeEntityList(Writer output, ArrayList<Entity> list) throw\n                 output.write(\"\\\"/>\");\n                 output.write(CommonConstants.NL);\n             }\n+\n+            // Write the force hierarchy\n+            if (entity.getForceString().length() > 0) {\n+                output.write(indentStr(indentLvl+1) + \"<Force force=\\\"\");", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcwOTgyNA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616709824", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            output.write(indentStr(indentLvl+1) + \"<Force force=\\\"\");\n          \n          \n            \n                            output.write(indentStr(indentLvl + 1) + \"<Force force=\\\"\");", "author": "Windchild292", "createdAt": "2021-04-20T13:58:16Z", "path": "megamek/src/megamek/common/EntityListFile.java", "diffHunk": "@@ -1102,6 +1103,19 @@ private static void writeEntityList(Writer output, ArrayList<Entity> list) throw\n                 output.write(\"\\\"/>\");\n                 output.write(CommonConstants.NL);\n             }\n+\n+            // Write the force hierarchy\n+            if (entity.getForceString().length() > 0) {\n+                output.write(indentStr(indentLvl+1) + \"<Force force=\\\"\");\n+                output.write(entity.getForceString());\n+                output.write(\"\\\"/>\");\n+                output.write(CommonConstants.NL);\n+            } else if ((entity.getGame() != null) && (entity.getForceId() != Force.NO_FORCE)) {\n+                output.write(indentStr(indentLvl+1) + \"<Force force=\\\"\");", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxMTE3Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616711176", "bodyText": "Indent switch, and just have the default return OffBoardDirection.NONE instead of having it outside the switch", "author": "Windchild292", "createdAt": "2021-04-20T13:59:39Z", "path": "megamek/src/megamek/common/OffBoardDirection.java", "diffHunk": "@@ -78,4 +78,30 @@ public static OffBoardDirection getOpposite(OffBoardDirection value) {\n             return NONE;\n         }\n     }\n+    \n+    /** \n+     * Returns the OffBoardDirection associated with given the on-board deployment\n+     * position as defined in IStartingPositions.\n+     */\n+    public static OffBoardDirection translateStartPosition(int startPos) {\n+        if (startPos > 10) {\n+            startPos -= 10;\n+        }\n+        switch (startPos) {\n+        case 1:\n+        case 2:\n+        case 3:\n+            return OffBoardDirection.NORTH;\n+        case 4:\n+            return OffBoardDirection.EAST;\n+        case 5:\n+        case 6:\n+        case 7:\n+            return OffBoardDirection.SOUTH;\n+        case 8:\n+            return OffBoardDirection.WEST;\n+        default:", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxMjYyNw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616712627", "bodyText": "Unchecked TODO", "author": "Windchild292", "createdAt": "2021-04-20T14:01:11Z", "path": "megamek/src/megamek/common/Player.java", "diffHunk": "@@ -417,6 +418,7 @@ public int getBV() {\n      */\n     @Override\n     public int getFledBV() {\n+        //TODO: I'm not sure how squadrons are treated here - see getBV()", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODcwMDA4Nw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r618700087", "bodyText": "Note that I changed the getBV() function you updated to a stream() a few days ago because it counted Squadrons twice. With the FledBV I just wanted to note that the same problem applied here maybe but Im not about to figure that out now.", "author": "SJuliez", "createdAt": "2021-04-22T19:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxMjYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNDIxOQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616714219", "bodyText": "Header", "author": "Windchild292", "createdAt": "2021-04-20T14:03:02Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/TypeSorter.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNDcwMQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616714701", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-04-20T14:03:35Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/NameSorter.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNTA4MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616715080", "bodyText": "ternary return candidate", "author": "Windchild292", "createdAt": "2021-04-20T14:04:01Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/NameSorter.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+\r\n+/** A Lobby Mek Table sorter that sorts by unit name. */\r\n+public class NameSorter implements MekTableSorter {\r\n+\r\n+    private Sorting direction;\r\n+\r\n+    /** A Lobby Mek Table sorter that sorts by unit name. */\r\n+    public NameSorter(Sorting dir) {\r\n+        direction = dir;\r\n+    }\r\n+    \r\n+    @Override\r\n+    public int compare(final Entity a, final Entity b) {\r\n+        String aVal = a.getDisplayName();\r\n+        String bVal = b.getDisplayName();\r\n+        if (direction == Sorting.ASCENDING) {\r\n+            return aVal.compareTo(bVal);\r\n+        } else {\r\n+            return bVal.compareTo(aVal);\r\n+        }\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNTI2NQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616715265", "bodyText": "Header", "author": "Windchild292", "createdAt": "2021-04-20T14:04:14Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/PlayerBVSorter.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNjI0OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616716248", "bodyText": "Why not use two comparators, one that sorts by player, then a follow up comparator that sorts by BV?", "author": "Windchild292", "createdAt": "2021-04-20T14:05:16Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/PlayerBVSorter.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+\r\n+/** A Lobby Mek Table sorter that sorts for 1) Player 2) BV. */\r\n+public class PlayerBVSorter implements MekTableSorter {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODcwMTI0OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r618701248", "bodyText": "Another time...", "author": "SJuliez", "createdAt": "2021-04-22T20:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNjI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNjQ5Mg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616716492", "bodyText": "Same as above, why one instead of two?", "author": "Windchild292", "createdAt": "2021-04-20T14:05:31Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/PlayerTonnageSorter.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+\r\n+/** A Lobby Mek Table sorter that sorts by 1) player 2) tonnage. */\r\n+public class PlayerTonnageSorter implements MekTableSorter {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNjU1MQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616716551", "bodyText": "Header", "author": "Windchild292", "createdAt": "2021-04-20T14:05:34Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/PlayerTonnageSorter.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxNzg0OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616717848", "bodyText": "Header", "author": "Windchild292", "createdAt": "2021-04-20T14:07:01Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/BVSorter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxODI3OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616718279", "bodyText": "Header", "author": "Windchild292", "createdAt": "2021-04-20T14:07:26Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/C3IDSorter.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxODcwOA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616718708", "bodyText": "Class description would be nice, as is seen in the other sorters", "author": "Windchild292", "createdAt": "2021-04-20T14:07:48Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/C3IDSorter.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+\r\n+public class C3IDSorter implements MekTableSorter {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxOTM2NA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616719364", "bodyText": "Try to keep the same order of compare, display name, column index", "author": "Windchild292", "createdAt": "2021-04-20T14:08:27Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/C3IDSorter.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+\r\n+public class C3IDSorter implements MekTableSorter {\r\n+    \r\n+    private ClientGUI clientGui;\r\n+    \r\n+    /** A Lobby Mek Table sorter that sorts mainly by association to C3 networks */\r\n+    public C3IDSorter(ClientGUI cg) {\r\n+        clientGui = cg;\r\n+    }\r\n+    \r\n+    @Override\r\n+    public String getDisplayName() {\r\n+        return \"C3 Network\";\r\n+    }\r\n+    \r\n+    @Override\r\n+    public int getColumnIndex() {\r\n+        return MekTableModel.COL_UNIT;\r\n+    }\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODcwMTg4MQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r618701881", "bodyText": "Lets not overdo it.", "author": "SJuliez", "createdAt": "2021-04-22T20:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxOTM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxOTYwMQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616719601", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-04-20T14:08:43Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/ForceSorter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxOTc1MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616719750", "bodyText": "Class description would be nice here", "author": "Windchild292", "createdAt": "2021-04-20T14:08:53Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/ForceSorter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import java.util.ArrayList;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+import megamek.common.force.Force;\r\n+\r\n+public class ForceSorter implements MekTableSorter {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODcwMjAwOQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r618702009", "bodyText": "No longer used, deleted.", "author": "SJuliez", "createdAt": "2021-04-22T20:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcxOTc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMDA5Nw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616720097", "bodyText": "Try to keep the same order of compare, display name, column index", "author": "Windchild292", "createdAt": "2021-04-20T14:09:14Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/ForceSorter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import java.util.ArrayList;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+import megamek.common.force.Force;\r\n+\r\n+public class ForceSorter implements MekTableSorter {\r\n+\r\n+private ClientGUI clientGui;\r\n+    \r\n+    /** A Lobby Mek Table sorter that sorts mainly by association to forces. */\r\n+    public ForceSorter(ClientGUI cg) {\r\n+        clientGui = cg;\r\n+    }\r\n+    \r\n+    @Override\r\n+    public String getDisplayName() {\r\n+        return \"Forces\";\r\n+    }\r\n+    \r\n+    @Override\r\n+    public int getColumnIndex() {\r\n+        return MekTableModel.COL_UNIT;\r\n+    }\r\n+\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMDE5OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616720199", "bodyText": "indent", "author": "Windchild292", "createdAt": "2021-04-20T14:09:19Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/ForceSorter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import java.util.ArrayList;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+import megamek.common.force.Force;\r\n+\r\n+public class ForceSorter implements MekTableSorter {\r\n+\r\n+private ClientGUI clientGui;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMDQwMg==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616720402", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-04-20T14:09:31Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/IDSorter.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMDcyMA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616720720", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-04-20T14:09:54Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/MekTableSorter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMTAxMw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616721013", "bodyText": "ternary", "author": "Windchild292", "createdAt": "2021-04-20T14:10:12Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/MekTableSorter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import java.util.Comparator;\r\n+\r\n+import megamek.common.Entity;\r\n+import megamek.common.options.GameOptions;\r\n+\r\n+/** An interface for the Comparators used for the lobby Mek table. */\r\n+public interface MekTableSorter extends Comparator<Entity> {\r\n+    \r\n+    public enum Sorting { ASCENDING, DESCENDING; }\r\n+\r\n+    /** \r\n+     * Returns the info that is displayed in the column header to show\r\n+     * the sorting that is used, such as \"Team / BV\".\r\n+     */\r\n+    String getDisplayName();\r\n+    \r\n+    /** \r\n+     * Returns the column index of the Mek Table that this sorter is to be used with. \r\n+     */\r\n+    int getColumnIndex();\r\n+    \r\n+    /**\r\n+     * Returns true if this Sorter is currently allowed. Sorters might not be allowed e.g.\r\n+     * when they would give away info in blind drops.\r\n+     */\r\n+    default boolean isAllowed(GameOptions opts) {\r\n+        return true;\r\n+    }\r\n+    \r\n+    /** Returns the sorting direction. */\r\n+    default Sorting getSortingDirection() {\r\n+        return null;\r\n+    };\r\n+    \r\n+    /** Returns 1 if dir is ASCENDING, -1 otherwise. */\r\n+    default int bigger(Sorting dir) {\r\n+        if (dir == Sorting.ASCENDING) {\r\n+            return 1;\r\n+        } else {\r\n+            return -1;\r\n+        }\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMTA3OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616721079", "bodyText": "ternary", "author": "Windchild292", "createdAt": "2021-04-20T14:10:16Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/MekTableSorter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import java.util.Comparator;\r\n+\r\n+import megamek.common.Entity;\r\n+import megamek.common.options.GameOptions;\r\n+\r\n+/** An interface for the Comparators used for the lobby Mek table. */\r\n+public interface MekTableSorter extends Comparator<Entity> {\r\n+    \r\n+    public enum Sorting { ASCENDING, DESCENDING; }\r\n+\r\n+    /** \r\n+     * Returns the info that is displayed in the column header to show\r\n+     * the sorting that is used, such as \"Team / BV\".\r\n+     */\r\n+    String getDisplayName();\r\n+    \r\n+    /** \r\n+     * Returns the column index of the Mek Table that this sorter is to be used with. \r\n+     */\r\n+    int getColumnIndex();\r\n+    \r\n+    /**\r\n+     * Returns true if this Sorter is currently allowed. Sorters might not be allowed e.g.\r\n+     * when they would give away info in blind drops.\r\n+     */\r\n+    default boolean isAllowed(GameOptions opts) {\r\n+        return true;\r\n+    }\r\n+    \r\n+    /** Returns the sorting direction. */\r\n+    default Sorting getSortingDirection() {\r\n+        return null;\r\n+    };\r\n+    \r\n+    /** Returns 1 if dir is ASCENDING, -1 otherwise. */\r\n+    default int bigger(Sorting dir) {\r\n+        if (dir == Sorting.ASCENDING) {\r\n+            return 1;\r\n+        } else {\r\n+            return -1;\r\n+        }\r\n+    }\r\n+    \r\n+    /** Returns -1 if dir is ASCENDING, 1 otherwise. */\r\n+    default int smaller(Sorting dir) {\r\n+        if (dir == Sorting.ASCENDING) {\r\n+            return -1;\r\n+        } else {\r\n+            return 1;\r\n+        }\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMTU3Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616721573", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns true if this Sorter is currently allowed. Sorters might not be allowed e.g.\n          \n          \n            \n                 * when they would give away info in blind drops.\n          \n          \n            \n                 * Returns true if this Sorter is currently allowed. Sorters might not be allowed\n          \n          \n            \n                 * e.g. when they would give away info in blind drops.", "author": "Windchild292", "createdAt": "2021-04-20T14:10:46Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/MekTableSorter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import java.util.Comparator;\r\n+\r\n+import megamek.common.Entity;\r\n+import megamek.common.options.GameOptions;\r\n+\r\n+/** An interface for the Comparators used for the lobby Mek table. */\r\n+public interface MekTableSorter extends Comparator<Entity> {\r\n+    \r\n+    public enum Sorting { ASCENDING, DESCENDING; }\r\n+\r\n+    /** \r\n+     * Returns the info that is displayed in the column header to show\r\n+     * the sorting that is used, such as \"Team / BV\".\r\n+     */\r\n+    String getDisplayName();\r\n+    \r\n+    /** \r\n+     * Returns the column index of the Mek Table that this sorter is to be used with. \r\n+     */\r\n+    int getColumnIndex();\r\n+    \r\n+    /**\r\n+     * Returns true if this Sorter is currently allowed. Sorters might not be allowed e.g.\r\n+     * when they would give away info in blind drops.\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODcwMzI2NQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r618703265", "bodyText": "You do take things seriously, do you :)", "author": "SJuliez", "createdAt": "2021-04-22T20:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMjkyNw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616722927", "bodyText": "Try to keep the same order of compare, display name, column index", "author": "Windchild292", "createdAt": "2021-04-20T14:12:15Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/PlayerTransportIDSorter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+\r\n+/** A Lobby Mek Table sorter that sorts by 1) player 2) transported units 3) ID. */\r\n+public class PlayerTransportIDSorter implements MekTableSorter {\r\n+    \r\n+    private ClientGUI clientGui;\r\n+    \r\n+    /** A Lobby Mek Table sorter that sorts by 1) player 2) transported units 3) ID. */\r\n+    public PlayerTransportIDSorter(ClientGUI cg) {\r\n+        clientGui = cg;\r\n+    }\r\n+    \r\n+    @Override\r\n+    public String getDisplayName() {\r\n+        return \"Player, Transported Units, ID\";\r\n+    }\r\n+    \r\n+    @Override\r\n+    public int getColumnIndex() {\r\n+        return MekTableModel.COL_UNIT;\r\n+    }\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMjk4OA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616722988", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-04-20T14:12:19Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/PlayerTransportIDSorter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMzM0NQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616723345", "bodyText": "space before this line", "author": "Windchild292", "createdAt": "2021-04-20T14:12:39Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/PlayerTransportIDSorter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package megamek.client.ui.swing.lobby.sorters;\r\n+\r\n+import megamek.client.ui.swing.ClientGUI;\r\n+import megamek.client.ui.swing.lobby.MekTableModel;\r\n+import megamek.common.Entity;\r\n+import megamek.common.IPlayer;\r\n+\r\n+/** A Lobby Mek Table sorter that sorts by 1) player 2) transported units 3) ID. */\r\n+public class PlayerTransportIDSorter implements MekTableSorter {\r\n+    \r\n+    private ClientGUI clientGui;\r\n+    \r\n+    /** A Lobby Mek Table sorter that sorts by 1) player 2) transported units 3) ID. */\r\n+    public PlayerTransportIDSorter(ClientGUI cg) {\r\n+        clientGui = cg;\r\n+    }\r\n+    \r\n+    @Override\r\n+    public String getDisplayName() {\r\n+        return \"Player, Transported Units, ID\";\r\n+    }\r\n+    \r\n+    @Override\r\n+    public int getColumnIndex() {\r\n+        return MekTableModel.COL_UNIT;\r\n+    }\r\n+\r\n+    @Override\r\n+    public int compare(final Entity a, final Entity b) {\r\n+        // entity.getOwner() does not work properly because teams are\r\n+        // not updated for entities when the user switches teams\r\n+        final IPlayer p_a = clientGui.getClient().getGame().getPlayer(a.getOwnerId());\r\n+        final IPlayer p_b = clientGui.getClient().getGame().getPlayer(b.getOwnerId());\r\n+        final IPlayer localPlayer = clientGui.getClient().getLocalPlayer();\r\n+        final int t_a = p_a.getTeam();\r\n+        final int t_b = p_b.getTeam();\r\n+        final int tr_a = a.getTransportId();\r\n+        final int tr_b = b.getTransportId();\r\n+        if (p_a.equals(localPlayer) && !p_b.equals(localPlayer)) {\r\n+            return -1;\r\n+        } else if (!p_a.equals(localPlayer) && p_b.equals(localPlayer)) {\r\n+            return 1;\r\n+        } else if ((t_a == localPlayer.getTeam()) && (t_b != localPlayer.getTeam())) {\r\n+            return -1;\r\n+        } else if ((t_b == localPlayer.getTeam()) && (t_a != localPlayer.getTeam())) {\r\n+            return 1;\r\n+        } else if (t_a != t_b) {\r\n+            return t_a - t_b;\r\n+        } else if (!p_a.equals(p_b)) {\r\n+            return p_a.getName().compareTo(p_b.getName());\r\n+        } else {\r\n+            int a_id = a.getId();\r\n+            int b_id = b.getId();\r\n+            // loaded units should be put immediately below their parent unit\r\n+            // if a unit's transport ID is not none, then it should\r\n+            // replace their actual id\r\n+            if (tr_a == tr_b) {\r\n+                // either they are both not being transported, or they\r\n+                // are being transported by the same unit\r\n+                return a_id - b_id;\r\n+            }\r\n+\r\n+            if (tr_b != Entity.NONE) {\r\n+                if (tr_b == a_id) {\r\n+                    // b is loaded on a\r\n+                    return -1;\r\n+                }\r\n+                b_id = tr_b;\r\n+            }\r\n+            if (tr_a != Entity.NONE) {\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyMzU1Nw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616723557", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-04-20T14:12:51Z", "path": "megamek/src/megamek/client/ui/swing/lobby/sorters/TonnageSorter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package megamek.client.ui.swing.lobby.sorters;\r", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyNTU5NA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616725594", "bodyText": "Ternary candidate, remove old code", "author": "Windchild292", "createdAt": "2021-04-20T14:14:57Z", "path": "megamek/src/megamek/common/Entity.java", "diffHunk": "@@ -1482,7 +1497,21 @@ public int getBodyLocation() {\n      * Returns the player that \"owns\" this entity.\n      */\n     public IPlayer getOwner() {\n-        return owner;\n+        // Replaced 24 NOV 2020\n+        // Server and other central classes already used game.getplayer(entity.getownerID())\n+        // instead of entity.getowner() and it is noted that getOwner is not reliable. \n+        // The entity owner object would have to be replaced whenever a player is updated \n+        // which does not happen. The player ID on the other hand stays the same and the game\n+        // object is not usually replaced. I expect entity.game to be up to date much more than owner.\n+        // Unfortunately, entities freshly created may not have the game set. Therefore, fall\n+        // back to the old version when game == null\n+        if (game != null) {\n+            return game.getPlayer(ownerId);\n+        } else {\n+            return owner;\n+        }\n+        // FORMERLY:\n+        // return owner;", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODcwNTE2Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r618705166", "bodyText": "Id like this to remain non-ternary. This is kinda important, not something to collapse to a line.", "author": "SJuliez", "createdAt": "2021-04-22T20:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyNTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjcyNjIxNQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616726215", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(null == getOwner()) {\n          \n          \n            \n                    if (null == getOwner()) {\n          \n      \n    \n    \n  \n\nPlease try to fix this when you are editing, as it is an annoying accessibility issue.", "author": "Windchild292", "createdAt": "2021-04-20T14:15:33Z", "path": "megamek/src/megamek/common/Entity.java", "diffHunk": "@@ -1505,11 +1534,11 @@ public boolean isEnemyOf(Entity other) {\n         if(null == other) {\n             return false;\n         }\n-        if(null == owner) {\n+        if(null == getOwner()) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjczMjE0OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616732149", "bodyText": "The set increment of 16 caused a bug in MekHQ. It is far better to base it on the visible height of the panel being scrolled.", "author": "Windchild292", "createdAt": "2021-04-20T14:21:39Z", "path": "megamek/src/megamek/client/ui/swing/RandomMapPanelAdvanced.java", "diffHunk": "@@ -332,18 +332,23 @@ private void initGUI() {\n         // Let each tab have it's own scroll bar.\n \n         JScrollPane civilizedFeaturesPanel = setupCivilizedPanel();\n+        civilizedFeaturesPanel.getVerticalScrollBar().setUnitIncrement(16);\n         tabbedPane.addTab(Messages.getString(\"RandomMapDialog.tabCivilization\"), civilizedFeaturesPanel);\n \n         JScrollPane elevationPanel = setupElevationPanel();\n+        elevationPanel.getVerticalScrollBar().setUnitIncrement(16);\n         tabbedPane.addTab(Messages.getString(\"RandomMapDialog.tabElevation\"), elevationPanel);\n \n         JScrollPane naturalFeaturesPanel = setupNaturalFeaturesPanel();\n+        naturalFeaturesPanel.getVerticalScrollBar().setUnitIncrement(16);\n         tabbedPane.addTab(Messages.getString(\"RandomMapDialog.tabNatural\"), naturalFeaturesPanel);\n \n         JScrollPane effectsPanel = setupEffectsPanel();\n+        effectsPanel.getVerticalScrollBar().setUnitIncrement(16);\n         tabbedPane.addTab(Messages.getString(\"RandomMapDialog.tabEffects\"), effectsPanel);\n \n         JScrollPane waterPanel = setupWaterPanel();\n+        waterPanel.getVerticalScrollBar().setUnitIncrement(16);", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODcwNjcxMA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r618706710", "bodyText": "Um, what kind of bug? Why, where. It is used in MM widely and I see no bugs. In any case, please give me a better solution.", "author": "SJuliez", "createdAt": "2021-04-22T20:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjczMjE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjczMjU4Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616732586", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            \"pre { font-family: \" + font.getFamily() + \"; font-size: \"+size+\"pt; font-style:normal;}\");\n          \n          \n            \n                            \"pre { font-family: \" + font.getFamily() + \"; font-size: \" + size + \"pt; font-style:normal;}\");", "author": "Windchild292", "createdAt": "2021-04-20T14:22:03Z", "path": "megamek/src/megamek/client/ui/swing/ReportDisplay.java", "diffHunk": "@@ -223,10 +228,11 @@ public void setReportTab(int round, String roundText, String phaseText) {\n     public static void setupStylesheet(JTextPane pane) {\n         pane.setContentType(\"text/html\");\n         Font font = UIManager.getFont(\"Label.font\");\n+        int size = UIUtil.scaleForGUI(UIUtil.FONT_SCALE1);\n         ((HTMLEditorKit) pane.getEditorKit()).getStyleSheet().addRule(\n-               \"pre { font-family: \" + font.getFamily() + \"; font-size: 12pt; font-style:normal;}\");\n+                \"pre { font-family: \" + font.getFamily() + \"; font-size: \"+size+\"pt; font-style:normal;}\");", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjczMzA3MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616733070", "bodyText": "Indent", "author": "Windchild292", "createdAt": "2021-04-20T14:22:34Z", "path": "megamek/src/megamek/client/ui/swing/MovementDisplay.java", "diffHunk": "@@ -2116,12 +2116,12 @@ private void updateRACButton() {\n \n     private void updateSearchlightButton() {\n         final Entity ce = ce();\n-        if (null == ce) {\n-            return;\n-        }\n+        if (ce != null) {\n+        boolean isNight = clientgui.getClient().getGame().getPlanetaryConditions().isSearchlightEffective();\n         setSearchlightEnabled(", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0MjI5Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616742296", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ArrayList<ForceDescriptor> ancestors = new ArrayList<>();\n          \n          \n            \n                    List<ForceDescriptor> ancestors = new ArrayList<>();", "author": "Windchild292", "createdAt": "2021-04-20T14:32:27Z", "path": "megamek/src/megamek/client/ratgenerator/ForceDescriptor.java", "diffHunk": "@@ -843,6 +845,29 @@ public void loadEntities(Ruleset.ProgressListener l, double progress) {\n             l.updateProgress(progress, \"Loading entities\");\n         }\n     }\n+    \n+    /** Generates a force string for exporting these units to MUL / adding to the game. */\n+    private String getForceString() {\n+        ArrayList<ForceDescriptor> ancestors = new ArrayList<>();", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTE4ODIwOA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r619188208", "bodyText": "I'll use var instead", "author": "SJuliez", "createdAt": "2021-04-23T12:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0MjI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NjE0NA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616746144", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Integer> forceIds = new ArrayList<>();\n          \n          \n            \n                    toDelete.stream().mapToInt(f -> f.getId()).forEach(forceIds::add);\n          \n          \n            \n                    List<Integer> forceIds = toDelete.stream().mapToInt(Force::getId).boxed().collect(Collectors.toList());", "author": "Windchild292", "createdAt": "2021-04-20T14:36:39Z", "path": "megamek/src/megamek/client/Client.java", "diffHunk": "@@ -852,6 +865,50 @@ public void sendDeploymentUnload(Entity loader, Entity loaded) {\n         Object data[] = { loader.getId(), loaded.getId() };\n         send(new Packet(Packet.COMMAND_ENTITY_DEPLOY_UNLOAD, data));\n     }\n+    \n+    /**\n+     * Sends an \"Update force\" packet\n+     */\n+    public void sendUpdateForce(Collection<Force> changedForces, Collection<Entity> changedEntities) {\n+        send(new Packet(Packet.COMMAND_FORCE_UPDATE, new Object[] { changedForces, changedEntities }));\n+    }\n+    \n+    /**\n+     * Sends an \"Update force\" packet\n+     */\n+    public void sendUpdateForce(Collection<Force> changedForces) {\n+        send(new Packet(Packet.COMMAND_FORCE_UPDATE, new Object[] { changedForces, new ArrayList<>() }));\n+    }\n+    \n+    /**\n+     * Sends a packet instructing the server to add the given entities to the given force.\n+     * The server will handle this; the client does not have to implement the change.\n+     */\n+    public void sendAddEntitiesToForce(Collection<Entity> entities, int forceId) {\n+        send(new Packet(Packet.COMMAND_FORCE_ADD_ENTITY, new Object[] { entities, forceId }));\n+    }\n+    \n+    /**\n+     * Sends a packet instructing the server to add the given entities to the given force.\n+     * The server will handle this; the client does not have to implement the change.\n+     */\n+    public void sendAssignForceFull(Collection<Force> forceList, int newOwnerId) {\n+        send(new Packet(Packet.COMMAND_FORCE_ASSIGN_FULL, new Object[] { forceList, newOwnerId }));\n+    }\n+        \n+    /** Sends a packet to the Server requesting to delete the given forces. */\n+    public void sendDeleteForces(List<Force> toDelete) {\n+        List<Integer> forceIds = new ArrayList<>();\n+        toDelete.stream().mapToInt(f -> f.getId()).forEach(forceIds::add);", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NjQ0OQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616746449", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Force force: forces) {\n          \n          \n            \n                    for (Force force : forces) {", "author": "Windchild292", "createdAt": "2021-04-20T14:37:00Z", "path": "megamek/src/megamek/client/Client.java", "diffHunk": "@@ -953,7 +1015,41 @@ protected void receiveEntities(Packet c) {\n             cacheImgTag(e);\n         }\n     }\n-\n+    \n+    /**\n+     * Receives a force-related update containing affected forces and affected entities\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void receiveForceUpdate(Packet c) {\n+        Collection<Force> forces = (Collection<Force>) c.getObject(0);\n+        Collection<Entity> entities = (Collection<Entity>) c.getObject(1);\n+        for (Force force: forces) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTE4OTM4MA==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r619189380", "bodyText": "See below.", "author": "SJuliez", "createdAt": "2021-04-23T12:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NjQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NjcyNw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616746727", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Entity entity: entities) {\n          \n          \n            \n                    for (Entity entity : entities) {", "author": "Windchild292", "createdAt": "2021-04-20T14:37:17Z", "path": "megamek/src/megamek/client/Client.java", "diffHunk": "@@ -953,7 +1015,41 @@ protected void receiveEntities(Packet c) {\n             cacheImgTag(e);\n         }\n     }\n-\n+    \n+    /**\n+     * Receives a force-related update containing affected forces and affected entities\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void receiveForceUpdate(Packet c) {\n+        Collection<Force> forces = (Collection<Force>) c.getObject(0);\n+        Collection<Entity> entities = (Collection<Entity>) c.getObject(1);\n+        for (Force force: forces) {\n+            game.getForces().replace(force.getId(), force);\n+        }\n+        for (Entity entity: entities) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTE4NjU2Mw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r619186563", "bodyText": "Not my style.", "author": "SJuliez", "createdAt": "2021-04-23T12:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NjcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTY4OTk0NQ==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r619689945", "bodyText": "This isn't a style bit, but code accessibility. You separate out the \":\" to ensure that the symbol isn't read as part of the word and then ignored, as it makes it into a separate word.", "author": "Windchild292", "createdAt": "2021-04-24T18:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NjcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NzI4Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616747286", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Collection<Entity> entities = (Collection<Entity>) c.getObject(0);\n          \n          \n            \n                    for (Entity entity: entities) {\n          \n          \n            \n                    Collection<Entity> entities = (Collection<Entity>) c.getObject(0);\n          \n          \n            \n                    for (Entity entity : entities) {", "author": "Windchild292", "createdAt": "2021-04-20T14:37:49Z", "path": "megamek/src/megamek/client/Client.java", "diffHunk": "@@ -965,28 +1061,50 @@ protected void receiveEntityUpdate(Packet c) {\n         // Replace this entity in the game.\n         game.setEntity(eindex, entity, movePath);\n     }\n+    \n+    /**\n+     * Update multiple entities from the server. Used only in the lobby phase. \n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void receiveEntitiesUpdate(Packet c) {\n+        Collection<Entity> entities = (Collection<Entity>) c.getObject(0);\n+        for (Entity entity: entities) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NzY2Ng==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616747666", "bodyText": "Could also probably just have the cast in the for loop call", "author": "Windchild292", "createdAt": "2021-04-20T14:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NzI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0NzgzNw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616747837", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Force force: forces) {\n          \n          \n            \n                    for (Force force : forces) {", "author": "Windchild292", "createdAt": "2021-04-20T14:38:22Z", "path": "megamek/src/megamek/client/Client.java", "diffHunk": "@@ -965,28 +1061,50 @@ protected void receiveEntityUpdate(Packet c) {\n         // Replace this entity in the game.\n         game.setEntity(eindex, entity, movePath);\n     }\n+    \n+    /**\n+     * Update multiple entities from the server. Used only in the lobby phase. \n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void receiveEntitiesUpdate(Packet c) {\n+        Collection<Entity> entities = (Collection<Entity>) c.getObject(0);\n+        for (Entity entity: entities) {\n+            game.setEntity(entity.getId(), entity);\n+        }\n+    }\n \n     protected void receiveEntityAdd(Packet packet) {\n         @SuppressWarnings(\"unchecked\")\n         List<Integer> entityIds = (List<Integer>) packet.getObject(0);\n         @SuppressWarnings(\"unchecked\")\n         List<Entity> entities = (List<Entity>) packet.getObject(1);\n+        @SuppressWarnings(\"unchecked\")\n+        List<Force> forces = (List<Force>) packet.getObject(2);\n \n+        for (Force force: forces) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjc0ODA0Nw==", "url": "https://github.com/MegaMek/megamek/pull/2409#discussion_r616748047", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Force force: forces) {\n          \n          \n            \n                    for (Force force : forces) {", "author": "Windchild292", "createdAt": "2021-04-20T14:38:33Z", "path": "megamek/src/megamek/client/Client.java", "diffHunk": "@@ -965,28 +1061,50 @@ protected void receiveEntityUpdate(Packet c) {\n         // Replace this entity in the game.\n         game.setEntity(eindex, entity, movePath);\n     }\n+    \n+    /**\n+     * Update multiple entities from the server. Used only in the lobby phase. \n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void receiveEntitiesUpdate(Packet c) {\n+        Collection<Entity> entities = (Collection<Entity>) c.getObject(0);\n+        for (Entity entity: entities) {\n+            game.setEntity(entity.getId(), entity);\n+        }\n+    }\n \n     protected void receiveEntityAdd(Packet packet) {\n         @SuppressWarnings(\"unchecked\")\n         List<Integer> entityIds = (List<Integer>) packet.getObject(0);\n         @SuppressWarnings(\"unchecked\")\n         List<Entity> entities = (List<Entity>) packet.getObject(1);\n+        @SuppressWarnings(\"unchecked\")\n+        List<Force> forces = (List<Force>) packet.getObject(2);\n \n+        for (Force force: forces) {\n+            game.getForces().replace(force.getId(), force);\n+        }\n         assert(entityIds.size() == entities.size());\n         for (int i = 0; i < entityIds.size(); i++) {\n             assert(entityIds.get(i) == entities.get(i).getId());\n         }\n         game.addEntities(entities);\n+        \n     }\n \n     protected void receiveEntityRemove(Packet packet) {\n         @SuppressWarnings(\"unchecked\")\n         List<Integer> entityIds = (List<Integer>) packet.getObject(0);\n         int condition = packet.getIntValue(1);\n+        @SuppressWarnings(\"unchecked\")\n+        List<Force> forces = (List<Force>) packet.getObject(2);\n         //create a final image for the entity\n         for(int id: entityIds) {\n             cacheImgTag(game.getEntity(id));\n         }\n+        for (Force force: forces) {", "originalCommit": "10d62a97552c6e4017edbb11d566ca11d6954c04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "090f5b00e73479f91c0e4521dd23aa248e35aa4c", "url": "https://github.com/MegaMek/megamek/commit/090f5b00e73479f91c0e4521dd23aa248e35aa4c", "message": "Nickaragua Review changes", "committedDate": "2021-04-22T19:33:00Z", "type": "commit"}, {"oid": "34428509950ef1e1c3a590e289078319d4cdc7a4", "url": "https://github.com/MegaMek/megamek/commit/34428509950ef1e1c3a590e289078319d4cdc7a4", "message": "Merge branch 'master' into GUI", "committedDate": "2021-04-22T19:45:51Z", "type": "commit"}, {"oid": "609f3b8eb5c0b5daa863394b8e55a5b57eb94d1d", "url": "https://github.com/MegaMek/megamek/commit/609f3b8eb5c0b5daa863394b8e55a5b57eb94d1d", "message": "Windchild Review changes", "committedDate": "2021-04-23T12:46:57Z", "type": "commit"}, {"oid": "bcb8500a8c20d44143ba3bdc3a4a2eb6e4d3a462", "url": "https://github.com/MegaMek/megamek/commit/bcb8500a8c20d44143ba3bdc3a4a2eb6e4d3a462", "message": "Merge remote-tracking branch 'MM_Master/master' into GUI\n\nConflicts:\n\tmegamek/src/megamek/client/ui/swing/BotConfigDialog.java\n\tmegamek/src/megamek/client/ui/swing/ChatLounge.java", "committedDate": "2021-04-29T20:21:48Z", "type": "commit"}, {"oid": "94e0982a9d3e52800889c746207dec0bf5431329", "url": "https://github.com/MegaMek/megamek/commit/94e0982a9d3e52800889c746207dec0bf5431329", "message": "Aftermerge Constructor Correction", "committedDate": "2021-04-29T20:22:41Z", "type": "commit"}]}