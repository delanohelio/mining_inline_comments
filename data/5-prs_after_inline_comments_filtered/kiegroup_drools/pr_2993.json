{"pr_number": 2993, "pr_title": "[DROOLS-5502] DMN Generate Strongly Typed Output Set", "pr_createdAt": "2020-07-16T08:32:55Z", "pr_url": "https://github.com/kiegroup/drools/pull/2993", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYyMTkyMg==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r455621922", "bodyText": "I'll create a super class for DMNInputSetType and DMNOutputSetType to pull up methods/fields after confirming if I'm no the right track.", "author": "tkobayas", "createdAt": "2020-07-16T08:40:05Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/typesafe/DMNOutputSetType.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.typesafe;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.drools.modelcompiler.builder.generator.declaredtype.api.AnnotationDefinition;\n+import org.drools.modelcompiler.builder.generator.declaredtype.api.FieldDefinition;\n+import org.drools.modelcompiler.builder.generator.declaredtype.api.MethodDefinition;\n+import org.drools.modelcompiler.builder.generator.declaredtype.api.TypeDefinition;\n+import org.kie.dmn.api.core.DMNType;\n+import org.kie.dmn.api.core.FEELPropertyAccessible;\n+\n+class DMNOutputSetType implements TypeDefinition {", "originalCommit": "f38db886b2b8eb274eaea14bda9005d543756e94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYyNjU5OA==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r455626598", "bodyText": "Here, the actual field types are DMNDecisionServiceFunctionDefinitionEvaluator$DMNDSFunction or DMNFunctionWithReturnType. I use dmnModel.getTypeRegistry().unknown() (which results in Object type) for now but it may be an abuse of DMNType. Probably I should write another implementation of FieldDefinition to generate these fields.", "author": "tkobayas", "createdAt": "2020-07-16T08:47:36Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/typesafe/DMNTypeSafeTypeGenerator.java", "diffHunk": "@@ -97,6 +101,29 @@ public DMNTypeSafeTypeGenerator processTypes() {\n \n         types.add(inputSetType);\n \n+        Set<DecisionNode> decisions = dmnModel.getDecisions();\n+        Collection<DecisionServiceNode> decisionServices = dmnModel.getDecisionServices();\n+        Set<BusinessKnowledgeModelNode> bkms = dmnModel.getBusinessKnowledgeModels();\n+\n+        DMNOutputSetType outputSetType = new DMNOutputSetType(index, withJacksonAnnotation);\n+        for (InputDataNode i : inputs) {\n+            outputSetType.addField(i.getName(), i.getType()); // OutputSet also contains inputs\n+        }\n+        for (DecisionNode d : decisions) {\n+            outputSetType.addField(d.getName(), d.getResultType());\n+        }\n+        for (DecisionServiceNode ds : decisionServices) {\n+            outputSetType.addField(ds.getName(), dmnModel.getTypeRegistry().unknown());\n+        }\n+        for (BusinessKnowledgeModelNode bkm : bkms) {\n+            outputSetType.addField(bkm.getName(), dmnModel.getTypeRegistry().unknown());\n+        }", "originalCommit": "f38db886b2b8eb274eaea14bda9005d543756e94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTQ0Mg==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r456935442", "bodyText": "I believe it should work if you set them in such a way for those later are set hardcoded to org.kie.dmn.feel.runtime.FEELFunction in the resulting code-generated java class.\nBut it's okay for now to leave them here as FEEL : any as you are doing, the above can be an improvement for later.", "author": "tarilabs", "createdAt": "2020-07-19T17:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYyNjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAxMDk5Nw==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r457010997", "bodyText": "Thanks, filed https://issues.redhat.com/browse/DROOLS-5519", "author": "tkobayas", "createdAt": "2020-07-20T03:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYyNjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzMjc3MA==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r455632770", "bodyText": "When OutputSet.fromMap() takes DMNResult.getContext().getAll() as an argument, the context map may contain both Map based data and Typed objects (= generated by DMNTypeSafeTypeGenerator). So I enhanced the fromMap method like this. If you want keep fromMap() simple as before, I may write it as a different method (e.g. fromContextMap()). Feel free to let me know.", "author": "tkobayas", "createdAt": "2020-07-16T08:57:32Z", "path": "kie-dmn/kie-dmn-core/src/main/resources/org/kie/dmn/core/impl/DMNTypeSafeTypeTemplate.java", "diffHunk": "@@ -43,8 +43,12 @@ void fromMap(Map<String, Object> values) {\n         {\n             Object propertyValues = values.get(\"$property$\");\n             if(propertyValues != null) {\n-                $property$ = new PropertyType();\n-                $property$.fromMap((java.util.Map<String, Object>) propertyValues);\n+                if (propertyValues instanceof PropertyType) {\n+                    $property$ = (PropertyType) propertyValues;\n+                } else {\n+                    $property$ = new PropertyType();\n+                    $property$.fromMap((java.util.Map<String, Object>) propertyValues);\n+                }", "originalCommit": "f38db886b2b8eb274eaea14bda9005d543756e94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTczMTAxNg==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r455731016", "bodyText": "Yes maybe we can keep this method a little bit simpler I agree", "author": "lucamolteni", "createdAt": "2020-07-16T11:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzMjc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY0MDc1Ng==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r455640756", "bodyText": "Now we can generate OutputSet class and populate it by the map from DMNResult.getContext().getAll(). This is the goal of DROOLS-5502 (in kie-dmn-core), right? Then we will work on a KOGITO JIRA to generate REST endpoint which return type is OutputSet.", "author": "tkobayas", "createdAt": "2020-07-16T09:10:21Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/BaseVariantTest.java", "diffHunk": "@@ -222,6 +234,30 @@ private DMNResult evaluateTypeSafe(DMNRuntime runtime, DMNModel dmnModel, DMNCon\n         }\n     }\n \n+    private DMNResult evaluateDecisionServiceTypeSafe(DMNRuntime runtime, DMNModel dmnModel, DMNContext context, String decisionServiceName) {\n+        Map<String, Object> inputMap = context.getAll();\n+        FEELPropertyAccessible inputSet;\n+        try {\n+            inputSet = createInstanceFromCompiledClasses(allCompiledClasses, factory.create(dmnModel), \"InputSet\");\n+            inputSet.fromMap(inputMap);\n+            return runtime.evaluateDecisionService(dmnModel, new DMNContextFPAImpl(inputSet), decisionServiceName);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public FEELPropertyAccessible convertToOutputSet(DMNModel dmnModel, DMNResult dmnResult) {\n+        Map<String, Object> contextMap = dmnResult.getContext().getAll();\n+        FEELPropertyAccessible outputSet;\n+        try {\n+            outputSet = createInstanceFromCompiledClasses(allCompiledClasses, factory.create(dmnModel), \"OutputSet\");\n+            outputSet.fromMap(contextMap);\n+            return outputSet;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }", "originalCommit": "f38db886b2b8eb274eaea14bda9005d543756e94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMDU4NA==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r456300584", "bodyText": "@lucamolteni @tarilabs\nHey, I added an interesting test case. If we have node names where the difference is only \"First letter is capitalized or not\" (e.g. \"myPerson\" and \"MyPerson\"), it will cause a compile error for InputSet and OutputSet. Note that it works fine without typesafe.\nhttps://github.com/tkobayas/drools/blob/DROOLS-5502/kie-dmn/kie-dmn-core/src/test/resources/org/kie/dmn/core/stronglytyped/capitalLetterConflict.dmn\nfor example) Generated InputSet.java\nhttps://gist.github.com/tkobayas/bde48ea2ef76ab2f829fe0c66cd26fd2\nI think... we want to explicitly raise a build error in this case (if typesafe is enabled) even though the DMN itself is valid. Or do you have any other ideas? (hmm, adding an arbitrary suffix? but such a suffix may cause another conflict)", "author": "tkobayas", "createdAt": "2020-07-17T08:33:02Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/stronglytyped/DMNRuntimeTypesTest.java", "diffHunk": "@@ -318,6 +326,200 @@ public void testFieldCapitalization() {\n         LOG.debug(\"{}\", dmnResult);\n         assertThat(DMNRuntimeUtil.formatMessages(dmnResult.getMessages()), dmnResult.hasErrors(), is(false));\n         assertThat(dmnResult.getDecisionResultByName(\"Should the driver be suspended?\").getResult(), is(\"Yes\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            FEELPropertyAccessible driver = (FEELPropertyAccessible)allProperties.get(\"Driver\");\n+            assertThat(driver.getClass().getSimpleName(), is(\"TDriver\"));\n+            assertThat(driver.getFEELProperty(\"Name\").toOptional().get(), is(\"Luca\"));\n+            assertThat(driver.getFEELProperty(\"Age\").toOptional().get(), is(35));\n+            assertThat(driver.getFEELProperty(\"State\").toOptional().get(), is(\"Italy\"));\n+            assertThat(driver.getFEELProperty(\"City\").toOptional().get(), is(\"Milan\"));\n+            assertThat(driver.getFEELProperty(\"Points\").toOptional().get(), is(2000));\n+\n+            FEELPropertyAccessible violation = (FEELPropertyAccessible)allProperties.get(\"Violation\");\n+            assertThat(violation.getClass().getSimpleName(), is(\"TViolation\"));\n+            assertThat(violation.getFEELProperty(\"Code\").toOptional().get(), is(\"s\"));\n+            assertThat(violation.getFEELProperty(\"Date\").toOptional().get(), is(LocalDate.of(1984, 11, 6)));\n+            assertThat(violation.getFEELProperty(\"Type\").toOptional().get(), is(\"speed\"));\n+            assertThat(violation.getFEELProperty(\"Actual Speed\").toOptional().get(), is(120));\n+            assertThat(violation.getFEELProperty(\"Speed Limit\").toOptional().get(), is(100));\n+\n+            FEELPropertyAccessible fine = (FEELPropertyAccessible)allProperties.get(\"Fine\");\n+            assertThat(fine.getClass().getSimpleName(), is(\"TFine\"));\n+            assertThat(fine.getFEELProperty(\"Amount\").toOptional().get(), is(new BigDecimal(\"500\")));\n+            assertThat(fine.getFEELProperty(\"Points\").toOptional().get(), is(new BigDecimal(\"3\")));\n+\n+            Object suspended = allProperties.get(\"Should the driver be suspended?\");\n+            assertThat(suspended, instanceOf(String.class));\n+            assertThat(suspended, is(\"Yes\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testDecisionService() {\n+        final DMNRuntime runtime = createRuntime(\"DecisionServiceABC_DMN12.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"http://www.trisotech.com/dmn/definitions/_2443d3f5-f178-47c6-a0c9-b1fd1c933f60\", \"Drawing 1\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        // DecisionService only\n+        final DMNContext context = DMNFactory.newContext();\n+\n+        final DMNResult dmnResult1 = evaluateDecisionService(runtime, dmnModel, context, \"Decision Service ABC\");\n+        LOG.debug(\"{}\", dmnResult1);\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnResult1.getMessages()), dmnResult1.hasErrors(), is(false));\n+\n+        final DMNContext result = dmnResult1.getContext();\n+        assertThat(result.getAll(), not(hasEntry(is(\"Invoking Decision\"), anything()))); // we invoked only the Decision Service, not this other Decision in the model.\n+        assertThat(result.get(\"ABC\"), is(\"abc\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult1);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            assertThat(allProperties.get(\"Invoking Decision\"), nullValue());\n+            Object abc = allProperties.get(\"ABC\");\n+            assertThat(abc, instanceOf(String.class));\n+            assertThat(abc, is(\"abc\"));\n+        }\n+\n+        // evaluateAll\n+        final DMNContext context2 = DMNFactory.newContext();\n+\n+        final DMNResult dmnResult2 = runtime.evaluateAll(dmnModel, context2);\n+        LOG.debug(\"{}\", dmnResult2);\n+        dmnResult2.getDecisionResults().forEach(x -> LOG.debug(\"{}\", x));\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnResult2.getMessages()), dmnResult2.hasErrors(), is(false));\n+\n+        final DMNContext result2 = dmnResult2.getContext();\n+        assertThat(result2.get(\"ABC\"), is(\"abc\"));\n+        assertThat(result2.get(\"Invoking Decision\"), is(\"abc\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult2);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            Object decisionService = allProperties.get(\"Decision Service ABC\");\n+            assertThat(decisionService, instanceOf(FEELFunction.class));\n+            assertThat(((FEELFunction)decisionService).getName(), is(\"Decision Service ABC\"));\n+            Object invokingDecision = allProperties.get(\"Invoking Decision\");\n+            assertThat(invokingDecision, instanceOf(String.class));\n+            assertThat(invokingDecision, is(\"abc\"));\n+            Object abc = allProperties.get(\"ABC\");\n+            assertThat(abc, instanceOf(String.class));\n+            assertThat(abc, is(\"abc\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testBKM() {\n+        final DMNRuntime runtime = createRuntime(\"0009-invocation-arithmetic.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"http://www.trisotech.com/definitions/_cb28c255-91cd-4c01-ac7b-1a9cb1ecdb11\", \"literal invocation1\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        final Map<String, Object> loan = new HashMap<>();\n+        loan.put(\"amount\", BigDecimal.valueOf(600000));\n+        loan.put(\"rate\", new BigDecimal(\"0.0375\"));\n+        loan.put(\"term\", BigDecimal.valueOf(360));\n+        final DMNContext context = DMNFactory.newContext();\n+        context.set(\"fee\", 100);\n+        context.set(\"Loan\", loan);\n+\n+        final DMNResult dmnResult = runtime.evaluateAll(dmnModel, context);\n+        assertThat(dmnResult.hasErrors(), is(false));\n+        assertThat(\n+                   ((BigDecimal) dmnResult.getContext().get(\"MonthlyPayment\")).setScale(8, BigDecimal.ROUND_DOWN),\n+                   is(new BigDecimal(\"2878.69354943277\").setScale(8, BigDecimal.ROUND_DOWN)));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            Object fee = allProperties.get(\"fee\");\n+            assertThat(fee, is(100));\n+            FEELPropertyAccessible loanOut = (FEELPropertyAccessible)allProperties.get(\"Loan\");\n+            assertThat(loanOut.getClass().getSimpleName(), is(\"TLoan\"));\n+            assertThat(loanOut.getFEELProperty(\"amount\").toOptional().get(), is(BigDecimal.valueOf(600000)));\n+            assertThat(loanOut.getFEELProperty(\"rate\").toOptional().get(), is(new BigDecimal(\"0.0375\")));\n+            assertThat(loanOut.getFEELProperty(\"term\").toOptional().get(), is(BigDecimal.valueOf(360)));\n+            Object bkm = allProperties.get(\"PMT\");\n+            assertThat(bkm, instanceOf(FEELFunction.class));\n+            assertThat(((FEELFunction)bkm).getName(), is(\"PMT\"));\n+            Object monthlyPayment = allProperties.get(\"MonthlyPayment\");\n+            assertThat(((BigDecimal) monthlyPayment).setScale(8, BigDecimal.ROUND_DOWN),\n+                       is(new BigDecimal(\"2878.69354943277\").setScale(8, BigDecimal.ROUND_DOWN)));\n+        }\n     }\n-}\n \n+    @Test\n+    public void testCapitalLetterConflict() {\n+        final DMNRuntime runtime = createRuntime(\"capitalLetterConflict.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"https://kiegroup.org/dmn/_B321C9B1-856E-45DE-B05D-5B4D4D301D37\", \"capitalLetterConflict\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        final Map<String, Object> myPerson = new HashMap<>();\n+        myPerson.put(\"name\", \"John\");\n+        myPerson.put(\"age\", 28);\n+        final Map<String, Object> myPersonCapital = new HashMap<>();\n+        myPersonCapital.put(\"name\", \"Paul\");\n+        myPersonCapital.put(\"age\", 26);\n+\n+        final DMNContext context = DMNFactory.newContext();\n+        context.set(\"myPerson\", myPerson);\n+        context.set(\"MyPerson\", myPersonCapital);\n+\n+        final DMNResult dmnResult = runtime.evaluateAll(dmnModel, context);\n+        assertThat(dmnResult.hasErrors(), is(false));\n+        assertThat(dmnResult.getContext().get(\"myDecision\"), is(\"myDecision is John\"));\n+        assertThat(dmnResult.getContext().get(\"MyDecision\"), is(\"MyDecision is Paul\"));\n+", "originalCommit": "d5d2a6cdfc2cc502855217c72b1aa27a491dd289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNzMyOQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r456937329", "bodyText": "Ooh yes, this is an interesting point indeed! Thanks for spotting this!!\nThis is clearly a limitation of the DMN -> Java codegen strategy.\nThe DMN looks valid to me, and it's comforting it's executing fine with the default behaviour.\nWe should fix this problem when using strongly-typed, but I believe this is a separate issue.\nCould you raise a separate JIRA, and leave this test as Ignored/Disabled ?\nI believe whatever the strategy (for instance instead of playing with the first letter capitalization, we leave as-is, or we introduce a fixed _, or ... something else) this can be handled separately.", "author": "tarilabs", "createdAt": "2020-07-19T18:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMDU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5MDI0Mw==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r456990243", "bodyText": "Sure, filed https://issues.redhat.com/browse/DROOLS-5518", "author": "tkobayas", "createdAt": "2020-07-20T01:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMDU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTczNQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r456935735", "bodyText": "I am not sure what is the goal of this codegen method. Could you clarify, please?", "author": "tarilabs", "createdAt": "2020-07-19T17:47:42Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/typesafe/FEELPropertyAccessibleImplementation.java", "diffHunk": "@@ -186,9 +187,39 @@ private MethodDefinition fromMap() {\n         MethodWithStringBody setFeelProperty = new MethodWithStringBody(\"fromMap\", \"void\", body.toString());\n         setFeelProperty.addParameter(\"java.util.Map<String, Object>\", \"values\");\n \n+        addOverrideAnnotation(setFeelProperty);\n+\n         return setFeelProperty;\n     }\n \n+    private MethodDefinition fromContextMap() {", "originalCommit": "d5d2a6cdfc2cc502855217c72b1aa27a491dd289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAwMTk0NQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r457001945", "bodyText": "fromMap() is to convert simple Map data to a strongly typed object.\nHowever, DMNResult.getContext().getAll() may contain both simple Map data (given from DMN runtime execution) and strongly typed objects (given from InputSet).\nSo I added fromContextMap() which can convert both data to OutputSet. I was able to combine those logic in one fromMap() method but Luca preferred to keep fromMap() simple so I split to 2 methods.", "author": "tkobayas", "createdAt": "2020-07-20T02:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxMjUxNA==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r457212514", "bodyText": "Yeah I noticed, but sorry I don't concur with this additional method, for the reason it impacts the FEELPropertyAccessible interface.\nI don't think it make sense to have two methods with the same semantic signature, the user will find difficult to know when to invoke one or the other, or if implementing the pojo manually (ref scaffolding) it will find difficult to understand what's the difference between the two to implement.\nUnless I am mistaken, there are two differences.\nDifference1\nis relevant to the // Composite fields\n\nI believe is perfectly fine for this to be incorporated in the original fromMap(), that is ~saying: if I'm being passed already the target type I will assign it directly, otherwise I will create myself the target type using the fromMap().\nDifference2\nis relevant to the // Collections of composite fields\n\nI am not sure this is the modification you want.\nI believe we could leave the enhanced for loop where it was originally, can be generic on Object instead of Map<> and inside of the loop you do similarly as to what you did above for the \"Composite fields\" case.\nWdyt?\nThis way, we have only slight modifications to the original fromMap() which made sense any way, since the target object could have been used in a scaffolding approach, and we won't need an additional method in the FEELPropertyAccessible interface.", "author": "tarilabs", "createdAt": "2020-07-20T09:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUwMjczOA==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r457502738", "bodyText": "I haven't thought about affecting the fromMap() method, I thought we were creating a new private method. Any way is fine", "author": "lucamolteni", "createdAt": "2020-07-20T15:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxNTY1Nw==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r462015657", "bodyText": "Thank you for the suggestion. I removed fromContextMap() and combined to fromMap().", "author": "tkobayas", "createdAt": "2020-07-29T03:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNjYyMQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r456936621", "bodyText": "Yes, I'm not sure however there is value in testing this execution; the model, as you stated, is semantically incorrect due to the duplicate names, so I don't think we have to guarantee any behaviour here.\nCould you further elaborate on the goal of this test?", "author": "tarilabs", "createdAt": "2020-07-19T17:56:25Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/stronglytyped/DMNRuntimeTypesTest.java", "diffHunk": "@@ -318,6 +326,200 @@ public void testFieldCapitalization() {\n         LOG.debug(\"{}\", dmnResult);\n         assertThat(DMNRuntimeUtil.formatMessages(dmnResult.getMessages()), dmnResult.hasErrors(), is(false));\n         assertThat(dmnResult.getDecisionResultByName(\"Should the driver be suspended?\").getResult(), is(\"Yes\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            FEELPropertyAccessible driver = (FEELPropertyAccessible)allProperties.get(\"Driver\");\n+            assertThat(driver.getClass().getSimpleName(), is(\"TDriver\"));\n+            assertThat(driver.getFEELProperty(\"Name\").toOptional().get(), is(\"Luca\"));\n+            assertThat(driver.getFEELProperty(\"Age\").toOptional().get(), is(35));\n+            assertThat(driver.getFEELProperty(\"State\").toOptional().get(), is(\"Italy\"));\n+            assertThat(driver.getFEELProperty(\"City\").toOptional().get(), is(\"Milan\"));\n+            assertThat(driver.getFEELProperty(\"Points\").toOptional().get(), is(2000));\n+\n+            FEELPropertyAccessible violation = (FEELPropertyAccessible)allProperties.get(\"Violation\");\n+            assertThat(violation.getClass().getSimpleName(), is(\"TViolation\"));\n+            assertThat(violation.getFEELProperty(\"Code\").toOptional().get(), is(\"s\"));\n+            assertThat(violation.getFEELProperty(\"Date\").toOptional().get(), is(LocalDate.of(1984, 11, 6)));\n+            assertThat(violation.getFEELProperty(\"Type\").toOptional().get(), is(\"speed\"));\n+            assertThat(violation.getFEELProperty(\"Actual Speed\").toOptional().get(), is(120));\n+            assertThat(violation.getFEELProperty(\"Speed Limit\").toOptional().get(), is(100));\n+\n+            FEELPropertyAccessible fine = (FEELPropertyAccessible)allProperties.get(\"Fine\");\n+            assertThat(fine.getClass().getSimpleName(), is(\"TFine\"));\n+            assertThat(fine.getFEELProperty(\"Amount\").toOptional().get(), is(new BigDecimal(\"500\")));\n+            assertThat(fine.getFEELProperty(\"Points\").toOptional().get(), is(new BigDecimal(\"3\")));\n+\n+            Object suspended = allProperties.get(\"Should the driver be suspended?\");\n+            assertThat(suspended, instanceOf(String.class));\n+            assertThat(suspended, is(\"Yes\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testDecisionService() {\n+        final DMNRuntime runtime = createRuntime(\"DecisionServiceABC_DMN12.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"http://www.trisotech.com/dmn/definitions/_2443d3f5-f178-47c6-a0c9-b1fd1c933f60\", \"Drawing 1\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        // DecisionService only\n+        final DMNContext context = DMNFactory.newContext();\n+\n+        final DMNResult dmnResult1 = evaluateDecisionService(runtime, dmnModel, context, \"Decision Service ABC\");\n+        LOG.debug(\"{}\", dmnResult1);\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnResult1.getMessages()), dmnResult1.hasErrors(), is(false));\n+\n+        final DMNContext result = dmnResult1.getContext();\n+        assertThat(result.getAll(), not(hasEntry(is(\"Invoking Decision\"), anything()))); // we invoked only the Decision Service, not this other Decision in the model.\n+        assertThat(result.get(\"ABC\"), is(\"abc\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult1);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            assertThat(allProperties.get(\"Invoking Decision\"), nullValue());\n+            Object abc = allProperties.get(\"ABC\");\n+            assertThat(abc, instanceOf(String.class));\n+            assertThat(abc, is(\"abc\"));\n+        }\n+\n+        // evaluateAll\n+        final DMNContext context2 = DMNFactory.newContext();\n+\n+        final DMNResult dmnResult2 = runtime.evaluateAll(dmnModel, context2);\n+        LOG.debug(\"{}\", dmnResult2);\n+        dmnResult2.getDecisionResults().forEach(x -> LOG.debug(\"{}\", x));\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnResult2.getMessages()), dmnResult2.hasErrors(), is(false));\n+\n+        final DMNContext result2 = dmnResult2.getContext();\n+        assertThat(result2.get(\"ABC\"), is(\"abc\"));\n+        assertThat(result2.get(\"Invoking Decision\"), is(\"abc\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult2);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            Object decisionService = allProperties.get(\"Decision Service ABC\");\n+            assertThat(decisionService, instanceOf(FEELFunction.class));\n+            assertThat(((FEELFunction)decisionService).getName(), is(\"Decision Service ABC\"));\n+            Object invokingDecision = allProperties.get(\"Invoking Decision\");\n+            assertThat(invokingDecision, instanceOf(String.class));\n+            assertThat(invokingDecision, is(\"abc\"));\n+            Object abc = allProperties.get(\"ABC\");\n+            assertThat(abc, instanceOf(String.class));\n+            assertThat(abc, is(\"abc\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testBKM() {\n+        final DMNRuntime runtime = createRuntime(\"0009-invocation-arithmetic.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"http://www.trisotech.com/definitions/_cb28c255-91cd-4c01-ac7b-1a9cb1ecdb11\", \"literal invocation1\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        final Map<String, Object> loan = new HashMap<>();\n+        loan.put(\"amount\", BigDecimal.valueOf(600000));\n+        loan.put(\"rate\", new BigDecimal(\"0.0375\"));\n+        loan.put(\"term\", BigDecimal.valueOf(360));\n+        final DMNContext context = DMNFactory.newContext();\n+        context.set(\"fee\", 100);\n+        context.set(\"Loan\", loan);\n+\n+        final DMNResult dmnResult = runtime.evaluateAll(dmnModel, context);\n+        assertThat(dmnResult.hasErrors(), is(false));\n+        assertThat(\n+                   ((BigDecimal) dmnResult.getContext().get(\"MonthlyPayment\")).setScale(8, BigDecimal.ROUND_DOWN),\n+                   is(new BigDecimal(\"2878.69354943277\").setScale(8, BigDecimal.ROUND_DOWN)));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            Object fee = allProperties.get(\"fee\");\n+            assertThat(fee, is(100));\n+            FEELPropertyAccessible loanOut = (FEELPropertyAccessible)allProperties.get(\"Loan\");\n+            assertThat(loanOut.getClass().getSimpleName(), is(\"TLoan\"));\n+            assertThat(loanOut.getFEELProperty(\"amount\").toOptional().get(), is(BigDecimal.valueOf(600000)));\n+            assertThat(loanOut.getFEELProperty(\"rate\").toOptional().get(), is(new BigDecimal(\"0.0375\")));\n+            assertThat(loanOut.getFEELProperty(\"term\").toOptional().get(), is(BigDecimal.valueOf(360)));\n+            Object bkm = allProperties.get(\"PMT\");\n+            assertThat(bkm, instanceOf(FEELFunction.class));\n+            assertThat(((FEELFunction)bkm).getName(), is(\"PMT\"));\n+            Object monthlyPayment = allProperties.get(\"MonthlyPayment\");\n+            assertThat(((BigDecimal) monthlyPayment).setScale(8, BigDecimal.ROUND_DOWN),\n+                       is(new BigDecimal(\"2878.69354943277\").setScale(8, BigDecimal.ROUND_DOWN)));\n+        }\n     }\n-}\n \n+    @Test\n+    public void testCapitalLetterConflict() {\n+        final DMNRuntime runtime = createRuntime(\"capitalLetterConflict.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"https://kiegroup.org/dmn/_B321C9B1-856E-45DE-B05D-5B4D4D301D37\", \"capitalLetterConflict\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        final Map<String, Object> myPerson = new HashMap<>();\n+        myPerson.put(\"name\", \"John\");\n+        myPerson.put(\"age\", 28);\n+        final Map<String, Object> myPersonCapital = new HashMap<>();\n+        myPersonCapital.put(\"name\", \"Paul\");\n+        myPersonCapital.put(\"age\", 26);\n+\n+        final DMNContext context = DMNFactory.newContext();\n+        context.set(\"myPerson\", myPerson);\n+        context.set(\"MyPerson\", myPersonCapital);\n+\n+        final DMNResult dmnResult = runtime.evaluateAll(dmnModel, context);\n+        assertThat(dmnResult.hasErrors(), is(false));\n+        assertThat(dmnResult.getContext().get(\"myDecision\"), is(\"myDecision is John\"));\n+        assertThat(dmnResult.getContext().get(\"MyDecision\"), is(\"MyDecision is Paul\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            FEELPropertyAccessible myPersonOut = (FEELPropertyAccessible) allProperties.get(\"myPerson\");\n+            assertThat(myPersonOut.getClass().getSimpleName(), is(\"TPerson\"));\n+            assertThat(myPersonOut.getFEELProperty(\"name\").toOptional().get(), is(\"John\"));\n+            assertThat(myPersonOut.getFEELProperty(\"age\").toOptional().get(), is(28));\n+            FEELPropertyAccessible myPersonCapitalOut = (FEELPropertyAccessible) allProperties.get(\"MyPerson\");\n+            assertThat(myPersonCapitalOut.getClass().getSimpleName(), is(\"TPerson\"));\n+            assertThat(myPersonCapitalOut.getFEELProperty(\"name\").toOptional().get(), is(\"Paul\"));\n+            assertThat(myPersonCapitalOut.getFEELProperty(\"age\").toOptional().get(), is(26));\n+            Object myDecision = (String) allProperties.get(\"myDecision\");\n+            assertThat(myDecision, is(\"myDecision is John\"));\n+            Object myDecisionCapital = (String) allProperties.get(\"MyDecision\");\n+            assertThat(myDecisionCapital, is(\"MyDecision is Paul\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testDuplicateName() {\n+        // Note: DMNValidator raises errors for duplicate names\n+        final DMNRuntime runtime = createRuntime(\"duplicateName.dmn\", this.getClass());", "originalCommit": "d5d2a6cdfc2cc502855217c72b1aa27a491dd289", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5Nzc5OQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r456997799", "bodyText": "Thanks, yeah, I didn't need to have this test. Removing :)", "author": "tkobayas", "createdAt": "2020-07-20T02:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNjYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExODcwOQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r457118709", "bodyText": "not sure about this, as the role of this method IIRC is to suggest the Class to be used in the destination Java code generated. The engine will not support a generic temporal for a time, but it does support LocalTime. So I believe it was correct before.", "author": "tarilabs", "createdAt": "2020-07-20T07:11:29Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/typesafe/DMNAllTypesIndex.java", "diffHunk": "@@ -107,9 +110,9 @@ private String convertBuiltin(DMNType expectedFEELType) {\n             case DATE:\n                 return LocalDate.class;\n             case TIME:\n-                return LocalTime.class;\n+                return Temporal.class;", "originalCommit": "b3ad4d50d31f5c2a81643e07b867cf30554cd664", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ5NDkyMQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r463494921", "bodyText": "@tkobayas could you take a look on this comment, please?", "author": "hellowdan", "createdAt": "2020-07-31T09:06:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExODcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExODgzOA==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r457118838", "bodyText": "as above", "author": "tarilabs", "createdAt": "2020-07-20T07:11:41Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/typesafe/DMNAllTypesIndex.java", "diffHunk": "@@ -107,9 +110,9 @@ private String convertBuiltin(DMNType expectedFEELType) {\n             case DATE:\n                 return LocalDate.class;\n             case TIME:\n-                return LocalTime.class;\n+                return Temporal.class;\n             case DATE_TIME:\n-                return LocalDateTime.class;\n+                return Temporal.class;", "originalCommit": "b3ad4d50d31f5c2a81643e07b867cf30554cd664", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExODkxOQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r457118919", "bodyText": "as above", "author": "tarilabs", "createdAt": "2020-07-20T07:11:47Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/typesafe/DMNAllTypesIndex.java", "diffHunk": "@@ -126,10 +129,10 @@ private String convertBuiltin(DMNType expectedFEELType) {\n         switch (expectedFEELType.getName()) {\n             case SimpleType.YEARS_AND_MONTHS_DURATION:\n             case \"yearMonthDuration\":\n-                return Period.class;\n+                return ChronoPeriod.class;", "originalCommit": "b3ad4d50d31f5c2a81643e07b867cf30554cd664", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExODk3MQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r457118971", "bodyText": "as above", "author": "tarilabs", "createdAt": "2020-07-20T07:11:53Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/typesafe/DMNAllTypesIndex.java", "diffHunk": "@@ -126,10 +129,10 @@ private String convertBuiltin(DMNType expectedFEELType) {\n         switch (expectedFEELType.getName()) {\n             case SimpleType.YEARS_AND_MONTHS_DURATION:\n             case \"yearMonthDuration\":\n-                return Period.class;\n+                return ChronoPeriod.class;\n             case SimpleType.DAYS_AND_TIME_DURATION:\n             case \"dayTimeDuration\":\n-                return Duration.class;\n+                return TemporalAmount.class;", "originalCommit": "b3ad4d50d31f5c2a81643e07b867cf30554cd664", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxODE0MQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r462018141", "bodyText": "While adding test variations, I found that itemDefinition with isCollection=\"true\" is not properly handled (itemComponent with isCollection=\"true\" works fine). I filed another JIRA and set @Ignore at the moment.\nhttps://issues.redhat.com/browse/DROOLS-5538", "author": "tkobayas", "createdAt": "2020-07-29T03:36:11Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/stronglytyped/DMNRuntimeTypesTest.java", "diffHunk": "@@ -318,6 +406,358 @@ public void testFieldCapitalization() {\n         LOG.debug(\"{}\", dmnResult);\n         assertThat(DMNRuntimeUtil.formatMessages(dmnResult.getMessages()), dmnResult.hasErrors(), is(false));\n         assertThat(dmnResult.getDecisionResultByName(\"Should the driver be suspended?\").getResult(), is(\"Yes\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            FEELPropertyAccessible driver = (FEELPropertyAccessible)allProperties.get(\"Driver\");\n+            assertThat(driver.getClass().getSimpleName(), is(\"TDriver\"));\n+            assertThat(driver.getFEELProperty(\"Name\").toOptional().get(), is(\"Luca\"));\n+            assertThat(driver.getFEELProperty(\"Age\").toOptional().get(), is(35));\n+            assertThat(driver.getFEELProperty(\"State\").toOptional().get(), is(\"Italy\"));\n+            assertThat(driver.getFEELProperty(\"City\").toOptional().get(), is(\"Milan\"));\n+            assertThat(driver.getFEELProperty(\"Points\").toOptional().get(), is(2000));\n+\n+            FEELPropertyAccessible violation = (FEELPropertyAccessible)allProperties.get(\"Violation\");\n+            assertThat(violation.getClass().getSimpleName(), is(\"TViolation\"));\n+            assertThat(violation.getFEELProperty(\"Code\").toOptional().get(), is(\"s\"));\n+            assertThat(violation.getFEELProperty(\"Date\").toOptional().get(), is(LocalDate.of(1984, 11, 6)));\n+            assertThat(violation.getFEELProperty(\"Type\").toOptional().get(), is(\"speed\"));\n+            assertThat(violation.getFEELProperty(\"Actual Speed\").toOptional().get(), is(120));\n+            assertThat(violation.getFEELProperty(\"Speed Limit\").toOptional().get(), is(100));\n+\n+            FEELPropertyAccessible fine = (FEELPropertyAccessible)allProperties.get(\"Fine\");\n+            assertThat(fine.getClass().getSimpleName(), is(\"TFine\"));\n+            assertThat(fine.getFEELProperty(\"Amount\").toOptional().get(), is(new BigDecimal(\"500\")));\n+            assertThat(fine.getFEELProperty(\"Points\").toOptional().get(), is(new BigDecimal(\"3\")));\n+\n+            Object suspended = allProperties.get(\"Should the driver be suspended?\");\n+            assertThat(suspended, instanceOf(String.class));\n+            assertThat(suspended, is(\"Yes\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testDecisionService() {\n+        final DMNRuntime runtime = createRuntime(\"DecisionServiceABC_DMN12.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"http://www.trisotech.com/dmn/definitions/_2443d3f5-f178-47c6-a0c9-b1fd1c933f60\", \"Drawing 1\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        // DecisionService only\n+        final DMNContext context = DMNFactory.newContext();\n+\n+        final DMNResult dmnResult1 = evaluateDecisionService(runtime, dmnModel, context, \"Decision Service ABC\");\n+        LOG.debug(\"{}\", dmnResult1);\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnResult1.getMessages()), dmnResult1.hasErrors(), is(false));\n+\n+        final DMNContext result = dmnResult1.getContext();\n+        assertThat(result.getAll(), not(hasEntry(is(\"Invoking Decision\"), anything()))); // we invoked only the Decision Service, not this other Decision in the model.\n+        assertThat(result.get(\"ABC\"), is(\"abc\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult1);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            assertThat(allProperties.get(\"Invoking Decision\"), nullValue());\n+            Object abc = allProperties.get(\"ABC\");\n+            assertThat(abc, instanceOf(String.class));\n+            assertThat(abc, is(\"abc\"));\n+        }\n+\n+        // evaluateAll\n+        final DMNContext context2 = DMNFactory.newContext();\n+\n+        final DMNResult dmnResult2 = runtime.evaluateAll(dmnModel, context2);\n+        LOG.debug(\"{}\", dmnResult2);\n+        dmnResult2.getDecisionResults().forEach(x -> LOG.debug(\"{}\", x));\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnResult2.getMessages()), dmnResult2.hasErrors(), is(false));\n+\n+        final DMNContext result2 = dmnResult2.getContext();\n+        assertThat(result2.get(\"ABC\"), is(\"abc\"));\n+        assertThat(result2.get(\"Invoking Decision\"), is(\"abc\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult2);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            Object decisionService = allProperties.get(\"Decision Service ABC\");\n+            assertThat(decisionService, instanceOf(FEELFunction.class));\n+            assertThat(((FEELFunction)decisionService).getName(), is(\"Decision Service ABC\"));\n+            Object invokingDecision = allProperties.get(\"Invoking Decision\");\n+            assertThat(invokingDecision, instanceOf(String.class));\n+            assertThat(invokingDecision, is(\"abc\"));\n+            Object abc = allProperties.get(\"ABC\");\n+            assertThat(abc, instanceOf(String.class));\n+            assertThat(abc, is(\"abc\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testBKM() {\n+        final DMNRuntime runtime = createRuntime(\"0009-invocation-arithmetic.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"http://www.trisotech.com/definitions/_cb28c255-91cd-4c01-ac7b-1a9cb1ecdb11\", \"literal invocation1\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        final Map<String, Object> loan = new HashMap<>();\n+        loan.put(\"amount\", BigDecimal.valueOf(600000));\n+        loan.put(\"rate\", new BigDecimal(\"0.0375\"));\n+        loan.put(\"term\", BigDecimal.valueOf(360));\n+        final DMNContext context = DMNFactory.newContext();\n+        context.set(\"fee\", 100);\n+        context.set(\"Loan\", loan);\n+\n+        final DMNResult dmnResult = evaluateModel(runtime, dmnModel, context);\n+        assertThat(dmnResult.hasErrors(), is(false));\n+        assertThat(\n+                   ((BigDecimal) dmnResult.getContext().get(\"MonthlyPayment\")).setScale(8, BigDecimal.ROUND_DOWN),\n+                   is(new BigDecimal(\"2878.69354943277\").setScale(8, BigDecimal.ROUND_DOWN)));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            Object fee = allProperties.get(\"fee\");\n+            assertThat(fee, is(100));\n+            FEELPropertyAccessible loanOut = (FEELPropertyAccessible)allProperties.get(\"Loan\");\n+            assertThat(loanOut.getClass().getSimpleName(), is(\"TLoan\"));\n+            assertThat(loanOut.getFEELProperty(\"amount\").toOptional().get(), is(BigDecimal.valueOf(600000)));\n+            assertThat(loanOut.getFEELProperty(\"rate\").toOptional().get(), is(new BigDecimal(\"0.0375\")));\n+            assertThat(loanOut.getFEELProperty(\"term\").toOptional().get(), is(BigDecimal.valueOf(360)));\n+            Object bkm = allProperties.get(\"PMT\");\n+            assertThat(bkm, instanceOf(FEELFunction.class));\n+            assertThat(((FEELFunction)bkm).getName(), is(\"PMT\"));\n+            Object monthlyPayment = allProperties.get(\"MonthlyPayment\");\n+            assertThat(((BigDecimal) monthlyPayment).setScale(8, BigDecimal.ROUND_DOWN),\n+                       is(new BigDecimal(\"2878.69354943277\").setScale(8, BigDecimal.ROUND_DOWN)));\n+        }\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testCapitalLetterConflict() {\n+        // To be fixed by DROOLS-5518\n+        final DMNRuntime runtime = createRuntime(\"capitalLetterConflict.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"https://kiegroup.org/dmn/_B321C9B1-856E-45DE-B05D-5B4D4D301D37\", \"capitalLetterConflict\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        final Map<String, Object> myPerson = new HashMap<>();\n+        myPerson.put(\"name\", \"John\");\n+        myPerson.put(\"age\", 28);\n+        final Map<String, Object> myPersonCapital = new HashMap<>();\n+        myPersonCapital.put(\"name\", \"Paul\");\n+        myPersonCapital.put(\"age\", 26);\n+\n+        final DMNContext context = DMNFactory.newContext();\n+        context.set(\"myPerson\", myPerson);\n+        context.set(\"MyPerson\", myPersonCapital);\n+\n+        final DMNResult dmnResult = evaluateModel(runtime, dmnModel, context);\n+        assertThat(dmnResult.hasErrors(), is(false));\n+        assertThat(dmnResult.getContext().get(\"myDecision\"), is(\"myDecision is John\"));\n+        assertThat(dmnResult.getContext().get(\"MyDecision\"), is(\"MyDecision is Paul\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            FEELPropertyAccessible myPersonOut = (FEELPropertyAccessible) allProperties.get(\"myPerson\");\n+            assertThat(myPersonOut.getClass().getSimpleName(), is(\"TPerson\"));\n+            assertThat(myPersonOut.getFEELProperty(\"name\").toOptional().get(), is(\"John\"));\n+            assertThat(myPersonOut.getFEELProperty(\"age\").toOptional().get(), is(28));\n+            FEELPropertyAccessible myPersonCapitalOut = (FEELPropertyAccessible) allProperties.get(\"MyPerson\");\n+            assertThat(myPersonCapitalOut.getClass().getSimpleName(), is(\"TPerson\"));\n+            assertThat(myPersonCapitalOut.getFEELProperty(\"name\").toOptional().get(), is(\"Paul\"));\n+            assertThat(myPersonCapitalOut.getFEELProperty(\"age\").toOptional().get(), is(26));\n+            Object myDecision = (String) allProperties.get(\"myDecision\");\n+            assertThat(myDecision, is(\"myDecision is John\"));\n+            Object myDecisionCapital = (String) allProperties.get(\"MyDecision\");\n+            assertThat(myDecisionCapital, is(\"MyDecision is Paul\"));\n+        }\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testCapitalLetterConflictWithInputAndDecision() {\n+        // To be fixed by DROOLS-5518\n+        final DMNRuntime runtime = createRuntime(\"capitalLetterConflictWithInputAndDecision.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"https://kiegroup.org/dmn/_EE9DAFC0-D50D-4D23-8676-FF8A40E02919\", \"capitalLetterConflictWithInputAndDecision\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        final Map<String, Object> person = new HashMap<>();\n+        person.put(\"name\", \"John\");\n+        person.put(\"age\", 28);\n+\n+        final DMNContext context = DMNFactory.newContext();\n+        context.set(\"myNode\", person);\n+\n+        final DMNResult dmnResult = evaluateModel(runtime, dmnModel, context);\n+        assertThat(dmnResult.hasErrors(), is(false));\n+        assertThat(dmnResult.getContext().get(\"MyNode\"), is(\"MyNode is John\"));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            FEELPropertyAccessible myPersonOut = (FEELPropertyAccessible) allProperties.get(\"myNode\");\n+            assertThat(myPersonOut.getClass().getSimpleName(), is(\"TPerson\"));\n+            assertThat(myPersonOut.getFEELProperty(\"name\").toOptional().get(), is(\"John\"));\n+            assertThat(myPersonOut.getFEELProperty(\"age\").toOptional().get(), is(28));\n+            Object myDecision = (String) allProperties.get(\"MyNode\");\n+            assertThat(myDecision, is(\"MyNode is John\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testShareTypeForInputAndOutput() {\n+        final DMNRuntime runtime = createRuntime(\"shareTypeForInputAndOutput.dmn\", this.getClass());\n+        final DMNModel dmnModel = runtime.getModel(\"https://kiegroup.org/dmn/_DBEFBA7B-C568-4631-A89E-AA31F7C6564B\", \"shareTypeForInputAndOutput\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        final Map<String, Object> person = new HashMap<>();\n+        person.put(\"name\", \"John\");\n+        person.put(\"age\", 28);\n+        person.put(\"employmentPeriod\", Period.of(1, 2, 1));\n+\n+        final DMNContext context = DMNFactory.newContext();\n+        context.set(\"inputPerson\", person);\n+\n+        final DMNResult dmnResult = evaluateModel(runtime, dmnModel, context);\n+        assertThat(dmnResult.hasErrors(), is(false));\n+\n+        Map<String, Object> outputPerson = (Map<String, Object>) dmnResult.getContext().get(\"outputPerson\");\n+        assertThat(outputPerson.get(\"name\"), is(\"Paul\"));\n+        assertThat(outputPerson.get(\"age\"), is(new BigDecimal(20)));\n+        assertThat(outputPerson.get(\"employmentPeriod\"), is(ComparablePeriod.of(1, 3, 1)));\n+\n+        if (isTypeSafe()) {\n+            FEELPropertyAccessible outputSet = convertToOutputSet(dmnModel, dmnResult);\n+            Map<String, Object> allProperties = outputSet.allFEELProperties();\n+            FEELPropertyAccessible myPersonOut = (FEELPropertyAccessible) allProperties.get(\"outputPerson\");\n+            assertThat(myPersonOut.getClass().getSimpleName(), is(\"TPerson\"));\n+            assertThat(myPersonOut.getFEELProperty(\"name\").toOptional().get(), is(\"Paul\"));\n+            assertThat(myPersonOut.getFEELProperty(\"age\").toOptional().get(), is(new BigDecimal(20)));\n+            assertThat(myPersonOut.getFEELProperty(\"employmentPeriod\").toOptional().get(), is(ComparablePeriod.of(1, 3, 1)));\n+        }\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testCollectionType() {\n+        // To be fixed by DROOLS-5538\n+        final DMNRuntime runtime = createRuntime(\"PersonListHelloBKM2.dmn\", this.getClass());", "originalCommit": "613f6fecc089d1b3e8751ff33703f83a7a198922", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUwMDg2NQ==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r463500865", "bodyText": "Just asking: wouldn't it be better to have separate tests for TypeSafe variations?", "author": "hellowdan", "createdAt": "2020-07-31T09:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxODE0MQ=="}], "type": "inlineReview"}, {"oid": "614da4d9af69ae3480307065b8194def87ed00e4", "url": "https://github.com/kiegroup/drools/commit/614da4d9af69ae3480307065b8194def87ed00e4", "message": "[DROOLS-5502] DMN Generate Strongly Typed Output Set\n- rebased", "committedDate": "2020-07-30T01:41:48Z", "type": "commit"}, {"oid": "614da4d9af69ae3480307065b8194def87ed00e4", "url": "https://github.com/kiegroup/drools/commit/614da4d9af69ae3480307065b8194def87ed00e4", "message": "[DROOLS-5502] DMN Generate Strongly Typed Output Set\n- rebased", "committedDate": "2020-07-30T01:41:48Z", "type": "forcePushed"}, {"oid": "16f72705e4929c4ce19cd7b647c0957351606dfb", "url": "https://github.com/kiegroup/drools/commit/16f72705e4929c4ce19cd7b647c0957351606dfb", "message": "- Generate javadoc with DMNType", "committedDate": "2020-07-30T06:19:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1Mzg5Mw==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r463453893", "bodyText": "this is awesome, thanks @tkobayas !\nJust a side note however, let's limit Javadoc assertions at this model for now, the reason is, I believe this Javadoc format will change to make it more \"business friendly\", so I would like to avoid having to update later too many assertions! \ud83d\ude06\nAlso, I believe we can use Eclipse MP annotation now so they will indeed properly reflect in the generated swagger/OpenApi", "author": "tarilabs", "createdAt": "2020-07-31T07:38:44Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/stronglytyped/JavadocTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.stronglytyped;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.FieldDeclaration;\n+import com.github.javaparser.ast.comments.JavadocComment;\n+import org.junit.Test;\n+import org.junit.runners.Parameterized;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.dmn.core.BaseVariantTest;\n+import org.kie.dmn.core.util.DMNRuntimeUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.dmn.core.BaseVariantTest.VariantTestConf.BUILDER_DEFAULT_NOCL_TYPECHECK_TYPESAFE;\n+import static org.kie.dmn.core.BaseVariantTest.VariantTestConf.KIE_API_TYPECHECK_TYPESAFE;\n+\n+public class JavadocTest extends BaseVariantTest {\n+\n+    public static final Logger LOG = LoggerFactory.getLogger(JavadocTest.class);\n+\n+    public JavadocTest(VariantTestConf testConfig) {\n+        super(testConfig);\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Object[] params() {\n+        return new Object[]{BUILDER_DEFAULT_NOCL_TYPECHECK_TYPESAFE, KIE_API_TYPECHECK_TYPESAFE};\n+    }\n+\n+    @Test\n+    public void testDateAndTime() throws Exception {\n+        final DMNRuntime runtime = createRuntime(\"0007-date-time.dmn\", getClass());\n+        runtime.addListener(DMNRuntimeUtil.createListener());\n+\n+        final DMNModel dmnModel = runtime.getModel(\"http://www.trisotech.com/definitions/_69430b3e-17b8-430d-b760-c505bf6469f9\", \"dateTime Table 58\");\n+        assertThat(dmnModel, notNullValue());\n+        assertThat(DMNRuntimeUtil.formatMessages(dmnModel.getMessages()), dmnModel.hasErrors(), is(false));\n+\n+        // Typesafe only test\n+        Map<String, String> sourceMap = new HashMap<>();\n+        allSources.forEach((k, v) -> sourceMap.put(k.substring(k.lastIndexOf(\".\") + 1), v));\n+\n+        String inputSet = sourceMap.get(\"InputSet\");\n+        CompilationUnit cu = StaticJavaParser.parse(inputSet);\n+        assertJavadoc(cu, \"dateTimeString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"timezone\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"oneHour\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : days and time duration }\");\n+        assertJavadoc(cu, \"month\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"year\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"hours\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"timeString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"dateString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"seconds\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"day\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"minutes\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"durationString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+\n+        String outputSet = sourceMap.get(\"OutputSet\");\n+        cu = StaticJavaParser.parse(outputSet);\n+        assertJavadoc(cu, \"timezone\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"date_45Time\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : date and time }\");\n+        assertJavadoc(cu, \"hours\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"time\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : time }\");\n+        assertJavadoc(cu, \"minutes\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"date_45Time2\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : date and time }\");\n+        assertJavadoc(cu, \"years\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"dateTimeString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"oneHour\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : days and time duration }\");\n+        assertJavadoc(cu, \"d1seconds\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"month\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"cDay\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"sumDurations\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : days and time duration }\");\n+        assertJavadoc(cu, \"cYear\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"cSecond\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"dateString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"cTimezone\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"durationString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"cHour\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"year\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"time2\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : time }\");\n+        assertJavadoc(cu, \"timeString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : string }\");\n+        assertJavadoc(cu, \"time3\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : time }\");\n+        assertJavadoc(cu, \"hoursInDuration\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"dtDuration1\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : days and time duration }\");\n+        assertJavadoc(cu, \"seconds\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"dtDuration2\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : days and time duration }\");\n+        assertJavadoc(cu, \"day\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"cMonth\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"cMinute\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"ymDuration2\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : days and time duration }\");\n+\n+        String tDateVariants = sourceMap.get(\"TDateVariants\");\n+        cu = StaticJavaParser.parse(tDateVariants);\n+        assertJavadoc(cu, \"fromString\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : date }\");\n+        assertJavadoc(cu, \"fromDateTime\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : date }\");\n+        assertJavadoc(cu, \"fromYearMonthDay\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : date }\");\n+\n+        String tDateTimeComponents = sourceMap.get(\"TDateTimeComponents\");\n+        cu = StaticJavaParser.parse(tDateTimeComponents);\n+        assertJavadoc(cu, \"year\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"month\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"day\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"hour\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"minute\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");\n+        assertJavadoc(cu, \"second\", \"DMNType{ http://www.omg.org/spec/FEEL/20140401 : number }\");", "originalCommit": "16f72705e4929c4ce19cd7b647c0957351606dfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3NDg5OA==", "url": "https://github.com/kiegroup/drools/pull/2993#discussion_r463474898", "bodyText": "Sure, I'll keep in mind :)", "author": "tkobayas", "createdAt": "2020-07-31T08:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ1Mzg5Mw=="}], "type": "inlineReview"}]}