{"pr_number": 2948, "pr_title": "Drools 5372 - Implement PMML coexistence", "pr_createdAt": "2020-06-15T15:53:29Z", "pr_url": "https://github.com/kiegroup/drools/pull/2948", "timeline": [{"oid": "0310b667ce6c8f6cc92720c750d9d61558494338", "url": "https://github.com/kiegroup/drools/commit/0310b667ce6c8f6cc92720c750d9d61558494338", "message": "[Drools-5373] Refactored PMMLAssembler - implemented two delegates PMMLCompilerService and PMMLLoaderService", "committedDate": "2020-06-04T10:24:17Z", "type": "commit"}, {"oid": "6d3ac318ed0ac6edce90a020807c85146675c5cf", "url": "https://github.com/kiegroup/drools/commit/6d3ac318ed0ac6edce90a020807c85146675c5cf", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-5372", "committedDate": "2020-06-05T10:06:24Z", "type": "commit"}, {"oid": "2badfe14a34ed998f036b866cf8a94b3ad2efe42", "url": "https://github.com/kiegroup/drools/commit/2badfe14a34ed998f036b866cf8a94b3ad2efe42", "message": "[DROOLS-5372] Implement dynamic ResourceType switch inside PMMLAssemblerService(s)", "committedDate": "2020-06-05T11:42:15Z", "type": "commit"}, {"oid": "7eab522b04d70abe69e173f9acf834ea13d24cdd", "url": "https://github.com/kiegroup/drools/commit/7eab522b04d70abe69e173f9acf834ea13d24cdd", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-5372", "committedDate": "2020-06-05T11:43:25Z", "type": "commit"}, {"oid": "0d3f2e54864708e535bcd3f317323acca93c14b9", "url": "https://github.com/kiegroup/drools/commit/0d3f2e54864708e535bcd3f317323acca93c14b9", "message": "[DROOLS-5372] Using PMMLConstants for system property retrieval/setting", "committedDate": "2020-06-05T13:08:37Z", "type": "commit"}, {"oid": "7ea3d3c2399c6eb18b9f914d63cc0ec48a2974a0", "url": "https://github.com/kiegroup/drools/commit/7ea3d3c2399c6eb18b9f914d63cc0ec48a2974a0", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-5372", "committedDate": "2020-06-08T08:54:50Z", "type": "commit"}, {"oid": "a5676276eeaa963be72a67a71d7a1911469a9899", "url": "https://github.com/kiegroup/drools/commit/a5676276eeaa963be72a67a71d7a1911469a9899", "message": "[DROOLS-5372] Implementing  AbstractDMNKiePMMLInvocationEvaluator and DMNKiePMMLNewInvocationEvaluator. Refactored DMNKiePMMLInvocationEvaluator. Implement switch between them inside AbstractPMMLInvocationEvaluator", "committedDate": "2020-06-08T11:07:36Z", "type": "commit"}, {"oid": "a74915ee8ccdb0ae9b5f17fa488b8234e60c12d3", "url": "https://github.com/kiegroup/drools/commit/a74915ee8ccdb0ae9b5f17fa488b8234e60c12d3", "message": "[DROOLS-5372] Fixing bug with nested node containing only a True predicate. Add test", "committedDate": "2020-06-08T16:07:11Z", "type": "commit"}, {"oid": "9a0beb8528e5f0ae06c26e3cc9ed8cdf79435918", "url": "https://github.com/kiegroup/drools/commit/9a0beb8528e5f0ae06c26e3cc9ed8cdf79435918", "message": "[DROOLS-5372] Working on DMN-PMML implementation", "committedDate": "2020-06-09T14:55:58Z", "type": "commit"}, {"oid": "f14623a16993cf0f3b887a976faebbcfe7791c67", "url": "https://github.com/kiegroup/drools/commit/f14623a16993cf0f3b887a976faebbcfe7791c67", "message": "[DROOLS-5423] Declaring glassfish jaxb-runtime dependency for JDK >= 11 to maintain compiler functionality in such environments", "committedDate": "2020-06-10T10:19:42Z", "type": "commit"}, {"oid": "848624b1a9ba09597b50c2002df702c507421bde", "url": "https://github.com/kiegroup/drools/commit/848624b1a9ba09597b50c2002df702c507421bde", "message": "[DROOLS-5372] Add specific message for missing PMML result. Working on tests (currently broken when run together)", "committedDate": "2020-06-11T07:27:14Z", "type": "commit"}, {"oid": "aeb07adcb468e27eff2c087ed61e8d657360772a", "url": "https://github.com/kiegroup/drools/commit/aeb07adcb468e27eff2c087ed61e8d657360772a", "message": "Merge branch 'master' into DROOLS-5372", "committedDate": "2020-06-11T07:32:38Z", "type": "commit"}, {"oid": "628aee3515caf031794523f89222ebef64c9bc0a", "url": "https://github.com/kiegroup/drools/commit/628aee3515caf031794523f89222ebef64c9bc0a", "message": "[DROOLS-5258] Working with tests. Currently broken if DMNTreePMMLTest and DMNTreePMMLNewImplTest run concurrently.\nLOT of System.out.println to remove", "committedDate": "2020-06-11T15:38:13Z", "type": "commit"}, {"oid": "4f6240cf6317fdee876a085f5eb17fbfe347abe2", "url": "https://github.com/kiegroup/drools/commit/4f6240cf6317fdee876a085f5eb17fbfe347abe2", "message": "[DROOLS-5372] Working with tests. Currently broken if DMNTreePMMLTest and DMNTreePMMLNewImplTest run concurrently.\nLOT of System.out.println to remove", "committedDate": "2020-06-11T15:38:59Z", "type": "commit"}, {"oid": "9d4e925f944f3b3485ad71e8e21c66f53c1e8fed", "url": "https://github.com/kiegroup/drools/commit/9d4e925f944f3b3485ad71e8e21c66f53c1e8fed", "message": "Merge branch 'DROOLS-5372' of github.com:gitgabrio/drools into DROOLS-5372", "committedDate": "2020-06-11T15:39:38Z", "type": "commit"}, {"oid": "02673158812e720c1e1862d4379c2e9980cc1f81", "url": "https://github.com/kiegroup/drools/commit/02673158812e720c1e1862d4379c2e9980cc1f81", "message": "[DROOLS-5372] Implemented reset workaround", "committedDate": "2020-06-15T15:03:36Z", "type": "commit"}, {"oid": "623f03f6b59d4baae90e927b207cae9f982beceb", "url": "https://github.com/kiegroup/drools/commit/623f03f6b59d4baae90e927b207cae9f982beceb", "message": "[DROOLS-5372] Fixed DMN-PMML tests", "committedDate": "2020-06-15T15:43:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0ODk2NQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r440648965", "bodyText": "Is there any reason why you're attempting to load the class from the thread context class loader? Not saying it's wrong, just wondering if a plain Class.forName() wouldn't be enough in this case.", "author": "mariofusco", "createdAt": "2020-06-16T07:42:04Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static DMNKiePMMLInvocationEvaluator getDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        try {\n+            return new DMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } catch (NoClassDefFoundError e) {\n+            LOG.warn(\"Tried binding org.drools:kie-pmml, failed.\");\n+        } catch (Throwable e) {\n+            LOG.warn(\"Binding org.drools:kie-pmml succeded but initialization failed, with:\", e);\n+        }\n+        return null;\n+    }\n+\n+    private static DMNKiePMMLNewInvocationEvaluator getDMNKiePMMLNewInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        try {\n+            return new DMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } catch (NoClassDefFoundError e) {\n+            LOG.warn(\"Tried binding org.drools:kie-pmml-new, failed.\");\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Binding org.drools:kie-pmml-new succeded but initialization failed, with:\", e);\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isLegacyPMMLRequired() {\n+        final String property = System.getProperty(KIE_PMML_IMPLEMENTATION.getName(), LEGACY.getName());\n+        return property.equals(LEGACY.getName());\n+    }\n+\n+    private static boolean isLegacyImplementationPresent() {\n+        try {\n+            Thread.currentThread().getContextClassLoader().loadClass(\"org.kie.pmml.pmml_4_2.PMML4ExecutionHelper\");", "originalCommit": "623f03f6b59d4baae90e927b207cae9f982beceb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2Mjc2Nw==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r440662767", "bodyText": "@mariofusco\nReplaced with Class.forName. Seems to work.\nThanks for suggestion", "author": "gitgabrio", "createdAt": "2020-06-16T08:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0ODk2NQ=="}], "type": "inlineReview"}, {"oid": "df529ffbbdfd8a55f8b4ad5e8774067752529808", "url": "https://github.com/kiegroup/drools/commit/df529ffbbdfd8a55f8b4ad5e8774067752529808", "message": "[DROOLS-5372] Replaced ContextClassLoader.loadClass(...) with Class.forName(...)", "committedDate": "2020-06-16T08:04:34Z", "type": "commit"}, {"oid": "78156d8aaf79d5949db204458805b64351bb2eca", "url": "https://github.com/kiegroup/drools/commit/78156d8aaf79d5949db204458805b64351bb2eca", "message": "Merge remote-tracking branch 'origin/master' into DROOLS-5372", "committedDate": "2020-06-16T08:56:01Z", "type": "commit"}, {"oid": "6fa1d857373755be933c0ec0c6222f40f09da365", "url": "https://github.com/kiegroup/drools/commit/6fa1d857373755be933c0ec0c6222f40f09da365", "message": "[DROOLS-5372] Add kie-pmml-new to drools build", "committedDate": "2020-06-16T10:38:33Z", "type": "commit"}, {"oid": "14363955cfa11b69997a54b69a1d9622845fca65", "url": "https://github.com/kiegroup/drools/commit/14363955cfa11b69997a54b69a1d9622845fca65", "message": "[DROOLS-5372] Excluding dependencies from org.kie:kie-test-util due to ban-duplicated-classes enforcer rule fired on FDB", "committedDate": "2020-06-16T11:40:05Z", "type": "commit"}, {"oid": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "url": "https://github.com/kiegroup/drools/commit/b701f0bac31cc69636b09c32e1d8c320c510a37b", "message": "[DROOLS-5372] Excluding dependencies due to ban-duplicated-classes enforcer rule fired on FDB", "committedDate": "2020-06-16T13:18:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzM4NA==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441327384", "bodyText": "Is this wrong? What is missing?", "author": "danielezonca", "createdAt": "2020-06-17T07:09:38Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractDMNKiePMMLInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Field;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.DMNType;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.api.EvaluatorResult;\n+import org.kie.dmn.core.api.EvaluatorResult.ResultType;\n+import org.kie.dmn.core.ast.EvaluatorResultImpl;\n+import org.kie.dmn.core.impl.CompositeTypeImpl;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract <code>DMNKiePMMLInvocationEvaluator</code> to delegate actual <code>PMML4Result</code> retrieval to specific\n+ * kie-pmml implementation (legacy or new)\n+ */\n+public abstract class AbstractDMNKiePMMLInvocationEvaluator extends AbstractPMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDMNKiePMMLInvocationEvaluator.class);\n+    protected final PMMLInfo<?> pmmlInfo;\n+\n+    public AbstractDMNKiePMMLInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model);\n+        this.pmmlInfo = pmmlInfo;\n+    }\n+\n+    @Override\n+    public EvaluatorResult evaluate(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        PMML4Result resultHolder = getPMML4Result(eventManager, dmnr);\n+\n+        Map<String, Object> resultVariables = resultHolder.getResultVariables();\n+        Map<String, Object> result = getOutputFieldValues(resultHolder, resultVariables, dmnr);\n+        if (result.isEmpty()) {\n+            result = getPredictedValues(resultHolder, dmnr);\n+        }\n+        if (result.isEmpty()) {\n+            // TO FIX\n+            MsgUtil.reportMessage(LOG,", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjgxNA==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046814", "bodyText": "@danielezonca\nleftover", "author": "gitgabrio", "createdAt": "2020-06-18T08:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTk5MQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441491991", "bodyText": "What about wrap decision logic to a method like checkPMMLavailability that just returns LEGACY or NEW?\nI think it could improve readability", "author": "danielezonca", "createdAt": "2020-06-17T12:01:32Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;\n+        }", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjY1MA==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046650", "bodyText": "@danielezonca\nDone", "author": "gitgabrio", "createdAt": "2020-06-18T08:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5MTk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDczMA==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441514730", "bodyText": "To be removed", "author": "danielezonca", "createdAt": "2020-06-17T12:43:00Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/util/KieHelper.java", "diffHunk": "@@ -30,11 +30,16 @@\n \n public final class KieHelper {\n \n+    private KieHelper() {\n+        // Constructing instances is not allowed for this class\n+    }\n+\n     public static KieContainer getKieContainer(ReleaseId releaseId,\n-                                               Resource... resources ) {\n+                                               Resource... resources) {\n         KieServices ks = KieServices.Factory.get();\n-        createAndDeployJar( ks, releaseId, resources );\n-        return ks.newKieContainer( releaseId );\n+//        createAndDeployJar( ks, releaseId, resources );", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjYwNA==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046604", "bodyText": "@danielezonca\nDone", "author": "gitgabrio", "createdAt": "2020-06-18T08:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5NzQ0Mg==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441597442", "bodyText": "Is it possible to move this code to AbstractDMNPMMLTest? It seems to me always the same", "author": "danielezonca", "createdAt": "2020-06-17T14:39:40Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/DMNNaiveBayesPMMLTest.java", "diffHunk": "@@ -30,12 +31,22 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class DMNNaiveBayesPMMLTest {\n+import static org.kie.api.pmml.PMMLConstants.KIE_PMML_IMPLEMENTATION;\n+import static org.kie.api.pmml.PMMLConstants.LEGACY;\n+import static org.kie.dmn.core.util.DMNRuntimeUtil.resetServices;\n+\n+public class DMNNaiveBayesPMMLTest extends AbstractDMNPMMLTest {\n     private static final Logger LOG = LoggerFactory.getLogger(DMNNaiveBayesPMMLTest.class);\n \n     private DMNRuntime runtime;\n     private DMNModel dmnModel;\n \n+    @Before\n+    public void resetEnvironment() {\n+        LOG.debug(\"resetEnvironment\");\n+        resetEnvironment(LEGACY.getName());\n+    }\n+", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjU2OA==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046568", "bodyText": "@danielezonca\nThe parameter is different - tests for new kiepmml should invoke it with \"NEW.getName()\", while the other tests should use \"LEGACY.getName()\"; (fixed inside DMNTreePMMLNewImplTest)", "author": "gitgabrio", "createdAt": "2020-06-18T08:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5NzQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTQ0MQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441599441", "bodyText": "Can you please add logging in both branches (debug should be fine)?", "author": "danielezonca", "createdAt": "2020-06-17T14:42:21Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n+            Object r = kv.getValue();\n+            populateWithObject(toReturn, kv.getKey(), r, dmnr);\n+        }\n+        return toReturn;\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"pmml4Result\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        String resultName = pmml4Result.getResultObjectName();\n+        Object value = pmml4Result.getResultVariables().get(resultName);\n+        toReturn.put(resultName, EvalHelper.coerceNumber(value));\n+        return toReturn;\n+    }\n+\n+    private void populateWithObject(Map<String, Object> toPopulate, String resultName, Object r, DMNResult dmnr) {\n+        Optional<String> outputFieldNameFromInfo = getOutputFieldNameFromInfo(resultName);\n+        if (outputFieldNameFromInfo.isPresent()) {\n+            String name = outputFieldNameFromInfo.get();\n+            try {\n+                toPopulate.put(name, EvalHelper.coerceNumber(r));\n+            } catch (Throwable e) {\n+                MsgUtil.reportMessage(LOG,\n+                                      DMNMessage.Severity.WARN,\n+                                      node,\n+                                      ((DMNResultImpl) dmnr),\n+                                      e,\n+                                      null,\n+                                      Msg.INVALID_NAME,\n+                                      name,\n+                                      e.getMessage());\n+                toPopulate.put(name, null);\n+            }\n+        }\n+    }\n+\n+    private PMMLRuntime getPMMLRuntime(DMNRuntimeEventManager eventManager, String sanitizedKieBase) {\n+        KnowledgeBaseImpl knowledgeBase = ((KnowledgeBaseImpl) ((DMNRuntimeImpl) eventManager.getRuntime()).getInternalKnowledgeBase());\n+        KieContainer kieContainer = knowledgeBase.getKieContainer();\n+        KieBase kieBase;\n+        if (kieContainer.getKieBaseNames().contains(sanitizedKieBase)) {\n+            kieBase = kieContainer.getKieBase(sanitizedKieBase);\n+        } else {\n+            kieBase = kieContainer.getKieBase();\n+        }", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjUyMg==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046522", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-18T08:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTgwMQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441599801", "bodyText": "Can you please remove them or move to trace level?", "author": "danielezonca", "createdAt": "2020-06-17T14:42:49Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n+            Object r = kv.getValue();\n+            populateWithObject(toReturn, kv.getKey(), r, dmnr);\n+        }\n+        return toReturn;\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"pmml4Result\");", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjQ4MQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046481", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-18T08:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTg4Ng==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441599886", "bodyText": "Can you please remove them or move to trace level?", "author": "danielezonca", "createdAt": "2020-06-17T14:42:55Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");\n+        PMMLContext pmmlContext = getPMMLPMMLContext(UUID.randomUUID().toString(), model, dmnr);\n+        String sanitizedKieBase = getSanitizedPackageName(model);\n+        PMMLRuntime pmmlRuntime = getPMMLRuntime(eventManager, sanitizedKieBase);\n+        return pmmlRuntime.evaluate(model, pmmlContext);\n+    }\n+\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjQyMQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046421", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-18T08:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTk2NQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441599965", "bodyText": "Can you please remove them or move to trace level?", "author": "danielezonca", "createdAt": "2020-06-17T14:43:02Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLNewInvocationEvaluator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.dmn.core.pmml;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.drools.core.impl.KnowledgeBaseImpl;\n+import org.kie.api.KieBase;\n+import org.kie.api.io.Resource;\n+import org.kie.api.pmml.PMML4Result;\n+import org.kie.api.runtime.KieContainer;\n+import org.kie.api.runtime.KieRuntimeFactory;\n+import org.kie.dmn.api.core.DMNMessage;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventManager;\n+import org.kie.dmn.core.ast.DMNFunctionDefinitionEvaluator.FormalParameter;\n+import org.kie.dmn.core.impl.DMNResultImpl;\n+import org.kie.dmn.core.impl.DMNRuntimeImpl;\n+import org.kie.dmn.core.util.Msg;\n+import org.kie.dmn.core.util.MsgUtil;\n+import org.kie.dmn.feel.util.EvalHelper;\n+import org.kie.dmn.model.api.DMNElement;\n+import org.kie.pmml.evaluator.api.executor.PMMLContext;\n+import org.kie.pmml.evaluator.api.executor.PMMLRuntime;\n+import org.kie.pmml.evaluator.core.PMMLContextImpl;\n+import org.kie.pmml.evaluator.core.utils.PMMLRequestDataBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedPackageName;\n+\n+public class DMNKiePMMLNewInvocationEvaluator extends AbstractDMNKiePMMLInvocationEvaluator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DMNKiePMMLNewInvocationEvaluator.class);\n+\n+    public DMNKiePMMLNewInvocationEvaluator(String dmnNS, DMNElement node, Resource pmmlResource, String model, PMMLInfo<?> pmmlInfo) {\n+        super(dmnNS, node, pmmlResource, model, pmmlInfo);\n+    }\n+\n+    @Override\n+    protected PMML4Result getPMML4Result(DMNRuntimeEventManager eventManager, DMNResult dmnr) {\n+        LOG.debug(\"getPMML4Result\");", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjM2Nw==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046367", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-18T08:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5OTk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwMzc1NQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441603755", "bodyText": "This method is a bit misleading because it is not a proper ignore case. For example using these values List(\"sAmple\") and sample will fail", "author": "danielezonca", "createdAt": "2020-06-17T14:47:56Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/DMNKiePMMLInvocationEvaluator.java", "diffHunk": "@@ -76,70 +74,90 @@ public EvaluatorResult evaluate(DMNRuntimeEventManager eventManager, DMNResult d\n             Class class1 = pValue.getClass();\n             request.addParameter(p.name, pValue, class1);\n         }\n-        PMML4Result resultHolder = helper.submitRequest(request.build());\n-\n-        Map<String, Object> resultVariables = resultHolder.getResultVariables();\n+        return helper.submitRequest(request.build());\n+    }\n \n-        Map<String, Object> result = new HashMap<>();\n-        for (Entry<String, Object> kv : resultVariables.entrySet()) {\n+    @Override\n+    protected Map<String, Object> getOutputFieldValues(PMML4Result pmml4Result, Map<String, Object> resultVariables, DMNResult dmnr) {\n+        LOG.debug(\"getOutputFieldValues\");\n+        Map<String, Object> toReturn = new HashMap<>();\n+        for (Map.Entry<String, Object> kv : resultVariables.entrySet()) {\n+            String resultName = kv.getKey();\n+            if (resultName == null || resultName.isEmpty()) {\n+                continue;\n+            }\n             Object r = kv.getValue();\n             if (r instanceof PMML4Field) {\n-                final String resultName = kv.getKey();\n-                if (resultName != null && !resultName.isEmpty()) {\n-                    Optional<String> outputFieldNameFromInfo;\n-                    Optional<DMNType> opt = getCompositeOutput();\n-                    if (opt.isPresent()) {\n-                        CompositeTypeImpl type = (CompositeTypeImpl) opt.get();\n-                        outputFieldNameFromInfo = type.getFields()\n-                                                      .keySet()\n-                                                      .stream()\n-                                                      .filter(k -> k.equalsIgnoreCase(resultName))\n-                                                      .findFirst();\n-                    } else {\n-                        outputFieldNameFromInfo = pmmlInfo.getModels()\n-                                                          .stream()\n-                                                          .filter(m -> model.equals(m.getName()))\n-                                                          .flatMap(m -> m.getOutputFieldNames().stream())\n-                                                          .filter(ofn -> ofn.equalsIgnoreCase(resultName))\n-                                                          .findFirst();\n-                    }\n-                    if (outputFieldNameFromInfo.isPresent()) {\n-                        String name = outputFieldNameFromInfo.get();\n-                        try {\n-                            Method method = r.getClass().getMethod(\"getValue\");\n-                            Object value = method.invoke(r);\n-                            result.put(name, EvalHelper.coerceNumber(value));\n-                        } catch (Throwable e) {\n-                            MsgUtil.reportMessage(LOG,\n-                                                  DMNMessage.Severity.WARN,\n-                                                  node,\n-                                                  ((DMNResultImpl) result),\n-                                                  e,\n-                                                  null,\n-                                                  Msg.INVALID_NAME,\n-                                                  name,\n-                                                  e.getMessage());\n-                            result.put(name, null);\n-                        }\n-                    }\n-                }\n+                populateWithPMML4Field(toReturn, kv.getKey(), (PMML4Field) r, dmnr);\n             }\n         }\n+        return toReturn;\n+    }\n \n-        Object coercedResult = result.size() > 1 ? result : result.values().iterator().next();\n-        return new EvaluatorResultImpl(coercedResult, ResultType.SUCCESS);\n+    @Override\n+    protected Map<String, Object> getPredictedValues(PMML4Result pmml4Result, DMNResult dmnr) {\n+        LOG.debug(\"getPredictedValues\");\n+        final DMNPMMLModelInfo modelInfo = getDMNPMMLInfo();\n+        if (modelInfo == null) {\n+            return Collections.emptyMap();\n+        }\n+        return getTargetObjects(modelInfo.getTargetFieldNames(), pmml4Result, dmnr);\n     }\n \n-    private Optional<DMNType> getCompositeOutput() {\n-        Collection<? extends PMMLModelInfo> models = pmmlInfo.getModels();\n-        return models.stream()\n-                .filter(m -> model.equals(m.getName()))\n-                .filter(m -> m instanceof DMNPMMLModelInfo)\n-                .flatMap(m -> ((DMNPMMLModelInfo)m).getOutputFields().entrySet().stream())\n-                .filter(e -> e.getKey().equals(model))\n-                .filter(e -> e.getValue() instanceof CompositeTypeImpl)\n-                .map(Map.Entry::getValue)\n-                .findFirst();\n+    private Map<String, Object> getTargetObjects(Collection<String> targetFieldNames, PMML4Result pmml4Result, DMNResult dmnr) {\n+        Map<String, Object> toReturn = new HashMap<>();\n+        pmml4Result.getResultVariables().forEach((key, value) -> {\n+            if (containsIgnoreCase(targetFieldNames, key) && value instanceof PMML4OutputField) {\n+                PMML4OutputField pmml4OutputField = (PMML4OutputField) value;\n+                populateWithReflection(toReturn, key, pmml4OutputField, dmnr);\n+            }\n+        });\n+        return toReturn;\n     }\n \n+    private void populateWithPMML4Field(Map<String, Object> toPopulate, String resultName, PMML4Field pmml4Field, DMNResult dmnr) {\n+        Optional<String> outputFieldNameFromInfo = getOutputFieldNameFromInfo(resultName);\n+        if (outputFieldNameFromInfo.isPresent()) {\n+            String name = outputFieldNameFromInfo.get();\n+            populateWithReflection(toPopulate, name, pmml4Field, dmnr);\n+        }\n+    }\n+\n+    private void populateWithReflection(Map<String, Object> toPopulate, String name, PMML4Field pmml4Field, DMNResult dmnr) {\n+        try {\n+            Method method = pmml4Field.getClass().getMethod(\"getValue\");\n+            Object value = method.invoke(pmml4Field);\n+            toPopulate.put(name, EvalHelper.coerceNumber(value));\n+        } catch (Throwable e) {\n+            MsgUtil.reportMessage(LOG,\n+                                  DMNMessage.Severity.WARN,\n+                                  node,\n+                                  ((DMNResultImpl) dmnr),\n+                                  e,\n+                                  null,\n+                                  Msg.INVALID_NAME,\n+                                  name,\n+                                  e.getMessage());\n+            toPopulate.put(name, null);\n+        }\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if <b>containingCollection</b> contains <b>searchedString</b> OR <b>searchedString.toLowerCase()</b>\n+     * @param containingCollection\n+     * @param searchedString\n+     * @return\n+     */\n+    private boolean containsIgnoreCase(Collection<String> containingCollection, String searchedString) {\n+        return containingCollection.contains(searchedString) || containingCollection.contains(searchedString.toLowerCase());\n+    }", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjMwMQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046301", "bodyText": "@danielezonca\nRenamed a little bit.\nBTW - that is one of the reason of javadoc -  sometimes it is hard to explain a specific logic in one camel-cased word", "author": "gitgabrio", "createdAt": "2020-06-18T08:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwMzc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwNzYzMQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441607631", "bodyText": "To be removed", "author": "danielezonca", "createdAt": "2020-06-17T14:52:59Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java", "diffHunk": "@@ -94,6 +103,21 @@ public static DMNRuntime createRuntime(final String resourceName, final Class te\n         return dmnMessages;\n     }\n \n+    public static void resetServices() {\n+        final ServiceDiscoveryImpl serviceDiscovery = ServiceDiscoveryImpl.getInstance();\n+        serviceDiscovery.reset();\n+        final ServiceRegistryImpl instance = (ServiceRegistryImpl)ServiceRegistry.getInstance();\n+        instance.reload();\n+//\n+//\n+//        Map<String, Object> resetServices = serviceDiscovery.getServices();\n+//        KieAssemblersImpl resetKieAssemblers = (KieAssemblersImpl)resetServices.get(\"org.kie.api.internal.assembler.KieAssemblers\");\n+//        KieAssemblersImpl kieAssemblers = (KieAssemblersImpl)instance.get(KieAssemblers.class);\n+//        Map<ResourceType, KieAssemblerService> registeredKieAssemblers = kieAssemblers.getAssemblers();\n+//        resetKieAssemblers.getAssemblers()\n+//                .forEach(registeredKieAssemblers::put);", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjI0Mw==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046243", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-18T08:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwNzYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwOTc2MQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441609761", "bodyText": "Is this always true?", "author": "danielezonca", "createdAt": "2020-06-17T14:55:42Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-tree/kie-pmml-models-drools-tree-compiler/src/main/java/org/kie/pmml/models/drools/tree/compiler/factories/KiePMMLTreeModelNodeASTFactory.java", "diffHunk": "@@ -98,10 +98,8 @@ protected void declareFinalRuleFromNode(final Node node,\n             return;\n         }\n         String currentRule = String.format(PATH_PATTERN, parentPath, node.getScore());\n-        if (!(predicate instanceof True)) {", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjE3NA==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046174", "bodyText": "@danielezonca\nThis is out of the scope of this PR - I will check in another ticket", "author": "gitgabrio", "createdAt": "2020-06-18T08:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwOTc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4NTg5MA==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441785890", "bodyText": "Is there any reason to keep commented code? If yes please add description into the comment. Otherwise please remove.", "author": "jiripetrlik", "createdAt": "2020-06-17T19:33:50Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/util/DMNRuntimeUtil.java", "diffHunk": "@@ -94,6 +103,21 @@ public static DMNRuntime createRuntime(final String resourceName, final Class te\n         return dmnMessages;\n     }\n \n+    public static void resetServices() {\n+        final ServiceDiscoveryImpl serviceDiscovery = ServiceDiscoveryImpl.getInstance();\n+        serviceDiscovery.reset();\n+        final ServiceRegistryImpl instance = (ServiceRegistryImpl)ServiceRegistry.getInstance();\n+        instance.reload();\n+//\n+//\n+//        Map<String, Object> resetServices = serviceDiscovery.getServices();", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjA1Ng==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442046056", "bodyText": "@jiripetrlik\nThe issue here is different. Here we have both kie-pmml implementations in the classpath (legacy and new one) and unfortunatley the \"utils\" used in the tests does not clear the runtime. What happens is that all the KieServices are populated (normally) only at application startup (see https://github.com/kiegroup/droolsjbpm-knowledge/blob/master/kie-internal/src/main/java/org/kie/internal/services/KieAssemblersImpl.java#L67).\n/---/\nRemoved commented code", "author": "gitgabrio", "createdAt": "2020-06-18T08:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4NTg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTUzNg==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441789536", "bodyText": "Maybe it would be better to throw exception.", "author": "jiripetrlik", "createdAt": "2020-06-17T19:40:56Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/pmml/AbstractPMMLInvocationEvaluator.java", "diffHunk": "@@ -143,9 +146,68 @@ public static AbstractPMMLInvocationEvaluator newInstance(DMNModelImpl model, Cl\n                                   funcDef.getIdentifierString());\n             return new AbstractPMMLInvocationEvaluator.DummyPMMLInvocationEvaluator(model.getNamespace(), funcDef, pmmlResource, pmmlModel);\n         }\n+    }\n \n-        private PMMLInvocationEvaluatorFactory() {\n-            // Constructing instances is not allowed for this Factory\n+    private static AbstractDMNKiePMMLInvocationEvaluator getAbstractDMNKiePMMLInvocationEvaluator(String nameSpace, DMNElement funcDef, Resource pmmlResource, String pmmlModel, PMMLInfo<?> pmmlInfo) {\n+        final boolean legacyImplementationPresent = isLegacyImplementationPresent();\n+        final boolean newImplementationPresent = isNewImplementationPresent();\n+        if (legacyImplementationPresent && newImplementationPresent) {\n+            if (isLegacyPMMLRequired()) {\n+                return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            } else {\n+                return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+            }\n+        } else if (legacyImplementationPresent) {\n+            return getDMNKiePMMLInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else if (newImplementationPresent) {\n+            return getDMNKiePMMLNewInvocationEvaluator(nameSpace, funcDef, pmmlResource, pmmlModel, pmmlInfo);\n+        } else {\n+            return null;", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NTk5Nw==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442045997", "bodyText": "@jiripetrlik\nThat \"null\" is expected since - in this case - the code is written to return a \"DummyPMMLInvocationEvaluator\"", "author": "gitgabrio", "createdAt": "2020-06-18T08:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4OTUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5Mjc4MQ==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r441792781", "bodyText": "I'm not sure about this. I think it would be much more clear to create two separate modules as @tarilabs suggested with different jars on classpath. We can never be sure that it DMN PMML works without logic in resetService() method.", "author": "jiripetrlik", "createdAt": "2020-06-17T19:47:23Z", "path": "kie-dmn/kie-dmn-core/src/test/java/org/kie/dmn/core/pmml/AbstractDMNPMMLTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.dmn.core.pmml;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.api.pmml.PMMLConstants.KIE_PMML_IMPLEMENTATION;\n+import static org.kie.dmn.core.util.DMNRuntimeUtil.resetServices;\n+\n+public abstract class AbstractDMNPMMLTest {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractDMNPMMLTest.class);\n+\n+    protected void resetEnvironment(String pmmlVersion) {\n+        LOG.debug(\"resetEnvironment {}\", pmmlVersion);\n+        System.setProperty(KIE_PMML_IMPLEMENTATION.getName(), pmmlVersion);", "originalCommit": "b701f0bac31cc69636b09c32e1d8c320c510a37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NTg2Mg==", "url": "https://github.com/kiegroup/drools/pull/2948#discussion_r442045862", "bodyText": "@jiripetrlik\nThis workaround is needed because all those DMN-PMML tests are using \"utils\" (like KieHelper) that by themselves are \"by-passing\" the normal usage; as they currently are they do not test the real runtime.\nRewriting all those tests is out of the scope of this PR.", "author": "gitgabrio", "createdAt": "2020-06-18T08:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5Mjc4MQ=="}], "type": "inlineReview"}, {"oid": "8ffec110ad745dee881b1f64edc7850cca7124f2", "url": "https://github.com/kiegroup/drools/commit/8ffec110ad745dee881b1f64edc7850cca7124f2", "message": "[DROOLS-5372] Fixed as per PR suggestion", "committedDate": "2020-06-18T08:08:41Z", "type": "commit"}, {"oid": "4257ccbee1c3cf820bca85275966600e12cae01e", "url": "https://github.com/kiegroup/drools/commit/4257ccbee1c3cf820bca85275966600e12cae01e", "message": "[DROOLS-5372] Fixed as per PR suggestion", "committedDate": "2020-06-18T09:51:48Z", "type": "commit"}, {"oid": "a8fb0f11fa8f30b95be15ea4165e5d2d35bf2e89", "url": "https://github.com/kiegroup/drools/commit/a8fb0f11fa8f30b95be15ea4165e5d2d35bf2e89", "message": "[DROOLS-5372] Revert empty spaces/formatting modification", "committedDate": "2020-06-19T11:26:18Z", "type": "commit"}]}