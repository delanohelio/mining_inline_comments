{"pr_number": 2900, "pr_title": "[BAPL-1259] Add logging for rule performance analysis", "pr_createdAt": "2020-05-15T06:13:49Z", "pr_url": "https://github.com/kiegroup/drools/pull/2900", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0MzIzNA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r432443234", "bodyText": "Instead of 4 different ThreadLocals would be better (for perf reasons too) to encapsulate the statistics collected per BaseNode into a BaseNodeStats class that could be used into a single ThreadLocal", "author": "franz1981", "createdAt": "2020-05-29T12:16:11Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<Boolean> started = new ThreadLocal<>();", "originalCommit": "064e986a5f5c87a9fae8570ce5344e8e31b69ac9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0MzcyNQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r432443725", "bodyText": "There is no need to use an AtomicInteger here, but a single int (or long?) field into the BaseNodeStats (see prev comment) would be enough, given that is being used in a single threaded fashion", "author": "franz1981", "createdAt": "2020-05-29T12:17:14Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<Boolean> started = new ThreadLocal<>();\n+    private static final ThreadLocal<AtomicInteger> evalCount = new ThreadLocal<>();", "originalCommit": "064e986a5f5c87a9fae8570ce5344e8e31b69ac9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NDQ2MQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r432444461", "bodyText": "There is no need to use a boxed type here, but just a single long field into BaseNodeStats (see previous comments) is enough: it would save both pointer chasing and garbage produced", "author": "franz1981", "createdAt": "2020-05-29T12:18:40Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<Boolean> started = new ThreadLocal<>();\n+    private static final ThreadLocal<AtomicInteger> evalCount = new ThreadLocal<>();\n+    private static final ThreadLocal<Long> startTime = new ThreadLocal<>();", "originalCommit": "064e986a5f5c87a9fae8570ce5344e8e31b69ac9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0Njg0OA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r432446848", "bodyText": "Ditto as before: could be part of a single thread local instance (ie BaseNodeStats), but it worries me that I cannot see any code path that set it to null..it risks to became an actual memory leak: I suggest to rethink if it worths to make this a weak reference field instead...", "author": "franz1981", "createdAt": "2020-05-29T12:23:02Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<Boolean> started = new ThreadLocal<>();\n+    private static final ThreadLocal<AtomicInteger> evalCount = new ThreadLocal<>();\n+    private static final ThreadLocal<Long> startTime = new ThreadLocal<>();\n+    private static final ThreadLocal<BaseNode> node = new ThreadLocal<>();", "originalCommit": "064e986a5f5c87a9fae8570ce5344e8e31b69ac9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA5MjE0Mw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r433092143", "bodyText": "I would save this expensive computation ie  elapsedTime / 1000 to perform it just once and I would handle the case of stats == null with a log or something similar: at this point this is not supposed to be null right?", "author": "franz1981", "createdAt": "2020-06-01T07:53:51Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -55,33 +50,29 @@ public static void setEnabled(boolean enabled) {\n \n     public static void startMetrics(BaseNode baseNode) {\n         if (enabled) {\n-            started.set(true);\n-            node.set(baseNode);\n-            evalCount.set(new AtomicInteger(0));\n-            startTime.set(System.nanoTime());\n-        }\n-    }\n-\n-    public static void endMetrics() {\n-        if (enabled) {\n-            started.set(false);\n+            nodeStats.set(new NodeStats(baseNode));\n         }\n     }\n \n     public static void incrementEvalCount() {\n-        if (enabled && started.get().booleanValue()) {\n-            evalCount.get().getAndIncrement();\n+        if (enabled) {\n+            NodeStats stats = nodeStats.get();\n+            if (stats != null && stats.isStarted()) {\n+                stats.incrementEvalCount();\n+            }\n         }\n     }\n \n     public static void logAndEndMetrics() {\n-        if (enabled && started.get().booleanValue()) {\n-            long elapsedTime = (System.nanoTime() - startTime.get());\n-            int count = evalCount.get().intValue();\n-            if (count > 0 && (elapsedTime / 1000) > threshold) {\n-                logger.trace(\"{}, evalCount:{}, elapsed:{}\", node.get(), count, elapsedTime / 1000); // microseconds\n+        if (enabled) {\n+            NodeStats stats = nodeStats.get();\n+            if (stats != null && stats.isStarted()) {\n+                long elapsedTime = (System.nanoTime() - stats.getStartTime());\n+                if (stats.getEvalCount() > 0 && (elapsedTime / 1000) > threshold) {", "originalCommit": "c09049ac9b83c905e70ff4bd1a51d1daaa991182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU4ODE3MQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r433588171", "bodyText": "Applied the suggestion. Thanks!", "author": "tkobayas", "createdAt": "2020-06-02T02:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA5MjE0Mw=="}], "type": "inlineReview"}, {"oid": "8adf0839793929a354155ce2d95661f2253505ca", "url": "https://github.com/kiegroup/drools/commit/8adf0839793929a354155ce2d95661f2253505ca", "message": "- applied to PhrealEvalNode\n- try/finally", "committedDate": "2020-06-22T00:17:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzOTI4Mg==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r443439282", "bodyText": "Given that's globally visible...maybe it should use a volatile here: you expect this to change while the application is running?", "author": "franz1981", "createdAt": "2020-06-22T09:42:44Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<NodeStats> nodeStats = new ThreadLocal<>();\n+\n+    public static int getThreshold() {\n+        return threshold;\n+    }\n+\n+    public static void setThreshold(int threshold) {\n+        PerfLogUtils.threshold = threshold;\n+    }\n+\n+    public static boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public static void setEnabled(boolean enabled) {\n+        PerfLogUtils.enabled = enabled;", "originalCommit": "8adf0839793929a354155ce2d95661f2253505ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MjMyMQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r443952321", "bodyText": "I don't expect this to be changed while the application is running, I added this for test convenience but maybe I can make it package private (or even remove)... Thanks for pointing this out :)", "author": "tkobayas", "createdAt": "2020-06-23T04:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzOTI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMDgyNA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446810824", "bodyText": "I think that this constructor is called by default. Any reason for explicitly adding it here?", "author": "jiripetrlik", "createdAt": "2020-06-29T06:58:34Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.common.metric;\n+\n+import org.drools.core.RuleBaseConfiguration;\n+import org.drools.core.common.DefaultBetaConstraints;\n+import org.drools.core.common.InternalFactHandle;\n+import org.drools.core.rule.ContextEntry;\n+import org.drools.core.rule.MutableTypeConstraint;\n+import org.drools.core.spi.BetaNodeFieldConstraint;\n+import org.drools.core.spi.Tuple;\n+import org.drools.core.util.PerfLogUtils;\n+\n+public class DefaultBetaConstraintsMetric extends DefaultBetaConstraints {\n+\n+    private static final long serialVersionUID = 510l;\n+\n+    public DefaultBetaConstraintsMetric() {\n+        super();", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMTMzOA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446911338", "bodyText": "Thank you for pointing this! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTU1Nw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446811557", "bodyText": "I know it is a detail. But maybe please update 2005 to 2020.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:00:16Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTYxMA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446811610", "bodyText": "I know it is a detail. But maybe please update 2005 to 2020.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:00:23Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/DoubleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMTc4OQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446911789", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTc5Mg==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446811792", "bodyText": "I know it is a detail. But maybe please update 2005 to 2020.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:00:46Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMTk3MQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446911971", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjA4OQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812089", "bodyText": "Isn't this called by default?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:01:28Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.common.metric;\n+\n+import org.drools.core.RuleBaseConfiguration;\n+import org.drools.core.common.DefaultBetaConstraints;\n+import org.drools.core.common.InternalFactHandle;\n+import org.drools.core.rule.ContextEntry;\n+import org.drools.core.rule.MutableTypeConstraint;\n+import org.drools.core.spi.BetaNodeFieldConstraint;\n+import org.drools.core.spi.Tuple;\n+import org.drools.core.util.PerfLogUtils;\n+\n+public class DefaultBetaConstraintsMetric extends DefaultBetaConstraints {\n+\n+    private static final long serialVersionUID = 510l;\n+\n+    public DefaultBetaConstraintsMetric() {\n+        super();", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjQyMQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912421", "bodyText": "Thank you for pointing this! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjE1MA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812150", "bodyText": "Is this indent intentional?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:01:38Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.common.metric;\n+\n+import org.drools.core.RuleBaseConfiguration;\n+import org.drools.core.common.InternalFactHandle;\n+import org.drools.core.common.QuadroupleBetaConstraints;\n+import org.drools.core.rule.ContextEntry;\n+import org.drools.core.rule.MutableTypeConstraint;\n+import org.drools.core.spi.BetaNodeFieldConstraint;\n+import org.drools.core.spi.Tuple;\n+import org.drools.core.util.PerfLogUtils;\n+import org.kie.internal.conf.IndexPrecedenceOption;\n+\n+public class QuadroupleBetaConstraintsMetric extends QuadroupleBetaConstraints {\n+\n+    private static final long             serialVersionUID = 510l;", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjE1Ng==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912156", "bodyText": "Thanks! Formatted", "author": "tkobayas", "createdAt": "2020-06-29T11:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjM0Mg==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812342", "bodyText": "Please update date.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:02:05Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/SingleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjIxNQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912215", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjYyMA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812620", "bodyText": "Please fix date.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:02:50Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/TripleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjU0NA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912544", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjcxMA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812710", "bodyText": "Missing license header.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:03:04Z", "path": "drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.drools.core.phreak;", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjYxNQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912615", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMzgwNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446813807", "bodyText": "Is missing access modifier intentional? Shouldn't we rather use public?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:05:33Z", "path": "drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.drools.core.phreak;\n+\n+import org.drools.core.phreak.metric.PhreakAccumulateNodeMetric;\n+import org.drools.core.phreak.metric.PhreakAsyncReceiveNodeMetric;\n+import org.drools.core.phreak.metric.PhreakAsyncSendNodeMetric;\n+import org.drools.core.phreak.metric.PhreakBranchNodeMetric;\n+import org.drools.core.phreak.metric.PhreakEvalNodeMetric;\n+import org.drools.core.phreak.metric.PhreakExistsNodeMetric;\n+import org.drools.core.phreak.metric.PhreakFromNodeMetric;\n+import org.drools.core.phreak.metric.PhreakJoinNodeMetric;\n+import org.drools.core.phreak.metric.PhreakNotNodeMetric;\n+import org.drools.core.phreak.metric.PhreakQueryNodeMetric;\n+import org.drools.core.phreak.metric.PhreakQueryTerminalNodeMetric;\n+import org.drools.core.phreak.metric.PhreakReactiveFromNodeMetric;\n+import org.drools.core.phreak.metric.PhreakTimerNodeMetric;\n+import org.drools.core.util.PerfLogUtils;\n+\n+public class PhreakNetworkNodeFactory {\n+\n+    private static final PhreakNetworkNodeFactory INSTANCE = new PhreakNetworkNodeFactory();\n+\n+    public static PhreakNetworkNodeFactory getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private PhreakNetworkNodeFactory() {}\n+\n+    PhreakJoinNode createPhreakJoinNode() {", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMzM4NA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446913384", "bodyText": "Yes, it's intentional to be package private. Thanks!", "author": "tkobayas", "createdAt": "2020-06-29T11:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMzgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMzk2MA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446813960", "bodyText": "Please fix date.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:05:52Z", "path": "drools-core/src/main/java/org/drools/core/phreak/metric/PhreakAccumulateNodeMetric.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2015 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMzYwNQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446913605", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMzk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNTc0Mg==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446815742", "bodyText": "Is it ok to do nothing for all these exception types? For example Security or Illegal argument exceptions? Maybe it would be good to at least log something at debug or trace level. What do you think?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:09:56Z", "path": "drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.drools.core.reteoo;\n+\n+import java.io.PrintWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.core.common.BaseNode;\n+import org.drools.core.impl.InternalKnowledgeBase;\n+import org.kie.api.KieBase;\n+import org.kie.api.definition.rule.Rule;\n+import org.kie.api.runtime.KieRuntime;\n+import org.kie.api.runtime.KieSession;\n+\n+/**\n+ * \n+ * Utility class to view Rete models\n+ *\n+ */\n+public class ReteDumper {\n+\n+    private PrintWriter writer;\n+    private StringBuilder sb;\n+    private Predicate<BaseNode> nodesFilter;\n+\n+    private boolean nodeInfoOnly = false;\n+\n+    public ReteDumper() {\n+        this(node -> true);\n+    }\n+\n+    public ReteDumper(Predicate<BaseNode> nodesFilter) {\n+        this.nodesFilter = nodesFilter;\n+    }\n+\n+    public ReteDumper(String ruleName) {\n+        this( node -> Stream.of( node.getAssociatedRules() ).anyMatch( rule -> rule.getName().equals( ruleName ) ) );\n+    }\n+\n+    public PrintWriter getWriter() {\n+        return writer;\n+    }\n+\n+    /**\n+     * Set a writer to which ReteDumper prints results. By default, results will be printed to STDOUT\n+     * @param writer\n+     */\n+    public void setWriter(PrintWriter writer) {\n+        this.writer = writer;\n+    }\n+\n+    public boolean isNodeInfoOnly() {\n+        return nodeInfoOnly;\n+    }\n+\n+    /**\n+     * If true, dump without partition/mask information. Default value is false\n+     * @param nodeInfoOnly\n+     */\n+    public void setNodeInfoOnly(boolean nodeInfoOnly) {\n+        this.nodeInfoOnly = nodeInfoOnly;\n+    }\n+\n+    public static void dumpRete(KieBase kbase ) {\n+        new ReteDumper().dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static void dumpRete(KieRuntime session ) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(KieSession session) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(InternalKnowledgeBase kBase) {\n+        new ReteDumper().dump(kBase.getRete());\n+    }\n+\n+    public static void dumpRete(Rete rete) {\n+        new ReteDumper().dump(rete);\n+    }\n+\n+    public void dump(KieBase kbase ) {\n+        dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public void dump(KieRuntime session ) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(KieSession session) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(InternalKnowledgeBase kBase) {\n+        dump(kBase.getRete());\n+    }\n+\n+    public void dump(Rete rete) {\n+        // Other dump/dumpRete methods eventually call this method\n+        sb = new StringBuilder();\n+        traverseRete(rete, this::dumpNode);\n+        printResults();\n+    }\n+\n+    private void printResults() {\n+        if (writer == null) {\n+            System.out.print(sb.toString());\n+        } else {\n+            // if a writer is given by a caller, the caller is responsible for closing\n+            writer.print(sb.toString());\n+        }\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieBase kbase ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieRuntime session ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieSession session) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(InternalKnowledgeBase kBase) {\n+        return new ReteDumper().collect(kBase.getRete());\n+    }\n+\n+    public static Set<BaseNode> collectRete(Rete rete) {\n+        return new ReteDumper().collect(rete);\n+    }\n+\n+    public Set<BaseNode> collect(KieBase kbase ) {\n+        return collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public Set<BaseNode> collect(KieRuntime session ) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(KieSession session) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(InternalKnowledgeBase kBase) {\n+        return collect(kBase.getRete());\n+    }\n+\n+    public Set<BaseNode> collect(Rete rete) {\n+        Set<BaseNode> nodes = createIdentitySet();\n+        traverseRete(rete, (node, s) -> nodes.add(node));\n+        return nodes;\n+    }\n+\n+    public void traverseRete(Rete rete, BiConsumer<BaseNode, String> consumer) {\n+        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {\n+            dumpNode( entryPointNode, \"\", createIdentitySet(), consumer);\n+        }\n+    }\n+\n+    private <T> Set<T> createIdentitySet() {\n+        return Collections.newSetFromMap(new IdentityHashMap<>());\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident, Set<BaseNode> visitedNodes, BiConsumer<BaseNode, String> consumer ) {\n+        consumer.accept( node, ident );\n+        if (!visitedNodes.add( node )) {\n+            return;\n+        }\n+        Sink[] sinks = node.getSinks();\n+        if (sinks != null) {\n+            for (Sink sink : sinks) {\n+                if (sink instanceof BaseNode) {\n+                    BaseNode sinkNode = ( BaseNode ) sink;\n+                    if ( nodesFilter.test( sinkNode ) ) {\n+                        dumpNode( sinkNode, ident + \"  \", visitedNodes, consumer );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident ) {\n+        sb.append(ident + formatNode(node));\n+        if (!nodeInfoOnly) {\n+            sb.append(\" on \" + node.getPartitionId());\n+            try {\n+                Object declaredMask = node.getClass().getMethod(\"getDeclaredMask\").invoke(node);\n+                Object inferreddMask = node.getClass().getMethod(\"getInferredMask\").invoke(node);\n+                sb.append(\" d \"+declaredMask + \" i \" + inferreddMask);\n+            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+                // do nothing.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNzY4OA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446937688", "bodyText": "Hmm, I think that this part is used only for debugging purpose by core developers so it may not need to handle Exception. But anyway, I added trace logging as suggested so that other people will not need to worry in the future :) Thanks!", "author": "tkobayas", "createdAt": "2020-06-29T12:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNTc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNTkxNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446815917", "bodyText": "Same as for previous try catch block.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:10:17Z", "path": "drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.drools.core.reteoo;\n+\n+import java.io.PrintWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.core.common.BaseNode;\n+import org.drools.core.impl.InternalKnowledgeBase;\n+import org.kie.api.KieBase;\n+import org.kie.api.definition.rule.Rule;\n+import org.kie.api.runtime.KieRuntime;\n+import org.kie.api.runtime.KieSession;\n+\n+/**\n+ * \n+ * Utility class to view Rete models\n+ *\n+ */\n+public class ReteDumper {\n+\n+    private PrintWriter writer;\n+    private StringBuilder sb;\n+    private Predicate<BaseNode> nodesFilter;\n+\n+    private boolean nodeInfoOnly = false;\n+\n+    public ReteDumper() {\n+        this(node -> true);\n+    }\n+\n+    public ReteDumper(Predicate<BaseNode> nodesFilter) {\n+        this.nodesFilter = nodesFilter;\n+    }\n+\n+    public ReteDumper(String ruleName) {\n+        this( node -> Stream.of( node.getAssociatedRules() ).anyMatch( rule -> rule.getName().equals( ruleName ) ) );\n+    }\n+\n+    public PrintWriter getWriter() {\n+        return writer;\n+    }\n+\n+    /**\n+     * Set a writer to which ReteDumper prints results. By default, results will be printed to STDOUT\n+     * @param writer\n+     */\n+    public void setWriter(PrintWriter writer) {\n+        this.writer = writer;\n+    }\n+\n+    public boolean isNodeInfoOnly() {\n+        return nodeInfoOnly;\n+    }\n+\n+    /**\n+     * If true, dump without partition/mask information. Default value is false\n+     * @param nodeInfoOnly\n+     */\n+    public void setNodeInfoOnly(boolean nodeInfoOnly) {\n+        this.nodeInfoOnly = nodeInfoOnly;\n+    }\n+\n+    public static void dumpRete(KieBase kbase ) {\n+        new ReteDumper().dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static void dumpRete(KieRuntime session ) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(KieSession session) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(InternalKnowledgeBase kBase) {\n+        new ReteDumper().dump(kBase.getRete());\n+    }\n+\n+    public static void dumpRete(Rete rete) {\n+        new ReteDumper().dump(rete);\n+    }\n+\n+    public void dump(KieBase kbase ) {\n+        dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public void dump(KieRuntime session ) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(KieSession session) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(InternalKnowledgeBase kBase) {\n+        dump(kBase.getRete());\n+    }\n+\n+    public void dump(Rete rete) {\n+        // Other dump/dumpRete methods eventually call this method\n+        sb = new StringBuilder();\n+        traverseRete(rete, this::dumpNode);\n+        printResults();\n+    }\n+\n+    private void printResults() {\n+        if (writer == null) {\n+            System.out.print(sb.toString());\n+        } else {\n+            // if a writer is given by a caller, the caller is responsible for closing\n+            writer.print(sb.toString());\n+        }\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieBase kbase ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieRuntime session ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieSession session) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(InternalKnowledgeBase kBase) {\n+        return new ReteDumper().collect(kBase.getRete());\n+    }\n+\n+    public static Set<BaseNode> collectRete(Rete rete) {\n+        return new ReteDumper().collect(rete);\n+    }\n+\n+    public Set<BaseNode> collect(KieBase kbase ) {\n+        return collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public Set<BaseNode> collect(KieRuntime session ) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(KieSession session) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(InternalKnowledgeBase kBase) {\n+        return collect(kBase.getRete());\n+    }\n+\n+    public Set<BaseNode> collect(Rete rete) {\n+        Set<BaseNode> nodes = createIdentitySet();\n+        traverseRete(rete, (node, s) -> nodes.add(node));\n+        return nodes;\n+    }\n+\n+    public void traverseRete(Rete rete, BiConsumer<BaseNode, String> consumer) {\n+        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {\n+            dumpNode( entryPointNode, \"\", createIdentitySet(), consumer);\n+        }\n+    }\n+\n+    private <T> Set<T> createIdentitySet() {\n+        return Collections.newSetFromMap(new IdentityHashMap<>());\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident, Set<BaseNode> visitedNodes, BiConsumer<BaseNode, String> consumer ) {\n+        consumer.accept( node, ident );\n+        if (!visitedNodes.add( node )) {\n+            return;\n+        }\n+        Sink[] sinks = node.getSinks();\n+        if (sinks != null) {\n+            for (Sink sink : sinks) {\n+                if (sink instanceof BaseNode) {\n+                    BaseNode sinkNode = ( BaseNode ) sink;\n+                    if ( nodesFilter.test( sinkNode ) ) {\n+                        dumpNode( sinkNode, ident + \"  \", visitedNodes, consumer );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident ) {\n+        sb.append(ident + formatNode(node));\n+        if (!nodeInfoOnly) {\n+            sb.append(\" on \" + node.getPartitionId());\n+            try {\n+                Object declaredMask = node.getClass().getMethod(\"getDeclaredMask\").invoke(node);\n+                Object inferreddMask = node.getClass().getMethod(\"getInferredMask\").invoke(node);\n+                sb.append(\" d \"+declaredMask + \" i \" + inferreddMask);\n+            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+                // do nothing.\n+            }\n+            try {\n+                Object declaredMask = node.getClass().getMethod(\"getLeftDeclaredMask\").invoke(node);\n+                Object inferreddMask = node.getClass().getMethod(\"getLeftInferredMask\").invoke(node);\n+                sb.append(\" Ld \"+declaredMask + \" Li \" + inferreddMask);\n+            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+                // do nothing.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzODAwNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446938007", "bodyText": "Added logging. Thanks!", "author": "tkobayas", "createdAt": "2020-06-29T12:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjI5NA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446816294", "bodyText": "Missing license header.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:11:06Z", "path": "drools-core/src/main/java/org/drools/core/reteoo/builder/BetaNodeConstraintFactory.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.drools.core.reteoo.builder;", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTYyNA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446925624", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T12:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjc5NQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446816795", "bodyText": "Only for curiosity. Is there any reason for this change? It seems both do the same.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:12:14Z", "path": "drools-core/src/main/java/org/drools/core/rule/EvalCondition.java", "diffHunk": "@@ -153,7 +153,7 @@ public boolean equals(final Object object) {\n             return true;\n         }\n \n-        if ( object == null || object.getClass() != EvalCondition.class ) {\n+        if ( object == null || object.getClass() != this.getClass() ) {", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNzkwMw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446927903", "bodyText": "I wanted to compare with the right class (= if \"this\" is a sub class, e.g. EvalConditionMetric, I need to use \"this.getClass()\").", "author": "tkobayas", "createdAt": "2020-06-29T12:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjg5NQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446816895", "bodyText": "Missing license header.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:12:29Z", "path": "drools-core/src/main/java/org/drools/core/rule/EvalConditionFactory.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package org.drools.core.rule;", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTcwNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446925707", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T12:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNzA0MA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446817040", "bodyText": "Any reason for calling super here?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:12:48Z", "path": "drools-core/src/main/java/org/drools/core/rule/metric/EvalConditionMetric.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.drools.core.rule.metric;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.drools.core.WorkingMemory;\n+import org.drools.core.rule.Declaration;\n+import org.drools.core.rule.EvalCondition;\n+import org.drools.core.spi.EvalExpression;\n+import org.drools.core.spi.Tuple;\n+import org.drools.core.util.PerfLogUtils;\n+\n+public class EvalConditionMetric extends EvalCondition {\n+\n+    public EvalConditionMetric() {\n+        super();", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTg0MA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446925840", "bodyText": "Thank you for pointing this! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T12:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0ODIwNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r450648207", "bodyText": "I believe that having a ThreadLocal here is only necessary if the engine is running in parallel evaluation mode (which is not the default). Probably you could have a single plain NodeStats if parallel evaluation is not enabled.", "author": "mariofusco", "createdAt": "2020-07-07T06:55:40Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private final ThreadLocal<NodeStats> nodeStats = new ThreadLocal<>();", "originalCommit": "8ecf6a08302c2a59c8003dd34438626cf74fa211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5MjkzOA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r451292938", "bodyText": "@mariofusco I used ThreadLocal considering the case where a user executes multiple ksessions concurrently (e.g. in kie-server). But of course, we can limit the use of this feature only for single thread execution (= Raise an error log when PerfLogUtils is concurrently accessed). If you think it's better, I'll change. Please let me know your thought, thanks!", "author": "tkobayas", "createdAt": "2020-07-08T05:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0ODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4OTA1Nw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r452089057", "bodyText": "As discussed with Mario, we keep ThreadLocal for now", "author": "tkobayas", "createdAt": "2020-07-09T09:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0ODIwNw=="}], "type": "inlineReview"}, {"oid": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "url": "https://github.com/kiegroup/drools/commit/b01eddfc9e8034c0fb6b255bc356092071da55a4", "message": "[BAPL-1259] Add logging for rule performance analysis\n- wip", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "3d8ebd7238423977f098ec41f4e0db3e50a6da7b", "url": "https://github.com/kiegroup/drools/commit/3d8ebd7238423977f098ec41f4e0db3e50a6da7b", "message": "- Encapsulate data in NodeStats", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "a2ef0e4cc6eed8cf4e9aab961beedd962c1f1008", "url": "https://github.com/kiegroup/drools/commit/a2ef0e4cc6eed8cf4e9aab961beedd962c1f1008", "message": "- License", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "985d0d3e24363938f6757565fac2f6cc85a2672d", "url": "https://github.com/kiegroup/drools/commit/985d0d3e24363938f6757565fac2f6cc85a2672d", "message": "- warn log. better calc", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "77b515ceb5e6e862927f050f77a323429c3c7d2e", "url": "https://github.com/kiegroup/drools/commit/77b515ceb5e6e862927f050f77a323429c3c7d2e", "message": "- applied to phreak nodes\n- moved ReteDumper to src", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "3a95c02c40a69663bfefa1b1b2b489ad0210d117", "url": "https://github.com/kiegroup/drools/commit/3a95c02c40a69663bfefa1b1b2b489ad0210d117", "message": "- applied to PhrealEvalNode\n- try/finally", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "cdb3615ca655c02736ec4b86fa2fca6c71e9c20e", "url": "https://github.com/kiegroup/drools/commit/cdb3615ca655c02736ec4b86fa2fca6c71e9c20e", "message": "- Introduced Factory to keep original PhreakNode and Constraints clean. Mertic classes are implemented as sub class", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "219553a7a632dfcb7ac39b79f1d8159be2c78d4a", "url": "https://github.com/kiegroup/drools/commit/219553a7a632dfcb7ac39b79f1d8159be2c78d4a", "message": "- fix equals", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "cedbab8213bb31643acb7b37c82d53f611289cbd", "url": "https://github.com/kiegroup/drools/commit/cedbab8213bb31643acb7b37c82d53f611289cbd", "message": "- revert pom", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "6ee0206f0390d79849ba8095e2a670879f53dc18", "url": "https://github.com/kiegroup/drools/commit/6ee0206f0390d79849ba8095e2a670879f53dc18", "message": "- remove setEnabled", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "4970a98b3d5c378d4474daf1139426fa85e4a016", "url": "https://github.com/kiegroup/drools/commit/4970a98b3d5c378d4474daf1139426fa85e4a016", "message": "- fixed code smells", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "02926f0a1fe101ffa7f90b757873e7a3ea8bfc1b", "url": "https://github.com/kiegroup/drools/commit/02926f0a1fe101ffa7f90b757873e7a3ea8bfc1b", "message": "- fixed code smells. Keep \"cloned\" private", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "9c0a70c1129313c8af65e7101dc6831e3faf2012", "url": "https://github.com/kiegroup/drools/commit/9c0a70c1129313c8af65e7101dc6831e3faf2012", "message": "- Fix/Add license\n- Removed unnecessary super()\n- Fixed access modifier", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "4202f96fbed76826d078744dc6d392ee0020d4de", "url": "https://github.com/kiegroup/drools/commit/4202f96fbed76826d078744dc6d392ee0020d4de", "message": "- Add log to ReteDumper", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "7af973cddd7ffb37a5d1d190de806f7e882dea6b", "url": "https://github.com/kiegroup/drools/commit/7af973cddd7ffb37a5d1d190de806f7e882dea6b", "message": "- fixed license", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "c6cbb56515f09c0a7d76dabb3d2a7786f18dca1d", "url": "https://github.com/kiegroup/drools/commit/c6cbb56515f09c0a7d76dabb3d2a7786f18dca1d", "message": "- moved to drools-metric", "committedDate": "2020-07-09T09:27:51Z", "type": "commit"}, {"oid": "c6cbb56515f09c0a7d76dabb3d2a7786f18dca1d", "url": "https://github.com/kiegroup/drools/commit/c6cbb56515f09c0a7d76dabb3d2a7786f18dca1d", "message": "- moved to drools-metric", "committedDate": "2020-07-09T09:27:51Z", "type": "forcePushed"}, {"oid": "f1bceab3b02781876e84acabadc9b4970ea2020d", "url": "https://github.com/kiegroup/drools/commit/f1bceab3b02781876e84acabadc9b4970ea2020d", "message": "- osgi bundle", "committedDate": "2020-07-17T02:23:05Z", "type": "commit"}, {"oid": "149b69bf34a48bf19f6c7b39f507052a295c4291", "url": "https://github.com/kiegroup/drools/commit/149b69bf34a48bf19f6c7b39f507052a295c4291", "message": "- fixed code smell", "committedDate": "2020-07-17T02:57:58Z", "type": "commit"}, {"oid": "8c6660fd9a667bf0bc5cb67a505a094cab0664c3", "url": "https://github.com/kiegroup/drools/commit/8c6660fd9a667bf0bc5cb67a505a094cab0664c3", "message": "- Removed OSGi bundle", "committedDate": "2020-07-21T01:31:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk1MzUzOA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r513953538", "bodyText": "@lucamolteni I strongly suggest to look into MethodHandle::invokeExact that disturb much less the security manager while producing less garbage too", "author": "franz1981", "createdAt": "2020-10-29T04:22:13Z", "path": "drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.drools.core.reteoo;\n+\n+import java.io.PrintWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.core.common.BaseNode;\n+import org.drools.core.impl.InternalKnowledgeBase;\n+import org.kie.api.KieBase;\n+import org.kie.api.definition.rule.Rule;\n+import org.kie.api.runtime.KieRuntime;\n+import org.kie.api.runtime.KieSession;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * \n+ * Utility class to view Rete models\n+ *\n+ */\n+public class ReteDumper {\n+\n+    private static Logger logger = LoggerFactory.getLogger(ReteDumper.class);\n+\n+    private PrintWriter writer;\n+    private StringBuilder sb;\n+    private Predicate<BaseNode> nodesFilter;\n+\n+    private boolean nodeInfoOnly = false;\n+\n+    public ReteDumper() {\n+        this(node -> true);\n+    }\n+\n+    public ReteDumper(Predicate<BaseNode> nodesFilter) {\n+        this.nodesFilter = nodesFilter;\n+    }\n+\n+    public ReteDumper(String ruleName) {\n+        this( node -> Stream.of( node.getAssociatedRules() ).anyMatch( rule -> rule.getName().equals( ruleName ) ) );\n+    }\n+\n+    public PrintWriter getWriter() {\n+        return writer;\n+    }\n+\n+    /**\n+     * Set a writer to which ReteDumper prints results. By default, results will be printed to STDOUT\n+     * @param writer\n+     */\n+    public void setWriter(PrintWriter writer) {\n+        this.writer = writer;\n+    }\n+\n+    public boolean isNodeInfoOnly() {\n+        return nodeInfoOnly;\n+    }\n+\n+    /**\n+     * If true, dump without partition/mask information. Default value is false\n+     * @param nodeInfoOnly\n+     */\n+    public void setNodeInfoOnly(boolean nodeInfoOnly) {\n+        this.nodeInfoOnly = nodeInfoOnly;\n+    }\n+\n+    public static void dumpRete(KieBase kbase ) {\n+        new ReteDumper().dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static void dumpRete(KieRuntime session ) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(KieSession session) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(InternalKnowledgeBase kBase) {\n+        new ReteDumper().dump(kBase.getRete());\n+    }\n+\n+    public static void dumpRete(Rete rete) {\n+        new ReteDumper().dump(rete);\n+    }\n+\n+    public void dump(KieBase kbase ) {\n+        dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public void dump(KieRuntime session ) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(KieSession session) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(InternalKnowledgeBase kBase) {\n+        dump(kBase.getRete());\n+    }\n+\n+    public void dump(Rete rete) {\n+        // Other dump/dumpRete methods eventually call this method\n+        sb = new StringBuilder();\n+        traverseRete(rete, this::dumpNode);\n+        printResults();\n+    }\n+\n+    private void printResults() {\n+        if (writer == null) {\n+            System.out.print(sb.toString());\n+        } else {\n+            // if a writer is given by a caller, the caller is responsible for closing\n+            writer.print(sb.toString());\n+        }\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieBase kbase ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieRuntime session ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieSession session) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(InternalKnowledgeBase kBase) {\n+        return new ReteDumper().collect(kBase.getRete());\n+    }\n+\n+    public static Set<BaseNode> collectRete(Rete rete) {\n+        return new ReteDumper().collect(rete);\n+    }\n+\n+    public Set<BaseNode> collect(KieBase kbase ) {\n+        return collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public Set<BaseNode> collect(KieRuntime session ) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(KieSession session) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(InternalKnowledgeBase kBase) {\n+        return collect(kBase.getRete());\n+    }\n+\n+    public Set<BaseNode> collect(Rete rete) {\n+        Set<BaseNode> nodes = createIdentitySet();\n+        traverseRete(rete, (node, s) -> nodes.add(node));\n+        return nodes;\n+    }\n+\n+    public void traverseRete(Rete rete, BiConsumer<BaseNode, String> consumer) {\n+        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {\n+            dumpNode( entryPointNode, \"\", createIdentitySet(), consumer);\n+        }\n+    }\n+\n+    private <T> Set<T> createIdentitySet() {\n+        return Collections.newSetFromMap(new IdentityHashMap<>());\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident, Set<BaseNode> visitedNodes, BiConsumer<BaseNode, String> consumer ) {\n+        consumer.accept( node, ident );\n+        if (!visitedNodes.add( node )) {\n+            return;\n+        }\n+        Sink[] sinks = node.getSinks();\n+        if (sinks != null) {\n+            for (Sink sink : sinks) {\n+                if (sink instanceof BaseNode) {\n+                    BaseNode sinkNode = ( BaseNode ) sink;\n+                    if ( nodesFilter.test( sinkNode ) ) {\n+                        dumpNode( sinkNode, ident + \"  \", visitedNodes, consumer );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident ) {\n+        sb.append(ident + formatNode(node));\n+        if (!nodeInfoOnly) {\n+            sb.append(\" on \" + node.getPartitionId());\n+            try {\n+                Object declaredMask = node.getClass().getMethod(\"getDeclaredMask\").invoke(node);", "originalCommit": "8c6660fd9a667bf0bc5cb67a505a094cab0664c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA0NzI1Nw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r514047257", "bodyText": "@franz1981 Thank you for the suggestion. I filed https://issues.redhat.com/browse/DROOLS-5772", "author": "tkobayas", "createdAt": "2020-10-29T07:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk1MzUzOA=="}], "type": "inlineReview"}]}