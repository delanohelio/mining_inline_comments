{"pr_number": 708, "pr_title": "Retry task release in postShutdownHook in KafkaMirrorMakerConnectorTask on interrupt", "pr_createdAt": "2020-05-02T00:08:39Z", "pr_url": "https://github.com/linkedin/brooklin/pull/708", "timeline": [{"oid": "3271d17d6c912969f32b85d0a06f47a5332ff1c4", "url": "https://github.com/linkedin/brooklin/commit/3271d17d6c912969f32b85d0a06f47a5332ff1c4", "message": "Allow finally block to complete in spite of interrupt exception in AbstractKafkaBasedConnectorTask", "committedDate": "2020-05-01T23:50:25Z", "type": "commit"}, {"oid": "268b697542fe938319da12e9a8e3d1dbe4b536c4", "url": "https://github.com/linkedin/brooklin/commit/268b697542fe938319da12e9a8e3d1dbe4b536c4", "message": "Minor fix", "committedDate": "2020-05-01T23:53:43Z", "type": "commit"}, {"oid": "dde3129bc89baafcec974e50a1e5279275e6d959", "url": "https://github.com/linkedin/brooklin/commit/dde3129bc89baafcec974e50a1e5279275e6d959", "message": "Address review comments and move interrupt handling to postShutdownHook()", "committedDate": "2020-05-02T03:08:15Z", "type": "commit"}, {"oid": "e2c641ad484ac60ba55c9dd812aa5c3f8bf5f35f", "url": "https://github.com/linkedin/brooklin/commit/e2c641ad484ac60ba55c9dd812aa5c3f8bf5f35f", "message": "Minor cleanup", "committedDate": "2020-05-02T03:10:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIxODkyNQ==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419218925", "bodyText": "nit: Please print the attempt number as well.", "author": "vmaheshw", "createdAt": "2020-05-04T05:27:26Z", "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/mirrormaker/KafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -382,10 +383,27 @@ protected void maybeCommitOffsets(Consumer<?, ?> consumer, boolean hardCommit) {\n   @Override\n   protected void postShutdownHook() {\n     if (_enablePartitionAssignment) {\n-      // The task lock should only be released when it is absolutely safe (we can guarantee that the task cannot\n-      // consume any further). The shutdown process must complete and the consumer must be closed.\n-      LOG.info(\"Releasing the lock on datastreamTask: {}\", _datastreamTask);\n-      _datastreamTask.release();\n+      boolean isInterrupted = false;\n+      for (int numAttempts = 0; numAttempts < 3; ++numAttempts) {\n+        try {\n+          // The task lock should only be released when it is absolutely safe (we can guarantee that the task cannot\n+          // consume any further). The shutdown process must complete and the consumer must be closed.\n+          LOG.info(\"Releasing the lock on datastreamTask: {}, isInterrupted: {}\", _datastreamTask, isInterrupted);", "originalCommit": "e2c641ad484ac60ba55c9dd812aa5c3f8bf5f35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTc3MQ==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419615771", "bodyText": "done", "author": "somandal", "createdAt": "2020-05-04T17:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIxODkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMTk4MA==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419221980", "bodyText": "This finally should be outside the for loop, otherwise this code will not work. The thread interrupt status will get cleared in the catch and immediately will be set again in finally.", "author": "vmaheshw", "createdAt": "2020-05-04T05:44:05Z", "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/mirrormaker/KafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -382,10 +383,27 @@ protected void maybeCommitOffsets(Consumer<?, ?> consumer, boolean hardCommit) {\n   @Override\n   protected void postShutdownHook() {\n     if (_enablePartitionAssignment) {\n-      // The task lock should only be released when it is absolutely safe (we can guarantee that the task cannot\n-      // consume any further). The shutdown process must complete and the consumer must be closed.\n-      LOG.info(\"Releasing the lock on datastreamTask: {}\", _datastreamTask);\n-      _datastreamTask.release();\n+      boolean isInterrupted = false;\n+      for (int numAttempts = 0; numAttempts < 3; ++numAttempts) {\n+        try {\n+          // The task lock should only be released when it is absolutely safe (we can guarantee that the task cannot\n+          // consume any further). The shutdown process must complete and the consumer must be closed.\n+          LOG.info(\"Releasing the lock on datastreamTask: {}, isInterrupted: {}\", _datastreamTask, isInterrupted);\n+          _datastreamTask.release();\n+          return;\n+        } catch (ZkInterruptedException e) {\n+          LOG.warn(\"Releasing the task lock failed for datastreamTask: {}, retrying\", _datastreamTask);\n+          if (Thread.currentThread().isInterrupted()) {\n+            // The interrupted status of the current thread must be reset to allow the task lock to be released\n+            isInterrupted = Thread.interrupted();\n+          }\n+        } finally {\n+          if (isInterrupted) {", "originalCommit": "e2c641ad484ac60ba55c9dd812aa5c3f8bf5f35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNjY1Mg==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419616652", "bodyText": "good catch, thanks! updated this to catch + cache exceptions other than the Interrupted one as well, reset the flag outside the loop, and then throw the cached exception if any.", "author": "somandal", "createdAt": "2020-05-04T17:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzIyMQ==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419223221", "bodyText": "This name is confusing since it is very similar to Thread.currentThread().isInterrupted(). May be a slightly different name with revert as prefix.", "author": "vmaheshw", "createdAt": "2020-05-04T05:49:38Z", "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/mirrormaker/KafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -382,10 +383,27 @@ protected void maybeCommitOffsets(Consumer<?, ?> consumer, boolean hardCommit) {\n   @Override\n   protected void postShutdownHook() {\n     if (_enablePartitionAssignment) {\n-      // The task lock should only be released when it is absolutely safe (we can guarantee that the task cannot\n-      // consume any further). The shutdown process must complete and the consumer must be closed.\n-      LOG.info(\"Releasing the lock on datastreamTask: {}\", _datastreamTask);\n-      _datastreamTask.release();\n+      boolean isInterrupted = false;", "originalCommit": "e2c641ad484ac60ba55c9dd812aa5c3f8bf5f35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNTY5Nw==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419615697", "bodyText": "sure, renamed to resetInterrupted", "author": "somandal", "createdAt": "2020-05-04T17:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMzIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIzMTc5MQ==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419231791", "bodyText": "This test will not cover the interrupted exception piece. Can you check if there is a way to add that in the test as well?", "author": "vmaheshw", "createdAt": "2020-05-04T06:25:11Z", "path": "datastream-kafka-connector/src/test/java/com/linkedin/datastream/connectors/kafka/mirrormaker/TestKafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -325,6 +333,72 @@ public void testPartitionManagedLockReleaseOnConsumerCloseException() throws Exc\n     Assert.assertTrue(releaseCall.await(10, TimeUnit.SECONDS), \"DatastreamTask never released\");\n   }\n \n+  static class KafkaMirrorMakerConnectorTaskTest extends KafkaMirrorMakerConnectorTask {\n+    boolean postShutdownHookExceptionCaught;\n+\n+    /**\n+     * Constructor for TestInterruptKafkaMirrorMakerConnectorTask\n+     * @param config Task configuration properties\n+     * @param task Datastream task\n+     * @param connectorName Connector name\n+     * @param isFlushlessModeEnabled true if {@value KafkaMirrorMakerConnector#IS_FLUSHLESS_MODE_ENABLED}\n+     *                               is set to true for the connector identified with {@code connectorName}\n+     * @param groupIdConstructor Kafka consumer group ID constructor\n+     */\n+    public KafkaMirrorMakerConnectorTaskTest(KafkaBasedConnectorConfig config, DatastreamTask task,\n+        String connectorName, boolean isFlushlessModeEnabled, GroupIdConstructor groupIdConstructor) {\n+      super(config, task, connectorName, isFlushlessModeEnabled, groupIdConstructor);\n+    }\n+\n+    @Override\n+    protected void postShutdownHook() {\n+      try {\n+        super.postShutdownHook();\n+      } catch (Exception e) {\n+        postShutdownHookExceptionCaught = true;\n+      }\n+    }\n+\n+    boolean isPostShutdownHookExceptionCaught() {\n+      return postShutdownHookExceptionCaught;\n+    }\n+  }\n+\n+  @Test\n+  public void testPartitionManagedLockReleaseOnInterruptException() throws InterruptedException {\n+    Datastream datastream = KafkaMirrorMakerConnectorTestUtils.createDatastream(\"pizzaStream\", _broker, \"\\\\w+Pizza\");\n+    DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(datastream));\n+    DatastreamEventProducer mockDatastreamEventProducer = mock(DatastreamEventProducer.class);\n+    doThrow(InterruptException.class).when(mockDatastreamEventProducer).flush();\n+    doNothing().when(mockDatastreamEventProducer).send(any(DatastreamProducerRecord.class), any(SendCallback.class));\n+    task.setEventProducer(mockDatastreamEventProducer);\n+\n+    KafkaBasedConnectorConfig connectorConfig = new KafkaBasedConnectorConfigBuilder()\n+        .setConsumerFactory(new LiKafkaConsumerFactory())\n+        .setCommitIntervalMillis(10000)\n+        .setEnablePartitionManaged(true)\n+        .build();\n+\n+    ZkAdapter zkAdatper = new ZkAdapter(_kafkaCluster.getZkConnection(), \"testCluster\", null,\n+        ZkClient.DEFAULT_SESSION_TIMEOUT, ZkClient.DEFAULT_CONNECTION_TIMEOUT, null);\n+    task.setZkAdapter(zkAdatper);\n+    zkAdatper.connect();\n+", "originalCommit": "e2c641ad484ac60ba55c9dd812aa5c3f8bf5f35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNjg2Mw==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419616863", "bodyText": "added a test for thread.interrupt().", "author": "somandal", "createdAt": "2020-05-04T17:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIzMTc5MQ=="}], "type": "inlineReview"}, {"oid": "9e80bf2671e9b03f6305dc5085a533117a663e86", "url": "https://github.com/linkedin/brooklin/commit/9e80bf2671e9b03f6305dc5085a533117a663e86", "message": "Address review comments", "committedDate": "2020-05-04T18:00:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNTMzOA==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419635338", "bodyText": "Just a suggestion, please feel free to ignore if you don't like it: would it be nicer if wrote this as:\nboolean resetInterrupted = false;\n\ntry {\n    for (int numAttempts = 1; numAttempts <= 3; ++numAttempts) {\n        try {\n            ...\n            _datastreamTask.release();\n            break;\n        } catch (ZkInterruptedException e) {\n            ...\n        }\n    }\n} finally {\n    if (resetInterrupted) {\n        // Setting the status of the thread back to interrupted\n        Thread.currentThread().interrupt();\n    }\n}\nSimply put: an outer try/finally for resetting interruption status and an inner try/catch for retrying lock release. Writing it this way spares you having to add a second catch clause with a break statement or an explicit throw.", "author": "ahmedahamid", "createdAt": "2020-05-04T18:21:41Z", "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/mirrormaker/KafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -382,10 +383,36 @@ protected void maybeCommitOffsets(Consumer<?, ?> consumer, boolean hardCommit) {\n   @Override\n   protected void postShutdownHook() {\n     if (_enablePartitionAssignment) {\n-      // The task lock should only be released when it is absolutely safe (we can guarantee that the task cannot\n-      // consume any further). The shutdown process must complete and the consumer must be closed.\n-      LOG.info(\"Releasing the lock on datastreamTask: {}\", _datastreamTask);\n-      _datastreamTask.release();\n+      DatastreamRuntimeException exception = null;\n+      boolean resetInterrupted = false;\n+      for (int numAttempts = 1; numAttempts <= 3; ++numAttempts) {\n+        try {\n+          // The task lock should only be released when it is absolutely safe (we can guarantee that the task cannot\n+          // consume any further). The shutdown process must complete and the consumer must be closed.\n+          LOG.info(\"Releasing the lock on datastreamTask: {}, was thread interrupted: {}, attempt: {}\", _datastreamTask,\n+              resetInterrupted, numAttempts);\n+          _datastreamTask.release();\n+          break;\n+        } catch (ZkInterruptedException e) {\n+          LOG.warn(\"Releasing the task lock failed for datastreamTask: {}, retrying\", _datastreamTask);\n+          if (Thread.currentThread().isInterrupted()) {\n+            // The interrupted status of the current thread must be reset to allow the task lock to be released\n+            resetInterrupted = Thread.interrupted();\n+          }\n+        } catch (Exception e) {\n+          exception = new DatastreamRuntimeException(\"Failed to perform post shutdown actions\", e);\n+          break;\n+        }\n+      }\n+\n+      if (resetInterrupted) {\n+        // Setting the status of the thread back to interrupted\n+        Thread.currentThread().interrupt();\n+      }\n+\n+      if (exception != null) {\n+        throw exception;\n+      }", "originalCommit": "9e80bf2671e9b03f6305dc5085a533117a663e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MDYwNw==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419650607", "bodyText": "done", "author": "somandal", "createdAt": "2020-05-04T18:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNTMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNjkzMQ==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419636931", "bodyText": "private", "author": "ahmedahamid", "createdAt": "2020-05-04T18:24:25Z", "path": "datastream-kafka-connector/src/test/java/com/linkedin/datastream/connectors/kafka/mirrormaker/TestKafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -325,6 +333,109 @@ public void testPartitionManagedLockReleaseOnConsumerCloseException() throws Exc\n     Assert.assertTrue(releaseCall.await(10, TimeUnit.SECONDS), \"DatastreamTask never released\");\n   }\n \n+  static class KafkaMirrorMakerConnectorTaskTest extends KafkaMirrorMakerConnectorTask {", "originalCommit": "9e80bf2671e9b03f6305dc5085a533117a663e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MDY1Mg==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419650652", "bodyText": "done", "author": "somandal", "createdAt": "2020-05-04T18:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNjkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNzE2Mg==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419637162", "bodyText": "Remove the javadocs?", "author": "ahmedahamid", "createdAt": "2020-05-04T18:24:45Z", "path": "datastream-kafka-connector/src/test/java/com/linkedin/datastream/connectors/kafka/mirrormaker/TestKafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -325,6 +333,109 @@ public void testPartitionManagedLockReleaseOnConsumerCloseException() throws Exc\n     Assert.assertTrue(releaseCall.await(10, TimeUnit.SECONDS), \"DatastreamTask never released\");\n   }\n \n+  static class KafkaMirrorMakerConnectorTaskTest extends KafkaMirrorMakerConnectorTask {\n+    boolean postShutdownHookExceptionCaught;\n+\n+    /**\n+     * Constructor for TestInterruptKafkaMirrorMakerConnectorTask\n+     * @param config Task configuration properties\n+     * @param task Datastream task\n+     * @param connectorName Connector name\n+     * @param isFlushlessModeEnabled true if {@value KafkaMirrorMakerConnector#IS_FLUSHLESS_MODE_ENABLED}\n+     *                               is set to true for the connector identified with {@code connectorName}\n+     * @param groupIdConstructor Kafka consumer group ID constructor\n+     */", "originalCommit": "9e80bf2671e9b03f6305dc5085a533117a663e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MDcwMQ==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419650701", "bodyText": "done", "author": "somandal", "createdAt": "2020-05-04T18:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNzE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNzQ1NQ==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419637455", "bodyText": "private", "author": "ahmedahamid", "createdAt": "2020-05-04T18:25:13Z", "path": "datastream-kafka-connector/src/test/java/com/linkedin/datastream/connectors/kafka/mirrormaker/TestKafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -325,6 +333,109 @@ public void testPartitionManagedLockReleaseOnConsumerCloseException() throws Exc\n     Assert.assertTrue(releaseCall.await(10, TimeUnit.SECONDS), \"DatastreamTask never released\");\n   }\n \n+  static class KafkaMirrorMakerConnectorTaskTest extends KafkaMirrorMakerConnectorTask {\n+    boolean postShutdownHookExceptionCaught;", "originalCommit": "9e80bf2671e9b03f6305dc5085a533117a663e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MDY3OA==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419650678", "bodyText": "done", "author": "somandal", "createdAt": "2020-05-04T18:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNzQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzODUzNg==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419638536", "bodyText": "Did you need this line? I think doing nothing is Mockito's default behavior (unless otherwise instructed)", "author": "ahmedahamid", "createdAt": "2020-05-04T18:26:58Z", "path": "datastream-kafka-connector/src/test/java/com/linkedin/datastream/connectors/kafka/mirrormaker/TestKafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -325,6 +333,109 @@ public void testPartitionManagedLockReleaseOnConsumerCloseException() throws Exc\n     Assert.assertTrue(releaseCall.await(10, TimeUnit.SECONDS), \"DatastreamTask never released\");\n   }\n \n+  static class KafkaMirrorMakerConnectorTaskTest extends KafkaMirrorMakerConnectorTask {\n+    boolean postShutdownHookExceptionCaught;\n+\n+    /**\n+     * Constructor for TestInterruptKafkaMirrorMakerConnectorTask\n+     * @param config Task configuration properties\n+     * @param task Datastream task\n+     * @param connectorName Connector name\n+     * @param isFlushlessModeEnabled true if {@value KafkaMirrorMakerConnector#IS_FLUSHLESS_MODE_ENABLED}\n+     *                               is set to true for the connector identified with {@code connectorName}\n+     * @param groupIdConstructor Kafka consumer group ID constructor\n+     */\n+    public KafkaMirrorMakerConnectorTaskTest(KafkaBasedConnectorConfig config, DatastreamTask task,\n+        String connectorName, boolean isFlushlessModeEnabled, GroupIdConstructor groupIdConstructor) {\n+      super(config, task, connectorName, isFlushlessModeEnabled, groupIdConstructor);\n+    }\n+\n+    @Override\n+    protected void postShutdownHook() {\n+      try {\n+        super.postShutdownHook();\n+      } catch (Exception e) {\n+        postShutdownHookExceptionCaught = true;\n+      }\n+    }\n+\n+    boolean isPostShutdownHookExceptionCaught() {\n+      return postShutdownHookExceptionCaught;\n+    }\n+  }\n+\n+  @Test\n+  public void testPartitionManagedLockReleaseOnInterruptException() throws InterruptedException {\n+    Datastream datastream = KafkaMirrorMakerConnectorTestUtils.createDatastream(\"pizzaStream\", _broker, \"\\\\w+Pizza\");\n+    DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(datastream));\n+    DatastreamEventProducer mockDatastreamEventProducer = mock(DatastreamEventProducer.class);\n+    doThrow(InterruptException.class).when(mockDatastreamEventProducer).flush();\n+    doNothing().when(mockDatastreamEventProducer).send(any(DatastreamProducerRecord.class), any(SendCallback.class));", "originalCommit": "9e80bf2671e9b03f6305dc5085a533117a663e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MDgxNw==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419650817", "bodyText": "done", "author": "somandal", "createdAt": "2020-05-04T18:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzODUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjQzMA==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419642430", "bodyText": "Would it better if we replaced this bit with\nThread connectorThread = KafkaMirrorMakerConnectorTestUtils.runKafkaMirrorMakerConnectorTask(connectorTask);\nAfter changing that method to have it return the thread it creates?", "author": "ahmedahamid", "createdAt": "2020-05-04T18:33:21Z", "path": "datastream-kafka-connector/src/test/java/com/linkedin/datastream/connectors/kafka/mirrormaker/TestKafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -325,6 +333,109 @@ public void testPartitionManagedLockReleaseOnConsumerCloseException() throws Exc\n     Assert.assertTrue(releaseCall.await(10, TimeUnit.SECONDS), \"DatastreamTask never released\");\n   }\n \n+  static class KafkaMirrorMakerConnectorTaskTest extends KafkaMirrorMakerConnectorTask {\n+    boolean postShutdownHookExceptionCaught;\n+\n+    /**\n+     * Constructor for TestInterruptKafkaMirrorMakerConnectorTask\n+     * @param config Task configuration properties\n+     * @param task Datastream task\n+     * @param connectorName Connector name\n+     * @param isFlushlessModeEnabled true if {@value KafkaMirrorMakerConnector#IS_FLUSHLESS_MODE_ENABLED}\n+     *                               is set to true for the connector identified with {@code connectorName}\n+     * @param groupIdConstructor Kafka consumer group ID constructor\n+     */\n+    public KafkaMirrorMakerConnectorTaskTest(KafkaBasedConnectorConfig config, DatastreamTask task,\n+        String connectorName, boolean isFlushlessModeEnabled, GroupIdConstructor groupIdConstructor) {\n+      super(config, task, connectorName, isFlushlessModeEnabled, groupIdConstructor);\n+    }\n+\n+    @Override\n+    protected void postShutdownHook() {\n+      try {\n+        super.postShutdownHook();\n+      } catch (Exception e) {\n+        postShutdownHookExceptionCaught = true;\n+      }\n+    }\n+\n+    boolean isPostShutdownHookExceptionCaught() {\n+      return postShutdownHookExceptionCaught;\n+    }\n+  }\n+\n+  @Test\n+  public void testPartitionManagedLockReleaseOnInterruptException() throws InterruptedException {\n+    Datastream datastream = KafkaMirrorMakerConnectorTestUtils.createDatastream(\"pizzaStream\", _broker, \"\\\\w+Pizza\");\n+    DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(datastream));\n+    DatastreamEventProducer mockDatastreamEventProducer = mock(DatastreamEventProducer.class);\n+    doThrow(InterruptException.class).when(mockDatastreamEventProducer).flush();\n+    doNothing().when(mockDatastreamEventProducer).send(any(DatastreamProducerRecord.class), any(SendCallback.class));\n+    task.setEventProducer(mockDatastreamEventProducer);\n+\n+    KafkaBasedConnectorConfig connectorConfig = new KafkaBasedConnectorConfigBuilder()\n+        .setConsumerFactory(new LiKafkaConsumerFactory())\n+        .setCommitIntervalMillis(10000)\n+        .setEnablePartitionManaged(true)\n+        .build();\n+\n+    ZkAdapter zkAdatper = new ZkAdapter(_kafkaCluster.getZkConnection(), \"testCluster\", null,\n+        ZkClient.DEFAULT_SESSION_TIMEOUT, ZkClient.DEFAULT_CONNECTION_TIMEOUT, null);\n+    task.setZkAdapter(zkAdatper);\n+    zkAdatper.connect();\n+\n+    KafkaMirrorMakerConnectorTaskTest connectorTask = new KafkaMirrorMakerConnectorTaskTest(connectorConfig, task, \"\",\n+        false, new KafkaMirrorMakerGroupIdConstructor(false, \"testCluster\"));\n+    Thread connectorThread = new Thread(connectorTask, \"connector thread\");\n+    connectorThread.setDaemon(true);\n+    AtomicReference<Throwable> uncaughtException = new AtomicReference<>();\n+    connectorThread.setUncaughtExceptionHandler((t, e) -> uncaughtException.set(e));\n+    connectorThread.start();\n+    if (!connectorTask.awaitStart(60, TimeUnit.SECONDS)) {\n+      Assert.fail(\"connector did not start within timeout\");\n+    }", "originalCommit": "9e80bf2671e9b03f6305dc5085a533117a663e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MDkyNw==", "url": "https://github.com/linkedin/brooklin/pull/708#discussion_r419650927", "bodyText": "done", "author": "somandal", "createdAt": "2020-05-04T18:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjQzMA=="}], "type": "inlineReview"}, {"oid": "4bd6795be1e93f6f44518a96fbfcb2af9b2f779f", "url": "https://github.com/linkedin/brooklin/commit/4bd6795be1e93f6f44518a96fbfcb2af9b2f779f", "message": "Address review comments", "committedDate": "2020-05-04T18:57:10Z", "type": "commit"}]}