{"pr_number": 713, "pr_title": "Fix KeyedMeter metrics in the Coordinator", "pr_createdAt": "2020-05-21T05:31:45Z", "pr_url": "https://github.com/linkedin/brooklin/pull/713", "timeline": [{"oid": "b9d858871beed74f2583c20269b99f61a57e816b", "url": "https://github.com/linkedin/brooklin/commit/b9d858871beed74f2583c20269b99f61a57e816b", "message": "Fix KeyedMeter metrics in the Coordinator\n\nThis change fixes a discrepancy between the names of the KeyedMeter\nobjects registered with the DynamicMetricsManager and the BrooklinMetricInfo\nobjects returned by the Coordinator.", "committedDate": "2020-05-21T05:30:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNDU1MA==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r428814550", "bodyText": "nothing wrong with what you have done. But can you consider the alternative ,as well, used in other classes?\nString prefix = CLASS_NAME + MetricsAware.KEY_REGEX; instead of module ? This is how other classes have handled this scenario.", "author": "vmaheshw", "createdAt": "2020-05-21T17:51:23Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1769,7 +1769,7 @@ private void registerMeter(Meter metric) {\n     private void registerKeyedMeter(KeyedMeter metric) {\n       String metricName = metric.getName();\n       _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n-      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metric.getKey(), metricName)));", "originalCommit": "b9d858871beed74f2583c20269b99f61a57e816b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MTk1OA==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r429581958", "bodyText": "Thank you so much for bringing this to my attention.\nThis question led me to have a conversation with Celia (the feature author) about how metrics work and when regex-based BrooklinMetricInfo objects should be used. It turns out there are quite a few interesting details that got me to revisit the way some of the Coordinator metrics are registered/created. I'll put together a short writeup to summarize the key aspects and best practices.\nAs far as this code change is concerned, here are the adjustments I made:\n\nAll KeyedMeter objects have been changed to be lazily created. This involves:\n\nCreating them lazily using DynamicMetricsManager.createOrUpdate*()  as opposed to DynamicMetricsManager.register*())\nAdding regex-based BrooklinMetricInfo objects for them as you suggested\n\n\nMoving the metric below to be a Meter instead of a KeyedMeter since it doesn't follow the same naming pattern\nPERFORM_CLEANUP_ORPHAN_CONNECTOR_TASKS(\"performCleanupOrphanConnectorTasks\", \"numOrphanConnectorTasks\"),", "author": "ahmedahamid", "createdAt": "2020-05-23T22:08:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNDU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNTMyMg==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r428815322", "bodyText": "any particular reason to name variable actualMetricClazz and not actualMetricClass", "author": "vmaheshw", "createdAt": "2020-05-21T17:52:49Z", "path": "datastream-server-restli/src/test/java/com/linkedin/datastream/server/TestCoordinator.java", "diffHunk": "@@ -174,6 +183,54 @@ public void teardown() throws IOException {\n     _embeddedZookeeper.shutdown();\n   }\n \n+  @Test\n+  public void testRegistersMetricsCorrectly() throws Exception {\n+    String testCluster = \"testCoordinatorMetrics\";\n+    Coordinator coordinator = createCoordinator(_zkConnectionString, testCluster);\n+    coordinator.start();\n+\n+    // Make sure the set of metrics the Coordinator registers with the DynamicMetricsManager\n+    // matches the metricInfos the Coordinator returns from getMetricInfos().\n+    List<BrooklinMetricInfo> metricInfos = coordinator.getMetricInfos();\n+    DynamicMetricsManager metricsManager = DynamicMetricsManager.getInstance();\n+\n+    String coordinatorSimpleClassName = Coordinator.class.getSimpleName();\n+    // Keep Coordinator metricInfos\n+    Map<String, BrooklinMetricInfo> metricInfoByName = metricInfos.stream()\n+        .filter(info -> info.getNameOrRegex().startsWith(coordinatorSimpleClassName))\n+        .collect(Collectors.toMap(BrooklinMetricInfo::getNameOrRegex, Function.identity()));\n+\n+    // Keep Coordinator metrics\n+    Map<String, Metric> metrics = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(entry -> entry.getKey().startsWith(coordinatorSimpleClassName))\n+        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+    Assert.assertEquals(metricInfoByName.size(), metrics.size());\n+\n+    // Mapping of BrooklinMetricInfo sub-type -> com.codahale.metrics type\n+    Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> metricInfoTypeToMetricType = new HashMap<>();\n+    metricInfoTypeToMetricType.put(BrooklinCounterInfo.class, Counter.class);\n+    metricInfoTypeToMetricType.put(BrooklinGaugeInfo.class, Gauge.class);\n+    metricInfoTypeToMetricType.put(BrooklinHistogramInfo.class, Histogram.class);\n+    metricInfoTypeToMetricType.put(BrooklinMeterInfo.class, Meter.class);\n+\n+    for (Map.Entry<String, BrooklinMetricInfo> entry : metricInfoByName.entrySet()) {\n+      String metricInfoKey = entry.getKey();\n+      BrooklinMetricInfo metricInfo = entry.getValue();\n+\n+      // For every BrooklinMetricInfo, there must be a registered codahale metric\n+      Metric metric = metrics.get(metricInfoKey);\n+      Assert.assertNotNull(metric);\n+\n+      // The registered codahale metric type must correspond to the BrooklinMetricInfo sub-type\n+      Class<? extends Metric> actualMetricClazz = metric.getClass();", "originalCommit": "b9d858871beed74f2583c20269b99f61a57e816b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNzgzNA==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r428817834", "bodyText": "Java tradition (sigh): https://stackoverflow.com/questions/2529974/why-do-java-programmers-like-to-name-a-variable-clazz", "author": "ahmedahamid", "createdAt": "2020-05-21T17:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNTMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MTIyOQ==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r429581229", "bodyText": "That code was moved into a dedicated utility for validating metrics. I also changed the code to use Class instead of Clazz since it's not used on its own but as part of a longer identifier.", "author": "ahmedahamid", "createdAt": "2020-05-23T21:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxNTMyMg=="}], "type": "inlineReview"}, {"oid": "152dd079a7d6c3160ee39eb5ec533cb97c417906", "url": "https://github.com/linkedin/brooklin/commit/152dd079a7d6c3160ee39eb5ec533cb97c417906", "message": "Lazily create KeyedMeter metrics and introduce utility for validating metrics", "committedDate": "2020-05-23T21:52:00Z", "type": "commit"}, {"oid": "5dadfbb2d1c75f07f4710288a965a5e32cd32b2c", "url": "https://github.com/linkedin/brooklin/commit/5dadfbb2d1c75f07f4710288a965a5e32cd32b2c", "message": "Fix compilation warning", "committedDate": "2020-05-23T22:18:03Z", "type": "commit"}, {"oid": "43527b61fefdbfa6c82d9a407073e276a520f860", "url": "https://github.com/linkedin/brooklin/commit/43527b61fefdbfa6c82d9a407073e276a520f860", "message": "Add license header", "committedDate": "2020-05-24T04:33:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5NDg0MA==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r432594840", "bodyText": "nit whitespace missing before ':'", "author": "vmaheshw", "createdAt": "2020-05-29T16:20:10Z", "path": "datastream-testcommon/src/main/java/com/linkedin/datastream/testutil/MetricsTestUtils.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ *  Copyright 2020 LinkedIn Corporation. All rights reserved.\n+ *  Licensed under the BSD 2-Clause License. See the LICENSE file in the project root for license information.\n+ *  See the NOTICE file in the project root for additional information regarding copyright ownership.\n+ */\n+package com.linkedin.datastream.testutil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.testng.Assert;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.Gauge;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Metric;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linkedin.datastream.metrics.BrooklinCounterInfo;\n+import com.linkedin.datastream.metrics.BrooklinGaugeInfo;\n+import com.linkedin.datastream.metrics.BrooklinHistogramInfo;\n+import com.linkedin.datastream.metrics.BrooklinMeterInfo;\n+import com.linkedin.datastream.metrics.BrooklinMetricInfo;\n+import com.linkedin.datastream.metrics.DynamicMetricsManager;\n+import com.linkedin.datastream.metrics.MetricsAware;\n+\n+\n+/**\n+ * Test utilities for verifying metrics\n+ * @see MetricsAware\n+ */\n+public class MetricsTestUtils {\n+  // Mapping of BrooklinMetricInfo sub-types -> com.codahale.metrics types\n+  private static final Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> METRICS_TYPE_MAPPING = ImmutableMap.of(\n+      BrooklinCounterInfo.class, Counter.class,\n+      BrooklinGaugeInfo.class, Gauge.class,\n+      BrooklinHistogramInfo.class, Histogram.class,\n+      BrooklinMeterInfo.class, Meter.class);\n+\n+  private MetricsTestUtils() {\n+  }\n+\n+  /**\n+   * @see #verifyMetrics(MetricsAware, DynamicMetricsManager, Predicate)\n+   *\n+   * This verification only covers {@link Metric} and {@link BrooklinMetricInfo} objects whose\n+   * names start with the provided {@code metricsAware}'s simple class name.\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager) {\n+    verifyMetrics(metricsAware, metricsManager, s -> s.startsWith(metricsAware.getClass().getSimpleName()));\n+  }\n+\n+  /**\n+   * Verifies consistency between:\n+   * <ol>\n+   *   <li>{@link BrooklinMetricInfo} objects returned by the specified {@code metricsAware}\n+   *   (specifically {@link MetricsAware#getMetricInfos()}) after filtering them using {@code metricFilter}</li>\n+   *   <li>{@link Metric} objects registered with the specified {@code metricsManager} after filtering them\n+   *   using {@code metricFilter}</li>\n+   * </ol>\n+   *\n+   * In particular, it verifies that:\n+   * <ul>\n+   *   <li>All {@link BrooklinMetricInfo} are distinct</li>\n+   *   <li>Every {@link Metric} object has exactly one {@link BrooklinMetricInfo} object whose\n+   *   {@link BrooklinMetricInfo#getNameOrRegex()} matches the metric's name</li>\n+   *   <li>Every {@link Metric} is matched with a {@link BrooklinMetricInfo} object whose concrete\n+   *   type matches the metric's type according to {@link MetricsTestUtils#METRICS_TYPE_MAPPING}</li>\n+   * </ul>\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager,\n+      Predicate<String> metricFilter) {\n+\n+    List<BrooklinMetricInfo> metricInfos = metricsAware.getMetricInfos().stream()\n+        .filter(metricInfo -> metricFilter.test(metricInfo.getNameOrRegex()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that all metricInfos are distinct\n+    Assert.assertEquals(metricInfos.size(), metricInfos.stream().distinct().count(),\n+        \"The supplied metricsAware returned duplicate BrooklinMetricInfo objects\");\n+\n+    Map<String, BrooklinMetricInfo> metricInfoByName = new HashMap<>();\n+    List<BrooklinMetricInfo> regexMetricInfos = new ArrayList<>();\n+    classifyMetricInfos(metricInfos, metricInfoByName, regexMetricInfos);\n+\n+    Collection<Map.Entry<String, Metric>> metricEntries = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(metricEntry -> metricFilter.test(metricEntry.getKey()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that every metric has exactly one metricInfo whose nameOrRegex matches the metric's name\n+    for (Map.Entry<String, Metric> metricEntry: metricEntries) {", "originalCommit": "43527b61fefdbfa6c82d9a407073e276a520f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0Mjc3Mw==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r432642773", "bodyText": "Fixed. Thanks for the catch.", "author": "ahmedahamid", "createdAt": "2020-05-29T17:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5NDg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwNDUzNw==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r432604537", "bodyText": "I see that you changed clazz to class. My last comment around it was to understand the reasoning and not object the naming convention. After you mentioned, I noticed in other places where clazz is getting used instead of class.", "author": "vmaheshw", "createdAt": "2020-05-29T16:38:43Z", "path": "datastream-testcommon/src/main/java/com/linkedin/datastream/testutil/MetricsTestUtils.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ *  Copyright 2020 LinkedIn Corporation. All rights reserved.\n+ *  Licensed under the BSD 2-Clause License. See the LICENSE file in the project root for license information.\n+ *  See the NOTICE file in the project root for additional information regarding copyright ownership.\n+ */\n+package com.linkedin.datastream.testutil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.testng.Assert;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.Gauge;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.Metric;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linkedin.datastream.metrics.BrooklinCounterInfo;\n+import com.linkedin.datastream.metrics.BrooklinGaugeInfo;\n+import com.linkedin.datastream.metrics.BrooklinHistogramInfo;\n+import com.linkedin.datastream.metrics.BrooklinMeterInfo;\n+import com.linkedin.datastream.metrics.BrooklinMetricInfo;\n+import com.linkedin.datastream.metrics.DynamicMetricsManager;\n+import com.linkedin.datastream.metrics.MetricsAware;\n+\n+\n+/**\n+ * Test utilities for verifying metrics\n+ * @see MetricsAware\n+ */\n+public class MetricsTestUtils {\n+  // Mapping of BrooklinMetricInfo sub-types -> com.codahale.metrics types\n+  private static final Map<Class<? extends BrooklinMetricInfo>, Class<? extends Metric>> METRICS_TYPE_MAPPING = ImmutableMap.of(\n+      BrooklinCounterInfo.class, Counter.class,\n+      BrooklinGaugeInfo.class, Gauge.class,\n+      BrooklinHistogramInfo.class, Histogram.class,\n+      BrooklinMeterInfo.class, Meter.class);\n+\n+  private MetricsTestUtils() {\n+  }\n+\n+  /**\n+   * @see #verifyMetrics(MetricsAware, DynamicMetricsManager, Predicate)\n+   *\n+   * This verification only covers {@link Metric} and {@link BrooklinMetricInfo} objects whose\n+   * names start with the provided {@code metricsAware}'s simple class name.\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager) {\n+    verifyMetrics(metricsAware, metricsManager, s -> s.startsWith(metricsAware.getClass().getSimpleName()));\n+  }\n+\n+  /**\n+   * Verifies consistency between:\n+   * <ol>\n+   *   <li>{@link BrooklinMetricInfo} objects returned by the specified {@code metricsAware}\n+   *   (specifically {@link MetricsAware#getMetricInfos()}) after filtering them using {@code metricFilter}</li>\n+   *   <li>{@link Metric} objects registered with the specified {@code metricsManager} after filtering them\n+   *   using {@code metricFilter}</li>\n+   * </ol>\n+   *\n+   * In particular, it verifies that:\n+   * <ul>\n+   *   <li>All {@link BrooklinMetricInfo} are distinct</li>\n+   *   <li>Every {@link Metric} object has exactly one {@link BrooklinMetricInfo} object whose\n+   *   {@link BrooklinMetricInfo#getNameOrRegex()} matches the metric's name</li>\n+   *   <li>Every {@link Metric} is matched with a {@link BrooklinMetricInfo} object whose concrete\n+   *   type matches the metric's type according to {@link MetricsTestUtils#METRICS_TYPE_MAPPING}</li>\n+   * </ul>\n+   */\n+  public static void verifyMetrics(MetricsAware metricsAware, DynamicMetricsManager metricsManager,\n+      Predicate<String> metricFilter) {\n+\n+    List<BrooklinMetricInfo> metricInfos = metricsAware.getMetricInfos().stream()\n+        .filter(metricInfo -> metricFilter.test(metricInfo.getNameOrRegex()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that all metricInfos are distinct\n+    Assert.assertEquals(metricInfos.size(), metricInfos.stream().distinct().count(),\n+        \"The supplied metricsAware returned duplicate BrooklinMetricInfo objects\");\n+\n+    Map<String, BrooklinMetricInfo> metricInfoByName = new HashMap<>();\n+    List<BrooklinMetricInfo> regexMetricInfos = new ArrayList<>();\n+    classifyMetricInfos(metricInfos, metricInfoByName, regexMetricInfos);\n+\n+    Collection<Map.Entry<String, Metric>> metricEntries = metricsManager.getMetricRegistry().getMetrics().entrySet().stream()\n+        .filter(metricEntry -> metricFilter.test(metricEntry.getKey()))\n+        .collect(Collectors.toList());\n+\n+    // Assert that every metric has exactly one metricInfo whose nameOrRegex matches the metric's name\n+    for (Map.Entry<String, Metric> metricEntry: metricEntries) {\n+      int count = getMatchingMetricInfoCount(metricEntry, metricInfoByName, regexMetricInfos);\n+      Assert.assertEquals(count, 1,\n+          String.format(\"Metric %s must match exactly one BrooklinMetricInfo but it matched %d\",\n+              metricEntry.getKey(), count));\n+    }\n+  }\n+\n+  private static void classifyMetricInfos(Collection<BrooklinMetricInfo> metricInfos,\n+      Map<String, BrooklinMetricInfo> metricInfoByName, List<BrooklinMetricInfo> regexMetricInfos) {\n+    for (BrooklinMetricInfo metricInfo : metricInfos) {\n+      String nameOrRegex = metricInfo.getNameOrRegex();\n+      if (nameOrRegex.contains(MetricsAware.KEY_REGEX)) {\n+        regexMetricInfos.add(metricInfo);\n+      } else {\n+        metricInfoByName.put(nameOrRegex, metricInfo);\n+      }\n+    }\n+  }\n+\n+  private static int getMatchingMetricInfoCount(Map.Entry<String, Metric> metricEntry,\n+      Map<String, BrooklinMetricInfo> metricInfoByName, List<BrooklinMetricInfo> regexMetricInfos) {\n+    int count = 0;\n+\n+    String metricName = metricEntry.getKey();\n+    if (metricInfoByName.containsKey(metricName)) {\n+      BrooklinMetricInfo metricInfo = metricInfoByName.get(metricName);\n+      assertTypeCompatibility(metricInfo, metricEntry);\n+      ++count;\n+    }\n+\n+    for (BrooklinMetricInfo metricInfo : regexMetricInfos) {\n+      if (metricName.matches(metricInfo.getNameOrRegex())) {\n+        assertTypeCompatibility(metricInfo, metricEntry);\n+        ++count;\n+      }\n+    }\n+\n+    return count;\n+  }\n+\n+  private static void assertTypeCompatibility(BrooklinMetricInfo metricInfo, Map.Entry<String, Metric> metricEntry) {\n+    String metricName = metricEntry.getKey();\n+    Metric metric = metricEntry.getValue();\n+\n+    Class<? extends BrooklinMetricInfo> metricInfoClass = metricInfo.getClass();", "originalCommit": "43527b61fefdbfa6c82d9a407073e276a520f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MTA1MQ==", "url": "https://github.com/linkedin/brooklin/pull/713#discussion_r432641051", "bodyText": "No worries at all. I did explain why I preferred doing that eventually in my response to your earlier comment.", "author": "ahmedahamid", "createdAt": "2020-05-29T17:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwNDUzNw=="}], "type": "inlineReview"}, {"oid": "7dc012f17af54a1c13a3cc1f992b3e0f1d22227a", "url": "https://github.com/linkedin/brooklin/commit/7dc012f17af54a1c13a3cc1f992b3e0f1d22227a", "message": "Address PR review comments", "committedDate": "2020-05-29T17:46:44Z", "type": "commit"}]}