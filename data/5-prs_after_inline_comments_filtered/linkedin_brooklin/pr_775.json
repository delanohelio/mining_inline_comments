{"pr_number": 775, "pr_title": "Fix multiple issues found in the partition movement code", "pr_createdAt": "2020-11-04T15:52:38Z", "pr_url": "https://github.com/linkedin/brooklin/pull/775", "timeline": [{"oid": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "url": "https://github.com/linkedin/brooklin/commit/df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "message": "Fix multiple issues found in the partition movement code", "committedDate": "2020-11-04T15:41:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MjY0Nw==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r519062647", "bodyText": "Nit: Avoid unnecessary changes to make reviews shorter.", "author": "jzakaryan", "createdAt": "2020-11-07T00:04:51Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java", "diffHunk": "@@ -182,14 +177,13 @@ public void testMovePartitionToInstanceWithoutTask() {\n         new DatastreamGroupPartitionsMetadata(datastreams.get(0), partitions);\n     // Generate partition assignment\n     assignment = strategy.assignPartitions(assignment, partitionsMetadata);\n-    assignment.put(\"empty\", new HashSet<DatastreamTask>());\n+    assignment.put(\"empty\", new HashSet<>());\n \n     Map<String, Set<String>> targetAssignment = new HashMap<>();\n     targetAssignment.put(\"empty\", ImmutableSet.of(\"t-3\", \"t-2\", \"t-1\", \"t-5\"));\n-    assignment = strategy.movePartitions(assignment, targetAssignment, partitionsMetadata);\n+    strategy.movePartitions(assignment, targetAssignment, partitionsMetadata);\n   }\n \n-", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDIyMg==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520934222", "bodyText": "nits: tasks to task", "author": "vmaheshw", "createdAt": "2020-11-10T23:14:31Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -151,11 +152,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Preprocess the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source task\n+   * Step 3) If the instance is the one we want to move, we choose a task to which we should assign the partition\n    *         from that instance\n-   * Step 3) Scan the current assignment, compute new task if the old task belongs to these source tasks or if it\n-   *         is the target task we want to move to\n+   * Step 4) Scan the current assignment, compute the new task if the old task belongs to this source tasks or if it", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxOTU4Mw==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521019583", "bodyText": "done", "author": "somandal", "createdAt": "2020-11-11T02:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDQxOQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520934419", "bodyText": "nit: task to tasks, preprocess to pre-process", "author": "vmaheshw", "createdAt": "2020-11-10T23:15:01Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -151,11 +152,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Preprocess the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source task", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxOTQ5NA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521019494", "bodyText": "done", "author": "somandal", "createdAt": "2020-11-11T02:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNDQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520936630", "bodyText": "addAll with throw NullPointerException for the value set to null. The value is set to null for the instance where there is no movement.", "author": "vmaheshw", "createdAt": "2020-11-10T23:20:33Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)\n+          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n+\n+      Set<String> updatedTargetPartitionList = new HashSet<>(partitions);\n+      updatedTargetPartitionList.removeAll(partitionsAcrossAllDatastreamTasks);\n+\n+      preprocessedTargetAssignment.computeIfAbsent(instance,\n+          val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n+    });\n+\n+    LOG.info(\"The preprocessed targetAssignment: {}\", preprocessedTargetAssignment);\n+\n     Set<String> allToReassignPartitions = new HashSet<>();\n-    targetAssignment.values().forEach(allToReassignPartitions::addAll);\n+    preprocessedTargetAssignment.values().forEach(allToReassignPartitions::addAll);", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODAwNQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520958005", "bodyText": "In the previous step, where we create preprocessedTargetAssignment, the computeIfAbsent does not add the key to the map if the computed value is null. I've modified this to filter out null values anyways just to be safe, but using addAll here without null checks should be safe.\nCode that updates preProcessedTargetAssignment:\n      preProcessedTargetAssignment.computeIfAbsent(instance,\n          val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n\nComments on computeIfAbsent:\n\n* If the specified key is not already associated with a value (or is mapped\n* to {@code null}), attempts to compute its value using the given mapping\n* function and enters it into this map unless {@code null}.\n\n\nI had also validated that conputeIfAbsent works as expected for null values using some test cases when writing the code.", "author": "somandal", "createdAt": "2020-11-11T00:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTUwNg==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520961506", "bodyText": "Make sense. You can ignore this comment.\nFeel free to ignore this suggestion. Just wondering should we make this piece more simple and readable.\nif (!updatedTargetPartitionList.isEmpty()) {\npreProcessedTargetAssignment.put(instance, updatedTargetPartitionList);\n}", "author": "vmaheshw", "createdAt": "2020-11-11T00:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwNTgzMQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521005831", "bodyText": "I sort of prefer computeIfAbsent here, so will leave this as is.", "author": "somandal", "createdAt": "2020-11-11T01:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNjYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzQ2Mg==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520937462", "bodyText": "Can you merge these two lines?", "author": "vmaheshw", "createdAt": "2020-11-10T23:22:47Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -170,17 +173,35 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n \n     DatastreamGroup dg = partitionsMetadata.getDatastreamGroup();\n \n+    // Pre-process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n+    // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on instance1\n+    // and is supposed to move to instance1, remove it from the targetAssignment as this should be a no-op.\n+    Map<String, Set<String>> preprocessedTargetAssignment = new HashMap<>();\n+    targetAssignment.forEach((instance, partitions) -> {\n+      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n+      Set<String> partitionsAcrossAllDatastreamTasks = tasks.stream().filter(dg::belongsTo)", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxOTY0OQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521019649", "bodyText": "done", "author": "somandal", "createdAt": "2020-11-11T02:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkzNzQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520946468", "bodyText": "I feel we can avoid splitting this in two steps. Please check and let me know your opinion.\n    // If the partitions cannot be found from any task, we ignore these partitions\n    currentAssignment.keySet().forEach(instance -> {\n      Set<DatastreamTask> tasks = currentAssignment.get(instance);\n      Set<String> partitionsAcrossAllDatastreamTasks = currentAssignment.get(instance).stream().filter(dg::belongsTo)\n          .map(DatastreamTask::getPartitionsV2).flatMap(Collection::stream).collect(Collectors.toSet());\n      //Remove the partitions that do not need migration.\n      allToReassignPartitions.removeAll(partitionsAcrossAllDatastreamTasks);\n      tasks.forEach(task -> {\n        if (dg.belongsTo(task)) {\n          Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n          toMovePartitions.retainAll(allToReassignPartitions);\n          if (!toMovePartitions.isEmpty()) {\n            // Only update the confirmedPartitionsTaskMap if a partition is indeed being deleted from it\n            confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n            toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, (DatastreamTaskImpl) task));\n          }\n        }\n      });\n    });`", "author": "vmaheshw", "createdAt": "2020-11-10T23:47:16Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -190,15 +211,18 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n         if (dg.belongsTo(task)) {\n           Set<String> toMovePartitions = new HashSet<>(task.getPartitionsV2());\n           toMovePartitions.retainAll(allToReassignPartitions);\n-          confirmedPartitionsTaskMap.put(task.getDatastreamTaskName(), toMovePartitions);\n-          toMovePartitions.forEach(p -> partitionToSourceTaskMap.put(p, task.getDatastreamTaskName()));\n+          if (!toMovePartitions.isEmpty()) {", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwNTA2Mg==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521005062", "bodyText": "I tried this as is, but it doesn't work (preprocessedTargetAssignment is used in a later step, so I also added code here to create this too - but that isn't what kept breaking) and it's also getting very tricky to get it to work. Just removing the partitionsAcrossAllDatastreamTasks from allToReassignPartitions results in allToReassignPartitions becoming empty by the end of the lambda. I tried creating a copy of allToReassignPartitions too, and removed from that, but  the logic wasn't correct. Tried to retain all of partitionsAcrossAllDatastreamTasks, then there are issues with creating the confirmedPartitionsTaskMap, and when I try to fix that then I see that some partitions are completely removed from the final assignment, etc.\nAt least for me, this code is quite tricky to reason with, so the two step assignment just feels cleaner and easier to understand. It may be okay to perform a two step process here, since it's just recalculating the assignments. What do you think?", "author": "somandal", "createdAt": "2020-11-11T01:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA0OTU4NQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521049585", "bodyText": "Found a way to make this work. Silly me should have tried moving the update of allToReassignPartitions to within the targetAssignment.containsKey() block.", "author": "somandal", "createdAt": "2020-11-11T02:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMzU0OQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521113549", "bodyText": "Can you please check this code block? This logic is correct (with one minor addition required) but not so easy to get it.\n if (targetAssignment.containsKey(instance)) {\n        // Process the targetAssignment to filter out partitions that are supposed to move to the target instance that\n        // they are already on to avoid unnecessary partition movements. That is, if partition1 is currently on\n        // instance1 and is supposed to move to instance1, remove it from the targetAssignment as this should be a\n        // no-op. Accordingly the allToReassignPartitions should also be updated to remove such partitions.\n        //Partitions not suppose to move\n        Set<String> partitionsRemovedFromTargetAssignment = new HashSet<>(targetAssignment.get(instance));\n        partitionsRemovedFromTargetAssignment.retainAll(partitionsAcrossAllDatastreamTasks);\n\n        Set<String> updatedTargetPartitionList = new HashSet<>(targetAssignment.get(instance));\n        updatedTargetPartitionList.removeAll(partitionsRemovedFromTargetAssignment);\n        // filter invalid partitions\n        updatedTargetPartitionList.retainAll(allToReassignPartitions);\n\n        processedTargetAssignment.computeIfAbsent(instance,\n            val -> updatedTargetPartitionList.isEmpty() ? null : updatedTargetPartitionList);\n\n        allToReassignPartitions.removeAll(partitionsRemovedFromTargetAssignment);\n      }`\n\nIn this, I have reordered your calls,\na. first find the partitions  from the target, which are not moving. \nb. Remove these partitions from the targetAssignment and retain  only the valid partitions in allToReassignPartitions (missing in your code) and save it in updatedTargetPartitionList\nc. Remove these partitions from allToReassignPartitions", "author": "vmaheshw", "createdAt": "2020-11-11T04:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyMjI0MA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521122240", "bodyText": "done.\n\nb. Remove these partitions from the targetAssignment and retain  only the valid partitions in allToReassignPartitions (missing in your code) and save it in updatedTargetPartitionList\n\nThat step isn't really necessary (though I added it) since allToReassignPartitions has already filtered out invalid partitions, and all the other data-structures are created based on this.", "author": "somandal", "createdAt": "2020-11-11T05:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NzY0Nw==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520947647", "bodyText": "Sorry for my ignorance. I'm not able to find anything changing in the next few code diff blocks, except empty lines. Just want to be sure that I'm not missing anything.", "author": "vmaheshw", "createdAt": "2020-11-10T23:50:42Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -228,37 +251,39 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n           .reduce((task1, task2) -> task1.getPartitionsV2().size() < task2.getPartitionsV2().size() ? task1 : task2)\n           .get() : null;\n \n-        // compute new assignment for that instance\n-        Set<DatastreamTask> newAssignedTask = tasks.stream().map(task -> {\n-          if (!dg.belongsTo(task)) {\n-            return task;\n-          }\n-          boolean partitionChanged = false;\n-          List<String> newPartitions = new ArrayList<>(task.getPartitionsV2());\n-          Set<String> extraDependencies = new HashSet<>();\n+      // compute new assignment for that instance\n+      Set<DatastreamTask> newAssignedTask = tasks.stream().map(task -> {", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwODA4OA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521008088", "bodyText": "yeah sorry, there was an indentation issue in this part of the code, so just fixed that. next time i'll do this as part of a separate change.", "author": "somandal", "createdAt": "2020-11-11T01:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NzY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODAwNw==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948007", "bodyText": "nit: mockZkAdapter2 to mockZkAdapter0", "author": "vmaheshw", "createdAt": "2020-11-10T23:51:47Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDQ3NA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020474", "bodyText": "moved to a separate function", "author": "somandal", "createdAt": "2020-11-11T02:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODc1MA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948750", "bodyText": "Nit: Not your fault, Do you think this test can be changed to validate the exception using AssertThrows to ensure that all the blocks including the new code is getting executed.", "author": "vmaheshw", "createdAt": "2020-11-10T23:54:01Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDU1Nw==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020557", "bodyText": "done", "author": "somandal", "createdAt": "2020-11-11T02:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODk1OA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520948958", "bodyText": "same nit: mockZkAdapter2 to 0, here and other places.", "author": "vmaheshw", "createdAt": "2020-11-10T23:54:34Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDYxNg==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020616", "bodyText": "moved to a separate function", "author": "somandal", "createdAt": "2020-11-11T02:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTIzMQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520949231", "bodyText": "Also, do you see a value of extracting the method for this new duplicate code block?", "author": "vmaheshw", "createdAt": "2020-11-10T23:55:17Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDY5MA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020690", "bodyText": "done", "author": "somandal", "createdAt": "2020-11-11T02:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTM5Nw==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r520949397", "bodyText": "Please transform this test to AssertThrows as well.", "author": "vmaheshw", "createdAt": "2020-11-10T23:55:45Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/TestDatastreamTask.java", "diffHunk": "@@ -38,47 +38,84 @@\n public class TestDatastreamTask {\n \n   @Test\n-  public void testAcquireWithDependencies() throws Exception {\n+  public void testAcquireWithDependencies() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n \n-    task.addDependency(\"task0\");\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     task.acquire(Duration.ofMillis(60));\n     verify(mockZkAdapter, atLeastOnce()).waitForDependencies(any(DatastreamTaskImpl.class), any(Duration.class));\n   }\n \n   @Test(expectedExceptions = DatastreamTransientException.class)\n-  public void testCreateNewTaskFromUnlockedTask() throws Exception {\n+  public void testCreateNewTaskFromUnlockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n     task.setPartitionsV2(ImmutableList.of(\"partition1\"));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(false);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n   }\n \n   @Test\n-  public void testCreateNewTaskFromLockedTask() throws Exception {\n+  public void testCreateNewTaskFromLockedTask() {\n     Datastream stream = DatastreamTestUtils.createDatastream(\"dummy\", \"dummy\", \"dummy\");\n     stream.getMetadata().put(DatastreamMetadataConstants.TASK_PREFIX, DatastreamTaskImpl.getTaskPrefix(stream));\n \n     DatastreamTaskImpl task = new DatastreamTaskImpl(Collections.singletonList(stream));\n-    task.addDependency(\"task0\");\n+\n     ZkAdapter mockZkAdapter = mock(ZkAdapter.class);\n     task.setZkAdapter(mockZkAdapter);\n+\n+    DatastreamTaskImpl task0 = new DatastreamTaskImpl(Collections.singletonList(stream));\n+    ZkAdapter mockZkAdapter2 = mock(ZkAdapter.class);\n+    task0.setZkAdapter(mockZkAdapter2);\n+    when(mockZkAdapter2.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n+\n+    task.addDependency(task0);\n+\n     when(mockZkAdapter.checkIsTaskLocked(anyString(), anyString(), anyString())).thenReturn(true);\n     DatastreamTaskImpl task2 = new DatastreamTaskImpl(task, new ArrayList<>());\n     Assert.assertEquals(new HashSet<>(task2.getDependencies()), ImmutableSet.of(task.getDatastreamTaskName()));\n   }\n \n+  @Test(expectedExceptions = DatastreamTransientException.class)\n+  public void testTaskAddUnlockedDependency() {", "originalCommit": "df82240c977ec668acccb62ebbbfc8fccc2d3cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMDc0OQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521020749", "bodyText": "done", "author": "somandal", "createdAt": "2020-11-11T02:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0OTM5Nw=="}], "type": "inlineReview"}, {"oid": "9068c87e7d089bb222b291f9bbbbfd10498c256d", "url": "https://github.com/linkedin/brooklin/commit/9068c87e7d089bb222b291f9bbbbfd10498c256d", "message": "Address review comments", "committedDate": "2020-11-11T02:07:36Z", "type": "commit"}, {"oid": "68f164664325c943dc4272621354a9a7efd8eb1a", "url": "https://github.com/linkedin/brooklin/commit/68f164664325c943dc4272621354a9a7efd8eb1a", "message": "Merge branch 'master' into partition-movement-fixes", "committedDate": "2020-11-11T02:13:43Z", "type": "commit"}, {"oid": "dbe8b5645adef83ee7507bf75ef79220b4f00fb4", "url": "https://github.com/linkedin/brooklin/commit/dbe8b5645adef83ee7507bf75ef79220b4f00fb4", "message": "Merge targetAssignment processing step into the existing step where we compute tasks with partitions going away", "committedDate": "2020-11-11T02:47:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMzY5MQ==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521113691", "bodyText": "Also, can you please add the steps in the comments in the code, so it is clear which code block is which step?", "author": "vmaheshw", "createdAt": "2020-11-11T04:58:00Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -154,11 +154,13 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n   /**\n    * Move a partition for a datastream group according to the targetAssignment. As we are only allowed to mutate the\n    * task once. It follow the steps\n-   * Step 1) get the partitions that to be moved, and find out their source task\n-   * Step 2) If the instance is the one we want to move, we find out the task which we should assign the partition\n+   * Step 1) Process the targetAssignment to remove any partitions with no-op moves (partition currently assigned\n+   *         to the same instance where the partition is to be moved)\n+   * Step 2) Get the partitions that are to be moved, and find their source tasks\n+   * Step 3) If the instance is the one we want to move, we choose a task to which we should assign the partition", "originalCommit": "dbe8b5645adef83ee7507bf75ef79220b4f00fb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyMTg5OA==", "url": "https://github.com/linkedin/brooklin/pull/775#discussion_r521121898", "bodyText": "done", "author": "somandal", "createdAt": "2020-11-11T05:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExMzY5MQ=="}], "type": "inlineReview"}, {"oid": "28caf6eed1e3df59e50f352bc8306ea86814e6fa", "url": "https://github.com/linkedin/brooklin/commit/28caf6eed1e3df59e50f352bc8306ea86814e6fa", "message": "Address review comments", "committedDate": "2020-11-11T05:29:11Z", "type": "commit"}]}