{"pr_number": 751, "pr_title": "shutdown producer in KafkaProducerWrapper during task assign/unassign call.", "pr_createdAt": "2020-09-14T21:21:58Z", "pr_url": "https://github.com/linkedin/brooklin/pull/751", "timeline": [{"oid": "c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "url": "https://github.com/linkedin/brooklin/commit/c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "message": "Merge pull request #1 from linkedin/master\n\nPull latest", "committedDate": "2019-11-18T20:06:44Z", "type": "commit"}, {"oid": "8db5941e3dd2292f5ebbc40962874d08bfe4b38f", "url": "https://github.com/linkedin/brooklin/commit/8db5941e3dd2292f5ebbc40962874d08bfe4b38f", "message": "Fix KafkaProducerWrapper to not allow any send/flush operation for a task after unassign", "committedDate": "2020-09-14T21:14:51Z", "type": "commit"}, {"oid": "261567c3ca629c22be99e773dea67f4b6590f610", "url": "https://github.com/linkedin/brooklin/commit/261567c3ca629c22be99e773dea67f4b6590f610", "message": "Fix build failure", "committedDate": "2020-09-14T21:50:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4NTcyMw==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r488785723", "bodyText": "nit: \"Any further sends by this task will not work\"\nAlso, do you think we should add a small sentence about how this affects existing tasks that share the same producer? i.e. their inflight records will attempt to flushed, but if it doesn't complete, they'll see send failures, but this is okay since they'll be able to create a new producer on the next send?", "author": "somandal", "createdAt": "2020-09-15T16:04:32Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -177,7 +182,12 @@ void assignTask(DatastreamTask task) {\n   }\n \n   void unassignTask(DatastreamTask task) {\n-    _tasks.remove(task);\n+    boolean taskPresent = _tasks.remove(task);\n+    // whenever a task is unassigned the kafka producer should be shutdown to ensure that\n+    // there are no in-flight sends. Any further send will not work.", "originalCommit": "261567c3ca629c22be99e773dea67f4b6590f610", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc5NzI2OA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r488797268", "bodyText": "Does adding a comment here make sense, that if the task is not assigned, production should be disallowed?", "author": "somandal", "createdAt": "2020-09-15T16:21:21Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -166,6 +166,11 @@ private void populateDefaultProducerConfigs() {\n \n   private Optional<Producer<K, V>> maybeGetKafkaProducer(DatastreamTask task) {\n     Producer<K, V> producer = _kafkaProducer;\n+    if (!_tasks.contains(task)) {", "originalCommit": "261567c3ca629c22be99e773dea67f4b6590f610", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzAwNQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494753005", "bodyText": "I feel the code is self explainatory.", "author": "vmaheshw", "createdAt": "2020-09-25T05:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc5NzI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc5OTgyNQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r488799825", "bodyText": "One thing to note here is that since shutdownProducer() requires obtaining the lock, this operation can get stuck waiting on this lock. Operations such as flush can take a while (up to 15 minutes for BMM with the current flush timeout). Once concern might be that unassignTask() is called from the onAssignmentChange() threads, right? And have a limited time of 30-60 seconds within which it needs to complete?", "author": "somandal", "createdAt": "2020-09-15T16:25:08Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -177,7 +182,12 @@ void assignTask(DatastreamTask task) {\n   }\n \n   void unassignTask(DatastreamTask task) {\n-    _tasks.remove(task);\n+    boolean taskPresent = _tasks.remove(task);\n+    // whenever a task is unassigned the kafka producer should be shutdown to ensure that\n+    // there are no in-flight sends. Any further send will not work.\n+    if (taskPresent) {\n+      shutdownProducer();", "originalCommit": "261567c3ca629c22be99e773dea67f4b6590f610", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDA0OQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494754049", "bodyText": "handled it.", "author": "vmaheshw", "createdAt": "2020-09-25T05:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc5OTgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgwMjUzOQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r488802539", "bodyText": "Can you add  a comment here or somewhere in this file that if a new field is added along with a setter, or any function that modifies the values, the setter/function must call computeHashCode()?", "author": "somandal", "createdAt": "2020-09-15T16:29:24Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/DatastreamTaskImpl.java", "diffHunk": "@@ -89,6 +89,7 @@\n   private DatastreamEventProducer _eventProducer;\n   private String _transportProviderName;\n   private SerDeSet _destinationSerDes = new SerDeSet(null, null, null);\n+  private int _hashCode;", "originalCommit": "261567c3ca629c22be99e773dea67f4b6590f610", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1d1688689d6ec083a647554146dfbf478d7d94a", "url": "https://github.com/linkedin/brooklin/commit/e1d1688689d6ec083a647554146dfbf478d7d94a", "message": "Merge branch 'master' of github.com:vmaheshw/Brooklin into fixKafkaProducerWrapper", "committedDate": "2020-09-21T19:22:07Z", "type": "commit"}, {"oid": "ca788a52a629ed332efb97868dcc0f868c3fabb5", "url": "https://github.com/linkedin/brooklin/commit/ca788a52a629ed332efb97868dcc0f868c3fabb5", "message": "Merge changes", "committedDate": "2020-09-21T19:24:02Z", "type": "commit"}, {"oid": "0b96260b1f27844b27061d49963d97e837742648", "url": "https://github.com/linkedin/brooklin/commit/0b96260b1f27844b27061d49963d97e837742648", "message": "Add interface to TransportProviderAdmin", "committedDate": "2020-09-21T23:31:03Z", "type": "commit"}, {"oid": "91cb2378a8678ccd02ecac30434f850868b442b6", "url": "https://github.com/linkedin/brooklin/commit/91cb2378a8678ccd02ecac30434f850868b442b6", "message": "Fix code", "committedDate": "2020-09-21T23:34:43Z", "type": "commit"}, {"oid": "6893a7faeacde6c74aac74213266b6f06948485d", "url": "https://github.com/linkedin/brooklin/commit/6893a7faeacde6c74aac74213266b6f06948485d", "message": "Build failures", "committedDate": "2020-09-21T23:40:03Z", "type": "commit"}, {"oid": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "url": "https://github.com/linkedin/brooklin/commit/4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "message": "Refactor producerlock", "committedDate": "2020-09-23T04:07:19Z", "type": "commit"}, {"oid": "5f8e6759819a260be1e48b9e556de963b7decbca", "url": "https://github.com/linkedin/brooklin/commit/5f8e6759819a260be1e48b9e556de963b7decbca", "message": "Fix comments", "committedDate": "2020-09-24T04:39:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk0MDI1MQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r493940251", "bodyText": "nit: _waitOnNoProducerClose -> _waitOnProducerClose", "author": "somandal", "createdAt": "2020-09-23T22:57:37Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -111,11 +114,13 @@\n   private final String _metricsNamesPrefix;\n \n   // A lock used to synchronize access to operations performed on the _kafkaProducer object\n-  private final Object _producerLock = new Object();\n+  private final Lock _producerLock = new ReentrantLock();\n+  private final Condition _waitOnNoProducerClose = _producerLock.newCondition();", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk0MDU4MQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r493940581", "bodyText": "You should move the \"closeInProgress\" here and mention that it also needs to be accessed from under the same lock.", "author": "somandal", "createdAt": "2020-09-23T22:58:40Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -111,11 +114,13 @@\n   private final String _metricsNamesPrefix;\n \n   // A lock used to synchronize access to operations performed on the _kafkaProducer object", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk0MDg2MA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r493940860", "bodyText": "nit: closeInProgress -> _closeInProgress\nAlso move this to where the lock is declared, and make it clear that the lock protects updates to this too.", "author": "somandal", "createdAt": "2020-09-23T22:59:33Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -111,11 +114,13 @@\n   private final String _metricsNamesPrefix;\n \n   // A lock used to synchronize access to operations performed on the _kafkaProducer object\n-  private final Object _producerLock = new Object();\n+  private final Lock _producerLock = new ReentrantLock();\n+  private final Condition _waitOnNoProducerClose = _producerLock.newCondition();\n \n   // An executor to spawn threads to close the producer.\n   private final ExecutorService _producerCloseExecutorService = Executors.newSingleThreadExecutor(\n       new ThreadFactoryBuilder().setNameFormat(\"KafkaProducerWrapperClose-%d\").build());\n+  private boolean closeInProgress = false;", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk0MTI3Mw==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r493941273", "bodyText": "nit: unassignTask  -> unassignTasks (since it can unassign multiple tasks)", "author": "somandal", "createdAt": "2020-09-23T23:00:51Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -177,29 +191,54 @@ void assignTask(DatastreamTask task) {\n   }\n \n   void unassignTask(DatastreamTask task) {\n-    _tasks.remove(task);\n+    unassignTask(Collections.singletonList(task));\n+  }\n+\n+  void unassignTask(List<DatastreamTask> taskList) {", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyNTYwMg==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494625602", "bodyText": "nit:  there are no in-flight sends -> there are no pending in-flight sends\nnit: Any further send will not work -> Further sends will fail until the producer is re-initialized by a valid task", "author": "somandal", "createdAt": "2020-09-24T21:38:15Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -177,29 +191,54 @@ void assignTask(DatastreamTask task) {\n   }\n \n   void unassignTask(DatastreamTask task) {\n-    _tasks.remove(task);\n+    unassignTask(Collections.singletonList(task));\n+  }\n+\n+  void unassignTask(List<DatastreamTask> taskList) {\n+    boolean taskPresent = _tasks.removeAll(taskList);\n+    try {\n+      _producerLock.lock();\n+\n+      // whenever a task is unassigned the kafka producer should be shutdown to ensure that\n+      // there are no in-flight sends. Any further send will not work.", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzMjM0OQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494632349", "bodyText": "Let's add comments here explaining why it's okay to only shutdown the producer when the task list is empty (i.e. we are on shutdown path)? It becomes confusing since in unassignTask(), we need to close the producer ever time we remove a task.", "author": "somandal", "createdAt": "2020-09-24T21:54:36Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -254,67 +298,92 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n       } catch (Exception e) {\n         _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n-        throw generateSendFailure(e);\n+        throw generateSendFailure(e, task);\n       }\n     }\n   }\n \n   @VisibleForTesting\n   void shutdownProducer() {\n     Producer<K, V> producer;\n-    synchronized (_producerLock) {\n+    try {\n+      _producerLock.lock();\n+      if (_kafkaProducer == null || closeInProgress) {\n+        return;\n+      }\n       producer = _kafkaProducer;\n+      closeInProgress = true;\n       // Nullify first to prevent subsequent send() to use\n       // the current producer which is being shutdown.\n       _kafkaProducer = null;\n-    }\n \n-    // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n-    // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n-    // thread\n-    if (producer != null) {\n+      // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n+      // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n+      // thread\n+\n       _producerCloseExecutorService.submit(() -> {\n         _log.info(\"KafkaProducerWrapper: Closing the Kafka Producer\");\n-        producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-        NUM_PRODUCERS.decrementAndGet();\n-        _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        try {\n+          producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+          NUM_PRODUCERS.decrementAndGet();\n+          _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        } finally {\n+          try {\n+            _producerLock.lock();\n+            closeInProgress = false;\n+            _waitOnNoProducerClose.signalAll();\n+          } finally {\n+            _producerLock.unlock();\n+          }\n+        }\n       });\n+    } finally {\n+      _producerLock.unlock();\n     }\n   }\n \n-  private DatastreamRuntimeException generateSendFailure(Exception exception) {\n+  private DatastreamRuntimeException generateSendFailure(Exception exception, DatastreamTask task) {\n     _dynamicMetricsManager.createOrUpdateMeter(_metricsNamesPrefix, AGGREGATE, PRODUCER_ERROR, 1);\n     if (exception instanceof IllegalStateException) {\n       _log.warn(\"Send failed transiently with exception: \", exception);\n       return new DatastreamTransientException(exception);\n     } else {\n       _log.warn(\"Send failed with a non-transient exception. Shutting down producer, exception: \", exception);\n-      shutdownProducer();\n+      if (_tasks.contains(task)) {\n+        shutdownProducer();\n+      }\n       return new DatastreamRuntimeException(exception);\n     }\n   }\n \n   void flush() {\n-    synchronized (_producerLock) {\n-      try {\n-        if (_kafkaProducer != null) {\n-          _kafkaProducer.flush(_producerFlushTimeoutMs, TimeUnit.MILLISECONDS);\n-        }\n-      } catch (InterruptException | TimeoutException e) {\n-        // The KafkaProducer object should not be reused on an interrupted flush\n-        _log.warn(\"Kafka producer flush interrupted/timed out, closing producer {}.\", _kafkaProducer);\n+    Producer<K, V> producer;\n+    try {\n+      _producerLock.lock();\n+      producer = _kafkaProducer;\n+    } finally {\n+      _producerLock.unlock();\n+    }\n+\n+    try {\n+      if (producer != null) {\n+          producer.flush(_producerFlushTimeoutMs, TimeUnit.MILLISECONDS);\n+      }\n+    } catch (InterruptException | TimeoutException e) {\n+      // The KafkaProducer object should not be reused on an interrupted flush\n+      if (producer == _kafkaProducer) {\n+        _log.warn(\"Kafka producer flush interrupted/timed out, closing producer {}.\", producer);\n         shutdownProducer();\n-        throw e;\n+      } else {\n+        _log.warn(\"Kafka producer flush interrupted/timed out, producer {} already closed.\", producer);\n       }\n+      throw e;\n     }\n   }\n \n   void close(DatastreamTask task) {\n-    synchronized (_producerLock) {\n-      _tasks.remove(task);\n-      if (_kafkaProducer != null && _tasks.isEmpty()) {\n-        shutdownProducer();\n-      }\n+    if (_tasks.remove(task) && _tasks.isEmpty()) {", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzNDUyMw==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494634523", "bodyText": "So we already check for this before we call initializeProducer, is this really needed here too? If yes, can you add comments explaining why?\nI feel a little bit like assignTask/unassignTask aren't synchronizing access to _tasks as such, which means the state of _tasks can change at any point in time anyways. So I don't see much point in checking for this twice. Do correct me if I missed something though.", "author": "somandal", "createdAt": "2020-09-24T21:59:42Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -177,29 +191,54 @@ void assignTask(DatastreamTask task) {\n   }\n \n   void unassignTask(DatastreamTask task) {\n-    _tasks.remove(task);\n+    unassignTask(Collections.singletonList(task));\n+  }\n+\n+  void unassignTask(List<DatastreamTask> taskList) {\n+    boolean taskPresent = _tasks.removeAll(taskList);\n+    try {\n+      _producerLock.lock();\n+\n+      // whenever a task is unassigned the kafka producer should be shutdown to ensure that\n+      // there are no in-flight sends. Any further send will not work.\n+      if (taskPresent && _kafkaProducer != null && !closeInProgress) {\n+        shutdownProducer();\n+      }\n+    } finally {\n+      _producerLock.unlock();\n+    }\n   }\n \n   int getTasksSize() {\n     return _tasks.size();\n   }\n \n-  private Producer<K, V> initializeProducer(DatastreamTask task) {\n+  private Producer<K, V> initializeProducer(DatastreamTask task) throws InterruptedException {\n+    if (!_tasks.contains(task)) {\n+      _log.warn(\"Task {} has been unassigned for producer, abort the send\", task);\n+      return null;\n+    }", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYzNjgwOA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494636808", "bodyText": "nit: Close not completed. Retry -> Close did not complete in {} ms, retrying {}th time\n(or something along those lines - maybe skip the number of retries)\nI somehow think we should make this an info/warn. Will be hard to debug if for some reason we get stuck in this loop.\nAlso, what if close is stuck indefinitely? Looks like this thread will just be stuck waiting forever in that case. We should definitely at least log periodically if not every time we finish an await().\nAlso a good idea to add  some comments here calling out that this can affect other tasks that use the same producer and cause some latency, but it is necessary for correctness. Don't want history to repeat itself.", "author": "somandal", "createdAt": "2020-09-24T22:05:22Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -177,29 +191,54 @@ void assignTask(DatastreamTask task) {\n   }\n \n   void unassignTask(DatastreamTask task) {\n-    _tasks.remove(task);\n+    unassignTask(Collections.singletonList(task));\n+  }\n+\n+  void unassignTask(List<DatastreamTask> taskList) {\n+    boolean taskPresent = _tasks.removeAll(taskList);\n+    try {\n+      _producerLock.lock();\n+\n+      // whenever a task is unassigned the kafka producer should be shutdown to ensure that\n+      // there are no in-flight sends. Any further send will not work.\n+      if (taskPresent && _kafkaProducer != null && !closeInProgress) {\n+        shutdownProducer();\n+      }\n+    } finally {\n+      _producerLock.unlock();\n+    }\n   }\n \n   int getTasksSize() {\n     return _tasks.size();\n   }\n \n-  private Producer<K, V> initializeProducer(DatastreamTask task) {\n+  private Producer<K, V> initializeProducer(DatastreamTask task) throws InterruptedException {\n+    if (!_tasks.contains(task)) {\n+      _log.warn(\"Task {} has been unassigned for producer, abort the send\", task);\n+      return null;\n+    }\n     // Must be protected by a lock to avoid creating duplicate producers when multiple concurrent\n     // sends are in-flight and _kafkaProducer has been set to null as a result of previous\n     // producer exception.\n-    synchronized (_producerLock) {\n-      if (!_tasks.contains(task)) {\n-        _log.warn(\"Task {} has been unassigned for producer, abort the send\", task);\n-        return null;\n-      } else {\n-        if (_kafkaProducer == null) {\n-          _rateLimiter.acquire();\n-          _kafkaProducer = createKafkaProducer();\n-          NUM_PRODUCERS.incrementAndGet();\n+    try {\n+      _producerLock.lock();\n+\n+      while (closeInProgress) {\n+        boolean closeCompleted = _waitOnNoProducerClose.await(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+        if (!closeCompleted) {\n+          _log.debug(\"Close not completed. Retry\");", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0NjcwNw==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494646707", "bodyText": "Shall we move this block into a separate function? Looks very long here and can be a little confusing to read (first I  thought you're releasing the lock in two different finally blocks, and then realized that the first one is a separate thread)", "author": "somandal", "createdAt": "2020-09-24T22:32:42Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -254,67 +298,92 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n       } catch (Exception e) {\n         _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n-        throw generateSendFailure(e);\n+        throw generateSendFailure(e, task);\n       }\n     }\n   }\n \n   @VisibleForTesting\n   void shutdownProducer() {\n     Producer<K, V> producer;\n-    synchronized (_producerLock) {\n+    try {\n+      _producerLock.lock();\n+      if (_kafkaProducer == null || closeInProgress) {\n+        return;\n+      }\n       producer = _kafkaProducer;\n+      closeInProgress = true;\n       // Nullify first to prevent subsequent send() to use\n       // the current producer which is being shutdown.\n       _kafkaProducer = null;\n-    }\n \n-    // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n-    // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n-    // thread\n-    if (producer != null) {\n+      // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n+      // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n+      // thread\n+\n       _producerCloseExecutorService.submit(() -> {\n         _log.info(\"KafkaProducerWrapper: Closing the Kafka Producer\");\n-        producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-        NUM_PRODUCERS.decrementAndGet();\n-        _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        try {\n+          producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+          NUM_PRODUCERS.decrementAndGet();\n+          _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        } finally {\n+          try {\n+            _producerLock.lock();\n+            closeInProgress = false;\n+            _waitOnNoProducerClose.signalAll();\n+          } finally {\n+            _producerLock.unlock();\n+          }\n+        }", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDMxMA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494754310", "bodyText": "I moved the finally block in another method to improve readability.", "author": "vmaheshw", "createdAt": "2020-09-25T05:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0NjcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0NzczOQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494647739", "bodyText": "we're checking _kafkaProducer outside the lock. _kafkaProducer may change by the time shutdownProducer() is called. Can we instead have a shutdownProducer(producer) that does this comparison under the lock and calls shutdownProducer(), or something along those lines?", "author": "somandal", "createdAt": "2020-09-24T22:35:33Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -254,67 +298,92 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n       } catch (Exception e) {\n         _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n-        throw generateSendFailure(e);\n+        throw generateSendFailure(e, task);\n       }\n     }\n   }\n \n   @VisibleForTesting\n   void shutdownProducer() {\n     Producer<K, V> producer;\n-    synchronized (_producerLock) {\n+    try {\n+      _producerLock.lock();\n+      if (_kafkaProducer == null || closeInProgress) {\n+        return;\n+      }\n       producer = _kafkaProducer;\n+      closeInProgress = true;\n       // Nullify first to prevent subsequent send() to use\n       // the current producer which is being shutdown.\n       _kafkaProducer = null;\n-    }\n \n-    // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n-    // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n-    // thread\n-    if (producer != null) {\n+      // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n+      // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n+      // thread\n+\n       _producerCloseExecutorService.submit(() -> {\n         _log.info(\"KafkaProducerWrapper: Closing the Kafka Producer\");\n-        producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-        NUM_PRODUCERS.decrementAndGet();\n-        _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        try {\n+          producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+          NUM_PRODUCERS.decrementAndGet();\n+          _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        } finally {\n+          try {\n+            _producerLock.lock();\n+            closeInProgress = false;\n+            _waitOnNoProducerClose.signalAll();\n+          } finally {\n+            _producerLock.unlock();\n+          }\n+        }\n       });\n+    } finally {\n+      _producerLock.unlock();\n     }\n   }\n \n-  private DatastreamRuntimeException generateSendFailure(Exception exception) {\n+  private DatastreamRuntimeException generateSendFailure(Exception exception, DatastreamTask task) {\n     _dynamicMetricsManager.createOrUpdateMeter(_metricsNamesPrefix, AGGREGATE, PRODUCER_ERROR, 1);\n     if (exception instanceof IllegalStateException) {\n       _log.warn(\"Send failed transiently with exception: \", exception);\n       return new DatastreamTransientException(exception);\n     } else {\n       _log.warn(\"Send failed with a non-transient exception. Shutting down producer, exception: \", exception);\n-      shutdownProducer();\n+      if (_tasks.contains(task)) {\n+        shutdownProducer();\n+      }\n       return new DatastreamRuntimeException(exception);\n     }\n   }\n \n   void flush() {\n-    synchronized (_producerLock) {\n-      try {\n-        if (_kafkaProducer != null) {\n-          _kafkaProducer.flush(_producerFlushTimeoutMs, TimeUnit.MILLISECONDS);\n-        }\n-      } catch (InterruptException | TimeoutException e) {\n-        // The KafkaProducer object should not be reused on an interrupted flush\n-        _log.warn(\"Kafka producer flush interrupted/timed out, closing producer {}.\", _kafkaProducer);\n+    Producer<K, V> producer;\n+    try {\n+      _producerLock.lock();\n+      producer = _kafkaProducer;\n+    } finally {\n+      _producerLock.unlock();\n+    }\n+\n+    try {\n+      if (producer != null) {\n+          producer.flush(_producerFlushTimeoutMs, TimeUnit.MILLISECONDS);\n+      }\n+    } catch (InterruptException | TimeoutException e) {\n+      // The KafkaProducer object should not be reused on an interrupted flush\n+      if (producer == _kafkaProducer) {", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzY3OQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494753679", "bodyText": "The reason to skip here is to avoid closing the other producer. I initially thought of passing producer to the method, but that will imply making the producer final to be passed from send callback and I wanted to avoid it from garbage collection point of view and producer is a heavyweight object in general.", "author": "vmaheshw", "createdAt": "2020-09-25T05:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0NzczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NzgxNQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494757815", "bodyText": "I wasn't implying always passing the producer object to shutdownProducer(). I was thinking that you can keep shutdownProducer() as is, but add:\nvoid shutdownProducer(KafkaProducer producer) { _producerLock.lock() try { if (producer == _kafkaProducer) { shutdownProducer() } } finally { _producerLock.unlock() } }\nThis new method would be called from flush() only. The send callback path will just call the existing shutdownProducer() directly, since this method acquires the lock anyways.\nI'd like to avoid access to _kafkaProducer outside the lock as much as possible. Makes the code much cleaner and easier to reason about. Otherwise one will always need to remember that another code path can potentially have changed the  _kafkaProducer object from underneath us by the time we actually call shutdownProducer(), implying that we've just closed a newly created producer, etc.", "author": "somandal", "createdAt": "2020-09-25T05:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0NzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0ODY2NA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494648664", "bodyText": "nit: remove extra line?", "author": "somandal", "createdAt": "2020-09-24T22:38:19Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaTransportProviderAdmin.java", "diffHunk": "@@ -172,6 +173,24 @@ public void unassignTransportProvider(DatastreamTask task) {\n     }\n   }\n \n+  @Override\n+  public void unassignTransportProvider(List<DatastreamTask> taskList) {\n+    Validate.notNull(taskList, \"null task\");\n+    Set<KafkaProducerWrapper<byte[], byte[]>> producers = new HashSet<>();\n+    for (DatastreamTask task : taskList) {\n+      if (_transportProviders.containsKey(task)) {\n+        KafkaTransportProvider transportProvider = _transportProviders.remove(task);\n+        producers.addAll(transportProvider.getProducers());\n+        //transportProvider.getProducers().forEach(p -> p.unassignTask(task));\n+      } else {\n+        LOG.warn(\"Trying to unassign already unassigned transport provider for task {}.\", task);\n+      }\n+    }\n+\n+    producers.forEach(p -> p.unassignTask(taskList));\n+", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY0ODg5Mg==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494648892", "bodyText": "nit: \"null task\" -> \"null task list\"\nDo we need validate for list size too?", "author": "somandal", "createdAt": "2020-09-24T22:38:59Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaTransportProviderAdmin.java", "diffHunk": "@@ -172,6 +173,24 @@ public void unassignTransportProvider(DatastreamTask task) {\n     }\n   }\n \n+  @Override\n+  public void unassignTransportProvider(List<DatastreamTask> taskList) {\n+    Validate.notNull(taskList, \"null task\");", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1MDcxNw==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494650717", "bodyText": "remove this commented out code? or is the intention to do this here?", "author": "somandal", "createdAt": "2020-09-24T22:44:38Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaTransportProviderAdmin.java", "diffHunk": "@@ -172,6 +173,24 @@ public void unassignTransportProvider(DatastreamTask task) {\n     }\n   }\n \n+  @Override\n+  public void unassignTransportProvider(List<DatastreamTask> taskList) {\n+    Validate.notNull(taskList, \"null task\");\n+    Set<KafkaProducerWrapper<byte[], byte[]>> producers = new HashSet<>();\n+    for (DatastreamTask task : taskList) {\n+      if (_transportProviders.containsKey(task)) {\n+        KafkaTransportProvider transportProvider = _transportProviders.remove(task);\n+        producers.addAll(transportProvider.getProducers());\n+        //transportProvider.getProducers().forEach(p -> p.unassignTask(task));", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1MjEyMQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494652121", "bodyText": "So we gather all the producers and pass the taskList as is without worrying about the fact that only a subset of tasks will actually be assigned to that producer? Is this to ensure that you unassign all the tasks assigned to the producer, and only call shutdown once?", "author": "somandal", "createdAt": "2020-09-24T22:48:56Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaTransportProviderAdmin.java", "diffHunk": "@@ -172,6 +173,24 @@ public void unassignTransportProvider(DatastreamTask task) {\n     }\n   }\n \n+  @Override\n+  public void unassignTransportProvider(List<DatastreamTask> taskList) {\n+    Validate.notNull(taskList, \"null task\");\n+    Set<KafkaProducerWrapper<byte[], byte[]>> producers = new HashSet<>();\n+    for (DatastreamTask task : taskList) {\n+      if (_transportProviders.containsKey(task)) {\n+        KafkaTransportProvider transportProvider = _transportProviders.remove(task);\n+        producers.addAll(transportProvider.getProducers());\n+        //transportProvider.getProducers().forEach(p -> p.unassignTask(task));\n+      } else {\n+        LOG.warn(\"Trying to unassign already unassigned transport provider for task {}.\", task);\n+      }\n+    }\n+\n+    producers.forEach(p -> p.unassignTask(taskList));", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDQ4MQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494754481", "bodyText": "Yes, that is true.", "author": "vmaheshw", "createdAt": "2020-09-25T05:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1MjEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1NDMwMQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494654301", "bodyText": "Should we have a test where we assign two tasks, unassign one and check that the second task is still able to send (with a new producer of course)?\nAlso this part of the test onwards looks very similar to the first part onwards. Is that intended? Not clear what's being tested.", "author": "somandal", "createdAt": "2020-09-24T22:55:26Z", "path": "datastream-kafka/src/test/java/com/linkedin/datastream/kafka/TestKafkaProducerWrapper.java", "diffHunk": "@@ -94,37 +95,104 @@ private void testFlushBehaviorOnException(Class<? extends Throwable> exceptionCl\n \n     producerWrapper.verifySend(1);\n     producerWrapper.verifyFlush(1);\n-    producerWrapper.verifyClose(1);\n+    producerWrapper.verifyClose(1, 1);\n \n     // Second send should create a new producer, resetting flush() and close() invocation counts\n     producerWrapper.send(task, producerRecord, null);\n     producerWrapper.verifySend(1);\n     producerWrapper.verifyFlush(0);\n-    producerWrapper.verifyClose(0);\n+    producerWrapper.verifyClose(0, 1);\n     Assert.assertEquals(producerWrapper.getNumCreateKafkaProducerCalls(), 2);\n \n     // Second producer's flush() has not been mocked to throw exceptions, this should not throw\n     producerWrapper.flush();\n     producerWrapper.verifySend(1);\n     producerWrapper.verifyFlush(1);\n-    producerWrapper.verifyClose(0);\n+    producerWrapper.verifyClose(0, 1);\n     Assert.assertEquals(producerWrapper.getNumCreateKafkaProducerCalls(), 2);\n \n     // Send should reuse the older producer and the counts should not be reset\n     producerWrapper.send(task, producerRecord, null);\n     producerWrapper.verifySend(2);\n     producerWrapper.verifyFlush(1);\n-    producerWrapper.verifyClose(0);\n+    producerWrapper.verifyClose(0, 1);\n     Assert.assertEquals(producerWrapper.getNumCreateKafkaProducerCalls(), 2);\n \n     // Closing the producer's task. Since this is the only task, the producer should be closed\n     producerWrapper.close(task);\n     producerWrapper.verifySend(2);\n     producerWrapper.verifyFlush(1);\n-    producerWrapper.verifyClose(1);\n+    producerWrapper.verifyClose(1, 2);\n     Assert.assertEquals(producerWrapper.getNumCreateKafkaProducerCalls(), 2);\n   }\n \n+  @Test\n+  public void testAssignAndUnassignTask() throws Exception {\n+    DynamicMetricsManager.createInstance(new MetricRegistry(), getClass().getSimpleName());\n+    Properties transportProviderProperties = new Properties();\n+    transportProviderProperties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:1234\");\n+    transportProviderProperties.put(ProducerConfig.CLIENT_ID_CONFIG, \"testClient\");\n+    transportProviderProperties.put(KafkaTransportProviderAdmin.ZK_CONNECT_STRING_CONFIG, \"zk-connect-string\");\n+    transportProviderProperties.put(KafkaProducerWrapper.CFG_PRODUCER_FLUSH_TIMEOUT_MS, \"1\");\n+\n+    String topicName = \"topic-43\";\n+\n+    MockKafkaProducerWrapper<byte[], byte[]> producerWrapper =\n+        new MockKafkaProducerWrapper<>(\"log-suffix\", transportProviderProperties, \"metrics\",\n+            TimeoutException.class);\n+\n+    String destinationUri = \"localhost:1234/\" + topicName;\n+    Datastream ds = DatastreamTestUtils.createDatastream(\"test\", \"ds1\", \"source\", destinationUri, 1);\n+\n+    DatastreamTask task = new DatastreamTaskImpl(Collections.singletonList(ds));\n+    ProducerRecord<byte[], byte[]> producerRecord = new ProducerRecord<>(topicName, null, null);\n+    producerWrapper.assignTask(task);\n+\n+    // Sending first event, send should pass, none of the other methods on the producer should have been called\n+    producerWrapper.send(task, producerRecord, null);\n+    producerWrapper.verifySend(1);\n+    producerWrapper.verifyFlush(0);\n+    producerWrapper.verifyClose(0, 0);\n+    Assert.assertEquals(producerWrapper.getNumCreateKafkaProducerCalls(), 1);\n+\n+    producerWrapper.unassignTask(task);\n+    producerWrapper.verifySend(1);\n+    producerWrapper.verifyFlush(0);\n+    producerWrapper.verifyClose(1, 1);\n+\n+    // Second send should fail as the task is unassigned\n+    Assert.assertThrows(DatastreamRuntimeException.class, () -> producerWrapper.send(task, producerRecord, null));\n+    producerWrapper.verifySend(1);\n+    producerWrapper.verifyFlush(0);\n+    producerWrapper.verifyClose(1, 1);\n+\n+    // Closing the producer's task. Since this is the only task, the producer should be closed\n+    producerWrapper.close(task);\n+    producerWrapper.verifySend(1);\n+    producerWrapper.verifyFlush(0);\n+    producerWrapper.verifyClose(1, 1);\n+    Assert.assertEquals(producerWrapper.getNumCreateKafkaProducerCalls(), 1);\n+\n+    producerWrapper.assignTask(task);", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDU4Ng==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494754586", "bodyText": "added.", "author": "vmaheshw", "createdAt": "2020-09-25T05:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY1NDMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4NjYyNg==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r494686626", "bodyText": "not you fault, but can you change the input variable to be \"tasks\" instead of \"t\". It's much easier to read.", "author": "somandal", "createdAt": "2020-09-25T00:47:27Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -710,10 +710,17 @@ private DatastreamTask getDatastreamTask(String taskName) {\n     });\n   }\n \n-  private void uninitializeTask(DatastreamTask t) {\n-    TransportProviderAdmin tpAdmin = _transportProviderAdmins.get(t.getTransportProviderName());\n-    tpAdmin.unassignTransportProvider(t);\n-    _cpProvider.unassignDatastreamTask(t);\n+  private void uninitializeTask(List<DatastreamTask> t) {", "originalCommit": "4e6c7bd9cebf647fcb82063ef9f99ac9d2f07001", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ccf2995710d5d0bdbf26ff4d54e2f06988c03cfb", "url": "https://github.com/linkedin/brooklin/commit/ccf2995710d5d0bdbf26ff4d54e2f06988c03cfb", "message": "Address comments", "committedDate": "2020-09-25T05:16:25Z", "type": "commit"}, {"oid": "528e8b5153543bf4b41712f5124d04ebe0710278", "url": "https://github.com/linkedin/brooklin/commit/528e8b5153543bf4b41712f5124d04ebe0710278", "message": "Address comments", "committedDate": "2020-09-25T06:03:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNTc0MQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496825741", "bodyText": "Add a comment explaining the hashcode field as it is not obvious why this optimization is important", "author": "DEEPTHIKORAT", "createdAt": "2020-09-29T15:38:49Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/DatastreamTaskImpl.java", "diffHunk": "@@ -89,6 +89,7 @@\n   private DatastreamEventProducer _eventProducer;\n   private String _transportProviderName;\n   private SerDeSet _destinationSerDes = new SerDeSet(null, null, null);\n+  private int _hashCode;", "originalCommit": "528e8b5153543bf4b41712f5124d04ebe0710278", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg1NjIwMg==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496856202", "bodyText": "extreme nit: move this after the below check.", "author": "DEEPTHIKORAT", "createdAt": "2020-09-29T16:07:35Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -166,8 +173,17 @@ private void populateDefaultProducerConfigs() {\n \n   private Optional<Producer<K, V>> maybeGetKafkaProducer(DatastreamTask task) {\n     Producer<K, V> producer = _kafkaProducer;", "originalCommit": "528e8b5153543bf4b41712f5124d04ebe0710278", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg1OTcwNA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496859704", "bodyText": "nit: Would a Set rather than a List be better to use here?", "author": "DEEPTHIKORAT", "createdAt": "2020-09-29T16:11:01Z", "path": "datastream-directory/src/main/java/com/linkedin/datastream/server/DirectoryTransportProviderAdmin.java", "diffHunk": "@@ -39,6 +40,10 @@ public TransportProvider assignTransportProvider(DatastreamTask task) {\n   public void unassignTransportProvider(DatastreamTask task) {\n   }\n \n+  @Override\n+  public void unassignTransportProvider(List<DatastreamTask> taskList) {", "originalCommit": "528e8b5153543bf4b41712f5124d04ebe0710278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NzY0MQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496897641", "bodyText": "Keeping aligned with the other interfaces used in connector that pass bunch of task object, uses list and not set.", "author": "vmaheshw", "createdAt": "2020-09-29T16:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg1OTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2MTY1MA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496861650", "bodyText": "Does access to _tasks not need to be synchronized?", "author": "DEEPTHIKORAT", "createdAt": "2020-09-29T16:12:55Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -166,8 +173,17 @@ private void populateDefaultProducerConfigs() {\n \n   private Optional<Producer<K, V>> maybeGetKafkaProducer(DatastreamTask task) {\n     Producer<K, V> producer = _kafkaProducer;\n+    if (!_tasks.contains(task)) {", "originalCommit": "528e8b5153543bf4b41712f5124d04ebe0710278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5ODM2Ng==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496898366", "bodyText": "_tasks is a concurrent Hash map and based on its usage, it really does not have to be in synchronized block. We have added other checks as well to catch the misuse. for eg, every send checks if the task is present in _tasks or not.", "author": "vmaheshw", "createdAt": "2020-09-29T17:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2MTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MDg5NA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496870894", "bodyText": "nit: Make this line\nProducer<K, V> producer = maybeGetKafkaProducer(task).get() instead  and use the if (producer == null) check first to throw so you don't need the else block.\nDoes it help to print the task in question in the exception?", "author": "DEEPTHIKORAT", "createdAt": "2020-09-29T16:22:01Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -219,13 +258,18 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n     while (retry) {\n       try {\n         ++numberOfAttempt;\n-        maybeGetKafkaProducer(task).ifPresent(p -> p.send(producerRecord, (metadata, exception) -> {\n-          if (exception == null) {\n-            onComplete.onCompletion(metadata, null);\n-          } else {\n-            onComplete.onCompletion(metadata, generateSendFailure(exception));\n-          }\n-        }));\n+        Optional<Producer<K, V>> producer = maybeGetKafkaProducer(task);", "originalCommit": "528e8b5153543bf4b41712f5124d04ebe0710278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwMDMwMg==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496900302", "bodyText": "I want to avoid calling get() without isPresent() check. Java 11 has introduced a new api ifPresentOrElse() that will make this api cleaner.", "author": "vmaheshw", "createdAt": "2020-09-29T17:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MDg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3ODU4NQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496878585", "bodyText": "is this comment still relevant now that producer access is protected with lock? The code is not harmful, but may be the comment can go if this is not relevant as it might cause some confusion on the intent of the code.", "author": "DEEPTHIKORAT", "createdAt": "2020-09-29T16:30:50Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -254,67 +298,103 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n       } catch (Exception e) {\n         _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n-        throw generateSendFailure(e);\n+        throw generateSendFailure(e, task);\n       }\n     }\n   }\n \n   @VisibleForTesting\n   void shutdownProducer() {\n     Producer<K, V> producer;\n-    synchronized (_producerLock) {\n+    try {\n+      _producerLock.lock();\n+      // if there is no producer or the producer close is in progress, return.\n+      if (_kafkaProducer == null || _closeInProgress) {\n+        return;\n+      }\n       producer = _kafkaProducer;\n+      _closeInProgress = true;\n       // Nullify first to prevent subsequent send() to use", "originalCommit": "528e8b5153543bf4b41712f5124d04ebe0710278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwMjQzNg==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496902436", "bodyText": "Actually I feel the comment helps in understanding the intent, even though we have made sure that the producer close in progress will block the send anyway. In the send() if the producer is not null, it does not check for close in progress.", "author": "vmaheshw", "createdAt": "2020-09-29T17:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3ODU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NzYxNQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496887615", "bodyText": "sorry I might be missing the reason the code looks like this but should it read\n    if (producer != null) {\n       try {\n          producer.flush (...)\n       } catch (..) {\n         ...\n       }\n  } ```", "author": "DEEPTHIKORAT", "createdAt": "2020-09-29T16:44:38Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -254,67 +298,103 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n       } catch (Exception e) {\n         _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n-        throw generateSendFailure(e);\n+        throw generateSendFailure(e, task);\n       }\n     }\n   }\n \n   @VisibleForTesting\n   void shutdownProducer() {\n     Producer<K, V> producer;\n-    synchronized (_producerLock) {\n+    try {\n+      _producerLock.lock();\n+      // if there is no producer or the producer close is in progress, return.\n+      if (_kafkaProducer == null || _closeInProgress) {\n+        return;\n+      }\n       producer = _kafkaProducer;\n+      _closeInProgress = true;\n       // Nullify first to prevent subsequent send() to use\n       // the current producer which is being shutdown.\n       _kafkaProducer = null;\n-    }\n \n-    // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n-    // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n-    // thread\n-    if (producer != null) {\n+      // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n+      // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n+      // thread\n       _producerCloseExecutorService.submit(() -> {\n         _log.info(\"KafkaProducerWrapper: Closing the Kafka Producer\");\n-        producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-        NUM_PRODUCERS.decrementAndGet();\n-        _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        try {\n+          producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+          NUM_PRODUCERS.decrementAndGet();\n+          _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        } finally {\n+          markProducerCloseComplete();\n+        }\n       });\n+    } finally {\n+      _producerLock.unlock();\n     }\n   }\n \n-  private DatastreamRuntimeException generateSendFailure(Exception exception) {\n+  private void markProducerCloseComplete() {\n+    try {\n+      _producerLock.lock();\n+      _closeInProgress = false;\n+      _waitOnProducerClose.signalAll();\n+    } finally {\n+      _producerLock.unlock();\n+    }\n+  }\n+\n+  private DatastreamRuntimeException generateSendFailure(Exception exception, DatastreamTask task) {\n     _dynamicMetricsManager.createOrUpdateMeter(_metricsNamesPrefix, AGGREGATE, PRODUCER_ERROR, 1);\n     if (exception instanceof IllegalStateException) {\n       _log.warn(\"Send failed transiently with exception: \", exception);\n       return new DatastreamTransientException(exception);\n     } else {\n       _log.warn(\"Send failed with a non-transient exception. Shutting down producer, exception: \", exception);\n-      shutdownProducer();\n+      if (_tasks.contains(task)) {\n+        shutdownProducer();\n+      }\n       return new DatastreamRuntimeException(exception);\n     }\n   }\n \n   void flush() {\n-    synchronized (_producerLock) {\n+    Producer<K, V> producer;\n+    try {\n+      _producerLock.lock();\n+      producer = _kafkaProducer;\n+    } finally {\n+      _producerLock.unlock();\n+    }\n+\n+    try {", "originalCommit": "528e8b5153543bf4b41712f5124d04ebe0710278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwNjMzOQ==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496906339", "bodyText": "done.", "author": "vmaheshw", "createdAt": "2020-09-29T17:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NzYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MjM3MA==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496892370", "bodyText": "Is the interruption/timeout typical? Wondering about the use of log.warn which are not too noticeable in logs.. wondering if log.error might be better, but I know it raises false alarms in thinking something is wrong when it is being handled here fine.", "author": "DEEPTHIKORAT", "createdAt": "2020-09-29T16:51:44Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaProducerWrapper.java", "diffHunk": "@@ -254,67 +298,103 @@ void send(DatastreamTask task, ProducerRecord<K, V> producerRecord, Callback onC\n         }\n       } catch (Exception e) {\n         _log.error(String.format(\"Send failed for partition %d with an exception\", producerRecord.partition()), e);\n-        throw generateSendFailure(e);\n+        throw generateSendFailure(e, task);\n       }\n     }\n   }\n \n   @VisibleForTesting\n   void shutdownProducer() {\n     Producer<K, V> producer;\n-    synchronized (_producerLock) {\n+    try {\n+      _producerLock.lock();\n+      // if there is no producer or the producer close is in progress, return.\n+      if (_kafkaProducer == null || _closeInProgress) {\n+        return;\n+      }\n       producer = _kafkaProducer;\n+      _closeInProgress = true;\n       // Nullify first to prevent subsequent send() to use\n       // the current producer which is being shutdown.\n       _kafkaProducer = null;\n-    }\n \n-    // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n-    // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n-    // thread\n-    if (producer != null) {\n+      // This may be called from the send callback. The callbacks are called from the sender thread, and must complete\n+      // quickly to avoid delaying/blocking the sender thread. Thus schedule the actual producer.close() on a separate\n+      // thread\n       _producerCloseExecutorService.submit(() -> {\n         _log.info(\"KafkaProducerWrapper: Closing the Kafka Producer\");\n-        producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-        NUM_PRODUCERS.decrementAndGet();\n-        _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        try {\n+          producer.close(CLOSE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+          NUM_PRODUCERS.decrementAndGet();\n+          _log.info(\"KafkaProducerWrapper: Kafka Producer is closed\");\n+        } finally {\n+          markProducerCloseComplete();\n+        }\n       });\n+    } finally {\n+      _producerLock.unlock();\n     }\n   }\n \n-  private DatastreamRuntimeException generateSendFailure(Exception exception) {\n+  private void markProducerCloseComplete() {\n+    try {\n+      _producerLock.lock();\n+      _closeInProgress = false;\n+      _waitOnProducerClose.signalAll();\n+    } finally {\n+      _producerLock.unlock();\n+    }\n+  }\n+\n+  private DatastreamRuntimeException generateSendFailure(Exception exception, DatastreamTask task) {\n     _dynamicMetricsManager.createOrUpdateMeter(_metricsNamesPrefix, AGGREGATE, PRODUCER_ERROR, 1);\n     if (exception instanceof IllegalStateException) {\n       _log.warn(\"Send failed transiently with exception: \", exception);\n       return new DatastreamTransientException(exception);\n     } else {\n       _log.warn(\"Send failed with a non-transient exception. Shutting down producer, exception: \", exception);\n-      shutdownProducer();\n+      if (_tasks.contains(task)) {\n+        shutdownProducer();\n+      }\n       return new DatastreamRuntimeException(exception);\n     }\n   }\n \n   void flush() {\n-    synchronized (_producerLock) {\n+    Producer<K, V> producer;\n+    try {\n+      _producerLock.lock();\n+      producer = _kafkaProducer;\n+    } finally {\n+      _producerLock.unlock();\n+    }\n+\n+    try {\n+      if (producer != null) {\n+          producer.flush(_producerFlushTimeoutMs, TimeUnit.MILLISECONDS);\n+      }\n+    } catch (InterruptException | TimeoutException e) {\n+      // The KafkaProducer object should not be reused on an interrupted flush\n       try {\n-        if (_kafkaProducer != null) {\n-          _kafkaProducer.flush(_producerFlushTimeoutMs, TimeUnit.MILLISECONDS);\n+        _producerLock.lock();\n+        if (producer == _kafkaProducer) {\n+          _log.warn(\"Kafka producer flush interrupted/timed out, closing producer {}.\", producer);", "originalCommit": "528e8b5153543bf4b41712f5124d04ebe0710278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwNjE5Nw==", "url": "https://github.com/linkedin/brooklin/pull/751#discussion_r496906197", "bodyText": "This will be useful in identifying the producer stuck on flush issues. Yes, you are correct. The reason to not add it as ERROR  is to avoid false alarm. This is a self-recovering scenario which should not need extra attention. So, warns will be sufficient to  identify if this issue happened.", "author": "vmaheshw", "createdAt": "2020-09-29T17:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MjM3MA=="}], "type": "inlineReview"}, {"oid": "b58d1442147bc9eca70dacf839cdecb181e1a26c", "url": "https://github.com/linkedin/brooklin/commit/b58d1442147bc9eca70dacf839cdecb181e1a26c", "message": "Address comments", "committedDate": "2020-09-29T17:34:51Z", "type": "commit"}]}