{"pr_number": 4329, "pr_title": "Adding AutoScaling for cks + CKS CoreOS EOL update + systemvmtemplate improvements", "pr_createdAt": "2020-09-16T06:04:55Z", "pr_url": "https://github.com/apache/cloudstack/pull/4329", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU5MDU1Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694590557", "bodyText": "suggestion - is this global default - can this be zone specific?", "author": "rhtyd", "createdAt": "2021-08-24T07:49:35Z", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -405,6 +405,10 @@\n     static final ConfigKey<Boolean> HaVmRestartHostUp = new ConfigKey<Boolean>(\"Advanced\", Boolean.class, \"ha.vm.restart.hostup\", \"true\",\n             \"If an out-of-band stop of a VM is detected and its host is up, then power on the VM\", true);\n \n+    static final ConfigKey<Long> SystemVmRootDiskSize = new ConfigKey<Long>(\"Advanced\",\n+            Long.class, \"systemvm.root.disk.size\", \"-1\",", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5MzI1Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695793257", "bodyText": "Can be done as part of another phase?", "author": "Pearl1594", "createdAt": "2021-08-25T14:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU5MDU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNDI4MQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694604281", "bodyText": "minor nit - the standard practice is to introduce getters and setters for internal or static fields", "author": "rhtyd", "createdAt": "2021-08-24T08:07:46Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/DatabaseUpgradeChecker.java", "diffHunk": "@@ -364,7 +364,11 @@ public void check() {\n                     return;\n                 }\n \n+                SystemVmTemplateRegistration.parseMetadataFile();\n                 final CloudStackVersion currentVersion = CloudStackVersion.parse(currentVersionValue);\n+                SystemVmTemplateRegistration.CS_MAJOR_VERSION  = String.valueOf(currentVersion.getMajorRelease()) + \".\" + String.valueOf(currentVersion.getMinorRelease());", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNDQzNQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694604435", "bodyText": "minor nit - same as above ^^", "author": "rhtyd", "createdAt": "2021-08-24T08:07:55Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/DatabaseUpgradeChecker.java", "diffHunk": "@@ -364,7 +364,11 @@ public void check() {\n                     return;\n                 }\n \n+                SystemVmTemplateRegistration.parseMetadataFile();\n                 final CloudStackVersion currentVersion = CloudStackVersion.parse(currentVersionValue);\n+                SystemVmTemplateRegistration.CS_MAJOR_VERSION  = String.valueOf(currentVersion.getMajorRelease()) + \".\" + String.valueOf(currentVersion.getMinorRelease());\n+                SystemVmTemplateRegistration.CS_TINY_VERSION = String.valueOf(currentVersion.getPatchRelease());", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNTY4NQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694605685", "bodyText": "Remove unnecessary constructor", "author": "rhtyd", "createdAt": "2021-08-24T08:09:26Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNjc1Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694606752", "bodyText": "Security issue - you may want to randomly create a directory in java tmp space for example:\nPath tempDirWithPrefix = Files.createTempDirectory(prefix);\n\nAnd in the finally block remove the temp directory after unmounting it. Using the tmp directory may also guard against multiple-threads trying to execute this method.", "author": "rhtyd", "createdAt": "2021-08-24T08:10:48Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNzM5Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694607396", "bodyText": "same as last time - what is this magic number?", "author": "rhtyd", "createdAt": "2021-08-24T08:11:41Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNzgyMg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694607822", "bodyText": "Can we use any off-the-shelf utility/method to do checksums? Otherwise, pl add unit tests to cover this method.", "author": "rhtyd", "createdAt": "2021-08-24T08:12:15Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwOTQ3NQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694609475", "bodyText": "Minor nit - refactor/rename the method which is returning template ID? Maybe return Long than long (the idea that return object is null means object not found, otherwise template ID is found and returned - this also allows you to not compare against magic no. -1)?", "author": "rhtyd", "createdAt": "2021-08-24T08:14:11Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgzMzgxNw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695833817", "bodyText": "rather throw an exception than return null imnsho", "author": "DaanHoogland", "createdAt": "2021-08-25T14:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwOTQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjI4Mzk5NA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r696283994", "bodyText": "this has been refactored and handled - thanks", "author": "Pearl1594", "createdAt": "2021-08-26T04:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwOTQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxMjQ2NQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694612465", "bodyText": "Check - These strings are hardcoded, could the cause an issue:\n    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n\nIn different distros, as some of these paths are overridden by build.properties. The relative path is that relative wrt the jar, or is that a file/dir path we use? Or is that to support developer's workflow?", "author": "rhtyd", "createdAt": "2021-08-24T08:16:22Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5NzQ3Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695797473", "bodyText": "The check for ./engine/schema/dist/systemvm-templates/\" path is for developer workflow - similar to this: https://github.com/apache/cloudstack/blob/main/plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java#L7053", "author": "Pearl1594", "createdAt": "2021-08-25T14:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxMjQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxMzMxMg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694613312", "bodyText": "Refactor move this to an already existing Enum?", "author": "rhtyd", "createdAt": "2021-08-24T08:17:00Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNDAyMg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694614022", "bodyText": "Refactor move this to an already existing Enum?\nThe logic would be you ask the Enum or Utility to get the Enum by string; than you can convert the Enum to string or just use Enum.", "author": "rhtyd", "createdAt": "2021-08-24T08:17:32Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5ODUxMw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695798513", "bodyText": "the reason for doing this is that templates names don't have \"xenserver\" / \"ovm3\" but rather \"xen\"/\"ovm\" - hence using this to fetch the template names while parsing the metadata file", "author": "Pearl1594", "createdAt": "2021-08-25T14:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNDAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNTM2Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694615362", "bodyText": "Use Files to create tmp directory than use static - and add a finally block to remove/unmount/cleanup dir.", "author": "rhtyd", "createdAt": "2021-08-24T08:18:31Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNjcyMw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694616723", "bodyText": "This would break/cause maintenance issue/if/when the table changes - see if there's a way to use/initialise GenericDaoBase if possible? If it's not possible then keep as is.", "author": "rhtyd", "createdAt": "2021-08-24T08:19:29Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNzQ2Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694617466", "bodyText": "Minor nit - update name to make more sense (updateSystemVmTemplateDetails?)", "author": "rhtyd", "createdAt": "2021-08-24T08:20:00Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMDk0MQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694620941", "bodyText": "Can we somehow explore transactions? General comment - in this class we're doing many SQL transactions manually instead of using generic dao base, how should the system recover in case of failure; consider this method where you update something, but what if the delete fails afterwards? Similar other cases throughout this class where some statements work but others fail.\nOne way is to wrap each try-catch for each sql query that is not just read-only (select query) and handle on case-by-case basis.", "author": "rhtyd", "createdAt": "2021-08-24T08:22:26Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMjIyNA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694622224", "bodyText": "Check and see if we should run using sudo (there's usually some API param you can pass so commands run as sudo) as mgmt server process runs as cloud user.", "author": "rhtyd", "createdAt": "2021-08-24T08:23:20Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTc5OTg5Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695799897", "bodyText": "I haven't faced any permission issue during mount/umount - so adding sudo may not be required", "author": "Pearl1594", "createdAt": "2021-08-25T14:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMjIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMjcyMA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694622720", "bodyText": "if this is static move this to private static String field?", "author": "rhtyd", "createdAt": "2021-08-24T08:23:42Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMzIyOQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694623229", "bodyText": "Minor nit - should we run this as root user? that is run as sudo/sudoer?", "author": "rhtyd", "createdAt": "2021-08-24T08:24:03Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwMTY3Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695801672", "bodyText": "It isn't required that the script be run by root user - the necessary command - \"touch\" has been added to the  /etc/sudoers.d/cloudstack-management file", "author": "Pearl1594", "createdAt": "2021-08-25T14:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyMzIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyNjI4Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694626287", "bodyText": "General comment:\n\nBreak failure-cases in individual try-catch and apply recovery/finally logic\nFor path creation use a standard utility from Files or other utility/dependency (this code highly assumes Linux and specific paths than tmp folders)\ncan we introduce transactional query? (fail together or pass together)\nUse tmp files and folders and cleanup/unmount/gc in finally", "author": "rhtyd", "createdAt": "2021-08-24T08:26:18Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYyNzU3OA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694627578", "bodyText": "See above method and review comments - seems redundant code, could be refactored together?", "author": "rhtyd", "createdAt": "2021-08-24T08:27:13Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzMDA0Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694630046", "bodyText": "Minor nit - use consistent naming style for public static fields (if not necessary you want to convert them into private static ... fields, or use getters/setters - also makes it easier to write unit tests).", "author": "rhtyd", "createdAt": "2021-08-24T08:28:52Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzMTQxNA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694631414", "bodyText": "Suggestion - instead of four different fields you want a Map of HypervisorType to an object that returns all metadata of the template (name, filename, url and checksum).", "author": "rhtyd", "createdAt": "2021-08-24T08:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzMDA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzMjY4Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694632683", "bodyText": "Instead of four fields, you want a map object that maps hypervisor type to a template object that holds all four properties - filename, checksum, url and name", "author": "rhtyd", "createdAt": "2021-08-24T08:30:41Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, true);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(METADATA_FILE));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzNDM4Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694634383", "bodyText": "HOL UP: Oh dear (/me bites lip) - you want to be very very very cautious with this sort of code; try and use Java Files or similar to do deletion and cleanup :)", "author": "rhtyd", "createdAt": "2021-08-24T08:31:54Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, true);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(METADATA_FILE));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));\n+            }\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to parse systemVM template metadata file: %s\", METADATA_FILE);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void cleanupStore(Long templateId) {\n+        String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + String.valueOf(templateId);\n+        Script.runSimpleBashScript(\"rm -rf \" + destTempFolder);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzNjIyNw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694636227", "bodyText": "You may want to explore non-static way and use tmp directory created by Files, to create folder, mount secondary storage, do all sorts of things.\nhttps://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-", "author": "rhtyd", "createdAt": "2021-08-24T08:33:12Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, true);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(METADATA_FILE));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));\n+            }\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to parse systemVM template metadata file: %s\", METADATA_FILE);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void cleanupStore(Long templateId) {\n+        String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + String.valueOf(templateId);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzNzkzMQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694637931", "bodyText": "Can you explain/simplify logic - break in smaller methods?", "author": "rhtyd", "createdAt": "2021-08-24T08:34:53Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,801 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String HASH_ALGORITHM = \"MD5\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = RELATIVE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = RELATIVE_TEMPLATE_PATH;\n+            }\n+            if (templatePath == null) {\n+                filePath = ABSOLUTE_TEMPLATE_PATH + METADATA_FILE_NAME;\n+                metaFile = new File(filePath);\n+                templatePath = ABSOLUTE_TEMPLATE_PATH;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(MOUNT_COMMAND, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details, boolean updateTemplateDetails) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = null;\n+            if (updateTemplateDetails) {\n+                pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+                if (pstmt != null) {\n+                    pstmt.setLong(i++, details.getSize());\n+                    pstmt.setLong(i++, details.getId());\n+                    pstmt.executeUpdate();\n+                }\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(UMOUNT_COMMAND, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+\n+    private static void setupTemplate(String templateName, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+        String destTempFolder) throws CloudRuntimeException{\n+        String storageScriptsDir = \"scripts/storage/secondary\";\n+        String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+        if (setupTmpltScript == null) {\n+            throw new CloudRuntimeException(\"Unable to find the createtmplt.sh\");\n+        }\n+        Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+        scr.add(\"-u\", templateName);\n+        scr.add(\"-f\", TEMPLATES_PATH + fileNames.get(hypervisorAndTemplateName.first()));\n+        scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+        scr.add(\"-d\", destTempFolder);\n+        String result = scr.execute();\n+        if (result != null) {\n+            String errMsg = String.format(\"failed to create template: %s \", result);\n+            LOGGER.error(errMsg);\n+            throw new CloudRuntimeException(errMsg);\n+        }\n+\n+    }\n+\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName,\n+                                        Pair<String, Long> storeUrlAndId, VMTemplateVO templateVO) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    templateVO.getUrl(), templateVO.getChecksum(), templateVO.getFormat(), (int) templateVO.getGuestOSId(), templateVO.getHypervisorType(),\n+                    storeUrlAndId.second());\n+            templateId = templateVO.getId();\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, false);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            setupTemplate(templateName, hypervisorAndTemplateName, destTempFolder);\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details, true);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(METADATA_FILE));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));\n+            }\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to parse systemVM template metadata file: %s\", METADATA_FILE);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void cleanupStore(Long templateId) {\n+        String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + String.valueOf(templateId);\n+        Script.runSimpleBashScript(\"rm -rf \" + destTempFolder);\n+    }\n+\n+    public static void registerTemplates(Connection conn, Set<Hypervisor.HypervisorType> hypervisorsInUse) {\n+        GlobalLock lock = GlobalLock.getInternLock(\"UpgradeDatabase-Lock\");\n+        try {\n+            LOGGER.info(\"Grabbing lock to register templates.\");\n+            if (!lock.lock(LOCK_WAIT_TIMEOUT)) {\n+                throw new CloudRuntimeException(\"Unable to acquire lock to register SystemVM template.\");\n+            }\n+            // Check if templates path exists\n+            try {\n+                Set<String> hypervisors = hypervisorsInUse.stream().map(Enum::name).\n+                        map(name -> name.toLowerCase(Locale.ROOT)).map(SystemVmTemplateRegistration::getHypervisorName).collect(Collectors.toSet());\n+                List<String> templates = new ArrayList<>();\n+                for (Hypervisor.HypervisorType hypervisorType : hypervisorsInUse) {\n+                    templates.add(fileNames.get(hypervisorType));\n+                }\n+\n+                boolean templatesFound = true;\n+                for (String hypervisor : hypervisors) {\n+                    String matchedTemplate = templates.stream().filter(x -> x.contains(hypervisor)).findAny().orElse(null);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzODgwMg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694638802", "bodyText": "Why specific code for VMware? Can we add some generic utility in this new class (or create a new/different class/manager) and let it handle/do any systemvmtemplate upgrade logic?", "author": "rhtyd", "createdAt": "2021-08-24T08:36:00Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "diffHunk": "@@ -64,6 +66,7 @@ public boolean supportsRollingUpgrade() {\n \n     @Override\n     public void performDataMigration(Connection conn) {\n+        updateVMwareSystemvVMTemplateField(conn, SystemVmTemplateRegistration.NewTemplateNameList.get(Hypervisor.HypervisorType.VMware));", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwMzMwMQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695803301", "bodyText": "This was done as there was a change in  upgrade workflow made in 4.15 - I've now reverted it, as we have gone back to the old w/f of first updating the schema and then registering the template(s)", "author": "Pearl1594", "createdAt": "2021-08-25T14:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzODgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYzOTM5NA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694639394", "bodyText": "Suggestion - move all systemvmtemplate changes to a service/manager/utility class? (as we keep repeating this logic between upgrade classes)", "author": "rhtyd", "createdAt": "2021-08-24T08:36:47Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "diffHunk": "@@ -235,6 +175,16 @@ public void updateSystemVmTemplates(final Connection conn) {\n         LOG.debug(\"Updating System Vm Template IDs Complete\");\n     }\n \n+    private void updateVMwareSystemvVMTemplateField(final Connection conn, String templateName) {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0MDA5Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694640093", "bodyText": "Minor nit - is this guarded for user account/roles (they shouldn't be able to change template type)", "author": "rhtyd", "createdAt": "2021-08-24T08:37:37Z", "path": "engine/schema/src/main/java/com/cloud/vm/UserVmVO.java", "diffHunk": "@@ -48,6 +48,9 @@\n     @Column(name = \"update_parameters\", updatable = true)\n     protected boolean updateParameters = true;\n \n+    @Column(name = \"user_vm_type\", updatable = true)\n+    private String userVmType;", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0ODU3NQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694648575", "bodyText": "Question - are we using cmdline to pass params/args to CKS node? Why not have some logic in systemvmtemplate to fire-up dhcp services, and get params consumed from VR's user-data or config drive?", "author": "rhtyd", "createdAt": "2021-08-24T08:47:03Z", "path": "plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/resource/wrapper/LibvirtStartCommandWrapper.java", "diffHunk": "@@ -88,14 +89,7 @@ public Answer execute(final StartCommand command, final LibvirtComputingResource\n             libvirtComputingResource.applyDefaultNetworkRules(conn, vmSpec, false);\n \n             // pass cmdline info to system vms\n-            if (vmSpec.getType() != VirtualMachine.Type.User) {\n-                String controlIp = null;\n-                for (final NicTO nic : vmSpec.getNics()) {\n-                    if (nic.getType() == TrafficType.Control) {\n-                        controlIp = nic.getIp();\n-                        break;\n-                    }\n-                }\n+            if (vmSpec.getType() != VirtualMachine.Type.User || (vmSpec.getBootArgs() != null && vmSpec.getBootArgs().contains(UserVmManager.CKS_NODE))) {\n                 // try to patch and SSH into the systemvm for up to 5 minutes\n                 for (int count = 0; count < 10; count++) {\n                     // wait and try passCmdLine for 30 seconds at most for CLOUDSTACK-2823", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0OTY5Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694649693", "bodyText": "I think the user-consumed templates shouldn't be allowed to use the systemvm's patching (cmdline specifically). Btw, if we're going with the tradeoff of using same patching mechanism as systemvms, then do we now allow users to ssh to CKS nodes?", "author": "rhtyd", "createdAt": "2021-08-24T08:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0ODU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjI4MTk5NA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r696281994", "bodyText": "Currently, yes, we pass the cmdline args to CKS nodes as we do with systemVMs - and this has been restricted to other userVMs", "author": "Pearl1594", "createdAt": "2021-08-26T04:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY0ODU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MDI3Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694650277", "bodyText": "Nit - Use Files.separator to create the path? Could user.home be not available or defined?", "author": "rhtyd", "createdAt": "2021-08-24T08:48:52Z", "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -425,8 +423,8 @@\n \n     protected static File s_systemVmKeyFile = null;\n     private static final Object s_syncLockObjectFetchKeyFile = new Object();\n-    protected static final String s_relativePathSystemVmKeyFileInstallDir = \"scripts/vm/systemvm/id_rsa.cloud\";\n-    protected static final String s_defaultPathSystemVmKeyFile = \"/usr/share/cloudstack-common/scripts/vm/systemvm/id_rsa.cloud\";\n+    private static final String homeDir = System.getProperty(\"user.home\");\n+    protected static final String s_defaultPathSystemVmKeyFile =  homeDir + \"/.ssh/id_rsa\";", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MTg0Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694651842", "bodyText": "Suggestion - maybe we want to revisit this? We may want to by default require CKS to use systemvmtemplates, but do we want to allow admin/operator/user to bring their own templates? If yes than in future phases, we want to revisit these settings or similar. (for example the create CKS cluster can allow selection of template?) cc @shwstppr @davidjumani", "author": "rhtyd", "createdAt": "2021-08-24T08:50:48Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterService.java", "diffHunk": "@@ -41,26 +41,6 @@\n             \"false\",\n             \"Indicates whether Kubernetes Service plugin is enabled or not. Management server restart needed on change\",\n             false);\n-    static final ConfigKey<String> KubernetesClusterHyperVTemplateName = new ConfigKey<String>(\"Advanced\", String.class,\n-            \"cloud.kubernetes.cluster.template.name.hyperv\",\n-            \"Kubernetes-Service-Template-HyperV\",\n-            \"Name of the template to be used for creating Kubernetes cluster nodes on HyperV\",\n-            true);\n-    static final ConfigKey<String> KubernetesClusterKVMTemplateName = new ConfigKey<String>(\"Advanced\", String.class,\n-            \"cloud.kubernetes.cluster.template.name.kvm\",\n-            \"Kubernetes-Service-Template-KVM\",\n-            \"Name of the template to be used for creating Kubernetes cluster nodes on KVM\",\n-            true);\n-    static final ConfigKey<String> KubernetesClusterVMwareTemplateName = new ConfigKey<String>(\"Advanced\", String.class,\n-            \"cloud.kubernetes.cluster.template.name.vmware\",\n-            \"Kubernetes-Service-Template-VMware\",\n-            \"Name of the template to be used for creating Kubernetes cluster nodes on VMware\",\n-            true);\n-    static final ConfigKey<String> KubernetesClusterXenserverTemplateName = new ConfigKey<String>(\"Advanced\", String.class,\n-            \"cloud.kubernetes.cluster.template.name.xenserver\",\n-            \"Kubernetes-Service-Template-Xenserver\",\n-            \"Name of the template to be used for creating Kubernetes cluster nodes on Xenserver\",\n-            true);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NjQ3NA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694656474", "bodyText": "Does it make sense to move this logic/code as a utility? I see at least 4-5 usage already across systemvms?\n(or better save the base64 encoded string somewhere and simply call use the DB/VO/ConfigKey?)", "author": "rhtyd", "createdAt": "2021-08-24T08:56:44Z", "path": "server/src/main/java/com/cloud/network/router/VirtualNetworkApplianceManagerImpl.java", "diffHunk": "@@ -1939,6 +1941,13 @@ public boolean finalizeVirtualMachineProfile(final VirtualMachineProfile profile\n         if (Boolean.valueOf(_configDao.getValue(\"system.vm.random.password\"))) {\n             buf.append(\" vmpassword=\").append(_configDao.getValue(\"system.vm.password\"));\n         }\n+        String MsPublicKey = _configDao.getValue(\"ssh.publickey\");\n+        String base64EncodedPublicKey = null;\n+        if (MsPublicKey != null) {\n+            base64EncodedPublicKey = Base64.getEncoder().encodeToString(MsPublicKey.getBytes(StandardCharsets.UTF_8));", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NzExNA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694657114", "bodyText": "Isn't LXC same as KVM or there is a different global setting?", "author": "rhtyd", "createdAt": "2021-08-24T08:57:33Z", "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "diffHunk": "@@ -2638,6 +2643,29 @@ public String getName() {\n         return null;\n     }\n \n+    private String getValidTemplateName(Long zoneId, HypervisorType hType) {\n+        String templateName = null;\n+        switch (hType) {\n+            case XenServer:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateXen.valueIn(zoneId);\n+                break;\n+            case KVM:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateKvm.valueIn(zoneId);\n+                break;\n+            case VMware:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateVmware.valueIn(zoneId);\n+                break;\n+            case Hyperv:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateHyperV.valueIn(zoneId);\n+                break;\n+            case LXC:\n+                templateName = VirtualNetworkApplianceManager.RouterTemplateLxc.valueIn(zoneId);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwNzYwNg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695807606", "bodyText": "There is different global setting for LXC's template name", "author": "Pearl1594", "createdAt": "2021-08-25T14:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1NzExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1Nzc4MQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694657781", "bodyText": "Do it like: NFS_IMAGE.equals(providerName) - this style of comparing is more defensive in case providerName is null.", "author": "rhtyd", "createdAt": "2021-08-24T08:58:27Z", "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "diffHunk": "@@ -2722,6 +2750,52 @@ public ImageStore discoverImageStore(String name, String url, String providerNam\n             // populate template_store_ref table\n             _imageSrv.addSystemVMTemplatesToSecondary(store);\n             _imageSrv.handleTemplateSync(store);\n+            if (providerName.equals(DataStoreProvider.NFS_IMAGE) && zoneId != null) {", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1ODUxMg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694658512", "bodyText": "See comment in upgrade path, this is not necessary a  type param already exists.", "author": "rhtyd", "createdAt": "2021-08-24T08:59:27Z", "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -4179,6 +4179,7 @@ public UserVmVO doInTransaction(TransactionStatus status) throws InsufficientCap\n                     }\n                 }\n \n+                vm.setUserVmType(type);", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwODg1Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695808853", "bodyText": "cks nodes are at the end of the day UserVMs - hence, CKSNode userVM type is to further categorize the user vm", "author": "Pearl1594", "createdAt": "2021-08-25T14:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1ODUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1OTM0Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694659347", "bodyText": "Suggestion - we should revisit the initialisation/setup code, otherwise we hardcode/tie exclusively with systemvmtemplate (if not now then in phase2/future)", "author": "rhtyd", "createdAt": "2021-08-24T09:00:30Z", "path": "server/src/main/java/com/cloud/vm/UserVmManagerImpl.java", "diffHunk": "@@ -4603,12 +4604,54 @@ private UserVm startVirtualMachine(long vmId, Long podId, Long clusterId, Long h\n         return vm;\n     }\n \n+    private void addUserVMCmdlineArgs(Long vmId, VirtualMachineProfile profile, DeployDestination dest, StringBuilder buf) {\n+        UserVmVO k8sVM = _vmDao.findById(vmId);\n+        buf.append(\" template=domP\");\n+        buf.append(\" name=\").append(profile.getHostName());\n+        buf.append(\" type=\").append(k8sVM.getUserVmType());\n+        for (NicProfile nic : profile.getNics()) {\n+            int deviceId = nic.getDeviceId();\n+            if (nic.getIPv4Address() == null) {\n+                buf.append(\" eth\").append(deviceId).append(\"ip=\").append(\"0.0.0.0\");", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgwODk3Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695808977", "bodyText": "+1", "author": "Pearl1594", "createdAt": "2021-08-25T14:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1OTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1OTYwOA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694659608", "bodyText": "Use Files to create path?", "author": "rhtyd", "createdAt": "2021-08-24T09:00:50Z", "path": "server/src/main/java/org/apache/cloudstack/diagnostics/DiagnosticsServiceImpl.java", "diffHunk": "@@ -341,7 +341,8 @@ private Answer deleteDiagnosticsZipFileInsystemVm(VMInstanceVO vmInstance, Strin\n             boolean existsInSecondaryStore = dataDirectory.exists() || dataDirectory.mkdir();\n             if (existsInSecondaryStore) {\n                 // scp from system VM to mounted sec storage directory\n-                File permKey = new File(\"/var/cloudstack/management/.ssh/id_rsa\");\n+                String homeDir = System.getProperty(\"user.home\");\n+                File permKey = new File(homeDir + \"/.ssh/id_rsa\");", "originalCommit": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI4NjQ0Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697286446", "bodyText": "Tests advised - run diagnostic tests across all supported distros", "author": "rhtyd", "createdAt": "2021-08-27T09:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1OTYwOA=="}], "type": "inlineReview"}, {"oid": "5a9274028b72bc732cbeac7e4efc3ed75e053190", "url": "https://github.com/apache/cloudstack/commit/5a9274028b72bc732cbeac7e4efc3ed75e053190", "message": "Addressed comments:\n1. random temporary mount directory for secondary stores\n2. use a java utility to do checksum validation\n3. Use Dao for queries\n4. mvn build - checksum validation to overcome caching issue\n5. modularized code, and other changes", "committedDate": "2021-08-25T13:58:15Z", "type": "commit"}, {"oid": "5a9274028b72bc732cbeac7e4efc3ed75e053190", "url": "https://github.com/apache/cloudstack/commit/5a9274028b72bc732cbeac7e4efc3ed75e053190", "message": "Addressed comments:\n1. random temporary mount directory for secondary stores\n2. use a java utility to do checksum validation\n3. Use Dao for queries\n4. mvn build - checksum validation to overcome caching issue\n5. modularized code, and other changes", "committedDate": "2021-08-25T13:58:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkxMTE5OQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693911199", "bodyText": "nice little utility method getIntendedRootDiskSize(DiskOffering rootDiskOfferingInfo, VirtualMachine vm) is in order here.", "author": "DaanHoogland", "createdAt": "2021-08-23T12:05:52Z", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -453,6 +457,12 @@ public void allocate(final String vmInstanceName, final VirtualMachineTemplate t\n \n         final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmFinal, template, serviceOffering, null, null);\n \n+        Long rootDiskSize = rootDiskOfferingInfo.getSize();\n+        if (vm.getType().isUsedBySystem() && SystemVmRootDiskSize.value() != null && SystemVmRootDiskSize.value() > 0L) {\n+            rootDiskSize = SystemVmRootDiskSize.value();\n+        }\n+        final Long rootDiskSizeFinal = rootDiskSize;", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYxNjc2Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694616766", "bodyText": "could this be disected a bit more? at least the if(enable) and its else block in extra methods?", "author": "DaanHoogland", "createdAt": "2021-08-24T08:19:31Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterResourceModifierActionWorker.java", "diffHunk": "@@ -548,13 +565,96 @@ protected String getKubernetesClusterNodeNamePrefix() {\n         return prefix;\n     }\n \n-    protected String getKubernetesClusterNodeAvailableName(final String hostName) {\n-        String name = hostName;\n-        int suffix = 1;\n-        while (vmInstanceDao.findVMByHostName(name) != null) {\n-            name = String.format(\"%s-%d\", hostName, suffix);\n-            suffix++;\n+    protected KubernetesClusterVO updateKubernetesClusterEntry(final Long cores, final Long memory,\n+        final Long size, final Long serviceOfferingId, final Boolean autoscaleEnabled, final Long minSize, final Long maxSize) {\n+        return Transaction.execute(new TransactionCallback<KubernetesClusterVO>() {\n+                @Override\n+                public KubernetesClusterVO doInTransaction(TransactionStatus status) {\n+                KubernetesClusterVO updatedCluster = kubernetesClusterDao.createForUpdate(kubernetesCluster.getId());\n+                if (cores != null) {\n+                    updatedCluster.setCores(cores);\n+                }\n+                if (memory != null) {\n+                    updatedCluster.setMemory(memory);\n+                }\n+                if (size != null) {\n+                    updatedCluster.setNodeCount(size);\n+                }\n+                if (serviceOfferingId != null) {\n+                    updatedCluster.setServiceOfferingId(serviceOfferingId);\n+                }\n+                if (autoscaleEnabled != null) {\n+                    updatedCluster.setAutoscalingEnabled(autoscaleEnabled.booleanValue());\n+                }\n+                updatedCluster.setMinSize(minSize);\n+                updatedCluster.setMaxSize(maxSize);\n+                return kubernetesClusterDao.persist(updatedCluster);\n+            }\n+        });\n+    }\n+\n+    private KubernetesClusterVO updateKubernetesClusterEntry(final Boolean autoscaleEnabled, final Long minSize, final Long maxSize) throws CloudRuntimeException {\n+        KubernetesClusterVO kubernetesClusterVO = updateKubernetesClusterEntry(null, null, null, null, autoscaleEnabled, minSize, maxSize);\n+        if (kubernetesClusterVO == null) {\n+            logTransitStateAndThrow(Level.ERROR, String.format(\"Scaling Kubernetes cluster %s failed, unable to update Kubernetes cluster\",\n+                    kubernetesCluster.getName()), kubernetesCluster.getId(), KubernetesCluster.Event.OperationFailed);\n+        }\n+        return kubernetesClusterVO;\n+    }\n+\n+    protected boolean autoscaleCluster(boolean enable, Long minSize, Long maxSize) {", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MTM2NQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694651365", "bodyText": "good method name; LoadBalancerRuleForAPIAccessForControlNodeVMs", "author": "DaanHoogland", "createdAt": "2021-08-24T08:50:12Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -385,39 +385,45 @@ private void setupKubernetesClusterNetworkRules(Network network, List<UserVm> cl\n                 network.getName(), kubernetesCluster.getName()));\n         }\n \n+        createFirewallRules(publicIp, clusterVMIds);\n+\n+        // Load balancer rule fo API access for control node VMs", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1MjE2Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694652166", "bodyText": "love this one as well: PortForwardingRuleForSSHAccessOnEachNodeVM", "author": "DaanHoogland", "createdAt": "2021-08-24T08:51:15Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -385,39 +385,45 @@ private void setupKubernetesClusterNetworkRules(Network network, List<UserVm> cl\n                 network.getName(), kubernetesCluster.getName()));\n         }\n \n+        createFirewallRules(publicIp, clusterVMIds);\n+\n+        // Load balancer rule fo API access for control node VMs\n+        try {\n+            provisionLoadBalancerRule(publicIp, network, owner, clusterVMIds, CLUSTER_API_PORT);\n+        } catch (NetworkRuleConflictException | InsufficientAddressCapacityException e) {\n+            throw new ManagementServerException(String.format(\"Failed to provision load balancer rule for API access for the Kubernetes cluster : %s\", kubernetesCluster.getName()), e);\n+        }\n+\n+        // Port forwarding rule fo SSH access on each node VM", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyMDAwNQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695820005", "bodyText": "Can you extract this block", "author": "DaanHoogland", "createdAt": "2021-08-25T14:38:20Z", "path": "server/src/main/java/com/cloud/storage/StorageManagerImpl.java", "diffHunk": "@@ -2722,6 +2750,46 @@ public ImageStore discoverImageStore(String name, String url, String providerNam\n             // populate template_store_ref table\n             _imageSrv.addSystemVMTemplatesToSecondary(store);\n             _imageSrv.handleTemplateSync(store);\n+            if (providerName.equals(DataStoreProvider.NFS_IMAGE) && zoneId != null) {", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyMTQ0Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695821446", "bodyText": "this block is repeated ...", "author": "DaanHoogland", "createdAt": "2021-08-25T14:39:52Z", "path": "server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java", "diffHunk": "@@ -2806,7 +2806,12 @@ public Snapshot allocSnapshot(Long volumeId, Long policyId, String snapshotName,\n \n         if (volume.getTemplateId() != null) {\n             VMTemplateVO template = _templateDao.findById(volume.getTemplateId());\n-            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM) {\n+            Long instanceId = volume.getInstanceId();\n+            UserVmVO userVmVO = null;\n+            if (instanceId != null) {\n+                userVmVO = _userVmDao.findById(instanceId);\n+            }\n+            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM && (userVmVO == null || !UserVmManager.CKS_NODE.equals(userVmVO.getUserVmType()))) {", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyMTk0Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695821943", "bodyText": "... here. can you extract?", "author": "DaanHoogland", "createdAt": "2021-08-25T14:40:24Z", "path": "server/src/main/java/com/cloud/storage/VolumeApiServiceImpl.java", "diffHunk": "@@ -2863,7 +2868,12 @@ public Snapshot allocSnapshotForVm(Long vmId, Long volumeId, String snapshotName\n \n         if (volume.getTemplateId() != null) {\n             VMTemplateVO template = _templateDao.findById(volume.getTemplateId());\n-            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM) {\n+            Long instanceId = volume.getInstanceId();\n+            UserVmVO userVmVO = null;\n+            if (instanceId != null) {\n+                userVmVO = _userVmDao.findById(instanceId);\n+            }\n+            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM && (userVmVO == null || !UserVmManager.CKS_NODE.equals(userVmVO.getUserVmType()))) {", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyMjk2NQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695822965", "bodyText": "this block seems to exist in VolumeApiServiceImpl as well (twice)", "author": "DaanHoogland", "createdAt": "2021-08-25T14:41:29Z", "path": "server/src/main/java/com/cloud/storage/snapshot/SnapshotManagerImpl.java", "diffHunk": "@@ -834,7 +835,12 @@ public SnapshotPolicyVO createPolicy(CreateSnapshotPolicyCmd cmd, Account policy\n \n         if (volume.getTemplateId() != null) {\n             VMTemplateVO template = _templateDao.findById(volume.getTemplateId());\n-            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM) {\n+            Long instanceId = volume.getInstanceId();\n+            UserVmVO userVmVO = null;\n+            if (instanceId != null) {\n+                userVmVO = _vmDao.findById(instanceId);\n+            }\n+            if (template != null && template.getTemplateType() == Storage.TemplateType.SYSTEM && (userVmVO == null || !UserVmManager.CKS_NODE.equals(userVmVO.getUserVmType()))) {", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgzODA1Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695838052", "bodyText": "PerformRegistration()", "author": "DaanHoogland", "createdAt": "2021-08-25T14:56:41Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";\n+    private static final String relativeTemplatePath = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String AbsolutetemplatesPath = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String templatesPath = fetchTemplatesPath();\n+    private static final String metadataFileName = \"metadata.ini\";\n+    private static final String metadataFile = templatesPath + metadataFileName;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";\n+    public static String CS_TINY_VERSION = \"0\";\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails() {\n+        }\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> fileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        try {\n+            mountStore(url);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = TEMPORARY_SECONDARY_STORE + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore();\n+        }\n+    }\n+\n+    private static String calculateChecksum(MessageDigest digest, File file) {\n+        try {\n+            FileInputStream fis = new FileInputStream(file);\n+            byte[] byteArray = new byte[1024];\n+            int bytesCount = 0;\n+\n+            while ((bytesCount = fis.read(byteArray)) != -1) {\n+                digest.update(byteArray, 0, bytesCount);\n+            }\n+\n+            fis.close();\n+            byte[] bytes = digest.digest();\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (byte aByte : bytes) {\n+                sb.append(Integer\n+                        .toString((aByte & 0xff) + 0x100, 16)\n+                        .substring(1));\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            String errMsg = String.format(\"Failed to calculate Checksum of template file: %s \", file.getName());\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static long isTemplateAlreadyRegistered(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        long templateId = -1;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\");\n+            // Get systemvm template id for corresponding hypervisor\n+            pstmt.setString(1, hypervisorAndTemplateName.second());\n+            try (ResultSet rs = pstmt.executeQuery()) {\n+                if (rs.next()) {\n+                    templateId = rs.getLong(1);\n+                }\n+            } catch (final SQLException e) {\n+                String errMsg = \"updateSystemVmTemplates: Exception caught while getting ids of SystemVM templates\";\n+                LOGGER.error(errMsg, e);\n+                throw new CloudRuntimeException(errMsg, e);\n+            }\n+        } catch (SQLException e) {\n+            String errorMessage = \"Unable to upgrade the database\";\n+            LOGGER.error(errorMessage, e);\n+            throw new CloudRuntimeException(errorMessage, e);\n+        }\n+        return templateId;\n+    }\n+\n+    private static String fetchTemplatesPath() {\n+            String filePath = relativeTemplatePath + metadataFileName;\n+            LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+            File metaFile = new File(filePath);\n+            String templatePath = null;\n+            if (metaFile.exists()) {\n+                templatePath = relativeTemplatePath;\n+            }\n+            if (templatePath == null) {\n+                filePath = AbsolutetemplatesPath + metadataFileName;\n+                metaFile = new File(filePath);\n+                templatePath = AbsolutetemplatesPath;\n+                LOGGER.debug(String.format(\"Looking for file [ %s ] in the classpath.\", filePath));\n+                if (!metaFile.exists()) {\n+                    String errMsg = String.format(\"Unable to locate metadata file in your setup at %s\", filePath.toString());\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+            }\n+        return templatePath;\n+    }\n+\n+    private static String getHypervisorName(String name) {\n+        if (name.equals(\"xenserver\")) {\n+            return \"xen\";\n+        }\n+        if (name.equals(\"ovm3\")) {\n+            return \"ovm\";\n+        }\n+        return name;\n+\n+    }\n+\n+    private static Hypervisor.HypervisorType getHypervisorType(String hypervisor) {\n+        if (hypervisor.equalsIgnoreCase(\"xen\")) {\n+            hypervisor = \"xenserver\";\n+        } else if (hypervisor.equalsIgnoreCase(\"ovm\")) {\n+            hypervisor = \"ovm3\";\n+        }\n+        return Hypervisor.HypervisorType.getType(hypervisor);\n+    }\n+\n+    private static List<Long> getEligibleZoneIds(Connection conn) {\n+        List<Long> zones = new ArrayList<Long>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_ELIGIBLE_ZONES);\n+            ResultSet rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                zones.add(rs.getLong(1));\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = \"Failed to fetch eligible zones for SystemVM template registration\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return zones;\n+    }\n+\n+    private static Pair<String, Long> getNfsStoreInZone(Connection conn, Long zoneId) {\n+        String url = null;\n+        Long storeId = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_IMAGE_STORE_PER_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    url = resultSet.getString(1);\n+                    storeId = resultSet.getLong(2);\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch NFS store in zone = %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        if (url == null || storeId == null) {\n+            throw new CloudRuntimeException(String.format(\"Failed to get an NFS store in zone: %s\", zoneId));\n+        }\n+        return new Pair<>(url, storeId);\n+    }\n+\n+    public static void mountStore(String storeUrl) {\n+        try {\n+            if (storeUrl != null) {\n+                URI uri = new URI(UriUtils.encodeURIComponent(storeUrl));\n+                String host = uri.getHost();\n+                String mountPath = uri.getPath();\n+                Script.runSimpleBashScript(\"mkdir -p \" + TEMPORARY_SECONDARY_STORE);\n+                String mount = String.format(mountCommand, host + \":\" + mountPath, TEMPORARY_SECONDARY_STORE);\n+                Script.runSimpleBashScript(mount);\n+            }\n+        } catch (Exception e) {\n+            String msg = \"NFS Store URL is not in the correct format\";\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+\n+        }\n+    }\n+\n+    private static List<String> fetchAllHypervisors(Connection conn, Long zoneId) {\n+        List<String> hypervisorList = new ArrayList<>();\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(FETCH_DISTINCT_HYPERVISORS_IN_ZONE);\n+            if(pstmt != null) {\n+                pstmt.setLong(1, zoneId);\n+                ResultSet resultSet = pstmt.executeQuery();\n+                while (resultSet.next()) {\n+                    hypervisorList.add(resultSet.getString(1));\n+                }\n+            }\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"Failed to fetch distinct hypervisors in zone: %s for SystemVM template registration\", zoneId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+        return hypervisorList;\n+    }\n+\n+    private static Long createTemplateObjectInDB(Connection conn, SystemVMTemplateDetails details) {\n+        Long id = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_VM_TEMPLATE_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getUuid());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.setString(i++, details.getChecksum());\n+                pstmt.setString(i++, details.getName());\n+                pstmt.setString(i++, details.getFormat().toString());\n+                pstmt.setLong(i++, details.getGuestOsId());\n+                pstmt.setString(i++, details.getHypervisorType().toString());\n+                pstmt.setBoolean(i++, details.getHypervisorType() == Hypervisor.HypervisorType.VMware);\n+                pstmt.executeUpdate();\n+\n+                pstmt = conn.prepareStatement(\"SELECT id FROM vm_template ORDER BY id DESC LIMIT 1\");\n+                try (ResultSet rs = pstmt.executeQuery()) {\n+                    if (rs.next()) {\n+                        id = rs.getLong(1);\n+                    }\n+                } catch (final SQLException e) {\n+                    String errMsg = \"Failed to fetch template id \";\n+                    LOGGER.error(errMsg, e);\n+                    throw new CloudRuntimeException(errMsg, e);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create vm_template record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+        return id;\n+    }\n+\n+    private static void createTemplateStoreRefEntry(Connection conn, SystemVMTemplateDetails details) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(INSERT_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                int i = 1;\n+                pstmt.setLong(i++, details.getStoreId());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setDate(i++, details.getCreated());\n+                pstmt.setString(i++, details.getInstallPath());\n+                pstmt.setString(i++, details.getUrl());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to create template_store_ref record for the systemVM template for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateDb(Connection conn,  SystemVMTemplateDetails details) {\n+        try {\n+            int i = 1;\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_VM_TEMPLATE_ENTRY);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+            i = 1;\n+            pstmt = conn.prepareStatement(UPDATE_TEMPLATE_STORE_REF_TABLE);\n+            if (pstmt != null) {\n+                pstmt.setLong(i++, details.getSize());\n+                pstmt.setLong(i++, details.getPhysicalSize());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setDate(i++, details.getUpdated());\n+                pstmt.setLong(i++, details.getId());\n+                pstmt.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(String.format(\"Failed to update template_store_ref record for the systemVM template registered for hypervisor: %s\", details.getHypervisorType().name()), e);\n+        }\n+    }\n+\n+    public static void updateSystemVMEntries(Connection conn, Long templateId, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        // update template ID of system Vms\n+        try {\n+            PreparedStatement update_templ_id_pstmt = conn\n+                    .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");\n+            update_templ_id_pstmt.setLong(1, templateId);\n+            update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.first().toString());\n+            update_templ_id_pstmt.executeUpdate();\n+        } catch (SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates:Exception while setting template for %s to %s\",hypervisorAndTemplateName.first().toString(), templateId);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void updateConfigurationParams(Connection conn, Map<String, String> configParams) {\n+        String key = null;\n+        String value = null;\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_CONFIGURATION_TABLE);\n+            for (Map.Entry<String, String> config : configParams.entrySet()) {\n+                key = config.getKey();\n+                value = config.getValue();\n+                pstmt.setString(1, value);\n+                pstmt.setString(2, key);\n+                pstmt.executeUpdate();\n+            }\n+\n+        } catch (final SQLException e) {\n+            String errMsg = String.format(\"updateSystemVmTemplates: Exception while setting %s to %s \", key, value);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void readTemplateProperties(String path, SystemVMTemplateDetails details) {\n+        File tmpFile = new File(path);\n+        Long size = null;\n+        Long physicalSize = 0L;\n+        try (FileReader fr = new FileReader(tmpFile); BufferedReader brf = new BufferedReader(fr);) {\n+            String line = null;\n+            while ((line = brf.readLine()) != null) {\n+                if (line.startsWith(\"size=\")) {\n+                    physicalSize = Long.parseLong(line.split(\"=\")[1]);\n+                } else if (line.startsWith(\"virtualsize=\")) {\n+                    size = Long.parseLong(line.split(\"=\")[1]);\n+                }\n+                if (size == null) {\n+                    size = physicalSize;\n+                }\n+            }\n+        } catch (IOException ex) {\n+            LOGGER.warn(\"Failed to read from template.properties\", ex);\n+        }\n+        details.setSize(size);\n+        details.setPhysicalSize(physicalSize);\n+    }\n+\n+    private static  void updateTemplateTablesOnFailure(Connection conn, long templateId) {\n+        try {\n+            PreparedStatement pstmt = conn.prepareStatement(UPDATE_TEMPLATE_TABLE_ON_FAILURE);\n+            if (pstmt != null) {\n+                Date removedTime = new Date(DateUtil.currentGMTTime().getTime());\n+                pstmt.setDate(1, removedTime);\n+                pstmt.setLong(2, templateId);\n+                pstmt.executeUpdate();\n+            }\n+\n+            PreparedStatement pstmt1 = conn.prepareStatement(DELETE_TEMPLATE_REF_RECORD_ON_FAILURE);\n+            if (pstmt1 != null) {\n+                pstmt1.setLong(1, templateId);\n+                pstmt1.executeUpdate();\n+            }\n+        } catch (Exception e) {\n+            String errMsg = \"updateSystemVmTemplates: Exception while updating vm_template and template_store_ref tables on failure\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void unmountStore() {\n+        try {\n+            LOGGER.info(\"Unmounting store\");\n+            String umountCmd = String.format(umountCommand, TEMPORARY_SECONDARY_STORE);\n+            Script.runSimpleBashScript(umountCmd);\n+        } catch (Exception e) {\n+            String msg = String.format(\"Failed to unmount store mounted at %s\", TEMPORARY_SECONDARY_STORE);\n+            LOGGER.error(msg, e);\n+            throw new CloudRuntimeException(msg, e);\n+        }\n+    }\n+    public static void registerTemplate(Connection conn, Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName, Pair<String, Long> storeUrlAndId) {\n+        Long templateId = null;\n+        try {\n+            Hypervisor.HypervisorType hypervisor = hypervisorAndTemplateName.first();\n+            final String templateName = UUID.randomUUID().toString();\n+            Date created = new Date(DateUtil.currentGMTTime().getTime());\n+            SystemVMTemplateDetails details = new SystemVMTemplateDetails(templateName, hypervisorAndTemplateName.second(), created,\n+                    newTemplateUrl.get(hypervisor), newTemplateChecksum.get(hypervisor), hypervisorImageFormat.get(hypervisor), hypervisorGuestOsMap.get(hypervisor), hypervisor, storeUrlAndId.second());\n+            templateId = createTemplateObjectInDB(conn, details);\n+            if (templateId == null) {\n+                throw new CloudRuntimeException(String.format(\"Failed to register template for hypervisor: %s\", hypervisor.name()));\n+            }\n+            details.setId(templateId);\n+            String destTempFolderName = String.valueOf(templateId);\n+            String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + destTempFolderName;\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            createTemplateStoreRefEntry(conn, details);\n+            String storageScriptsDir = \"scripts/storage/secondary\";\n+            String setupTmpltScript = Script.findScript(storageScriptsDir, \"setup-sysvm-tmplt\");\n+            if (setupTmpltScript == null) {\n+                throw new ConfigurationException(\"Unable to find the createtmplt.sh\");\n+            }\n+            Script scr = new Script(setupTmpltScript, SCRIPT_TIMEOUT, LOGGER);\n+            scr.add(\"-u\", templateName);\n+            scr.add(\"-f\", templatesPath + fileNames.get(hypervisorAndTemplateName.first()));\n+            scr.add(\"-h\", hypervisorAndTemplateName.first().name().toLowerCase(Locale.ROOT));\n+            scr.add(\"-d\", destTempFolder);\n+            String result = scr.execute();\n+            if (result != null) {\n+                String errMsg = String.format(\"failed to create template: %s \", result);\n+                LOGGER.error(errMsg);\n+                throw new CloudRuntimeException(errMsg);\n+            }\n+            details.setInstallPath(PARTIAL_TEMPLATE_FOLDER + destTempFolderName + File.separator + templateName + \".\" + hypervisorImageFormat.get(hypervisor).getFileExtension());\n+            readTemplateProperties(destTempFolder + \"/template.properties\", details);\n+            details.setUpdated(new Date(DateUtil.currentGMTTime().getTime()));\n+            updateDb(conn, details);\n+            Map<String, String> configParams = new HashMap<>();\n+            configParams.put(SystemVmTemplateRegistration.routerTemplateConfigurationNames.get(hypervisorAndTemplateName.first()), hypervisorAndTemplateName.second());\n+            configParams.put(\"minreq.sysvmtemplate.version\", CS_MAJOR_VERSION + \".\" + CS_TINY_VERSION);\n+            updateConfigurationParams(conn, configParams);\n+            updateSystemVMEntries(conn, templateId, hypervisorAndTemplateName);\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to register template for hypervisor: %s\", hypervisorAndTemplateName.first());\n+            LOGGER.error(errMsg, e);\n+            if (templateId != null) {\n+                updateTemplateTablesOnFailure(conn, templateId);\n+                cleanupStore(templateId);\n+            }\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public static void parseMetadataFile() {\n+        try {\n+            Ini ini = new Ini();\n+            ini.load(new FileReader(metadataFile));\n+            for (Hypervisor.HypervisorType hypervisorType : hypervisorList) {\n+                String hypervisor = hypervisorType.name().toLowerCase(Locale.ROOT);\n+                Ini.Section section = ini.get(hypervisor);\n+                NewTemplateNameList.put(hypervisorType, section.get(\"templatename\"));\n+                fileNames.put(hypervisorType, section.get(\"filename\"));\n+                newTemplateChecksum.put(hypervisorType, section.get(\"checksum\"));\n+                newTemplateUrl.put(hypervisorType, section.get(\"downloadurl\"));\n+            }\n+        } catch (Exception e) {\n+            String errMsg = String.format(\"Failed to parse systemVM template metadata file: %s\", metadataFile);\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    private static void cleanupStore(Long templateId) {\n+        String destTempFolder = PARENT_TEMPLATE_FOLDER + PARTIAL_TEMPLATE_FOLDER + String.valueOf(templateId);\n+        Script.runSimpleBashScript(\"rm -rf \" + destTempFolder);\n+    }\n+\n+    public static void registerTemplates(Connection conn, Set<Hypervisor.HypervisorType> hypervisorsInUse) {\n+        GlobalLock lock = GlobalLock.getInternLock(\"UpgradeDatabase-Lock\");\n+        try {\n+            LOGGER.info(\"Grabbing lock to register templates.\");\n+            if (!lock.lock(LOCK_WAIT_TIMEOUT)) {\n+                throw new CloudRuntimeException(\"Unable to acquire lock to register SystemVM template.\");\n+            }\n+            // Check if templates path exists\n+            try {\n+                Set<String> hypervisors = hypervisorsInUse.stream().map(Enum::name).\n+                        map(name -> name.toLowerCase(Locale.ROOT)).map(SystemVmTemplateRegistration::getHypervisorName).collect(Collectors.toSet());\n+                List<String> templates = new ArrayList<>();\n+                for (Hypervisor.HypervisorType hypervisorType : hypervisorsInUse) {\n+                    templates.add(fileNames.get(hypervisorType));\n+                }\n+\n+                boolean templatesFound = true;\n+                for (String hypervisor : hypervisors) {\n+                    String matchedTemplate = templates.stream().filter(x -> x.contains(hypervisor)).findAny().orElse(null);\n+                    if (matchedTemplate == null) {\n+                        templatesFound = false;\n+                        break;\n+                    }\n+                    MessageDigest mdigest = MessageDigest.getInstance(hashAlgorithm);\n+                    File tempFile = new File(templatesPath + matchedTemplate);\n+                    String templateChecksum = calculateChecksum(mdigest, tempFile);\n+                    if (!templateChecksum.equals(newTemplateChecksum.get(getHypervisorType(hypervisor)))) {\n+                        LOGGER.error(String.format(\"Checksum mismatch: %s != %s \", templateChecksum, newTemplateChecksum.get(getHypervisorType(hypervisor))));\n+                        templatesFound = false;\n+                        break;\n+                    }\n+                }\n+\n+                if (!templatesFound) {\n+                    String errMsg = \"SystemVm template not found. Cannot upgrade system Vms\";\n+                    LOGGER.error(errMsg);\n+                    throw new CloudRuntimeException(errMsg);\n+                }\n+\n+                // Perform Registration if templates not already registered", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7196216185e30ac3810aa8315b1abddf2b6cd6ef", "url": "https://github.com/apache/cloudstack/commit/7196216185e30ac3810aa8315b1abddf2b6cd6ef", "message": "Address Review comments - part2:\n1. extract repeated code to a common location - wrt adding encoded public key to the cmdline args\n2. changed name of folder containing systemvm templates on MS\n3. Use Files for creating folders as opposed to bash cmds\n4. extract code", "committedDate": "2021-08-26T05:13:17Z", "type": "commit"}, {"oid": "53431365fb666ebb85de1861bf5899f08d4fc8a6", "url": "https://github.com/apache/cloudstack/commit/53431365fb666ebb85de1861bf5899f08d4fc8a6", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-26T05:14:15Z", "type": "commit"}, {"oid": "788247e1aef237d66fc33eb9febc610b7550d02d", "url": "https://github.com/apache/cloudstack/commit/788247e1aef237d66fc33eb9febc610b7550d02d", "message": "fix filepath", "committedDate": "2021-08-26T08:23:49Z", "type": "commit"}, {"oid": "3249c8b7c45c39dc6a84321e46cf0c9789a03f94", "url": "https://github.com/apache/cloudstack/commit/3249c8b7c45c39dc6a84321e46cf0c9789a03f94", "message": "register template with same name in the 2 stores", "committedDate": "2021-08-26T10:22:48Z", "type": "commit"}, {"oid": "3c3b33683cba1c81dbb816124a081d0bc784051e", "url": "https://github.com/apache/cloudstack/commit/3c3b33683cba1c81dbb816124a081d0bc784051e", "message": "Not to use uuid as unique name to avoid unnecessary re-syncs + list templates refactor", "committedDate": "2021-08-26T13:50:39Z", "type": "commit"}, {"oid": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183", "url": "https://github.com/apache/cloudstack/commit/5fa86f5a1a1c90971cd1676f6f6aa0e27b281183", "message": "reduce no of db updates + revert vmwareResource change", "committedDate": "2021-08-27T06:21:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI2NDAyNQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697264025", "bodyText": "@Pearl1594 just check/revisit", "author": "rhtyd", "createdAt": "2021-08-27T08:44:33Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";", "originalCommit": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI2NzY1MA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697267650", "bodyText": "@Pearl1594 can we make it use dao/vo as well?", "author": "rhtyd", "createdAt": "2021-08-27T08:49:55Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARTIAL_TEMPLATE_FOLDER = String.format(\"/template/tmpl/%d/\", Account.ACCOUNT_ID_SYSTEM);\n+    private static final String FETCH_REGISTERED_TEMPLATE_INSTALL_PATH = \"SELECT install_path FROM `cloud`.`template_store_ref` where template_id = ? LIMIT 1\";", "originalCommit": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI2ODY2MA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697268660", "bodyText": "Put a comment to explain the guest OS ID", "author": "rhtyd", "createdAt": "2021-08-27T08:51:18Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARTIAL_TEMPLATE_FOLDER = String.format(\"/template/tmpl/%d/\", Account.ACCOUNT_ID_SYSTEM);\n+    private static final String FETCH_REGISTERED_TEMPLATE_INSTALL_PATH = \"SELECT install_path FROM `cloud`.`template_store_ref` where template_id = ? LIMIT 1\";\n+    private static final String storageScriptsDir = \"scripts/storage/secondary\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    private static final Integer TOKEN_LENGTH = 10;\n+\n+    public static String CS_MAJOR_VERSION = null;\n+    public static String CS_TINY_VERSION = null;\n+\n+    @Inject\n+    DataCenterDao dataCenterDao;\n+    @Inject\n+    VMTemplateDao vmTemplateDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    VMInstanceDao vmInstanceDao;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    ClusterDao clusterDao;\n+    @Inject\n+    ConfigurationDao configurationDao;\n+\n+    public SystemVmTemplateRegistration() {\n+        dataCenterDao = new DataCenterDaoImpl();\n+        vmTemplateDao = new VMTemplateDaoImpl();\n+        templateDataStoreDao = new BasicTemplateDataStoreDaoImpl();\n+        vmInstanceDao = new VMInstanceDaoImpl();\n+        imageStoreDao = new ImageStoreDaoImpl();\n+        clusterDao = new ClusterDaoImpl();\n+        configurationDao = new ConfigurationDaoImpl();\n+    }\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> FileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);", "originalCommit": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI3MDY5Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697270693", "bodyText": "Explore use of Files", "author": "rhtyd", "createdAt": "2021-08-27T08:54:04Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARTIAL_TEMPLATE_FOLDER = String.format(\"/template/tmpl/%d/\", Account.ACCOUNT_ID_SYSTEM);\n+    private static final String FETCH_REGISTERED_TEMPLATE_INSTALL_PATH = \"SELECT install_path FROM `cloud`.`template_store_ref` where template_id = ? LIMIT 1\";\n+    private static final String storageScriptsDir = \"scripts/storage/secondary\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    private static final Integer TOKEN_LENGTH = 10;\n+\n+    public static String CS_MAJOR_VERSION = null;\n+    public static String CS_TINY_VERSION = null;\n+\n+    @Inject\n+    DataCenterDao dataCenterDao;\n+    @Inject\n+    VMTemplateDao vmTemplateDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    VMInstanceDao vmInstanceDao;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    ClusterDao clusterDao;\n+    @Inject\n+    ConfigurationDao configurationDao;\n+\n+    public SystemVmTemplateRegistration() {\n+        dataCenterDao = new DataCenterDaoImpl();\n+        vmTemplateDao = new VMTemplateDaoImpl();\n+        templateDataStoreDao = new BasicTemplateDataStoreDaoImpl();\n+        vmInstanceDao = new VMInstanceDaoImpl();\n+        imageStoreDao = new ImageStoreDaoImpl();\n+        clusterDao = new ClusterDaoImpl();\n+        configurationDao = new ConfigurationDaoImpl();\n+    }\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> FileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static String generateToken(int length) {", "originalCommit": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI3MTU0OA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697271548", "bodyText": "Nit - Magic no. check can be avoided if primitive fields are not used", "author": "rhtyd", "createdAt": "2021-08-27T08:55:13Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,778 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String MOUNT_COMMAND = \"sudo mount -t nfs %s %s\";\n+    private static final String UMOUNT_COMMAND = \"sudo umount %s\";\n+    private static final String RELATIVE_TEMPLATE_PATH = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String ABSOLUTE_TEMPLATE_PATH = \"/usr/share/cloudstack-management/templates/systemvm/\";\n+    private static final String TEMPLATES_PATH = fetchTemplatesPath();\n+    private static final String METADATA_FILE_NAME = \"metadata.ini\";\n+    private static final String METADATA_FILE = TEMPLATES_PATH + METADATA_FILE_NAME;\n+    public static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARTIAL_TEMPLATE_FOLDER = String.format(\"/template/tmpl/%d/\", Account.ACCOUNT_ID_SYSTEM);\n+    private static final String FETCH_REGISTERED_TEMPLATE_INSTALL_PATH = \"SELECT install_path FROM `cloud`.`template_store_ref` where template_id = ? LIMIT 1\";\n+    private static final String storageScriptsDir = \"scripts/storage/secondary\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    private static final Integer TOKEN_LENGTH = 10;\n+\n+    public static String CS_MAJOR_VERSION = null;\n+    public static String CS_TINY_VERSION = null;\n+\n+    @Inject\n+    DataCenterDao dataCenterDao;\n+    @Inject\n+    VMTemplateDao vmTemplateDao;\n+    @Inject\n+    TemplateDataStoreDao templateDataStoreDao;\n+    @Inject\n+    VMInstanceDao vmInstanceDao;\n+    @Inject\n+    ImageStoreDao imageStoreDao;\n+    @Inject\n+    ClusterDao clusterDao;\n+    @Inject\n+    ConfigurationDao configurationDao;\n+\n+    public SystemVmTemplateRegistration() {\n+        dataCenterDao = new DataCenterDaoImpl();\n+        vmTemplateDao = new VMTemplateDaoImpl();\n+        templateDataStoreDao = new BasicTemplateDataStoreDaoImpl();\n+        vmInstanceDao = new VMInstanceDaoImpl();\n+        imageStoreDao = new ImageStoreDaoImpl();\n+        clusterDao = new ClusterDaoImpl();\n+        configurationDao = new ConfigurationDaoImpl();\n+    }\n+\n+    private static class SystemVMTemplateDetails {\n+        Long id;\n+        String uuid;\n+        String name;\n+        String uniqueName;\n+        Date created;\n+        String url;\n+        String checksum;\n+        ImageFormat format;\n+        Integer guestOsId;\n+        Hypervisor.HypervisorType hypervisorType;\n+        Long storeId;\n+        Long size;\n+        Long physicalSize;\n+        String installPath;\n+        boolean deployAsIs;\n+        Date updated;\n+\n+        SystemVMTemplateDetails(String uuid, String name, Date created, String url, String checksum,\n+                                ImageFormat format, Integer guestOsId, Hypervisor.HypervisorType hypervisorType,\n+                                Long storeId) {\n+            this.uuid = uuid;\n+            this.name = name;\n+            this.created = created;\n+            this.url = url;\n+            this.checksum = checksum;\n+            this.format = format;\n+            this.guestOsId = guestOsId;\n+            this.hypervisorType = hypervisorType;\n+            this.storeId = storeId;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public String getUuid() {\n+            return uuid;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public Date getCreated() {\n+            return created;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getChecksum() {\n+            return checksum;\n+        }\n+\n+        public ImageFormat getFormat() {\n+            return format;\n+        }\n+\n+        public Integer getGuestOsId() {\n+            return guestOsId;\n+        }\n+\n+        public Hypervisor.HypervisorType getHypervisorType() {\n+            return hypervisorType;\n+        }\n+\n+        public Long getStoreId() {\n+            return storeId;\n+        }\n+\n+        public Long getSize() {\n+            return size;\n+        }\n+\n+        public void setSize(Long size) {\n+            this.size = size;\n+        }\n+\n+        public Long getPhysicalSize() {\n+            return physicalSize;\n+        }\n+\n+        public void setPhysicalSize(Long physicalSize) {\n+            this.physicalSize = physicalSize;\n+        }\n+\n+        public String getInstallPath() {\n+            return installPath;\n+        }\n+\n+        public void setInstallPath(String installPath) {\n+            this.installPath = installPath;\n+        }\n+\n+        public String getUniqueName() {\n+            return uniqueName;\n+        }\n+\n+        public void setUniqueName(String uniqueName) {\n+            this.uniqueName = uniqueName;\n+        }\n+\n+        public boolean isDeployAsIs() {\n+            return deployAsIs;\n+        }\n+\n+        public void setDeployAsIs(boolean deployAsIs) {\n+            this.deployAsIs = deployAsIs;\n+        }\n+\n+        public Date getUpdated() {\n+            return updated;\n+        }\n+\n+        public void setUpdated(Date updated) {\n+            this.updated = updated;\n+        }\n+    }\n+\n+    public static final List<Hypervisor.HypervisorType> hypervisorList = Arrays.asList(Hypervisor.HypervisorType.KVM,\n+            Hypervisor.HypervisorType.VMware,\n+            Hypervisor.HypervisorType.XenServer,\n+            Hypervisor.HypervisorType.Hyperv,\n+            Hypervisor.HypervisorType.LXC,\n+            Hypervisor.HypervisorType.Ovm3\n+    );\n+\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> FileNames = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>();\n+    public static final Map<Hypervisor.HypervisorType, String> NewTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>();\n+\n+    public static final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n+            put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n+            put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n+            put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n+            put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n+            put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, Integer> hypervisorGuestOsMap = new HashMap<Hypervisor.HypervisorType, Integer>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, 15);\n+            put(Hypervisor.HypervisorType.XenServer, 99);\n+            put(Hypervisor.HypervisorType.VMware, 99);\n+            put(Hypervisor.HypervisorType.Hyperv, 15);\n+            put(Hypervisor.HypervisorType.LXC, 15);\n+            put(Hypervisor.HypervisorType.Ovm3, 183);\n+        }\n+    };\n+\n+    public static final Map<Hypervisor.HypervisorType, ImageFormat> hypervisorImageFormat = new HashMap<Hypervisor.HypervisorType, ImageFormat>() {\n+        {\n+            put(Hypervisor.HypervisorType.KVM, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.XenServer, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.VMware, ImageFormat.OVA);\n+            put(Hypervisor.HypervisorType.Hyperv, ImageFormat.VHD);\n+            put(Hypervisor.HypervisorType.LXC, ImageFormat.QCOW2);\n+            put(Hypervisor.HypervisorType.Ovm3, ImageFormat.RAW);\n+        }\n+    };\n+\n+    public static String generateToken(int length) {\n+        String charset = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+        Random rand = new Random(System.currentTimeMillis());\n+        StringBuffer sb = new StringBuffer();\n+        for (int i = 0; i < length; i++) {\n+            int pos = rand.nextInt(charset.length());\n+            sb.append(charset.charAt(pos));\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static boolean validateIfSeeded(String url, String path) {\n+        String filePath = TEMPORARY_SECONDARY_STORE + generateToken(TOKEN_LENGTH);\n+        try {\n+            mountStore(url, filePath);\n+            int lastIdx = path.lastIndexOf(File.separator);\n+            String partialDirPath = path.substring(0, lastIdx);\n+            String templatePath = filePath + File.separator + partialDirPath;\n+            File templateProps = new File(templatePath + \"/template.properties\");\n+            if (templateProps.exists()) {\n+                LOGGER.info(\"SystemVM template already seeded, skipping registration\");\n+                return true;\n+            }\n+            LOGGER.info(\"SystemVM template not seeded\");\n+            return false;\n+        } catch (Exception e) {\n+            LOGGER.error(\"Failed to verify if the template is seeded\", e);\n+            throw new CloudRuntimeException(\"Failed to verify if the template is seeded\", e);\n+        } finally {\n+            unmountStore(filePath);\n+        }\n+    }\n+\n+    private String calculateChecksum(File file) {\n+        try (InputStream is = Files.newInputStream(Paths.get(file.getPath()))) {\n+            return DigestUtils.md5Hex(is);\n+        } catch (IOException e) {\n+            String errMsg = \"Failed to calculate template checksum\";\n+            LOGGER.error(errMsg, e);\n+            throw new CloudRuntimeException(errMsg, e);\n+        }\n+    }\n+\n+    public long getRegisteredTemplateId(Pair<Hypervisor.HypervisorType, String> hypervisorAndTemplateName) {\n+        VMTemplateVO vmTemplate = vmTemplateDao.findLatestTemplateByName(hypervisorAndTemplateName.second());\n+        long templateId = -1;", "originalCommit": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzI3NzU4NQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r697277585", "bodyText": "Can we refactor and move this to the systemvmtemplate check/register service/class...", "author": "rhtyd", "createdAt": "2021-08-27T09:03:53Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41510to41600.java", "diffHunk": "@@ -66,10 +71,15 @@ public boolean supportsRollingUpgrade() {\n     public void performDataMigration(Connection conn) {\n     }\n \n+    private void initSystemVmTemplateRegistration() {\n+        systemVmTemplateRegistration = new SystemVmTemplateRegistration();\n+    }\n+\n     @Override\n     @SuppressWarnings(\"serial\")\n     public void updateSystemVmTemplates(final Connection conn) {", "originalCommit": "5fa86f5a1a1c90971cd1676f6f6aa0e27b281183", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1532adaecab523a584f890deb9dfdd721235ff3", "url": "https://github.com/apache/cloudstack/commit/e1532adaecab523a584f890deb9dfdd721235ff3", "message": "Address comments:\n1. Move upgrade logic completely to new class\n2. Use Files for creation of temp directories\n3. Use Daos for existing sql queries in the upgrade path\n4. Define constants for guest os ids", "committedDate": "2021-08-31T05:59:08Z", "type": "commit"}, {"oid": "d505d5ffa3eb6f8a90bc33266d015ab56141fa2b", "url": "https://github.com/apache/cloudstack/commit/d505d5ffa3eb6f8a90bc33266d015ab56141fa2b", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-31T06:07:27Z", "type": "commit"}, {"oid": "41c276583ad87faf2255f6d71783039d9692b54d", "url": "https://github.com/apache/cloudstack/commit/41c276583ad87faf2255f6d71783039d9692b54d", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-09-02T14:53:14Z", "type": "commit"}, {"oid": "10f5e61ba8b1a1d45277473ee43ca40b48a07617", "url": "https://github.com/apache/cloudstack/commit/10f5e61ba8b1a1d45277473ee43ca40b48a07617", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-09-08T05:51:04Z", "type": "commit"}, {"oid": "28a03b25ab4556211efa3d80854b557952a38d15", "url": "https://github.com/apache/cloudstack/commit/28a03b25ab4556211efa3d80854b557952a38d15", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-09-16T05:51:37Z", "type": "commit"}, {"id": "PRRC_kwDOAJTq2M4qT098", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r709840764", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Set<HypervisorType> getDistictAvailableHypervisorsAcrossClusters();\n          \n          \n            \n                Set<HypervisorType> getDistinctAvailableHypervisorsAcrossClusters();\n          \n      \n    \n    \n  \n\ntypo ^^^", "author": "sureshanaparti", "createdAt": "2021-09-16T07:12:45Z", "path": "engine/schema/src/main/java/com/cloud/dc/dao/ClusterDao.java", "diffHunk": "@@ -34,6 +35,8 @@\n \n     List<HypervisorType> getAvailableHypervisorInZone(Long zoneId);\n \n+    Set<HypervisorType> getDistictAvailableHypervisorsAcrossClusters();", "originalCommit": "28a03b25ab4556211efa3d80854b557952a38d15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "PRRC_kwDOAJTq2M4qT1Qg", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r709841952", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set<HypervisorType> hypers = new HashSet<>();\n          \n          \n            \n                    Set<HypervisorType> hypervisorTypes = new HashSet<>();", "author": "sureshanaparti", "createdAt": "2021-09-16T07:13:50Z", "path": "engine/schema/src/main/java/com/cloud/dc/dao/ClusterDaoImpl.java", "diffHunk": "@@ -154,6 +161,17 @@ public ClusterVO findBy(String name, long podId) {\n         return hypers;\n     }\n \n+    @Override\n+    public Set<HypervisorType> getDistictAvailableHypervisorsAcrossClusters() {\n+        SearchCriteria<ClusterVO> sc = ClusterSearch.create();\n+        List<ClusterVO> clusters = listBy(sc);\n+        Set<HypervisorType> hypers = new HashSet<>();", "originalCommit": "28a03b25ab4556211efa3d80854b557952a38d15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "PRRC_kwDOAJTq2M4qT3C6", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r709849274", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class SystemVmTemplateRegistration {\n          \n          \n            \n            public class SystemVmTemplate {", "author": "sureshanaparti", "createdAt": "2021-09-16T07:20:16Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,849 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.dc.dao.ClusterDao;\n+import com.cloud.dc.dao.ClusterDaoImpl;\n+import com.cloud.dc.dao.DataCenterDao;\n+import com.cloud.dc.dao.DataCenterDaoImpl;\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.DataStoreRole;\n+import com.cloud.storage.Storage;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.storage.VMTemplateStorageResourceAssoc;\n+import com.cloud.storage.VMTemplateVO;\n+import com.cloud.storage.dao.VMTemplateDao;\n+import com.cloud.storage.dao.VMTemplateDaoImpl;\n+import com.cloud.template.VirtualMachineTemplate;\n+import com.cloud.upgrade.dao.BasicTemplateDataStoreDaoImpl;\n+import com.cloud.user.Account;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.db.Transaction;\n+import com.cloud.utils.db.TransactionCallbackNoReturn;\n+import com.cloud.utils.db.TransactionStatus;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import com.cloud.vm.dao.VMInstanceDao;\n+import com.cloud.vm.dao.VMInstanceDaoImpl;\n+import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDao;\n+import org.apache.cloudstack.framework.config.dao.ConfigurationDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreDaoImpl;\n+import org.apache.cloudstack.storage.datastore.db.ImageStoreVO;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;\n+import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;\n+import org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.inject.Inject;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {", "originalCommit": "28a03b25ab4556211efa3d80854b557952a38d15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "PRRC_kwDOAJTq2M4qX0dN", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r710887245", "bodyText": "shouldn't this now become a standard check and no longer part of a specific upgrade step?", "author": "DaanHoogland", "createdAt": "2021-09-17T09:07:46Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41520to41600.java", "diffHunk": "@@ -92,173 +92,20 @@ private void generateUuidForExistingSshKeyPairs(Connection conn) {\n         }\n     }\n \n+    private void initSystemVmTemplateRegistration() {\n+        systemVmTemplateRegistration = new SystemVmTemplateRegistration();\n+    }\n+\n     @Override\n     @SuppressWarnings(\"serial\")\n     public void updateSystemVmTemplates(final Connection conn) {\n         LOG.debug(\"Updating System Vm template IDs\");\n-        final Set<Hypervisor.HypervisorType> hypervisorsListInUse = new HashSet<Hypervisor.HypervisorType>();\n-        try (PreparedStatement pstmt = conn.prepareStatement(\"select distinct(hypervisor_type) from `cloud`.`cluster` where removed is null\"); ResultSet rs = pstmt.executeQuery()) {\n-            while (rs.next()) {\n-                switch (Hypervisor.HypervisorType.getType(rs.getString(1))) {\n-                    case XenServer:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.XenServer);\n-                        break;\n-                    case KVM:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.KVM);\n-                        break;\n-                    case VMware:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.VMware);\n-                        break;\n-                    case Hyperv:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.Hyperv);\n-                        break;\n-                    case LXC:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.LXC);\n-                        break;\n-                    case Ovm3:\n-                        hypervisorsListInUse.add(Hypervisor.HypervisorType.Ovm3);\n-                        break;\n-                    default:\n-                        break;\n-                }\n-            }\n-        } catch (final SQLException e) {\n-            LOG.error(\"updateSystemVmTemplates: Exception caught while getting hypervisor types from clusters: \" + e.getMessage());\n-            throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while getting hypervisor types from clusters\", e);\n-        }\n-\n-        final Map<Hypervisor.HypervisorType, String> NewTemplateNameList = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"systemvm-kvm-4.16.0\");\n-                put(Hypervisor.HypervisorType.VMware, \"systemvm-vmware-4.16.0\");\n-                put(Hypervisor.HypervisorType.XenServer, \"systemvm-xenserver-4.16.0\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"systemvm-hyperv-4.16.0\");\n-                put(Hypervisor.HypervisorType.LXC, \"systemvm-lxc-4.16.0\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"systemvm-ovm3-4.16.0\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> routerTemplateConfigurationNames = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"router.template.kvm\");\n-                put(Hypervisor.HypervisorType.VMware, \"router.template.vmware\");\n-                put(Hypervisor.HypervisorType.XenServer, \"router.template.xenserver\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"router.template.hyperv\");\n-                put(Hypervisor.HypervisorType.LXC, \"router.template.lxc\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"router.template.ovm3\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> newTemplateUrl = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-kvm.qcow2.bz2\");\n-                put(Hypervisor.HypervisorType.VMware, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-vmware.ova\");\n-                put(Hypervisor.HypervisorType.XenServer, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-xen.vhd.bz2\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-hyperv.vhd.zip\");\n-                put(Hypervisor.HypervisorType.LXC, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-kvm.qcow2.bz2\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"https://download.cloudstack.org/systemvm/4.16/systemvmtemplate-4.16.0-ovm.raw.bz2\");\n-            }\n-        };\n-\n-        final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>() {\n-            {\n-                put(Hypervisor.HypervisorType.KVM, \"81b3e48bb934784a13555a43c5ef5ffb\");\n-                put(Hypervisor.HypervisorType.XenServer, \"1b178a5dbdbe090555515340144c6017\");\n-                put(Hypervisor.HypervisorType.VMware, \"e6a88e518c57d6f36c096c4204c3417f\");\n-                put(Hypervisor.HypervisorType.Hyperv, \"5c94da45337cf3e1910dcbe084d4b9ad\");\n-                put(Hypervisor.HypervisorType.LXC, \"81b3e48bb934784a13555a43c5ef5ffb\");\n-                put(Hypervisor.HypervisorType.Ovm3, \"875c5c65455fc06c4a012394410db375\");\n-            }\n-        };\n-\n-        for (final Map.Entry<Hypervisor.HypervisorType, String> hypervisorAndTemplateName : NewTemplateNameList.entrySet()) {\n-            LOG.debug(\"Updating \" + hypervisorAndTemplateName.getKey() + \" System Vms\");\n-            try (PreparedStatement pstmt = conn.prepareStatement(\"select id from `cloud`.`vm_template` where name = ? and removed is null order by id desc limit 1\")) {\n-                // Get systemvm template id for corresponding hypervisor\n-                long templateId = -1;\n-                pstmt.setString(1, hypervisorAndTemplateName.getValue());\n-                try (ResultSet rs = pstmt.executeQuery()) {\n-                    if (rs.next()) {\n-                        templateId = rs.getLong(1);\n-                    }\n-                } catch (final SQLException e) {\n-                    LOG.error(\"updateSystemVmTemplates: Exception caught while getting ids of templates: \" + e.getMessage());\n-                    throw new CloudRuntimeException(\"updateSystemVmTemplates: Exception caught while getting ids of templates\", e);\n-                }\n-\n-                // change template type to SYSTEM\n-                if (templateId != -1) {\n-                    try (PreparedStatement templ_type_pstmt = conn.prepareStatement(\"update `cloud`.`vm_template` set type='SYSTEM' where id = ?\");) {\n-                        templ_type_pstmt.setLong(1, templateId);\n-                        templ_type_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while updating template with id \" + templateId + \" to be marked as 'system': \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while updating template with id \" + templateId + \" to be marked as 'system'\", e);\n-                    }\n-                    // update template ID of system Vms\n-                    try (PreparedStatement update_templ_id_pstmt = conn\n-                            .prepareStatement(\"update `cloud`.`vm_instance` set vm_template_id = ? where type <> 'User' and hypervisor_type = ? and removed is NULL\");) {\n-                        update_templ_id_pstmt.setLong(1, templateId);\n-                        update_templ_id_pstmt.setString(2, hypervisorAndTemplateName.getKey().toString());\n-                        update_templ_id_pstmt.executeUpdate();\n-                    } catch (final Exception e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting template for \" + hypervisorAndTemplateName.getKey().toString() + \" to \" + templateId\n-                                + \": \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting template for \" + hypervisorAndTemplateName.getKey().toString() + \" to \"\n-                                + templateId, e);\n-                    }\n-\n-                    // Change value of global configuration parameter\n-                    // router.template.* for the corresponding hypervisor\n-                    try (PreparedStatement update_pstmt = conn.prepareStatement(\"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\");) {\n-                        update_pstmt.setString(1, hypervisorAndTemplateName.getValue());\n-                        update_pstmt.setString(2, routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()));\n-                        update_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting \" + routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()) + \" to \"\n-                                + hypervisorAndTemplateName.getValue() + \": \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting \"\n-                                + routerTemplateConfigurationNames.get(hypervisorAndTemplateName.getKey()) + \" to \" + hypervisorAndTemplateName.getValue(), e);\n-                    }\n-\n-                    // Change value of global configuration parameter\n-                    // minreq.sysvmtemplate.version for the ACS version\n-                    try (PreparedStatement update_pstmt = conn.prepareStatement(\"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\");) {\n-                        update_pstmt.setString(1, \"4.16.0\");\n-                        update_pstmt.setString(2, \"minreq.sysvmtemplate.version\");\n-                        update_pstmt.executeUpdate();\n-                    } catch (final SQLException e) {\n-                        LOG.error(\"updateSystemVmTemplates:Exception while setting 'minreq.sysvmtemplate.version' to 4.16.0: \" + e.getMessage());\n-                        throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while setting 'minreq.sysvmtemplate.version' to 4.16.0\", e);\n-                    }\n-                } else {\n-                    if (hypervisorsListInUse.contains(hypervisorAndTemplateName.getKey())) {\n-                        throw new CloudRuntimeException(getUpgradedVersion() + hypervisorAndTemplateName.getKey() + \" SystemVm template not found. Cannot upgrade system Vms\");\n-                    } else {\n-                        LOG.warn(getUpgradedVersion() + hypervisorAndTemplateName.getKey() + \" SystemVm template not found. \" + hypervisorAndTemplateName.getKey()\n-                                + \" hypervisor is not used, so not failing upgrade\");\n-                        // Update the latest template URLs for corresponding\n-                        // hypervisor\n-                        try (PreparedStatement update_templ_url_pstmt = conn\n-                                .prepareStatement(\"UPDATE `cloud`.`vm_template` SET url = ? , checksum = ? WHERE hypervisor_type = ? AND type = 'SYSTEM' AND removed is null order by id desc limit 1\");) {\n-                            update_templ_url_pstmt.setString(1, newTemplateUrl.get(hypervisorAndTemplateName.getKey()));\n-                            update_templ_url_pstmt.setString(2, newTemplateChecksum.get(hypervisorAndTemplateName.getKey()));\n-                            update_templ_url_pstmt.setString(3, hypervisorAndTemplateName.getKey().toString());\n-                            update_templ_url_pstmt.executeUpdate();\n-                        } catch (final SQLException e) {\n-                            LOG.error(\"updateSystemVmTemplates:Exception while updating 'url' and 'checksum' for hypervisor type \"\n-                                    + hypervisorAndTemplateName.getKey().toString() + \": \" + e.getMessage());\n-                            throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while updating 'url' and 'checksum' for hypervisor type \"\n-                                    + hypervisorAndTemplateName.getKey().toString(), e);\n-                        }\n-                    }\n-                }\n-            } catch (final SQLException e) {\n-                LOG.error(\"updateSystemVmTemplates:Exception while getting ids of templates: \" + e.getMessage());\n-                throw new CloudRuntimeException(\"updateSystemVmTemplates:Exception while getting ids of templates\", e);\n-            }\n+        initSystemVmTemplateRegistration();\n+        try {\n+            systemVmTemplateRegistration.updateSystemVmTemplates(conn);\n+        } catch (Exception e) {\n+            throw new CloudRuntimeException(\"Failed to find / register SystemVM template(s)\");", "originalCommit": "28a03b25ab4556211efa3d80854b557952a38d15", "replyToReviewId": null, "replies": [{"id": "PRRC_kwDOAJTq2M4qX2nC", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r710896066", "bodyText": "At this point I haven't changed the structuring. Could probably be done as part of Phase2", "author": "Pearl1594", "createdAt": "2021-09-17T09:19:53Z", "replyToReviewId": "PRRC_kwDOAJTq2M4qX0dN"}], "type": "inlineReview"}, {"id": "PRRC_kwDOAJTq2M4qX0vh", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r710888417", "bodyText": "is this change on purpose?", "author": "DaanHoogland", "createdAt": "2021-09-17T09:09:17Z", "path": "plugins/hypervisors/vmware/src/main/java/com/cloud/hypervisor/vmware/resource/VmwareResource.java", "diffHunk": "@@ -48,6 +48,7 @@\n import javax.naming.ConfigurationException;\n import javax.xml.datatype.XMLGregorianCalendar;\n \n+import com.cloud.utils.script.Script;", "originalCommit": "28a03b25ab4556211efa3d80854b557952a38d15", "replyToReviewId": null, "replies": [{"id": "PRRC_kwDOAJTq2M4qX2-Z", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r710897561", "bodyText": "I had initially done some refactor to the logic of fetching id_rsa file and then reverted it - this is probably a consequence of that action", "author": "Pearl1594", "createdAt": "2021-09-17T09:21:56Z", "replyToReviewId": "PRRC_kwDOAJTq2M4qX0vh"}], "type": "inlineReview"}, {"oid": "9ba1d6a7ca91a5f0ad13da27b14aa55e8d303cf9", "url": "https://github.com/apache/cloudstack/commit/9ba1d6a7ca91a5f0ad13da27b14aa55e8d303cf9", "message": "Fixing missing label", "committedDate": "2021-09-21T11:22:50Z", "type": "commit"}, {"oid": "75abaf9920ade43c9fe3e4f8667db7a46a68d3ef", "url": "https://github.com/apache/cloudstack/commit/75abaf9920ade43c9fe3e4f8667db7a46a68d3ef", "message": "Fix confusing error message", "committedDate": "2021-09-21T11:25:28Z", "type": "commit"}, {"oid": "457c1f39d90d9c6d2f3d9d6f188305cc2cc3feb2", "url": "https://github.com/apache/cloudstack/commit/457c1f39d90d9c6d2f3d9d6f188305cc2cc3feb2", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-09-22T09:22:07Z", "type": "commit"}, {"oid": "6fff01e60f76846ff277833341b724b1d3ebc505", "url": "https://github.com/apache/cloudstack/commit/6fff01e60f76846ff277833341b724b1d3ebc505", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-09-27T09:41:24Z", "type": "commit"}, {"oid": "6deb6f05376aa817671810e4e55920248b46d449", "url": "https://github.com/apache/cloudstack/commit/6deb6f05376aa817671810e4e55920248b46d449", "message": "Add taint on control nodes", "committedDate": "2021-09-28T10:52:37Z", "type": "commit"}, {"oid": "e8b93ddc950748124ff1956536567029b673fae7", "url": "https://github.com/apache/cloudstack/commit/e8b93ddc950748124ff1956536567029b673fae7", "message": "Fix vm name", "committedDate": "2021-09-28T13:14:32Z", "type": "commit"}, {"oid": "c49ba7debfef736bd758287c49cb2afc04d3af7c", "url": "https://github.com/apache/cloudstack/commit/c49ba7debfef736bd758287c49cb2afc04d3af7c", "message": "Fix name again", "committedDate": "2021-09-29T03:47:42Z", "type": "commit"}, {"oid": "06f629967e2dd5cbfcc3fedb9d09ed3cda1f38e3", "url": "https://github.com/apache/cloudstack/commit/06f629967e2dd5cbfcc3fedb9d09ed3cda1f38e3", "message": "Port UI changes", "committedDate": "2021-02-04T12:54:36Z", "type": "forcePushed"}, {"oid": "735b257ee2c3da425524d5541963cac696476f4c", "url": "https://github.com/apache/cloudstack/commit/735b257ee2c3da425524d5541963cac696476f4c", "message": "Fix versions", "committedDate": "2021-02-05T17:14:19Z", "type": "commit"}, {"oid": "acb20e539d191ce01282fb09af56c7b7e3995664", "url": "https://github.com/apache/cloudstack/commit/acb20e539d191ce01282fb09af56c7b7e3995664", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-02-16T06:02:42Z", "type": "commit"}, {"oid": "acb20e539d191ce01282fb09af56c7b7e3995664", "url": "https://github.com/apache/cloudstack/commit/acb20e539d191ce01282fb09af56c7b7e3995664", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-02-16T06:02:42Z", "type": "forcePushed"}, {"oid": "f5e866cb1f2a21e345f0dc1d6b6061960176d4df", "url": "https://github.com/apache/cloudstack/commit/f5e866cb1f2a21e345f0dc1d6b6061960176d4df", "message": "CKS deployment fix for Vmware - resize volume", "committedDate": "2021-03-17T12:03:21Z", "type": "commit"}, {"oid": "c887ac4bd947683071160670140508c5ad36345b", "url": "https://github.com/apache/cloudstack/commit/c887ac4bd947683071160670140508c5ad36345b", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-03-17T12:40:12Z", "type": "commit"}, {"oid": "380c9b0a7f55690c62d52345ab9753370e009c6a", "url": "https://github.com/apache/cloudstack/commit/380c9b0a7f55690c62d52345ab9753370e009c6a", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-03-17T13:03:30Z", "type": "commit"}, {"oid": "324e8923426e38cf830934edc70613cafdec4a60", "url": "https://github.com/apache/cloudstack/commit/324e8923426e38cf830934edc70613cafdec4a60", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-03-23T05:57:24Z", "type": "commit"}, {"oid": "6a48ac8830d79bc7342fdc016542ff020a116383", "url": "https://github.com/apache/cloudstack/commit/6a48ac8830d79bc7342fdc016542ff020a116383", "message": "Update deploy as is field for templates registed < ACS 4.15", "committedDate": "2021-03-23T12:31:32Z", "type": "commit"}, {"oid": "825e4b6b04774bd82ea92400ff6cb38de297e08f", "url": "https://github.com/apache/cloudstack/commit/825e4b6b04774bd82ea92400ff6cb38de297e08f", "message": "Merge branch 'add-cks-autoscaling' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-03-23T16:10:03Z", "type": "commit"}, {"oid": "afd17e28c5814bdfdd65259af62fcc69b341fd03", "url": "https://github.com/apache/cloudstack/commit/afd17e28c5814bdfdd65259af62fcc69b341fd03", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-03-24T06:27:54Z", "type": "commit"}, {"oid": "ce506892be726239fa2fbe3ad89289a2a9864455", "url": "https://github.com/apache/cloudstack/commit/ce506892be726239fa2fbe3ad89289a2a9864455", "message": "Allow vol snap for a disk brought up using sysvm template - only for cks nodes", "committedDate": "2021-03-25T05:07:14Z", "type": "commit"}, {"oid": "a3364115dbc26afe710416ba59e4c5d04685bbaf", "url": "https://github.com/apache/cloudstack/commit/a3364115dbc26afe710416ba59e4c5d04685bbaf", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-03-25T05:44:09Z", "type": "commit"}, {"oid": "39ef51bbde633f03f97fa356b7acbd5d7162b921", "url": "https://github.com/apache/cloudstack/commit/39ef51bbde633f03f97fa356b7acbd5d7162b921", "message": "Update sysvm template + default to legacy iptables on cks nodes", "committedDate": "2021-03-26T15:35:52Z", "type": "commit"}, {"oid": "2bdd3d0dbcb7300e5414e88f2447c6fefc69091b", "url": "https://github.com/apache/cloudstack/commit/2bdd3d0dbcb7300e5414e88f2447c6fefc69091b", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-03-31T09:52:26Z", "type": "commit"}, {"oid": "8b0554c779ec534512d6b99202c3bfd053c7dd26", "url": "https://github.com/apache/cloudstack/commit/8b0554c779ec534512d6b99202c3bfd053c7dd26", "message": "enable full clone for vmware for cks tests", "committedDate": "2021-03-31T09:56:46Z", "type": "commit"}, {"oid": "289b6de6c2f2dd425cbd5802a9b002973ed357c4", "url": "https://github.com/apache/cloudstack/commit/289b6de6c2f2dd425cbd5802a9b002973ed357c4", "message": "Update checksums for new system vm template", "committedDate": "2021-03-31T14:36:24Z", "type": "commit"}, {"oid": "a9f536b88a353254773146bb1950dd8592da1088", "url": "https://github.com/apache/cloudstack/commit/a9f536b88a353254773146bb1950dd8592da1088", "message": "Merge branch 'add-cks-autoscaling' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-04-01T04:45:26Z", "type": "commit"}, {"oid": "88b8c4d599d7d242a17308d05fba6d2d5b57ea39", "url": "https://github.com/apache/cloudstack/commit/88b8c4d599d7d242a17308d05fba6d2d5b57ea39", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-05-26T10:59:52Z", "type": "commit"}, {"oid": "b6786140bbda89f6f338623a2a44a597d34d597f", "url": "https://github.com/apache/cloudstack/commit/b6786140bbda89f6f338623a2a44a597d34d597f", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-05-26T11:00:17Z", "type": "commit"}, {"oid": "94e9c5580ad33494afaca83021d96dc5aeb29ada", "url": "https://github.com/apache/cloudstack/commit/94e9c5580ad33494afaca83021d96dc5aeb29ada", "message": "Merge branch 'add-cks-autoscaling' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-05-27T06:03:18Z", "type": "commit"}, {"oid": "ef273cbd9d8b3c45713f03112413b0099ceaf7da", "url": "https://github.com/apache/cloudstack/commit/ef273cbd9d8b3c45713f03112413b0099ceaf7da", "message": "Merge branch 'master' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-06-09T11:19:06Z", "type": "commit"}, {"oid": "d49bab74b2f653c94182e6ae894fda2d692d2d84", "url": "https://github.com/apache/cloudstack/commit/d49bab74b2f653c94182e6ae894fda2d692d2d84", "message": "fix test and dependencies", "committedDate": "2021-06-10T04:52:30Z", "type": "commit"}, {"oid": "0422e0e7cba5fa64a9d74faf0e5d21a3e606e7f5", "url": "https://github.com/apache/cloudstack/commit/0422e0e7cba5fa64a9d74faf0e5d21a3e606e7f5", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-07-08T04:34:43Z", "type": "commit"}, {"oid": "4d11ea75b8c172c80729a998055887c2140170ac", "url": "https://github.com/apache/cloudstack/commit/4d11ea75b8c172c80729a998055887c2140170ac", "message": "test changes to include inclusivity changes", "committedDate": "2021-07-08T14:52:24Z", "type": "commit"}, {"oid": "26c05cb1f3b61e9bf429fa43e77510c4dde0090c", "url": "https://github.com/apache/cloudstack/commit/26c05cb1f3b61e9bf429fa43e77510c4dde0090c", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-07-19T12:52:09Z", "type": "commit"}, {"oid": "062fa0c4764645eae790383ed6aa593801103653", "url": "https://github.com/apache/cloudstack/commit/062fa0c4764645eae790383ed6aa593801103653", "message": "SystemVM upgrade improvements", "committedDate": "2021-07-20T11:30:25Z", "type": "commit"}, {"oid": "fc7d93e273ee86e4d30096e7b1813d73ff091968", "url": "https://github.com/apache/cloudstack/commit/fc7d93e273ee86e4d30096e7b1813d73ff091968", "message": "install pkg - requests", "committedDate": "2021-07-21T06:02:22Z", "type": "commit"}, {"oid": "33eec1e02490771ed7194ed0e5d5ad716578c093", "url": "https://github.com/apache/cloudstack/commit/33eec1e02490771ed7194ed0e5d5ad716578c093", "message": "Add logic for template registration if not preset", "committedDate": "2021-07-21T13:01:17Z", "type": "commit"}, {"oid": "be80bafee50e37ab3c1b76138f9daccc74da5558", "url": "https://github.com/apache/cloudstack/commit/be80bafee50e37ab3c1b76138f9daccc74da5558", "message": "handle automatic upgrade if templates present in package(cloudstack-management)", "committedDate": "2021-07-27T06:28:23Z", "type": "commit"}, {"oid": "c622904c7ecc8655ef25e934d20c4aefc5ad794c", "url": "https://github.com/apache/cloudstack/commit/c622904c7ecc8655ef25e934d20c4aefc5ad794c", "message": "packaging fixes", "committedDate": "2021-07-28T06:46:37Z", "type": "commit"}, {"oid": "fd14a87d2ff79c15fc5f049ad0b051bc178debf9", "url": "https://github.com/apache/cloudstack/commit/fd14a87d2ff79c15fc5f049ad0b051bc178debf9", "message": "1. Move download of templates and creation of meta file logic to mvn (systemvm/pom)\n2. Remove hard-coded references in the upgrade path - use meta file as input\n3. changed path of templates from packaging to systemvm/dist/systemvm-templates", "committedDate": "2021-07-29T09:56:01Z", "type": "commit"}, {"oid": "9787f140241f6519d2f2e2623bcad39a16bd96cc", "url": "https://github.com/apache/cloudstack/commit/9787f140241f6519d2f2e2623bcad39a16bd96cc", "message": "fix rpm build", "committedDate": "2021-07-30T09:43:53Z", "type": "commit"}, {"oid": "05aa40ca2e17bb699084fb5c04e6130272cd6f91", "url": "https://github.com/apache/cloudstack/commit/05aa40ca2e17bb699084fb5c04e6130272cd6f91", "message": "fix deb rules", "committedDate": "2021-07-30T09:53:33Z", "type": "commit"}, {"oid": "6ba24bf502d488001b1c603f4e34b32cacc900ed", "url": "https://github.com/apache/cloudstack/commit/6ba24bf502d488001b1c603f4e34b32cacc900ed", "message": "fix deb rules", "committedDate": "2021-07-30T10:27:57Z", "type": "commit"}, {"oid": "8677d4658306508f0948b0aa656e7bbde8935d2f", "url": "https://github.com/apache/cloudstack/commit/8677d4658306508f0948b0aa656e7bbde8935d2f", "message": "fix deb rules", "committedDate": "2021-07-30T10:28:28Z", "type": "commit"}, {"oid": "8718b9c607edfcc4998508502c80e4bdf40a6a4a", "url": "https://github.com/apache/cloudstack/commit/8718b9c607edfcc4998508502c80e4bdf40a6a4a", "message": "test", "committedDate": "2021-07-30T11:37:25Z", "type": "commit"}, {"oid": "5b849e81a332c9ecfa21126f064310f17cced2fb", "url": "https://github.com/apache/cloudstack/commit/5b849e81a332c9ecfa21126f064310f17cced2fb", "message": "Merge branch 'test-packaging' of github.com:shapeblue/cloudstack into sysvm-upgrade-improvements", "committedDate": "2021-07-30T13:05:43Z", "type": "commit"}, {"oid": "a6b23715fefe0acfeec42e81de1ceec1194031c4", "url": "https://github.com/apache/cloudstack/commit/a6b23715fefe0acfeec42e81de1ceec1194031c4", "message": "cleanup", "committedDate": "2021-07-30T13:07:38Z", "type": "commit"}, {"oid": "ffb3d9fdecd46d1afd031d76121006c77993a654", "url": "https://github.com/apache/cloudstack/commit/ffb3d9fdecd46d1afd031d76121006c77993a654", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into sysvm-upgrade-improvements", "committedDate": "2021-07-30T17:09:25Z", "type": "commit"}, {"oid": "390c14b8fafd9f05c6626c211ff64c4434943de8", "url": "https://github.com/apache/cloudstack/commit/390c14b8fafd9f05c6626c211ff64c4434943de8", "message": "update injectkeys.sh script to only copy private key to hosts and update pom xml to adapt for noredis\nnoredist vs other builds", "committedDate": "2021-08-02T07:29:34Z", "type": "commit"}, {"oid": "6038c60911cc181b1264d7beec94459fb6daca21", "url": "https://github.com/apache/cloudstack/commit/6038c60911cc181b1264d7beec94459fb6daca21", "message": "Fix travis failure", "committedDate": "2021-08-02T11:38:49Z", "type": "commit"}, {"oid": "82620a7d271187f927b68d4991da7ddd28c2e5ca", "url": "https://github.com/apache/cloudstack/commit/82620a7d271187f927b68d4991da7ddd28c2e5ca", "message": "Update registration workflow during upgrade", "committedDate": "2021-08-02T13:03:59Z", "type": "commit"}, {"oid": "027d8f9f03b87a1bc97119c417c867eb96b9ae35", "url": "https://github.com/apache/cloudstack/commit/027d8f9f03b87a1bc97119c417c867eb96b9ae35", "message": "change master reference in k8s context to control Node", "committedDate": "2021-08-02T13:08:18Z", "type": "commit"}, {"oid": "7d61f88e0357337a37bad48e3b9bd1f20c8eecd2", "url": "https://github.com/apache/cloudstack/commit/7d61f88e0357337a37bad48e3b9bd1f20c8eecd2", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-02T13:11:23Z", "type": "commit"}, {"oid": "96d148279ca82c02844e6109295d286cf0a8180f", "url": "https://github.com/apache/cloudstack/commit/96d148279ca82c02844e6109295d286cf0a8180f", "message": "upgrade setuptools - required by k8s", "committedDate": "2021-08-02T14:57:39Z", "type": "commit"}, {"oid": "e49ad71f3f1a38fe19553388aa35e95ac61c3061", "url": "https://github.com/apache/cloudstack/commit/e49ad71f3f1a38fe19553388aa35e95ac61c3061", "message": "Change location of template files and script to work with simulator build", "committedDate": "2021-08-03T10:04:48Z", "type": "commit"}, {"oid": "820192f39ebf41d722d7bac92118ad39b5d586d9", "url": "https://github.com/apache/cloudstack/commit/820192f39ebf41d722d7bac92118ad39b5d586d9", "message": "Port python script to bash - to avoid package installations", "committedDate": "2021-08-04T05:37:32Z", "type": "commit"}, {"oid": "274330dc1399081e4827ef4800063480875bb5c6", "url": "https://github.com/apache/cloudstack/commit/274330dc1399081e4827ef4800063480875bb5c6", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into sysvm-upgrade-improvements", "committedDate": "2021-08-05T05:43:39Z", "type": "commit"}, {"oid": "51b38dee282932433bcd285c000901a9fa5a9384", "url": "https://github.com/apache/cloudstack/commit/51b38dee282932433bcd285c000901a9fa5a9384", "message": "Merge branch 'sysvm-upgrade-improvements' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-05T13:17:34Z", "type": "commit"}, {"oid": "324bc73983bdf6b57240ce840a9eef0afb070a21", "url": "https://github.com/apache/cloudstack/commit/324bc73983bdf6b57240ce840a9eef0afb070a21", "message": "add logic to get code version", "committedDate": "2021-08-05T14:14:01Z", "type": "commit"}, {"oid": "433db66a7722d5785f7b76a9a968b2348c0ea5f9", "url": "https://github.com/apache/cloudstack/commit/433db66a7722d5785f7b76a9a968b2348c0ea5f9", "message": "update naming convention + identify store to be used on a per zone basis", "committedDate": "2021-08-06T07:07:14Z", "type": "commit"}, {"oid": "6b391d1803a04e1970b66001fdbdeb3638701450", "url": "https://github.com/apache/cloudstack/commit/6b391d1803a04e1970b66001fdbdeb3638701450", "message": "Merge branch 'sysvm-upgrade-improvements' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-06T07:09:34Z", "type": "commit"}, {"oid": "33b4293a6e8571d30a83c73b8dccba4a64f055cf", "url": "https://github.com/apache/cloudstack/commit/33b4293a6e8571d30a83c73b8dccba4a64f055cf", "message": "add timeout constant", "committedDate": "2021-08-06T07:57:34Z", "type": "commit"}, {"oid": "316a43af55a43e0380a6924812d6480463d5e4be", "url": "https://github.com/apache/cloudstack/commit/316a43af55a43e0380a6924812d6480463d5e4be", "message": "modify script permission", "committedDate": "2021-08-06T09:57:30Z", "type": "commit"}, {"oid": "0378e1d752ff7ee794e6d30629d32a28a7e6e1e1", "url": "https://github.com/apache/cloudstack/commit/0378e1d752ff7ee794e6d30629d32a28a7e6e1e1", "message": "cleanup + prevent hardcoded ssh location - as ubuntu places it at /var/lib/cloudstack/mgmt/.ssh vs /var/cloud.", "committedDate": "2021-08-06T12:09:24Z", "type": "commit"}, {"oid": "f1b9baf81a0227ca474449558a16f13b6af7b8c6", "url": "https://github.com/apache/cloudstack/commit/f1b9baf81a0227ca474449558a16f13b6af7b8c6", "message": "fix failing test - delete k8s cluster", "committedDate": "2021-08-06T17:18:18Z", "type": "commit"}, {"oid": "6872512fb443d4b252753454b06bce2d3c2ce1ad", "url": "https://github.com/apache/cloudstack/commit/6872512fb443d4b252753454b06bce2d3c2ce1ad", "message": "fix test", "committedDate": "2021-08-09T05:43:50Z", "type": "commit"}, {"oid": "f82b33cad91de42f5d38bb6977127a4193853fa9", "url": "https://github.com/apache/cloudstack/commit/f82b33cad91de42f5d38bb6977127a4193853fa9", "message": "Merge branch 'main' of github.com:apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-09T09:59:39Z", "type": "commit"}, {"oid": "28263b328fc25d9d0df16a25f1af881e2392c6d0", "url": "https://github.com/apache/cloudstack/commit/28263b328fc25d9d0df16a25f1af881e2392c6d0", "message": "Fix checkstyle", "committedDate": "2021-08-09T10:45:24Z", "type": "forcePushed"}, {"oid": "226879fe4ffa8ca5f5d09f9fcf59dc400a83849a", "url": "https://github.com/apache/cloudstack/commit/226879fe4ffa8ca5f5d09f9fcf59dc400a83849a", "message": "Fix checkstyle", "committedDate": "2021-08-09T11:25:26Z", "type": "commit"}, {"oid": "226879fe4ffa8ca5f5d09f9fcf59dc400a83849a", "url": "https://github.com/apache/cloudstack/commit/226879fe4ffa8ca5f5d09f9fcf59dc400a83849a", "message": "Fix checkstyle", "committedDate": "2021-08-09T11:25:26Z", "type": "forcePushed"}, {"oid": "26c2fa7bd305bd5f2dbf5b42c5cd7855d6b31054", "url": "https://github.com/apache/cloudstack/commit/26c2fa7bd305bd5f2dbf5b42c5cd7855d6b31054", "message": "register sysvm template on addition of 1st store in a zone", "committedDate": "2021-08-10T04:09:15Z", "type": "commit"}, {"oid": "b9825010a9f1ab0dee9827442250809e2a79200d", "url": "https://github.com/apache/cloudstack/commit/b9825010a9f1ab0dee9827442250809e2a79200d", "message": "validate if template is registered/seeded in a fresh env and bypass registration on storage addition", "committedDate": "2021-08-10T04:09:43Z", "type": "commit"}, {"oid": "fde018508ec380791b0893971bdd274ee5742a88", "url": "https://github.com/apache/cloudstack/commit/fde018508ec380791b0893971bdd274ee5742a88", "message": "remove unnecessary commit", "committedDate": "2021-08-10T04:10:02Z", "type": "commit"}, {"oid": "c249c92e8b06c8629ec7d091d309d96629e9d3bb", "url": "https://github.com/apache/cloudstack/commit/c249c92e8b06c8629ec7d091d309d96629e9d3bb", "message": "Fix setup-kube-system", "committedDate": "2021-08-10T07:08:23Z", "type": "commit"}, {"oid": "48b8552a864eac69f9d8b1160bc3db06a3e82d8e", "url": "https://github.com/apache/cloudstack/commit/48b8552a864eac69f9d8b1160bc3db06a3e82d8e", "message": "Add kubectl path in deployprovider", "committedDate": "2021-08-10T08:29:53Z", "type": "commit"}, {"oid": "6d37af84e8e0f03303504f92492a2bc3d433a9fc", "url": "https://github.com/apache/cloudstack/commit/6d37af84e8e0f03303504f92492a2bc3d433a9fc", "message": "upgraded sysvm template + temporary changes wrt sysvm url path", "committedDate": "2021-08-10T09:19:49Z", "type": "commit"}, {"oid": "786eec3b68d162eb8baf75ce7dc159bf541a8064", "url": "https://github.com/apache/cloudstack/commit/786eec3b68d162eb8baf75ce7dc159bf541a8064", "message": "Merge branch 'add-cks-autoscaling' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-10T09:20:31Z", "type": "commit"}, {"oid": "8fea654d33ed3c69f468fb602a493d1d9d2ef97d", "url": "https://github.com/apache/cloudstack/commit/8fea654d33ed3c69f468fb602a493d1d9d2ef97d", "message": "Remove redundant validtion", "committedDate": "2021-08-11T06:31:17Z", "type": "commit"}, {"oid": "7812024962d92f6f64f340b8daeef1229c99bddb", "url": "https://github.com/apache/cloudstack/commit/7812024962d92f6f64f340b8daeef1229c99bddb", "message": "add dependency req for k8s versions > 1.18 + move conf / service file to nonoss repo", "committedDate": "2021-08-11T12:13:52Z", "type": "commit"}, {"oid": "39868c10e8acba655d3ec8c4009eaf77f6ae99fb", "url": "https://github.com/apache/cloudstack/commit/39868c10e8acba655d3ec8c4009eaf77f6ae99fb", "message": "Merge branch 'add-cks-autoscaling' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-11T12:14:31Z", "type": "commit"}, {"oid": "f3ac89bbcc193b9920cedb5c7edc486190529d7e", "url": "https://github.com/apache/cloudstack/commit/f3ac89bbcc193b9920cedb5c7edc486190529d7e", "message": "update branch", "committedDate": "2021-08-11T12:54:06Z", "type": "commit"}, {"oid": "37139d046237e4b1daf3ce1fcfe3c52744e60e80", "url": "https://github.com/apache/cloudstack/commit/37139d046237e4b1daf3ce1fcfe3c52744e60e80", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-13T06:13:59Z", "type": "commit"}, {"oid": "c5be93abb2e5a8bc1b42db24451065d05e360cc3", "url": "https://github.com/apache/cloudstack/commit/c5be93abb2e5a8bc1b42db24451065d05e360cc3", "message": "ssh key missing - iLB and elasticLB", "committedDate": "2021-08-13T06:34:17Z", "type": "commit"}, {"oid": "62831c936851bb69766533b5e11b9ced798d86ae", "url": "https://github.com/apache/cloudstack/commit/62831c936851bb69766533b5e11b9ced798d86ae", "message": "systemvmtemplate: bump to Debian 11.0.0 systemvmtemplate\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>", "committedDate": "2021-08-16T08:24:30Z", "type": "commit"}, {"oid": "78f6423b7ff9362c63ca49821057490b47f4d3fe", "url": "https://github.com/apache/cloudstack/commit/78f6423b7ff9362c63ca49821057490b47f4d3fe", "message": "fixes\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>", "committedDate": "2021-08-16T08:46:32Z", "type": "commit"}, {"oid": "b187e51aa6ad352aab510857c5a115d3f9e729a3", "url": "https://github.com/apache/cloudstack/commit/b187e51aa6ad352aab510857c5a115d3f9e729a3", "message": "fix missing py3 packages (netaddr) and migrate one file to py3/flask\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>", "committedDate": "2021-08-16T09:22:12Z", "type": "commit"}, {"oid": "bc6ef8dd9e3777eccad76200ac75ce9d3960a98c", "url": "https://github.com/apache/cloudstack/commit/bc6ef8dd9e3777eccad76200ac75ce9d3960a98c", "message": "fix strongswan starter systemd\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>", "committedDate": "2021-08-16T10:18:04Z", "type": "commit"}, {"oid": "500ccbcb5f9a9f0c305de901ea5cbca30bb41c5f", "url": "https://github.com/apache/cloudstack/commit/500ccbcb5f9a9f0c305de901ea5cbca30bb41c5f", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-17T04:26:36Z", "type": "commit"}, {"oid": "940916adf4d23e2dcceb16013459a569e042925f", "url": "https://github.com/apache/cloudstack/commit/940916adf4d23e2dcceb16013459a569e042925f", "message": "Merge branch 'debian11-systemvmtemplate' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-17T04:27:32Z", "type": "commit"}, {"oid": "6f2b0b3910cb9d93922f95058a4634d435afeb7c", "url": "https://github.com/apache/cloudstack/commit/6f2b0b3910cb9d93922f95058a4634d435afeb7c", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-17T18:11:35Z", "type": "commit"}, {"oid": "8796ce65d4fb5c1891da86e5bfbba34a169b45fa", "url": "https://github.com/apache/cloudstack/commit/8796ce65d4fb5c1891da86e5bfbba34a169b45fa", "message": "Merge branch 'debian11-systemvmtemplate' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-17T18:13:10Z", "type": "commit"}, {"oid": "06381a36d4edadd61a5c8c5fdb5e6ae972f4f572", "url": "https://github.com/apache/cloudstack/commit/06381a36d4edadd61a5c8c5fdb5e6ae972f4f572", "message": "address comments - part1", "committedDate": "2021-08-17T18:17:44Z", "type": "commit"}, {"oid": "c91c39652d301c9bfc9dfd227531e3b262d87218", "url": "https://github.com/apache/cloudstack/commit/c91c39652d301c9bfc9dfd227531e3b262d87218", "message": "test updates + install latest packages", "committedDate": "2021-08-18T06:20:12Z", "type": "commit"}, {"oid": "c3210fe7fb00dd339888c457f3e4adf14f5a4146", "url": "https://github.com/apache/cloudstack/commit/c3210fe7fb00dd339888c457f3e4adf14f5a4146", "message": "intensify checks and queries + update authorised_keys decode logic", "committedDate": "2021-08-18T10:01:08Z", "type": "commit"}, {"oid": "f69e9542b8c847c1e5fedd5d463e9472cd4e4342", "url": "https://github.com/apache/cloudstack/commit/f69e9542b8c847c1e5fedd5d463e9472cd4e4342", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-18T11:43:11Z", "type": "commit"}, {"oid": "1bff8ea1f4addd93e2f657b40a75fcf55625fc0f", "url": "https://github.com/apache/cloudstack/commit/1bff8ea1f4addd93e2f657b40a75fcf55625fc0f", "message": "fix issues with merge conflict\n\nSigned-off-by: Rohit Yadav <rohit.yadav@shapeblue.com>", "committedDate": "2021-08-18T11:59:12Z", "type": "commit"}, {"oid": "bcef568af68b4ade02a9cf562bb01d08977c47b1", "url": "https://github.com/apache/cloudstack/commit/bcef568af68b4ade02a9cf562bb01d08977c47b1", "message": "code refactor", "committedDate": "2021-08-18T12:49:34Z", "type": "commit"}, {"oid": "6efee51074b197324c3aa0a3c36959291e32e588", "url": "https://github.com/apache/cloudstack/commit/6efee51074b197324c3aa0a3c36959291e32e588", "message": "use the correct urls for downloading / referencing systemvm templates", "committedDate": "2021-08-18T13:39:49Z", "type": "commit"}, {"oid": "1a93a6dbc9f0828bcacf669b6119ae36ddd776a4", "url": "https://github.com/apache/cloudstack/commit/1a93a6dbc9f0828bcacf669b6119ae36ddd776a4", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-19T10:27:59Z", "type": "commit"}, {"oid": "b663500a98838651e2b3d907537e276f26ebea54", "url": "https://github.com/apache/cloudstack/commit/b663500a98838651e2b3d907537e276f26ebea54", "message": "update suse packaging to include sysvm templates", "committedDate": "2021-08-19T10:32:02Z", "type": "commit"}, {"oid": "d111510500e63e651eb5b6a4040676c6b8764a94", "url": "https://github.com/apache/cloudstack/commit/d111510500e63e651eb5b6a4040676c6b8764a94", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-20T11:17:17Z", "type": "commit"}, {"oid": "510e8684aae827f72deba44d430ceb34dd521d83", "url": "https://github.com/apache/cloudstack/commit/510e8684aae827f72deba44d430ceb34dd521d83", "message": "Merge branch 'add-cks-autoscaling' of github.com:shapeblue/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-20T11:18:05Z", "type": "commit"}, {"oid": "b5e03eb788d72947f699f2a6bd13cc83b4f08f22", "url": "https://github.com/apache/cloudstack/commit/b5e03eb788d72947f699f2a6bd13cc83b4f08f22", "message": "Fix query + cleanup", "committedDate": "2021-08-23T04:17:00Z", "type": "commit"}, {"oid": "ac54a79faf191878fd30133c90609a699fc84874", "url": "https://github.com/apache/cloudstack/commit/ac54a79faf191878fd30133c90609a699fc84874", "message": "Merge branch 'main' of https://github.com/apache/cloudstack into add-cks-autoscaling", "committedDate": "2021-08-23T04:25:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg1MzM5Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693853392", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"root size (in GB) of systemvm and virtual routers\", true);\n          \n          \n            \n                        \"Size of root volume (in GB) of system VMs and virtual routers\", true);", "author": "shwstppr", "createdAt": "2021-08-23T10:30:31Z", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -405,6 +405,10 @@\n     static final ConfigKey<Boolean> HaVmRestartHostUp = new ConfigKey<Boolean>(\"Advanced\", Boolean.class, \"ha.vm.restart.hostup\", \"true\",\n             \"If an out-of-band stop of a VM is detected and its host is up, then power on the VM\", true);\n \n+    static final ConfigKey<Long> SystemVmRootDiskSize = new ConfigKey<Long>(\"Advanced\",\n+            Long.class, \"systemvm.root.disk.size\", \"-1\",\n+            \"root size (in GB) of systemvm and virtual routers\", true);", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg1NTk4Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693855982", "bodyText": "I think SystemVmRootDiskSize.value() will always give a non-null", "author": "shwstppr", "createdAt": "2021-08-23T10:34:48Z", "path": "engine/orchestration/src/main/java/com/cloud/vm/VirtualMachineManagerImpl.java", "diffHunk": "@@ -453,6 +457,12 @@ public void allocate(final String vmInstanceName, final VirtualMachineTemplate t\n \n         final VirtualMachineProfileImpl vmProfile = new VirtualMachineProfileImpl(vmFinal, template, serviceOffering, null, null);\n \n+        Long rootDiskSize = rootDiskOfferingInfo.getSize();\n+        if (vm.getType().isUsedBySystem() && SystemVmRootDiskSize.value() != null && SystemVmRootDiskSize.value() > 0L) {", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDU5MDk5OA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694590998", "bodyText": "question - is isUsedBySystem() returning true for systemvms and VRs?", "author": "rhtyd", "createdAt": "2021-08-24T07:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg1NTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg1NzIwNw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693857207", "bodyText": "Why different naming scheme for different variables with same access?", "author": "shwstppr", "createdAt": "2021-08-23T10:36:48Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";\n+    private static final String relativeTemplatePath = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String AbsolutetemplatesPath = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String templatesPath = fetchTemplatesPath();\n+    private static final String metadataFileName = \"metadata.ini\";\n+    private static final String metadataFile = templatesPath + metadataFileName;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2MDQ0Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693860442", "bodyText": "Using getDataCenterId won't work?", "author": "shwstppr", "createdAt": "2021-08-23T10:42:02Z", "path": "engine/schema/src/main/java/org/apache/cloudstack/storage/datastore/db/ImageStoreVO.java", "diffHunk": "@@ -135,6 +135,10 @@ public Long getDataCenterId() {\n         return this.dcId;\n     }\n \n+    public Long getDcId() {\n+        return this.dcId;\n+    }\n+", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzk4NjA5Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693986097", "bodyText": "This was done because of this https://github.com/shapeblue/hackerbook/blob/main/hack/db.md#note-", "author": "Pearl1594", "createdAt": "2021-08-23T13:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2MDQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2MzgzNA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693863834", "bodyText": "Not good for people with OCD :-D\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final  String hashAlgorithm = \"MD5\";\n          \n          \n            \n                private static final String hashAlgorithm = \"MD5\";", "author": "shwstppr", "createdAt": "2021-08-23T10:47:19Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NTgyOTAyOQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r695829029", "bodyText": "let's apply this", "author": "DaanHoogland", "createdAt": "2021-08-25T14:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2MzgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2NTIwMw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693865203", "bodyText": "We will update this default value for every version in future?", "author": "shwstppr", "createdAt": "2021-08-23T10:49:29Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/SystemVmTemplateRegistration.java", "diffHunk": "@@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package com.cloud.upgrade;\n+\n+import com.cloud.hypervisor.Hypervisor;\n+import com.cloud.storage.Storage.ImageFormat;\n+import com.cloud.utils.DateUtil;\n+import com.cloud.utils.Pair;\n+import com.cloud.utils.UriUtils;\n+import com.cloud.utils.db.GlobalLock;\n+import com.cloud.utils.exception.CloudRuntimeException;\n+import com.cloud.utils.script.Script;\n+import org.apache.log4j.Logger;\n+import org.ini4j.Ini;\n+\n+import javax.naming.ConfigurationException;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.MessageDigest;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class SystemVmTemplateRegistration {\n+    private static final Logger LOGGER = Logger.getLogger(SystemVmTemplateRegistration.class);\n+    private static final String mountCommand = \"sudo mount -t nfs %s %s\";\n+    private static final String umountCommand = \"sudo umount %s\";\n+    private static final  String hashAlgorithm = \"MD5\";\n+    private static final String relativeTemplatePath = \"./engine/schema/dist/systemvm-templates/\";\n+    private static final String AbsolutetemplatesPath = \"/usr/share/cloudstack-management/templates/\";\n+    private static final String templatesPath = fetchTemplatesPath();\n+    private static final String metadataFileName = \"metadata.ini\";\n+    private static final String metadataFile = templatesPath + metadataFileName;\n+    private static final String TEMPORARY_SECONDARY_STORE = \"/tmp/tmpSecStorage\";\n+    private static final String PARENT_TEMPLATE_FOLDER = TEMPORARY_SECONDARY_STORE;\n+    private static final String PARTIAL_TEMPLATE_FOLDER = \"/template/tmpl/1/\";\n+    private static final String FETCH_DISTINCT_ELIGIBLE_ZONES = \"SELECT DISTINCT(data_center_id) FROM `cloud`.`image_store` WHERE protocol = \\\"nfs\\\"  AND role = \\\"Image\\\" AND removed is null\";\n+    private static final String FETCH_DISTINCT_HYPERVISORS_IN_ZONE = \"SELECT DISTINCT(hypervisor_type) FROM `cloud`.`cluster` where  removed is null AND data_center_id=?\";\n+    private static final String FETCH_IMAGE_STORE_PER_ZONE = \"SELECT url,id FROM `cloud`.`image_store` WHERE data_center_id=? AND role = \\\"Image\\\" AND image_provider_name = \\\"NFS\\\" AND removed IS NULL LIMIT 1\";\n+    private static final String INSERT_VM_TEMPLATE_TABLE = \"INSERT INTO `cloud`.`vm_template` (uuid, unique_name, name, public, featured, created, type, hvm, bits, account_id, url, checksum, enable_password, display_text, format, guest_os_id, cross_zones, hypervisor_type, state, deploy_as_is)\" +\n+        \"VALUES (?, ?, ?, 0, 0, ?, 'SYSTEM', 0, 64, 1, ?, ?, 0, ?, ?, ?, 1, ?, 'Inactive', ?)\";\n+    private static final String INSERT_TEMPLATE_STORE_REF_TABLE = \"INSERT INTO `cloud`.`template_store_ref` (store_id,  template_id, created, last_updated, job_id, download_pct, download_state, error_str, local_path, install_path, url, state, destroyed, is_copy,\" +\n+            \" update_count, ref_cnt, store_role) VALUES (?, ?, ?, ?, NULL, 0, 'NOT_DOWNLOADED', NULL, NULL, ?, ?, 'Allocated', 0, 0, 0, 0, 'Image')\";\n+    private static final String UPDATE_TEMPLATE_STORE_REF_TABLE = \"UPDATE `cloud`.`template_store_ref` SET download_pct=100, download_state='DOWNLOADED', \" +\n+            \"state='Ready', size=?, physical_size=?, last_updated=?, updated=? where template_id=?\";\n+    private static final String UPDATE_VM_TEMPLATE_ENTRY = \"UPDATE `cloud`.`vm_template` set size = ?, state = 'Active' where id = ?\";\n+    private static final String UPDATE_CONFIGURATION_TABLE = \"UPDATE `cloud`.`configuration` SET value = ? WHERE name = ?\";\n+    private static final String UPDATE_TEMPLATE_TABLE_ON_FAILURE = \"UPDATE `cloud`.`vm_template` set removed = ?, state = 'Inactive' where id = ?\";\n+    private static final String DELETE_TEMPLATE_REF_RECORD_ON_FAILURE = \"DELETE from `cloud`.`template_store_ref` where template_id = ?\";\n+    private static final Integer SCRIPT_TIMEOUT = 1800000;\n+    private static final Integer LOCK_WAIT_TIMEOUT = 1200;\n+    public static String CS_MAJOR_VERSION = \"4.16\";", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkxMDkzNw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693910937", "bodyText": "it's only a placeholder - this will automatically be updated during MS restart - if the code version has changed", "author": "Pearl1594", "createdAt": "2021-08-23T12:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2NTIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNTQ0NQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694605445", "bodyText": "suggestion - in that case set them as null or something invalid? If the field does not update, but is used elsewhere it will throw NPE and possible fail than do something wrong", "author": "rhtyd", "createdAt": "2021-08-24T08:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg2NTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg3Mjc0OQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693872749", "bodyText": "probably not needed", "author": "shwstppr", "createdAt": "2021-08-23T11:02:26Z", "path": "plugins/hypervisors/kvm/src/main/java/com/cloud/hypervisor/kvm/resource/LibvirtComputingResource.java", "diffHunk": "@@ -1667,6 +1667,7 @@ public boolean passCmdLine(final String vmName, final String cmdLine) throws Int\n         command.add(\"-n\", vmName);\n         command.add(\"-c\", cmdLine);\n         result = command.execute();\n+", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg3NzQ3MA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693877470", "bodyText": "needed?", "author": "shwstppr", "createdAt": "2021-08-23T11:10:39Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "diffHunk": "@@ -310,6 +333,7 @@ protected String getControlVmPrivateIp() {\n     }\n \n     protected void attachIsoKubernetesVMs(List<UserVm> clusterVMs, final KubernetesSupportedVersion kubernetesSupportedVersion) throws CloudRuntimeException {\n+        //final long startTimeoutTime = System.currentTimeMillis() + KubernetesClusterService.KubernetesClusterStartTimeout.value() * 1000;", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg4Mjg1MA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693882850", "bodyText": "Is it possible to call it only when needed? Not sure but as I can understand this might be called everytime there is an issue the k8s cluster such as upgrade/start (from stopped state) as well. Revoking permission log can be confusing in those cases. Though not a major issue", "author": "shwstppr", "createdAt": "2021-08-23T11:19:37Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "diffHunk": "@@ -203,11 +218,19 @@ protected void logTransitStateDetachIsoAndThrow(final Level logLevel, final Stri\n         throw new CloudRuntimeException(message, e);\n     }\n \n+    protected void deleteTemplateLaunchPermission() {\n+        if (clusterTemplate != null && owner != null) {\n+            LOGGER.info(\"Revoking launch permission for systemVM template\");\n+            launchPermissionDao.removePermissions(clusterTemplate.getId(), Collections.singletonList(owner.getId()));\n+        }\n+    }\n+\n     protected void logTransitStateAndThrow(final Level logLevel, final String message, final Long kubernetesClusterId, final KubernetesCluster.Event event, final Exception e) throws CloudRuntimeException {\n         logMessage(logLevel, message, e);\n         if (kubernetesClusterId != null && event != null) {\n             stateTransitTo(kubernetesClusterId, event);\n         }\n+        deleteTemplateLaunchPermission();", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg5MTQ5Nw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693891497", "bodyText": "Use list 'contains?", "author": "shwstppr", "createdAt": "2021-08-23T11:34:03Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -864,30 +807,92 @@ private void validateKubernetesClusterScaleParameters(ScaleKubernetesClusterCmd\n         final Long kubernetesClusterId = cmd.getId();\n         final Long serviceOfferingId = cmd.getServiceOfferingId();\n         final Long clusterSize = cmd.getClusterSize();\n+        final List<Long> nodeIds = cmd.getNodeIds();\n+        final Boolean isAutoscalingEnabled = cmd.isAutoscalingEnabled();\n+        final Long minSize = cmd.getMinSize();\n+        final Long maxSize = cmd.getMaxSize();\n+\n         if (kubernetesClusterId == null || kubernetesClusterId < 1L) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         KubernetesClusterVO kubernetesCluster = kubernetesClusterDao.findById(kubernetesClusterId);\n         if (kubernetesCluster == null || kubernetesCluster.getRemoved() != null) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         final DataCenter zone = dataCenterDao.findById(kubernetesCluster.getZoneId());\n         if (zone == null) {\n             logAndThrow(Level.WARN, String.format(\"Unable to find zone for Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (serviceOfferingId == null && clusterSize == null && nodeIds == null && isAutoscalingEnabled == null) {\n+            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster %s cannot be scaled, either service offering or cluster size or nodeids to be removed or autoscaling must be passed\", kubernetesCluster.getName()));\n+        }\n+\n         Account caller = CallContext.current().getCallingAccount();\n         accountManager.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, false, kubernetesCluster);\n \n-        if (serviceOfferingId == null && clusterSize == null) {\n-            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster : %s cannot be scaled, either a new service offering or a new cluster size must be passed\", kubernetesCluster.getName()));\n-        }\n-\n         final KubernetesSupportedVersion clusterVersion = kubernetesSupportedVersionDao.findById(kubernetesCluster.getKubernetesVersionId());\n         if (clusterVersion == null) {\n             throw new CloudRuntimeException(String.format(\"Invalid Kubernetes version associated with Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (!(kubernetesCluster.getState().equals(KubernetesCluster.State.Created) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Running) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Stopped))) {", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDYwNTk1MA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694605950", "bodyText": "and extract in a separate method", "author": "DaanHoogland", "createdAt": "2021-08-24T08:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg5MTQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg5NjU5OA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693896598", "bodyText": "Is this used anywhere? Can't find its usage in my IDE", "author": "shwstppr", "createdAt": "2021-08-23T11:42:06Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterVO.java", "diffHunk": "@@ -333,6 +369,16 @@ public KubernetesClusterVO(String name, String description, long zoneId, long ku\n         this.checkForGc = false;\n     }\n \n+    public KubernetesClusterVO(String name, String description, long zoneId, long kubernetesVersionId, long serviceOfferingId, long templateId,", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwOTg4MQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693909881", "bodyText": "I'm not sure of it's usage probably @davidjumani can advice", "author": "Pearl1594", "createdAt": "2021-08-23T12:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg5NjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwMjkwNA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693902904", "bodyText": "Can type be an enum value?", "author": "shwstppr", "createdAt": "2021-08-23T11:52:21Z", "path": "api/src/main/java/com/cloud/vm/UserVmService.java", "diffHunk": "@@ -379,7 +379,7 @@ UserVm createAdvancedVirtualMachine(DataCenter zone, ServiceOffering serviceOffe\n         String hostName, String displayName, Long diskOfferingId, Long diskSize, String group, HypervisorType hypervisor, HTTPMethod httpmethod, String userData,\n         String sshKeyPair, Map<Long, IpAddresses> requestedIps, IpAddresses defaultIps, Boolean displayVm, String keyboard, List<Long> affinityGroupIdList,\n         Map<String, String> customParameters, String customId, Map<String, Map<Integer, String>> dhcpOptionMap, Map<Long, DiskOffering> dataDiskTemplateToDiskOfferingMap,\n-        Map<String, String> templateOvfPropertiesMap, boolean dynamicScalingEnabled)\n+        Map<String, String> templateOvfPropertiesMap, boolean dynamicScalingEnabled, String type)", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwNzAyNg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693907026", "bodyText": "Is this some tested value?", "author": "shwstppr", "createdAt": "2021-08-23T11:58:58Z", "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/CreateKubernetesClusterCmd.java", "diffHunk": "@@ -55,6 +57,7 @@\n public class CreateKubernetesClusterCmd extends BaseAsyncCreateCmd {\n     public static final Logger LOGGER = Logger.getLogger(CreateKubernetesClusterCmd.class.getName());\n     public static final String APINAME = \"createKubernetesCluster\";\n+    private static final Long DEFAULT_NODE_ROOT_DISK_SIZE = 8L;", "originalCommit": "ac54a79faf191878fd30133c90609a699fc84874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwOTI5Mg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693909292", "bodyText": "We've set it as 8GB as this was the disk size for core os as well", "author": "Pearl1594", "createdAt": "2021-08-23T12:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwNzAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDY1Mjk3Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r694652976", "bodyText": "I read somewhere in k8s docs, this is probably recommended in best practices?", "author": "rhtyd", "createdAt": "2021-08-24T08:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzkwNzAyNg=="}], "type": "inlineReview"}, {"oid": "191bc5dad38100e2f33c9ff206de1732687ecb2e", "url": "https://github.com/apache/cloudstack/commit/191bc5dad38100e2f33c9ff206de1732687ecb2e", "message": "clear maven cache if template checksum file is different", "committedDate": "2021-08-23T13:37:45Z", "type": "commit"}, {"oid": "97d20aac78e9c8b143073fca8d64ec8574020ba5", "url": "https://github.com/apache/cloudstack/commit/97d20aac78e9c8b143073fca8d64ec8574020ba5", "message": "address review comments + cleanup", "committedDate": "2021-08-23T14:31:34Z", "type": "commit"}, {"oid": "9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "url": "https://github.com/apache/cloudstack/commit/9ee0b7b350376df2808c2aeb2288ad8b0866c35c", "message": "If a template (sysvm for a hypervisor) is present in one zone, prevent re-registration of the template - r\nrather copy template to the store at the same path i.e., template_id and update template_store_ref only", "committedDate": "2021-08-24T06:41:23Z", "type": "commit"}, {"oid": "8691708159580bda4ff3c7f078cf918286fafece", "url": "https://github.com/apache/cloudstack/commit/8691708159580bda4ff3c7f078cf918286fafece", "message": "Adding nodeid param in scalekubecluster", "committedDate": "2020-09-18T12:28:39Z", "type": "forcePushed"}, {"oid": "8784cc86cfde9a6cf39b9a9d556b1daea0313058", "url": "https://github.com/apache/cloudstack/commit/8784cc86cfde9a6cf39b9a9d556b1daea0313058", "message": "Changing cks nomenclature", "committedDate": "2020-09-21T06:21:21Z", "type": "forcePushed"}, {"oid": "a155864d2121d6004135c946883d3ce09d653994", "url": "https://github.com/apache/cloudstack/commit/a155864d2121d6004135c946883d3ce09d653994", "message": "Ensuring we dont remove all masters", "committedDate": "2020-10-01T06:50:29Z", "type": "forcePushed"}, {"oid": "d4e9a9b7f5d5da393f695f021d671de6f0a4afcc", "url": "https://github.com/apache/cloudstack/commit/d4e9a9b7f5d5da393f695f021d671de6f0a4afcc", "message": "Ensuring we dont remove all masters", "committedDate": "2020-10-01T07:24:42Z", "type": "forcePushed"}, {"oid": "09700de3abeaa3c4b8ef4a69e4959f161913ba11", "url": "https://github.com/apache/cloudstack/commit/09700de3abeaa3c4b8ef4a69e4959f161913ba11", "message": "Deploying the autoscaler", "committedDate": "2020-10-20T11:34:30Z", "type": "forcePushed"}, {"oid": "d0569c754f743a9d6eb3e615e01f6c6800cf4046", "url": "https://github.com/apache/cloudstack/commit/d0569c754f743a9d6eb3e615e01f6c6800cf4046", "message": "Adding api keys during cluster creation", "committedDate": "2020-10-21T11:31:17Z", "type": "forcePushed"}, {"oid": "53093549c11cec3cb3541d13ab0b02b27f7187aa", "url": "https://github.com/apache/cloudstack/commit/53093549c11cec3cb3541d13ab0b02b27f7187aa", "message": "Adding api keys during cluster creation", "committedDate": "2020-10-22T06:53:17Z", "type": "forcePushed"}, {"oid": "90ff19d2eab0a164234368d5bc759c2426e62032", "url": "https://github.com/apache/cloudstack/commit/90ff19d2eab0a164234368d5bc759c2426e62032", "message": "Adding api keys during cluster creation", "committedDate": "2020-10-22T09:26:49Z", "type": "forcePushed"}, {"oid": "072bbea610edcd8d858691afadf71c6fc9f7e6e5", "url": "https://github.com/apache/cloudstack/commit/072bbea610edcd8d858691afadf71c6fc9f7e6e5", "message": "Deploy keys as a secret file", "committedDate": "2020-10-23T04:29:24Z", "type": "forcePushed"}, {"oid": "345ce49fcccdf72ddec0723c13233f6de86a12f4", "url": "https://github.com/apache/cloudstack/commit/345ce49fcccdf72ddec0723c13233f6de86a12f4", "message": "Cleanup", "committedDate": "2020-10-23T05:34:25Z", "type": "forcePushed"}, {"oid": "035f48e1da874d5dfed5c922687e8a046db786c0", "url": "https://github.com/apache/cloudstack/commit/035f48e1da874d5dfed5c922687e8a046db786c0", "message": "Cleanup", "committedDate": "2020-10-23T06:01:46Z", "type": "forcePushed"}, {"oid": "94b69e33161dffc3ee2edabd9ceaa422c6607652", "url": "https://github.com/apache/cloudstack/commit/94b69e33161dffc3ee2edabd9ceaa422c6607652", "message": "Cleanup", "committedDate": "2020-10-23T06:05:25Z", "type": "forcePushed"}, {"oid": "a0b707bb42c6dfb02d372df8507cab1222b4f8a5", "url": "https://github.com/apache/cloudstack/commit/a0b707bb42c6dfb02d372df8507cab1222b4f8a5", "message": "Cleanup", "committedDate": "2020-10-23T08:20:51Z", "type": "forcePushed"}, {"oid": "ea3fa599c5075e4870d2481c47518a34f24aee36", "url": "https://github.com/apache/cloudstack/commit/ea3fa599c5075e4870d2481c47518a34f24aee36", "message": "Cleanup", "committedDate": "2020-10-25T06:15:32Z", "type": "forcePushed"}, {"oid": "338625fb8da5aeb401cc3c4766f77cfb5a31eeaa", "url": "https://github.com/apache/cloudstack/commit/338625fb8da5aeb401cc3c4766f77cfb5a31eeaa", "message": "Cleanup", "committedDate": "2020-10-25T14:36:53Z", "type": "forcePushed"}, {"oid": "ff1e0fd0870ca6d3fec123e8fc62d32017e1308b", "url": "https://github.com/apache/cloudstack/commit/ff1e0fd0870ca6d3fec123e8fc62d32017e1308b", "message": "Allowing for upgrades", "committedDate": "2020-10-27T16:50:24Z", "type": "forcePushed"}, {"oid": "4f00c51582aa7a5a45b25b78df5f72f47ab51b8c", "url": "https://github.com/apache/cloudstack/commit/4f00c51582aa7a5a45b25b78df5f72f47ab51b8c", "message": "Allowing for upgrades", "committedDate": "2020-10-28T05:13:59Z", "type": "forcePushed"}, {"oid": "39ab83867a4636040cc26d8841d8f31e6ac5c7f7", "url": "https://github.com/apache/cloudstack/commit/39ab83867a4636040cc26d8841d8f31e6ac5c7f7", "message": "Cleanup", "committedDate": "2020-10-28T09:16:19Z", "type": "forcePushed"}, {"oid": "7dc4ec847979153034e0731e65e58d1e18f93337", "url": "https://github.com/apache/cloudstack/commit/7dc4ec847979153034e0731e65e58d1e18f93337", "message": "Cleanup", "committedDate": "2020-10-28T09:30:19Z", "type": "forcePushed"}, {"oid": "804c91e4635554999516ddde72c65fbaea69aed4", "url": "https://github.com/apache/cloudstack/commit/804c91e4635554999516ddde72c65fbaea69aed4", "message": "Cleanup", "committedDate": "2020-10-28T09:36:48Z", "type": "forcePushed"}, {"oid": "9d07c7b9de3bec456b56d16cd0160caa19653c1f", "url": "https://github.com/apache/cloudstack/commit/9d07c7b9de3bec456b56d16cd0160caa19653c1f", "message": "Cleanup", "committedDate": "2020-10-28T12:49:18Z", "type": "forcePushed"}, {"oid": "d5f191aa3f7e01fc282b1d96f1f6aa865846783d", "url": "https://github.com/apache/cloudstack/commit/d5f191aa3f7e01fc282b1d96f1f6aa865846783d", "message": "Cleanup", "committedDate": "2020-10-28T12:54:22Z", "type": "forcePushed"}, {"oid": "3ada7bacb7605edd1b0fd76b8d629e2814691efe", "url": "https://github.com/apache/cloudstack/commit/3ada7bacb7605edd1b0fd76b8d629e2814691efe", "message": "Cleanup", "committedDate": "2020-10-28T13:50:25Z", "type": "forcePushed"}, {"oid": "dd3fe2ec193a057643e7793753de11efae7d491f", "url": "https://github.com/apache/cloudstack/commit/dd3fe2ec193a057643e7793753de11efae7d491f", "message": "Enhancing auytoscaler deployment", "committedDate": "2020-10-29T05:33:17Z", "type": "forcePushed"}, {"oid": "e65d32a068a05c9d1885a5ec9bfedec7f09d5fa4", "url": "https://github.com/apache/cloudstack/commit/e65d32a068a05c9d1885a5ec9bfedec7f09d5fa4", "message": "Adding logs for upgrade failure", "committedDate": "2020-10-29T11:05:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNDQyNA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514204424", "bodyText": "this comment could be a method name and the bit below factored out", "author": "DaanHoogland", "createdAt": "2020-10-29T12:00:33Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -378,17 +376,18 @@ private void setupKubernetesClusterNetworkRules(Network network, List<UserVm> cl\n             throw new ManagementServerException(String.format(\"No source NAT IP addresses found for network : %s, Kubernetes cluster : %s\",\n                 network.getName(), kubernetesCluster.getName()));\n         }\n-\n+        // Firewall rule fo API access for master node VMs", "originalCommit": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNDcxMw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514204713", "bodyText": "idem; this comment could be a method name and the bit below factored out", "author": "DaanHoogland", "createdAt": "2020-10-29T12:01:05Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -378,17 +376,18 @@ private void setupKubernetesClusterNetworkRules(Network network, List<UserVm> cl\n             throw new ManagementServerException(String.format(\"No source NAT IP addresses found for network : %s, Kubernetes cluster : %s\",\n                 network.getName(), kubernetesCluster.getName()));\n         }\n-\n+        // Firewall rule fo API access for master node VMs\n         try {\n             provisionFirewallRules(publicIp, owner, CLUSTER_API_PORT, CLUSTER_API_PORT);\n             if (LOGGER.isInfoEnabled()) {\n-                LOGGER.info(String.format(\"Provisioned firewall rule to open up port %d on %s for Kubernetes cluster ID: %s\",\n-                        CLUSTER_API_PORT, publicIp.getAddress().addr(), kubernetesCluster.getUuid()));\n+                LOGGER.info(String.format(\"Provisioned firewall rule to open up port %d on %s for Kubernetes cluster %s\",\n+                        CLUSTER_API_PORT, publicIp.getAddress().addr(), kubernetesCluster.getName()));\n             }\n         } catch (NoSuchFieldException | IllegalAccessException | ResourceUnavailableException | NetworkRuleConflictException e) {\n             throw new ManagementServerException(String.format(\"Failed to provision firewall rules for API access for the Kubernetes cluster : %s\", kubernetesCluster.getName()), e);\n         }\n \n+        // Firewall rule fo SSH access on each node VM", "originalCommit": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNTUyOA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514205528", "bodyText": "one or two extra methods", "author": "DaanHoogland", "createdAt": "2020-10-29T12:02:37Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterStartWorker.java", "diffHunk": "@@ -565,6 +564,18 @@ public boolean startKubernetesClusterOnCreate() {\n         if (!isKubernetesClusterDashboardServiceRunning(true, startTimeoutTime)) {\n             logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup Kubernetes cluster : %s in usable state as unable to get Dashboard service running for the cluster\", kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n         }\n+        retrieveScriptFiles();\n+        for (int i = 0; i < clusterVMs.size(); ++i) {\n+            try {\n+                copyAutoscalerScripts(publicIpAddress, CLUSTER_NODES_DEFAULT_START_SSH_PORT + i);\n+            } catch (Exception e) {\n+                throw new CloudRuntimeException(e);\n+            }\n+        }\n+        if (!createCloudStackSecret(keys)) {\n+            logTransitStateAndThrow(Level.ERROR, String.format(\"Failed to setup keys for Kubernetes cluster %s\",\n+                kubernetesCluster.getName()), kubernetesCluster.getId(),KubernetesCluster.Event.OperationFailed);\n+        }", "originalCommit": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2MjgyMg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514962822", "bodyText": "Minor nit, inconsistency in exception messages. At some places it is bit detailed while at some places it is single phrase starting with lowercase", "author": "shwstppr", "createdAt": "2020-10-30T09:18:28Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -845,30 +865,87 @@ private void validateKubernetesClusterScaleParameters(ScaleKubernetesClusterCmd\n         final Long kubernetesClusterId = cmd.getId();\n         final Long serviceOfferingId = cmd.getServiceOfferingId();\n         final Long clusterSize = cmd.getClusterSize();\n+        final List<Long> nodeIds = cmd.getNodeIds();\n+        final Boolean isAutoscalingEnabled = cmd.isAutoscalingEnabled();\n+        final Long minSize = cmd.getMinSize();\n+        final Long maxSize = cmd.getMaxSize();\n+\n         if (kubernetesClusterId == null || kubernetesClusterId < 1L) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         KubernetesClusterVO kubernetesCluster = kubernetesClusterDao.findById(kubernetesClusterId);\n         if (kubernetesCluster == null || kubernetesCluster.getRemoved() != null) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         final DataCenter zone = dataCenterDao.findById(kubernetesCluster.getZoneId());\n         if (zone == null) {\n             logAndThrow(Level.WARN, String.format(\"Unable to find zone for Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (serviceOfferingId == null && clusterSize == null && nodeIds == null && isAutoscalingEnabled == null) {\n+            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster %s cannot be scaled, either service offering or cluster size or nodeids to be removed or autoscaling must be passed\", kubernetesCluster.getName()));\n+        }\n+\n         Account caller = CallContext.current().getCallingAccount();\n         accountManager.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, false, kubernetesCluster);\n \n-        if (serviceOfferingId == null && clusterSize == null) {\n-            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster : %s cannot be scaled, either a new service offering or a new cluster size must be passed\", kubernetesCluster.getName()));\n-        }\n-\n         final KubernetesSupportedVersion clusterVersion = kubernetesSupportedVersionDao.findById(kubernetesCluster.getKubernetesVersionId());\n         if (clusterVersion == null) {\n             throw new CloudRuntimeException(String.format(\"Invalid Kubernetes version associated with Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (!(kubernetesCluster.getState().equals(KubernetesCluster.State.Created) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Running) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Stopped))) {\n+            throw new PermissionDeniedException(String.format(\"Kubernetes cluster %s is in %s state and can not be scaled\", kubernetesCluster.getName(), kubernetesCluster.getState().toString()));\n+        }\n+\n+        if (isAutoscalingEnabled != null && isAutoscalingEnabled) {\n+            if (clusterSize != null || serviceOfferingId != null || nodeIds != null) {\n+                throw new InvalidParameterValueException(\"autoscaling can not be passed along with nodeids or clustersize or service offering\");\n+            }\n+\n+            if (!KubernetesVersionManagerImpl.versionSupportsAutoscaling(clusterVersion)) {\n+                throw new InvalidParameterValueException(String.format(\"Autoscaling requires Kubernetes Version %s or above\",\n+                    KubernetesVersionManagerImpl.MINIMUN_AUTOSCALER_SUPPORTED_VERSION ));\n+            }\n+", "originalCommit": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2MzE2MA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514963160", "bodyText": "Are we allowing scaling for master nodes?", "author": "shwstppr", "createdAt": "2020-10-30T09:19:08Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -845,30 +865,87 @@ private void validateKubernetesClusterScaleParameters(ScaleKubernetesClusterCmd\n         final Long kubernetesClusterId = cmd.getId();\n         final Long serviceOfferingId = cmd.getServiceOfferingId();\n         final Long clusterSize = cmd.getClusterSize();\n+        final List<Long> nodeIds = cmd.getNodeIds();\n+        final Boolean isAutoscalingEnabled = cmd.isAutoscalingEnabled();\n+        final Long minSize = cmd.getMinSize();\n+        final Long maxSize = cmd.getMaxSize();\n+\n         if (kubernetesClusterId == null || kubernetesClusterId < 1L) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         KubernetesClusterVO kubernetesCluster = kubernetesClusterDao.findById(kubernetesClusterId);\n         if (kubernetesCluster == null || kubernetesCluster.getRemoved() != null) {\n             throw new InvalidParameterValueException(\"Invalid Kubernetes cluster ID\");\n         }\n+\n         final DataCenter zone = dataCenterDao.findById(kubernetesCluster.getZoneId());\n         if (zone == null) {\n             logAndThrow(Level.WARN, String.format(\"Unable to find zone for Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (serviceOfferingId == null && clusterSize == null && nodeIds == null && isAutoscalingEnabled == null) {\n+            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster %s cannot be scaled, either service offering or cluster size or nodeids to be removed or autoscaling must be passed\", kubernetesCluster.getName()));\n+        }\n+\n         Account caller = CallContext.current().getCallingAccount();\n         accountManager.checkAccess(caller, SecurityChecker.AccessType.OperateEntry, false, kubernetesCluster);\n \n-        if (serviceOfferingId == null && clusterSize == null) {\n-            throw new InvalidParameterValueException(String.format(\"Kubernetes cluster : %s cannot be scaled, either a new service offering or a new cluster size must be passed\", kubernetesCluster.getName()));\n-        }\n-\n         final KubernetesSupportedVersion clusterVersion = kubernetesSupportedVersionDao.findById(kubernetesCluster.getKubernetesVersionId());\n         if (clusterVersion == null) {\n             throw new CloudRuntimeException(String.format(\"Invalid Kubernetes version associated with Kubernetes cluster : %s\", kubernetesCluster.getName()));\n         }\n \n+        if (!(kubernetesCluster.getState().equals(KubernetesCluster.State.Created) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Running) ||\n+                kubernetesCluster.getState().equals(KubernetesCluster.State.Stopped))) {\n+            throw new PermissionDeniedException(String.format(\"Kubernetes cluster %s is in %s state and can not be scaled\", kubernetesCluster.getName(), kubernetesCluster.getState().toString()));\n+        }\n+\n+        if (isAutoscalingEnabled != null && isAutoscalingEnabled) {\n+            if (clusterSize != null || serviceOfferingId != null || nodeIds != null) {\n+                throw new InvalidParameterValueException(\"autoscaling can not be passed along with nodeids or clustersize or service offering\");\n+            }\n+\n+            if (!KubernetesVersionManagerImpl.versionSupportsAutoscaling(clusterVersion)) {\n+                throw new InvalidParameterValueException(String.format(\"Autoscaling requires Kubernetes Version %s or above\",\n+                    KubernetesVersionManagerImpl.MINIMUN_AUTOSCALER_SUPPORTED_VERSION ));\n+            }\n+\n+            validateEndpointUrl();\n+\n+            if (minSize == null || maxSize == null) {\n+                throw new InvalidParameterValueException(\"autoscaling requires minsize and maxsize to be passed\");\n+            }\n+            if (minSize < 1) {\n+                throw new InvalidParameterValueException(\"minsize must be at least than 1\");\n+            }\n+            if (maxSize <= minSize) {\n+                throw new InvalidParameterValueException(\"maxsize must be greater than or equal to minsize\");\n+            }\n+        }\n+\n+        if (nodeIds != null) {\n+            if (clusterSize != null || serviceOfferingId != null) {\n+                throw new InvalidParameterValueException(\"nodeids can not be passed along with clustersize or service offering\");\n+            }\n+            List<KubernetesClusterVmMapVO> nodes = kubernetesClusterVmMapDao.listByClusterIdAndVmIdsIn(kubernetesCluster.getId(), nodeIds);\n+            // Do all the nodes exist ?\n+            if (nodes == null || nodes.size() != nodeIds.size()) {\n+                throw new InvalidParameterValueException(\"Invalid node ids\");\n+            }\n+            // Ensure there's always a master\n+            long mastersToRemove = nodes.stream().filter(x -> x.isMaster()).count();\n+            if (mastersToRemove >= kubernetesCluster.getMasterNodeCount()) {\n+                throw new InvalidParameterValueException(\"Can not remove all masters from a cluster\");\n+            }", "originalCommit": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjgyMQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515016821", "bodyText": "The autoscaler will not remove master nodes, however, nodeids can be passed, ensuring that users do not accidentally delete master nodes", "author": "davidjumani", "createdAt": "2020-10-30T11:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2MzE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2NjMxNw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514966317", "bodyText": "For UI, do we need to return this in KubernetesSupportedVersionResponse? Or can we deprecate older k8s version?", "author": "shwstppr", "createdAt": "2020-10-30T09:25:12Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/version/KubernetesVersionManagerImpl.java", "diffHunk": "@@ -202,6 +204,10 @@ public static int compareSemanticVersions(String v1, String v2) throws IllegalAr\n         return 0;\n     }\n \n+    public static boolean versionSupportsAutoscaling(KubernetesSupportedVersion clusterVersion) {", "originalCommit": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzIwOQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515017209", "bodyText": "@shwstppr Do you mean as a flag ?", "author": "davidjumani", "createdAt": "2020-10-30T11:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2NjMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMzczOQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515023739", "bodyText": "@davidjumani something like this https://github.com/shapeblue/cloudstack/blob/41a7eac5f55acfe85f7f32443f1b8ef8574392f5/plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/response/KubernetesSupportedVersionResponse.java#L63?", "author": "shwstppr", "createdAt": "2020-10-30T11:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2NjMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc3MTczNg==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515771736", "bodyText": "Makes sense to deprecate it. Can also add a flag in case users are running older versions. Thanks @shwstppr", "author": "davidjumani", "createdAt": "2020-11-02T07:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2NjMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2Nzc2Ng==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r514967766", "bodyText": "We don't support allowing autoscaling while deployment itself and it can be enabled only after the cluster is deployed?", "author": "shwstppr", "createdAt": "2020-10-30T09:28:00Z", "path": "plugins/integrations/kubernetes-service/src/main/java/org/apache/cloudstack/api/command/user/kubernetes/cluster/ScaleKubernetesClusterCmd.java", "diffHunk": "@@ -58,19 +61,38 @@\n     //////////////// API parameters /////////////////////\n     /////////////////////////////////////////////////////\n     @Parameter(name = ApiConstants.ID, type = CommandType.UUID, required = true,\n-            entityType = KubernetesClusterResponse.class,\n-            description = \"the ID of the Kubernetes cluster\")\n+        entityType = KubernetesClusterResponse.class,\n+        description = \"the ID of the Kubernetes cluster\")\n     private Long id;\n \n     @ACL(accessType = SecurityChecker.AccessType.UseEntry)\n     @Parameter(name = ApiConstants.SERVICE_OFFERING_ID, type = CommandType.UUID, entityType = ServiceOfferingResponse.class,\n-            description = \"the ID of the service offering for the virtual machines in the cluster.\")\n+        description = \"the ID of the service offering for the virtual machines in the cluster.\")\n     private Long serviceOfferingId;\n \n     @Parameter(name=ApiConstants.SIZE, type = CommandType.LONG,\n-            description = \"number of Kubernetes cluster nodes\")\n+        description = \"number of Kubernetes cluster nodes\")\n     private Long clusterSize;\n \n+    @Parameter(name = ApiConstants.NODE_IDS,\n+        type = CommandType.LIST,\n+        collectionType = CommandType.UUID,\n+        entityType = UserVmResponse.class,\n+        description = \"the IDs of the nodes to be removed\")\n+    private List<Long> nodeIds;\n+\n+    @Parameter(name=ApiConstants.AUTOSCALING_ENABLED, type = CommandType.BOOLEAN,", "originalCommit": "41a7eac5f55acfe85f7f32443f1b8ef8574392f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzY2Mw==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r515017663", "bodyText": "Yes, for now only after deployment, however, I do plan to add that in the future", "author": "davidjumani", "createdAt": "2020-10-30T11:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk2Nzc2Ng=="}], "type": "inlineReview"}, {"oid": "123f00ab07d985429a779bee2ae71509d586b2a4", "url": "https://github.com/apache/cloudstack/commit/123f00ab07d985429a779bee2ae71509d586b2a4", "message": "refactor code and test", "committedDate": "2020-11-03T05:47:15Z", "type": "forcePushed"}, {"oid": "7b1de9260c2af989cd49c440470bff21a6566336", "url": "https://github.com/apache/cloudstack/commit/7b1de9260c2af989cd49c440470bff21a6566336", "message": "Refactoring tests", "committedDate": "2020-11-03T06:05:33Z", "type": "forcePushed"}, {"oid": "2b341f07edf3c4fa4596f7a788dba444cf846545", "url": "https://github.com/apache/cloudstack/commit/2b341f07edf3c4fa4596f7a788dba444cf846545", "message": "Refactoring tests", "committedDate": "2020-11-03T06:07:56Z", "type": "forcePushed"}, {"oid": "2060e0bcbaa4088f1fa8c1f8da4c8404d29e46c0", "url": "https://github.com/apache/cloudstack/commit/2060e0bcbaa4088f1fa8c1f8da4c8404d29e46c0", "message": "Fixes", "committedDate": "2020-11-03T08:58:05Z", "type": "forcePushed"}, {"oid": "8d17ec823143358944009300bb44c579b26e762d", "url": "https://github.com/apache/cloudstack/commit/8d17ec823143358944009300bb44c579b26e762d", "message": "Fixes", "committedDate": "2020-11-03T10:42:56Z", "type": "forcePushed"}, {"oid": "9a665990ce007b3120a3cdb98efc46f9e144eddb", "url": "https://github.com/apache/cloudstack/commit/9a665990ce007b3120a3cdb98efc46f9e144eddb", "message": "Fixes", "committedDate": "2020-11-03T11:19:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNDk3MA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517204970", "bodyText": "Note: after 4.15 is cut; we need to create a new upgrade path from 4.15->4.16 and move these there. cc @Pearl1594", "author": "rhtyd", "createdAt": "2020-11-04T09:27:23Z", "path": "engine/schema/src/main/java/com/cloud/upgrade/dao/Upgrade41400to41500.java", "diffHunk": "@@ -140,9 +140,9 @@ private void updateSystemVmTemplates(final Connection conn) {\n \n         final Map<Hypervisor.HypervisorType, String> newTemplateChecksum = new HashMap<Hypervisor.HypervisorType, String>() {\n             {\n-                put(Hypervisor.HypervisorType.KVM, \"81b3e48bb934784a13555a43c5ef5ffb\");\n-                put(Hypervisor.HypervisorType.XenServer, \"1b178a5dbdbe090555515340144c6017\");\n-                put(Hypervisor.HypervisorType.VMware, \"e6a88e518c57d6f36c096c4204c3417f\");\n+                put(Hypervisor.HypervisorType.KVM, \"0d95bb3d9385097dec8b485e46eae34b\");", "originalCommit": "9a665990ce007b3120a3cdb98efc46f9e144eddb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MDIwNQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517160205", "bodyText": "@Pearl1594 have we put any check or something for people who will upgrade to 4.16 and have existing k8s cluster? They try to scale their cluster cc @davidjumani", "author": "shwstppr", "createdAt": "2020-11-04T08:10:15Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/KubernetesClusterManagerImpl.java", "diffHunk": "@@ -261,60 +269,6 @@ private void logAndThrow(final Level logLevel, final String message, final Excep\n         logTransitStateAndThrow(logLevel, message, null, null, ex);\n     }\n \n-    private boolean isKubernetesServiceTemplateConfigured(DataCenter zone) {\n-        // Check Kubernetes VM template for zone\n-        boolean isHyperVAvailable = false;\n-        boolean isKVMAvailable = false;\n-        boolean isVMwareAvailable = false;\n-        boolean isXenserverAvailable = false;\n-        List<ClusterVO> clusters = clusterDao.listByZoneId(zone.getId());\n-        for (ClusterVO clusterVO : clusters) {\n-            if (Hypervisor.HypervisorType.Hyperv.equals(clusterVO.getHypervisorType())) {\n-                isHyperVAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.KVM.equals(clusterVO.getHypervisorType())) {\n-                isKVMAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.VMware.equals(clusterVO.getHypervisorType())) {\n-                isVMwareAvailable = true;\n-            }\n-            if (Hypervisor.HypervisorType.XenServer.equals(clusterVO.getHypervisorType())) {\n-                isXenserverAvailable = true;\n-            }\n-        }\n-        List<Pair<String, String>> templatePairs = new ArrayList<>();\n-        if (isHyperVAvailable) {\n-            templatePairs.add(new Pair<>(KubernetesClusterHyperVTemplateName.key(), KubernetesClusterHyperVTemplateName.value()));\n-        }\n-        if (isKVMAvailable) {", "originalCommit": "9a665990ce007b3120a3cdb98efc46f9e144eddb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYzMjgyMA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r519632820", "bodyText": "@shwstppr On an upgraded env, the existing cluster will continue to operate  as is, and scaling will result in creation of a new debian-based worker node", "author": "Pearl1594", "createdAt": "2020-11-09T08:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MDIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5Mzg4NjA2NA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r693886064", "bodyText": "@Pearl1594 a follow up question on this - I've a running k8s cluster. I upgrade ACS to 4.16. I scale-up my k8s cluster. Now there will be mixed node VMs (with coreos and systemvm templates). Now when I try to upgrade k8s version on my k8s cluster will there be an issue? As user on these VMs may be different core and root.", "author": "shwstppr", "createdAt": "2021-08-23T11:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2MDIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2Mjg4OA==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517162888", "bodyText": "Don't we need to have some default type?", "author": "shwstppr", "createdAt": "2020-11-04T08:15:32Z", "path": "server/src/main/java/com/cloud/vm/UserVmManager.java", "diffHunk": "@@ -55,6 +55,10 @@\n \n     static final int MAX_USER_DATA_LENGTH_BYTES = 2048;\n \n+    public static enum UserVmType {\n+        CKSNode\n+    }", "originalCommit": "9a665990ce007b3120a3cdb98efc46f9e144eddb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0ODk3MQ==", "url": "https://github.com/apache/cloudstack/pull/4329#discussion_r517248971", "bodyText": "@davidjumani - our systemvmtemplate patching also uses /opt/bin --> data iso patching doesn't overwrite any scripts or folders?", "author": "rhtyd", "createdAt": "2020-11-04T10:37:18Z", "path": "plugins/integrations/kubernetes-service/src/main/java/com/cloud/kubernetes/cluster/actionworkers/KubernetesClusterActionWorker.java", "diffHunk": "@@ -380,4 +411,59 @@ protected boolean stateTransitTo(long kubernetesClusterId, KubernetesCluster.Eve\n             return false;\n         }\n     }\n+\n+    protected boolean createCloudStackSecret(String[] keys) {\n+        File pkFile = getManagementServerSshPublicKeyFile();\n+        Pair<String, Integer> publicIpSshPort = getKubernetesClusterServerIpSshPort(null);\n+        publicIpAddress = publicIpSshPort.first();\n+        sshPort = publicIpSshPort.second();\n+\n+        try {\n+            Pair<Boolean, String> result = SshHelper.sshExecute(publicIpAddress, sshPort, CLUSTER_NODE_VM_USER,\n+                pkFile, null, String.format(\"/opt/bin/deploy-cloudstack-secret -u '%s' -k '%s' -s '%s'\",", "originalCommit": "9a665990ce007b3120a3cdb98efc46f9e144eddb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "969ef36c56bbdcd8c70324ac31d7fbea75f2bc47", "url": "https://github.com/apache/cloudstack/commit/969ef36c56bbdcd8c70324ac31d7fbea75f2bc47", "message": "Upgrade path changes", "committedDate": "2020-11-04T15:30:57Z", "type": "forcePushed"}, {"oid": "20c927e904550fb43ad9a291b53477a7a41f433e", "url": "https://github.com/apache/cloudstack/commit/20c927e904550fb43ad9a291b53477a7a41f433e", "message": "Upgrade path changes", "committedDate": "2020-11-04T15:40:20Z", "type": "forcePushed"}, {"oid": "01da7dadd1582f0fedc0713457ff714f525dedf0", "url": "https://github.com/apache/cloudstack/commit/01da7dadd1582f0fedc0713457ff714f525dedf0", "message": "grow root partition for cks node", "committedDate": "2020-11-09T07:38:24Z", "type": "forcePushed"}, {"oid": "9c3c6c78b130cc9146aa6d78f8522f041426baa7", "url": "https://github.com/apache/cloudstack/commit/9c3c6c78b130cc9146aa6d78f8522f041426baa7", "message": "Refactoring tests", "committedDate": "2020-11-10T05:24:08Z", "type": "forcePushed"}, {"oid": "f9ed8ff37d6595f1f240a67cd70a72975a80855d", "url": "https://github.com/apache/cloudstack/commit/f9ed8ff37d6595f1f240a67cd70a72975a80855d", "message": "Refactoring tests", "committedDate": "2020-11-10T05:25:35Z", "type": "forcePushed"}, {"oid": "4164998a0b03cd34d03078a5c2f7115f4b1bbb97", "url": "https://github.com/apache/cloudstack/commit/4164998a0b03cd34d03078a5c2f7115f4b1bbb97", "message": "fix port number passed on shared n/ws + optimize disk size", "committedDate": "2020-11-12T05:38:12Z", "type": "forcePushed"}, {"oid": "15ae34dfebe6945a2c6d07032fc78c246db1c694", "url": "https://github.com/apache/cloudstack/commit/15ae34dfebe6945a2c6d07032fc78c246db1c694", "message": "Adding kubernetes as a dependency for marvin", "committedDate": "2021-01-25T06:52:15Z", "type": "forcePushed"}, {"oid": "8cbddf284b89dfd8b2ddc10e01551e337fd47c8b", "url": "https://github.com/apache/cloudstack/commit/8cbddf284b89dfd8b2ddc10e01551e337fd47c8b", "message": "Adding nodeid param in scalekubecluster", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "53a94627109a31366a58c1107479da0e6d253343", "url": "https://github.com/apache/cloudstack/commit/53a94627109a31366a58c1107479da0e6d253343", "message": "Changing cks nomenclature", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "b81e9ee75bf5e7cfa7ebb6f91e8bca5f9a515581", "url": "https://github.com/apache/cloudstack/commit/b81e9ee75bf5e7cfa7ebb6f91e8bca5f9a515581", "message": "Adding isMaster in KubernetesClusterVmMap", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "52211651e4a21b92b9716ccebb43d6fb2e0346b6", "url": "https://github.com/apache/cloudstack/commit/52211651e4a21b92b9716ccebb43d6fb2e0346b6", "message": "Ensuring we dont remove all masters", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "83b3bd787bc60bc3aa247778819c76c2c02178c3", "url": "https://github.com/apache/cloudstack/commit/83b3bd787bc60bc3aa247778819c76c2c02178c3", "message": "Deploying the autoscaler", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "ef65329c99946331b882caac60a335f633a92248", "url": "https://github.com/apache/cloudstack/commit/ef65329c99946331b882caac60a335f633a92248", "message": "Adding public ip to listKubernetesClusterResponse", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "74539e2d63e2d0e049b8a67a003fd368a825929b", "url": "https://github.com/apache/cloudstack/commit/74539e2d63e2d0e049b8a67a003fd368a825929b", "message": "Adding api keys during cluster creation", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "9121b1e613c52139da74c84e8cc5d7e22282589b", "url": "https://github.com/apache/cloudstack/commit/9121b1e613c52139da74c84e8cc5d7e22282589b", "message": "Cleanup", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "39651680cf1d97151865207135798d303f6ab247", "url": "https://github.com/apache/cloudstack/commit/39651680cf1d97151865207135798d303f6ab247", "message": "Deploy keys as a secret file", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "30b8c04e8fc8dd7dd76bab711e461415b848a371", "url": "https://github.com/apache/cloudstack/commit/30b8c04e8fc8dd7dd76bab711e461415b848a371", "message": "Cleanup", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "82b98d2aed6e5c8010e2eba5affcb21c0f5b346d", "url": "https://github.com/apache/cloudstack/commit/82b98d2aed6e5c8010e2eba5affcb21c0f5b346d", "message": "Adding smoke tests", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "3e145dd075915b60d78b14847608ab355c0884a0", "url": "https://github.com/apache/cloudstack/commit/3e145dd075915b60d78b14847608ab355c0884a0", "message": "Allowing for upgrades", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "db6b7622a63bb41dcad9ff370b07160e1340f448", "url": "https://github.com/apache/cloudstack/commit/db6b7622a63bb41dcad9ff370b07160e1340f448", "message": "Ensure there's always a node during scale down", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "1f23c7eb3fd8fa54344f8c8afb23574d043b2baa", "url": "https://github.com/apache/cloudstack/commit/1f23c7eb3fd8fa54344f8c8afb23574d043b2baa", "message": "Tweaking nw rules while scaling", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "fa4d064980c04028733095899bc0fdc5b5b1f638", "url": "https://github.com/apache/cloudstack/commit/fa4d064980c04028733095899bc0fdc5b5b1f638", "message": "Cleanup", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "cd136db317840ae4730366ad518b7b907dbcdf8b", "url": "https://github.com/apache/cloudstack/commit/cd136db317840ae4730366ad518b7b907dbcdf8b", "message": "Enhancing auytoscaler deployment", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "4fa20f4e8c74860de74ab643436e5f8512fc2967", "url": "https://github.com/apache/cloudstack/commit/4fa20f4e8c74860de74ab643436e5f8512fc2967", "message": "Fixing tests", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "71d1ee102f5093b75ebcbbe0613c0e4f2b643c20", "url": "https://github.com/apache/cloudstack/commit/71d1ee102f5093b75ebcbbe0613c0e4f2b643c20", "message": "Refactoring", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "4a08b1e20fbe969ce00d654c0c32ff163d12f361", "url": "https://github.com/apache/cloudstack/commit/4a08b1e20fbe969ce00d654c0c32ff163d12f361", "message": "Adding logs for upgrade failure", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "0a67da858cd4a69d12571976558974f79d60dbde", "url": "https://github.com/apache/cloudstack/commit/0a67da858cd4a69d12571976558974f79d60dbde", "message": "More cleanup", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "0860d1e57e1c6ccf9a2dac1d62af3be083d0a319", "url": "https://github.com/apache/cloudstack/commit/0860d1e57e1c6ccf9a2dac1d62af3be083d0a319", "message": "Limiting max cluster size to global setting KubernetesMaxClusterSize", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "15ccfbfd76cdeda95a3b045a995dd2f73c9ecf26", "url": "https://github.com/apache/cloudstack/commit/15ccfbfd76cdeda95a3b045a995dd2f73c9ecf26", "message": "CKS CoreOS EOL update  (#68)\n\n* prevent NPE during ssh key reset\r\n\r\n* Initial Commit - Debian template as replacement for CoreOS\r\n\r\n* Support for cks nodes to use systemvm template\r\n\r\n* Allow usage of systemvm template by other accounts during k8s cluster deployment\r\n\r\n* Refactor tests + allow user to use SystemVM template during scaling\r\n\r\n* Fix additional master config file\r\n\r\n* remove redundant lines\r\n\r\n* Formatted code\r\n\r\n* temporary checksum update\r\n\r\n* change guest os id for xenserver\r\n\r\n* Adding public ip to listKubernetesClusterResponse\r\n\r\n* Guestos id for vmware\r\n\r\n* Cleaned up code\r\n\r\n* Wait for ssh to become available before attaching ISO and template changes\r\n\r\n* debug logs\r\n\r\n* commit addresses systemvm iso not getting attached during bootup\r\n\r\n* Cleanup + set vmware systemvm template deploy_as_is to 1\r\n\r\n* fix for systemvm template - deploy as is field\r\n\r\n* code cleanup\r\n\r\n* Additional details to support deployment on shared network\r\n\r\n* Support for shared networks\r\n\r\nCo-authored-by: Pearl Dsilva <pearl.dsilva@shapeblue.com>\r\nCo-authored-by: davidjumani <dj.davidjumani1994@gmail.com>", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "e66c085ea38ca9e8c47c1176c1f120c7c6984a2e", "url": "https://github.com/apache/cloudstack/commit/e66c085ea38ca9e8c47c1176c1f120c7c6984a2e", "message": "Adding verbosity to upgrade script", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "200e01c7bdf153bec769a8662a1957844530730a", "url": "https://github.com/apache/cloudstack/commit/200e01c7bdf153bec769a8662a1957844530730a", "message": "Adding supportsautoscaling to supported version response", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "ca15896f691a2005217aba8bd92c87de2b0c4117", "url": "https://github.com/apache/cloudstack/commit/ca15896f691a2005217aba8bd92c87de2b0c4117", "message": "Refactor", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "586f2613c3d9c8b8ce4b207bb3fc2c15236daffd", "url": "https://github.com/apache/cloudstack/commit/586f2613c3d9c8b8ce4b207bb3fc2c15236daffd", "message": "Adding licensing headers", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "e8ab782368b97ff1e06a5bb07ccf4e2ba89377f8", "url": "https://github.com/apache/cloudstack/commit/e8ab782368b97ff1e06a5bb07ccf4e2ba89377f8", "message": "Adding absolute path to kubectl", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "7f5e3297c83918e8c56d141512d3706520b530fb", "url": "https://github.com/apache/cloudstack/commit/7f5e3297c83918e8c56d141512d3706520b530fb", "message": "Removing sudo for kubectl commands", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "2e69c17dc862042fc28bb5cc177f25f4ece895c1", "url": "https://github.com/apache/cloudstack/commit/2e69c17dc862042fc28bb5cc177f25f4ece895c1", "message": "refactor code and test", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "e53af8db96264d4f83950d97e52ea27897c53671", "url": "https://github.com/apache/cloudstack/commit/e53af8db96264d4f83950d97e52ea27897c53671", "message": "Refactoring tests", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "347428d5241a7f7e4a1a599d6fb2f24908e73806", "url": "https://github.com/apache/cloudstack/commit/347428d5241a7f7e4a1a599d6fb2f24908e73806", "message": "Fixes", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "63454cecee7307f49f34952af4d9f487a6914126", "url": "https://github.com/apache/cloudstack/commit/63454cecee7307f49f34952af4d9f487a6914126", "message": "Upgrade path changes", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "6cd04545e3f2802bb5c3f63771df6a820609e9e8", "url": "https://github.com/apache/cloudstack/commit/6cd04545e3f2802bb5c3f63771df6a820609e9e8", "message": "Added core user for b/w compatibility + cks template fixes", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "46250e52c03b3fd4b2f1de306a5d7fd87391e621", "url": "https://github.com/apache/cloudstack/commit/46250e52c03b3fd4b2f1de306a5d7fd87391e621", "message": "Renaming db column", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "5f36ddb22f0276fda0edddc7ffd850f8b42d0a77", "url": "https://github.com/apache/cloudstack/commit/5f36ddb22f0276fda0edddc7ffd850f8b42d0a77", "message": "systemvm: install haproxy 1.8 instead of 1.7 to support HTTP2", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "a5fa98861b814dc314212da90fc538aab724d0fa", "url": "https://github.com/apache/cloudstack/commit/a5fa98861b814dc314212da90fc538aab724d0fa", "message": "systemvm: configurable root disk size", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "7fc88572ed81706f26327bda9a7005dedaa30975", "url": "https://github.com/apache/cloudstack/commit/7fc88572ed81706f26327bda9a7005dedaa30975", "message": "systemvm: auto-grow partitions only when growpart is found", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "59e11ea3b63185ed2c01273caa2b126b48eef54b", "url": "https://github.com/apache/cloudstack/commit/59e11ea3b63185ed2c01273caa2b126b48eef54b", "message": "add haproxy back", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "01edb107d6f736dee06dd972d96a782fad6000a2", "url": "https://github.com/apache/cloudstack/commit/01edb107d6f736dee06dd972d96a782fad6000a2", "message": "grow root partition for cks node", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "785ac2cb56192163c01a30f2f55c10453a1d865c", "url": "https://github.com/apache/cloudstack/commit/785ac2cb56192163c01a30f2f55c10453a1d865c", "message": "Updating api param doc", "committedDate": "2021-02-03T13:26:14Z", "type": "commit"}, {"oid": "01142cde637d78ff4ba6e9941602aaa8cf8b27d6", "url": "https://github.com/apache/cloudstack/commit/01142cde637d78ff4ba6e9941602aaa8cf8b27d6", "message": "Refactoring tests", "committedDate": "2021-02-03T13:26:15Z", "type": "commit"}, {"oid": "9843efc44b1ef21f8480ee5674b3388fc311622d", "url": "https://github.com/apache/cloudstack/commit/9843efc44b1ef21f8480ee5674b3388fc311622d", "message": "fix port number passed on shared n/ws + optimize disk size", "committedDate": "2021-02-03T13:26:15Z", "type": "commit"}, {"oid": "4a1cc89b426184166a996f162eb042192c10eea3", "url": "https://github.com/apache/cloudstack/commit/4a1cc89b426184166a996f162eb042192c10eea3", "message": "Adding kubernetes as a dependency for marvin", "committedDate": "2021-02-03T13:26:15Z", "type": "commit"}, {"oid": "144114ee67e18790977bcd3c45a6d7d143e949d9", "url": "https://github.com/apache/cloudstack/commit/144114ee67e18790977bcd3c45a6d7d143e949d9", "message": "Port UI changes", "committedDate": "2021-02-04T12:39:26Z", "type": "forcePushed"}, {"oid": "06f629967e2dd5cbfcc3fedb9d09ed3cda1f38e3", "url": "https://github.com/apache/cloudstack/commit/06f629967e2dd5cbfcc3fedb9d09ed3cda1f38e3", "message": "Port UI changes", "committedDate": "2021-02-04T12:54:36Z", "type": "commit"}]}