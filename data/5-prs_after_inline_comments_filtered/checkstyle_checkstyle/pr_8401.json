{"pr_number": 8401, "pr_title": "Issue #7290: Add support for enhanced instanceof", "pr_createdAt": "2020-07-06T00:49:04Z", "pr_url": "https://github.com/checkstyle/checkstyle/pull/8401", "timeline": [{"oid": "9635860cd2edd8e45eef73d16e8549af66fc5daa", "url": "https://github.com/checkstyle/checkstyle/commit/9635860cd2edd8e45eef73d16e8549af66fc5daa", "message": "Issue #7290: Add support for enhanced instanceof", "committedDate": "2020-07-06T02:31:49Z", "type": "forcePushed"}, {"oid": "8b0a24c5349bfe72716dba3dbfcb289985aa9b0d", "url": "https://github.com/checkstyle/checkstyle/commit/8b0a24c5349bfe72716dba3dbfcb289985aa9b0d", "message": "Issue #7290: Add support for enhanced instanceof", "committedDate": "2020-07-06T23:04:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMjE1OA==", "url": "https://github.com/checkstyle/checkstyle/pull/8401#discussion_r450832158", "bodyText": "I do not understand why PATTERN appear under IDENT, it should be sibling.\n$ cat Test.java \npublic class Test {\n void foo() {\n  String s = \"\";\n  boolean b = s instanceof String;\n }\n}\n\n$ java $RUN_LOCALE -jar /var/tmp/checkstyle-8.33-all.jar -t Test.java | grep -C 3 instanceof | sed \"s/    |       |   //\"\n|--IDENT -> b [4:10]\n`--ASSIGN -> = [4:12]\n    `--EXPR -> EXPR [4:16]\n        `--LITERAL_INSTANCEOF -> instanceof [4:16]\n            |--IDENT -> s [4:14]\n            `--TYPE -> TYPE [4:27]\n                `--IDENT -> String [4:27]\n\neven in txt inputs you have them as sibling.", "author": "romani", "createdAt": "2020-07-07T12:39:30Z", "path": "src/main/java/com/puppycrawl/tools/checkstyle/api/TokenTypes.java", "diffHunk": "@@ -3540,6 +3540,34 @@\n     public static final int COMMENT_CONTENT =\n             GeneratedJavaTokenTypes.COMMENT_CONTENT;\n \n+    /**\n+     * A pattern variable definition; when conditionally matched,\n+     * this variable is assigned with the defined type.\n+     *\n+     * <p>For example:</p>\n+     * <pre>\n+     * if (obj instanceof String str) { }\n+     * </pre>\n+     * <p>parses as:</p>\n+     * <pre>\n+     * LITERAL_IF (if)\n+     *  |--LPAREN (()\n+     *  |--EXPR\n+     *  |   `--LITERAL_INSTANCEOF (instanceof)\n+     *  |       `--IDENT (obj)\n+     *  |           `--PATTERN_VARIABLE_DEF", "originalCommit": "8b0a24c5349bfe72716dba3dbfcb289985aa9b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ab164222dfa78dcda338650aae67cd4b1f0243df", "url": "https://github.com/checkstyle/checkstyle/commit/ab164222dfa78dcda338650aae67cd4b1f0243df", "message": "Issue #7290: Add support for enhanced instanceof", "committedDate": "2020-07-07T12:48:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3NzYzOA==", "url": "https://github.com/checkstyle/checkstyle/pull/8401#discussion_r450877638", "bodyText": "This import is not used. What is it for?", "author": "pbludov", "createdAt": "2020-07-07T13:48:07Z", "path": "src/test/resources-noncompilable/com/puppycrawl/tools/checkstyle/grammar/java14/InputJava14InstanceofWithPatternMatching.java", "diffHunk": "@@ -1,9 +1,13 @@\n //non-compiled with javac: Compilable with Java14\n package com.puppycrawl.tools.checkstyle.grammar.java14;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Locale;\n \n+import org.w3c.dom.ls.LSOutput;", "originalCommit": "ab164222dfa78dcda338650aae67cd4b1f0243df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3OTQ4Mg==", "url": "https://github.com/checkstyle/checkstyle/pull/8401#discussion_r450879482", "bodyText": "java.util.List is also not used.", "author": "pbludov", "createdAt": "2020-07-07T13:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3NzYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3Mzk1Mg==", "url": "https://github.com/checkstyle/checkstyle/pull/8401#discussion_r450973952", "bodyText": "Fixed.", "author": "nmancus1", "createdAt": "2020-07-07T15:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3NzYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4MTEwMg==", "url": "https://github.com/checkstyle/checkstyle/pull/8401#discussion_r450881102", "bodyText": "Please add a code snippet with the full class name, something like\nif (o instanceof org.example.Foo foo)", "author": "pbludov", "createdAt": "2020-07-07T13:52:44Z", "path": "src/test/resources-noncompilable/com/puppycrawl/tools/checkstyle/grammar/java14/InputJava14InstanceofWithPatternMatching.java", "diffHunk": "@@ -59,18 +63,154 @@ public void setModel(String model) {\n         }\n \n         String[] someString1 = {\"some string\"};\n-        if(someString1 instanceof Object  []) {\n+        if (someString1 instanceof Object[]) {\n             System.out.println(Arrays.toString(someString1));\n         }\n \n         String[][] someString2 = new String[2][3];\n-        if(someString2 instanceof Object[]  []) {\n+        if (someString2 instanceof Object[][]) {\n             System.out.println(Arrays.toString(someString2));\n         }\n \n         String[][][] someString3 = new String[3][4][5];\n-        if(someString3 instanceof Object[][]) {\n+        if (someString3 instanceof Object[][]) {\n             System.out.println(Arrays.toString(someString3));\n         }\n     }\n+\n+    interface VoidPredicate {\n+        public boolean get();\n+    }\n+\n+    public void t(Object o1, Object o2) {\n+        Object b;\n+        Object c;\n+        if (!(o1 instanceof String s) && (o2 instanceof String s)) {} //ok\n+        if (o1 instanceof String s || !(o2 instanceof String s)) {} //ok\n+        b = ((VoidPredicate) () -> o1 instanceof String s).get();\n+\n+        ArrayList<Integer> arrayList = new ArrayList<Integer>();\n+        if (arrayList instanceof ArrayList<Integer> ai) {\n+            System.out.println(\"Blah\");\n+        }\n+\n+        if (!(o1 instanceof String k)) {\n+            return ;\n+        }\n+\n+        if (o1 instanceof String s2) {}\n+\n+\n+        if (!(o1 instanceof String s4)) {\n+            return ;\n+        }\n+\n+        boolean result = (o1 instanceof String a1) ?\n+                (o1 instanceof String a2) : (!(o1 instanceof String a3));\n+\n+        if (!(o1 instanceof String s) ? false : s.length()>0){\n+            System.out.println(\"done\");\n+        }\n+\n+        if ((o1 instanceof String s) ? s.length()>0 : false){\n+            System.out.println(\"done\");\n+        }\n+\n+        if (!(o1 instanceof String s) || !(o2 instanceof Integer i)){\n+        } else {\n+            s.length();\n+            i.intValue();\n+        }\n+\n+        if (!(o1 instanceof String s) || !(o2 instanceof Integer i)){\n+        } else {\n+            s.length();\n+            i.intValue();\n+        }\n+\n+        if (o1 instanceof String s && o2 instanceof Integer in) {\n+            s.length();\n+            in.intValue();\n+        }\n+\n+        L1: {\n+            if (o1 instanceof String s) {\n+                s.length();\n+            } else {\n+                break L1;\n+            }\n+            s.length();\n+        }\n+\n+        {\n+            L2: for ( ;!(o1 instanceof String s); ) {\n+\n+            }\n+\n+            s.length();\n+        }\n+\n+        {\n+            while (!(o1 instanceof String s)) {\n+                L3: break L3;\n+            }\n+\n+            while(o1 instanceof String str) {\n+                str.length();\n+            }\n+        }\n+\n+        if (!new VoidPredicate() { public boolean get() { return o1 instanceof String str\n+                && !str.isEmpty();} }.get()) {\n+            throw new AssertionError();\n+        }\n+\n+        if (!((VoidPredicate) () -> o1 instanceof String str && !str.isEmpty()).get()) {\n+            throw new AssertionError();\n+        }\n+\n+        if (o1 instanceof String j && j.length() == 5 && o2 instanceof Integer z && z == 42) {\n+            System.out.println(j);\n+            System.out.println(z);\n+        } else {\n+        }\n+\n+        int x = o1 instanceof String j ? j.length() : 2;\n+\n+        x = !(o1 instanceof String j) ? 2 : j.length();\n+\n+        Object ch = null;\n+\n+        for (; o1 instanceof String j; j.length()) {\n+            System.out.println(j);\n+        }\n+\n+        String formatted;\n+        if (o1 instanceof Integer i) formatted = String.format(\"int %d\", i);\n+        else if (o1 instanceof Byte by) formatted = String.format(\"byte %d\", by);\n+        else if (o1 instanceof Long l) formatted = String.format(\"long %d\", l);\n+        else if (o1 instanceof Double d) formatted = String.format(\"double %f\", d);\n+        else if (o1 instanceof String s) formatted = String.format(\"String %s\", s);\n+        else formatted = String.format(\"Something else \"+ o1.toString());\n+\n+        do {\n+            L4: break L4;\n+        } while (!(o1 instanceof String s));\n+    }", "originalCommit": "ab164222dfa78dcda338650aae67cd4b1f0243df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3Mzg5NQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8401#discussion_r450973895", "bodyText": "Fixed.", "author": "nmancus1", "createdAt": "2020-07-07T15:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg4MTEwMg=="}], "type": "inlineReview"}, {"oid": "893bcc865eda349955bdc1771b98e90e7beb1072", "url": "https://github.com/checkstyle/checkstyle/commit/893bcc865eda349955bdc1771b98e90e7beb1072", "message": "Issue #7290: Add support for enhanced instanceof", "committedDate": "2020-07-07T15:54:52Z", "type": "commit"}, {"oid": "893bcc865eda349955bdc1771b98e90e7beb1072", "url": "https://github.com/checkstyle/checkstyle/commit/893bcc865eda349955bdc1771b98e90e7beb1072", "message": "Issue #7290: Add support for enhanced instanceof", "committedDate": "2020-07-07T15:54:52Z", "type": "forcePushed"}]}