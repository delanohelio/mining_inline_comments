{"pr_number": 8743, "pr_title": "Issue #8742: Metadata-gen code migration", "pr_createdAt": "2020-08-21T10:37:28Z", "pr_url": "https://github.com/checkstyle/checkstyle/pull/8743", "timeline": [{"oid": "9e6432be6d93f8707d2a33d16602e26794ffdc7e", "url": "https://github.com/checkstyle/checkstyle/commit/9e6432be6d93f8707d2a33d16602e26794ffdc7e", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-21T11:10:39Z", "type": "forcePushed"}, {"oid": "b6a15f2671945c9db4b43b6ffa431d438421b934", "url": "https://github.com/checkstyle/checkstyle/commit/b6a15f2671945c9db4b43b6ffa431d438421b934", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-21T12:44:52Z", "type": "forcePushed"}, {"oid": "0285625e8219ba9045ae9fc3f2c42f471a46e677", "url": "https://github.com/checkstyle/checkstyle/commit/0285625e8219ba9045ae9fc3f2c42f471a46e677", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-21T13:10:51Z", "type": "forcePushed"}, {"oid": "3b12186422d5a010432b92d0509e09cfd1ee7bf1", "url": "https://github.com/checkstyle/checkstyle/commit/3b12186422d5a010432b92d0509e09cfd1ee7bf1", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-21T22:59:29Z", "type": "forcePushed"}, {"oid": "0cf70094b000cb300ef482609c6827fc7b924638", "url": "https://github.com/checkstyle/checkstyle/commit/0cf70094b000cb300ef482609c6827fc7b924638", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-22T13:10:03Z", "type": "forcePushed"}, {"oid": "6d65455ccf8b1e5760247d86c5d5416baf9211b0", "url": "https://github.com/checkstyle/checkstyle/commit/6d65455ccf8b1e5760247d86c5d5416baf9211b0", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-22T20:53:16Z", "type": "forcePushed"}, {"oid": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "url": "https://github.com/checkstyle/checkstyle/commit/b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-23T00:45:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1NDI4OQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475154289", "bodyText": "please make list of strings that will contain internal modules, please place this module in that new list", "author": "romani", "createdAt": "2020-08-23T00:53:28Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/PackageObjectFactoryTest.java", "diffHunk": "@@ -343,7 +343,11 @@ public void testNameToFullModuleNameMap() throws Exception {\n         final Collection<String> canonicalNames = ((Map<String, String>) field.get(null)).values();\n \n         final Optional<Class<?>> optional1 = classes.stream()\n-                .filter(clazz -> !canonicalNames.contains(clazz.getCanonicalName())).findFirst();\n+                .filter(clazz -> {\n+                    return !canonicalNames.contains(clazz.getCanonicalName())\n+                            && !\"com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper\"", "originalCommit": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4ODQ4Mg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475688482", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1NDI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1NDMwMw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475154303", "bodyText": "please make list of strings that will contain internal modules, please place this module in that new list", "author": "romani", "createdAt": "2020-08-23T00:53:49Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/internal/AllChecksTest.java", "diffHunk": "@@ -357,6 +357,8 @@ public void testAllModulesAreReferencedInConfigFile() throws Exception {\n         final Set<String> modulesReferencedInConfig = CheckUtil.getConfigCheckStyleModules();\n         final Set<String> moduleNames = CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules());\n \n+        // JavadocMetadataScraper shouldn't be checked.\n+        moduleNames.remove(\"JavadocMetadataScraper\");", "originalCommit": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4ODUyNg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475688526", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1NDMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1NDQwNw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475154407", "bodyText": "please make list of strings that will contain internal modules, please place this module in that new list", "author": "romani", "createdAt": "2020-08-23T00:55:05Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XpathRegressionTest.java", "diffHunk": "@@ -70,6 +70,7 @@\n             Collections.unmodifiableSet(new HashSet<>(Arrays.asList(\n                     \"AtclauseOrder\",\n                     \"JavadocBlockTagLocation\",\n+                    \"JavadocMetadataScraper\",", "originalCommit": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4ODU5OA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475688598", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1NDQwNw=="}], "type": "inlineReview"}, {"oid": "f111c4f650af9e6fb72601444c880a3d92a80b39", "url": "https://github.com/checkstyle/checkstyle/commit/f111c4f650af9e6fb72601444c880a3d92a80b39", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-23T21:53:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MjA4MA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475272080", "bodyText": "please wrap exception to runtime exception and rethrow it.\ncatch (ParserConfigurationException | IOException | SAXException ex) {\n   new IllegalStateException(\"Problem to read all modules including third party if any\", ex)", "author": "romani", "createdAt": "2020-08-23T21:57:12Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaReader.java", "diffHunk": "@@ -0,0 +1,178 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+import org.reflections.Reflections;\n+import org.reflections.scanners.ResourcesScanner;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+public final class XmlMetaReader {\n+    public List<ModuleDetails> readAllModulesIncludingThirdPartyIfAny(\n+            String... thirdPartyPackages) {\n+        final Set<String> standardModuleFileNames =\n+                new Reflections(\"com.puppycrawl.tools.checkstyle.meta\",\n+                        new ResourcesScanner()).getResources(Pattern.compile(\".*\\\\.xml\"));\n+        final Set<String> allMetadataSources = new HashSet<>(standardModuleFileNames);\n+        for (String packageName : thirdPartyPackages) {\n+            final Set<String> thirdPartyModuleFileNames =\n+                    new Reflections(packageName, new ResourcesScanner())\n+                            .getResources(Pattern.compile(\".*checkstylemeta-.*\\\\.xml\"));\n+            allMetadataSources.addAll(thirdPartyModuleFileNames);\n+        }\n+\n+        final List<ModuleDetails> result = new ArrayList<>();\n+        allMetadataSources.forEach(fileName -> {\n+            final ModuleType moduleType;\n+            if (fileName.endsWith(\"FileFilter.xml\")) {\n+                moduleType = ModuleType.FILEFILTER;\n+            }\n+            else if (fileName.endsWith(\"Filter.xml\")) {\n+                moduleType = ModuleType.FILTER;\n+            }\n+            else {\n+                moduleType = ModuleType.CHECK;\n+            }\n+            ModuleDetails moduleDetails = null;\n+            try {\n+                moduleDetails = read(getClass().getResourceAsStream(\"/\" + fileName),\n+                        moduleType);\n+            }\n+            catch (ParserConfigurationException | IOException | SAXException ex) {\n+                ex.printStackTrace();", "originalCommit": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NDk2Mg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475694962", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MjA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MjM1NA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475272354", "bodyText": "log to\nplease rephase comment, you do not any logging in this block.", "author": "romani", "createdAt": "2020-08-23T22:00:08Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java", "diffHunk": "@@ -0,0 +1,159 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.io.File;\n+import java.util.Locale;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+\n+public final class XmlMetaWriter {\n+    private static final Pattern FILEPATH_CONVERSION = Pattern.compile(\"\\\\.\");\n+\n+    public void write(ModuleDetails moduleDetails) throws TransformerException,\n+            ParserConfigurationException {\n+        final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+        final Document doc = dBuilder.newDocument();\n+\n+        final Element rootElement = doc.createElement(\"checkstyle-metadata\");\n+        final Element rootChild = doc.createElement(\"module\");\n+        rootElement.appendChild(rootChild);\n+\n+        doc.appendChild(rootElement);\n+\n+        Element checkModule = null;\n+        final ModuleType moduleType = moduleDetails.getModuleType();\n+        if (moduleType == ModuleType.CHECK) {\n+            checkModule = doc.createElement(\"check\");\n+        }\n+        else if (moduleType == ModuleType.FILTER) {\n+            checkModule = doc.createElement(\"filter\");\n+        }\n+        else if (moduleType == ModuleType.FILEFILTER) {\n+            checkModule = doc.createElement(\"file-filter\");\n+        }\n+        rootChild.appendChild(checkModule);\n+\n+        checkModule.setAttribute(\"name\", moduleDetails.getName());\n+        checkModule.setAttribute(\"fully-qualified-name\",\n+                moduleDetails.getFullQualifiedName());\n+        checkModule.setAttribute(\"parent\", moduleDetails.getParent());\n+\n+        final Element desc = doc.createElement(\"description\");\n+        final Node cdataDesc = doc.createCDATASection(moduleDetails.getDescription());\n+        desc.appendChild(cdataDesc);\n+        checkModule.appendChild(desc);\n+        createPropertySection(moduleDetails, checkModule, doc);\n+        if (!moduleDetails.getViolationMessageKeys().isEmpty()) {\n+            final Element messageKeys = doc.createElement(\"message-keys\");\n+            for (String msg : moduleDetails.getViolationMessageKeys()) {\n+                final Element messageKey = doc.createElement(\"message-key\");\n+                messageKey.setAttribute(\"key\", msg);\n+                messageKeys.appendChild(messageKey);\n+            }\n+            checkModule.appendChild(messageKeys);\n+        }\n+\n+        writeToFile(doc, moduleDetails);\n+    }\n+\n+    private static void createPropertySection(ModuleDetails moduleDetails, Element checkModule,\n+                                              Document doc) {\n+        if (!moduleDetails.getProperties().isEmpty()) {\n+            final Element properties = doc.createElement(\"properties\");\n+            checkModule.appendChild(properties);\n+            for (ModulePropertyDetails modulePropertyDetails : moduleDetails.getProperties()) {\n+                final Element property = doc.createElement(\"property\");\n+                properties.appendChild(property);\n+                property.setAttribute(\"name\", modulePropertyDetails.getName());\n+                property.setAttribute(\"type\", modulePropertyDetails.getType());\n+                if (modulePropertyDetails.getDefaultValue() != null) {\n+                    property.setAttribute(\"default-value\",\n+                            modulePropertyDetails.getDefaultValue());\n+                }\n+                if (modulePropertyDetails.getValidationType() != null) {\n+                    property.setAttribute(\"validation-type\",\n+                            modulePropertyDetails.getValidationType());\n+                }\n+                final Element propertyDesc = doc.createElement(\"description\");\n+                propertyDesc.appendChild(doc.createCDATASection(\n+                        modulePropertyDetails.getDescription()));\n+                property.appendChild(propertyDesc);\n+            }\n+        }\n+    }\n+\n+    private static void writeToFile(Document document, ModuleDetails moduleDetails)\n+            throws TransformerException {\n+        final String rootOutputPath = System.getProperty(\"user.dir\") + \"/src/main/resources\";\n+        String fileSeperator = System.getProperty(\"file.separator\");\n+        if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).contains(\"win\")) {\n+            fileSeperator = \"\\\\\" + fileSeperator;\n+        }\n+        final String moduleFilePath = FILEPATH_CONVERSION\n+                .matcher(moduleDetails.getFullQualifiedName())\n+                .replaceAll(fileSeperator);\n+        final String modifiedPath;\n+        if (moduleFilePath.contains(\"puppycrawl\")) {\n+            final int idxOfCheckstyle =\n+                    moduleFilePath.indexOf(\"checkstyle\") + \"checkstyle\".length();\n+            // make sure all folders are created\n+            modifiedPath = rootOutputPath + System.getProperty(\"file.separator\")\n+                    + moduleFilePath.substring(0, idxOfCheckstyle)\n+                    + System.getProperty(\"file.separator\") + \"meta\"\n+                    + System.getProperty(\"file.separator\")\n+                    + moduleFilePath.substring(idxOfCheckstyle + 1) + \".xml\";\n+        }\n+        else {\n+            String moduleName = moduleDetails.getName();\n+            if (moduleDetails.getModuleType() == ModuleType.CHECK) {\n+                moduleName += \"Check\";\n+            }\n+            modifiedPath = rootOutputPath + System.getProperty(\"file.separator\") + \"checkstylemeta-\"\n+                    + moduleName + \".xml\";\n+        }\n+        if (!moduleDetails.getDescription().isEmpty()) {\n+            // log to ensure folders exist", "originalCommit": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NTEzNA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475695134", "bodyText": "I have removed, since its solved.", "author": "gaurabdg", "createdAt": "2020-08-24T15:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MjM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MjQ0Ng==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475272446", "bodyText": "please recheck full name of package ... com. .....", "author": "romani", "createdAt": "2020-08-23T22:01:01Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java", "diffHunk": "@@ -0,0 +1,159 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.io.File;\n+import java.util.Locale;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+\n+public final class XmlMetaWriter {\n+    private static final Pattern FILEPATH_CONVERSION = Pattern.compile(\"\\\\.\");\n+\n+    public void write(ModuleDetails moduleDetails) throws TransformerException,\n+            ParserConfigurationException {\n+        final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+        final Document doc = dBuilder.newDocument();\n+\n+        final Element rootElement = doc.createElement(\"checkstyle-metadata\");\n+        final Element rootChild = doc.createElement(\"module\");\n+        rootElement.appendChild(rootChild);\n+\n+        doc.appendChild(rootElement);\n+\n+        Element checkModule = null;\n+        final ModuleType moduleType = moduleDetails.getModuleType();\n+        if (moduleType == ModuleType.CHECK) {\n+            checkModule = doc.createElement(\"check\");\n+        }\n+        else if (moduleType == ModuleType.FILTER) {\n+            checkModule = doc.createElement(\"filter\");\n+        }\n+        else if (moduleType == ModuleType.FILEFILTER) {\n+            checkModule = doc.createElement(\"file-filter\");\n+        }\n+        rootChild.appendChild(checkModule);\n+\n+        checkModule.setAttribute(\"name\", moduleDetails.getName());\n+        checkModule.setAttribute(\"fully-qualified-name\",\n+                moduleDetails.getFullQualifiedName());\n+        checkModule.setAttribute(\"parent\", moduleDetails.getParent());\n+\n+        final Element desc = doc.createElement(\"description\");\n+        final Node cdataDesc = doc.createCDATASection(moduleDetails.getDescription());\n+        desc.appendChild(cdataDesc);\n+        checkModule.appendChild(desc);\n+        createPropertySection(moduleDetails, checkModule, doc);\n+        if (!moduleDetails.getViolationMessageKeys().isEmpty()) {\n+            final Element messageKeys = doc.createElement(\"message-keys\");\n+            for (String msg : moduleDetails.getViolationMessageKeys()) {\n+                final Element messageKey = doc.createElement(\"message-key\");\n+                messageKey.setAttribute(\"key\", msg);\n+                messageKeys.appendChild(messageKey);\n+            }\n+            checkModule.appendChild(messageKeys);\n+        }\n+\n+        writeToFile(doc, moduleDetails);\n+    }\n+\n+    private static void createPropertySection(ModuleDetails moduleDetails, Element checkModule,\n+                                              Document doc) {\n+        if (!moduleDetails.getProperties().isEmpty()) {\n+            final Element properties = doc.createElement(\"properties\");\n+            checkModule.appendChild(properties);\n+            for (ModulePropertyDetails modulePropertyDetails : moduleDetails.getProperties()) {\n+                final Element property = doc.createElement(\"property\");\n+                properties.appendChild(property);\n+                property.setAttribute(\"name\", modulePropertyDetails.getName());\n+                property.setAttribute(\"type\", modulePropertyDetails.getType());\n+                if (modulePropertyDetails.getDefaultValue() != null) {\n+                    property.setAttribute(\"default-value\",\n+                            modulePropertyDetails.getDefaultValue());\n+                }\n+                if (modulePropertyDetails.getValidationType() != null) {\n+                    property.setAttribute(\"validation-type\",\n+                            modulePropertyDetails.getValidationType());\n+                }\n+                final Element propertyDesc = doc.createElement(\"description\");\n+                propertyDesc.appendChild(doc.createCDATASection(\n+                        modulePropertyDetails.getDescription()));\n+                property.appendChild(propertyDesc);\n+            }\n+        }\n+    }\n+\n+    private static void writeToFile(Document document, ModuleDetails moduleDetails)\n+            throws TransformerException {\n+        final String rootOutputPath = System.getProperty(\"user.dir\") + \"/src/main/resources\";\n+        String fileSeperator = System.getProperty(\"file.separator\");\n+        if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).contains(\"win\")) {\n+            fileSeperator = \"\\\\\" + fileSeperator;\n+        }\n+        final String moduleFilePath = FILEPATH_CONVERSION\n+                .matcher(moduleDetails.getFullQualifiedName())\n+                .replaceAll(fileSeperator);\n+        final String modifiedPath;\n+        if (moduleFilePath.contains(\"puppycrawl\")) {", "originalCommit": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NTE5Mw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475695193", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3Mjc3Mg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475272772", "bodyText": "This property is java type that plugins can use to validate user input, it is used when 'type' field is \"String\".\nbe used for special cases such as regexp and tokenSet.", "author": "romani", "createdAt": "2020-08-23T22:04:42Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/ModulePropertyDetails.java", "diffHunk": "@@ -0,0 +1,69 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+public final class ModulePropertyDetails {\n+    private String name;\n+    private String type;\n+    private String defaultValue;\n+    /** This property is optional and will be used for special cases such as regexp and tokenSet. */", "originalCommit": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NTI0Nw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475695247", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3Mjc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3Mjg4OA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475272888", "bodyText": "please move collections after  simple fields.", "author": "romani", "createdAt": "2020-08-23T22:05:30Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/ModuleDetails.java", "diffHunk": "@@ -0,0 +1,109 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class ModuleDetails {\n+    private final List<ModulePropertyDetails> properties = new ArrayList<>();\n+    private final Map<String, ModulePropertyDetails> modulePropertyKeyMap = new HashMap<>();\n+    private final List<String> violationMessageKeys = new ArrayList<>();", "originalCommit": "b295c4c9ee8f3be670bb64a66847ee1471aec9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NTQzOA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475695438", "bodyText": "It will violate sevntu checks.", "author": "gaurabdg", "createdAt": "2020-08-24T15:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3Mjg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2NTEzNw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476165137", "bodyText": "please remove final from them", "author": "romani", "createdAt": "2020-08-25T04:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3Mjg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNjI0MA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476416240", "bodyText": "Then IDEA inspection will fail", "author": "gaurabdg", "createdAt": "2020-08-25T12:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3Mjg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MzIwNA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475273204", "bodyText": "please do assert on amount of files generated in result folder.\nno suppression will not be required.", "author": "romani", "createdAt": "2020-08-23T22:09:31Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public final class MetadataGeneratorTest {\n+    /**\n+     * Test contains assertions in the callstack, but TeamCity inspection does not see them.\n+     *\n+     * @noinspection JUnitTestMethodWithNoAssertions\n+     */\n+    @Test\n+    public void testBasic() throws Exception {\n+        MetadataGenerator.generate(System.getProperty(\"user.dir\")\n+                + \"/src/main/java/com/puppycrawl/tools/checkstyle\");", "originalCommit": "f111c4f650af9e6fb72601444c880a3d92a80b39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NTUyOQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475695529", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MzIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MzUwOA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475273508", "bodyText": "fix indentation.", "author": "romani", "createdAt": "2020-08-23T22:12:31Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "diffHunk": "@@ -236,6 +236,8 @@ public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n         final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n \n         CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n+                .stream()\n+            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))", "originalCommit": "f111c4f650af9e6fb72601444c880a3d92a80b39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NTYxNQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475695615", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MzUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MzY3Mw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475273673", "bodyText": "wrap exception in runtime exception and rethrow it.", "author": "romani", "createdAt": "2020-08-23T22:14:43Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "diffHunk": "@@ -0,0 +1,571 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.TransformerException;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n+import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n+import com.puppycrawl.tools.checkstyle.api.DetailAST;\n+import com.puppycrawl.tools.checkstyle.api.DetailNode;\n+import com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\n+import com.puppycrawl.tools.checkstyle.api.TokenTypes;\n+import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n+import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n+\n+@FileStatefulCheck\n+public class JavadocMetadataScraper extends AbstractJavadocCheck {\n+    private static final Pattern PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n+    private static final Pattern TYPE_TAG = Pattern.compile(\"\\\\s.*Type is\\\\s.*\");\n+    private static final Pattern VALIDATION_TYPE_TAG =\n+            Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n+    private static final Pattern DEFAULT_VALUE_TAG = Pattern.compile(\"\\\\s*Default value is:*.*\");\n+    private static final Pattern EXAMPLES_TAG =\n+            Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n+    private static final Pattern PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n+    private static final Pattern VIOLATION_MESSAGES_TAG =\n+            Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n+    private static final Pattern TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z]+_*)+[A-Z]+\");\n+    private static final Pattern DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n+    private static final Pattern FILE_SEPARATOR_PATTERN =\n+            Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n+    private static final Pattern QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n+\n+    private Log log;\n+    private ModuleDetails moduleDetails;\n+    private ScrapeStatus currentStatus;\n+    private boolean toScan;\n+    private String descriptionText;\n+    private DetailNode rootNode;\n+    private int propertySectionStartIdx;\n+    private int exampleSectionStartIdx;\n+    private int parentSectionStartIdx;\n+\n+    @Override\n+    public int[] getDefaultJavadocTokens() {\n+        return new int[] {\n+            JavadocTokenTypes.JAVADOC,\n+            JavadocTokenTypes.PARAGRAPH,\n+            JavadocTokenTypes.LI,\n+            JavadocTokenTypes.SINCE_LITERAL,\n+        };\n+    }\n+\n+    @Override\n+    public int[] getRequiredJavadocTokens() {\n+        return getAcceptableJavadocTokens();\n+    }\n+\n+    @Override\n+    public void beginJavadocTree(DetailNode rootAst) {\n+        log = LogFactory.getLog(JavadocMetadataScraper.class);\n+        if (isTopLevelClassJavadoc()) {\n+            moduleDetails = new ModuleDetails();\n+            currentStatus = ScrapeStatus.DESCRIPTION;\n+            toScan = false;\n+            descriptionText = \"\";\n+            propertySectionStartIdx = -1;\n+            exampleSectionStartIdx = -1;\n+            parentSectionStartIdx = -1;\n+\n+            final String filePath = getFileContents().getFileName();\n+            String moduleName = getModuleSimpleName();\n+            if (moduleName.contains(\"Check\")) {\n+                moduleName = moduleName.substring(0, moduleName.indexOf(\"Check\"));\n+            }\n+            moduleDetails.setName(moduleName);\n+            moduleDetails.setFullQualifiedName(getPackageName(filePath));\n+            moduleDetails.setModuleType(getModuleType());\n+        }\n+    }\n+\n+    @Override\n+    public void visitJavadocToken(DetailNode ast) {\n+        if (toScan) {\n+            scrapeContent(ast);\n+        }\n+\n+        if (ast.getType() == JavadocTokenTypes.JAVADOC\n+            && getParent(getBlockCommentAst()).getType() == TokenTypes.CLASS_DEF) {\n+            rootNode = ast;\n+            toScan = true;\n+        }\n+        else if (ast.getType() == JavadocTokenTypes.SINCE_LITERAL) {\n+            toScan = false;\n+        }\n+    }\n+\n+    @Override\n+    public void finishJavadocTree(DetailNode rootAst) {\n+        moduleDetails.setDescription(getDescriptionText());\n+        if (isTopLevelClassJavadoc()) {\n+            try {\n+                new XmlMetaWriter().write(moduleDetails);\n+            }\n+            catch (TransformerException | ParserConfigurationException ex) {\n+                log.debug(\"Exception occured while writing metadata of\"\n+                                + getModuleSimpleName() + \" into XML files: \", ex);", "originalCommit": "f111c4f650af9e6fb72601444c880a3d92a80b39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU0NDQ0MA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475544440", "bodyText": "Errors:\n\n'throw' inside 'catch' block ignores the caught exception\nProhibited exception 'RuntimeException' thrown", "author": "gaurabdg", "createdAt": "2020-08-24T11:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MzY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU1MDg4Nw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475550887", "bodyText": "@gaurabdg\n\nYou can set caught exception as cause in new exception constructor, it is should eliminate error\nPlease choose some other runtime exception or create one.", "author": "strkkk", "createdAt": "2020-08-24T12:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MzY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcxMTcyOQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r475711729", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-24T15:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI3MzY3Mw=="}], "type": "inlineReview"}, {"oid": "22f809cea49f41628308b4d8d878b5d2e2d24358", "url": "https://github.com/checkstyle/checkstyle/commit/22f809cea49f41628308b4d8d878b5d2e2d24358", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-24T08:09:21Z", "type": "forcePushed"}, {"oid": "a0d51e8b93a190f95dbf42fef443960c4783fefb", "url": "https://github.com/checkstyle/checkstyle/commit/a0d51e8b93a190f95dbf42fef443960c4783fefb", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-24T14:56:21Z", "type": "forcePushed"}, {"oid": "393e4d5886af3f023acaf51892492238bb66187d", "url": "https://github.com/checkstyle/checkstyle/commit/393e4d5886af3f023acaf51892492238bb66187d", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-24T15:28:36Z", "type": "forcePushed"}, {"oid": "b332d3cae0e762838dae897a07aab3d6d74e12b1", "url": "https://github.com/checkstyle/checkstyle/commit/b332d3cae0e762838dae897a07aab3d6d74e12b1", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-24T15:44:06Z", "type": "forcePushed"}, {"oid": "44ba27af77bb7f2f3ee956852f3c4786790faed7", "url": "https://github.com/checkstyle/checkstyle/commit/44ba27af77bb7f2f3ee956852f3c4786790faed7", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-24T21:54:35Z", "type": "forcePushed"}, {"oid": "44ba27af77bb7f2f3ee956852f3c4786790faed7", "url": "https://github.com/checkstyle/checkstyle/commit/44ba27af77bb7f2f3ee956852f3c4786790faed7", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-24T21:54:35Z", "type": "forcePushed"}, {"oid": "05f47af89190a044b93855e9bd485dd9d2abe965", "url": "https://github.com/checkstyle/checkstyle/commit/05f47af89190a044b93855e9bd485dd9d2abe965", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-25T04:34:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2Mzk0Nw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476163947", "bodyText": "startWith", "author": "romani", "createdAt": "2020-08-25T04:38:55Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.io.File;\n+import java.util.Locale;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+\n+public final class XmlMetaWriter {\n+    private static final Pattern FILEPATH_CONVERSION = Pattern.compile(\"\\\\.\");\n+\n+    public void write(ModuleDetails moduleDetails) throws TransformerException,\n+            ParserConfigurationException {\n+        final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+        final Document doc = dBuilder.newDocument();\n+\n+        final Element rootElement = doc.createElement(\"checkstyle-metadata\");\n+        final Element rootChild = doc.createElement(\"module\");\n+        rootElement.appendChild(rootChild);\n+\n+        doc.appendChild(rootElement);\n+\n+        Element checkModule = null;\n+        final ModuleType moduleType = moduleDetails.getModuleType();\n+        if (moduleType == ModuleType.CHECK) {\n+            checkModule = doc.createElement(\"check\");\n+        }\n+        else if (moduleType == ModuleType.FILTER) {\n+            checkModule = doc.createElement(\"filter\");\n+        }\n+        else if (moduleType == ModuleType.FILEFILTER) {\n+            checkModule = doc.createElement(\"file-filter\");\n+        }\n+        rootChild.appendChild(checkModule);\n+\n+        checkModule.setAttribute(\"name\", moduleDetails.getName());\n+        checkModule.setAttribute(\"fully-qualified-name\",\n+                moduleDetails.getFullQualifiedName());\n+        checkModule.setAttribute(\"parent\", moduleDetails.getParent());\n+\n+        final Element desc = doc.createElement(\"description\");\n+        final Node cdataDesc = doc.createCDATASection(moduleDetails.getDescription());\n+        desc.appendChild(cdataDesc);\n+        checkModule.appendChild(desc);\n+        createPropertySection(moduleDetails, checkModule, doc);\n+        if (!moduleDetails.getViolationMessageKeys().isEmpty()) {\n+            final Element messageKeys = doc.createElement(\"message-keys\");\n+            for (String msg : moduleDetails.getViolationMessageKeys()) {\n+                final Element messageKey = doc.createElement(\"message-key\");\n+                messageKey.setAttribute(\"key\", msg);\n+                messageKeys.appendChild(messageKey);\n+            }\n+            checkModule.appendChild(messageKeys);\n+        }\n+\n+        writeToFile(doc, moduleDetails);\n+    }\n+\n+    private static void createPropertySection(ModuleDetails moduleDetails, Element checkModule,\n+                                              Document doc) {\n+        if (!moduleDetails.getProperties().isEmpty()) {\n+            final Element properties = doc.createElement(\"properties\");\n+            checkModule.appendChild(properties);\n+            for (ModulePropertyDetails modulePropertyDetails : moduleDetails.getProperties()) {\n+                final Element property = doc.createElement(\"property\");\n+                properties.appendChild(property);\n+                property.setAttribute(\"name\", modulePropertyDetails.getName());\n+                property.setAttribute(\"type\", modulePropertyDetails.getType());\n+                if (modulePropertyDetails.getDefaultValue() != null) {\n+                    property.setAttribute(\"default-value\",\n+                            modulePropertyDetails.getDefaultValue());\n+                }\n+                if (modulePropertyDetails.getValidationType() != null) {\n+                    property.setAttribute(\"validation-type\",\n+                            modulePropertyDetails.getValidationType());\n+                }\n+                final Element propertyDesc = doc.createElement(\"description\");\n+                propertyDesc.appendChild(doc.createCDATASection(\n+                        modulePropertyDetails.getDescription()));\n+                property.appendChild(propertyDesc);\n+            }\n+        }\n+    }\n+\n+    private static void writeToFile(Document document, ModuleDetails moduleDetails)\n+            throws TransformerException {\n+        final String rootOutputPath = System.getProperty(\"user.dir\") + \"/src/main/resources\";\n+        String fileSeperator = \"/\";\n+        if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).contains(\"win\")) {\n+            fileSeperator = \"\\\\\" + fileSeperator;\n+        }\n+        final String modifiedPath;\n+        if (moduleDetails.getFullQualifiedName().contains(\"com.puppycrawl.tools.checkstyle\")) {", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNDM2Mg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476534362", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-25T15:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2Mzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2NDIyMw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476164223", "bodyText": "idxOfCheckstyle", "author": "romani", "createdAt": "2020-08-25T04:39:12Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.io.File;\n+import java.util.Locale;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+\n+public final class XmlMetaWriter {\n+    private static final Pattern FILEPATH_CONVERSION = Pattern.compile(\"\\\\.\");\n+\n+    public void write(ModuleDetails moduleDetails) throws TransformerException,\n+            ParserConfigurationException {\n+        final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+        final Document doc = dBuilder.newDocument();\n+\n+        final Element rootElement = doc.createElement(\"checkstyle-metadata\");\n+        final Element rootChild = doc.createElement(\"module\");\n+        rootElement.appendChild(rootChild);\n+\n+        doc.appendChild(rootElement);\n+\n+        Element checkModule = null;\n+        final ModuleType moduleType = moduleDetails.getModuleType();\n+        if (moduleType == ModuleType.CHECK) {\n+            checkModule = doc.createElement(\"check\");\n+        }\n+        else if (moduleType == ModuleType.FILTER) {\n+            checkModule = doc.createElement(\"filter\");\n+        }\n+        else if (moduleType == ModuleType.FILEFILTER) {\n+            checkModule = doc.createElement(\"file-filter\");\n+        }\n+        rootChild.appendChild(checkModule);\n+\n+        checkModule.setAttribute(\"name\", moduleDetails.getName());\n+        checkModule.setAttribute(\"fully-qualified-name\",\n+                moduleDetails.getFullQualifiedName());\n+        checkModule.setAttribute(\"parent\", moduleDetails.getParent());\n+\n+        final Element desc = doc.createElement(\"description\");\n+        final Node cdataDesc = doc.createCDATASection(moduleDetails.getDescription());\n+        desc.appendChild(cdataDesc);\n+        checkModule.appendChild(desc);\n+        createPropertySection(moduleDetails, checkModule, doc);\n+        if (!moduleDetails.getViolationMessageKeys().isEmpty()) {\n+            final Element messageKeys = doc.createElement(\"message-keys\");\n+            for (String msg : moduleDetails.getViolationMessageKeys()) {\n+                final Element messageKey = doc.createElement(\"message-key\");\n+                messageKey.setAttribute(\"key\", msg);\n+                messageKeys.appendChild(messageKey);\n+            }\n+            checkModule.appendChild(messageKeys);\n+        }\n+\n+        writeToFile(doc, moduleDetails);\n+    }\n+\n+    private static void createPropertySection(ModuleDetails moduleDetails, Element checkModule,\n+                                              Document doc) {\n+        if (!moduleDetails.getProperties().isEmpty()) {\n+            final Element properties = doc.createElement(\"properties\");\n+            checkModule.appendChild(properties);\n+            for (ModulePropertyDetails modulePropertyDetails : moduleDetails.getProperties()) {\n+                final Element property = doc.createElement(\"property\");\n+                properties.appendChild(property);\n+                property.setAttribute(\"name\", modulePropertyDetails.getName());\n+                property.setAttribute(\"type\", modulePropertyDetails.getType());\n+                if (modulePropertyDetails.getDefaultValue() != null) {\n+                    property.setAttribute(\"default-value\",\n+                            modulePropertyDetails.getDefaultValue());\n+                }\n+                if (modulePropertyDetails.getValidationType() != null) {\n+                    property.setAttribute(\"validation-type\",\n+                            modulePropertyDetails.getValidationType());\n+                }\n+                final Element propertyDesc = doc.createElement(\"description\");\n+                propertyDesc.appendChild(doc.createCDATASection(\n+                        modulePropertyDetails.getDescription()));\n+                property.appendChild(propertyDesc);\n+            }\n+        }\n+    }\n+\n+    private static void writeToFile(Document document, ModuleDetails moduleDetails)\n+            throws TransformerException {\n+        final String rootOutputPath = System.getProperty(\"user.dir\") + \"/src/main/resources\";\n+        String fileSeperator = \"/\";\n+        if (System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH).contains(\"win\")) {\n+            fileSeperator = \"\\\\\" + fileSeperator;\n+        }\n+        final String modifiedPath;\n+        if (moduleDetails.getFullQualifiedName().contains(\"com.puppycrawl.tools.checkstyle\")) {\n+            final String moduleFilePath = FILEPATH_CONVERSION\n+                    .matcher(moduleDetails.getFullQualifiedName())\n+                    .replaceAll(fileSeperator);\n+            final int idxOfCheckstyle =", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQxNjkyNg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476416926", "bodyText": "I am sorry I didnt understand, its already idxOfCheckstyle.", "author": "gaurabdg", "createdAt": "2020-08-25T12:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2NDIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzMjUwMg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476632502", "bodyText": "indexOfCheckstyle\nno shortages in names.", "author": "romani", "createdAt": "2020-08-25T17:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2NDIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3MzYxMw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476673613", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-25T19:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2NDIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI1NDAzMg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476254032", "bodyText": "Collections.unmodifiableSet(\n            new HashSet<>(Collections.singletonList(\n\nAll this can be changed to Collections.singletonSet()", "author": "strkkk", "createdAt": "2020-08-25T08:01:44Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/PackageObjectFactoryTest.java", "diffHunk": "@@ -59,6 +59,11 @@\n  */\n public class PackageObjectFactoryTest {\n \n+    private static final Set<String> INTERNAL_MODULES = Collections.unmodifiableSet(\n+            new HashSet<>(Collections.singletonList(\n+            \"com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper\"\n+    )));", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMjQ5NQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476422495", "bodyText": "Since I moved INTERNAL_MODULES to Definitions class, it needs unmodifiable object.", "author": "gaurabdg", "createdAt": "2020-08-25T12:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI1NDAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI1NDMwOQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476254309", "bodyText": "same here", "author": "strkkk", "createdAt": "2020-08-25T08:02:14Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/internal/AllChecksTest.java", "diffHunk": "@@ -63,6 +64,11 @@\n \n public class AllChecksTest extends AbstractModuleTestSupport {\n \n+    private static final Set<String> INTERNAL_MODULES = Collections.unmodifiableSet(\n+            new HashSet<>(Collections.singletonList(", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMjYyNQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476422625", "bodyText": "Since I moved INTERNAL_MODULES to Definitions class, it needs unmodifiable object.", "author": "gaurabdg", "createdAt": "2020-08-25T12:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI1NDMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI1NDg0OA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476254848", "bodyText": "same here\nBy the way, this is duplicated several times, may be extract this list to some common class?", "author": "strkkk", "createdAt": "2020-08-25T08:03:13Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XpathRegressionTest.java", "diffHunk": "@@ -160,6 +160,11 @@\n             \"SuppressWarningsHolder\"\n     ));\n \n+    private static final Set<String> INTERNAL_MODULES = Collections.unmodifiableSet(\n+            new HashSet<>(Collections.singletonList(", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMjgxOQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476422819", "bodyText": "Done, moved to Definitions.\nSince I moved INTERNAL_MODULES to Definitions class, it needs unmodifiable object.", "author": "gaurabdg", "createdAt": "2020-08-25T12:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI1NDg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI1NzgxNg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476257816", "bodyText": "Arrays.asList(\"Checker\", \"TreeWalker\", JavadocMetadataScraper\")\nthis list can be extracted as field", "author": "strkkk", "createdAt": "2020-08-25T08:06:24Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorTest.java", "diffHunk": "@@ -0,0 +1,73 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\n+\n+public final class MetadataGeneratorTest {\n+    @Test\n+    public void testBasic() throws Exception {\n+        MetadataGenerator.generate(System.getProperty(\"user.dir\")\n+                + \"/src/main/java/com/puppycrawl/tools/checkstyle\");\n+        final Set<String> metaFiles;\n+\n+        try (Stream<Path> fileStream = Files.walk(\n+                Paths.get(System.getProperty(\"user.dir\") + \"/src/main/resources/com/puppycrawl\"\n+                        + \"/tools/checkstyle/meta\"))) {\n+            metaFiles = fileStream\n+                    .filter(Files::isRegularFile)\n+                    .map(file -> {\n+                        final String fileName = file.getFileName().toString();\n+                        final int lengthToOmit;\n+                        if (fileName.contains(\"Check\")) {\n+                            lengthToOmit = \"Check.xml\".length();\n+                        }\n+                        else {\n+                            lengthToOmit = \".xml\".length();\n+                        }\n+                        return fileName.substring(0, fileName.length() - lengthToOmit);\n+                    })\n+                    .sorted()\n+                    .collect(Collectors.toCollection(LinkedHashSet::new));\n+        }\n+        final Set<String> checkstyleModules =\n+                CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n+                .stream()\n+                .sorted()\n+                .collect(Collectors.toCollection(LinkedHashSet::new));\n+        checkstyleModules.removeAll(Arrays.asList(\"Checker\", \"TreeWalker\",\n+                \"JavadocMetadataScraper\"));", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNDY3OA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476534678", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-25T15:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI1NzgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2MDMxMQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476260311", "bodyText": "instead of repeating if blocks, you can add field in enum and make it like doc.createElement(moduleType.getElementName());", "author": "strkkk", "createdAt": "2020-08-25T08:10:35Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java", "diffHunk": "@@ -0,0 +1,154 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.io.File;\n+import java.util.Locale;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+\n+public final class XmlMetaWriter {\n+    private static final Pattern FILEPATH_CONVERSION = Pattern.compile(\"\\\\.\");\n+\n+    public void write(ModuleDetails moduleDetails) throws TransformerException,\n+            ParserConfigurationException {\n+        final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n+        final Document doc = dBuilder.newDocument();\n+\n+        final Element rootElement = doc.createElement(\"checkstyle-metadata\");\n+        final Element rootChild = doc.createElement(\"module\");\n+        rootElement.appendChild(rootChild);\n+\n+        doc.appendChild(rootElement);\n+\n+        Element checkModule = null;\n+        final ModuleType moduleType = moduleDetails.getModuleType();\n+        if (moduleType == ModuleType.CHECK) {\n+            checkModule = doc.createElement(\"check\");\n+        }\n+        else if (moduleType == ModuleType.FILTER) {\n+            checkModule = doc.createElement(\"filter\");\n+        }\n+        else if (moduleType == ModuleType.FILEFILTER) {\n+            checkModule = doc.createElement(\"file-filter\");\n+        }", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNDczNA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476534734", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-25T15:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2MDMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2Mjk0Mw==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476262943", "bodyText": "files.map(Path::toString)\nthere is no need to convert Path into string and then into file, Path has methods boolean endsWith(String other) and  File toFile() which will make it simpler\nPlease correct other occurrences if any", "author": "strkkk", "createdAt": "2020-08-25T08:14:52Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/MetadataGenerator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import com.puppycrawl.tools.checkstyle.Checker;\n+import com.puppycrawl.tools.checkstyle.DefaultConfiguration;\n+import com.puppycrawl.tools.checkstyle.TreeWalker;\n+import com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n+\n+public final class MetadataGenerator {\n+\n+    private MetadataGenerator() {\n+    }\n+\n+    /**\n+     * Generate metadata from the module source files available in the input argument path.\n+     *\n+     * @param args arguments\n+     * @throws IOException ioException\n+     * @throws CheckstyleException checkstyleException\n+     */\n+    public static void generate(String... args) throws IOException, CheckstyleException {\n+        final Checker checker = new Checker();\n+        checker.setModuleClassLoader(Checker.class.getClassLoader());\n+        final DefaultConfiguration scraperCheckConfig =\n+                        new DefaultConfiguration(JavadocMetadataScraper.class.getName());\n+        final DefaultConfiguration defaultConfiguration = new DefaultConfiguration(\"configuration\");\n+        final DefaultConfiguration treeWalkerConfig =\n+                new DefaultConfiguration(TreeWalker.class.getName());\n+        defaultConfiguration.addAttribute(\"charset\", StandardCharsets.UTF_8.name());\n+        defaultConfiguration.addChild(treeWalkerConfig);\n+        treeWalkerConfig.addChild(scraperCheckConfig);\n+        checker.configure(defaultConfiguration);\n+        dumpMetadata(checker, args[0]);\n+    }\n+\n+    /**\n+     * Process files using the checker passed and write to corresponding XML files.\n+     *\n+     * @param checker checker\n+     * @param path rootPath\n+     * @throws CheckstyleException checkstyleException\n+     * @throws IOException ioException\n+     */\n+    private static void dumpMetadata(Checker checker, String path) throws CheckstyleException,\n+            IOException {\n+        final List<File> validFiles = new ArrayList<>();\n+        if (path.endsWith(\".java\")) {\n+            validFiles.add(new File(path));\n+        }\n+        else {\n+            final List<String> moduleFolders = Arrays.asList(\"checks\", \"filters\", \"filefilters\");\n+            for (String folder : moduleFolders) {\n+                try (Stream<Path> files = Files.walk(Paths.get(path\n+                        + \"/\" + folder))) {\n+                    validFiles.addAll(files.map(Path::toString)", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNDgwMg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476534802", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-25T15:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2Mjk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NDc3Ng==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476264776", "bodyText": "Please extract this special default values into list and change this to List#contains", "author": "strkkk", "createdAt": "2020-08-25T08:17:54Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "diffHunk": "@@ -0,0 +1,566 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.TransformerException;\n+\n+import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n+import com.puppycrawl.tools.checkstyle.api.DetailAST;\n+import com.puppycrawl.tools.checkstyle.api.DetailNode;\n+import com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\n+import com.puppycrawl.tools.checkstyle.api.TokenTypes;\n+import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n+import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n+\n+@FileStatefulCheck\n+public class JavadocMetadataScraper extends AbstractJavadocCheck {\n+    private static final Pattern PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n+    private static final Pattern TYPE_TAG = Pattern.compile(\"\\\\s.*Type is\\\\s.*\");\n+    private static final Pattern VALIDATION_TYPE_TAG =\n+            Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n+    private static final Pattern DEFAULT_VALUE_TAG = Pattern.compile(\"\\\\s*Default value is:*.*\");\n+    private static final Pattern EXAMPLES_TAG =\n+            Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n+    private static final Pattern PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n+    private static final Pattern VIOLATION_MESSAGES_TAG =\n+            Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n+    private static final Pattern TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z]+_*)+[A-Z]+\");\n+    private static final Pattern DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n+    private static final Pattern FILE_SEPARATOR_PATTERN =\n+            Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n+    private static final Pattern QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n+\n+    private ModuleDetails moduleDetails;\n+    private ScrapeStatus currentStatus;\n+    private boolean toScan;\n+    private String descriptionText;\n+    private DetailNode rootNode;\n+    private int propertySectionStartIdx;\n+    private int exampleSectionStartIdx;\n+    private int parentSectionStartIdx;\n+\n+    @Override\n+    public int[] getDefaultJavadocTokens() {\n+        return new int[] {\n+            JavadocTokenTypes.JAVADOC,\n+            JavadocTokenTypes.PARAGRAPH,\n+            JavadocTokenTypes.LI,\n+            JavadocTokenTypes.SINCE_LITERAL,\n+        };\n+    }\n+\n+    @Override\n+    public int[] getRequiredJavadocTokens() {\n+        return getAcceptableJavadocTokens();\n+    }\n+\n+    @Override\n+    public void beginJavadocTree(DetailNode rootAst) {\n+        if (isTopLevelClassJavadoc()) {\n+            moduleDetails = new ModuleDetails();\n+            currentStatus = ScrapeStatus.DESCRIPTION;\n+            toScan = false;\n+            descriptionText = \"\";\n+            propertySectionStartIdx = -1;\n+            exampleSectionStartIdx = -1;\n+            parentSectionStartIdx = -1;\n+\n+            final String filePath = getFileContents().getFileName();\n+            String moduleName = getModuleSimpleName();\n+            if (moduleName.contains(\"Check\")) {\n+                moduleName = moduleName.substring(0, moduleName.indexOf(\"Check\"));\n+            }\n+            moduleDetails.setName(moduleName);\n+            moduleDetails.setFullQualifiedName(getPackageName(filePath));\n+            moduleDetails.setModuleType(getModuleType());\n+        }\n+    }\n+\n+    @Override\n+    public void visitJavadocToken(DetailNode ast) {\n+        if (toScan) {\n+            scrapeContent(ast);\n+        }\n+\n+        if (ast.getType() == JavadocTokenTypes.JAVADOC\n+            && getParent(getBlockCommentAst()).getType() == TokenTypes.CLASS_DEF) {\n+            rootNode = ast;\n+            toScan = true;\n+        }\n+        else if (ast.getType() == JavadocTokenTypes.SINCE_LITERAL) {\n+            toScan = false;\n+        }\n+    }\n+\n+    @Override\n+    public void finishJavadocTree(DetailNode rootAst) {\n+        moduleDetails.setDescription(getDescriptionText());\n+        if (isTopLevelClassJavadoc()) {\n+            try {\n+                new XmlMetaWriter().write(moduleDetails);\n+            }\n+            catch (TransformerException | ParserConfigurationException ex) {\n+                throw new IllegalStateException(\"Failed to write metadata into XML file for \"\n+                        + \"module: \" + getModuleSimpleName(), ex);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method containing the core logic of scraping. This keeps track and decides which phase of\n+     * scraping we are in, and accordingly call other subroutines.\n+     *\n+     * @param ast javadoc ast\n+     */\n+    public void scrapeContent(DetailNode ast) {\n+        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n+            if (isParentText(ast)) {\n+                currentStatus = ScrapeStatus.PARENT;\n+                parentSectionStartIdx = getParentIndexOf(ast);\n+                moduleDetails.setParent(getParentText(ast));\n+            }\n+            else if (isViolationMessagesText(ast)) {\n+                currentStatus = ScrapeStatus.VIOLATION_MESSAGES;\n+            }\n+            else if (exampleSectionStartIdx == -1\n+                    && isExamplesText(ast)) {\n+                exampleSectionStartIdx = getParentIndexOf(ast);\n+            }\n+        }\n+        else if (ast.getType() == JavadocTokenTypes.LI) {\n+            if (isPropertyList(ast)) {\n+                currentStatus = ScrapeStatus.PROPERTY;\n+\n+                if (propertySectionStartIdx == -1) {\n+                    propertySectionStartIdx = getParentIndexOf(ast);\n+                }\n+\n+                moduleDetails.setDescription(descriptionText);\n+                moduleDetails.addToProperties(createProperties(ast));\n+            }\n+            else if (currentStatus == ScrapeStatus.VIOLATION_MESSAGES) {\n+                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create the modulePropertyDetails content.\n+     *\n+     * @param nodeLi list item javadoc node\n+     * @return modulePropertyDetail object for the corresponding property\n+     */\n+    private static ModulePropertyDetails createProperties(DetailNode nodeLi) {\n+        final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n+        final DetailNode propertyNameTag =\n+                getFirstChildOfType(nodeLi, JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n+        final DetailNode propertyType = getFirstChildOfMatchingText(nodeLi, TYPE_TAG);\n+\n+        final String propertyDesc = DESC_CLEAN.matcher(\n+                constructSubTreeText(nodeLi, propertyNameTag.getIndex() + 1,\n+                propertyType.getIndex() - 1))\n+                .replaceAll(Matcher.quoteReplacement(\"\"));\n+\n+        modulePropertyDetails.setDescription(propertyDesc.trim());\n+        modulePropertyDetails.setName(getTextFromTag(propertyNameTag));\n+        modulePropertyDetails.setType(\n+                getTagTextFromProperty(nodeLi,\n+                getFirstChildOfMatchingText(nodeLi, TYPE_TAG)));\n+        final DetailNode validationTypeNode = getFirstChildOfMatchingText(nodeLi,\n+                VALIDATION_TYPE_TAG);\n+        if (validationTypeNode != null) {\n+            modulePropertyDetails.setValidationType(getTagTextFromProperty(nodeLi,\n+                    validationTypeNode));\n+        }\n+        final String defaultValue = getPropertyDefaultText(nodeLi);\n+        if (!\"null\".equals(defaultValue)\n+            && !\"the charset property of the parent\".equals(defaultValue)) {", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNDkwNQ==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476534905", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-25T15:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NDc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NzYxNA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476267614", "bodyText": "it is better to either throw an exception or return Optional for such case. I see no good handling for null values in invocations of getFirstChildOfType method", "author": "strkkk", "createdAt": "2020-08-25T08:22:19Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "diffHunk": "@@ -0,0 +1,566 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.TransformerException;\n+\n+import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n+import com.puppycrawl.tools.checkstyle.api.DetailAST;\n+import com.puppycrawl.tools.checkstyle.api.DetailNode;\n+import com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\n+import com.puppycrawl.tools.checkstyle.api.TokenTypes;\n+import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n+import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n+\n+@FileStatefulCheck\n+public class JavadocMetadataScraper extends AbstractJavadocCheck {\n+    private static final Pattern PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n+    private static final Pattern TYPE_TAG = Pattern.compile(\"\\\\s.*Type is\\\\s.*\");\n+    private static final Pattern VALIDATION_TYPE_TAG =\n+            Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n+    private static final Pattern DEFAULT_VALUE_TAG = Pattern.compile(\"\\\\s*Default value is:*.*\");\n+    private static final Pattern EXAMPLES_TAG =\n+            Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n+    private static final Pattern PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n+    private static final Pattern VIOLATION_MESSAGES_TAG =\n+            Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n+    private static final Pattern TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z]+_*)+[A-Z]+\");\n+    private static final Pattern DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n+    private static final Pattern FILE_SEPARATOR_PATTERN =\n+            Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n+    private static final Pattern QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n+\n+    private ModuleDetails moduleDetails;\n+    private ScrapeStatus currentStatus;\n+    private boolean toScan;\n+    private String descriptionText;\n+    private DetailNode rootNode;\n+    private int propertySectionStartIdx;\n+    private int exampleSectionStartIdx;\n+    private int parentSectionStartIdx;\n+\n+    @Override\n+    public int[] getDefaultJavadocTokens() {\n+        return new int[] {\n+            JavadocTokenTypes.JAVADOC,\n+            JavadocTokenTypes.PARAGRAPH,\n+            JavadocTokenTypes.LI,\n+            JavadocTokenTypes.SINCE_LITERAL,\n+        };\n+    }\n+\n+    @Override\n+    public int[] getRequiredJavadocTokens() {\n+        return getAcceptableJavadocTokens();\n+    }\n+\n+    @Override\n+    public void beginJavadocTree(DetailNode rootAst) {\n+        if (isTopLevelClassJavadoc()) {\n+            moduleDetails = new ModuleDetails();\n+            currentStatus = ScrapeStatus.DESCRIPTION;\n+            toScan = false;\n+            descriptionText = \"\";\n+            propertySectionStartIdx = -1;\n+            exampleSectionStartIdx = -1;\n+            parentSectionStartIdx = -1;\n+\n+            final String filePath = getFileContents().getFileName();\n+            String moduleName = getModuleSimpleName();\n+            if (moduleName.contains(\"Check\")) {\n+                moduleName = moduleName.substring(0, moduleName.indexOf(\"Check\"));\n+            }\n+            moduleDetails.setName(moduleName);\n+            moduleDetails.setFullQualifiedName(getPackageName(filePath));\n+            moduleDetails.setModuleType(getModuleType());\n+        }\n+    }\n+\n+    @Override\n+    public void visitJavadocToken(DetailNode ast) {\n+        if (toScan) {\n+            scrapeContent(ast);\n+        }\n+\n+        if (ast.getType() == JavadocTokenTypes.JAVADOC\n+            && getParent(getBlockCommentAst()).getType() == TokenTypes.CLASS_DEF) {\n+            rootNode = ast;\n+            toScan = true;\n+        }\n+        else if (ast.getType() == JavadocTokenTypes.SINCE_LITERAL) {\n+            toScan = false;\n+        }\n+    }\n+\n+    @Override\n+    public void finishJavadocTree(DetailNode rootAst) {\n+        moduleDetails.setDescription(getDescriptionText());\n+        if (isTopLevelClassJavadoc()) {\n+            try {\n+                new XmlMetaWriter().write(moduleDetails);\n+            }\n+            catch (TransformerException | ParserConfigurationException ex) {\n+                throw new IllegalStateException(\"Failed to write metadata into XML file for \"\n+                        + \"module: \" + getModuleSimpleName(), ex);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method containing the core logic of scraping. This keeps track and decides which phase of\n+     * scraping we are in, and accordingly call other subroutines.\n+     *\n+     * @param ast javadoc ast\n+     */\n+    public void scrapeContent(DetailNode ast) {\n+        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n+            if (isParentText(ast)) {\n+                currentStatus = ScrapeStatus.PARENT;\n+                parentSectionStartIdx = getParentIndexOf(ast);\n+                moduleDetails.setParent(getParentText(ast));\n+            }\n+            else if (isViolationMessagesText(ast)) {\n+                currentStatus = ScrapeStatus.VIOLATION_MESSAGES;\n+            }\n+            else if (exampleSectionStartIdx == -1\n+                    && isExamplesText(ast)) {\n+                exampleSectionStartIdx = getParentIndexOf(ast);\n+            }\n+        }\n+        else if (ast.getType() == JavadocTokenTypes.LI) {\n+            if (isPropertyList(ast)) {\n+                currentStatus = ScrapeStatus.PROPERTY;\n+\n+                if (propertySectionStartIdx == -1) {\n+                    propertySectionStartIdx = getParentIndexOf(ast);\n+                }\n+\n+                moduleDetails.setDescription(descriptionText);\n+                moduleDetails.addToProperties(createProperties(ast));\n+            }\n+            else if (currentStatus == ScrapeStatus.VIOLATION_MESSAGES) {\n+                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create the modulePropertyDetails content.\n+     *\n+     * @param nodeLi list item javadoc node\n+     * @return modulePropertyDetail object for the corresponding property\n+     */\n+    private static ModulePropertyDetails createProperties(DetailNode nodeLi) {\n+        final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n+        final DetailNode propertyNameTag =\n+                getFirstChildOfType(nodeLi, JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n+        final DetailNode propertyType = getFirstChildOfMatchingText(nodeLi, TYPE_TAG);\n+\n+        final String propertyDesc = DESC_CLEAN.matcher(\n+                constructSubTreeText(nodeLi, propertyNameTag.getIndex() + 1,\n+                propertyType.getIndex() - 1))\n+                .replaceAll(Matcher.quoteReplacement(\"\"));\n+\n+        modulePropertyDetails.setDescription(propertyDesc.trim());\n+        modulePropertyDetails.setName(getTextFromTag(propertyNameTag));\n+        modulePropertyDetails.setType(\n+                getTagTextFromProperty(nodeLi,\n+                getFirstChildOfMatchingText(nodeLi, TYPE_TAG)));\n+        final DetailNode validationTypeNode = getFirstChildOfMatchingText(nodeLi,\n+                VALIDATION_TYPE_TAG);\n+        if (validationTypeNode != null) {\n+            modulePropertyDetails.setValidationType(getTagTextFromProperty(nodeLi,\n+                    validationTypeNode));\n+        }\n+        final String defaultValue = getPropertyDefaultText(nodeLi);\n+        if (!\"null\".equals(defaultValue)\n+            && !\"the charset property of the parent\".equals(defaultValue)) {\n+            modulePropertyDetails.setDefaultValue(defaultValue);\n+        }\n+        return modulePropertyDetails;\n+    }\n+\n+    /**\n+     * Get tag text from property data.\n+     *\n+     * @param nodeLi javadoc li item node\n+     * @param propertyMeta property javadoc node\n+     * @return property metadata text\n+     */\n+    private static String getTagTextFromProperty(DetailNode nodeLi, DetailNode propertyMeta) {\n+        final DetailNode tagNode = getFirstChildOfType(nodeLi,\n+                JavadocTokenTypes.JAVADOC_INLINE_TAG, propertyMeta.getIndex() + 1);\n+        return getTextFromTag(tagNode);\n+    }\n+\n+    /**\n+     * Clean up the default token text by removing hyperlinks, and only keeping token type text.\n+     *\n+     * @param initialText unclean text\n+     * @return clean text\n+     */\n+    private static String cleanDefaultTokensText(String initialText) {\n+        final Set<String> tokens = new LinkedHashSet<>();\n+        final Matcher matcher = TOKEN_TEXT_PATTERN.matcher(initialText);\n+        while (matcher.find()) {\n+            tokens.add(matcher.group(0));\n+        }\n+        return String.join(\",\", tokens);\n+    }\n+\n+    /**\n+     * Performs a DFS of the subtree with a node as the root and constructs the text of that\n+     * tree, ignoring JavadocToken texts.\n+     *\n+     * @param node root node of subtree\n+     * @param childLeftLimit the left index of root children from where to scan\n+     * @param childRightLimit the right index of root children till where to scan\n+     * @return constructed text of subtree\n+     */\n+    private static String constructSubTreeText(DetailNode node, int childLeftLimit,\n+                                               int childRightLimit) {\n+        final StringBuilder result = new StringBuilder(1024);\n+        DetailNode detailNode = node;\n+        final Set<DetailNode> visited = new HashSet<>();\n+\n+        final Deque<DetailNode> stack = new ArrayDeque<>();\n+        stack.addFirst(detailNode);\n+        while (!stack.isEmpty()) {\n+            detailNode = stack.getFirst();\n+            stack.removeFirst();\n+\n+            if (!visited.contains(detailNode)) {\n+                final String childText = detailNode.getText();\n+                if (detailNode.getType() != JavadocTokenTypes.LEADING_ASTERISK\n+                        && !TOKEN_TEXT_PATTERN.matcher(childText).matches()) {\n+                    result.insert(0, detailNode.getText());\n+                }\n+                visited.add(detailNode);\n+            }\n+\n+            for (DetailNode child : detailNode.getChildren()) {\n+                if (child.getParent().equals(node)\n+                        && (child.getIndex() < childLeftLimit\n+                        || child.getIndex() > childRightLimit)) {\n+                    continue;\n+                }\n+                if (!visited.contains(child)) {\n+                    stack.addFirst(child);\n+                }\n+            }\n+        }\n+        return result.toString().trim();\n+    }\n+\n+    /**\n+     * Create the description text with starting index as 0 and ending index would be the first\n+     * valid non zero index amongst in the order of {@code propertySectionStartIdx},\n+     * {@code exampleSectionStartIdx} and {@code parentSectionStartIdx}.\n+     *\n+     * @return description text\n+     */\n+    private String getDescriptionText() {\n+        final int descriptionEndIdx;\n+        if (propertySectionStartIdx > -1) {\n+            descriptionEndIdx = propertySectionStartIdx;\n+        }\n+        else if (exampleSectionStartIdx > -1) {\n+            descriptionEndIdx = exampleSectionStartIdx;\n+        }\n+        else {\n+            descriptionEndIdx = parentSectionStartIdx;\n+        }\n+        return constructSubTreeText(rootNode, 0, descriptionEndIdx - 1);\n+    }\n+\n+    /**\n+     * Create property default text, which is either normal property value or list of tokens.\n+     *\n+     * @param nodeLi list item javadoc node\n+     * @return default property text\n+     */\n+    private static String getPropertyDefaultText(DetailNode nodeLi) {\n+        final String result;\n+        final DetailNode defaultValueNode = getFirstChildOfMatchingText(nodeLi, DEFAULT_VALUE_TAG);\n+        final DetailNode propertyDefaultValueTag = getFirstChildOfType(nodeLi,\n+                JavadocTokenTypes.JAVADOC_INLINE_TAG, defaultValueNode.getIndex() + 1);\n+        if (propertyDefaultValueTag == null) {\n+            final String tokenText = constructSubTreeText(nodeLi,\n+                    defaultValueNode.getIndex(), nodeLi.getChildren().length);\n+            result = cleanDefaultTokensText(tokenText);\n+        }\n+        else {\n+            result = getTextFromTag(propertyDefaultValueTag);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the violation message text for a specific key from the list item.\n+     *\n+     * @param nodeLi list item javadoc node\n+     * @return violation message key text\n+     */\n+    private static String getViolationMessages(DetailNode nodeLi) {\n+        return getTextFromTag(\n+                getFirstChildOfType(nodeLi, JavadocTokenTypes.JAVADOC_INLINE_TAG, 0));\n+    }\n+\n+    /**\n+     * Get text from {@code JavadocTokenTypes.JAVADOC_INLINE_TAG}.\n+     *\n+     * @param nodeTag target javadoc tag\n+     * @return text contained by the tag\n+     */\n+    private static String getTextFromTag(DetailNode nodeTag) {\n+        String result = \"\";\n+        if (nodeTag != null) {\n+            result = QUOTE_PATTERN.matcher(\n+                    getFirstChildOfType(nodeTag, JavadocTokenTypes.TEXT, 0)\n+                            .getText().trim()).replaceAll(\"\");\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the first child node which matches the provided {@code TokenType} and has the\n+     * children index after the offset value.\n+     *\n+     * @param node parent node\n+     * @param tokenType token type to match\n+     * @param offset children array index offset\n+     * @return the first child satisfying the conditions\n+     */\n+    private static DetailNode getFirstChildOfType(DetailNode node, int tokenType, int offset) {\n+        return Arrays.stream(node.getChildren())\n+                .filter(child -> child.getIndex() >= offset && child.getType() == tokenType)\n+                .findFirst()\n+                .orElse(null);", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNDk5MA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476534990", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-25T15:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NzYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NzcyMg==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476267722", "bodyText": "same here", "author": "strkkk", "createdAt": "2020-08-25T08:22:32Z", "path": "src/test/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "diffHunk": "@@ -0,0 +1,566 @@\n+////////////////////////////////////////////////////////////////////////////////\n+// checkstyle: Checks Java source code for adherence to a set of rules.\n+// Copyright (C) 2001-2020 the original author or authors.\n+//\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU Lesser General Public\n+// License as published by the Free Software Foundation; either\n+// version 2.1 of the License, or (at your option) any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// Lesser General Public License for more details.\n+//\n+// You should have received a copy of the GNU Lesser General Public\n+// License along with this library; if not, write to the Free Software\n+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+////////////////////////////////////////////////////////////////////////////////\n+\n+package com.puppycrawl.tools.checkstyle.meta;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.TransformerException;\n+\n+import com.puppycrawl.tools.checkstyle.FileStatefulCheck;\n+import com.puppycrawl.tools.checkstyle.api.DetailAST;\n+import com.puppycrawl.tools.checkstyle.api.DetailNode;\n+import com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\n+import com.puppycrawl.tools.checkstyle.api.TokenTypes;\n+import com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\n+import com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n+\n+@FileStatefulCheck\n+public class JavadocMetadataScraper extends AbstractJavadocCheck {\n+    private static final Pattern PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n+    private static final Pattern TYPE_TAG = Pattern.compile(\"\\\\s.*Type is\\\\s.*\");\n+    private static final Pattern VALIDATION_TYPE_TAG =\n+            Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n+    private static final Pattern DEFAULT_VALUE_TAG = Pattern.compile(\"\\\\s*Default value is:*.*\");\n+    private static final Pattern EXAMPLES_TAG =\n+            Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n+    private static final Pattern PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n+    private static final Pattern VIOLATION_MESSAGES_TAG =\n+            Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n+    private static final Pattern TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z]+_*)+[A-Z]+\");\n+    private static final Pattern DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n+    private static final Pattern FILE_SEPARATOR_PATTERN =\n+            Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n+    private static final Pattern QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n+\n+    private ModuleDetails moduleDetails;\n+    private ScrapeStatus currentStatus;\n+    private boolean toScan;\n+    private String descriptionText;\n+    private DetailNode rootNode;\n+    private int propertySectionStartIdx;\n+    private int exampleSectionStartIdx;\n+    private int parentSectionStartIdx;\n+\n+    @Override\n+    public int[] getDefaultJavadocTokens() {\n+        return new int[] {\n+            JavadocTokenTypes.JAVADOC,\n+            JavadocTokenTypes.PARAGRAPH,\n+            JavadocTokenTypes.LI,\n+            JavadocTokenTypes.SINCE_LITERAL,\n+        };\n+    }\n+\n+    @Override\n+    public int[] getRequiredJavadocTokens() {\n+        return getAcceptableJavadocTokens();\n+    }\n+\n+    @Override\n+    public void beginJavadocTree(DetailNode rootAst) {\n+        if (isTopLevelClassJavadoc()) {\n+            moduleDetails = new ModuleDetails();\n+            currentStatus = ScrapeStatus.DESCRIPTION;\n+            toScan = false;\n+            descriptionText = \"\";\n+            propertySectionStartIdx = -1;\n+            exampleSectionStartIdx = -1;\n+            parentSectionStartIdx = -1;\n+\n+            final String filePath = getFileContents().getFileName();\n+            String moduleName = getModuleSimpleName();\n+            if (moduleName.contains(\"Check\")) {\n+                moduleName = moduleName.substring(0, moduleName.indexOf(\"Check\"));\n+            }\n+            moduleDetails.setName(moduleName);\n+            moduleDetails.setFullQualifiedName(getPackageName(filePath));\n+            moduleDetails.setModuleType(getModuleType());\n+        }\n+    }\n+\n+    @Override\n+    public void visitJavadocToken(DetailNode ast) {\n+        if (toScan) {\n+            scrapeContent(ast);\n+        }\n+\n+        if (ast.getType() == JavadocTokenTypes.JAVADOC\n+            && getParent(getBlockCommentAst()).getType() == TokenTypes.CLASS_DEF) {\n+            rootNode = ast;\n+            toScan = true;\n+        }\n+        else if (ast.getType() == JavadocTokenTypes.SINCE_LITERAL) {\n+            toScan = false;\n+        }\n+    }\n+\n+    @Override\n+    public void finishJavadocTree(DetailNode rootAst) {\n+        moduleDetails.setDescription(getDescriptionText());\n+        if (isTopLevelClassJavadoc()) {\n+            try {\n+                new XmlMetaWriter().write(moduleDetails);\n+            }\n+            catch (TransformerException | ParserConfigurationException ex) {\n+                throw new IllegalStateException(\"Failed to write metadata into XML file for \"\n+                        + \"module: \" + getModuleSimpleName(), ex);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method containing the core logic of scraping. This keeps track and decides which phase of\n+     * scraping we are in, and accordingly call other subroutines.\n+     *\n+     * @param ast javadoc ast\n+     */\n+    public void scrapeContent(DetailNode ast) {\n+        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n+            if (isParentText(ast)) {\n+                currentStatus = ScrapeStatus.PARENT;\n+                parentSectionStartIdx = getParentIndexOf(ast);\n+                moduleDetails.setParent(getParentText(ast));\n+            }\n+            else if (isViolationMessagesText(ast)) {\n+                currentStatus = ScrapeStatus.VIOLATION_MESSAGES;\n+            }\n+            else if (exampleSectionStartIdx == -1\n+                    && isExamplesText(ast)) {\n+                exampleSectionStartIdx = getParentIndexOf(ast);\n+            }\n+        }\n+        else if (ast.getType() == JavadocTokenTypes.LI) {\n+            if (isPropertyList(ast)) {\n+                currentStatus = ScrapeStatus.PROPERTY;\n+\n+                if (propertySectionStartIdx == -1) {\n+                    propertySectionStartIdx = getParentIndexOf(ast);\n+                }\n+\n+                moduleDetails.setDescription(descriptionText);\n+                moduleDetails.addToProperties(createProperties(ast));\n+            }\n+            else if (currentStatus == ScrapeStatus.VIOLATION_MESSAGES) {\n+                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create the modulePropertyDetails content.\n+     *\n+     * @param nodeLi list item javadoc node\n+     * @return modulePropertyDetail object for the corresponding property\n+     */\n+    private static ModulePropertyDetails createProperties(DetailNode nodeLi) {\n+        final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n+        final DetailNode propertyNameTag =\n+                getFirstChildOfType(nodeLi, JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n+        final DetailNode propertyType = getFirstChildOfMatchingText(nodeLi, TYPE_TAG);\n+\n+        final String propertyDesc = DESC_CLEAN.matcher(\n+                constructSubTreeText(nodeLi, propertyNameTag.getIndex() + 1,\n+                propertyType.getIndex() - 1))\n+                .replaceAll(Matcher.quoteReplacement(\"\"));\n+\n+        modulePropertyDetails.setDescription(propertyDesc.trim());\n+        modulePropertyDetails.setName(getTextFromTag(propertyNameTag));\n+        modulePropertyDetails.setType(\n+                getTagTextFromProperty(nodeLi,\n+                getFirstChildOfMatchingText(nodeLi, TYPE_TAG)));\n+        final DetailNode validationTypeNode = getFirstChildOfMatchingText(nodeLi,\n+                VALIDATION_TYPE_TAG);\n+        if (validationTypeNode != null) {\n+            modulePropertyDetails.setValidationType(getTagTextFromProperty(nodeLi,\n+                    validationTypeNode));\n+        }\n+        final String defaultValue = getPropertyDefaultText(nodeLi);\n+        if (!\"null\".equals(defaultValue)\n+            && !\"the charset property of the parent\".equals(defaultValue)) {\n+            modulePropertyDetails.setDefaultValue(defaultValue);\n+        }\n+        return modulePropertyDetails;\n+    }\n+\n+    /**\n+     * Get tag text from property data.\n+     *\n+     * @param nodeLi javadoc li item node\n+     * @param propertyMeta property javadoc node\n+     * @return property metadata text\n+     */\n+    private static String getTagTextFromProperty(DetailNode nodeLi, DetailNode propertyMeta) {\n+        final DetailNode tagNode = getFirstChildOfType(nodeLi,\n+                JavadocTokenTypes.JAVADOC_INLINE_TAG, propertyMeta.getIndex() + 1);\n+        return getTextFromTag(tagNode);\n+    }\n+\n+    /**\n+     * Clean up the default token text by removing hyperlinks, and only keeping token type text.\n+     *\n+     * @param initialText unclean text\n+     * @return clean text\n+     */\n+    private static String cleanDefaultTokensText(String initialText) {\n+        final Set<String> tokens = new LinkedHashSet<>();\n+        final Matcher matcher = TOKEN_TEXT_PATTERN.matcher(initialText);\n+        while (matcher.find()) {\n+            tokens.add(matcher.group(0));\n+        }\n+        return String.join(\",\", tokens);\n+    }\n+\n+    /**\n+     * Performs a DFS of the subtree with a node as the root and constructs the text of that\n+     * tree, ignoring JavadocToken texts.\n+     *\n+     * @param node root node of subtree\n+     * @param childLeftLimit the left index of root children from where to scan\n+     * @param childRightLimit the right index of root children till where to scan\n+     * @return constructed text of subtree\n+     */\n+    private static String constructSubTreeText(DetailNode node, int childLeftLimit,\n+                                               int childRightLimit) {\n+        final StringBuilder result = new StringBuilder(1024);\n+        DetailNode detailNode = node;\n+        final Set<DetailNode> visited = new HashSet<>();\n+\n+        final Deque<DetailNode> stack = new ArrayDeque<>();\n+        stack.addFirst(detailNode);\n+        while (!stack.isEmpty()) {\n+            detailNode = stack.getFirst();\n+            stack.removeFirst();\n+\n+            if (!visited.contains(detailNode)) {\n+                final String childText = detailNode.getText();\n+                if (detailNode.getType() != JavadocTokenTypes.LEADING_ASTERISK\n+                        && !TOKEN_TEXT_PATTERN.matcher(childText).matches()) {\n+                    result.insert(0, detailNode.getText());\n+                }\n+                visited.add(detailNode);\n+            }\n+\n+            for (DetailNode child : detailNode.getChildren()) {\n+                if (child.getParent().equals(node)\n+                        && (child.getIndex() < childLeftLimit\n+                        || child.getIndex() > childRightLimit)) {\n+                    continue;\n+                }\n+                if (!visited.contains(child)) {\n+                    stack.addFirst(child);\n+                }\n+            }\n+        }\n+        return result.toString().trim();\n+    }\n+\n+    /**\n+     * Create the description text with starting index as 0 and ending index would be the first\n+     * valid non zero index amongst in the order of {@code propertySectionStartIdx},\n+     * {@code exampleSectionStartIdx} and {@code parentSectionStartIdx}.\n+     *\n+     * @return description text\n+     */\n+    private String getDescriptionText() {\n+        final int descriptionEndIdx;\n+        if (propertySectionStartIdx > -1) {\n+            descriptionEndIdx = propertySectionStartIdx;\n+        }\n+        else if (exampleSectionStartIdx > -1) {\n+            descriptionEndIdx = exampleSectionStartIdx;\n+        }\n+        else {\n+            descriptionEndIdx = parentSectionStartIdx;\n+        }\n+        return constructSubTreeText(rootNode, 0, descriptionEndIdx - 1);\n+    }\n+\n+    /**\n+     * Create property default text, which is either normal property value or list of tokens.\n+     *\n+     * @param nodeLi list item javadoc node\n+     * @return default property text\n+     */\n+    private static String getPropertyDefaultText(DetailNode nodeLi) {\n+        final String result;\n+        final DetailNode defaultValueNode = getFirstChildOfMatchingText(nodeLi, DEFAULT_VALUE_TAG);\n+        final DetailNode propertyDefaultValueTag = getFirstChildOfType(nodeLi,\n+                JavadocTokenTypes.JAVADOC_INLINE_TAG, defaultValueNode.getIndex() + 1);\n+        if (propertyDefaultValueTag == null) {\n+            final String tokenText = constructSubTreeText(nodeLi,\n+                    defaultValueNode.getIndex(), nodeLi.getChildren().length);\n+            result = cleanDefaultTokensText(tokenText);\n+        }\n+        else {\n+            result = getTextFromTag(propertyDefaultValueTag);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the violation message text for a specific key from the list item.\n+     *\n+     * @param nodeLi list item javadoc node\n+     * @return violation message key text\n+     */\n+    private static String getViolationMessages(DetailNode nodeLi) {\n+        return getTextFromTag(\n+                getFirstChildOfType(nodeLi, JavadocTokenTypes.JAVADOC_INLINE_TAG, 0));\n+    }\n+\n+    /**\n+     * Get text from {@code JavadocTokenTypes.JAVADOC_INLINE_TAG}.\n+     *\n+     * @param nodeTag target javadoc tag\n+     * @return text contained by the tag\n+     */\n+    private static String getTextFromTag(DetailNode nodeTag) {\n+        String result = \"\";\n+        if (nodeTag != null) {\n+            result = QUOTE_PATTERN.matcher(\n+                    getFirstChildOfType(nodeTag, JavadocTokenTypes.TEXT, 0)\n+                            .getText().trim()).replaceAll(\"\");\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the first child node which matches the provided {@code TokenType} and has the\n+     * children index after the offset value.\n+     *\n+     * @param node parent node\n+     * @param tokenType token type to match\n+     * @param offset children array index offset\n+     * @return the first child satisfying the conditions\n+     */\n+    private static DetailNode getFirstChildOfType(DetailNode node, int tokenType, int offset) {\n+        return Arrays.stream(node.getChildren())\n+                .filter(child -> child.getIndex() >= offset && child.getType() == tokenType)\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    /**\n+     * Get first child of parent node matching the provided pattern.\n+     *\n+     * @param node parent node\n+     * @param pattern pattern to match against\n+     * @return the first child node matching the condition\n+     */\n+    private static DetailNode getFirstChildOfMatchingText(DetailNode node, Pattern pattern) {\n+        return Arrays.stream(node.getChildren())\n+                .filter(child -> pattern.matcher(child.getText()).matches())\n+                .findFirst()\n+                .orElse(null);", "originalCommit": "05f47af89190a044b93855e9bd485dd9d2abe965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNTAzOA==", "url": "https://github.com/checkstyle/checkstyle/pull/8743#discussion_r476535038", "bodyText": "Done", "author": "gaurabdg", "createdAt": "2020-08-25T15:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NzcyMg=="}], "type": "inlineReview"}, {"oid": "00a6f46468340813b1c6c32407ab0e7df05fda94", "url": "https://github.com/checkstyle/checkstyle/commit/00a6f46468340813b1c6c32407ab0e7df05fda94", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-25T15:22:25Z", "type": "forcePushed"}, {"oid": "4581293a2f1fbf5a081fec8976c0393c4ce1e400", "url": "https://github.com/checkstyle/checkstyle/commit/4581293a2f1fbf5a081fec8976c0393c4ce1e400", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-25T16:21:29Z", "type": "forcePushed"}, {"oid": "debde384c3d57fcf44b9b2b0649ca35663ead2f7", "url": "https://github.com/checkstyle/checkstyle/commit/debde384c3d57fcf44b9b2b0649ca35663ead2f7", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-25T19:02:51Z", "type": "forcePushed"}, {"oid": "743424477d0dab9521fa8055698f850e7d3ae288", "url": "https://github.com/checkstyle/checkstyle/commit/743424477d0dab9521fa8055698f850e7d3ae288", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-25T19:35:45Z", "type": "forcePushed"}, {"oid": "a65d4345ed008666938dc8ea623565fbecca0231", "url": "https://github.com/checkstyle/checkstyle/commit/a65d4345ed008666938dc8ea623565fbecca0231", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-25T20:11:14Z", "type": "commit"}, {"oid": "a65d4345ed008666938dc8ea623565fbecca0231", "url": "https://github.com/checkstyle/checkstyle/commit/a65d4345ed008666938dc8ea623565fbecca0231", "message": "Issue #8742: Metadata-gen code migration", "committedDate": "2020-08-25T20:11:14Z", "type": "forcePushed"}]}