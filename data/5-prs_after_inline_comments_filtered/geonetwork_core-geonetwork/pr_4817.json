{"pr_number": 4817, "pr_title": "Allow to restore a metadata record from deleted records (Part 3)", "pr_createdAt": "2020-07-01T15:44:13Z", "pr_url": "https://github.com/geonetwork/core-geonetwork/pull/4817", "timeline": [{"oid": "e2d532a95ca5214ed1541b7bb083027e3c53628b", "url": "https://github.com/geonetwork/core-geonetwork/commit/e2d532a95ca5214ed1541b7bb083027e3c53628b", "message": "Restore from history functionality", "committedDate": "2019-11-06T13:43:47Z", "type": "commit"}, {"oid": "171a19244848fa0eae1614d698c237ac5c5bd7ac", "url": "https://github.com/geonetwork/core-geonetwork/commit/171a19244848fa0eae1614d698c237ac5c5bd7ac", "message": "Behavior when draft exists", "committedDate": "2019-11-11T16:34:46Z", "type": "commit"}, {"oid": "0e740644fedcefe8f9457cba28323cdc327038d2", "url": "https://github.com/geonetwork/core-geonetwork/commit/0e740644fedcefe8f9457cba28323cdc327038d2", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory\n\n# Conflicts:\n#\tweb-ui/src/main/resources/catalog/locales/en-core.json\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v390/migrate-default.sql", "committedDate": "2020-06-02T14:26:06Z", "type": "commit"}, {"oid": "28037420226c475812f557ab848405cb5deb1c38", "url": "https://github.com/geonetwork/core-geonetwork/commit/28037420226c475812f557ab848405cb5deb1c38", "message": "Fixed migration merge", "committedDate": "2020-06-02T14:37:50Z", "type": "commit"}, {"oid": "a5e97b66a5f5f28c0b83309acf257a86ce7a0bfb", "url": "https://github.com/geonetwork/core-geonetwork/commit/a5e97b66a5f5f28c0b83309acf257a86ce7a0bfb", "message": "Removed MetadataStatusId Serialization and Deserialization and used existing format of /{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}\nRemoved rollback option as a rollback is the same as a restore.  Also removed logic to delete status of rollback status.\nRenamed view to view previous version and changed version and added new showStatusAfter api to support this.\nDatabase\nAdded missing fre language for insert\nMove migration inserts to 3110 and also added missing translation.", "committedDate": "2020-06-10T20:00:28Z", "type": "commit"}, {"oid": "cccf33dc4988cdc9924ccebde601e4fb3854d580", "url": "https://github.com/geonetwork/core-geonetwork/commit/cccf33dc4988cdc9924ccebde601e4fb3854d580", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory\n\n# Conflicts:\n#\tservices/src/main/java/org/fao/geonet/api/records/model/MetadataStatusResponse.java", "committedDate": "2020-06-12T11:29:23Z", "type": "commit"}, {"oid": "423e3f2de8f0b58f43fb3cd889f4a72ec0791a66", "url": "https://github.com/geonetwork/core-geonetwork/commit/423e3f2de8f0b58f43fb3cd889f4a72ec0791a66", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory\n\n# Conflicts:\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-default.sql", "committedDate": "2020-06-29T13:45:26Z", "type": "commit"}, {"oid": "8ebec258d842aae3973e32d68f955d7eceb505e6", "url": "https://github.com/geonetwork/core-geonetwork/commit/8ebec258d842aae3973e32d68f955d7eceb505e6", "message": "Allow capability to recover deleted records\nChanged PK key for metadatastatus so that it is a single key.\nAdded groupownname to geonet:info to assist with the recovery.\nAdd metadataStatus entry for deleted objects.\n    Added UUID and Titles to the status so that the data is available for deleted records as well.", "committedDate": "2020-07-01T16:35:33Z", "type": "commit"}, {"oid": "8ebec258d842aae3973e32d68f955d7eceb505e6", "url": "https://github.com/geonetwork/core-geonetwork/commit/8ebec258d842aae3973e32d68f955d7eceb505e6", "message": "Allow capability to recover deleted records\nChanged PK key for metadatastatus so that it is a single key.\nAdded groupownname to geonet:info to assist with the recovery.\nAdd metadataStatus entry for deleted objects.\n    Added UUID and Titles to the status so that the data is available for deleted records as well.", "committedDate": "2020-07-01T16:35:33Z", "type": "forcePushed"}, {"oid": "d2f1c58cdd1e94995dfb63b538379cc2d8890c51", "url": "https://github.com/geonetwork/core-geonetwork/commit/d2f1c58cdd1e94995dfb63b538379cc2d8890c51", "message": "removed duplicate status_id which is the same as the statusvalue.", "committedDate": "2020-07-01T21:08:11Z", "type": "commit"}, {"oid": "3717110450b83b29724acd3f96056715480ddd6e", "url": "https://github.com/geonetwork/core-geonetwork/commit/3717110450b83b29724acd3f96056715480ddd6e", "message": "Fixed improper resolved conflict which accidentally converted file to ascci causing script to fail.", "committedDate": "2020-07-03T18:31:02Z", "type": "commit"}, {"oid": "b0298b8f557226e985b84e71ead774a47ae9c98e", "url": "https://github.com/geonetwork/core-geonetwork/commit/b0298b8f557226e985b84e71ead774a47ae9c98e", "message": "Updated migration script\nattempted to load titles but failed.", "committedDate": "2020-07-03T18:34:40Z", "type": "commit"}, {"oid": "2f81e98203baccb1071648f8d6e0472bc664bb01", "url": "https://github.com/geonetwork/core-geonetwork/commit/2f81e98203baccb1071648f8d6e0472bc664bb01", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix", "committedDate": "2020-08-06T13:01:46Z", "type": "commit"}, {"oid": "e89ab67da98182068a521cfc1d5beabb98f4cd99", "url": "https://github.com/geonetwork/core-geonetwork/commit/e89ab67da98182068a521cfc1d5beabb98f4cd99", "message": "More versioning changes\nChanged titles to LinkedHashMap so that the order is static.\nUpdated status search api so that we can query based on id and uuid.\nUpdated API results\n   Changed RelatedMetadataStatus to only return the id instead of the object.\n   Return titles as a json object (applied temp hack until we upgrade jpa)\n   renamed *statusEmpty to *stateEmpty for consistency\n   Fixed bug with some fields being null when they should have values.\n   Removed *statusDetail as we already had the *state fields from the parent.  If we want them named statusDetail then we should rename the fields in MetadataStatus.\nAlso updated migration script to attempt to fix primary key issue - but may need more work.", "committedDate": "2020-08-07T22:56:35Z", "type": "commit"}, {"oid": "779274618d9126f1ba2f47a8cb17ba3a60068f5e", "url": "https://github.com/geonetwork/core-geonetwork/commit/779274618d9126f1ba2f47a8cb17ba3a60068f5e", "message": "Added @Type annotations", "committedDate": "2020-08-11T14:37:28Z", "type": "commit"}, {"oid": "aced878f3962039b8a289eb540682cb4fab40653", "url": "https://github.com/geonetwork/core-geonetwork/commit/aced878f3962039b8a289eb540682cb4fab40653", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix", "committedDate": "2020-09-04T10:33:04Z", "type": "commit"}, {"oid": "aecc4cea12d266521f7eff79968131b80f0feaa3", "url": "https://github.com/geonetwork/core-geonetwork/commit/aecc4cea12d266521f7eff79968131b80f0feaa3", "message": "Fixed H2 migration primary key issues and also completed the rest field migrations issues (except for the the titles)\n    Removed multikey Unique key on metadata status.  It was confusing H2 as it was using the same index for the PK and unique key making it difficult to remove the primary key.\nAdded missing commands in the oracle and mysql scripts.", "committedDate": "2020-09-14T17:04:35Z", "type": "commit"}, {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c", "url": "https://github.com/geonetwork/core-geonetwork/commit/41d89b2b3dd6b38775af1a3256a5b3c6071bd92c", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix\n\n# Conflicts:\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-default.sql", "committedDate": "2020-09-15T11:01:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNjMwNA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499606304", "bodyText": "Is this required or can be updated the code that uses this method to use Integer.parseInt?", "author": "josegar74", "createdAt": "2020-10-05T13:40:13Z", "path": "domain/src/main/java/org/fao/geonet/repository/GroupRepositoryCustom.java", "diffHunk": "@@ -36,6 +37,16 @@\n  * @author Jesse\n  */\n public interface GroupRepositoryCustom {\n+    /**\n+     * Find the group with the given groupId (where groupId is a string).  The string will be converted\n+     * to an integer for making the query.\n+     *\n+     * @param groupId the groupid.\n+     * @return the group with the given groupid\n+     */\n+    @Nullable\n+    Group findOne(@Nonnull String groupId);", "originalCommit": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3OTM2Nw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r500579367", "bodyText": "Looks like I did not need it at all as it was starting with an numeric id.\nReverted the changes and fixed code to use numeric id.", "author": "ianwallen", "createdAt": "2020-10-06T20:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNjMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxNTA2Ng==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499615066", "bodyText": "Indentation", "author": "josegar74", "createdAt": "2020-10-05T13:52:30Z", "path": "listeners/src/main/java/org/fao/geonet/listener/metadata/draft/DraftUtilities.java", "diffHunk": "@@ -111,12 +112,17 @@ public AbstractMetadata replaceMetadataWithDraft(AbstractMetadata md, AbstractMe\n             st.setOwner(old.getOwner());\n             st.setPreviousState(old.getPreviousState());\n             st.setStatusValue(old.getStatusValue());\n-            MetadataStatusId id = new MetadataStatusId();\n-            id.setChangeDate(old.getId().getChangeDate());\n-            id.setStatusId(old.getId().getStatusId());\n-            id.setUserId(old.getId().getUserId());\n-            id.setMetadataId(md.getId());\n-            st.setId(id);\n+            st.setChangeDate(old.getChangeDate());\n+            st.setUserId(old.getUserId());\n+            st.setMetadataId(md.getId());\n+            st.setUuid(md.getUuid());\n+            try {\n+            st.setTitles(metadataUtils.extractTitles(Integer.toString(md.getId())));", "originalCommit": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3OTMxMQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r500579311", "bodyText": "fixed", "author": "ianwallen", "createdAt": "2020-10-06T20:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxNTA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMDY0MQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499630641", "bodyText": "To check to refactor with the code https://github.com/geonetwork/core-geonetwork/pull/4817/files#diff-668fdf0a09c1a8afb5771c9e85715598R496-R506, seem the same code", "author": "josegar74", "createdAt": "2020-10-05T14:14:53Z", "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -419,23 +442,268 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n         return metadataStatus;\n     }\n \n+    @ApiOperation(\n+            value = \"Get saved content from the status record before changes\",\n+            notes = \"\",\n+            nickname = \"showStatusBefore\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/before\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Previous version of the record.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusBefore(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getPreviousState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Get saved content from the status record after changes\",\n+            notes = \"\",\n+            nickname = \"showStatusAfter\")\n+    @RequestMapping(value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/after\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Version of the record after changes.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusAfter(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Changes cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getCurrentState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for metadata record '%d', user '%s' at date '%s'. Changes state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getCurrentState();", "originalCommit": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxODg1Nw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r502018857", "bodyText": "refactored code for before/after api so that that they use common code.", "author": "ianwallen", "createdAt": "2020-10-08T21:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMDY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMTIxMA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499631210", "bodyText": "To check to refactor with the code https://github.com/geonetwork/core-geonetwork/pull/4817/files#diff-668fdf0a09c1a8afb5771c9e85715598R496-R506, seem the same code", "author": "josegar74", "createdAt": "2020-10-05T14:15:40Z", "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -419,23 +442,268 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n         return metadataStatus;\n     }\n \n+    @ApiOperation(\n+            value = \"Get saved content from the status record before changes\",\n+            notes = \"\",\n+            nickname = \"showStatusBefore\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/before\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Previous version of the record.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusBefore(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getPreviousState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Get saved content from the status record after changes\",\n+            notes = \"\",\n+            nickname = \"showStatusAfter\")\n+    @RequestMapping(value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/after\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Version of the record after changes.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusAfter(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Changes cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getCurrentState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for metadata record '%d', user '%s' at date '%s'. Changes state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getCurrentState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Restore saved content from a status record\",\n+            notes = \"\",\n+            nickname = \"restoreAtStatusSave\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/restore\",\n+            method = RequestMethod.POST\n+            )\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Record restored.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public void restoreAtStatusSave(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+            )\n+                    throws Exception {\n+\n+        ApplicationContext applicationContext = ApplicationContextHolder.get();\n+        DataManager dataMan = applicationContext.getBean(DataManager.class);\n+\n+        MetadataStatus metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Record cannot be restored\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"The recover for this element is not supported. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) +\n+                    \"'. Received status type '\" + metadataStatus.getStatusValue().getType() + \"' with status id '\" + statusId + \"'\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Record cannot be restrored\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        AbstractMetadata metadata = null;", "originalCommit": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxODkzNQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r502018935", "bodyText": "refactored code for before/after api so that that they use common code.", "author": "ianwallen", "createdAt": "2020-10-08T21:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMTIxMA=="}], "type": "inlineReview"}, {"oid": "2ce1d69ec12e741e03e7725731a4e3ef363160a8", "url": "https://github.com/geonetwork/core-geonetwork/commit/2ce1d69ec12e741e03e7725731a4e3ef363160a8", "message": "Revert grouprepository findOne as it was not required.\nFixed indentation\nGet first language in case there are multiple for the dc:language.", "committedDate": "2020-10-06T20:33:50Z", "type": "commit"}, {"oid": "da9721301c688b6579519fc66f4502aa846d2498", "url": "https://github.com/geonetwork/core-geonetwork/commit/da9721301c688b6579519fc66f4502aa846d2498", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix", "committedDate": "2020-10-07T14:38:58Z", "type": "commit"}, {"oid": "21b5b30540940648e71f056e7f9dbb756d2111df", "url": "https://github.com/geonetwork/core-geonetwork/commit/21b5b30540940648e71f056e7f9dbb756d2111df", "message": "Another fix for groupowner - for sample data which does not belong to a group.\nRenamed deleteAllByMetadataId back to deleteAllById_MetadataId - There are lots of others that should be renamed and this will be done as separate pr.\nRevert api calls using uuid as it could cause issues with drafts.\n    Updated api to support metadataUuid being a metadata id or uuid", "committedDate": "2020-10-08T15:28:09Z", "type": "commit"}, {"oid": "9a8f80fc696fa93d4bbc39972bbe0b35a90033a8", "url": "https://github.com/geonetwork/core-geonetwork/commit/9a8f80fc696fa93d4bbc39972bbe0b35a90033a8", "message": "Removed sequence name from annotation - issue will be resolved in version 4 of geonetwork (see https://github.com/geonetwork/core-geonetwork/pull/5003)\nupdate migration to support sequence or hybernate_sequence", "committedDate": "2020-10-08T16:07:03Z", "type": "commit"}, {"oid": "cd0ece6fe57126036e2e6128e9df77b2b9df483a", "url": "https://github.com/geonetwork/core-geonetwork/commit/cd0ece6fe57126036e2e6128e9df77b2b9df483a", "message": "Refactor - cleanup duplicate code for showing before/after versions.", "committedDate": "2020-10-08T21:18:27Z", "type": "commit"}, {"oid": "3c0bbe48728259c8fcefea3235e295da4bdaaa88", "url": "https://github.com/geonetwork/core-geonetwork/commit/3c0bbe48728259c8fcefea3235e295da4bdaaa88", "message": "Fix encoding issue. - File should be UTF-8", "committedDate": "2020-10-09T11:38:30Z", "type": "commit"}, {"oid": "e6274d205f7de08c837fd2a5de6ad0c39de12cc1", "url": "https://github.com/geonetwork/core-geonetwork/commit/e6274d205f7de08c837fd2a5de6ad0c39de12cc1", "message": "Titles will be null on migration so allow for null values. Otherwise jpa calls may fail.", "committedDate": "2020-10-09T11:40:10Z", "type": "commit"}, {"oid": "f2670b19538a30733f6a131f369818c03b05491a", "url": "https://github.com/geonetwork/core-geonetwork/commit/f2670b19538a30733f6a131f369818c03b05491a", "message": "Added some corrections so that the migration works with PostgreSQL", "committedDate": "2020-10-14T11:41:31Z", "type": "commit"}, {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3", "url": "https://github.com/geonetwork/core-geonetwork/commit/73accd2229c4e308868c2e1791a3c0e7e88dd9e3", "message": "Added xsl to extra titles for iso19115-3.2018", "committedDate": "2020-10-14T15:06:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MjczMA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510692730", "bodyText": "To check if this code can be changed by AccessManager.getGroups", "author": "josegar74", "createdAt": "2020-10-23T07:38:09Z", "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -497,41 +687,219 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n \n     private String extractCurrentStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTADDED:\n-            return s.getCurrentState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDPROCESSINGCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n-        case StatusValue.Events.RECORDCATEGORYCHANGE:\n-            List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n-                    \"name\");\n-            StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n-            for (String categoryName : categories) {\n-                categoriesAsString.append(categoryName + \" \");\n-            }\n-            categoriesAsString.append(\"]\");\n-            return categoriesAsString.toString();\n-        case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n-            return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTADDED:\n+                return s.getCurrentState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDPROCESSINGCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n+            case StatusValue.Events.RECORDCATEGORYCHANGE:\n+                List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n+                        \"name\");\n+                StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n+                for (String categoryName : categories) {\n+                    categoriesAsString.append(categoryName + \" \");\n+                }\n+                categoriesAsString.append(\"]\");\n+                return categoriesAsString.toString();\n+            case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n+                return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n+            default:\n+                return \"\";\n         }\n     }\n \n     private String extractPreviousStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTDELETED:\n-            return s.getPreviousState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTDELETED:\n+                return s.getPreviousState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            default:\n+                return \"\";\n+        }\n+    }\n+\n+    private void checkCanViewStatus(String metadata, MetadataStatus metadataStatus, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+        Element xmlElement = null;\n+        try {\n+            xmlElement = Xml.loadString(metadata, false);\n+        } catch (JDOMParseException ex) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"XML fragment is invalid. Error is %s\", ex.getMessage()));\n+        }\n+\n+        Element info = xmlElement.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't locate required geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))\n+                        .and(UserGroupSpecs.hasUserId(user.getUserIdAsInt()))\n+                        .and(UserGroupSpecs.hasGroupId(Integer.valueOf(groupId)));\n+\n+                final List<UserGroup> userGroups = userGroupRepository.findAll(spec);\n+\n+                if (userGroups.size() == 0) {\n+                    throw new SecurityException(\n+                            String.format(\"You can't view history from this group (\" + groupOwnerName + \"). User MUST be an Editor in that group\"));\n+                }\n+            } else {\n+                throw new SecurityException(\n+                        String.format(\"Error identify group where this metadata belong to. Only administrator can restore this record\"));\n+            }\n         }\n     }\n \n+    private int reloadRecord(MetadataStatus metadataStatus, Element md, IMetadataManager iMetadataManager, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+\n+        Element info = md.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't location geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        md = metadataUtils.removeMetadataInfo(md);\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))", "originalCommit": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MjgwNw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510692807", "bodyText": "To check if this code can be changed by AccessManager.getGroups", "author": "josegar74", "createdAt": "2020-10-23T07:38:18Z", "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -497,41 +687,219 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n \n     private String extractCurrentStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTADDED:\n-            return s.getCurrentState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDPROCESSINGCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n-        case StatusValue.Events.RECORDCATEGORYCHANGE:\n-            List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n-                    \"name\");\n-            StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n-            for (String categoryName : categories) {\n-                categoriesAsString.append(categoryName + \" \");\n-            }\n-            categoriesAsString.append(\"]\");\n-            return categoriesAsString.toString();\n-        case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n-            return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTADDED:\n+                return s.getCurrentState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDPROCESSINGCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n+            case StatusValue.Events.RECORDCATEGORYCHANGE:\n+                List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n+                        \"name\");\n+                StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n+                for (String categoryName : categories) {\n+                    categoriesAsString.append(categoryName + \" \");\n+                }\n+                categoriesAsString.append(\"]\");\n+                return categoriesAsString.toString();\n+            case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n+                return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n+            default:\n+                return \"\";\n         }\n     }\n \n     private String extractPreviousStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTDELETED:\n-            return s.getPreviousState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTDELETED:\n+                return s.getPreviousState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            default:\n+                return \"\";\n+        }\n+    }\n+\n+    private void checkCanViewStatus(String metadata, MetadataStatus metadataStatus, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+        Element xmlElement = null;\n+        try {\n+            xmlElement = Xml.loadString(metadata, false);\n+        } catch (JDOMParseException ex) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"XML fragment is invalid. Error is %s\", ex.getMessage()));\n+        }\n+\n+        Element info = xmlElement.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't locate required geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))", "originalCommit": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5NDQ0NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510694444", "bodyText": "Remove commented code", "author": "josegar74", "createdAt": "2020-10-23T07:41:27Z", "path": "web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright (C) 2001-2018 Food and Agriculture Organization of the\n+ * United Nations (FAO-UN), United Nations World Food Programme (WFP)\n+ * and United Nations Environment Programme (UNEP)\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation; either version 2 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+ *\n+ * Contact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+ * Rome - Italy. email: geonetwork@osgeo.org\n+ */\n+\n+package v3110;\n+\n+import org.fao.geonet.DatabaseMigrationTask;\n+import org.fao.geonet.domain.MetadataStatus;\n+import org.fao.geonet.domain.MetadataStatus_;\n+import org.fao.geonet.kernel.datamanager.IMetadataUtils;\n+import org.fao.geonet.constants.Geonet;\n+import org.fao.geonet.repository.MetadataStatusRepository;\n+import org.fao.geonet.utils.Log;\n+import org.hibernate.dialect.Dialect;\n+import org.hibernate.engine.jdbc.dialect.internal.StandardDialectResolver;\n+import org.hibernate.engine.jdbc.dialect.spi.DatabaseMetaDataDialectResolutionInfoAdapter;\n+import org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.PageRequest;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import java.sql.*;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Class to be executed during the migration which will update some new not null columns\n+ * on the metadataStatus table.\n+ *\n+ * Note: After this step is complete most of the changes should be in place however their may still be\n+ * some missing JPA settings that would initially fail due to these NOT NULL columns.\n+ *\n+ * It is recommended that after the initial startup and migration execution that the system be stopped and\n+ * restarted to ensure that all JPA settings are applied correctly.\n+ */\n+public class UpdateMetadataStatus extends DatabaseMigrationTask {\n+\n+    private MetadataStatusRepository metadataStatusRepository;\n+    private IMetadataUtils metadataUtils;\n+\n+    /**\n+     * Override the setContext so do the autowire of the other fields.\n+     * @param applicationContext\n+     */\n+    @Override\n+    public void setContext(ApplicationContext applicationContext)  {\n+        super.setContext(applicationContext);\n+        metadataUtils = applicationContext.getBean(IMetadataUtils.class);\n+        metadataStatusRepository = applicationContext.getBean(MetadataStatusRepository.class);\n+    }\n+\n+    /**\n+     * Maing flow for the updating of the ID. UUID and TITLES fields\n+     * @param connection\n+     * @throws SQLException\n+     */\n+        @Override\n+    public void update(Connection connection) throws SQLException {\n+\n+        final MetadataStatus metadataStatusObject = new MetadataStatus();\n+\n+            DialectResolutionInfo dialectResolutionInfo = new DatabaseMetaDataDialectResolutionInfoAdapter(connection.getMetaData());\n+            Dialect dialect = new StandardDialectResolver().resolveDialect(dialectResolutionInfo);\n+\n+            Log.debug(Geonet.DB, \"UpdateMetadataStatus\");\n+\n+            // First add the id and uuid as nullable.\n+            addMissingColumn(connection, dialect);\n+\n+            // Now update the id to sequence values so that all id's are not null.\n+            updatePKValue(connection, dialect);\n+\n+            // Now update uuid and titles for the existing records\n+            updateOtherNewFields();\n+            // commit the changes\n+            connection.commit();\n+\n+            // finallize the change\n+            finalizeChanges(connection, dialect);\n+    }\n+\n+    /**\n+     *  JPA will not be able to create the ID and UUID because they are not null\n+     *  So we need to add them as nullable initially until we update all the data in the tables.\n+     *\n+     * @param connection\n+     * @param dialect - specific to each database - i.e. oracke, h2, postgresl...\n+     * @throws SQLException\n+     */\n+    private void addMissingColumn(final Connection connection, Dialect dialect ) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            statement.execute(\"ALTER TABLE \" + MetadataStatus.TABLE_NAME + \" \" + dialect.getAddColumnString() + \"  \" + MetadataStatus_.id.getName() + \" INTEGER NULL\");\n+        } catch (Exception e) {\n+            // If there was an error then we will log the error and continue.\n+            // Most likely cause is that the column already exists which should be fine.\n+            Log.error(Geonet.DB, \"  Exception while adding new \" + MetadataStatus_.id.getName() + \" column to \" + MetadataStatus.TABLE_NAME + \". \" + \n+                    \"Error is: \" + e.getMessage());\n+            Log.debug(Geonet.DB, e);\n+        }\n+        try (Statement statement = connection.createStatement()) {\n+            statement.execute(\"ALTER TABLE \" + MetadataStatus.TABLE_NAME + \" \" + dialect.getAddColumnString() + \"  \" + MetadataStatus_.uuid.getName() + \" VARCHAR(255) NULL\");\n+        } catch (Exception e) {\n+            // If there was an erro then we will log the error and continue.\n+            // Most likely cause is that the column already exists which should be fine.\n+            Log.error(Geonet.DB, \"  Exception while adding new \" + MetadataStatus_.uuid.getName() + \" column to \" + MetadataStatus.TABLE_NAME + \". \" +\n+                    \"Error is: \" + e.getMessage());\n+            Log.debug(Geonet.DB, e);\n+        }\n+\n+        connection.commit();\n+    }\n+\n+    /**\n+     * Update the ID (primary key field) for the database to be equal to the sequence values.\n+     * @param connection\n+     * @param dialect - specific to each database - i.e. oracke, h2, postgresl...\n+     * @throws SQLException\n+     */\n+\n+    private void updatePKValue(final Connection connection, Dialect dialect) throws SQLException {\n+\n+        String HIBERNATE_SEQUENCE = getDatabaseObjectName(connection, \"HIBERNATE_SEQUENCE\");\n+\n+        Statement statement = null;\n+        Integer rowcount = null;\n+        try {\n+            statement = connection.createStatement();\n+            try {\n+                rowcount = statement.executeUpdate(\"update \" + MetadataStatus.TABLE_NAME +\n+                        \" set \" + MetadataStatus_.id.getName() + \" = \" + dialect.getSelectSequenceNextValString(MetadataStatus.ID_SEQ_NAME) +\n+                        \" where \" + MetadataStatus_.id.getName() + \" IS NULL\");\n+            } catch (SQLException e1) {\n+                try {\n+                    connection.rollback();\n+                    if (statement != null) {\n+                        statement.close();\n+                    }\n+                    statement = connection.createStatement();\n+                    rowcount = statement.executeUpdate(\"update \" + MetadataStatus.TABLE_NAME +\n+                            \" set \" + MetadataStatus_.id.getName() + \" = \" + dialect.getSelectSequenceNextValString(HIBERNATE_SEQUENCE) +\n+                            \" where \" + MetadataStatus_.id.getName() + \" IS NULL\");\n+                } catch (SQLException e2) {\n+                    throw new SQLException(\"Error updating table \\\"\" + MetadataStatus.TABLE_NAME + \".\" + MetadataStatus_.id.getName() +\n+                            \"\\\" values to sequence value using sequence \\\"\" + MetadataStatus.ID_SEQ_NAME + \"\\\" and \\\"\" + HIBERNATE_SEQUENCE + \"\\\"\\n\" + e1.getMessage() + \"\\n\", e2);\n+                }\n+            }\n+        } finally {\n+            if (statement != null) {\n+                statement.close();\n+            }\n+        }\n+\n+        // Need to commit changes or they it will not be available to JPA calls.\n+        connection.commit();\n+\n+        Log.info(Geonet.DB, \"Migration: Updated \" + rowcount + \" primary key values for '\" + MetadataStatus.TABLE_NAME + \"'\");\n+    }\n+\n+    /**\n+     * Update the new UUID and Titles field based on existing data.\n+     * @throws SQLException\n+     */\n+    private void updateOtherNewFields() throws SQLException {\n+\n+        Pageable pageRequest = new PageRequest(0, 1000, new Sort(\"id\"));\n+        int totalRowCount = 0;\n+        int updateRowCount = 0;\n+        int uuidRowCount = 0;\n+        int titleRowCount = 0;\n+        Map<Integer, LinkedHashMap<String, String>> titlesMap = new HashMap<>();\n+        Map<Integer, String> uuidMap = new HashMap<>();\n+        //List<Language> languages = languageRepository.findAll();\n+        Page<MetadataStatus> page;\n+        do {\n+            page = metadataStatusRepository.findAll(pageRequest);\n+            if (page != null && page.hasContent()) {\n+                for (MetadataStatus metadataStatus : page.getContent()) {\n+                    totalRowCount++;\n+                    if (metadataStatus.getUuid() == null || metadataStatus.getUuid().length() == 0 ||\n+                            metadataStatus.getTitles() == null || metadataStatus.getTitles().size() == 0) {\n+\n+                        boolean changeflag = false;\n+                        if (metadataStatus.getUuid() == null || metadataStatus.getUuid().length() == 0) {\n+                            String uuid = uuidMap.get(metadataStatus.getMetadataId());\n+                            if (uuid == null) {\n+                                try {\n+                                    uuid = metadataUtils.getMetadataUuid(Integer.toString(metadataStatus.getMetadataId()));\n+                                    if (uuid != null) {\n+                                        uuidMap.put(metadataStatus.getMetadataId(), uuid);\n+                                    }\n+                                } catch (Exception e) {\n+                                    Log.error(Geonet.DATA_MANAGER, String.format(\n+                                            \"Error locating uuid for metadata id: %d\", +metadataStatus.getMetadataId()), e);\n+                                }\n+                                if (uuid == null || uuid.length() == 0) {\n+                                    Log.error(Geonet.DATA_MANAGER, String.format(\n+                                            \"Could not located uuid for metadata id: %d\", + metadataStatus.getMetadataId()));\n+                                }\n+                            }\n+                            if (uuid != null && uuid.length() > 0) {\n+                                metadataStatus.setUuid(uuid);\n+                                uuidRowCount++;\n+                                changeflag = true;\n+                            }\n+                        }\n+                        if (metadataStatus.getTitles() == null || metadataStatus.getTitles().size() == 0) {\n+                            LinkedHashMap<String, String> titles = titlesMap.get(metadataStatus.getMetadataId());\n+                            // Try to get the titles from the schema.", "originalCommit": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1be3cb73c9f3e1afbb84d8a7d2168ab029c0abe0", "url": "https://github.com/geonetwork/core-geonetwork/commit/1be3cb73c9f3e1afbb84d8a7d2168ab029c0abe0", "message": "Update permission check to use AccessManager.getGroups\nRemoved comments", "committedDate": "2020-10-24T11:23:42Z", "type": "commit"}, {"oid": "3554e56fb79fc63362ea53d675ee52857801afe0", "url": "https://github.com/geonetwork/core-geonetwork/commit/3554e56fb79fc63362ea53d675ee52857801afe0", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix\n\n# Conflicts:\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-default.sql\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-mysql.sql\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-oracle.sql", "committedDate": "2020-11-05T19:12:02Z", "type": "commit"}]}