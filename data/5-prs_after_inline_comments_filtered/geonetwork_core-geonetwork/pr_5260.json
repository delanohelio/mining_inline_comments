{"pr_number": 5260, "pr_title": "Review ServiceContext resource leak", "pr_createdAt": "2020-12-14T06:21:44Z", "pr_url": "https://github.com/geonetwork/core-geonetwork/pull/5260", "timeline": [{"oid": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "url": "https://github.com/geonetwork/core-geonetwork/commit/a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2020-12-14T06:57:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE5NjY0Ng==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r542196646", "bodyText": "This is pretty ugly coding, keeping a throwable in order to report back who called setAsThreadLocal() in case of future conflict (the approach may confuse debuggers configured to stop when a Throwable is created).", "author": "jodygarnett", "createdAt": "2020-12-14T08:31:35Z", "path": "core/src/main/java/jeeves/server/context/ServiceContext.java", "diffHunk": "@@ -115,10 +160,168 @@ public static ServiceContext get() {\n \n     /**\n      * Called to set the Service context for this thread and inherited threads.\n+     *\n+     * If you call this method you are responsible for thread context management and {@link #clearAsThreadLocal()}.\n+     * <pre>\n+     * try {\n+     *     context.setAsThreadLocal();\n+     * }\n+     * finally {\n+     *     context.clearAsThreadLocal();\n+     * }\n+     * </pre>\n      */\n     public void setAsThreadLocal() {\n+        ServiceContext check = THREAD_LOCAL_INSTANCE.get();\n+\n+        if( POLICY == ThreadLocalPolicy.DIRECT || check == null){\n+            // step one set thread local\n+            THREAD_LOCAL_INSTANCE.set(this);\n+            // step two ensure ApplicationContextHolder thread local kept in sync\n+            ApplicationContextHolder.set(this.getApplicationContext());\n+            // step three details on allocation\n+            allocation = new Throwable(\"ServiceContext allocated to thread\");", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701753", "bodyText": "This seem not used later.", "author": "josegar74", "createdAt": "2020-12-21T13:20:59Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0NzQzNQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547047435", "bodyText": "I did not change any logic here, however I can can see how would be used ... if an exception is thrown during doRollback then the catch Throwable t on line 126 would wish to check this flag.", "author": "jodygarnett", "createdAt": "2020-12-22T03:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MDE0Nw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547090147", "bodyText": "Added debug messages to mimic the kind of checks I was performing with the debugger.", "author": "jodygarnett", "createdAt": "2020-12-22T06:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTg1OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701858", "bodyText": "This seem not used later.", "author": "josegar74", "createdAt": "2020-12-21T13:21:13Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                if (!rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTA0OQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547051049", "bodyText": "You are correct, this I think is the last one. I would leave it as written:\na) To be be clear of rollBack state (setting with try/finally after each call to doRollback\nb) This way you can put a breakpoint in a debugger, or add more logic after this catch and be clear what is going on....\nA more interesting question, if you look at the previous logic, should I set rolledBack = true before calling the doRollback method?", "author": "jodygarnett", "createdAt": "2020-12-22T03:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTk1OQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701959", "bodyText": "This seem not used later.", "author": "josegar74", "createdAt": "2020-12-21T13:21:27Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MDQ4NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547050484", "bodyText": "See line 126, we are trying to prevent duplicate rollback.\nAside: Trying for minimal change the previous tested logic. With more time I would refactor into multiple methods to clearly document what each branch of logic is trying to do etc...", "author": "jodygarnett", "createdAt": "2020-12-22T03:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjg4NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546702884", "bodyText": "Is the intention that the code continues?", "author": "josegar74", "createdAt": "2020-12-21T13:23:32Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -113,43 +148,158 @@\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        try {\n+            fireBeforeCommit(context, transactionManager, transaction);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+        try {\n+            transactionManager.commit(transaction);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, transaction);\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n+            }\n+        }\n+    }\n+\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterCommitFailure = null;\n+\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n+        }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n         }\n+    }\n \n-        transactionManager.commit(transaction);\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    private static void fireNewTransaction(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                    PlatformTransactionManager transactionManager,\n+                                    @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n                                    @Nullable TransactionStatus transaction) {\n+        if ( transaction == null || transaction.isCompleted()){\n+            // nothing to do", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTQ2NQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547051465", "bodyText": "no, reading the previous logic I should have a return. Idea was to change the check to be postive, general principle to improve legibility.", "author": "jodygarnett", "createdAt": "2020-12-22T03:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNDM3Mg==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546704372", "bodyText": "In previous code when a listener failed, seem no further processing, now all are processed and thrown the exception of the last one that fails. It can be fine, but want to confirm that is the intention.", "author": "josegar74", "createdAt": "2020-12-21T13:26:26Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -113,43 +148,158 @@\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        try {\n+            fireBeforeCommit(context, transactionManager, transaction);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+        try {\n+            transactionManager.commit(transaction);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, transaction);\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n+            }\n+        }\n+    }\n+\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterCommitFailure = null;\n+\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n+        }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n         }\n+    }\n \n-        transactionManager.commit(transaction);\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    private static void fireNewTransaction(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                    PlatformTransactionManager transactionManager,\n+                                    @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(transaction);\n+            }\n+            catch (Throwable t){", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0OTc1Ng==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547049756", "bodyText": "Yes that was my intension, trying to read the code and check the listener api contracts and make the application more predictable.\nThere was nothing explicit in the api about allowing listeners to halt the notification process (sometimes in core java api listeners are allowed to return \"true\" if they have addressed an event to prevent further processing).", "author": "jodygarnett", "createdAt": "2020-12-22T03:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNDM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNzM5NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546707394", "bodyText": "To confirm no need to call _context.clear() as this code runs in a custom thread?", "author": "josegar74", "createdAt": "2020-12-21T13:32:47Z", "path": "core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java", "diffHunk": "@@ -125,6 +125,7 @@ public void run() {\n             Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n+            _context.clearAsThreadLocal();", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1OTM3NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547059374", "bodyText": "This may be a case where a task is sharing a context, so calling clear() breaks another task.\nLong term it may be smart to implement reference counting, or a context wrapper, when providing the same context to more than one thread.", "author": "jodygarnett", "createdAt": "2020-12-22T04:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwODYxNg==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546708616", "bodyText": "I see some code in the API package creating a ServiceContext, but not calling the clear method at the end (for example: \n  \n    \n      core-geonetwork/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java\n    \n    \n        Lines 189 to 258\n      in\n      23910ce\n    \n    \n    \n    \n\n        \n          \n           public void getGroupLogo( \n        \n\n        \n          \n               @ApiParam(value = \"Group identifier\", required = true) @PathVariable(value = \"groupId\") final Integer groupId, \n        \n\n        \n          \n               @ApiIgnore final WebRequest webRequest, \n        \n\n        \n          \n               HttpServletRequest request, \n        \n\n        \n          \n               HttpServletResponse response) throws ResourceNotFoundException { \n        \n\n        \n          \n            \n        \n\n        \n          \n               Locale locale = languageUtils.parseAcceptLanguage(request.getLocales()); \n        \n\n        \n          \n            \n        \n\n        \n          \n               ApplicationContext context = ApplicationContextHolder.get(); \n        \n\n        \n          \n               ServiceContext serviceContext = ApiUtils.createServiceContext(request, locale.getISO3Country()); \n        \n\n        \n          \n               if (context == null) { \n        \n\n        \n          \n                   throw new RuntimeException(\"ServiceContext not available\"); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               Group group = groupRepository.findOne(groupId); \n        \n\n        \n          \n               if (group == null) { \n        \n\n        \n          \n                   throw new ResourceNotFoundException(messages.getMessage(\"api.groups.group_not_found\", new \n        \n\n        \n          \n                       Object[]{groupId}, locale)); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               try { \n        \n\n        \n          \n                   final Resources resources = context.getBean(Resources.class); \n        \n\n        \n          \n                   final String logoUUID = group.getLogo(); \n        \n\n        \n          \n                   if (StringUtils.isNotBlank(logoUUID) && !logoUUID.startsWith(\"http://\") && !logoUUID.startsWith(\"https//\")) { \n        \n\n        \n          \n                       try (Resources.ResourceHolder image = getImage(resources, serviceContext, group)){ \n        \n\n        \n          \n                           if (image != null) { \n        \n\n        \n          \n                               FileTime lastModifiedTime = image.getLastModifiedTime(); \n        \n\n        \n          \n                               response.setDateHeader(\"Expires\", System.currentTimeMillis() + SIX_HOURS * 1000L); \n        \n\n        \n          \n                               if (webRequest.checkNotModified(lastModifiedTime.toMillis())) { \n        \n\n        \n          \n                                   // webRequest.checkNotModified sets the right HTTP headers \n        \n\n        \n          \n                                   return; \n        \n\n        \n          \n                               } \n        \n\n        \n          \n                               response.setContentType(AttachmentsApi.getFileContentType(image.getPath())); \n        \n\n        \n          \n                               response.setContentLength((int) Files.size(image.getPath())); \n        \n\n        \n          \n                               response.addHeader(\"Cache-Control\", \"max-age=\" + SIX_HOURS + \", public\"); \n        \n\n        \n          \n                               FileUtils.copyFile(image.getPath().toFile(), response.getOutputStream()); \n        \n\n        \n          \n                               return; \n        \n\n        \n          \n                           } \n        \n\n        \n          \n                       } \n        \n\n        \n          \n                   } \n        \n\n        \n          \n            \n        \n\n        \n          \n                   // no logo image found. Return a transparent 1x1 png \n        \n\n        \n          \n                   FileTime lastModifiedTime = FileTime.fromMillis(0); \n        \n\n        \n          \n                   if (webRequest.checkNotModified(lastModifiedTime.toMillis())) { \n        \n\n        \n          \n                       return; \n        \n\n        \n          \n                   } \n        \n\n        \n          \n                   response.setContentType(\"image/png\"); \n        \n\n        \n          \n                   response.setContentLength(TRANSPARENT_1_X_1_PNG.length); \n        \n\n        \n          \n                   response.addHeader(\"Cache-Control\", \"max-age=\" + SIX_HOURS + \", public\"); \n        \n\n        \n          \n                   response.getOutputStream().write(TRANSPARENT_1_X_1_PNG); \n        \n\n        \n          \n            \n        \n\n        \n          \n               } catch (IOException e) { \n        \n\n        \n          \n                   Log.error(LOGGER, String.format(\"There was an error accessing the logo of the group with id '%d'\", \n        \n\n        \n          \n                       groupId)); \n        \n\n        \n          \n                   throw new RuntimeException(e); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           private static Resources.ResourceHolder getImage(Resources resources, ServiceContext serviceContext, Group group) throws IOException { \n        \n\n        \n          \n               final Path logosDir = resources.locateLogosDir(serviceContext); \n        \n\n        \n          \n               final Path harvesterLogosDir = resources.locateHarvesterLogosDir(serviceContext); \n        \n\n        \n          \n               final String logoUUID = group.getLogo(); \n        \n\n        \n          \n               Resources.ResourceHolder image = null; \n        \n\n        \n          \n               if (StringUtils.isNotBlank(logoUUID) && !logoUUID.startsWith(\"http://\") && !logoUUID.startsWith(\"https//\")) { \n        \n\n        \n          \n                   image = resources.getImage(serviceContext, logoUUID, logosDir); \n        \n\n        \n          \n                   if (image == null) { \n        \n\n        \n          \n                       image = resources.getImage(serviceContext, logoUUID, harvesterLogosDir); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n               return image; \n        \n\n        \n          \n           } \n        \n    \n  \n\n)\nIs this due to the way of creating the ServiceContext (serviceManager.createServiceContext vs ApiUtils.createServiceContext)?", "author": "josegar74", "createdAt": "2020-12-21T13:35:13Z", "path": "services/src/main/java/org/fao/geonet/api/records/formatters/Register.java", "diffHunk": "@@ -145,6 +145,7 @@ public JSONObject serviceSpecificExec(HttpServletRequest request,\n             return response;\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n+            context.clear();", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5NDk0MA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547094940", "bodyText": "I expect more instances of clear() can be added over time, especially if you can confirm how it is used.", "author": "jodygarnett", "createdAt": "2020-12-22T06:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwODYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwOTM1OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546709358", "bodyText": "This code seem more for testing?", "author": "josegar74", "createdAt": "2020-12-21T13:36:42Z", "path": "web/src/main/java/org/fao/geonet/GeonetworkHttpSessionListener.java", "diffHunk": "@@ -0,0 +1,111 @@\n+//=============================================================================\n+//===\tCopyright (C) 2001-2007 Food and Agriculture Organization of the\n+//===\tUnited Nations (FAO-UN), United Nations World Food Programme (WFP)\n+//===\tand United Nations Environment Programme (UNEP)\n+//===\n+//===\tThis program is free software; you can redistribute it and/or modify\n+//===\tit under the terms of the GNU General Public License as published by\n+//===\tthe Free Software Foundation; either version 2 of the License, or (at\n+//===\tyour option) any later version.\n+//===\n+//===\tThis program is distributed in the hope that it will be useful, but\n+//===\tWITHOUT ANY WARRANTY; without even the implied warranty of\n+//===\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+//===\tGeneral Public License for more details.\n+//===\n+//===\tYou should have received a copy of the GNU General Public License\n+//===\talong with this program; if not, write to the Free Software\n+//===\tFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+//===\n+//===\tContact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+//===\tRome - Italy. email: geonetwork@osgeo.org\n+//==============================================================================\n+package org.fao.geonet;\n+\n+import jeeves.config.springutil.JeevesApplicationContext;\n+import jeeves.constants.Jeeves;\n+import jeeves.server.UserSession;\n+import org.fao.geonet.utils.Log;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpSessionEvent;\n+import javax.servlet.http.HttpSessionListener;\n+import java.util.Enumeration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Used to keep track of the number of active sessions.\\\n+ */\n+public class GeonetworkHttpSessionListener implements HttpSessionListener {", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MDQyMw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547090423", "bodyText": "It produces debug log messages that can be enabled in the field if needed", "author": "jodygarnett", "createdAt": "2020-12-22T06:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwOTM1OA=="}], "type": "inlineReview"}, {"oid": "9cebf79164064053563624e367a26a52a109c387", "url": "https://github.com/geonetwork/core-geonetwork/commit/9cebf79164064053563624e367a26a52a109c387", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2021-01-05T20:20:07Z", "type": "forcePushed"}, {"oid": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "url": "https://github.com/geonetwork/core-geonetwork/commit/a908c404ad2563809a67a9ebe71a3ce507531ef7", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-01-08T15:35:37Z", "type": "forcePushed"}, {"oid": "28605f0b877e44ea7fe5c31661b094e160382973", "url": "https://github.com/geonetwork/core-geonetwork/commit/28605f0b877e44ea7fe5c31661b094e160382973", "message": "Add debug logging for HTTP session created / destroyed\n\nUsed to track potential service context leaks.", "committedDate": "2021-02-23T22:17:37Z", "type": "commit"}, {"oid": "b8103a85dd637545b8ab5ef75f0c4b17bf745622", "url": "https://github.com/geonetwork/core-geonetwork/commit/b8103a85dd637545b8ab5ef75f0c4b17bf745622", "message": "ServiceLocator API contract for setAsThreadLocal() / clearAsThreadLocal() / clear()\n\nDocument api contract with respect to clearing up thread local use.", "committedDate": "2021-02-23T22:17:55Z", "type": "commit"}, {"oid": "fad3719aea04704cd7fee77b5d6333bc033a5f62", "url": "https://github.com/geonetwork/core-geonetwork/commit/fad3719aea04704cd7fee77b5d6333bc033a5f62", "message": "Introduce try / finally managmeent of ServiceContext", "committedDate": "2021-02-24T00:05:18Z", "type": "commit"}, {"oid": "210b97b3d149bc504475f0de966060190d3e1a42", "url": "https://github.com/geonetwork/core-geonetwork/commit/210b97b3d149bc504475f0de966060190d3e1a42", "message": "Clear XFrameOptionsFilter cache", "committedDate": "2021-02-24T00:08:28Z", "type": "commit"}, {"oid": "e3fc0b3310f9a4d8889005c968a7c90ebfb8d66e", "url": "https://github.com/geonetwork/core-geonetwork/commit/e3fc0b3310f9a4d8889005c968a7c90ebfb8d66e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T00:22:48Z", "type": "forcePushed"}, {"oid": "f98fb566bc604e5eb609a389b65889cd062b946b", "url": "https://github.com/geonetwork/core-geonetwork/commit/f98fb566bc604e5eb609a389b65889cd062b946b", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2021-02-24T05:14:25Z", "type": "commit"}, {"oid": "9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "url": "https://github.com/geonetwork/core-geonetwork/commit/9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T05:14:41Z", "type": "commit"}, {"oid": "9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "url": "https://github.com/geonetwork/core-geonetwork/commit/9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T05:14:41Z", "type": "forcePushed"}]}