{"pr_number": 1387, "pr_title": "Migrating a subset of Xtend code from org.eclipse.xtext.xbase.ui project to Java", "pr_createdAt": "2020-03-31T11:36:00Z", "pr_url": "https://github.com/eclipse/xtext-eclipse/pull/1387", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NDI5Ng==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400844296", "bodyText": "Added a safety-check which was not present in the original code. The code project.findPackageFragmentRoots(sourceFolder) may return an empty array.", "author": "nbhusare", "createdAt": "2020-03-31T11:39:53Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0OTYzMQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400949631", "bodyText": "Seems fine to me especially with the extra log", "author": "tivervac", "createdAt": "2020-03-31T14:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NDI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTM4Mw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400845383", "bodyText": "Logging an error message. I chose to do it after looking at other places in the source code where JavaModelException is caught. Please suggest if you would like me to replace with a RuntimeException.", "author": "nbhusare", "createdAt": "2020-03-31T11:41:52Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0OTM3Mw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400949373", "bodyText": "Going to leave this one for @szarnekow", "author": "tivervac", "createdAt": "2020-03-31T14:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNjk4MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401226981", "bodyText": "Please only log on error level if the exception is not e.isDoesNotExist()", "author": "szarnekow", "createdAt": "2020-03-31T21:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1MDAyMw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401750023", "bodyText": "@szarnekow Should I follow through if the condition e.isDoesNotExist() is not met?", "author": "nbhusare", "createdAt": "2020-04-01T16:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTc2NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400845764", "bodyText": "Simplified the logic. The original code made use of a while-loop to find the first element for which the \u201clanguageInfo.equals(candidate.getLanguage())\u201d is true. I do the same using the new code\nIterables.tryFind - Returns an Optional containing the first element in iterable that satisfies the given predicate, if such an element exists.", "author": "nbhusare", "createdAt": "2020-03-31T11:42:35Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource != null) {\n+\t\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\t\tif (original != input) {\n+\t\t\t\treturn original;\n+\t\t\t}\n+\n+\t\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\t\tif (trace == null) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\n+\t\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NjM5OQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400846399", "bodyText": "Added a safety-check here.", "author": "nbhusare", "createdAt": "2020-03-31T11:43:39Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource != null) {\n+\t\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\t\tif (original != input) {\n+\t\t\t\treturn original;\n+\t\t\t}\n+\n+\t\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\t\tif (trace == null) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\n+\t\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),\n+\t\t\t\t\t(candidate) -> languageInfo.equals(candidate.getLanguage()));\n+\n+\t\t\tif (!sourceInformation.isPresent()) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\n+\t\t\tIStorage originalStorage = sourceInformation.get().getPlatformResource();\n+\t\t\tif (originalStorage != null) {\n+\t\t\t\treturn EditorUtils.createEditorInput(originalStorage);\n+\t\t\t}\n+\t\t}\n+\t\treturn input;\n+\t}\n+\n+\t/**\n+\t * @return the {@code IPackageFragmentRoot} that contains the provided {@code element}\n+\t * @throws NullPointerException\n+\t *             if the provided {@code element} is null\n+\t */\n+\tpublic IPackageFragmentRoot getPackageFragmentRoot(IJavaElement element) {\n+\t\tPreconditions.checkNotNull(element, \"Couldn't find source package fragment root.\");", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1MTc5MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400951790", "bodyText": "LGTM", "author": "tivervac", "createdAt": "2020-03-31T14:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NjM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzYzNg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400847636", "bodyText": "org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService is deprecated. We'll have to revisit this code and replace the deprecated API with the correct one. Corresponding change needs to be made in the XbaseUiModule#bindCopyQualifiedNameService() method.", "author": "nbhusare", "createdAt": "2020-03-31T11:46:05Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzMzQ0NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401233444", "bodyText": "Please take a look at the conversion that was applied to the org.eclipse.xtext.naming.DefaultCopyQualifiedNameService - there we use a PolymorphicDispatcher.\nI'm afraid we have to do the same here in order to remain backwards compatible.", "author": "szarnekow", "createdAt": "2020-03-31T21:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4ODgwNA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401888804", "bodyText": "I'll file a separate jira for this.", "author": "nbhusare", "createdAt": "2020-04-01T20:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwODk4NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402108984", "bodyText": "eclipse/xtext-extras#581", "author": "szarnekow", "createdAt": "2020-04-02T07:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400848354", "bodyText": "FluentIterable - A bit of inspiration from @szarnekow code.", "author": "nbhusare", "createdAt": "2020-03-31T11:47:29Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1NzI2MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400957260", "bodyText": "Does this work if declaredConstructors is null?", "author": "tivervac", "createdAt": "2020-03-31T14:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5NDQ0Mg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401194442", "bodyText": "declaredConstructors can be empty, but not null. PS - https://bit.ly/3dIG53z\nGenerally speaking, FluentIterable.from will throw a NPE if the passed param. is null.", "author": "nbhusare", "createdAt": "2020-03-31T20:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNDQ3MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401234470", "bodyText": "declaredConstructors will still be null if resolvedFeatures is null.\nThese null checks look a little too xtendy to me. Many of the intermediate local vars will never be null if the actual receiver was present.\nPlease reverse the logic and exit early but otherwise keep a normal flow.", "author": "szarnekow", "createdAt": "2020-03-31T21:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjUyOA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401236528", "bodyText": "Also my preference would always be something like\nfor(IResolvedConstructor candidate: declaredConstructors) {\n  if (constructor.equals(candidate.getDeclaration()) {\n    return candidate;\n }\n}\nreturn null", "author": "szarnekow", "createdAt": "2020-03-31T21:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzMTc2Nw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401431767", "bodyText": "It is going to be null if resolvedFeatures is null", "author": "tivervac", "createdAt": "2020-04-01T08:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc4NzkxNw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401787917", "bodyText": "You are right, I missed that.", "author": "nbhusare", "createdAt": "2020-04-01T17:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0NTUyNg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400945526", "bodyText": "Either add the ! before both equals, or do && -> ||", "author": "tivervac", "createdAt": "2020-03-31T14:11:48Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/contentassist/XbaseContentProposalPriorities.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.contentassist;\n+\n+import org.eclipse.jface.text.contentassist.ICompletionProposal;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal;\n+import org.eclipse.xtext.ui.editor.contentassist.ContentProposalPriorities;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.SimpleIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.StaticFeatureDescriptionWithTypeLiteralReceiver;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class XbaseContentProposalPriorities extends ContentProposalPriorities {\n+\n+\t@Override\n+\tpublic void adjustCrossReferencePriority(ICompletionProposal proposal, String prefix) {\n+\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n+\t\t\tConfigurableCompletionProposal configurableProposal = (ConfigurableCompletionProposal) proposal;\n+\t\t\tObject desc = configurableProposal.getAdditionalData(XbaseProposalProvider.DESCRIPTION_KEY);\n+\t\t\tif (desc instanceof SimpleIdentifiableElementDescription) {\n+\t\t\t\tif (!(\"this\".equals(configurableProposal.getReplacementString())\n+\t\t\t\t\t\t&& \"super\".equals(configurableProposal.getReplacementString()))) {", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1MDI3MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400950270", "bodyText": "Might be better to just write if (resource == null) return input;", "author": "tivervac", "createdAt": "2020-03-31T14:17:50Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource != null) {", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1MjkwNg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400952906", "bodyText": "You can remove this, it's impossible to end up here, I don't if you leave it though", "author": "tivervac", "createdAt": "2020-03-31T14:21:05Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1NDQxOQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400954419", "bodyText": "constructor*", "author": "tivervac", "createdAt": "2020-03-31T14:23:05Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(constr -> constr.getDeclaration().equals(consturctor)) //", "originalCommit": "3f972df3abd1c588fa29e30466c29b4c79693888", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4Nzg3OQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401187879", "bodyText": "Let me change it to declaredConstructor.", "author": "nbhusare", "createdAt": "2020-03-31T20:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1NDQxOQ=="}], "type": "inlineReview"}, {"oid": "996ded0b113e8053e5981ac3285d564f4fede238", "url": "https://github.com/eclipse/xtext-eclipse/commit/996ded0b113e8053e5981ac3285d564f4fede238", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-03-31T20:39:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNTE5MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401225191", "bodyText": "This will fall through to the super.adjust.. call. Not sure if that was the intention in the xtend code.", "author": "szarnekow", "createdAt": "2020-03-31T21:26:19Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/contentassist/XbaseContentProposalPriorities.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.contentassist;\n+\n+import org.eclipse.jface.text.contentassist.ICompletionProposal;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal;\n+import org.eclipse.xtext.ui.editor.contentassist.ContentProposalPriorities;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.SimpleIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.StaticFeatureDescriptionWithTypeLiteralReceiver;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class XbaseContentProposalPriorities extends ContentProposalPriorities {\n+\n+\t@Override\n+\tpublic void adjustCrossReferencePriority(ICompletionProposal proposal, String prefix) {\n+\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n+\t\t\tConfigurableCompletionProposal configurableProposal = (ConfigurableCompletionProposal) proposal;\n+\t\t\tObject desc = configurableProposal.getAdditionalData(XbaseProposalProvider.DESCRIPTION_KEY);\n+\t\t\tif (desc instanceof SimpleIdentifiableElementDescription) {\n+\t\t\t\tif (!\"this\".equals(configurableProposal.getReplacementString())\n+\t\t\t\t\t\t&& !\"super\".equals(configurableProposal.getReplacementString())) {\n+\t\t\t\t\tadjustPriority(proposal, prefix, 570);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t} else if (desc instanceof StaticFeatureDescriptionWithTypeLiteralReceiver) {\n+\t\t\t\tadjustPriority(proposal, prefix, 560);", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDQ0MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401800440", "bodyText": "PS - https://bit.ly/3bJ43Kg", "author": "nbhusare", "createdAt": "2020-04-01T17:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMDY0NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402110645", "bodyText": "I think this was a bug in the old impl.", "author": "szarnekow", "createdAt": "2020-04-02T07:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNzY5MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401227691", "bodyText": "We probably want to use org.eclipse.jdt.core.IJavaElement.getAncestor(int) here", "author": "szarnekow", "createdAt": "2020-03-31T21:31:40Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\tif (original != input) {\n+\t\t\treturn original;\n+\t\t}\n+\n+\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\tif (trace == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),\n+\t\t\t\t(candidate) -> languageInfo.equals(candidate.getLanguage()));\n+\n+\t\tif (!sourceInformation.isPresent()) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tIStorage originalStorage = sourceInformation.get().getPlatformResource();\n+\t\tif (originalStorage != null) {\n+\t\t\treturn EditorUtils.createEditorInput(originalStorage);\n+\t\t}\n+\t\t\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @return the {@code IPackageFragmentRoot} that contains the provided {@code element}\n+\t * @throws NullPointerException\n+\t *             if the provided {@code element} is null\n+\t */\n+\tpublic IPackageFragmentRoot getPackageFragmentRoot(IJavaElement element) {\n+\t\tPreconditions.checkNotNull(element, \"Couldn't find source package fragment root.\");\n+\t\treturn element instanceof IPackageFragmentRoot ? (IPackageFragmentRoot) element : getPackageFragmentRoot(element.getParent());", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMjY2MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401802660", "bodyText": "Very good suggestion. Tx.", "author": "nbhusare", "createdAt": "2020-04-01T17:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNzY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyOTMwNw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401229307", "bodyText": "Iff we change this code, we could loop over all matching packageFragmentRoots until you find one that fulfills newFile.exists() below.", "author": "szarnekow", "createdAt": "2020-03-31T21:35:04Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyOTc2NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401229764", "bodyText": "Populating a list to loop over the list on step later appears to be unnecessary. Maybe extract a few smaller methods to improve the readability and avoid the intermediate list here?", "author": "szarnekow", "createdAt": "2020-03-31T21:36:07Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzMDE2Ng==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401230166", "bodyText": "Same comment here as a few lines below: We create unnecessary lists and end up with a very long method. Maybe it's better to refactor this by extracting a few smaller methods.", "author": "szarnekow", "createdAt": "2020-03-31T21:36:58Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzMjUzMA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401232530", "bodyText": "I'd prefer a more straight forward\nfor(PlatformResource candidate: trace.getAllAssociatedLocations()) {\n  if (languageInfo.equals(candidate.getLanguage()) {\n    IStorage storage = candidate.getPlatformResource();\n    if (storage != null) {\n      return ..\n    }\n  }\n}\nreturn input;", "author": "szarnekow", "createdAt": "2020-03-31T21:42:05Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\tif (original != input) {\n+\t\t\treturn original;\n+\t\t}\n+\n+\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\tif (trace == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg0OTgwMw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401849803", "bodyText": "The above code goes through all-the-candidates until it finds one for which storage != null. If you look at the original code (https://bit.ly/2wXAeXN), it gets the first candidate that matches the condition languageInfo.equals(candidate.getLanguage()), and uses it for further processing.\n@szarnekow Is it possible for more than one candidate for which the condition languageInfo.equals(candidate.getLanguage()) is true?", "author": "nbhusare", "createdAt": "2020-04-01T19:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzMjUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNDU4NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401234585", "bodyText": "Typo in variable name", "author": "szarnekow", "createdAt": "2020-03-31T21:46:23Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} \n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(declaredConstructor -> declaredConstructor.getDeclaration().equals(consturctor)) //\n+\t\t\t\t.first();\n+\t\treturn resolvedConstructor.isPresent() ? resolvedConstructor.get() : null;\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor constructor, XConstructorCall constructorCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(constructorCall);\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstrutor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(constr -> constr.getDeclaration().equals(constructor)) //\n+\t\t\t\t.first();\n+\t\treturn resolvedConstrutor.isPresent() ? resolvedConstrutor.get() : null;", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjYxMw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401236613", "bodyText": "Typo in parameter name", "author": "szarnekow", "createdAt": "2020-03-31T21:50:30Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} \n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNzEzNA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401237134", "bodyText": "Not sure how often we do similar things in the code base, but I can imagine this logic to be moved to ResolvedFeatures, e.g. findResolvedOperation(JvmOperation declaration)", "author": "szarnekow", "createdAt": "2020-03-31T21:51:44Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} \n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(declaredConstructor -> declaredConstructor.getDeclaration().equals(consturctor)) //\n+\t\t\t\t.first();\n+\t\treturn resolvedConstructor.isPresent() ? resolvedConstructor.get() : null;\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor constructor, XConstructorCall constructorCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(constructorCall);\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstrutor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(constr -> constr.getDeclaration().equals(constructor)) //\n+\t\t\t\t.first();\n+\t\treturn resolvedConstrutor.isPresent() ? resolvedConstrutor.get() : null;\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmOperation operation, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedOperation> allOperations = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tallOperations = resolvedFeatures.getAllOperations();\n+\t\t}\n+\n+\t\tOptional<IResolvedOperation> resolvedOperation = FluentIterable.from(allOperations)", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4NjExNw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401886117", "bodyText": "The methods ResolvedFeatures#getAllOperations() and ResolvedFeatures#getDeclaredConstructors() are used in very few places, not for the same purpose as we have here. Nevertheless, I like your idea of adding methods #findResolvedOperation(JvmOperation declaration) (and  #findDeclaredConstructor(JvmConstructor constructor)) to the ResolvedFeatures class.", "author": "nbhusare", "createdAt": "2020-04-01T20:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNzEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzODc3Nw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401238777", "bodyText": "Not a big fan of these usages of optionals. Checking for isPresent is usually not good style. You probably want to do something like Iterables.tryFind(..).transform(node->getOffset() + 1).or(compositeNode::getEndOffset)", "author": "szarnekow", "createdAt": "2020-03-31T21:55:12Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/util/InsertionOffsets.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.util;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+public class InsertionOffsets {\n+\n+\tpublic int before(EObject element) {\n+\t\treturn NodeModelUtils.findActualNodeFor(element).getOffset();\n+\t}\n+\n+\tpublic int after(EObject element) {\n+\t\treturn NodeModelUtils.findActualNodeFor(element).getEndOffset();\n+\t}\n+\n+\tpublic int inEmpty(EObject element) {\n+\t\tICompositeNode compositeNode = NodeModelUtils.findActualNodeFor(element);\n+\t\tOptional<ILeafNode> openingBraceNode = Iterables.tryFind(compositeNode.getLeafNodes(), (node) -> \"{\".equals(node.getText()));", "originalCommit": "996ded0b113e8053e5981ac3285d564f4fede238", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzODg0NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401238845", "bodyText": "Or preferably a plain for loop.", "author": "szarnekow", "createdAt": "2020-03-31T21:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzODc3Nw=="}], "type": "inlineReview"}, {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd", "url": "https://github.com/eclipse/xtext-eclipse/commit/053a448c376f5a427bfd21bacb85c9e6a560abfd", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-04-01T20:33:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5NTU4Ng==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402095586", "bodyText": "It's the opposite of what I tried to suggest: Only log, ig it is not e.isDoesNotExist()", "author": "szarnekow", "createdAt": "2020-04-02T07:08:31Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = root.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tif (classpathEntry.getOutputLocation() != null\n+\t\t\t\t\t\t\t\t\t\t&& classpathEntry.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath()\n+\t\t\t\t\t\t\t\t\t\t\t.removeFirstSegments(classpathEntry.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.findPackageFragmentRoots(classpathEntry)) {\n+\t\t\t\t\t\t\t\t\t\tIPath fullPath = root.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tif (e.isDoesNotExist()) {", "originalCommit": "053a448c376f5a427bfd21bacb85c9e6a560abfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5NjE2MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402096160", "bodyText": "The semantics of getAncestor do already imply the check of the element itself. Can be implemented as return (IPackageFragmentRoot) element.getAncestor()", "author": "szarnekow", "createdAt": "2020-04-02T07:09:43Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = root.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tif (classpathEntry.getOutputLocation() != null\n+\t\t\t\t\t\t\t\t\t\t&& classpathEntry.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath()\n+\t\t\t\t\t\t\t\t\t\t\t.removeFirstSegments(classpathEntry.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.findPackageFragmentRoots(classpathEntry)) {\n+\t\t\t\t\t\t\t\t\t\tIPath fullPath = root.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tif (e.isDoesNotExist()) {\n+\t\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\tif (original != input) {\n+\t\t\treturn original;\n+\t\t}\n+\n+\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\tif (trace == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tfor (ILocationInEclipseResource candidate : trace.getAllAssociatedLocations()) {\n+\t\t\tif (languageInfo.equals(candidate.getLanguage())) {\n+\t\t\t\tIStorage storage = candidate.getPlatformResource();\n+\t\t\t\tif (storage != null) {\n+\t\t\t\t\treturn EditorUtils.createEditorInput(storage);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\t/**\n+\t * @return the {@code IPackageFragmentRoot} that contains the provided {@code element}\n+\t * @throws NullPointerException\n+\t *             if the provided {@code element} is null\n+\t */\n+\tpublic IPackageFragmentRoot getPackageFragmentRoot(IJavaElement element) {\n+\t\tPreconditions.checkNotNull(element, \"Couldn't find source package fragment root.\");\n+\t\treturn element instanceof IPackageFragmentRoot //", "originalCommit": "053a448c376f5a427bfd21bacb85c9e6a560abfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5NjcyMA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402096720", "bodyText": "Code is duplicated in the method below.", "author": "szarnekow", "createdAt": "2020-04-02T07:11:02Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor constructor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tif (actualReceiver != null) {\n+\t\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(actualType);", "originalCommit": "053a448c376f5a427bfd21bacb85c9e6a560abfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNTI5NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402125294", "bodyText": "I would early return here as well, also this doesn't need to be in try catch, try to keep it as small as possible", "author": "tivervac", "createdAt": "2020-04-02T08:05:06Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {", "originalCommit": "053a448c376f5a427bfd21bacb85c9e6a560abfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNTQyOQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402125429", "bodyText": "s/if/If/", "author": "tivervac", "createdAt": "2020-04-02T08:05:23Z", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file", "originalCommit": "053a448c376f5a427bfd21bacb85c9e6a560abfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b084a1a7d2d0f83a135237db245bc3f9d267a306", "url": "https://github.com/eclipse/xtext-eclipse/commit/b084a1a7d2d0f83a135237db245bc3f9d267a306", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-04-02T19:50:08Z", "type": "commit"}, {"oid": "b084a1a7d2d0f83a135237db245bc3f9d267a306", "url": "https://github.com/eclipse/xtext-eclipse/commit/b084a1a7d2d0f83a135237db245bc3f9d267a306", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-04-02T19:50:08Z", "type": "forcePushed"}]}