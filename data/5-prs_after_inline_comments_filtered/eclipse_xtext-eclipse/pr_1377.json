{"pr_number": 1377, "pr_title": "Migrate the Xtend code from \"org.eclipse.xtext.common.types.ui\" project to Java ", "pr_createdAt": "2020-03-23T09:37:56Z", "pr_url": "https://github.com/eclipse/xtext-eclipse/pull/1377", "timeline": [{"oid": "1354ed12caf331759bcb1453d530e3eed9440857", "url": "https://github.com/eclipse/xtext-eclipse/commit/1354ed12caf331759bcb1453d530e3eed9440857", "message": "Migrated the Xtend code from org.eclipse.xtext.common.types.ui project to Java\nDeleted the xtend-gen folder and updated the .classpath file\nRemoved *.xbase.lib and *.xtend.lib dependencies from the manifest file\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-03-23T09:45:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxNTc5MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397715790", "bodyText": "You may want to checkout com.google.common.collect.Iterables.getFirst(Iterable<? extends T>, T)", "author": "szarnekow", "createdAt": "2020-03-25T09:33:20Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/navigation/LinkToOriginDetector.java", "diffHunk": "@@ -84,7 +84,8 @@\n \t\t\t\t\t\t\tif (traceToSource == null) {\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tILocationInResource sourceInformation = IterableExtensions.head(traceToSource.getAllAssociatedLocations());\n+\t\t\t\t\t\t\tIterator<? extends ILocationInResource> allAssociatedLocations = traceToSource.getAllAssociatedLocations().iterator();", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxNzA0MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397717041", "bodyText": "Minor: Could you please move this method up to the declarations of _getQualifiedTypeNames?", "author": "szarnekow", "createdAt": "2020-03-25T09:35:26Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/notification/JavaBuilderState.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.common.types.ui.notification;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.builder.State;\n+import org.eclipse.jdt.internal.core.builder.StringSet;\n+import org.eclipse.xtext.naming.QualifiedName;\n+\n+/**\n+ * @since 2.5\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class JavaBuilderState {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaBuilderState.class);\n+\n+\tprivate final State state;\n+\n+\tprivate final IProject project;\n+\n+\tprivate Integer buildNumber;\n+\n+\tprivate SimpleLookupTable references;\n+\n+\tprivate Long lastStructuralBuildTime;\n+\n+\tprivate Set<QualifiedName> structurallyChangedTypes;\n+\n+\tprivate JavaBuilderState(IProject project, State state) {\n+\t\tthis.project = project;\n+\t\tthis.state = state;\n+\t}\n+\n+\tpublic IProject getProject() {\n+\t\treturn project;\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IJavaElement javaElement) {\n+\t\tIJavaProject javaProject = javaElement.getJavaProject();\n+\t\treturn javaProject == null ? null : JavaBuilderState.getLastBuiltState(javaProject.getProject());\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IProject project) {\n+\t\tfinal State state;\n+\t\tObject lastBuiltState = JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);\n+\t\tif (lastBuiltState instanceof State) {\n+\t\t\tstate = (State) lastBuiltState;\n+\t\t} else {\n+\t\t\tstate = null;\n+\t\t}\n+\t\treturn new JavaBuilderState(project, state);\n+\t}\n+\n+\tpublic Long getLastStructuralBuildTime() {\n+\t\tif (lastStructuralBuildTime != null) {\n+\t\t\treturn lastStructuralBuildTime;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn lastStructuralBuildTime = -1l;\n+\t\t}\n+\t\treturn lastStructuralBuildTime = (Long) readField(state, \"lastStructuralBuildTime\", -1l);\n+\t}\n+\n+\tpublic Integer getBuildNumber() {\n+\t\tif (buildNumber != null) {\n+\t\t\treturn buildNumber;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn buildNumber = -1;\n+\t\t}\n+\t\treturn buildNumber = (Integer) readField(state, \"buildNumber\", -1);\n+\t}\n+\n+\tpublic Set<QualifiedName> getStructurallyChangedTypes() {\n+\t\tif (structurallyChangedTypes != null) {\n+\t\t\treturn structurallyChangedTypes;\n+\t\t}\n+\n+\t\tstructurallyChangedTypes = new HashSet<>();\n+\n+\t\tif (state != null) {\n+\t\t\tObject types = readField(state, \"structurallyChangedTypes\", null);\n+\t\t\tif (types instanceof StringSet) {\n+\t\t\t\tfor (String name : ((StringSet) types).values) {\n+\t\t\t\t\tif (name != null) {\n+\t\t\t\t\t\tstructurallyChangedTypes.add(QualifiedName.create(name.split(\"/\")));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn structurallyChangedTypes;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of the given package.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(IPackageFragment packageFragment) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(packageFragment.getJavaProject());\n+\n+\t\tSimpleLookupTable references = getReferences();\n+\t\tif (references == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tIResource resource = packageFragment.getResource();\n+\t\tif (resource == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tString packageName = packageFragment.getElementName();\n+\t\tIPath packagePath = resource.getProjectRelativePath();\n+\t\tint srcPathSegmentCount = getPackageFragmentRoot(packageFragment).getResource().getProjectRelativePath().segmentCount();\n+\t\tfor (Object typeLocator : references.keyTable) {\n+\t\t\tif (typeLocator instanceof String) {\n+\t\t\t\tIPath typeLocatorPath = packageFragment.getJavaProject().getProject().getFile((String) typeLocator)\n+\t\t\t\t\t\t.getProjectRelativePath();\n+\t\t\t\tif (packagePath.isPrefixOf(typeLocatorPath)) {\n+\t\t\t\t\tIPath qualifiedPath = typeLocatorPath.removeFirstSegments(srcPathSegmentCount).removeFileExtension();\n+\t\t\t\t\tString typePackageName = qualifiedPath.removeLastSegments(1).toString().replace(\"/\", \".\");\n+\t\t\t\t\tif (packageName.equals(typePackageName)) {\n+\t\t\t\t\t\tString simpleTypeName = qualifiedPath.lastSegment().toString();\n+\t\t\t\t\t\tqualifiedTypeNames.addAll(\n+\t\t\t\t\t\t\t\tgetQualifiedTypeNames((String) typeLocator, packageName, simpleTypeName, packageFragment.getJavaProject()));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of a given CompilationUnit.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(ICompilationUnit compilationUnit) {\n+\t\treturn getQualifiedTypeNames(getTypeLocator(compilationUnit), getPackageName(compilationUnit),\n+\t\t\t\tgetSimplePrimaryTypeName(compilationUnit), compilationUnit.getJavaProject());\n+\t}\n+\n+\tprivate IPackageFragmentRoot getPackageFragmentRoot(IJavaElement javaElement) {\n+\t\tIJavaElement parent = javaElement.getParent();\n+\t\treturn parent instanceof IPackageFragmentRoot ? ((IPackageFragmentRoot) parent) : getPackageFragmentRoot(parent);\n+\t}\n+\n+\tprivate TypeNames getQualifiedTypeNames(String typeLocator, String packageName, String simpleName, IJavaProject project) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(project);\n+\t\tString primaryTypeFqn = getQualifedTypeName(packageName, simpleName);\n+\n+\t\tchar[][] typeNames = null;\n+\t\tif (state != null) {\n+\t\t\ttypeNames = state.getDefinedTypeNamesFor(typeLocator);\n+\t\t}\n+\n+\t\tif (typeNames == null) {\n+\t\t\tTypeNames newTypeNames = new TypeNames(project);\n+\t\t\tnewTypeNames.addTypeName(primaryTypeFqn, primaryTypeFqn);\n+\t\t\treturn newTypeNames;\n+\t\t}\n+\n+\t\tfor (char[] typeName : typeNames) {\n+\t\t\tString qualifiedTypeName = getQualifedTypeName(packageName, new String(typeName));\n+\t\t\tqualifiedTypeNames.addTypeName(qualifiedTypeName, primaryTypeFqn);\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\tprivate String getQualifedTypeName(String packageName, String simpleTypeName) {\n+\t\treturn packageName == null ? simpleTypeName : packageName + \".\" + simpleTypeName;\n+\t}\n+\n+\tprivate String getTypeLocator(ICompilationUnit compilationUnit) {\n+\t\tIResource resource = compilationUnit.getResource();\n+\t\tif (resource != null && resource.getProjectRelativePath() != null) {\n+\t\t\treturn resource.getProjectRelativePath().toString();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getPackageName(ICompilationUnit compilationUnit) {\n+\t\tIJavaElement parent = compilationUnit.getParent();\n+\t\tif (parent instanceof IPackageFragment && !((IPackageFragment) parent).isDefaultPackage()) {\n+\t\t\treturn ((IPackageFragment) parent).getElementName();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getSimplePrimaryTypeName(ICompilationUnit compilationUnit) {\n+\t\tString elementName = compilationUnit.getElementName();\n+\t\treturn elementName.substring(0, elementName.lastIndexOf(\".\"));\n+\t}\n+\n+\tprivate SimpleLookupTable getReferences() {\n+\t\tif (references != null) {\n+\t\t\treturn references;\n+\t\t}\n+\n+\t\tif (state == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tObject referencesField = readField(state, \"references\", null);\n+\t\tif (referencesField instanceof SimpleLookupTable) {\n+\t\t\treferences = (SimpleLookupTable) referencesField;\n+\t\t}\n+\t\treturn references;\n+\t}\n+\n+\tprivate Object readField(Object instance, String fieldName, Object defaultValue) {\n+\t\ttry {\n+\t\t\tField field = instance.getClass().getDeclaredField(fieldName);\n+\t\t\tfield.setAccessible(true);\n+\t\t\tObject value = field.get(instance);\n+\t\t\tif (value != null) {\n+\t\t\t\treturn value;\n+\t\t\t}\n+\t\t\treturn defaultValue;\n+\t\t} catch (Exception e) {\n+\t\t\tif (LOG.isEnabledFor(Level.ERROR)) {\n+\t\t\t\tLOG.error(e.getMessage(), e);\n+\t\t\t}\n+\t\t\treturn defaultValue;\n+\t\t}\n+\t}\n+\n+\tpublic TypeNames getQualifiedTypeNames(Object obj) {", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxODIzMg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397718232", "bodyText": "This local variable is probably not necessary. return (SimpleLookupTable) readField(..) should be fine.\nMay bad, I misread the diff.\nCan you please use a better name for referencesField - it's not a field but a value that was read from the field. maybeLookupTable or readReferences could be better.", "author": "szarnekow", "createdAt": "2020-03-25T09:37:31Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/notification/JavaBuilderState.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.common.types.ui.notification;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.builder.State;\n+import org.eclipse.jdt.internal.core.builder.StringSet;\n+import org.eclipse.xtext.naming.QualifiedName;\n+\n+/**\n+ * @since 2.5\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class JavaBuilderState {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaBuilderState.class);\n+\n+\tprivate final State state;\n+\n+\tprivate final IProject project;\n+\n+\tprivate Integer buildNumber;\n+\n+\tprivate SimpleLookupTable references;\n+\n+\tprivate Long lastStructuralBuildTime;\n+\n+\tprivate Set<QualifiedName> structurallyChangedTypes;\n+\n+\tprivate JavaBuilderState(IProject project, State state) {\n+\t\tthis.project = project;\n+\t\tthis.state = state;\n+\t}\n+\n+\tpublic IProject getProject() {\n+\t\treturn project;\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IJavaElement javaElement) {\n+\t\tIJavaProject javaProject = javaElement.getJavaProject();\n+\t\treturn javaProject == null ? null : JavaBuilderState.getLastBuiltState(javaProject.getProject());\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IProject project) {\n+\t\tfinal State state;\n+\t\tObject lastBuiltState = JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);\n+\t\tif (lastBuiltState instanceof State) {\n+\t\t\tstate = (State) lastBuiltState;\n+\t\t} else {\n+\t\t\tstate = null;\n+\t\t}\n+\t\treturn new JavaBuilderState(project, state);\n+\t}\n+\n+\tpublic Long getLastStructuralBuildTime() {\n+\t\tif (lastStructuralBuildTime != null) {\n+\t\t\treturn lastStructuralBuildTime;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn lastStructuralBuildTime = -1l;\n+\t\t}\n+\t\treturn lastStructuralBuildTime = (Long) readField(state, \"lastStructuralBuildTime\", -1l);\n+\t}\n+\n+\tpublic Integer getBuildNumber() {\n+\t\tif (buildNumber != null) {\n+\t\t\treturn buildNumber;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn buildNumber = -1;\n+\t\t}\n+\t\treturn buildNumber = (Integer) readField(state, \"buildNumber\", -1);\n+\t}\n+\n+\tpublic Set<QualifiedName> getStructurallyChangedTypes() {\n+\t\tif (structurallyChangedTypes != null) {\n+\t\t\treturn structurallyChangedTypes;\n+\t\t}\n+\n+\t\tstructurallyChangedTypes = new HashSet<>();\n+\n+\t\tif (state != null) {\n+\t\t\tObject types = readField(state, \"structurallyChangedTypes\", null);\n+\t\t\tif (types instanceof StringSet) {\n+\t\t\t\tfor (String name : ((StringSet) types).values) {\n+\t\t\t\t\tif (name != null) {\n+\t\t\t\t\t\tstructurallyChangedTypes.add(QualifiedName.create(name.split(\"/\")));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn structurallyChangedTypes;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of the given package.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(IPackageFragment packageFragment) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(packageFragment.getJavaProject());\n+\n+\t\tSimpleLookupTable references = getReferences();\n+\t\tif (references == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tIResource resource = packageFragment.getResource();\n+\t\tif (resource == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tString packageName = packageFragment.getElementName();\n+\t\tIPath packagePath = resource.getProjectRelativePath();\n+\t\tint srcPathSegmentCount = getPackageFragmentRoot(packageFragment).getResource().getProjectRelativePath().segmentCount();\n+\t\tfor (Object typeLocator : references.keyTable) {\n+\t\t\tif (typeLocator instanceof String) {\n+\t\t\t\tIPath typeLocatorPath = packageFragment.getJavaProject().getProject().getFile((String) typeLocator)\n+\t\t\t\t\t\t.getProjectRelativePath();\n+\t\t\t\tif (packagePath.isPrefixOf(typeLocatorPath)) {\n+\t\t\t\t\tIPath qualifiedPath = typeLocatorPath.removeFirstSegments(srcPathSegmentCount).removeFileExtension();\n+\t\t\t\t\tString typePackageName = qualifiedPath.removeLastSegments(1).toString().replace(\"/\", \".\");\n+\t\t\t\t\tif (packageName.equals(typePackageName)) {\n+\t\t\t\t\t\tString simpleTypeName = qualifiedPath.lastSegment().toString();\n+\t\t\t\t\t\tqualifiedTypeNames.addAll(\n+\t\t\t\t\t\t\t\tgetQualifiedTypeNames((String) typeLocator, packageName, simpleTypeName, packageFragment.getJavaProject()));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of a given CompilationUnit.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(ICompilationUnit compilationUnit) {\n+\t\treturn getQualifiedTypeNames(getTypeLocator(compilationUnit), getPackageName(compilationUnit),\n+\t\t\t\tgetSimplePrimaryTypeName(compilationUnit), compilationUnit.getJavaProject());\n+\t}\n+\n+\tprivate IPackageFragmentRoot getPackageFragmentRoot(IJavaElement javaElement) {\n+\t\tIJavaElement parent = javaElement.getParent();\n+\t\treturn parent instanceof IPackageFragmentRoot ? ((IPackageFragmentRoot) parent) : getPackageFragmentRoot(parent);\n+\t}\n+\n+\tprivate TypeNames getQualifiedTypeNames(String typeLocator, String packageName, String simpleName, IJavaProject project) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(project);\n+\t\tString primaryTypeFqn = getQualifedTypeName(packageName, simpleName);\n+\n+\t\tchar[][] typeNames = null;\n+\t\tif (state != null) {\n+\t\t\ttypeNames = state.getDefinedTypeNamesFor(typeLocator);\n+\t\t}\n+\n+\t\tif (typeNames == null) {\n+\t\t\tTypeNames newTypeNames = new TypeNames(project);\n+\t\t\tnewTypeNames.addTypeName(primaryTypeFqn, primaryTypeFqn);\n+\t\t\treturn newTypeNames;\n+\t\t}\n+\n+\t\tfor (char[] typeName : typeNames) {\n+\t\t\tString qualifiedTypeName = getQualifedTypeName(packageName, new String(typeName));\n+\t\t\tqualifiedTypeNames.addTypeName(qualifiedTypeName, primaryTypeFqn);\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\tprivate String getQualifedTypeName(String packageName, String simpleTypeName) {\n+\t\treturn packageName == null ? simpleTypeName : packageName + \".\" + simpleTypeName;\n+\t}\n+\n+\tprivate String getTypeLocator(ICompilationUnit compilationUnit) {\n+\t\tIResource resource = compilationUnit.getResource();\n+\t\tif (resource != null && resource.getProjectRelativePath() != null) {\n+\t\t\treturn resource.getProjectRelativePath().toString();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getPackageName(ICompilationUnit compilationUnit) {\n+\t\tIJavaElement parent = compilationUnit.getParent();\n+\t\tif (parent instanceof IPackageFragment && !((IPackageFragment) parent).isDefaultPackage()) {\n+\t\t\treturn ((IPackageFragment) parent).getElementName();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getSimplePrimaryTypeName(ICompilationUnit compilationUnit) {\n+\t\tString elementName = compilationUnit.getElementName();\n+\t\treturn elementName.substring(0, elementName.lastIndexOf(\".\"));\n+\t}\n+\n+\tprivate SimpleLookupTable getReferences() {\n+\t\tif (references != null) {\n+\t\t\treturn references;\n+\t\t}\n+\n+\t\tif (state == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tObject referencesField = readField(state, \"references\", null);", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcyMTMwNg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397721306", "bodyText": "Not strictly related, so maybe something for a follow-up PR: This looks like org.eclipse.jdt.internal.compiler.env.ICompilationUnit.getMainTypeName() would be the better candidate to being invoked.", "author": "szarnekow", "createdAt": "2020-03-25T09:42:25Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/notification/JavaBuilderState.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.common.types.ui.notification;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.builder.State;\n+import org.eclipse.jdt.internal.core.builder.StringSet;\n+import org.eclipse.xtext.naming.QualifiedName;\n+\n+/**\n+ * @since 2.5\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class JavaBuilderState {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaBuilderState.class);\n+\n+\tprivate final State state;\n+\n+\tprivate final IProject project;\n+\n+\tprivate Integer buildNumber;\n+\n+\tprivate SimpleLookupTable references;\n+\n+\tprivate Long lastStructuralBuildTime;\n+\n+\tprivate Set<QualifiedName> structurallyChangedTypes;\n+\n+\tprivate JavaBuilderState(IProject project, State state) {\n+\t\tthis.project = project;\n+\t\tthis.state = state;\n+\t}\n+\n+\tpublic IProject getProject() {\n+\t\treturn project;\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IJavaElement javaElement) {\n+\t\tIJavaProject javaProject = javaElement.getJavaProject();\n+\t\treturn javaProject == null ? null : JavaBuilderState.getLastBuiltState(javaProject.getProject());\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IProject project) {\n+\t\tfinal State state;\n+\t\tObject lastBuiltState = JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);\n+\t\tif (lastBuiltState instanceof State) {\n+\t\t\tstate = (State) lastBuiltState;\n+\t\t} else {\n+\t\t\tstate = null;\n+\t\t}\n+\t\treturn new JavaBuilderState(project, state);\n+\t}\n+\n+\tpublic Long getLastStructuralBuildTime() {\n+\t\tif (lastStructuralBuildTime != null) {\n+\t\t\treturn lastStructuralBuildTime;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn lastStructuralBuildTime = -1l;\n+\t\t}\n+\t\treturn lastStructuralBuildTime = (Long) readField(state, \"lastStructuralBuildTime\", -1l);\n+\t}\n+\n+\tpublic Integer getBuildNumber() {\n+\t\tif (buildNumber != null) {\n+\t\t\treturn buildNumber;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn buildNumber = -1;\n+\t\t}\n+\t\treturn buildNumber = (Integer) readField(state, \"buildNumber\", -1);\n+\t}\n+\n+\tpublic Set<QualifiedName> getStructurallyChangedTypes() {\n+\t\tif (structurallyChangedTypes != null) {\n+\t\t\treturn structurallyChangedTypes;\n+\t\t}\n+\n+\t\tstructurallyChangedTypes = new HashSet<>();\n+\n+\t\tif (state != null) {\n+\t\t\tObject types = readField(state, \"structurallyChangedTypes\", null);\n+\t\t\tif (types instanceof StringSet) {\n+\t\t\t\tfor (String name : ((StringSet) types).values) {\n+\t\t\t\t\tif (name != null) {\n+\t\t\t\t\t\tstructurallyChangedTypes.add(QualifiedName.create(name.split(\"/\")));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn structurallyChangedTypes;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of the given package.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(IPackageFragment packageFragment) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(packageFragment.getJavaProject());\n+\n+\t\tSimpleLookupTable references = getReferences();\n+\t\tif (references == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tIResource resource = packageFragment.getResource();\n+\t\tif (resource == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tString packageName = packageFragment.getElementName();\n+\t\tIPath packagePath = resource.getProjectRelativePath();\n+\t\tint srcPathSegmentCount = getPackageFragmentRoot(packageFragment).getResource().getProjectRelativePath().segmentCount();\n+\t\tfor (Object typeLocator : references.keyTable) {\n+\t\t\tif (typeLocator instanceof String) {\n+\t\t\t\tIPath typeLocatorPath = packageFragment.getJavaProject().getProject().getFile((String) typeLocator)\n+\t\t\t\t\t\t.getProjectRelativePath();\n+\t\t\t\tif (packagePath.isPrefixOf(typeLocatorPath)) {\n+\t\t\t\t\tIPath qualifiedPath = typeLocatorPath.removeFirstSegments(srcPathSegmentCount).removeFileExtension();\n+\t\t\t\t\tString typePackageName = qualifiedPath.removeLastSegments(1).toString().replace(\"/\", \".\");\n+\t\t\t\t\tif (packageName.equals(typePackageName)) {\n+\t\t\t\t\t\tString simpleTypeName = qualifiedPath.lastSegment().toString();\n+\t\t\t\t\t\tqualifiedTypeNames.addAll(\n+\t\t\t\t\t\t\t\tgetQualifiedTypeNames((String) typeLocator, packageName, simpleTypeName, packageFragment.getJavaProject()));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of a given CompilationUnit.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(ICompilationUnit compilationUnit) {\n+\t\treturn getQualifiedTypeNames(getTypeLocator(compilationUnit), getPackageName(compilationUnit),\n+\t\t\t\tgetSimplePrimaryTypeName(compilationUnit), compilationUnit.getJavaProject());\n+\t}\n+\n+\tprivate IPackageFragmentRoot getPackageFragmentRoot(IJavaElement javaElement) {\n+\t\tIJavaElement parent = javaElement.getParent();\n+\t\treturn parent instanceof IPackageFragmentRoot ? ((IPackageFragmentRoot) parent) : getPackageFragmentRoot(parent);\n+\t}\n+\n+\tprivate TypeNames getQualifiedTypeNames(String typeLocator, String packageName, String simpleName, IJavaProject project) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(project);\n+\t\tString primaryTypeFqn = getQualifedTypeName(packageName, simpleName);\n+\n+\t\tchar[][] typeNames = null;\n+\t\tif (state != null) {\n+\t\t\ttypeNames = state.getDefinedTypeNamesFor(typeLocator);\n+\t\t}\n+\n+\t\tif (typeNames == null) {\n+\t\t\tTypeNames newTypeNames = new TypeNames(project);\n+\t\t\tnewTypeNames.addTypeName(primaryTypeFqn, primaryTypeFqn);\n+\t\t\treturn newTypeNames;\n+\t\t}\n+\n+\t\tfor (char[] typeName : typeNames) {\n+\t\t\tString qualifiedTypeName = getQualifedTypeName(packageName, new String(typeName));\n+\t\t\tqualifiedTypeNames.addTypeName(qualifiedTypeName, primaryTypeFqn);\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\tprivate String getQualifedTypeName(String packageName, String simpleTypeName) {\n+\t\treturn packageName == null ? simpleTypeName : packageName + \".\" + simpleTypeName;\n+\t}\n+\n+\tprivate String getTypeLocator(ICompilationUnit compilationUnit) {\n+\t\tIResource resource = compilationUnit.getResource();\n+\t\tif (resource != null && resource.getProjectRelativePath() != null) {\n+\t\t\treturn resource.getProjectRelativePath().toString();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getPackageName(ICompilationUnit compilationUnit) {\n+\t\tIJavaElement parent = compilationUnit.getParent();\n+\t\tif (parent instanceof IPackageFragment && !((IPackageFragment) parent).isDefaultPackage()) {\n+\t\t\treturn ((IPackageFragment) parent).getElementName();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getSimplePrimaryTypeName(ICompilationUnit compilationUnit) {\n+\t\tString elementName = compilationUnit.getElementName();\n+\t\treturn elementName.substring(0, elementName.lastIndexOf(\".\"));", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEzMDE5Nw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r398130197", "bodyText": "It looks like a better choice, however, I wonder if we can use it here. The public API in this class expects a IJavaElement, whereas, the above is not a Java element.\nPlease correct me if I am wrong.", "author": "nbhusare", "createdAt": "2020-03-25T19:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcyMTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM3NzI4Nw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r398377287", "bodyText": "True, I ended up in the wrong type when doing the research.\nManipulating strings can be brittle from time to time. Let's keep this as is for now.", "author": "szarnekow", "createdAt": "2020-03-26T08:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcyMTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcyMTkzOA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397721938", "bodyText": "org.eclipse.jdt.internal.compiler.env.ICompilationUnit.getPackageName()", "author": "szarnekow", "createdAt": "2020-03-25T09:43:18Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/notification/JavaBuilderState.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.common.types.ui.notification;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.builder.State;\n+import org.eclipse.jdt.internal.core.builder.StringSet;\n+import org.eclipse.xtext.naming.QualifiedName;\n+\n+/**\n+ * @since 2.5\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class JavaBuilderState {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaBuilderState.class);\n+\n+\tprivate final State state;\n+\n+\tprivate final IProject project;\n+\n+\tprivate Integer buildNumber;\n+\n+\tprivate SimpleLookupTable references;\n+\n+\tprivate Long lastStructuralBuildTime;\n+\n+\tprivate Set<QualifiedName> structurallyChangedTypes;\n+\n+\tprivate JavaBuilderState(IProject project, State state) {\n+\t\tthis.project = project;\n+\t\tthis.state = state;\n+\t}\n+\n+\tpublic IProject getProject() {\n+\t\treturn project;\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IJavaElement javaElement) {\n+\t\tIJavaProject javaProject = javaElement.getJavaProject();\n+\t\treturn javaProject == null ? null : JavaBuilderState.getLastBuiltState(javaProject.getProject());\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IProject project) {\n+\t\tfinal State state;\n+\t\tObject lastBuiltState = JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);\n+\t\tif (lastBuiltState instanceof State) {\n+\t\t\tstate = (State) lastBuiltState;\n+\t\t} else {\n+\t\t\tstate = null;\n+\t\t}\n+\t\treturn new JavaBuilderState(project, state);\n+\t}\n+\n+\tpublic Long getLastStructuralBuildTime() {\n+\t\tif (lastStructuralBuildTime != null) {\n+\t\t\treturn lastStructuralBuildTime;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn lastStructuralBuildTime = -1l;\n+\t\t}\n+\t\treturn lastStructuralBuildTime = (Long) readField(state, \"lastStructuralBuildTime\", -1l);\n+\t}\n+\n+\tpublic Integer getBuildNumber() {\n+\t\tif (buildNumber != null) {\n+\t\t\treturn buildNumber;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn buildNumber = -1;\n+\t\t}\n+\t\treturn buildNumber = (Integer) readField(state, \"buildNumber\", -1);\n+\t}\n+\n+\tpublic Set<QualifiedName> getStructurallyChangedTypes() {\n+\t\tif (structurallyChangedTypes != null) {\n+\t\t\treturn structurallyChangedTypes;\n+\t\t}\n+\n+\t\tstructurallyChangedTypes = new HashSet<>();\n+\n+\t\tif (state != null) {\n+\t\t\tObject types = readField(state, \"structurallyChangedTypes\", null);\n+\t\t\tif (types instanceof StringSet) {\n+\t\t\t\tfor (String name : ((StringSet) types).values) {\n+\t\t\t\t\tif (name != null) {\n+\t\t\t\t\t\tstructurallyChangedTypes.add(QualifiedName.create(name.split(\"/\")));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn structurallyChangedTypes;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of the given package.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(IPackageFragment packageFragment) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(packageFragment.getJavaProject());\n+\n+\t\tSimpleLookupTable references = getReferences();\n+\t\tif (references == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tIResource resource = packageFragment.getResource();\n+\t\tif (resource == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tString packageName = packageFragment.getElementName();\n+\t\tIPath packagePath = resource.getProjectRelativePath();\n+\t\tint srcPathSegmentCount = getPackageFragmentRoot(packageFragment).getResource().getProjectRelativePath().segmentCount();\n+\t\tfor (Object typeLocator : references.keyTable) {\n+\t\t\tif (typeLocator instanceof String) {\n+\t\t\t\tIPath typeLocatorPath = packageFragment.getJavaProject().getProject().getFile((String) typeLocator)\n+\t\t\t\t\t\t.getProjectRelativePath();\n+\t\t\t\tif (packagePath.isPrefixOf(typeLocatorPath)) {\n+\t\t\t\t\tIPath qualifiedPath = typeLocatorPath.removeFirstSegments(srcPathSegmentCount).removeFileExtension();\n+\t\t\t\t\tString typePackageName = qualifiedPath.removeLastSegments(1).toString().replace(\"/\", \".\");\n+\t\t\t\t\tif (packageName.equals(typePackageName)) {\n+\t\t\t\t\t\tString simpleTypeName = qualifiedPath.lastSegment().toString();\n+\t\t\t\t\t\tqualifiedTypeNames.addAll(\n+\t\t\t\t\t\t\t\tgetQualifiedTypeNames((String) typeLocator, packageName, simpleTypeName, packageFragment.getJavaProject()));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of a given CompilationUnit.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(ICompilationUnit compilationUnit) {\n+\t\treturn getQualifiedTypeNames(getTypeLocator(compilationUnit), getPackageName(compilationUnit),\n+\t\t\t\tgetSimplePrimaryTypeName(compilationUnit), compilationUnit.getJavaProject());\n+\t}\n+\n+\tprivate IPackageFragmentRoot getPackageFragmentRoot(IJavaElement javaElement) {\n+\t\tIJavaElement parent = javaElement.getParent();\n+\t\treturn parent instanceof IPackageFragmentRoot ? ((IPackageFragmentRoot) parent) : getPackageFragmentRoot(parent);\n+\t}\n+\n+\tprivate TypeNames getQualifiedTypeNames(String typeLocator, String packageName, String simpleName, IJavaProject project) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(project);\n+\t\tString primaryTypeFqn = getQualifedTypeName(packageName, simpleName);\n+\n+\t\tchar[][] typeNames = null;\n+\t\tif (state != null) {\n+\t\t\ttypeNames = state.getDefinedTypeNamesFor(typeLocator);\n+\t\t}\n+\n+\t\tif (typeNames == null) {\n+\t\t\tTypeNames newTypeNames = new TypeNames(project);\n+\t\t\tnewTypeNames.addTypeName(primaryTypeFqn, primaryTypeFqn);\n+\t\t\treturn newTypeNames;\n+\t\t}\n+\n+\t\tfor (char[] typeName : typeNames) {\n+\t\t\tString qualifiedTypeName = getQualifedTypeName(packageName, new String(typeName));\n+\t\t\tqualifiedTypeNames.addTypeName(qualifiedTypeName, primaryTypeFqn);\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\tprivate String getQualifedTypeName(String packageName, String simpleTypeName) {\n+\t\treturn packageName == null ? simpleTypeName : packageName + \".\" + simpleTypeName;\n+\t}\n+\n+\tprivate String getTypeLocator(ICompilationUnit compilationUnit) {\n+\t\tIResource resource = compilationUnit.getResource();\n+\t\tif (resource != null && resource.getProjectRelativePath() != null) {\n+\t\t\treturn resource.getProjectRelativePath().toString();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getPackageName(ICompilationUnit compilationUnit) {\n+\t\tIJavaElement parent = compilationUnit.getParent();", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyMjgyNg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r398122826", "bodyText": "We are using the ICompilationUnit from the org.eclipse.jdt.core package. It doesn't provide such a method.", "author": "nbhusare", "createdAt": "2020-03-25T19:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcyMTkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM3NzM0NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r398377345", "bodyText": "True.", "author": "szarnekow", "createdAt": "2020-03-26T08:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcyMTkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0MTQ1OA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397741458", "bodyText": "AFAIK capital letters are supposed for long literals. The new Eclipse also has a new warning for this.", "author": "tivervac", "createdAt": "2020-03-25T10:14:57Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/notification/JavaBuilderState.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.common.types.ui.notification;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.builder.State;\n+import org.eclipse.jdt.internal.core.builder.StringSet;\n+import org.eclipse.xtext.naming.QualifiedName;\n+\n+/**\n+ * @since 2.5\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class JavaBuilderState {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaBuilderState.class);\n+\n+\tprivate final State state;\n+\n+\tprivate final IProject project;\n+\n+\tprivate Integer buildNumber;\n+\n+\tprivate SimpleLookupTable references;\n+\n+\tprivate Long lastStructuralBuildTime;\n+\n+\tprivate Set<QualifiedName> structurallyChangedTypes;\n+\n+\tprivate JavaBuilderState(IProject project, State state) {\n+\t\tthis.project = project;\n+\t\tthis.state = state;\n+\t}\n+\n+\tpublic IProject getProject() {\n+\t\treturn project;\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IJavaElement javaElement) {\n+\t\tIJavaProject javaProject = javaElement.getJavaProject();\n+\t\treturn javaProject == null ? null : JavaBuilderState.getLastBuiltState(javaProject.getProject());\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IProject project) {\n+\t\tfinal State state;\n+\t\tObject lastBuiltState = JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);\n+\t\tif (lastBuiltState instanceof State) {\n+\t\t\tstate = (State) lastBuiltState;\n+\t\t} else {\n+\t\t\tstate = null;\n+\t\t}\n+\t\treturn new JavaBuilderState(project, state);\n+\t}\n+\n+\tpublic Long getLastStructuralBuildTime() {\n+\t\tif (lastStructuralBuildTime != null) {\n+\t\t\treturn lastStructuralBuildTime;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn lastStructuralBuildTime = -1l;", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODExNjI0OQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r398116249", "bodyText": "You are right. I am leaving a link here for others who might be interested in knowing the reason behind this recommendation (PS Integer Literals section) - https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html", "author": "nbhusare", "createdAt": "2020-03-25T19:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0MTQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0MTUzMg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397741532", "bodyText": "Same", "author": "tivervac", "createdAt": "2020-03-25T10:15:04Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/notification/JavaBuilderState.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.common.types.ui.notification;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.builder.State;\n+import org.eclipse.jdt.internal.core.builder.StringSet;\n+import org.eclipse.xtext.naming.QualifiedName;\n+\n+/**\n+ * @since 2.5\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class JavaBuilderState {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaBuilderState.class);\n+\n+\tprivate final State state;\n+\n+\tprivate final IProject project;\n+\n+\tprivate Integer buildNumber;\n+\n+\tprivate SimpleLookupTable references;\n+\n+\tprivate Long lastStructuralBuildTime;\n+\n+\tprivate Set<QualifiedName> structurallyChangedTypes;\n+\n+\tprivate JavaBuilderState(IProject project, State state) {\n+\t\tthis.project = project;\n+\t\tthis.state = state;\n+\t}\n+\n+\tpublic IProject getProject() {\n+\t\treturn project;\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IJavaElement javaElement) {\n+\t\tIJavaProject javaProject = javaElement.getJavaProject();\n+\t\treturn javaProject == null ? null : JavaBuilderState.getLastBuiltState(javaProject.getProject());\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IProject project) {\n+\t\tfinal State state;\n+\t\tObject lastBuiltState = JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);\n+\t\tif (lastBuiltState instanceof State) {\n+\t\t\tstate = (State) lastBuiltState;\n+\t\t} else {\n+\t\t\tstate = null;\n+\t\t}\n+\t\treturn new JavaBuilderState(project, state);\n+\t}\n+\n+\tpublic Long getLastStructuralBuildTime() {\n+\t\tif (lastStructuralBuildTime != null) {\n+\t\t\treturn lastStructuralBuildTime;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn lastStructuralBuildTime = -1l;\n+\t\t}\n+\t\treturn lastStructuralBuildTime = (Long) readField(state, \"lastStructuralBuildTime\", -1l);", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0Mjg1Mg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397742852", "bodyText": "Not related to the ticket but is it always /, even on windows?", "author": "tivervac", "createdAt": "2020-03-25T10:17:20Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/notification/JavaBuilderState.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.common.types.ui.notification;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.builder.State;\n+import org.eclipse.jdt.internal.core.builder.StringSet;\n+import org.eclipse.xtext.naming.QualifiedName;\n+\n+/**\n+ * @since 2.5\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class JavaBuilderState {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaBuilderState.class);\n+\n+\tprivate final State state;\n+\n+\tprivate final IProject project;\n+\n+\tprivate Integer buildNumber;\n+\n+\tprivate SimpleLookupTable references;\n+\n+\tprivate Long lastStructuralBuildTime;\n+\n+\tprivate Set<QualifiedName> structurallyChangedTypes;\n+\n+\tprivate JavaBuilderState(IProject project, State state) {\n+\t\tthis.project = project;\n+\t\tthis.state = state;\n+\t}\n+\n+\tpublic IProject getProject() {\n+\t\treturn project;\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IJavaElement javaElement) {\n+\t\tIJavaProject javaProject = javaElement.getJavaProject();\n+\t\treturn javaProject == null ? null : JavaBuilderState.getLastBuiltState(javaProject.getProject());\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IProject project) {\n+\t\tfinal State state;\n+\t\tObject lastBuiltState = JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);\n+\t\tif (lastBuiltState instanceof State) {\n+\t\t\tstate = (State) lastBuiltState;\n+\t\t} else {\n+\t\t\tstate = null;\n+\t\t}\n+\t\treturn new JavaBuilderState(project, state);\n+\t}\n+\n+\tpublic Long getLastStructuralBuildTime() {\n+\t\tif (lastStructuralBuildTime != null) {\n+\t\t\treturn lastStructuralBuildTime;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn lastStructuralBuildTime = -1l;\n+\t\t}\n+\t\treturn lastStructuralBuildTime = (Long) readField(state, \"lastStructuralBuildTime\", -1l);\n+\t}\n+\n+\tpublic Integer getBuildNumber() {\n+\t\tif (buildNumber != null) {\n+\t\t\treturn buildNumber;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn buildNumber = -1;\n+\t\t}\n+\t\treturn buildNumber = (Integer) readField(state, \"buildNumber\", -1);\n+\t}\n+\n+\tpublic Set<QualifiedName> getStructurallyChangedTypes() {\n+\t\tif (structurallyChangedTypes != null) {\n+\t\t\treturn structurallyChangedTypes;\n+\t\t}\n+\n+\t\tstructurallyChangedTypes = new HashSet<>();\n+\n+\t\tif (state != null) {\n+\t\t\tObject types = readField(state, \"structurallyChangedTypes\", null);\n+\t\t\tif (types instanceof StringSet) {\n+\t\t\t\tfor (String name : ((StringSet) types).values) {\n+\t\t\t\t\tif (name != null) {\n+\t\t\t\t\t\tstructurallyChangedTypes.add(QualifiedName.create(name.split(\"/\")));", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc2MzU0NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r397763544", "bodyText": "Hmmm, isn't this just checked in LOG.error itself?", "author": "tivervac", "createdAt": "2020-03-25T10:52:03Z", "path": "org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/ui/notification/JavaBuilderState.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.common.types.ui.notification;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IProject;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.builder.State;\n+import org.eclipse.jdt.internal.core.builder.StringSet;\n+import org.eclipse.xtext.naming.QualifiedName;\n+\n+/**\n+ * @since 2.5\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class JavaBuilderState {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaBuilderState.class);\n+\n+\tprivate final State state;\n+\n+\tprivate final IProject project;\n+\n+\tprivate Integer buildNumber;\n+\n+\tprivate SimpleLookupTable references;\n+\n+\tprivate Long lastStructuralBuildTime;\n+\n+\tprivate Set<QualifiedName> structurallyChangedTypes;\n+\n+\tprivate JavaBuilderState(IProject project, State state) {\n+\t\tthis.project = project;\n+\t\tthis.state = state;\n+\t}\n+\n+\tpublic IProject getProject() {\n+\t\treturn project;\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IJavaElement javaElement) {\n+\t\tIJavaProject javaProject = javaElement.getJavaProject();\n+\t\treturn javaProject == null ? null : JavaBuilderState.getLastBuiltState(javaProject.getProject());\n+\t}\n+\n+\tpublic static JavaBuilderState getLastBuiltState(IProject project) {\n+\t\tfinal State state;\n+\t\tObject lastBuiltState = JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);\n+\t\tif (lastBuiltState instanceof State) {\n+\t\t\tstate = (State) lastBuiltState;\n+\t\t} else {\n+\t\t\tstate = null;\n+\t\t}\n+\t\treturn new JavaBuilderState(project, state);\n+\t}\n+\n+\tpublic Long getLastStructuralBuildTime() {\n+\t\tif (lastStructuralBuildTime != null) {\n+\t\t\treturn lastStructuralBuildTime;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn lastStructuralBuildTime = -1l;\n+\t\t}\n+\t\treturn lastStructuralBuildTime = (Long) readField(state, \"lastStructuralBuildTime\", -1l);\n+\t}\n+\n+\tpublic Integer getBuildNumber() {\n+\t\tif (buildNumber != null) {\n+\t\t\treturn buildNumber;\n+\t\t}\n+\t\tif (state == null) {\n+\t\t\treturn buildNumber = -1;\n+\t\t}\n+\t\treturn buildNumber = (Integer) readField(state, \"buildNumber\", -1);\n+\t}\n+\n+\tpublic Set<QualifiedName> getStructurallyChangedTypes() {\n+\t\tif (structurallyChangedTypes != null) {\n+\t\t\treturn structurallyChangedTypes;\n+\t\t}\n+\n+\t\tstructurallyChangedTypes = new HashSet<>();\n+\n+\t\tif (state != null) {\n+\t\t\tObject types = readField(state, \"structurallyChangedTypes\", null);\n+\t\t\tif (types instanceof StringSet) {\n+\t\t\t\tfor (String name : ((StringSet) types).values) {\n+\t\t\t\t\tif (name != null) {\n+\t\t\t\t\t\tstructurallyChangedTypes.add(QualifiedName.create(name.split(\"/\")));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn structurallyChangedTypes;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of the given package.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(IPackageFragment packageFragment) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(packageFragment.getJavaProject());\n+\n+\t\tSimpleLookupTable references = getReferences();\n+\t\tif (references == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tIResource resource = packageFragment.getResource();\n+\t\tif (resource == null) {\n+\t\t\treturn qualifiedTypeNames;\n+\t\t}\n+\n+\t\tString packageName = packageFragment.getElementName();\n+\t\tIPath packagePath = resource.getProjectRelativePath();\n+\t\tint srcPathSegmentCount = getPackageFragmentRoot(packageFragment).getResource().getProjectRelativePath().segmentCount();\n+\t\tfor (Object typeLocator : references.keyTable) {\n+\t\t\tif (typeLocator instanceof String) {\n+\t\t\t\tIPath typeLocatorPath = packageFragment.getJavaProject().getProject().getFile((String) typeLocator)\n+\t\t\t\t\t\t.getProjectRelativePath();\n+\t\t\t\tif (packagePath.isPrefixOf(typeLocatorPath)) {\n+\t\t\t\t\tIPath qualifiedPath = typeLocatorPath.removeFirstSegments(srcPathSegmentCount).removeFileExtension();\n+\t\t\t\t\tString typePackageName = qualifiedPath.removeLastSegments(1).toString().replace(\"/\", \".\");\n+\t\t\t\t\tif (packageName.equals(typePackageName)) {\n+\t\t\t\t\t\tString simpleTypeName = qualifiedPath.lastSegment().toString();\n+\t\t\t\t\t\tqualifiedTypeNames.addAll(\n+\t\t\t\t\t\t\t\tgetQualifiedTypeNames((String) typeLocator, packageName, simpleTypeName, packageFragment.getJavaProject()));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\t/**\n+\t * @return The {@code TypeNames} which are direct children of a given CompilationUnit.\n+\t */\n+\tprotected TypeNames _getQualifiedTypeNames(ICompilationUnit compilationUnit) {\n+\t\treturn getQualifiedTypeNames(getTypeLocator(compilationUnit), getPackageName(compilationUnit),\n+\t\t\t\tgetSimplePrimaryTypeName(compilationUnit), compilationUnit.getJavaProject());\n+\t}\n+\n+\tprivate IPackageFragmentRoot getPackageFragmentRoot(IJavaElement javaElement) {\n+\t\tIJavaElement parent = javaElement.getParent();\n+\t\treturn parent instanceof IPackageFragmentRoot ? ((IPackageFragmentRoot) parent) : getPackageFragmentRoot(parent);\n+\t}\n+\n+\tprivate TypeNames getQualifiedTypeNames(String typeLocator, String packageName, String simpleName, IJavaProject project) {\n+\t\tTypeNames qualifiedTypeNames = new TypeNames(project);\n+\t\tString primaryTypeFqn = getQualifedTypeName(packageName, simpleName);\n+\n+\t\tchar[][] typeNames = null;\n+\t\tif (state != null) {\n+\t\t\ttypeNames = state.getDefinedTypeNamesFor(typeLocator);\n+\t\t}\n+\n+\t\tif (typeNames == null) {\n+\t\t\tTypeNames newTypeNames = new TypeNames(project);\n+\t\t\tnewTypeNames.addTypeName(primaryTypeFqn, primaryTypeFqn);\n+\t\t\treturn newTypeNames;\n+\t\t}\n+\n+\t\tfor (char[] typeName : typeNames) {\n+\t\t\tString qualifiedTypeName = getQualifedTypeName(packageName, new String(typeName));\n+\t\t\tqualifiedTypeNames.addTypeName(qualifiedTypeName, primaryTypeFqn);\n+\t\t}\n+\n+\t\treturn qualifiedTypeNames;\n+\t}\n+\n+\tprivate String getQualifedTypeName(String packageName, String simpleTypeName) {\n+\t\treturn packageName == null ? simpleTypeName : packageName + \".\" + simpleTypeName;\n+\t}\n+\n+\tprivate String getTypeLocator(ICompilationUnit compilationUnit) {\n+\t\tIResource resource = compilationUnit.getResource();\n+\t\tif (resource != null && resource.getProjectRelativePath() != null) {\n+\t\t\treturn resource.getProjectRelativePath().toString();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getPackageName(ICompilationUnit compilationUnit) {\n+\t\tIJavaElement parent = compilationUnit.getParent();\n+\t\tif (parent instanceof IPackageFragment && !((IPackageFragment) parent).isDefaultPackage()) {\n+\t\t\treturn ((IPackageFragment) parent).getElementName();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate String getSimplePrimaryTypeName(ICompilationUnit compilationUnit) {\n+\t\tString elementName = compilationUnit.getElementName();\n+\t\treturn elementName.substring(0, elementName.lastIndexOf(\".\"));\n+\t}\n+\n+\tprivate SimpleLookupTable getReferences() {\n+\t\tif (references != null) {\n+\t\t\treturn references;\n+\t\t}\n+\n+\t\tif (state == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tObject referencesField = readField(state, \"references\", null);\n+\t\tif (referencesField instanceof SimpleLookupTable) {\n+\t\t\treferences = (SimpleLookupTable) referencesField;\n+\t\t}\n+\t\treturn references;\n+\t}\n+\n+\tprivate Object readField(Object instance, String fieldName, Object defaultValue) {\n+\t\ttry {\n+\t\t\tField field = instance.getClass().getDeclaredField(fieldName);\n+\t\t\tfield.setAccessible(true);\n+\t\t\tObject value = field.get(instance);\n+\t\t\tif (value != null) {\n+\t\t\t\treturn value;\n+\t\t\t}\n+\t\t\treturn defaultValue;\n+\t\t} catch (Exception e) {\n+\t\t\tif (LOG.isEnabledFor(Level.ERROR)) {", "originalCommit": "1354ed12caf331759bcb1453d530e3eed9440857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEzMjcwMg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1377#discussion_r398132702", "bodyText": "You are right. I'll made the change.", "author": "nbhusare", "createdAt": "2020-03-25T20:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc2MzU0NA=="}], "type": "inlineReview"}, {"oid": "9dd7c611b2e34c67215d917139d6e96de5c84b39", "url": "https://github.com/eclipse/xtext-eclipse/commit/9dd7c611b2e34c67215d917139d6e96de5c84b39", "message": "Migrated the Xtend code from org.eclipse.xtext.common.types.ui project to Java\nDeleted the xtend-gen folder and updated the .classpath file\nRemoved *.xbase.lib and *.xtend.lib dependencies from the manifest file\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-03-25T20:07:44Z", "type": "commit"}, {"oid": "9dd7c611b2e34c67215d917139d6e96de5c84b39", "url": "https://github.com/eclipse/xtext-eclipse/commit/9dd7c611b2e34c67215d917139d6e96de5c84b39", "message": "Migrated the Xtend code from org.eclipse.xtext.common.types.ui project to Java\nDeleted the xtend-gen folder and updated the .classpath file\nRemoved *.xbase.lib and *.xtend.lib dependencies from the manifest file\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>", "committedDate": "2020-03-25T20:07:44Z", "type": "forcePushed"}]}