{"pr_number": 1592, "pr_title": "ported formatter to java", "pr_createdAt": "2020-11-23T13:34:14Z", "pr_url": "https://github.com/eclipse/xtext-eclipse/pull/1592", "timeline": [{"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "url": "https://github.com/eclipse/xtext-eclipse/commit/52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "message": "ported formatter to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-11-23T13:35:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MDk3Nw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530140977", "bodyText": "change the local parameter name from it to event", "author": "miklossy", "createdAt": "2020-11-25T06:48:40Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MTA2OQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530141069", "bodyText": "change the local parameter name from it to command", "author": "miklossy", "createdAt": "2020-11-25T06:49:02Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MTE4MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530141181", "bodyText": "change the local parameter name from it to names", "author": "miklossy", "createdAt": "2020-11-25T06:49:24Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MTc0NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530141744", "bodyText": "set a space before - and +", "author": "miklossy", "createdAt": "2020-11-25T06:50:56Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjE0Mg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142142", "bodyText": "change the local parameter name from it to names", "author": "miklossy", "createdAt": "2020-11-25T06:52:01Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjI1OA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142258", "bodyText": "change the local parameter name from it to sm", "author": "miklossy", "createdAt": "2020-11-25T06:52:18Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {\n+\t\treturn Iterables.getFirst(IterableExtensions.sortBy(it, s -> -s.length()), null);\n+\t}\n+\n+\tprivate boolean hasResetEvents(Statemachine it) {", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjQyMw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142423", "bodyText": "change the local parameter name from it to sm", "author": "miklossy", "createdAt": "2020-11-25T06:52:37Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {\n+\t\treturn Iterables.getFirst(IterableExtensions.sortBy(it, s -> -s.length()), null);\n+\t}\n+\n+\tprivate boolean hasResetEvents(Statemachine it) {\n+\t\treturn !it.getResetEvents().isEmpty();\n+\t}\n+\n+\tprivate boolean hasCommands(Statemachine it) {", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjQ3Mw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142473", "bodyText": "change the local parameter name from it to sm", "author": "miklossy", "createdAt": "2020-11-25T06:52:43Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {\n+\t\treturn Iterables.getFirst(IterableExtensions.sortBy(it, s -> -s.length()), null);\n+\t}\n+\n+\tprivate boolean hasResetEvents(Statemachine it) {\n+\t\treturn !it.getResetEvents().isEmpty();\n+\t}\n+\n+\tprivate boolean hasCommands(Statemachine it) {\n+\t\treturn !it.getCommands().isEmpty();\n+\t}\n+\n+\tprivate boolean hasStates(Statemachine it) {", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjU1Ng==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142556", "bodyText": "change the local parameter name from it to state", "author": "miklossy", "createdAt": "2020-11-25T06:52:53Z", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {\n+\t\treturn Iterables.getFirst(IterableExtensions.sortBy(it, s -> -s.length()), null);\n+\t}\n+\n+\tprivate boolean hasResetEvents(Statemachine it) {\n+\t\treturn !it.getResetEvents().isEmpty();\n+\t}\n+\n+\tprivate boolean hasCommands(Statemachine it) {\n+\t\treturn !it.getCommands().isEmpty();\n+\t}\n+\n+\tprivate boolean hasStates(Statemachine it) {\n+\t\treturn !it.getStates().isEmpty();\n+\t}\n+\n+\tprivate boolean isLastState(State it) {", "originalCommit": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ed72d92104e259badc2b9d47e8467a064139d290", "url": "https://github.com/eclipse/xtext-eclipse/commit/ed72d92104e259badc2b9d47e8467a064139d290", "message": "ported formatter to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-11-25T07:11:25Z", "type": "commit"}, {"oid": "ed72d92104e259badc2b9d47e8467a064139d290", "url": "https://github.com/eclipse/xtext-eclipse/commit/ed72d92104e259badc2b9d47e8467a064139d290", "message": "ported formatter to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-11-25T07:11:25Z", "type": "forcePushed"}]}