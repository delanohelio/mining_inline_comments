{"pr_number": 172, "pr_title": "StateMachine rewrite", "pr_createdAt": "2020-08-07T14:33:19Z", "pr_url": "https://github.com/temporalio/sdk-java/pull/172", "timeline": [{"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "url": "https://github.com/temporalio/sdk-java/commit/13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "message": "StateMachine refactoring", "committedDate": "2020-08-07T14:30:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzMjAyMg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467132022", "bodyText": "[Question] - Should this type of \"default\" be set on the Server side instead?", "author": "mastermanu", "createdAt": "2020-08-07T16:05:08Z", "path": "src/main/java/io/temporal/activity/ActivityOptions.java", "diffHunk": "@@ -185,7 +185,7 @@ public ActivityOptions validateAndBuildWithDefaults() {\n           taskQueue,\n           retryOptions,\n           contextPropagators,\n-          cancellationType);\n+          cancellationType == null ? ActivityCancellationType.TRY_CANCEL : cancellationType);", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1ODAwOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467158009", "bodyText": "This is purely client side option. It is not passed to the service anywhere.", "author": "mfateev", "createdAt": "2020-08-07T16:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzMjAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNzc5NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467137794", "bodyText": "[Nit] dumb question (based on similar change above), when do we use single quote (') vs double quote (\") for these types of messages?", "author": "mastermanu", "createdAt": "2020-08-07T16:15:58Z", "path": "src/main/java/io/temporal/internal/grpc/GrpcTracingInterceptor.java", "diffHunk": "@@ -49,7 +49,7 @@\n         next.newCall(method, callOptions)) {\n       @Override\n       public void sendMessage(ReqT message) {\n-        log.trace(\"Invoking \" + method.getFullMethodName() + \"with input: \" + message);\n+        log.trace(\"Invoking \\\"\" + method.getFullMethodName() + \"\\\" with input: \" + message);", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1ODUzNg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467158536", "bodyText": "There is no guideline here. I would support coming up with one and making sure that all the log messages obey it.", "author": "mfateev", "createdAt": "2020-08-07T16:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNzc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzODY0Mw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467138643", "bodyText": "even with the comment, it is still not obvious to me what the difference is between execution latency and execution total latency?", "author": "mastermanu", "createdAt": "2020-08-07T16:17:34Z", "path": "src/main/java/io/temporal/internal/metrics/MetricsType.java", "diffHunk": "@@ -42,13 +42,19 @@\n       TEMPORAL_METRICS_PREFIX + \"workflow_task_schedule_to_start_latency\";\n   public static final String WORKFLOW_TASK_EXECUTION_LATENCY =\n       TEMPORAL_METRICS_PREFIX + \"workflow_task_execution_latency\";\n+  // Total latency of a workflow task which can include multiple synchronous decision tasks", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MTM3Mw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467141373", "bodyText": "[Nit] also styling question on when to use \"//\" comment vs \"/** */\" comment delimiters, as is done below on lines 48, 51", "author": "mastermanu", "createdAt": "2020-08-07T16:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzODY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NDUyMA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467174520", "bodyText": "Fixed comments.\nTo understand this comment you need to know about workflow task heartbeat feature. Basically a workflow task when reporting completion can set ForceCreateNewWorkflowTask property to true on RespondWorkflowTaskCompletedRequest. In this case, the new workflow task is created immediately and returned as a response to the RespondWorkflowTaskCompletedRequest call. Such call acts as a heartbeat that extends the duration of a workflow task. Thus a single total execution latency of a workflow task can be larger than latencies of multiple such synchronously created tasks.", "author": "mfateev", "createdAt": "2020-08-07T17:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzODY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MzMxNg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467143316", "bodyText": "[Nit] no single or double quote delimiters around activityTask here?", "author": "mastermanu", "createdAt": "2020-08-07T16:26:23Z", "path": "src/main/java/io/temporal/internal/replay/ExecuteLocalActivityParameters.java", "diffHunk": "@@ -24,19 +24,17 @@\n public class ExecuteLocalActivityParameters {\n \n   private final PollActivityTaskQueueResponse.Builder activityTask;\n-  private final long elapsedTime;\n \n-  public ExecuteLocalActivityParameters(\n-      PollActivityTaskQueueResponse.Builder activityTask, long elapsedTime) {\n+  public ExecuteLocalActivityParameters(PollActivityTaskQueueResponse.Builder activityTask) {\n     this.activityTask = activityTask;\n-    this.elapsedTime = elapsedTime;\n   }\n \n   public PollActivityTaskQueueResponse.Builder getActivityTask() {\n     return activityTask;\n   }\n \n-  public long getElapsedTime() {\n-    return elapsedTime;\n+  @Override\n+  public String toString() {\n+    return \"ExecuteLocalActivityParameters{\" + \"activityTask=\" + activityTask + '}';", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MzgyOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467143829", "bodyText": "Also you can remove the first plus sign and concatenate the first two strings (e.g. \"ExecuteLocalActivityParameters{activityTask=\" + activityTask + \"}\"", "author": "mastermanu", "createdAt": "2020-08-07T16:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MzMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NzYwNw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467147607", "bodyText": "Curious why some of these methods have full comments (such as startChildWorkflow), but then some like this one (signalExternalWorkflowExecution) don't", "author": "mastermanu", "createdAt": "2020-08-07T16:35:01Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowContext.java", "diffHunk": "@@ -104,39 +104,39 @@\n    * @param parameters An object which encapsulates all the information required to schedule an\n    *     activity for execution\n    * @param callback Callback that is called upon activity completion or failure.\n-   * @return cancellation handle. Invoke {@link Consumer#accept(Object)} to cancel activity task.\n+   * @return cancellation handle. Invoke {@link Functions.Proc1#apply(Object)} to cancel activity\n+   *     task.\n    */\n-  Consumer<Exception> scheduleActivityTask(\n-      ExecuteActivityParameters parameters, BiConsumer<Optional<Payloads>, Exception> callback);\n+  Functions.Proc1<Exception> scheduleActivityTask(\n+      ExecuteActivityParameters parameters, Functions.Proc2<Optional<Payloads>, Failure> callback);\n \n-  Consumer<Exception> scheduleLocalActivityTask(\n+  Functions.Proc scheduleLocalActivityTask(\n       ExecuteLocalActivityParameters parameters,\n-      BiConsumer<Optional<Payloads>, Exception> callback);\n+      Functions.Proc2<Optional<Payloads>, Failure> callback);\n \n   /**\n    * Start child workflow.\n    *\n    * @param parameters An object which encapsulates all the information required to schedule a child\n    *     workflow for execution\n    * @param callback Callback that is called upon child workflow completion or failure.\n-   * @return cancellation handle. Invoke {@link Consumer#accept(Object)} to cancel activity task.\n+   * @return cancellation handle. Invoke {@link Functions.Proc1#apply(Object)} to cancel activity\n+   *     task.\n    */\n-  Consumer<Exception> startChildWorkflow(\n+  Functions.Proc1<Exception> startChildWorkflow(\n       StartChildWorkflowExecutionParameters parameters,\n-      Consumer<WorkflowExecution> executionCallback,\n-      BiConsumer<Optional<Payloads>, Exception> callback);\n+      Functions.Proc1<WorkflowExecution> executionCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> callback);\n \n-  Consumer<Exception> signalWorkflowExecution(\n+  Functions.Proc1<Exception> signalExternalWorkflowExecution(", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NDM1NQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467154355", "bodyText": "hopefully we added a unit test to cover this as this should have been caught when I was syncing to Alex's latest proto changes", "author": "mastermanu", "createdAt": "2020-08-07T16:48:43Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowTaskHandler.java", "diffHunk": "@@ -104,10 +108,27 @@ public ReplayWorkflowTaskHandler(\n       return handleWorkflowTaskImpl(workflowTask.toBuilder(), metricsScope);\n     } catch (Throwable e) {\n       metricsScope.counter(MetricsType.WORKFLOW_TASK_EXECUTION_FAILURE_COUNTER).inc(1);\n+      // Fail workflow and not a task as WorkflowExecutionException is thrown only if FailWorkflow\n+      // policy was set.\n+      if (e instanceof WorkflowExecutionException) {\n+        RespondWorkflowTaskCompletedRequest response =\n+            RespondWorkflowTaskCompletedRequest.newBuilder()\n+                .setTaskToken(workflowTask.getTaskToken())\n+                .setIdentity(options.getIdentity())\n+                .addCommands(\n+                    Command.newBuilder()\n+                        .setCommandType(CommandType.COMMAND_TYPE_FAIL_WORKFLOW_EXECUTION)\n+                        .setFailWorkflowExecutionCommandAttributes(\n+                            FailWorkflowExecutionCommandAttributes.newBuilder()\n+                                .setFailure(((WorkflowExecutionException) e).getFailure()))\n+                        .build())\n+                .build();\n+        return new WorkflowTaskHandler.Result(workflowType, response, null, null, null, false);\n+      }\n       // Only fail workflow task on the first attempt, subsequent failures of the same workflow task\n       // should timeout. This is to avoid spin on the failed workflow task as the service doesn't\n       // yet increase the retry interval.\n-      if (workflowTask.getAttempt() > 0) {\n+      if (workflowTask.getAttempt() > 1) {", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ4NTYwOA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467485608", "bodyText": "Good catch. We had a test that ensured that the worker doesn't spin on the task failure. But after I added an additional check that the task failure is reported exactly once I found that it wasn't doing so. Here is the new unit test and the fix. The unit test fails with attempts condition changed.", "author": "mfateev", "createdAt": "2020-08-08T17:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NjAwMQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467156001", "bodyText": "[Nit] what does it mean by return \"true if new task should be created synchronously\"? Does this mean not null?", "author": "mastermanu", "createdAt": "2020-08-07T16:52:08Z", "path": "src/main/java/io/temporal/internal/replay/WorkflowExecutor.java", "diffHunk": "@@ -24,45 +24,53 @@\n import io.temporal.api.query.v1.WorkflowQuery;\n import io.temporal.api.query.v1.WorkflowQueryResult;\n import io.temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponseOrBuilder;\n+import java.time.Duration;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n \n public interface WorkflowExecutor {\n \n-  WorkflowTaskResult handleWorkflowTask(PollWorkflowTaskQueueResponseOrBuilder workflowTask)\n-      throws Throwable;\n+  /**\n+   * Handles a single workflow task.\n+   *\n+   * @param workflowTask task to handle\n+   * @return true if new task should be created synchronously as local activities are still running.", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ4NTc0NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467485744", "bodyText": "See my earlier comment about force creating workflow tasks.", "author": "mfateev", "createdAt": "2020-08-08T17:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NjQ0Ng==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467156446", "bodyText": "we swapped the order to two arguments with the same type...hopefully all the callers have been updated", "author": "mastermanu", "createdAt": "2020-08-07T16:53:03Z", "path": "src/main/java/io/temporal/internal/replay/WorkflowExecutor.java", "diffHunk": "@@ -24,45 +24,53 @@\n import io.temporal.api.query.v1.WorkflowQuery;\n import io.temporal.api.query.v1.WorkflowQueryResult;\n import io.temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponseOrBuilder;\n+import java.time.Duration;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n \n public interface WorkflowExecutor {\n \n-  WorkflowTaskResult handleWorkflowTask(PollWorkflowTaskQueueResponseOrBuilder workflowTask)\n-      throws Throwable;\n+  /**\n+   * Handles a single workflow task.\n+   *\n+   * @param workflowTask task to handle\n+   * @return true if new task should be created synchronously as local activities are still running.\n+   */\n+  WorkflowTaskResult handleWorkflowTask(PollWorkflowTaskQueueResponseOrBuilder workflowTask);\n \n   Optional<Payloads> handleQueryWorkflowTask(\n-      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query) throws Throwable;\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query);\n \n   void close();\n \n+  Duration getWorkflowTaskTimeout();\n+\n   class WorkflowTaskResult {\n+\n     private final List<Command> commands;\n-    private final boolean forceCreateNewWorkflowTask;\n     private final boolean finalCommand;\n     private final Map<String, WorkflowQueryResult> queryResults;\n+    private final boolean forceWorkflowTask;\n \n     public WorkflowTaskResult(\n         List<Command> commands,\n         Map<String, WorkflowQueryResult> queryResults,\n-        boolean forceCreateNewWorkflowTask,\n-        boolean finalCommand) {\n+        boolean finalCommand,", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ4NzUzNQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467487535", "bodyText": "Agree that it is error-prone. Changed WorkflowTaskResult to use the Builder pattern.", "author": "mfateev", "createdAt": "2020-08-08T17:42:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1Nzg5OQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467157899", "bodyText": "Name of class implies two possible configurations, but it looks like its ActionOrEventTypeOrCommandType (three)", "author": "mastermanu", "createdAt": "2020-08-07T16:56:01Z", "path": "src/main/java/io/temporal/internal/statemachines/ActionOrEventType.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import com.google.common.base.Objects;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+\n+class ActionOrEventType<Action> {", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5ODk4MA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467498980", "bodyText": "Refactored StateMachine nomenclature to match the standard one.", "author": "mfateev", "createdAt": "2020-08-08T19:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1Nzg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MjMwNQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467162305", "bodyText": "is this a typo / copy paste error (SCHEDULE_COMMAND_CREATED twice)? Maybe I'm interpreting this incorrectly? I assumed first line is current state, subsequent line is potential transition, second line is final state and last line is an additional callback to run. Or should we add another state between \"CREATED\" and \"SCHEDULE_COMMAND_CREATED\"?", "author": "mastermanu", "createdAt": "2020-08-07T17:04:33Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.Action, ActivityStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, Action, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ5OTA4Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467499087", "bodyText": "This is practically saying that this event is not causing a state transition. We could introduce another event here, but it doesn't really bring any value as no action is executed.", "author": "mfateev", "createdAt": "2020-08-08T19:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MjMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NzEwNA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467167104", "bodyText": "for this state and the cancel_command_Created state, we don't have transitions for a timed out event?", "author": "mastermanu", "createdAt": "2020-08-07T17:14:15Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.Action, ActivityStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, Action, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            Action.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelScheduleCommand)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            Action.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED,\n+            Action.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjgwNQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468106805", "bodyText": "I've added unit tests that demonstrate that these transitions are not possible. The basic idea is that the workflow code always executes in the context of an event loop. It causes activity timeouts to be delivered before the code that causes the timeout which generates the cancel command.", "author": "mfateev", "createdAt": "2020-08-10T18:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2Nzk4MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467167981", "bodyText": "where are these 3 *_CANCEL_REQUESTED states used?", "author": "mastermanu", "createdAt": "2020-08-07T17:16:04Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.Action, ActivityStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzQyMg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468107422", "bodyText": "Good catch. Removed.", "author": "mfateev", "createdAt": "2020-08-10T18:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2Nzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3Mzg5OA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467173898", "bodyText": "should we have string constants file for these error messages so that its easy for a technical writer to review or so we can do translations (in the future)", "author": "mastermanu", "createdAt": "2020-08-07T17:28:05Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.Action, ActivityStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, Action, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            Action.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelScheduleCommand)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            Action.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED,\n+            Action.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::cancelScheduleCommandNotifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::cancelScheduleCommandNotifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCancellationFromEvent);\n+  }\n+\n+  private final ExecuteActivityParameters parameters;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Failure> completionCallback;\n+\n+  /**\n+   * @param parameters attributes used to schedule an activity\n+   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,\n+   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents\n+   * @param commandSink sink to send commands\n+   * @return an instance of ActivityCommands\n+   */\n+  public static ActivityStateMachine newInstance(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    return new ActivityStateMachine(parameters, completionCallback, commandSink);\n+  }\n+\n+  private ActivityStateMachine(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.parameters = parameters;\n+    this.completionCallback = completionCallback;\n+    action(Action.SCHEDULE);\n+  }\n+\n+  public void createScheduleActivityTaskCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK)\n+            .setScheduleActivityTaskCommandAttributes(parameters.getAttributes())\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    } else {\n+      action(Action.CANCEL);\n+    }\n+  }\n+\n+  private void cancelScheduleCommand() {\n+    cancelInitialCommand();\n+    if (parameters.getCancellationType() != ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceledIfTryCancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.TRY_CANCEL) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceled() {\n+    Failure canceledFailure =\n+        Failure.newBuilder()\n+            .setSource(JAVA_SDK)\n+            .setCanceledFailureInfo(CanceledFailureInfo.getDefaultInstance())\n+            .build();\n+    completionCallback.apply(Optional.empty(), canceledFailure);\n+  }\n+\n+  private void notifyCompleted() {\n+    ActivityTaskCompletedEventAttributes completedAttr =\n+        currentEvent.getActivityTaskCompletedEventAttributes();\n+    Optional<Payloads> result =\n+        completedAttr.hasResult() ? Optional.of(completedAttr.getResult()) : Optional.empty();\n+    completionCallback.apply(result, null);\n+  }\n+\n+  private void notifyFailed() {\n+    ActivityTaskFailedEventAttributes failed = currentEvent.getActivityTaskFailedEventAttributes();\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+    ActivityFailureInfo failureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setIdentity(failed.getIdentity())\n+            .setRetryState(failed.getRetryState())\n+            .setScheduledEventId(failed.getScheduledEventId())\n+            .setStartedEventId(failed.getStartedEventId())\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(failureInfo)\n+            .setCause(failed.getFailure())\n+            .setMessage(\"Activity task failed\")\n+            .build();\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyTimedOut() {\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+\n+    ActivityTaskTimedOutEventAttributes timedOut =\n+        currentEvent.getActivityTaskTimedOutEventAttributes();\n+\n+    ActivityFailureInfo failureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setRetryState(timedOut.getRetryState())\n+            .setScheduledEventId(timedOut.getScheduledEventId())\n+            .setStartedEventId(timedOut.getStartedEventId())\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(failureInfo)\n+            .setCause(timedOut.getFailure())\n+            .setMessage(\"Activity task timedOut\")", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzg4Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468107887", "bodyText": "Would you file an issue for this? I think it is a great idea, but we want to do it holistically with the whole SDK.", "author": "mfateev", "createdAt": "2020-08-10T18:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkyNjg0OQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468926849", "bodyText": "Hopefully we will never do translations :-)", "author": "alexshtin", "createdAt": "2020-08-11T23:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3Mzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NzAxMg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467177012", "bodyText": "we don't have any information as to why cancellation failed?", "author": "mastermanu", "createdAt": "2020-08-07T17:34:41Z", "path": "src/main/java/io/temporal/internal/statemachines/CancelExternalStateMachine.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.workflow.CancelExternalWorkflowException;\n+import io.temporal.workflow.Functions;\n+\n+final class CancelExternalStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        CancelExternalStateMachine.State,\n+        CancelExternalStateMachine.Action,\n+        CancelExternalStateMachine> {\n+\n+  private final RequestCancelExternalWorkflowExecutionCommandAttributes requestCancelAttributes;\n+\n+  private final Functions.Proc2<Void, RuntimeException> completionCallback;\n+\n+  /**\n+   * @param attributes attributes to use to cancel external worklfow\n+   * @param completionCallback one of ExternalWorkflowExecutionCancelRequestedEvent,\n+   *     RequestCancelExternalWorkflowExecutionFailedEvent\n+   * @param commandSink sink to send commands\n+   */\n+  public static void newInstance(\n+      RequestCancelExternalWorkflowExecutionCommandAttributes attributes,\n+      Functions.Proc2<Void, RuntimeException> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    new CancelExternalStateMachine(attributes, completionCallback, commandSink);\n+  }\n+\n+  private CancelExternalStateMachine(\n+      RequestCancelExternalWorkflowExecutionCommandAttributes requestCancelAttributes,\n+      Functions.Proc2<Void, RuntimeException> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.requestCancelAttributes = requestCancelAttributes;\n+    this.completionCallback = completionCallback;\n+    action(Action.SCHEDULE);\n+  }\n+\n+  enum Action {\n+    SCHEDULE\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED,\n+    REQUEST_CANCEL_EXTERNAL_COMMAND_RECORDED,\n+    CANCEL_REQUESTED,\n+    REQUEST_CANCEL_FAILED,\n+  }\n+\n+  private static StateMachine<State, Action, CancelExternalStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, CancelExternalStateMachine>newInstance(\n+            \"CancelExternal\", State.CREATED, State.CANCEL_REQUESTED, State.REQUEST_CANCEL_FAILED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED,\n+            CancelExternalStateMachine::createCancelExternalCommand)\n+        .add(\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION,\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED)\n+        .add(\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED,\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_RECORDED)\n+        .add(\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_RECORDED,\n+            EventType.EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED,\n+            State.CANCEL_REQUESTED,\n+            CancelExternalStateMachine::notifyCompleted)\n+        .add(\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_RECORDED,\n+            EventType.EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED,\n+            State.REQUEST_CANCEL_FAILED,\n+            CancelExternalStateMachine::notifyFailed);\n+  }\n+\n+  private void createCancelExternalCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION)\n+            .setRequestCancelExternalWorkflowExecutionCommandAttributes(requestCancelAttributes)\n+            .build());\n+  }\n+\n+  private void notifyCompleted() {\n+    completionCallback.apply(null, null);\n+  }\n+\n+  private void notifyFailed() {\n+    WorkflowExecution execution =\n+        WorkflowExecution.newBuilder()\n+            .setWorkflowId(requestCancelAttributes.getWorkflowId())\n+            .setRunId(requestCancelAttributes.getRunId())\n+            .build();\n+    completionCallback.apply(null, new CancelExternalWorkflowException(execution, \"\", null));", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODExMDQxNA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468110414", "bodyText": "Added message.", "author": "mfateev", "createdAt": "2020-08-10T18:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NzAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MDI1MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467180251", "bodyText": "can't get a cancel event type here?", "author": "mastermanu", "createdAt": "2020-08-07T17:41:23Z", "path": "src/main/java/io/temporal/internal/statemachines/ChildWorkflowStateMachine.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes;\n+import io.temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.client.WorkflowExecutionAlreadyStarted;\n+import io.temporal.common.converter.EncodedValues;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.internal.replay.ChildWorkflowTaskFailedException;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ChildWorkflowStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ChildWorkflowStateMachine.State,\n+        ChildWorkflowStateMachine.Action,\n+        ChildWorkflowStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_EVENT_RECORDED,\n+    STARTED,\n+    START_FAILED,\n+    COMPLETED,\n+    FAILED,\n+    CANCELED,\n+    TIMED_OUT,\n+    TERMINATED,\n+  }\n+\n+  private static StateMachine<State, Action, ChildWorkflowStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ChildWorkflowStateMachine>newInstance(\n+            \"ChildWorkflow\",\n+            State.CREATED,\n+            State.START_FAILED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.CANCELED,\n+            State.TIMED_OUT,\n+            State.TERMINATED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.START_COMMAND_CREATED,\n+            ChildWorkflowStateMachine::createStartChildCommand)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION,\n+            State.START_COMMAND_CREATED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED,\n+            State.START_EVENT_RECORDED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            Action.CANCEL,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::cancelStartChildCommand)\n+        .add(\n+            State.START_EVENT_RECORDED,", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODExMDgwNA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468110804", "bodyText": "ChildWorkflow is canceled using CancelExternalStateMachine.", "author": "mfateev", "createdAt": "2020-08-10T18:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MDI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwNjIzNg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467206236", "bodyText": "is it guaranteed that this is the only reason why we could not start a workflow?", "author": "mastermanu", "createdAt": "2020-08-07T18:36:12Z", "path": "src/main/java/io/temporal/internal/statemachines/ChildWorkflowStateMachine.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes;\n+import io.temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.client.WorkflowExecutionAlreadyStarted;\n+import io.temporal.common.converter.EncodedValues;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.internal.replay.ChildWorkflowTaskFailedException;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ChildWorkflowStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ChildWorkflowStateMachine.State,\n+        ChildWorkflowStateMachine.Action,\n+        ChildWorkflowStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_EVENT_RECORDED,\n+    STARTED,\n+    START_FAILED,\n+    COMPLETED,\n+    FAILED,\n+    CANCELED,\n+    TIMED_OUT,\n+    TERMINATED,\n+  }\n+\n+  private static StateMachine<State, Action, ChildWorkflowStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ChildWorkflowStateMachine>newInstance(\n+            \"ChildWorkflow\",\n+            State.CREATED,\n+            State.START_FAILED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.CANCELED,\n+            State.TIMED_OUT,\n+            State.TERMINATED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.START_COMMAND_CREATED,\n+            ChildWorkflowStateMachine::createStartChildCommand)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION,\n+            State.START_COMMAND_CREATED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED,\n+            State.START_EVENT_RECORDED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            Action.CANCEL,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::cancelStartChildCommand)\n+        .add(\n+            State.START_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED,\n+            State.STARTED,\n+            ChildWorkflowStateMachine::notifyStarted)\n+        .add(\n+            State.START_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED,\n+            State.START_FAILED,\n+            ChildWorkflowStateMachine::notifyStartFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED,\n+            State.COMPLETED,\n+            ChildWorkflowStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED,\n+            State.FAILED,\n+            ChildWorkflowStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ChildWorkflowStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::notifyCanceled)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED,\n+            State.TERMINATED,\n+            ChildWorkflowStateMachine::notifyTerminated);\n+  }\n+\n+  private final StartChildWorkflowExecutionCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<WorkflowExecution> startedCallback;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Exception> completionCallback;\n+\n+  /**\n+   * Creates a new child workflow state machine\n+   *\n+   * @param attributes child workflow start command attributes\n+   * @param startedCallback\n+   * @param completionCallback invoked when child reports completion or failure. The following types\n+   *     of events can be passed to the callback: StartChildWorkflowExecutionFailedEvent,\n+   *     ChildWorkflowExecutionCompletedEvent, ChildWorkflowExecutionFailedEvent,\n+   *     ChildWorkflowExecutionTimedOutEvent, ChildWorkflowExecutionCanceledEvent,\n+   *     ChildWorkflowExecutionTerminatedEvent.\n+   * @return cancellation callback that should be invoked to cancel the child\n+   */\n+  public static ChildWorkflowStateMachine newInstance(\n+      StartChildWorkflowExecutionCommandAttributes attributes,\n+      Functions.Proc1<WorkflowExecution> startedCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    return new ChildWorkflowStateMachine(\n+        attributes, startedCallback, completionCallback, commandSink);\n+  }\n+\n+  private ChildWorkflowStateMachine(\n+      StartChildWorkflowExecutionCommandAttributes startAttributes,\n+      Functions.Proc1<WorkflowExecution> startedCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.startAttributes = startAttributes;\n+    this.startedCallback = startedCallback;\n+    this.completionCallback = completionCallback;\n+    action(Action.SCHEDULE);\n+  }\n+\n+  public void createStartChildCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION)\n+            .setStartChildWorkflowExecutionCommandAttributes(startAttributes)\n+            .build());\n+  }\n+\n+  public boolean isCancellable() {\n+    return State.START_COMMAND_CREATED == getState();\n+  }\n+\n+  /**\n+   * Cancellation through this class is valid only when start child workflow command is not sent\n+   * yet. Cancellation of an initiated child workflow is done through CancelExternalCommands. So all\n+   * of the types besides ABANDON are treated differently.\n+   */\n+  public void cancel() {\n+    action(Action.CANCEL);\n+  }\n+\n+  private void cancelStartChildCommand() {\n+    cancelInitialCommand();\n+    CanceledFailure failure = new CanceledFailure(\"Child canceled\", null, null);\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyCompleted() {\n+    ChildWorkflowExecutionCompletedEventAttributes attributes =\n+        currentEvent.getChildWorkflowExecutionCompletedEventAttributes();\n+    Optional<Payloads> result =\n+        attributes.hasResult() ? Optional.of(attributes.getResult()) : Optional.empty();\n+    completionCallback.apply(result, null);\n+  }\n+\n+  private void notifyStartFailed() {\n+    StartChildWorkflowExecutionFailedEventAttributes attributes =\n+        currentEvent.getStartChildWorkflowExecutionFailedEventAttributes();\n+    Exception failure =\n+        new ChildWorkflowTaskFailedException(\n+            currentEvent.getEventId(),\n+            WorkflowExecution.newBuilder().setWorkflowId(attributes.getWorkflowId()).build(),\n+            attributes.getWorkflowType(),\n+            RetryState.RETRY_STATE_NON_RETRYABLE_FAILURE,\n+            null);\n+    failure.initCause(\n+        new WorkflowExecutionAlreadyStarted(", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1MDE1Ng==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468250156", "bodyText": "Yes, according to StartChildWorkflowExecutionFailedCause", "author": "mfateev", "createdAt": "2020-08-11T00:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwNjIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwODU0Mg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467208542", "bodyText": "shouldn't we do this check before applying the callback?", "author": "mastermanu", "createdAt": "2020-08-07T18:41:21Z", "path": "src/main/java/io/temporal/internal/statemachines/DynamicTransitionTarget.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+class DynamicTransitionTarget<State, Data> implements TransitionTarget<State, Data> {\n+\n+  final DynamicCallback<State, Data> callback;\n+  State[] expectedStates;\n+  State state;\n+\n+  DynamicTransitionTarget(State[] expectedStates, DynamicCallback<State, Data> callback) {\n+    this.expectedStates = expectedStates;\n+    this.callback = callback;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"DynamicTransitionDestination{\" + \"state=\" + state + \", callback=\" + callback + '}';\n+  }\n+\n+  @Override\n+  public State apply(Data data) {\n+    state = callback.apply(data);\n+    for (State s : expectedStates) {\n+      if (s.equals(state)) {\n+        return state;\n+      }\n+    }\n+    throw new IllegalStateException(", "originalCommit": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1MDYyMQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468250621", "bodyText": "After any such exception, the whole StateMachines object should be thrown away.", "author": "mfateev", "createdAt": "2020-08-11T00:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwODU0Mg=="}], "type": "inlineReview"}, {"oid": "0c08449829228c32f344cdf21fb6c0dc0c60a7f9", "url": "https://github.com/temporalio/sdk-java/commit/0c08449829228c32f344cdf21fb6c0dc0c60a7f9", "message": "PR feedback and broken unit test", "committedDate": "2020-08-08T16:45:18Z", "type": "commit"}, {"oid": "250f70dc022bffc0c2ea350a082fb8b46e6067ec", "url": "https://github.com/temporalio/sdk-java/commit/250f70dc022bffc0c2ea350a082fb8b46e6067ec", "message": "Fixed workflow task failure reporting", "committedDate": "2020-08-08T17:17:49Z", "type": "commit"}, {"oid": "68db6c6c2da1c4fce870ff2c41cbfdade02928cd", "url": "https://github.com/temporalio/sdk-java/commit/68db6c6c2da1c4fce870ff2c41cbfdade02928cd", "message": "WorkflowTaskResult now is created through a Builder", "committedDate": "2020-08-08T17:41:51Z", "type": "commit"}, {"oid": "1b1254b636ad9dd6895e8dc2179bede07b2153ae", "url": "https://github.com/temporalio/sdk-java/commit/1b1254b636ad9dd6895e8dc2179bede07b2153ae", "message": "StateMachine nomenclature cleanup", "committedDate": "2020-08-08T19:55:54Z", "type": "commit"}, {"oid": "8243071768b41f6b6582987ccc86d93871443752", "url": "https://github.com/temporalio/sdk-java/commit/8243071768b41f6b6582987ccc86d93871443752", "message": "Merge branch 'master' of github.com:temporalio/temporal-java-sdk into state-machine-review", "committedDate": "2020-08-09T00:29:05Z", "type": "commit"}, {"oid": "4df71d6cae7d14e25ebeadb368b9f0342653e85c", "url": "https://github.com/temporalio/sdk-java/commit/4df71d6cae7d14e25ebeadb368b9f0342653e85c", "message": "initial command refactoring", "committedDate": "2020-08-09T05:38:02Z", "type": "commit"}, {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737", "url": "https://github.com/temporalio/sdk-java/commit/e1e3fa6db2903db82312a1b256c2a8046f098737", "message": "Added ActivityStateMachineTest and fixed cancellation failure", "committedDate": "2020-08-09T20:43:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNTkwMw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467635903", "bodyText": "[Nit] swap the order of these two state transitions just for consistency (have the self-transition appear first)", "author": "mastermanu", "createdAt": "2020-08-09T22:25:55Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,", "originalCommit": "e1e3fa6db2903db82312a1b256c2a8046f098737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY3Mjg5MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469672891", "bodyText": "Done", "author": "mfateev", "createdAt": "2020-08-13T03:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNjA1NQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467636055", "bodyText": "can we group the transitions by state? You have a bunch of transitions from state.STARTED above...feels like you should move this cancel up there as well. there are a few other transitions that can be sorted as well just for better readability", "author": "mastermanu", "createdAt": "2020-08-09T22:27:25Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before\n+        the event loop invocation) before the cancellation request.\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+             */\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(", "originalCommit": "e1e3fa6db2903db82312a1b256c2a8046f098737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1MzY5MA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468253690", "bodyText": "Done", "author": "mfateev", "createdAt": "2020-08-11T00:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNjA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNjI0Mg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467636242", "bodyText": "[Nit] typo = 'sate machine'", "author": "mastermanu", "createdAt": "2020-08-09T22:29:44Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before", "originalCommit": "e1e3fa6db2903db82312a1b256c2a8046f098737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1MzkwOA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468253908", "bodyText": "Fixed", "author": "mfateev", "createdAt": "2020-08-11T00:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNjI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNzU3MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467637571", "bodyText": "(more for my own knowledge than an actual comment), what does \"Abandon\" mean vs some of the other semantics and why would a developer choose one over the other? Does it mean the server will just perceive an activity timeout vs an explicit cancellation? Or does it mean we will wait for the server to acknowledge the cancel before actually cancelling? Or I guess it means the caller doesn't care to wait for the cancellation to actually be ACK'd, (s)he just wants it scheduled?", "author": "mastermanu", "createdAt": "2020-08-09T22:44:08Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before\n+        the event loop invocation) before the cancellation request.\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+             */\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.STARTED,\n+            ExplicitEvent.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::cancelCommandNotifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::cancelCommandNotifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCancellationFromEvent);\n+  }\n+\n+  private final ExecuteActivityParameters parameters;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Failure> completionCallback;\n+\n+  private long startedCommandEventId;\n+\n+  /**\n+   * @param parameters attributes used to schedule an activity\n+   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,\n+   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents\n+   * @param commandSink sink to send commands\n+   * @return an instance of ActivityCommands\n+   */\n+  public static ActivityStateMachine newInstance(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    return new ActivityStateMachine(parameters, completionCallback, commandSink);\n+  }\n+\n+  private ActivityStateMachine(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.parameters = parameters;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  public void createScheduleActivityTaskCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK)\n+            .setScheduleActivityTaskCommandAttributes(parameters.getAttributes())\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.ABANDON) {", "originalCommit": "e1e3fa6db2903db82312a1b256c2a8046f098737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NDQ2NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468254464", "bodyText": "Let me know if the existing JavaDoc is not clear.", "author": "mfateev", "createdAt": "2020-08-11T00:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNzU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODAyNA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467638024", "bodyText": "[Nit] these fields seem more specific to ActivityInfo vs. ActivityFailureInfo", "author": "mastermanu", "createdAt": "2020-08-09T22:48:58Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before\n+        the event loop invocation) before the cancellation request.\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+             */\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.STARTED,\n+            ExplicitEvent.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::cancelCommandNotifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::cancelCommandNotifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCancellationFromEvent);\n+  }\n+\n+  private final ExecuteActivityParameters parameters;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Failure> completionCallback;\n+\n+  private long startedCommandEventId;\n+\n+  /**\n+   * @param parameters attributes used to schedule an activity\n+   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,\n+   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents\n+   * @param commandSink sink to send commands\n+   * @return an instance of ActivityCommands\n+   */\n+  public static ActivityStateMachine newInstance(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    return new ActivityStateMachine(parameters, completionCallback, commandSink);\n+  }\n+\n+  private ActivityStateMachine(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.parameters = parameters;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  public void createScheduleActivityTaskCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK)\n+            .setScheduleActivityTaskCommandAttributes(parameters.getAttributes())\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    } else {\n+      explicitEvent(ExplicitEvent.CANCEL);\n+    }\n+  }\n+\n+  private void setStartedCommandEventId() {\n+    startedCommandEventId = currentEvent.getEventId();\n+  }\n+\n+  private void cancelCommandNotifyCancelled() {\n+    cancelCommand();\n+    if (parameters.getCancellationType() != ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceledIfTryCancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.TRY_CANCEL) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceled() {\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+    Failure canceledFailure =\n+        Failure.newBuilder()\n+            .setSource(JAVA_SDK)\n+            .setCanceledFailureInfo(CanceledFailureInfo.getDefaultInstance())\n+            .build();\n+    ActivityFailureInfo activityFailureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())", "originalCommit": "e1e3fa6db2903db82312a1b256c2a8046f098737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NDc4OQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468254789", "bodyText": "I don't understand this comment.", "author": "mfateev", "createdAt": "2020-08-11T00:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkyNjUzOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468926539", "bodyText": "We have some ActivityInfo-ish fields in ActivityFailureInfo. They are needed to find activity in which failure was happened.", "author": "alexshtin", "createdAt": "2020-08-11T23:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODU0NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467638544", "bodyText": "should this error message indicate the activity was canceled rather than timed out?", "author": "mastermanu", "createdAt": "2020-08-09T22:54:27Z", "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before\n+        the event loop invocation) before the cancellation request.\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+             */\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.STARTED,\n+            ExplicitEvent.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::cancelCommandNotifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::cancelCommandNotifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCancellationFromEvent);\n+  }\n+\n+  private final ExecuteActivityParameters parameters;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Failure> completionCallback;\n+\n+  private long startedCommandEventId;\n+\n+  /**\n+   * @param parameters attributes used to schedule an activity\n+   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,\n+   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents\n+   * @param commandSink sink to send commands\n+   * @return an instance of ActivityCommands\n+   */\n+  public static ActivityStateMachine newInstance(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    return new ActivityStateMachine(parameters, completionCallback, commandSink);\n+  }\n+\n+  private ActivityStateMachine(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.parameters = parameters;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  public void createScheduleActivityTaskCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK)\n+            .setScheduleActivityTaskCommandAttributes(parameters.getAttributes())\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    } else {\n+      explicitEvent(ExplicitEvent.CANCEL);\n+    }\n+  }\n+\n+  private void setStartedCommandEventId() {\n+    startedCommandEventId = currentEvent.getEventId();\n+  }\n+\n+  private void cancelCommandNotifyCancelled() {\n+    cancelCommand();\n+    if (parameters.getCancellationType() != ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceledIfTryCancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.TRY_CANCEL) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceled() {\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+    Failure canceledFailure =\n+        Failure.newBuilder()\n+            .setSource(JAVA_SDK)\n+            .setCanceledFailureInfo(CanceledFailureInfo.getDefaultInstance())\n+            .build();\n+    ActivityFailureInfo activityFailureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setIdentity(\"workflow\")\n+            .setScheduledEventId(getInitialCommandEventId())\n+            .setStartedEventId(startedCommandEventId)\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(activityFailureInfo)\n+            .setCause(canceledFailure)\n+            .setMessage(\"Activity canceled\")\n+            .build();\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyCompleted() {\n+    ActivityTaskCompletedEventAttributes completedAttr =\n+        currentEvent.getActivityTaskCompletedEventAttributes();\n+    Optional<Payloads> result =\n+        completedAttr.hasResult() ? Optional.of(completedAttr.getResult()) : Optional.empty();\n+    completionCallback.apply(result, null);\n+  }\n+\n+  private void notifyFailed() {\n+    ActivityTaskFailedEventAttributes failed = currentEvent.getActivityTaskFailedEventAttributes();\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+    ActivityFailureInfo failureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setIdentity(failed.getIdentity())\n+            .setRetryState(failed.getRetryState())\n+            .setScheduledEventId(failed.getScheduledEventId())\n+            .setStartedEventId(failed.getStartedEventId())\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(failureInfo)\n+            .setCause(failed.getFailure())\n+            .setMessage(\"Activity task failed\")\n+            .build();\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyTimedOut() {\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+\n+    ActivityTaskTimedOutEventAttributes timedOut =\n+        currentEvent.getActivityTaskTimedOutEventAttributes();\n+\n+    ActivityFailureInfo failureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setRetryState(timedOut.getRetryState())\n+            .setScheduledEventId(timedOut.getScheduledEventId())\n+            .setStartedEventId(timedOut.getStartedEventId())\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(failureInfo)\n+            .setCause(timedOut.getFailure())\n+            .setMessage(\"Activity task timedOut\")\n+            .build();\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyCancellationFromEvent() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.WAIT_CANCELLATION_COMPLETED) {\n+      ActivityTaskCanceledEventAttributes canceledAttr =\n+          currentEvent.getActivityTaskCanceledEventAttributes();\n+      Failure canceledFailure =\n+          Failure.newBuilder()\n+              .setSource(JAVA_SDK)\n+              .setCanceledFailureInfo(\n+                  CanceledFailureInfo.newBuilder().setDetails(canceledAttr.getDetails()))\n+              .build();\n+\n+      ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+      ActivityFailureInfo failureInfo =\n+          ActivityFailureInfo.newBuilder()\n+              .setActivityId(scheduleAttr.getActivityId())\n+              .setActivityType(scheduleAttr.getActivityType())\n+              .setScheduledEventId(canceledAttr.getScheduledEventId())\n+              .setStartedEventId(canceledAttr.getStartedEventId())\n+              .build();\n+      Failure failure =\n+          Failure.newBuilder()\n+              .setActivityFailureInfo(failureInfo)\n+              .setCause(canceledFailure)\n+              .setMessage(\"Activity task timedOut\")", "originalCommit": "e1e3fa6db2903db82312a1b256c2a8046f098737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NTA4MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468255081", "bodyText": "Fixed", "author": "mfateev", "createdAt": "2020-08-11T00:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODU0NA=="}], "type": "inlineReview"}, {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "url": "https://github.com/temporalio/sdk-java/commit/190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "message": "Added more activity state machine tests", "committedDate": "2020-08-09T23:11:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MDI5OQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467640299", "bodyText": "[Nit] this variable name (commands) seems off?", "author": "mastermanu", "createdAt": "2020-08-09T23:12:19Z", "path": "src/main/java/io/temporal/internal/statemachines/CancellableCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import java.util.Objects;\n+\n+class CancellableCommand {\n+\n+  private final Command command;\n+  private final EntityStateMachine commands;", "originalCommit": "e1e3fa6db2903db82312a1b256c2a8046f098737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2NDg1OA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468264858", "bodyText": "done", "author": "mfateev", "createdAt": "2020-08-11T00:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MDI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MDQzOA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467640438", "bodyText": "\"NewCommand\" --> \"CancellableCommand\"", "author": "mastermanu", "createdAt": "2020-08-09T23:13:46Z", "path": "src/main/java/io/temporal/internal/statemachines/CancellableCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import java.util.Objects;\n+\n+class CancellableCommand {\n+\n+  private final Command command;\n+  private final EntityStateMachine commands;\n+  private boolean canceled;\n+\n+  public CancellableCommand(Command command, EntityStateMachine commands) {\n+    this.command = Objects.requireNonNull(command);\n+    this.commands = Objects.requireNonNull(commands);\n+  }\n+\n+  public Command getCommand() {\n+    if (canceled) {\n+      throw new IllegalStateException(\"canceled\");\n+    }\n+    return command;\n+  }\n+\n+  public boolean isCanceled() {\n+    return canceled;\n+  }\n+\n+  public void cancel() {\n+    canceled = true;\n+  }\n+\n+  public EntityStateMachine getStateMachine() {\n+    return commands;\n+  }\n+\n+  public CommandType getCommandType() {\n+    return command.getCommandType();\n+  }\n+\n+  public void handleCommand(CommandType commandType) {\n+    if (!canceled) {\n+      commands.handleCommand(commandType);\n+    }\n+  }\n+\n+  public WorkflowStateMachines.HandleEventStatus handleEvent(\n+      HistoryEvent event, boolean hasNextEvent) {\n+    if (canceled) {\n+      return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+    }\n+    return commands.handleEvent(event, hasNextEvent);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"NewCommand{\" + \"command=\" + command + \", canceled=\" + canceled + '}';", "originalCommit": "e1e3fa6db2903db82312a1b256c2a8046f098737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2NDk2NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468264964", "bodyText": "done", "author": "mfateev", "createdAt": "2020-08-11T00:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MDQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MTIzNw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467641237", "bodyText": "why do we need to set the stack trace here, but not for terminated?", "author": "mastermanu", "createdAt": "2020-08-09T23:21:13Z", "path": "src/main/java/io/temporal/internal/statemachines/ChildWorkflowStateMachine.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes;\n+import io.temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.client.WorkflowExecutionAlreadyStarted;\n+import io.temporal.common.converter.EncodedValues;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.internal.replay.ChildWorkflowTaskFailedException;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ChildWorkflowStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ChildWorkflowStateMachine.State,\n+        ChildWorkflowStateMachine.ExplicitEvent,\n+        ChildWorkflowStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_EVENT_RECORDED,\n+    STARTED,\n+    START_FAILED,\n+    COMPLETED,\n+    FAILED,\n+    CANCELED,\n+    TIMED_OUT,\n+    TERMINATED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ChildWorkflowStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ChildWorkflowStateMachine>newInstance(\n+            \"ChildWorkflow\",\n+            State.CREATED,\n+            State.START_FAILED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.CANCELED,\n+            State.TIMED_OUT,\n+            State.TERMINATED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.START_COMMAND_CREATED,\n+            ChildWorkflowStateMachine::createStartChildCommand)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION,\n+            State.START_COMMAND_CREATED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED,\n+            State.START_EVENT_RECORDED,\n+            EntityStateMachineInitialCommand::setInitialCommandEventId)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::cancelStartChildCommand)\n+        .add(\n+            State.START_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED,\n+            State.STARTED,\n+            ChildWorkflowStateMachine::notifyStarted)\n+        .add(\n+            State.START_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED,\n+            State.START_FAILED,\n+            ChildWorkflowStateMachine::notifyStartFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED,\n+            State.COMPLETED,\n+            ChildWorkflowStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED,\n+            State.FAILED,\n+            ChildWorkflowStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ChildWorkflowStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::notifyCanceled)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED,\n+            State.TERMINATED,\n+            ChildWorkflowStateMachine::notifyTerminated);\n+  }\n+\n+  private final StartChildWorkflowExecutionCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<WorkflowExecution> startedCallback;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Exception> completionCallback;\n+\n+  /**\n+   * Creates a new child workflow state machine\n+   *\n+   * @param attributes child workflow start command attributes\n+   * @param startedCallback\n+   * @param completionCallback invoked when child reports completion or failure. The following types\n+   *     of events can be passed to the callback: StartChildWorkflowExecutionFailedEvent,\n+   *     ChildWorkflowExecutionCompletedEvent, ChildWorkflowExecutionFailedEvent,\n+   *     ChildWorkflowExecutionTimedOutEvent, ChildWorkflowExecutionCanceledEvent,\n+   *     ChildWorkflowExecutionTerminatedEvent.\n+   * @return cancellation callback that should be invoked to cancel the child\n+   */\n+  public static ChildWorkflowStateMachine newInstance(\n+      StartChildWorkflowExecutionCommandAttributes attributes,\n+      Functions.Proc1<WorkflowExecution> startedCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    return new ChildWorkflowStateMachine(\n+        attributes, startedCallback, completionCallback, commandSink);\n+  }\n+\n+  private ChildWorkflowStateMachine(\n+      StartChildWorkflowExecutionCommandAttributes startAttributes,\n+      Functions.Proc1<WorkflowExecution> startedCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.startAttributes = startAttributes;\n+    this.startedCallback = startedCallback;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  public void createStartChildCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION)\n+            .setStartChildWorkflowExecutionCommandAttributes(startAttributes)\n+            .build());\n+  }\n+\n+  public boolean isCancellable() {\n+    return State.START_COMMAND_CREATED == getState();\n+  }\n+\n+  /**\n+   * Cancellation through this class is valid only when start child workflow command is not sent\n+   * yet. Cancellation of an initiated child workflow is done through CancelExternalCommands. So all\n+   * of the types besides ABANDON are treated differently.\n+   */\n+  public void cancel() {\n+    if (!isFinalState()) {\n+      explicitEvent(ExplicitEvent.CANCEL);\n+    }\n+  }\n+\n+  private void cancelStartChildCommand() {\n+    cancelCommand();\n+    RuntimeException failure =\n+        new ChildWorkflowFailure(\n+            0,\n+            0,\n+            startAttributes.getWorkflowType().getName(),\n+            WorkflowExecution.newBuilder().setWorkflowId(startAttributes.getWorkflowId()).build(),\n+            startAttributes.getNamespace(),\n+            RetryState.RETRY_STATE_NON_RETRYABLE_FAILURE,\n+            new CanceledFailure(\"Child immediately canceled\", null, null));\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyCompleted() {\n+    ChildWorkflowExecutionCompletedEventAttributes attributes =\n+        currentEvent.getChildWorkflowExecutionCompletedEventAttributes();\n+    Optional<Payloads> result =\n+        attributes.hasResult() ? Optional.of(attributes.getResult()) : Optional.empty();\n+    completionCallback.apply(result, null);\n+  }\n+\n+  private void notifyStartFailed() {\n+    StartChildWorkflowExecutionFailedEventAttributes attributes =\n+        currentEvent.getStartChildWorkflowExecutionFailedEventAttributes();\n+    Exception failure =\n+        new ChildWorkflowTaskFailedException(\n+            currentEvent.getEventId(),\n+            WorkflowExecution.newBuilder().setWorkflowId(attributes.getWorkflowId()).build(),\n+            attributes.getWorkflowType(),\n+            RetryState.RETRY_STATE_NON_RETRYABLE_FAILURE,\n+            null);\n+    failure.initCause(\n+        new WorkflowExecutionAlreadyStarted(\n+            WorkflowExecution.newBuilder().setWorkflowId(attributes.getWorkflowId()).build(),\n+            attributes.getWorkflowType().getName(),\n+            null));\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyFailed() {\n+    ChildWorkflowExecutionFailedEventAttributes attributes =\n+        currentEvent.getChildWorkflowExecutionFailedEventAttributes();\n+    RuntimeException failure =\n+        new ChildWorkflowTaskFailedException(\n+            currentEvent.getEventId(),\n+            attributes.getWorkflowExecution(),\n+            attributes.getWorkflowType(),\n+            attributes.getRetryState(),\n+            attributes.getFailure());\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyTimedOut() {\n+    ChildWorkflowExecutionTimedOutEventAttributes attributes =\n+        currentEvent.getChildWorkflowExecutionTimedOutEventAttributes();\n+    TimeoutFailure timeoutFailure =\n+        new TimeoutFailure(null, null, TimeoutType.TIMEOUT_TYPE_START_TO_CLOSE);\n+    timeoutFailure.setStackTrace(new StackTraceElement[0]);", "originalCommit": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2NTI3NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468265274", "bodyText": "removed", "author": "mfateev", "createdAt": "2020-08-11T00:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MTIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0Mjg1Mg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467642852", "bodyText": "[Nit] toString value does not match class name", "author": "mastermanu", "createdAt": "2020-08-09T23:36:21Z", "path": "src/main/java/io/temporal/internal/statemachines/DynamicTransitionAction.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/** Action that can dynamically decide to which state to transition. */\n+class DynamicTransitionAction<State, Data> implements TransitionAction<State, Data> {\n+\n+  final DynamicCallback<State, Data> callback;\n+  State[] expectedStates;\n+  State state;\n+\n+  DynamicTransitionAction(State[] expectedStates, DynamicCallback<State, Data> callback) {\n+    this.expectedStates = expectedStates;\n+    this.callback = callback;\n+  }\n+\n+  @Override\n+  public String toString() {", "originalCommit": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0Mjk2MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467642961", "bodyText": "also might be worth printing out the expected states", "author": "mastermanu", "createdAt": "2020-08-09T23:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0Mjg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2NTU2NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468265564", "bodyText": "done", "author": "mfateev", "createdAt": "2020-08-11T00:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0Mjg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MzA2OA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467643068", "bodyText": "[Nit] typo in comment", "author": "mastermanu", "createdAt": "2020-08-09T23:38:32Z", "path": "src/main/java/io/temporal/internal/statemachines/EntityStateMachineBase.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.workflow.Functions;\n+\n+class EntityStateMachineBase<State, ExplicitEvent, Data> implements EntityStateMachine {\n+\n+  private final StateMachine<State, ExplicitEvent, Data> stateMachine;\n+\n+  protected final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  protected HistoryEvent currentEvent;\n+  protected boolean hasNextEvent;\n+\n+  public EntityStateMachineBase(\n+      StateMachine<State, ExplicitEvent, Data> stateMachine,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    this.stateMachine = stateMachine;\n+    this.commandSink = commandSink;\n+  }\n+\n+  /**\n+   * Notifies that command is included into zthe workflow task completion result.", "originalCommit": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MzQzMw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467643433", "bodyText": "worth printing out some of the other class members here?", "author": "mastermanu", "createdAt": "2020-08-09T23:41:51Z", "path": "src/main/java/io/temporal/internal/statemachines/EntityStateMachineBase.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.workflow.Functions;\n+\n+class EntityStateMachineBase<State, ExplicitEvent, Data> implements EntityStateMachine {\n+\n+  private final StateMachine<State, ExplicitEvent, Data> stateMachine;\n+\n+  protected final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  protected HistoryEvent currentEvent;\n+  protected boolean hasNextEvent;\n+\n+  public EntityStateMachineBase(\n+      StateMachine<State, ExplicitEvent, Data> stateMachine,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    this.stateMachine = stateMachine;\n+    this.commandSink = commandSink;\n+  }\n+\n+  /**\n+   * Notifies that command is included into zthe workflow task completion result.\n+   *\n+   * <p>Is not called for commands generated during replay.\n+   */\n+  @Override\n+  public void handleCommand(CommandType commandType) {\n+    stateMachine.handleCommand(commandType, (Data) this);\n+  }\n+\n+  @Override\n+  public WorkflowStateMachines.HandleEventStatus handleEvent(\n+      HistoryEvent event, boolean hasNextEvent) {\n+    if (!stateMachine.getValidEventTypes().contains(event.getEventType())) {\n+      return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+    }\n+    this.currentEvent = event;\n+    this.hasNextEvent = hasNextEvent;\n+    try {\n+      stateMachine.handleHistoryEvent(event.getEventType(), (Data) this);\n+    } finally {\n+      this.currentEvent = null;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public void handleWorkflowTaskStarted() {}\n+\n+  protected final void explicitEvent(ExplicitEvent explicitEvent) {\n+    stateMachine.handleExplicitEvent(explicitEvent, (Data) this);\n+  }\n+\n+  @Override\n+  public boolean isFinalState() {\n+    return stateMachine.isFinalState();\n+  }\n+\n+  protected State getState() {\n+    return stateMachine.getState();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return this.getClass().getSimpleName() + \"{\" + \"state=\" + stateMachine + '}';", "originalCommit": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2NTk3Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468265977", "bodyText": "done", "author": "mfateev", "createdAt": "2020-08-11T00:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MzQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MzU4Mw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467643583", "bodyText": "[Nit] class doesn't match string value here as well. Also action= vs callback=", "author": "mastermanu", "createdAt": "2020-08-09T23:43:33Z", "path": "src/main/java/io/temporal/internal/statemachines/FixedTransitionAction.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.workflow.Functions;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/** Action that can transition to exactly one state. */\n+class FixedTransitionAction<State, Data> implements TransitionAction<State, Data> {\n+\n+  final State state;\n+\n+  final Functions.Proc1<Data> action;\n+\n+  FixedTransitionAction(State state, Functions.Proc1<Data> action) {\n+    this.state = state;\n+    this.action = action;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"TransitionDestination{\" + \"state=\" + state + \", callback=\" + action + '}';", "originalCommit": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2NjIzMg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468266232", "bodyText": "I\"m keeping action. For me callback is more like reply thing. In this case it is actual action implementation.", "author": "mfateev", "createdAt": "2020-08-11T00:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NjExOA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467646118", "bodyText": "what is this timeout? is it in ms? should we have a constant/take a duration here?", "author": "mastermanu", "createdAt": "2020-08-10T00:07:26Z", "path": "src/main/java/io/temporal/internal/sync/TestActivityEnvironmentInternal.java", "diffHunk": "@@ -115,6 +114,7 @@ public TestActivityEnvironmentInternal(TestEnvironmentOptions options) {\n             WorkflowServiceStubsOptions.newBuilder()\n                 .setChannel(channel)\n                 .setMetricsScope(options.getMetricsScope())\n+                .setQueryRpcTimeout(600000)", "originalCommit": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2ODY4NQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468268685", "bodyText": "Done.", "author": "mfateev", "createdAt": "2020-08-11T01:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NjQ2NQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467646465", "bodyText": "[Nit] let's update the strings for these two variables as well", "author": "mastermanu", "createdAt": "2020-08-10T00:10:48Z", "path": "src/main/java/io/temporal/worker/WorkerOptions.java", "diffHunk": "@@ -301,15 +304,15 @@ public int hashCode() {\n   public String toString() {\n     return \"WorkerOptions{\"\n         + \"maxActivitiesPerSecond=\"", "originalCommit": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2ODk1Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468268957", "bodyText": "done", "author": "mfateev", "createdAt": "2020-08-11T01:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NjQ2NQ=="}], "type": "inlineReview"}, {"oid": "f6ed96a2af365097f5a72b39719e9171a58c5982", "url": "https://github.com/temporalio/sdk-java/commit/f6ed96a2af365097f5a72b39719e9171a58c5982", "message": "Created StateMachineDefinition", "committedDate": "2020-08-10T00:32:05Z", "type": "commit"}, {"oid": "f94e9ec0929fe844dbfc56cde820525b51af751e", "url": "https://github.com/temporalio/sdk-java/commit/f94e9ec0929fe844dbfc56cde820525b51af751e", "message": "missing final", "committedDate": "2020-08-10T00:33:06Z", "type": "commit"}, {"oid": "ef3e87049571406b9fd67df2de6bb434c57ebf69", "url": "https://github.com/temporalio/sdk-java/commit/ef3e87049571406b9fd67df2de6bb434c57ebf69", "message": "Added state diagram coverage diagram", "committedDate": "2020-08-10T01:34:19Z", "type": "commit"}, {"oid": "eb1dfd93f2ed4ca0a9ee1e85786af0d623a5ddc3", "url": "https://github.com/temporalio/sdk-java/commit/eb1dfd93f2ed4ca0a9ee1e85786af0d623a5ddc3", "message": "100% coverage of ActivityStateMachine", "committedDate": "2020-08-10T18:00:19Z", "type": "commit"}, {"oid": "24e6d7fcc92f27792e3ce5cf686354d1e4331dbc", "url": "https://github.com/temporalio/sdk-java/commit/24e6d7fcc92f27792e3ce5cf686354d1e4331dbc", "message": "PR comments", "committedDate": "2020-08-10T19:16:29Z", "type": "commit"}, {"oid": "49713bd7f6295302a4de1f6464a27f527c9d4c0e", "url": "https://github.com/temporalio/sdk-java/commit/49713bd7f6295302a4de1f6464a27f527c9d4c0e", "message": "UnsupportedVersion exception. Cleanup", "committedDate": "2020-08-10T23:57:03Z", "type": "commit"}, {"oid": "8a22826a95e370fd13a7411aa5aa79a7644155f8", "url": "https://github.com/temporalio/sdk-java/commit/8a22826a95e370fd13a7411aa5aa79a7644155f8", "message": "Updated order of state transition in activity state machine", "committedDate": "2020-08-11T00:07:11Z", "type": "commit"}, {"oid": "a8ba786486a338f55a38b0c08f419610105ca5c3", "url": "https://github.com/temporalio/sdk-java/commit/a8ba786486a338f55a38b0c08f419610105ca5c3", "message": "Sort of the PlantUML diagrams", "committedDate": "2020-08-11T00:51:40Z", "type": "commit"}, {"oid": "5397c1734caed50fea7a179c362243eda2db0e74", "url": "https://github.com/temporalio/sdk-java/commit/5397c1734caed50fea7a179c362243eda2db0e74", "message": "PR feedback", "committedDate": "2020-08-11T01:13:46Z", "type": "commit"}, {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "url": "https://github.com/temporalio/sdk-java/commit/731f9022dc2ad7f599084a66bdeb82658cb1456a", "message": "Added coverage to LocalActivityStateMachineTest", "committedDate": "2020-08-11T03:35:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzA0MA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468307040", "bodyText": "Interesting that signalExternalWorkflowExecution is cancelable. What is the scenario for that?", "author": "mastermanu", "createdAt": "2020-08-11T03:36:10Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowContextImpl.java", "diffHunk": "@@ -214,183 +207,127 @@ public SearchAttributes getSearchAttributes() {\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleActivityTask(\n-      ExecuteActivityParameters parameters, BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return activityClient.scheduleActivityTask(parameters, callback);\n+  public Functions.Proc1<Exception> scheduleActivityTask(\n+      ExecuteActivityParameters parameters, Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    ScheduleActivityTaskCommandAttributes.Builder attributes = parameters.getAttributes();\n+    if (attributes.getActivityId().isEmpty()) {\n+      attributes.setActivityId(workflowStateMachines.randomUUID().toString());\n+    }\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.scheduleActivityTask(parameters, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleLocalActivityTask(\n+  public Functions.Proc scheduleLocalActivityTask(\n       ExecuteLocalActivityParameters parameters,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClock.scheduleLocalActivityTask(parameters, callback);\n+      Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    return workflowStateMachines.scheduleLocalActivityTask(parameters, callback);\n   }\n \n   @Override\n-  public Consumer<Exception> startChildWorkflow(\n+  public Functions.Proc1<Exception> startChildWorkflow(\n       StartChildWorkflowExecutionParameters parameters,\n-      Consumer<WorkflowExecution> executionCallback,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClient.startChildWorkflow(parameters, executionCallback, callback);\n+      Functions.Proc1<WorkflowExecution> executionCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.startChildWorkflow(parameters, executionCallback, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> signalWorkflowExecution(\n+  public Functions.Proc1<Exception> signalExternalWorkflowExecution(", "originalCommit": "5397c1734caed50fea7a179c362243eda2db0e74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MDI3Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468680277", "bodyText": "When workflow (or any part of its code) is canceled we automatically cancel all outstanding requests including signalExternalWorkflowExecution. Note that it is cancellable only until the command was sent out to the service.", "author": "mfateev", "createdAt": "2020-08-11T15:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczMTgzMg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468731832", "bodyText": "yeah, that cancellation window seems very, very tiny tbh.", "author": "mastermanu", "createdAt": "2020-08-11T17:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzMzMg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468307332", "bodyText": "Can we do <= here?", "author": "mastermanu", "createdAt": "2020-08-11T03:37:28Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowContextImpl.java", "diffHunk": "@@ -214,183 +207,127 @@ public SearchAttributes getSearchAttributes() {\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleActivityTask(\n-      ExecuteActivityParameters parameters, BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return activityClient.scheduleActivityTask(parameters, callback);\n+  public Functions.Proc1<Exception> scheduleActivityTask(\n+      ExecuteActivityParameters parameters, Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    ScheduleActivityTaskCommandAttributes.Builder attributes = parameters.getAttributes();\n+    if (attributes.getActivityId().isEmpty()) {\n+      attributes.setActivityId(workflowStateMachines.randomUUID().toString());\n+    }\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.scheduleActivityTask(parameters, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleLocalActivityTask(\n+  public Functions.Proc scheduleLocalActivityTask(\n       ExecuteLocalActivityParameters parameters,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClock.scheduleLocalActivityTask(parameters, callback);\n+      Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    return workflowStateMachines.scheduleLocalActivityTask(parameters, callback);\n   }\n \n   @Override\n-  public Consumer<Exception> startChildWorkflow(\n+  public Functions.Proc1<Exception> startChildWorkflow(\n       StartChildWorkflowExecutionParameters parameters,\n-      Consumer<WorkflowExecution> executionCallback,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClient.startChildWorkflow(parameters, executionCallback, callback);\n+      Functions.Proc1<WorkflowExecution> executionCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.startChildWorkflow(parameters, executionCallback, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> signalWorkflowExecution(\n+  public Functions.Proc1<Exception> signalExternalWorkflowExecution(\n       SignalExternalWorkflowExecutionCommandAttributes.Builder attributes,\n-      BiConsumer<Void, Exception> callback) {\n-    return workflowClient.signalWorkflowExecution(attributes, callback);\n+      Functions.Proc2<Void, Failure> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.signalExternalWorkflowExecution(attributes.build(), callback);\n+    return (e) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Promise<Void> requestCancelWorkflowExecution(WorkflowExecution execution) {\n-    workflowClient.requestCancelWorkflowExecution(execution);\n-    // TODO: Make promise return success or failure of the cancellation request.\n-    return Workflow.newPromise(null);\n+  public void requestCancelExternalWorkflowExecution(\n+      WorkflowExecution execution, Functions.Proc2<Void, RuntimeException> callback) {\n+    RequestCancelExternalWorkflowExecutionCommandAttributes attributes =\n+        RequestCancelExternalWorkflowExecutionCommandAttributes.newBuilder()\n+            .setWorkflowId(execution.getWorkflowId())\n+            .setRunId(execution.getRunId())\n+            .build();\n+    workflowStateMachines.requestCancelExternalWorkflowExecution(attributes, callback);\n   }\n \n   @Override\n   public void continueAsNewOnCompletion(\n       ContinueAsNewWorkflowExecutionCommandAttributes attributes) {\n-    workflowClient.continueAsNewOnCompletion(attributes);\n-  }\n-\n-  void setReplayCurrentTimeMilliseconds(long replayCurrentTimeMilliseconds) {\n-    if (replayCurrentTimeMilliseconds < workflowClock.currentTimeMillis()) {\n-      if (log.isWarnEnabled()) {\n-        log.warn(\n-            \"Trying to set workflow clock back from \"\n-                + workflowClock.currentTimeMillis()\n-                + \" to \"\n-                + replayCurrentTimeMilliseconds\n-                + \". This will be a no-op.\");\n-      }\n-      return;\n-    }\n-    workflowClock.setReplayCurrentTimeMilliseconds(replayCurrentTimeMilliseconds);\n+    workflowContext.setContinueAsNewOnCompletion(attributes);\n   }\n \n   long getReplayCurrentTimeMilliseconds() {\n-    return workflowClock.currentTimeMillis();\n+    return workflowStateMachines.currentTimeMillis();\n   }\n \n   @Override\n   public boolean isReplaying() {\n-    return workflowClock.isReplaying();\n+    return workflowStateMachines.isReplaying();\n   }\n \n   @Override\n-  public Consumer<Exception> createTimer(Duration delay, Consumer<Exception> callback) {\n-    return workflowClock.createTimer(delay, callback);\n+  public Functions.Proc1<RuntimeException> newTimer(\n+      Duration delay, Functions.Proc1<RuntimeException> callback) {\n+    if (delay == Duration.ZERO) {", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxNzQ4Mw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468717483", "bodyText": "done", "author": "mfateev", "createdAt": "2020-08-11T16:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzcxOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468307719", "bodyText": "[Super-Nit] Canceled vs Cancelled", "author": "mastermanu", "createdAt": "2020-08-11T03:39:12Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowContextImpl.java", "diffHunk": "@@ -214,183 +207,127 @@ public SearchAttributes getSearchAttributes() {\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleActivityTask(\n-      ExecuteActivityParameters parameters, BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return activityClient.scheduleActivityTask(parameters, callback);\n+  public Functions.Proc1<Exception> scheduleActivityTask(\n+      ExecuteActivityParameters parameters, Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    ScheduleActivityTaskCommandAttributes.Builder attributes = parameters.getAttributes();\n+    if (attributes.getActivityId().isEmpty()) {\n+      attributes.setActivityId(workflowStateMachines.randomUUID().toString());\n+    }\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.scheduleActivityTask(parameters, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleLocalActivityTask(\n+  public Functions.Proc scheduleLocalActivityTask(\n       ExecuteLocalActivityParameters parameters,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClock.scheduleLocalActivityTask(parameters, callback);\n+      Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    return workflowStateMachines.scheduleLocalActivityTask(parameters, callback);\n   }\n \n   @Override\n-  public Consumer<Exception> startChildWorkflow(\n+  public Functions.Proc1<Exception> startChildWorkflow(\n       StartChildWorkflowExecutionParameters parameters,\n-      Consumer<WorkflowExecution> executionCallback,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClient.startChildWorkflow(parameters, executionCallback, callback);\n+      Functions.Proc1<WorkflowExecution> executionCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.startChildWorkflow(parameters, executionCallback, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> signalWorkflowExecution(\n+  public Functions.Proc1<Exception> signalExternalWorkflowExecution(\n       SignalExternalWorkflowExecutionCommandAttributes.Builder attributes,\n-      BiConsumer<Void, Exception> callback) {\n-    return workflowClient.signalWorkflowExecution(attributes, callback);\n+      Functions.Proc2<Void, Failure> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.signalExternalWorkflowExecution(attributes.build(), callback);\n+    return (e) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Promise<Void> requestCancelWorkflowExecution(WorkflowExecution execution) {\n-    workflowClient.requestCancelWorkflowExecution(execution);\n-    // TODO: Make promise return success or failure of the cancellation request.\n-    return Workflow.newPromise(null);\n+  public void requestCancelExternalWorkflowExecution(\n+      WorkflowExecution execution, Functions.Proc2<Void, RuntimeException> callback) {\n+    RequestCancelExternalWorkflowExecutionCommandAttributes attributes =\n+        RequestCancelExternalWorkflowExecutionCommandAttributes.newBuilder()\n+            .setWorkflowId(execution.getWorkflowId())\n+            .setRunId(execution.getRunId())\n+            .build();\n+    workflowStateMachines.requestCancelExternalWorkflowExecution(attributes, callback);\n   }\n \n   @Override\n   public void continueAsNewOnCompletion(\n       ContinueAsNewWorkflowExecutionCommandAttributes attributes) {\n-    workflowClient.continueAsNewOnCompletion(attributes);\n-  }\n-\n-  void setReplayCurrentTimeMilliseconds(long replayCurrentTimeMilliseconds) {\n-    if (replayCurrentTimeMilliseconds < workflowClock.currentTimeMillis()) {\n-      if (log.isWarnEnabled()) {\n-        log.warn(\n-            \"Trying to set workflow clock back from \"\n-                + workflowClock.currentTimeMillis()\n-                + \" to \"\n-                + replayCurrentTimeMilliseconds\n-                + \". This will be a no-op.\");\n-      }\n-      return;\n-    }\n-    workflowClock.setReplayCurrentTimeMilliseconds(replayCurrentTimeMilliseconds);\n+    workflowContext.setContinueAsNewOnCompletion(attributes);\n   }\n \n   long getReplayCurrentTimeMilliseconds() {\n-    return workflowClock.currentTimeMillis();\n+    return workflowStateMachines.currentTimeMillis();\n   }\n \n   @Override\n   public boolean isReplaying() {\n-    return workflowClock.isReplaying();\n+    return workflowStateMachines.isReplaying();\n   }\n \n   @Override\n-  public Consumer<Exception> createTimer(Duration delay, Consumer<Exception> callback) {\n-    return workflowClock.createTimer(delay, callback);\n+  public Functions.Proc1<RuntimeException> newTimer(\n+      Duration delay, Functions.Proc1<RuntimeException> callback) {\n+    if (delay == Duration.ZERO) {\n+      callback.apply(null);\n+      return (e) -> {};\n+    }\n+    StartTimerCommandAttributes attributes =\n+        StartTimerCommandAttributes.newBuilder()\n+            .setStartToFireTimeout(ProtobufTimeUtils.ToProtoDuration(delay))\n+            .setTimerId(workflowStateMachines.randomUUID().toString())\n+            .build();\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.newTimer(attributes, (event) -> handleTimerCallback(callback, event));\n+    return (e) -> cancellationHandler.apply();\n+  }\n+\n+  private void handleTimerCallback(Functions.Proc1<RuntimeException> callback, HistoryEvent event) {\n+    switch (event.getEventType()) {\n+      case EVENT_TYPE_TIMER_FIRED:\n+        {\n+          callback.apply(null);\n+          return;\n+        }\n+      case EVENT_TYPE_TIMER_CANCELED:\n+        {\n+          CanceledFailure exception = new CanceledFailure(\"Cancelled by request\");", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwODI2NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468308264", "bodyText": "Canceled vs Cancelled", "author": "mastermanu", "createdAt": "2020-08-11T03:41:23Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -295,32 +190,27 @@ private void eventLoop() {\n       failure = workflow.mapUnexpectedException(e);\n       completed = true;\n     }\n-  }\n-\n-  private void mayBeCompleteWorkflow() {\n     if (completed) {\n       completeWorkflow();\n-    } else {\n-      updateTimers();\n     }\n   }\n \n   private void completeWorkflow() {\n     if (failure != null) {\n-      commandHelper.failWorkflowExecution(failure);\n+      workflowStateMachines.newFailWorkflow(failure.getFailure());\n       metricsScope.counter(MetricsType.WORKFLOW_FAILED_COUNTER).inc(1);\n     } else if (cancelRequested) {\n-      commandHelper.cancelWorkflowExecution();\n+      workflowStateMachines.newCancelWorkflow();\n       metricsScope.counter(MetricsType.WORKFLOW_CANCELLED_COUNTER).inc(1);", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxOTc5MA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468719790", "bodyText": "It looks like we are using Canceled in the API: https://github.com/temporalio/api/search?q=canceled&unscoped_q=canceled\nGoogle says  that Canceled is American and cancelled is British.", "author": "mfateev", "createdAt": "2020-08-11T16:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwODI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyMDUxOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468720519", "bodyText": "I'm going to rename cancelled to canceled everywhere.", "author": "mfateev", "createdAt": "2020-08-11T16:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwODI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwODcxMw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468308713", "bodyText": "[Nit] kinda strange that some of these methods communicate their results via return values while others communicate using instance members of the class.", "author": "mastermanu", "createdAt": "2020-08-11T03:43:18Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -395,96 +242,48 @@ private void handleWorkflowExecutionSignaled(HistoryEvent event) {\n   }\n \n   @Override\n-  public WorkflowTaskResult handleWorkflowTask(PollWorkflowTaskQueueResponseOrBuilder workflowTask)\n-      throws Throwable {\n+  public WorkflowTaskResult handleWorkflowTask(\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask) {\n     lock.lock();\n     try {\n+      long startTime = System.currentTimeMillis();\n       queryResults.clear();\n-      boolean forceCreateNewWorkflowTask = handleWorkflowTaskImpl(workflowTask, null);\n-      return new WorkflowTaskResult(\n-          commandHelper.getCommands(), queryResults, forceCreateNewWorkflowTask, completed);\n+      handleWorkflowTaskImpl(workflowTask);", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyODMyNQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468728325", "bodyText": "It would be a pretty large change. So far public methods return values and private ones communicate through fields.", "author": "mfateev", "createdAt": "2020-08-11T16:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwODcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMDAzNA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468310034", "bodyText": "this is a strange name for a variable (timeoutInterval) especially as it just seems to represent the elapsed amount of time / 2? This interval will simply get bigger as the while loop continues to run right?", "author": "mastermanu", "createdAt": "2020-08-11T03:48:39Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -622,27 +341,76 @@ public void close() {\n \n   @Override\n   public Optional<Payloads> handleQueryWorkflowTask(\n-      PollWorkflowTaskQueueResponseOrBuilder response, WorkflowQuery query) throws Throwable {\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query) {\n     lock.lock();\n     try {\n       AtomicReference<Optional<Payloads>> result = new AtomicReference<>();\n-      handleWorkflowTaskImpl(response, () -> result.set(workflow.query(query)));\n+      handleWorkflowTaskImpl(workflowTask);\n+      result.set(workflow.query(query));\n       return result.get();\n     } finally {\n       lock.unlock();\n     }\n   }\n \n-  public Consumer<HistoryEvent> getLocalActivityCompletionSink() {\n-    return localActivityCompletionSink;\n+  private void processLocalActivityRequests(long startTime) {\n+    Duration maxProcessingTime = getWorkflowTaskTimeout().multipliedBy(4).dividedBy(5);\n+    while (true) {\n+      List<ExecuteLocalActivityParameters> laRequests =\n+          workflowStateMachines.takeLocalActivityRequests();\n+      long timeoutInterval = (long) ((System.currentTimeMillis() - startTime) * 0.5);", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY3MzA0Mg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469673042", "bodyText": "Refactored this part of the code.", "author": "mfateev", "createdAt": "2020-08-13T03:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMDAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMTAyOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468311029", "bodyText": "this represents the amount of time the local activity has to execute?", "author": "mastermanu", "createdAt": "2020-08-11T03:52:51Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -622,27 +341,76 @@ public void close() {\n \n   @Override\n   public Optional<Payloads> handleQueryWorkflowTask(\n-      PollWorkflowTaskQueueResponseOrBuilder response, WorkflowQuery query) throws Throwable {\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query) {\n     lock.lock();\n     try {\n       AtomicReference<Optional<Payloads>> result = new AtomicReference<>();\n-      handleWorkflowTaskImpl(response, () -> result.set(workflow.query(query)));\n+      handleWorkflowTaskImpl(workflowTask);\n+      result.set(workflow.query(query));\n       return result.get();\n     } finally {\n       lock.unlock();\n     }\n   }\n \n-  public Consumer<HistoryEvent> getLocalActivityCompletionSink() {\n-    return localActivityCompletionSink;\n+  private void processLocalActivityRequests(long startTime) {\n+    Duration maxProcessingTime = getWorkflowTaskTimeout().multipliedBy(4).dividedBy(5);\n+    while (true) {\n+      List<ExecuteLocalActivityParameters> laRequests =\n+          workflowStateMachines.takeLocalActivityRequests();\n+      long timeoutInterval = (long) ((System.currentTimeMillis() - startTime) * 0.5);\n+      for (ExecuteLocalActivityParameters laRequest : laRequests) {\n+        // TODO(maxim): In the presence of workflow task heartbeat this timeout doesn't make\n+        // much sense. I believe we should add ScheduleToStart timeout for the local activities\n+        // as well.\n+        long processingTime = Math.min(System.currentTimeMillis() - startTime, timeoutInterval);\n+        boolean accepted =\n+            localActivityTaskPoller.apply(\n+                new LocalActivityWorker.Task(\n+                    laRequest, localActivityCompletionSink, 10000 /* TODO: Configurable */),\n+                Duration.ofMillis(processingTime));", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY4OTA2Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469689067", "bodyText": "This is the maximum time for local retries. I've made it configurable through LocalActivityOptions", "author": "mfateev", "createdAt": "2020-08-13T04:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMTU4Mg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468311582", "bodyText": "[Nit] double nested while(true) loops with breaks and returns might make this code hard to read", "author": "mastermanu", "createdAt": "2020-08-11T03:55:03Z", "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -622,27 +341,76 @@ public void close() {\n \n   @Override\n   public Optional<Payloads> handleQueryWorkflowTask(\n-      PollWorkflowTaskQueueResponseOrBuilder response, WorkflowQuery query) throws Throwable {\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query) {\n     lock.lock();\n     try {\n       AtomicReference<Optional<Payloads>> result = new AtomicReference<>();\n-      handleWorkflowTaskImpl(response, () -> result.set(workflow.query(query)));\n+      handleWorkflowTaskImpl(workflowTask);\n+      result.set(workflow.query(query));\n       return result.get();\n     } finally {\n       lock.unlock();\n     }\n   }\n \n-  public Consumer<HistoryEvent> getLocalActivityCompletionSink() {\n-    return localActivityCompletionSink;\n+  private void processLocalActivityRequests(long startTime) {\n+    Duration maxProcessingTime = getWorkflowTaskTimeout().multipliedBy(4).dividedBy(5);\n+    while (true) {\n+      List<ExecuteLocalActivityParameters> laRequests =\n+          workflowStateMachines.takeLocalActivityRequests();\n+      long timeoutInterval = (long) ((System.currentTimeMillis() - startTime) * 0.5);\n+      for (ExecuteLocalActivityParameters laRequest : laRequests) {\n+        // TODO(maxim): In the presence of workflow task heartbeat this timeout doesn't make\n+        // much sense. I believe we should add ScheduleToStart timeout for the local activities\n+        // as well.\n+        long processingTime = Math.min(System.currentTimeMillis() - startTime, timeoutInterval);\n+        boolean accepted =\n+            localActivityTaskPoller.apply(\n+                new LocalActivityWorker.Task(\n+                    laRequest, localActivityCompletionSink, 10000 /* TODO: Configurable */),\n+                Duration.ofMillis(processingTime));\n+        laTaskCount++;\n+        if (!accepted) {\n+          throw new Error(\"Unable to schedule local activity for execution\");\n+        }\n+      }\n+      if (laTaskCount == 0) {\n+        break;\n+      }\n+      while (true) {\n+        Duration processingTime = Duration.ofMillis(System.currentTimeMillis() - startTime);\n+        Duration maxWaitAllowed = maxProcessingTime.minus(processingTime);\n+        if (maxWaitAllowed.isZero() || maxWaitAllowed.isNegative()) {\n+          return;\n+        }\n+        ActivityTaskHandler.Result laCompletion;\n+        // Do not wait under lock.\n+        try {\n+          laCompletion =\n+              localActivityCompletionQueue.poll(maxWaitAllowed.toMillis(), TimeUnit.MILLISECONDS);\n+          if (laCompletion == null) {\n+            // Need to force a new task\n+            break;", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY4OTM5OQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469689399", "bodyText": "Fixed", "author": "mfateev", "createdAt": "2020-08-13T04:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMjI1OQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468312259", "bodyText": "typo in comment", "author": "mastermanu", "createdAt": "2020-08-11T03:58:01Z", "path": "src/main/java/io/temporal/internal/statemachines/EntityStateMachineInitialCommand.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.workflow.Functions;\n+\n+class EntityStateMachineInitialCommand<State, ExplicitEvent, Data>\n+    extends EntityStateMachineBase<State, ExplicitEvent, Data> {\n+\n+  private CancellableCommand command;\n+\n+  private long initialCommandEventId;\n+\n+  public EntityStateMachineInitialCommand(\n+      StateMachineDefinition<State, ExplicitEvent, Data> stateMachineDefinition,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(stateMachineDefinition, commandSink, stateMachineSink);\n+  }\n+\n+  protected final void addCommand(Command command) {\n+    if (command.getCommandType() == CommandType.COMMAND_TYPE_UNSPECIFIED) {\n+      throw new IllegalArgumentException(\"unspecified command type\");\n+    }\n+    this.command = new CancellableCommand(command, this);\n+    commandSink.apply(this.command);\n+  }\n+\n+  protected final void cancelCommand() {\n+    command.cancel();\n+  }\n+\n+  protected long getInitialCommandEventId() {\n+    return initialCommandEventId;\n+  }\n+\n+  /** Sets initialCommandEventId ot the currentEvent eventId. */", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMDIxNA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468320214", "bodyText": "so we have NOT_MATCHING_EVENT and NON_MATCHING_EVENT. Can we align these?", "author": "mastermanu", "createdAt": "2020-08-11T04:31:58Z", "path": "src/main/java/io/temporal/internal/statemachines/MutableSideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import com.google.common.base.Strings;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+final class MutableSideEffectStateMachine {\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String MARKER_SKIP_COUNT_KEY = \"skipCount\";\n+  static final String MARKER_ID_KEY = \"id\";\n+  static final String MUTABLE_SIDE_EFFECT_MARKER_NAME = \"MutableSideEffect\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+  private final String id;\n+  private final Functions.Func<Boolean> replaying;\n+  private final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  private Optional<Payloads> result = Optional.empty();\n+\n+  private int currentSkipCount;\n+\n+  private int skipCountFromMarker = Integer.MAX_VALUE;\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    NON_MATCHING_EVENT\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    MARKER_COMMAND_CREATED,\n+    SKIPPED,\n+    CACHED_RESULT_NOTIFIED,\n+    RESULT_NOTIFIED,\n+    SKIPPED_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, InvocationStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, InvocationStateMachine>newInstance(\n+                  \"MutableSideEffect\",\n+                  State.CREATED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  State.SKIPPED_NOTIFIED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  InvocationStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {State.MARKER_COMMAND_CREATED, State.SKIPPED},\n+                  InvocationStateMachine::createMarker)\n+              .add(\n+                  State.REPLAYING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  InvocationStateMachine::createFakeCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  InvocationStateMachine::notifyCachedResult)\n+              .add(\n+                  State.SKIPPED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  ExplicitEvent.NON_MATCHING_EVENT,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  new State[] {State.MARKER_COMMAND_RECORDED, State.SKIPPED_NOTIFIED},\n+                  InvocationStateMachine::notifyFromEvent);\n+\n+  /** Represents a single invocation of mutableSideEffect. */\n+  private class InvocationStateMachine\n+      extends EntityStateMachineInitialCommand<State, ExplicitEvent, InvocationStateMachine> {\n+\n+    private final Functions.Proc1<Optional<Payloads>> resultCallback;\n+    private final Functions.Func1<Optional<Payloads>, Optional<Payloads>> func;\n+\n+    InvocationStateMachine(\n+        Functions.Func1<Optional<Payloads>, Optional<Payloads>> func,\n+        Functions.Proc1<Optional<Payloads>> callback,\n+        Functions.Proc1<StateMachine> stateMachineSink) {\n+      super(\n+          STATE_MACHINE_DEFINITION,\n+          MutableSideEffectStateMachine.this.commandSink,\n+          stateMachineSink);\n+      this.func = Objects.requireNonNull(func);\n+      this.resultCallback = Objects.requireNonNull(callback);\n+    }\n+\n+    State getExecutionState() {\n+      return replaying.apply() ? State.REPLAYING : State.EXECUTING;\n+    }\n+\n+    @Override\n+    public WorkflowStateMachines.HandleEventStatus handleEvent(\n+        HistoryEvent event, boolean hasNextEvent) {\n+      if (event.getEventType() != EventType.EVENT_TYPE_MARKER_RECORDED\n+          || !event\n+              .getMarkerRecordedEventAttributes()\n+              .getMarkerName()\n+              .equals(MUTABLE_SIDE_EFFECT_MARKER_NAME)) {\n+        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);\n+        return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY4OTg3Ng==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469689876", "bodyText": "Fixed.", "author": "mfateev", "createdAt": "2020-08-13T04:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMDQ3Mw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468320473", "bodyText": "any reason this is commented out?", "author": "mastermanu", "createdAt": "2020-08-11T04:33:12Z", "path": "src/main/java/io/temporal/internal/statemachines/MutableSideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import com.google.common.base.Strings;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+final class MutableSideEffectStateMachine {\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String MARKER_SKIP_COUNT_KEY = \"skipCount\";\n+  static final String MARKER_ID_KEY = \"id\";\n+  static final String MUTABLE_SIDE_EFFECT_MARKER_NAME = \"MutableSideEffect\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+  private final String id;\n+  private final Functions.Func<Boolean> replaying;\n+  private final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  private Optional<Payloads> result = Optional.empty();\n+\n+  private int currentSkipCount;\n+\n+  private int skipCountFromMarker = Integer.MAX_VALUE;\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    NON_MATCHING_EVENT\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    MARKER_COMMAND_CREATED,\n+    SKIPPED,\n+    CACHED_RESULT_NOTIFIED,\n+    RESULT_NOTIFIED,\n+    SKIPPED_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, InvocationStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, InvocationStateMachine>newInstance(\n+                  \"MutableSideEffect\",\n+                  State.CREATED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  State.SKIPPED_NOTIFIED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  InvocationStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {State.MARKER_COMMAND_CREATED, State.SKIPPED},\n+                  InvocationStateMachine::createMarker)\n+              .add(\n+                  State.REPLAYING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  InvocationStateMachine::createFakeCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  InvocationStateMachine::notifyCachedResult)\n+              .add(\n+                  State.SKIPPED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  ExplicitEvent.NON_MATCHING_EVENT,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  new State[] {State.MARKER_COMMAND_RECORDED, State.SKIPPED_NOTIFIED},\n+                  InvocationStateMachine::notifyFromEvent);\n+\n+  /** Represents a single invocation of mutableSideEffect. */\n+  private class InvocationStateMachine\n+      extends EntityStateMachineInitialCommand<State, ExplicitEvent, InvocationStateMachine> {\n+\n+    private final Functions.Proc1<Optional<Payloads>> resultCallback;\n+    private final Functions.Func1<Optional<Payloads>, Optional<Payloads>> func;\n+\n+    InvocationStateMachine(\n+        Functions.Func1<Optional<Payloads>, Optional<Payloads>> func,\n+        Functions.Proc1<Optional<Payloads>> callback,\n+        Functions.Proc1<StateMachine> stateMachineSink) {\n+      super(\n+          STATE_MACHINE_DEFINITION,\n+          MutableSideEffectStateMachine.this.commandSink,\n+          stateMachineSink);\n+      this.func = Objects.requireNonNull(func);\n+      this.resultCallback = Objects.requireNonNull(callback);\n+    }\n+\n+    State getExecutionState() {\n+      return replaying.apply() ? State.REPLAYING : State.EXECUTING;\n+    }\n+\n+    @Override\n+    public WorkflowStateMachines.HandleEventStatus handleEvent(\n+        HistoryEvent event, boolean hasNextEvent) {\n+      if (event.getEventType() != EventType.EVENT_TYPE_MARKER_RECORDED\n+          || !event\n+              .getMarkerRecordedEventAttributes()\n+              .getMarkerName()\n+              .equals(MUTABLE_SIDE_EFFECT_MARKER_NAME)) {\n+        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);\n+        return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+      }\n+      Map<String, Payloads> detailsMap = event.getMarkerRecordedEventAttributes().getDetailsMap();\n+      Optional<Payloads> idPayloads = Optional.ofNullable(detailsMap.get(MARKER_ID_KEY));\n+      String expectedId = dataConverter.fromPayloads(0, idPayloads, String.class, String.class);\n+      if (Strings.isNullOrEmpty(expectedId)) {\n+        throw new IllegalStateException(\n+            \"Marker details map missing required key: \" + MARKER_ID_KEY);\n+      }\n+      if (!id.equals(expectedId)) {\n+        //        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMDU4Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468320587", "bodyText": "my own learning: i assume that isPresent returns false if the value is identical to the previously stored version, right?", "author": "mastermanu", "createdAt": "2020-08-11T04:33:41Z", "path": "src/main/java/io/temporal/internal/statemachines/MutableSideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import com.google.common.base.Strings;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+final class MutableSideEffectStateMachine {\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String MARKER_SKIP_COUNT_KEY = \"skipCount\";\n+  static final String MARKER_ID_KEY = \"id\";\n+  static final String MUTABLE_SIDE_EFFECT_MARKER_NAME = \"MutableSideEffect\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+  private final String id;\n+  private final Functions.Func<Boolean> replaying;\n+  private final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  private Optional<Payloads> result = Optional.empty();\n+\n+  private int currentSkipCount;\n+\n+  private int skipCountFromMarker = Integer.MAX_VALUE;\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    NON_MATCHING_EVENT\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    MARKER_COMMAND_CREATED,\n+    SKIPPED,\n+    CACHED_RESULT_NOTIFIED,\n+    RESULT_NOTIFIED,\n+    SKIPPED_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, InvocationStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, InvocationStateMachine>newInstance(\n+                  \"MutableSideEffect\",\n+                  State.CREATED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  State.SKIPPED_NOTIFIED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  InvocationStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {State.MARKER_COMMAND_CREATED, State.SKIPPED},\n+                  InvocationStateMachine::createMarker)\n+              .add(\n+                  State.REPLAYING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  InvocationStateMachine::createFakeCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  InvocationStateMachine::notifyCachedResult)\n+              .add(\n+                  State.SKIPPED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  ExplicitEvent.NON_MATCHING_EVENT,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  new State[] {State.MARKER_COMMAND_RECORDED, State.SKIPPED_NOTIFIED},\n+                  InvocationStateMachine::notifyFromEvent);\n+\n+  /** Represents a single invocation of mutableSideEffect. */\n+  private class InvocationStateMachine\n+      extends EntityStateMachineInitialCommand<State, ExplicitEvent, InvocationStateMachine> {\n+\n+    private final Functions.Proc1<Optional<Payloads>> resultCallback;\n+    private final Functions.Func1<Optional<Payloads>, Optional<Payloads>> func;\n+\n+    InvocationStateMachine(\n+        Functions.Func1<Optional<Payloads>, Optional<Payloads>> func,\n+        Functions.Proc1<Optional<Payloads>> callback,\n+        Functions.Proc1<StateMachine> stateMachineSink) {\n+      super(\n+          STATE_MACHINE_DEFINITION,\n+          MutableSideEffectStateMachine.this.commandSink,\n+          stateMachineSink);\n+      this.func = Objects.requireNonNull(func);\n+      this.resultCallback = Objects.requireNonNull(callback);\n+    }\n+\n+    State getExecutionState() {\n+      return replaying.apply() ? State.REPLAYING : State.EXECUTING;\n+    }\n+\n+    @Override\n+    public WorkflowStateMachines.HandleEventStatus handleEvent(\n+        HistoryEvent event, boolean hasNextEvent) {\n+      if (event.getEventType() != EventType.EVENT_TYPE_MARKER_RECORDED\n+          || !event\n+              .getMarkerRecordedEventAttributes()\n+              .getMarkerName()\n+              .equals(MUTABLE_SIDE_EFFECT_MARKER_NAME)) {\n+        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);\n+        return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+      }\n+      Map<String, Payloads> detailsMap = event.getMarkerRecordedEventAttributes().getDetailsMap();\n+      Optional<Payloads> idPayloads = Optional.ofNullable(detailsMap.get(MARKER_ID_KEY));\n+      String expectedId = dataConverter.fromPayloads(0, idPayloads, String.class, String.class);\n+      if (Strings.isNullOrEmpty(expectedId)) {\n+        throw new IllegalStateException(\n+            \"Marker details map missing required key: \" + MARKER_ID_KEY);\n+      }\n+      if (!id.equals(expectedId)) {\n+        //        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);\n+        return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+      }\n+      super.handleEvent(event, hasNextEvent);\n+      return WorkflowStateMachines.HandleEventStatus.OK;\n+    }\n+\n+    State createMarker() {\n+      State toState;\n+      RecordMarkerCommandAttributes markerAttributes;\n+      Optional<Payloads> updated;\n+      updated = func.apply(result);\n+      if (!updated.isPresent()) {", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5MDc3MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469690771", "bodyText": "right", "author": "mfateev", "createdAt": "2020-08-13T04:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMDU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMTU1Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468321557", "bodyText": "does this mean a side effect cannot return a null value?", "author": "mastermanu", "createdAt": "2020-08-11T04:37:44Z", "path": "src/main/java/io/temporal/internal/statemachines/SideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class SideEffectStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        SideEffectStateMachine.State,\n+        SideEffectStateMachine.ExplicitEvent,\n+        SideEffectStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE\n+  }\n+\n+  enum State {\n+    CREATED,\n+    MARKER_COMMAND_CREATED,\n+    RESULT_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String SIDE_EFFECT_MARKER_NAME = \"SideEffect\";\n+\n+  private final Functions.Proc1<Optional<Payloads>> callback;\n+  private final Functions.Func<Optional<Payloads>> func;\n+  private final Functions.Func<Boolean> replaying;\n+\n+  private Optional<Payloads> result;\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, SideEffectStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, SideEffectStateMachine>newInstance(\n+                  \"SideEffect\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {\n+                    State.MARKER_COMMAND_CREATED, State.MARKER_COMMAND_CREATED_REPLAYING\n+                  },\n+                  SideEffectStateMachine::createMarkerCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  SideEffectStateMachine::markerResultFromFunc)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  SideEffectStateMachine::markerResultFromEvent);\n+\n+  /**\n+   * Creates new SideEffect Marker\n+   *\n+   * @param func used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static void newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func<Optional<Payloads>> func,\n+      Functions.Proc1<Optional<Payloads>> callback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    new SideEffectStateMachine(replaying, func, callback, commandSink, stateMachineSink);\n+  }\n+\n+  private SideEffectStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func<Optional<Payloads>> func,\n+      Functions.Proc1<Optional<Payloads>> callback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.func = func;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  private State createMarkerCommand() {\n+    RecordMarkerCommandAttributes markerAttributes;\n+    if (replaying.apply()) {\n+      markerAttributes = RecordMarkerCommandAttributes.getDefaultInstance();\n+      return State.MARKER_COMMAND_CREATED_REPLAYING;\n+    } else {\n+      // executing first time\n+      result = func.apply();\n+      if (result == null) {", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5MDgzMQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469690831", "bodyText": "yes", "author": "mfateev", "createdAt": "2020-08-13T04:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMTY5MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468321691", "bodyText": "[Nit] fromMarker", "author": "mastermanu", "createdAt": "2020-08-11T04:38:19Z", "path": "src/main/java/io/temporal/internal/statemachines/SideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class SideEffectStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        SideEffectStateMachine.State,\n+        SideEffectStateMachine.ExplicitEvent,\n+        SideEffectStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE\n+  }\n+\n+  enum State {\n+    CREATED,\n+    MARKER_COMMAND_CREATED,\n+    RESULT_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String SIDE_EFFECT_MARKER_NAME = \"SideEffect\";\n+\n+  private final Functions.Proc1<Optional<Payloads>> callback;\n+  private final Functions.Func<Optional<Payloads>> func;\n+  private final Functions.Func<Boolean> replaying;\n+\n+  private Optional<Payloads> result;\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, SideEffectStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, SideEffectStateMachine>newInstance(\n+                  \"SideEffect\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {\n+                    State.MARKER_COMMAND_CREATED, State.MARKER_COMMAND_CREATED_REPLAYING\n+                  },\n+                  SideEffectStateMachine::createMarkerCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  SideEffectStateMachine::markerResultFromFunc)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  SideEffectStateMachine::markerResultFromEvent);\n+\n+  /**\n+   * Creates new SideEffect Marker\n+   *\n+   * @param func used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static void newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func<Optional<Payloads>> func,\n+      Functions.Proc1<Optional<Payloads>> callback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    new SideEffectStateMachine(replaying, func, callback, commandSink, stateMachineSink);\n+  }\n+\n+  private SideEffectStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func<Optional<Payloads>> func,\n+      Functions.Proc1<Optional<Payloads>> callback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.func = func;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  private State createMarkerCommand() {\n+    RecordMarkerCommandAttributes markerAttributes;\n+    if (replaying.apply()) {\n+      markerAttributes = RecordMarkerCommandAttributes.getDefaultInstance();\n+      return State.MARKER_COMMAND_CREATED_REPLAYING;\n+    } else {\n+      // executing first time\n+      result = func.apply();\n+      if (result == null) {\n+        throw new IllegalStateException(\"marker function returned null\");\n+      }\n+      Map<String, Payloads> details = new HashMap<>();\n+      if (result.isPresent()) {\n+        details.put(MARKER_DATA_KEY, result.get());\n+      }\n+      markerAttributes =\n+          RecordMarkerCommandAttributes.newBuilder()\n+              .setMarkerName(SIDE_EFFECT_MARKER_NAME)\n+              .putAllDetails(details)\n+              .build();\n+    }\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_RECORD_MARKER)\n+            .setRecordMarkerCommandAttributes(markerAttributes)\n+            .build());\n+    return State.MARKER_COMMAND_CREATED;\n+  }\n+\n+  private void markerResultFromEvent() {\n+    MarkerRecordedEventAttributes attributes = currentEvent.getMarkerRecordedEventAttributes();\n+    if (!attributes.getMarkerName().equals(SIDE_EFFECT_MARKER_NAME)) {\n+      throw new IllegalStateException(\n+          \"Expected \" + SIDE_EFFECT_MARKER_NAME + \", received: \" + attributes);\n+    }\n+    Map<String, Payloads> map = attributes.getDetailsMap();\n+    Optional<Payloads> fromMaker = Optional.ofNullable(map.get(MARKER_DATA_KEY));", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMjkwOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468322909", "bodyText": "basically, once we have a notification from the server that the external workflow was signaled, then a cancel is basically a no-op, hence this transition back to its own state?", "author": "mastermanu", "createdAt": "2020-08-11T04:43:19Z", "path": "src/main/java/io/temporal/internal/statemachines/SignalExternalStateMachine.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ApplicationFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.SignalExternalWorkflowExecutionFailedEventAttributes;\n+import io.temporal.workflow.Functions;\n+\n+final class SignalExternalStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        SignalExternalStateMachine.State,\n+        SignalExternalStateMachine.ExplicitEvent,\n+        SignalExternalStateMachine> {\n+\n+  private final SignalExternalWorkflowExecutionCommandAttributes signalAttributes;\n+\n+  private final Functions.Proc2<Void, Failure> completionCallback;\n+\n+  /**\n+   * Register new instance of the signal commands\n+   *\n+   * @param signalAttributes attributes used to signal an external workflow\n+   * @param completionCallback either SignalExternalWorkflowExecutionFailed,\n+   *     ExternalWorkflowExecutionSignaled or true value of the second parameter to indicate\n+   *     immediate cancellation.\n+   * @param commandSink sink to send commands\n+   * @return cancellation handler\n+   */\n+  public static Functions.Proc newInstance(\n+      SignalExternalWorkflowExecutionCommandAttributes signalAttributes,\n+      Functions.Proc2<Void, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    SignalExternalStateMachine commands =\n+        new SignalExternalStateMachine(\n+            signalAttributes, completionCallback, commandSink, stateMachineSink);\n+    return commands::cancel;\n+  }\n+\n+  private SignalExternalStateMachine(\n+      SignalExternalWorkflowExecutionCommandAttributes signalAttributes,\n+      Functions.Proc2<Void, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.signalAttributes = signalAttributes;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SIGNAL_EXTERNAL_COMMAND_CREATED,\n+    SIGNAL_EXTERNAL_COMMAND_RECORDED,\n+    SIGNALED,\n+    FAILED,\n+    CANCELED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, SignalExternalStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, SignalExternalStateMachine>newInstance(\n+                  \"SignalExternal\", State.CREATED, State.SIGNALED, State.FAILED, State.CANCELED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED,\n+                  SignalExternalStateMachine::createSignalExternalCommand)\n+              .add(\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION,\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED)\n+              .add(\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCELED,\n+                  SignalExternalStateMachine::cancelSignalExternalCommand)\n+              .add(\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED,\n+                  State.SIGNAL_EXTERNAL_COMMAND_RECORDED,\n+                  EntityStateMachineInitialCommand::setInitialCommandEventId)\n+              .add(", "originalCommit": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5MTA2NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469691064", "bodyText": "Yes, as there is no cancellation support by the service.", "author": "mfateev", "createdAt": "2020-08-13T04:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMjkwOQ=="}], "type": "inlineReview"}, {"oid": "088cbcfcdf31acfe7fcc37f60b4491b08324f04d", "url": "https://github.com/temporalio/sdk-java/commit/088cbcfcdf31acfe7fcc37f60b4491b08324f04d", "message": "Added coverage to versionStateMachineTest", "committedDate": "2020-08-11T16:42:07Z", "type": "commit"}, {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1", "url": "https://github.com/temporalio/sdk-java/commit/0b7bc472a702cfd414300d910dc9d26623233eb1", "message": "Cancelled->canceled", "committedDate": "2020-08-11T16:56:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MjEyNw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468742127", "bodyText": "there is zero chance we somehow get a timer fired event before the timer started event? This should be properly serialized on the server, right?", "author": "mastermanu", "createdAt": "2020-08-11T17:21:43Z", "path": "src/main/java/io/temporal/internal/statemachines/TimerStateMachine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.CancelTimerCommandAttributes;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartTimerCommandAttributes;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.TimerCanceledEventAttributes;\n+import io.temporal.workflow.Functions;\n+\n+final class TimerStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        TimerStateMachine.State, TimerStateMachine.ExplicitEvent, TimerStateMachine> {\n+\n+  private final StartTimerCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<HistoryEvent> completionCallback;\n+\n+  /**\n+   * Creates a new timer state machine\n+   *\n+   * @param attributes timer command attributes\n+   * @param completionCallback invoked when timer fires or reports cancellation. One of\n+   *     TimerFiredEvent, TimerCanceledEvent.\n+   * @return cancellation callback that should be invoked to initiate timer cancellation\n+   */\n+  public static TimerStateMachine newInstance(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new TimerStateMachine(attributes, completionCallback, commandSink, stateMachineSink);\n+  }\n+\n+  private TimerStateMachine(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.startAttributes = attributes;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_COMMAND_RECORDED,\n+    CANCEL_TIMER_COMMAND_CREATED,\n+    FIRED,\n+    CANCELED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, TimerStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, TimerStateMachine>newInstance(\n+                  \"Timer\", State.CREATED, State.FIRED, State.CANCELED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.START_COMMAND_CREATED,\n+                  TimerStateMachine::createStartTimerCommand)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_START_TIMER,\n+                  State.START_COMMAND_CREATED)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_STARTED,\n+                  State.START_COMMAND_RECORDED,\n+                  EntityStateMachineInitialCommand::setInitialCommandEventId)\n+              .add(", "originalCommit": "0b7bc472a702cfd414300d910dc9d26623233eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5MTQyMw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469691423", "bodyText": "No, as timerStarted is written transactionally with the task addition to the timer queue. And due to buffered events the guarantee is even stronger. Command events always follow WorkflowTaskCompleted event.", "author": "mfateev", "createdAt": "2020-08-13T04:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MjEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NjAyMQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468746021", "bodyText": "similarly, is there a chance the timer fired event arrives even after the explicit cancel, but before we get the event_type_timer started/fired events? In this case, we'd be in the Canceled state when we receive those events. I assume that is a no-op then?", "author": "mastermanu", "createdAt": "2020-08-11T17:28:27Z", "path": "src/main/java/io/temporal/internal/statemachines/TimerStateMachine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.CancelTimerCommandAttributes;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartTimerCommandAttributes;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.TimerCanceledEventAttributes;\n+import io.temporal.workflow.Functions;\n+\n+final class TimerStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        TimerStateMachine.State, TimerStateMachine.ExplicitEvent, TimerStateMachine> {\n+\n+  private final StartTimerCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<HistoryEvent> completionCallback;\n+\n+  /**\n+   * Creates a new timer state machine\n+   *\n+   * @param attributes timer command attributes\n+   * @param completionCallback invoked when timer fires or reports cancellation. One of\n+   *     TimerFiredEvent, TimerCanceledEvent.\n+   * @return cancellation callback that should be invoked to initiate timer cancellation\n+   */\n+  public static TimerStateMachine newInstance(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new TimerStateMachine(attributes, completionCallback, commandSink, stateMachineSink);\n+  }\n+\n+  private TimerStateMachine(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.startAttributes = attributes;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_COMMAND_RECORDED,\n+    CANCEL_TIMER_COMMAND_CREATED,\n+    FIRED,\n+    CANCELED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, TimerStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, TimerStateMachine>newInstance(\n+                  \"Timer\", State.CREATED, State.FIRED, State.CANCELED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.START_COMMAND_CREATED,\n+                  TimerStateMachine::createStartTimerCommand)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_START_TIMER,\n+                  State.START_COMMAND_CREATED)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_STARTED,\n+                  State.START_COMMAND_RECORDED,\n+                  EntityStateMachineInitialCommand::setInitialCommandEventId)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCELED,", "originalCommit": "0b7bc472a702cfd414300d910dc9d26623233eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5MTcxNw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469691717", "bodyText": "It is not possible as the code that calls cancel executes (due to event loop invocation) after fired event applied.", "author": "mfateev", "createdAt": "2020-08-13T04:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NjAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MjAzMA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468762030", "bodyText": "just curious: what would happen if we did not call cancelCommand() here? We would not filter it out when returning the commands, right?", "author": "mastermanu", "createdAt": "2020-08-11T17:55:54Z", "path": "src/main/java/io/temporal/internal/statemachines/TimerStateMachine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.CancelTimerCommandAttributes;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartTimerCommandAttributes;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.TimerCanceledEventAttributes;\n+import io.temporal.workflow.Functions;\n+\n+final class TimerStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        TimerStateMachine.State, TimerStateMachine.ExplicitEvent, TimerStateMachine> {\n+\n+  private final StartTimerCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<HistoryEvent> completionCallback;\n+\n+  /**\n+   * Creates a new timer state machine\n+   *\n+   * @param attributes timer command attributes\n+   * @param completionCallback invoked when timer fires or reports cancellation. One of\n+   *     TimerFiredEvent, TimerCanceledEvent.\n+   * @return cancellation callback that should be invoked to initiate timer cancellation\n+   */\n+  public static TimerStateMachine newInstance(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new TimerStateMachine(attributes, completionCallback, commandSink, stateMachineSink);\n+  }\n+\n+  private TimerStateMachine(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.startAttributes = attributes;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_COMMAND_RECORDED,\n+    CANCEL_TIMER_COMMAND_CREATED,\n+    FIRED,\n+    CANCELED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, TimerStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, TimerStateMachine>newInstance(\n+                  \"Timer\", State.CREATED, State.FIRED, State.CANCELED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.START_COMMAND_CREATED,\n+                  TimerStateMachine::createStartTimerCommand)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_START_TIMER,\n+                  State.START_COMMAND_CREATED)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_STARTED,\n+                  State.START_COMMAND_RECORDED,\n+                  EntityStateMachineInitialCommand::setInitialCommandEventId)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCELED,\n+                  TimerStateMachine::cancelStartTimerCommand)\n+              .add(\n+                  State.START_COMMAND_RECORDED,\n+                  EventType.EVENT_TYPE_TIMER_FIRED,\n+                  State.FIRED,\n+                  TimerStateMachine::notifyCompletion)\n+              .add(\n+                  State.START_COMMAND_RECORDED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  TimerStateMachine::createCancelTimerCommand)\n+              .add(\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCEL_TIMER_COMMAND_CREATED)\n+              .add(\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_CANCELED,\n+                  State.CANCELED)\n+              .add(\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_CANCEL_TIMER,\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  TimerStateMachine::notifyCancellation)\n+              .add(\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_FIRED,\n+                  State.FIRED,\n+                  TimerStateMachine::cancelTimerCommandFireTimer);\n+\n+  private void createStartTimerCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_START_TIMER)\n+            .setStartTimerCommandAttributes(startAttributes)\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (!isFinalState()) {\n+      explicitEvent(ExplicitEvent.CANCEL);\n+    }\n+  }\n+\n+  private void cancelStartTimerCommand() {\n+    cancelCommand();\n+    notifyCancellation();\n+  }\n+\n+  private void notifyCancellation() {\n+    completionCallback.apply(\n+        HistoryEvent.newBuilder()\n+            .setEventType(EventType.EVENT_TYPE_TIMER_CANCELED)\n+            .setTimerCanceledEventAttributes(\n+                TimerCanceledEventAttributes.newBuilder()\n+                    .setIdentity(\"workflow\")\n+                    .setTimerId(startAttributes.getTimerId()))\n+            .build());\n+  }\n+\n+  private void notifyCompletion() {\n+    completionCallback.apply(currentEvent);\n+  }\n+\n+  private void createCancelTimerCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_CANCEL_TIMER)\n+            .setCancelTimerCommandAttributes(\n+                CancelTimerCommandAttributes.newBuilder().setTimerId(startAttributes.getTimerId()))\n+            .build());\n+  }\n+\n+  private void cancelTimerCommandFireTimer() {\n+    cancelCommand();", "originalCommit": "0b7bc472a702cfd414300d910dc9d26623233eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5MTg3Nw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469691877", "bodyText": "Right, it will be sent to the service.", "author": "mfateev", "createdAt": "2020-08-13T04:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MjAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5Nzk0NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468897944", "bodyText": "We have the same mess on GoSDK and server side.", "author": "alexshtin", "createdAt": "2020-08-11T22:23:13Z", "path": "src/main/java/io/temporal/activity/ActivityCancellationType.java", "diffHunk": "@@ -24,7 +24,7 @@\n \n /**\n  * Defines behaviour of the parent workflow when {@link CancellationScope} that wraps child workflow\n- * execution request is cancelled. The result of the cancellation independently of the type is a\n+ * execution request is canceled. The result of the cancellation independently of the type is a", "originalCommit": "0b7bc472a702cfd414300d910dc9d26623233eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTg2OA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468901868", "bodyText": "temporalio/sdk-go#227", "author": "alexshtin", "createdAt": "2020-08-11T22:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5Nzk0NA=="}], "type": "inlineReview"}, {"oid": "dd642f04b93e7304b2fc768802317bfdd9ec3bc2", "url": "https://github.com/temporalio/sdk-java/commit/dd642f04b93e7304b2fc768802317bfdd9ec3bc2", "message": "Simplified local activity handling", "committedDate": "2020-08-12T00:47:37Z", "type": "commit"}, {"oid": "1cc7b0c1e729d543ca4eec4bc405d375c5f51533", "url": "https://github.com/temporalio/sdk-java/commit/1cc7b0c1e729d543ca4eec4bc405d375c5f51533", "message": "allOf, anyOf and iterator", "committedDate": "2020-08-12T03:00:51Z", "type": "commit"}, {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0", "url": "https://github.com/temporalio/sdk-java/commit/abf241cf397678698be6add3bcb457101f7b2cd0", "message": "event loop", "committedDate": "2020-08-12T03:06:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzNjkyNA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469536924", "bodyText": "is there a better name we can come up with than \"GET_REQUEST?\" maybe \"CREATE_REQUEST\" or CREATEORGET_REQUEST or something like that? And how do I interpret what REQUEST_SENT means? To me that sounds like something was sent to the server, but this is a local activity, so not sure if there is a more appropriate name", "author": "mastermanu", "createdAt": "2020-08-12T20:46:54Z", "path": "src/main/java/io/temporal/internal/statemachines/LocalActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.api.workflowservice.v1.PollActivityTaskQueueResponse;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.failure.FailureConverter;\n+import io.temporal.internal.replay.ExecuteLocalActivityParameters;\n+import io.temporal.internal.worker.ActivityTaskHandler;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class LocalActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        LocalActivityStateMachine.State,\n+        LocalActivityStateMachine.ExplicitEvent,\n+        LocalActivityStateMachine> {\n+\n+  static final String LOCAL_ACTIVITY_MARKER_NAME = \"LocalActivity\";\n+  static final String MARKER_ACTIVITY_ID_KEY = \"activityId\";\n+  static final String MARKER_TIME_KEY = \"time\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+\n+  private final Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink;\n+  private final Functions.Proc2<Optional<Payloads>, Failure> callback;\n+\n+  private final ExecuteLocalActivityParameters localActivityParameters;\n+  private final Functions.Func<Boolean> replaying;\n+  /** Accepts proposed current time. Returns accepted current time. */\n+  private final Functions.Func1<Long, Long> setCurrentTimeCallback;\n+\n+  private Failure failure;\n+  private ActivityTaskHandler.Result result;\n+  private Optional<Payloads> laResult;\n+\n+  /**\n+   * Creates new local activity marker\n+   *\n+   * @param localActivityParameters used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static LocalActivityStateMachine newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new LocalActivityStateMachine(\n+        replaying,\n+        setCurrentTimeCallback,\n+        localActivityParameters,\n+        callback,\n+        localActivityRequestSink,\n+        commandSink,\n+        stateMachineSink);\n+  }\n+\n+  private LocalActivityStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.setCurrentTimeCallback = setCurrentTimeCallback;\n+    this.localActivityParameters = localActivityParameters;\n+    this.localActivityRequestSink = localActivityRequestSink;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.CHECK_EXECUTION_STATE);\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    GET_REQUEST,\n+    HANDLE_RESPONSE,\n+    NON_REPLAY_WORKFLOW_TASK_STARTED\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    REQUEST_PREPARED,\n+    REQUEST_SENT,\n+    RESULT_NOTIFIED,\n+    MARKER_COMMAND_CREATED,\n+    MARKER_COMMAND_RECORDED,\n+    WAITING_MARKER_EVENT,\n+    RESULT_NOTIFIED_REPLAYING\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, LocalActivityStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, LocalActivityStateMachine>newInstance(\n+                  \"LocalActivity\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  LocalActivityStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.REQUEST_PREPARED,\n+                  LocalActivityStateMachine::sendRequest)\n+              .add(State.REQUEST_PREPARED, ExplicitEvent.GET_REQUEST, State.REQUEST_SENT)", "originalCommit": "abf241cf397678698be6add3bcb457101f7b2cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5MjUzNw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469692537", "bodyText": "Renamed to MARK_AS_SENT", "author": "mfateev", "createdAt": "2020-08-13T04:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzNjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTA2OA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469539068", "bodyText": "this basically means local activity execution started? or that we've started executing the workflow? is there a scenario where this same event gets invoked twice? can we come up with a more friendly name?", "author": "mastermanu", "createdAt": "2020-08-12T20:51:09Z", "path": "src/main/java/io/temporal/internal/statemachines/LocalActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.api.workflowservice.v1.PollActivityTaskQueueResponse;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.failure.FailureConverter;\n+import io.temporal.internal.replay.ExecuteLocalActivityParameters;\n+import io.temporal.internal.worker.ActivityTaskHandler;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class LocalActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        LocalActivityStateMachine.State,\n+        LocalActivityStateMachine.ExplicitEvent,\n+        LocalActivityStateMachine> {\n+\n+  static final String LOCAL_ACTIVITY_MARKER_NAME = \"LocalActivity\";\n+  static final String MARKER_ACTIVITY_ID_KEY = \"activityId\";\n+  static final String MARKER_TIME_KEY = \"time\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+\n+  private final Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink;\n+  private final Functions.Proc2<Optional<Payloads>, Failure> callback;\n+\n+  private final ExecuteLocalActivityParameters localActivityParameters;\n+  private final Functions.Func<Boolean> replaying;\n+  /** Accepts proposed current time. Returns accepted current time. */\n+  private final Functions.Func1<Long, Long> setCurrentTimeCallback;\n+\n+  private Failure failure;\n+  private ActivityTaskHandler.Result result;\n+  private Optional<Payloads> laResult;\n+\n+  /**\n+   * Creates new local activity marker\n+   *\n+   * @param localActivityParameters used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static LocalActivityStateMachine newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new LocalActivityStateMachine(\n+        replaying,\n+        setCurrentTimeCallback,\n+        localActivityParameters,\n+        callback,\n+        localActivityRequestSink,\n+        commandSink,\n+        stateMachineSink);\n+  }\n+\n+  private LocalActivityStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.setCurrentTimeCallback = setCurrentTimeCallback;\n+    this.localActivityParameters = localActivityParameters;\n+    this.localActivityRequestSink = localActivityRequestSink;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.CHECK_EXECUTION_STATE);\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    GET_REQUEST,\n+    HANDLE_RESPONSE,\n+    NON_REPLAY_WORKFLOW_TASK_STARTED\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    REQUEST_PREPARED,\n+    REQUEST_SENT,\n+    RESULT_NOTIFIED,\n+    MARKER_COMMAND_CREATED,\n+    MARKER_COMMAND_RECORDED,\n+    WAITING_MARKER_EVENT,\n+    RESULT_NOTIFIED_REPLAYING\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, LocalActivityStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, LocalActivityStateMachine>newInstance(\n+                  \"LocalActivity\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  LocalActivityStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.REQUEST_PREPARED,\n+                  LocalActivityStateMachine::sendRequest)\n+              .add(State.REQUEST_PREPARED, ExplicitEvent.GET_REQUEST, State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.NON_REPLAY_WORKFLOW_TASK_STARTED,", "originalCommit": "abf241cf397678698be6add3bcb457101f7b2cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5OTIxNg==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469699216", "bodyText": "This means that WORKFLOW_TASK_STARTED event for a non replay task has started. Not sure what would be the better name.", "author": "mfateev", "createdAt": "2020-08-13T05:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0MTIxMw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469541213", "bodyText": "and is this for explicitly reporting the local activity result? if so, can we have better naming for explicit event here?", "author": "mastermanu", "createdAt": "2020-08-12T20:55:17Z", "path": "src/main/java/io/temporal/internal/statemachines/LocalActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.api.workflowservice.v1.PollActivityTaskQueueResponse;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.failure.FailureConverter;\n+import io.temporal.internal.replay.ExecuteLocalActivityParameters;\n+import io.temporal.internal.worker.ActivityTaskHandler;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class LocalActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        LocalActivityStateMachine.State,\n+        LocalActivityStateMachine.ExplicitEvent,\n+        LocalActivityStateMachine> {\n+\n+  static final String LOCAL_ACTIVITY_MARKER_NAME = \"LocalActivity\";\n+  static final String MARKER_ACTIVITY_ID_KEY = \"activityId\";\n+  static final String MARKER_TIME_KEY = \"time\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+\n+  private final Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink;\n+  private final Functions.Proc2<Optional<Payloads>, Failure> callback;\n+\n+  private final ExecuteLocalActivityParameters localActivityParameters;\n+  private final Functions.Func<Boolean> replaying;\n+  /** Accepts proposed current time. Returns accepted current time. */\n+  private final Functions.Func1<Long, Long> setCurrentTimeCallback;\n+\n+  private Failure failure;\n+  private ActivityTaskHandler.Result result;\n+  private Optional<Payloads> laResult;\n+\n+  /**\n+   * Creates new local activity marker\n+   *\n+   * @param localActivityParameters used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static LocalActivityStateMachine newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new LocalActivityStateMachine(\n+        replaying,\n+        setCurrentTimeCallback,\n+        localActivityParameters,\n+        callback,\n+        localActivityRequestSink,\n+        commandSink,\n+        stateMachineSink);\n+  }\n+\n+  private LocalActivityStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.setCurrentTimeCallback = setCurrentTimeCallback;\n+    this.localActivityParameters = localActivityParameters;\n+    this.localActivityRequestSink = localActivityRequestSink;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.CHECK_EXECUTION_STATE);\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    GET_REQUEST,\n+    HANDLE_RESPONSE,\n+    NON_REPLAY_WORKFLOW_TASK_STARTED\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    REQUEST_PREPARED,\n+    REQUEST_SENT,\n+    RESULT_NOTIFIED,\n+    MARKER_COMMAND_CREATED,\n+    MARKER_COMMAND_RECORDED,\n+    WAITING_MARKER_EVENT,\n+    RESULT_NOTIFIED_REPLAYING\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, LocalActivityStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, LocalActivityStateMachine>newInstance(\n+                  \"LocalActivity\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  LocalActivityStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.REQUEST_PREPARED,\n+                  LocalActivityStateMachine::sendRequest)\n+              .add(State.REQUEST_PREPARED, ExplicitEvent.GET_REQUEST, State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.NON_REPLAY_WORKFLOW_TASK_STARTED,\n+                  State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.HANDLE_RESPONSE,", "originalCommit": "abf241cf397678698be6add3bcb457101f7b2cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5OTQyOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469699429", "bodyText": "renamed to HANDLE_RESULT", "author": "mfateev", "createdAt": "2020-08-13T05:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0MTIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0NDk5OA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469544998", "bodyText": "had a hard time following this. when calling getExecutionState wouldn't it still be as if the \"first time\" it ran? OR does the force workflowtask is started create a persistent checkpoint", "author": "mastermanu", "createdAt": "2020-08-12T21:02:30Z", "path": "src/main/java/io/temporal/internal/statemachines/LocalActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.api.workflowservice.v1.PollActivityTaskQueueResponse;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.failure.FailureConverter;\n+import io.temporal.internal.replay.ExecuteLocalActivityParameters;\n+import io.temporal.internal.worker.ActivityTaskHandler;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class LocalActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        LocalActivityStateMachine.State,\n+        LocalActivityStateMachine.ExplicitEvent,\n+        LocalActivityStateMachine> {\n+\n+  static final String LOCAL_ACTIVITY_MARKER_NAME = \"LocalActivity\";\n+  static final String MARKER_ACTIVITY_ID_KEY = \"activityId\";\n+  static final String MARKER_TIME_KEY = \"time\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+\n+  private final Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink;\n+  private final Functions.Proc2<Optional<Payloads>, Failure> callback;\n+\n+  private final ExecuteLocalActivityParameters localActivityParameters;\n+  private final Functions.Func<Boolean> replaying;\n+  /** Accepts proposed current time. Returns accepted current time. */\n+  private final Functions.Func1<Long, Long> setCurrentTimeCallback;\n+\n+  private Failure failure;\n+  private ActivityTaskHandler.Result result;\n+  private Optional<Payloads> laResult;\n+\n+  /**\n+   * Creates new local activity marker\n+   *\n+   * @param localActivityParameters used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static LocalActivityStateMachine newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new LocalActivityStateMachine(\n+        replaying,\n+        setCurrentTimeCallback,\n+        localActivityParameters,\n+        callback,\n+        localActivityRequestSink,\n+        commandSink,\n+        stateMachineSink);\n+  }\n+\n+  private LocalActivityStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.setCurrentTimeCallback = setCurrentTimeCallback;\n+    this.localActivityParameters = localActivityParameters;\n+    this.localActivityRequestSink = localActivityRequestSink;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.CHECK_EXECUTION_STATE);\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    GET_REQUEST,\n+    HANDLE_RESPONSE,\n+    NON_REPLAY_WORKFLOW_TASK_STARTED\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    REQUEST_PREPARED,\n+    REQUEST_SENT,\n+    RESULT_NOTIFIED,\n+    MARKER_COMMAND_CREATED,\n+    MARKER_COMMAND_RECORDED,\n+    WAITING_MARKER_EVENT,\n+    RESULT_NOTIFIED_REPLAYING\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, LocalActivityStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, LocalActivityStateMachine>newInstance(\n+                  \"LocalActivity\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  LocalActivityStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.REQUEST_PREPARED,\n+                  LocalActivityStateMachine::sendRequest)\n+              .add(State.REQUEST_PREPARED, ExplicitEvent.GET_REQUEST, State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.NON_REPLAY_WORKFLOW_TASK_STARTED,\n+                  State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.HANDLE_RESPONSE,\n+                  State.MARKER_COMMAND_CREATED,\n+                  LocalActivityStateMachine::createMarker)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  LocalActivityStateMachine::notifyResultFromResponse)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(State.REPLAYING, ExplicitEvent.SCHEDULE, State.WAITING_MARKER_EVENT)\n+              .add(\n+                  State.WAITING_MARKER_EVENT,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  LocalActivityStateMachine::notifyResultFromEvent)\n+              .add(\n+                  // This is to cover the following edge case:", "originalCommit": "abf241cf397678698be6add3bcb457101f7b2cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY5OTc3NA==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469699774", "bodyText": "Forced workflow task is a workflow task that is recorded in the history the same way as a normal workflow task.", "author": "mfateev", "createdAt": "2020-08-13T05:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0NDk5OA=="}], "type": "inlineReview"}, {"oid": "65ffd00a39575c4d3f242c398262b445c517ebb8", "url": "https://github.com/temporalio/sdk-java/commit/65ffd00a39575c4d3f242c398262b445c517ebb8", "message": "Refactored ReplayWorkflowExecutor", "committedDate": "2020-08-13T03:07:33Z", "type": "commit"}, {"oid": "919cad6eba2a314a9b8309fba84caa5d01cdfe1c", "url": "https://github.com/temporalio/sdk-java/commit/919cad6eba2a314a9b8309fba84caa5d01cdfe1c", "message": "Renamed StatefulTaskHandler to WorkflowRunTaskHandler", "committedDate": "2020-08-13T03:09:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY4MDE2Mw==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469680163", "bodyText": "why not have negative check here? Or do we treat that as 0? Interesting that we have different behavior than above (although I guess w/different defaults that makes sense)", "author": "mastermanu", "createdAt": "2020-08-13T03:50:15Z", "path": "src/main/java/io/temporal/worker/WorkerOptions.java", "diffHunk": "@@ -143,8 +144,8 @@ public Builder setMaxConcurrentLocalActivityExecutionSize(\n      * every 10 seconds. This can be used to protect down stream services from flooding. The zero\n      * value of this uses the default value. Default is unlimited.\n      */\n-    public Builder setTaskQueueActivitiesPerSecond(double taskQueueActivitiesPerSecond) {\n-      this.taskQueueActivitiesPerSecond = taskQueueActivitiesPerSecond;\n+    public Builder setMaxTaskQueueActivitiesPerSecond(double maxTaskQueueActivitiesPerSecond) {", "originalCommit": "919cad6eba2a314a9b8309fba84caa5d01cdfe1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTcwMDQ4MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469700481", "bodyText": "The above option is used only locally. So validation should be done by the SDK. The maxTaskQueueActivitiesPerSecond is an option sent to the service. We made a design decision to not validate on the client any server-side options.", "author": "mfateev", "createdAt": "2020-08-13T05:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY4MDE2Mw=="}], "type": "inlineReview"}, {"oid": "d6918a064fb75ac465cda8ab7078d7438e862c9a", "url": "https://github.com/temporalio/sdk-java/commit/d6918a064fb75ac465cda8ab7078d7438e862c9a", "message": "Fixed local activity retries", "committedDate": "2020-08-13T04:25:27Z", "type": "commit"}, {"oid": "92a3e36f6a15c46099d6fadd7a49074a64c6ec28", "url": "https://github.com/temporalio/sdk-java/commit/92a3e36f6a15c46099d6fadd7a49074a64c6ec28", "message": "PR comments", "committedDate": "2020-08-13T04:37:47Z", "type": "commit"}, {"oid": "0a4dc3876eea110fc74d03840ea3601db10a83af", "url": "https://github.com/temporalio/sdk-java/commit/0a4dc3876eea110fc74d03840ea3601db10a83af", "message": "PR feedback", "committedDate": "2020-08-13T05:39:19Z", "type": "commit"}, {"oid": "81a5fb3787d0549c786dbbe2c09f31daa96196f3", "url": "https://github.com/temporalio/sdk-java/commit/81a5fb3787d0549c786dbbe2c09f31daa96196f3", "message": "Fixed Saga defaults", "committedDate": "2020-08-13T21:11:16Z", "type": "commit"}, {"oid": "4ddab733749843b1db745cf45e3f8b1849be89f0", "url": "https://github.com/temporalio/sdk-java/commit/4ddab733749843b1db745cf45e3f8b1849be89f0", "message": "Fixed sticky task and cache invalidation", "committedDate": "2020-08-14T04:54:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1OTMyOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r470659329", "bodyText": "What are the side effects of not defining the no-op transitions that are command based?", "author": "shawnhathaway", "createdAt": "2020-08-14T14:30:45Z", "path": "src/main/java/io/temporal/internal/statemachines/ChildWorkflowStateMachine.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes;\n+import io.temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.client.WorkflowExecutionAlreadyStarted;\n+import io.temporal.common.converter.EncodedValues;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.internal.replay.ChildWorkflowTaskFailedException;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ChildWorkflowStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ChildWorkflowStateMachine.State,\n+        ChildWorkflowStateMachine.ExplicitEvent,\n+        ChildWorkflowStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_EVENT_RECORDED,\n+    STARTED,\n+    START_FAILED,\n+    COMPLETED,\n+    FAILED,\n+    CANCELED,\n+    TIMED_OUT,\n+    TERMINATED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, ChildWorkflowStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, ChildWorkflowStateMachine>newInstance(\n+                  \"ChildWorkflow\",\n+                  State.CREATED,\n+                  State.START_FAILED,\n+                  State.COMPLETED,\n+                  State.FAILED,\n+                  State.CANCELED,\n+                  State.TIMED_OUT,\n+                  State.TERMINATED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.START_COMMAND_CREATED,\n+                  ChildWorkflowStateMachine::createStartChildCommand)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION,", "originalCommit": "4ddab733749843b1db745cf45e3f8b1849be89f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc1Njc2NQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r470756765", "bodyText": "Only defined transitions are allowed. Workflow task fails if command or event is applied to the state that doesn't have a transition defined for it.", "author": "mfateev", "createdAt": "2020-08-14T17:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1OTMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MDIxOQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r470660219", "bodyText": "Why are events registered/validated, but commands are not?", "author": "shawnhathaway", "createdAt": "2020-08-14T14:32:21Z", "path": "src/main/java/io/temporal/internal/statemachines/EntityStateMachineBase.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.workflow.Functions;\n+\n+class EntityStateMachineBase<State, ExplicitEvent, Data> implements EntityStateMachine {\n+\n+  private final StateMachine<State, ExplicitEvent, Data> stateMachine;\n+\n+  protected final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  protected HistoryEvent currentEvent;\n+  protected boolean hasNextEvent;\n+\n+  public EntityStateMachineBase(\n+      StateMachineDefinition<State, ExplicitEvent, Data> stateMachineDefinition,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    this.stateMachine = StateMachine.newInstance(stateMachineDefinition);\n+    this.commandSink = commandSink;\n+    stateMachineSink.apply(this.stateMachine);\n+  }\n+\n+  /**\n+   * Notifies that command is included into the workflow task completion result.\n+   *\n+   * <p>Is not called for commands generated during replay.\n+   */\n+  @Override\n+  public void handleCommand(CommandType commandType) {\n+    stateMachine.handleCommand(commandType, (Data) this);", "originalCommit": "4ddab733749843b1db745cf45e3f8b1849be89f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc1ODI5MQ==", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r470758291", "bodyText": "It is pretty evolved. The short answer is that this validation is required to support mutable side effect and versions which can have events missing for the given state machine. So if event doesn't match then it still can be valid as it just doesn't apply to this specific state machine. The same doesn't apply to commands as they always have to match the state machine that created them.", "author": "mfateev", "createdAt": "2020-08-14T17:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MDIxOQ=="}], "type": "inlineReview"}]}