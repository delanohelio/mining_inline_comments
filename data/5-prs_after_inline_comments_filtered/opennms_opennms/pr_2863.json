{"pr_number": 2863, "pr_title": "NMS-12372: Add gRPC support for IPC RPC/Sink", "pr_createdAt": "2020-01-08T14:51:25Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/2863", "timeline": [{"oid": "f453ede6dffe134fbb5a51579679b865a0227cf8", "url": "https://github.com/OpenNMS/opennms/commit/f453ede6dffe134fbb5a51579679b865a0227cf8", "message": "NMS-12372: Add gRPC server/client\n\nAdd delegate on default class loader that will load actual rpc/sink\nservices from the serice registry.", "committedDate": "2020-01-06T19:38:44Z", "type": "commit"}, {"oid": "f27d06b7f750da19629abe001e49a04afc355fe3", "url": "https://github.com/OpenNMS/opennms/commit/f27d06b7f750da19629abe001e49a04afc355fe3", "message": "NMS-12372: Add tls support", "committedDate": "2020-01-07T18:08:13Z", "type": "commit"}, {"oid": "aa5888eb4f214113425aa013a3c95d9788452ffa", "url": "https://github.com/OpenNMS/opennms/commit/aa5888eb4f214113425aa013a3c95d9788452ffa", "message": "NMS-12372: Add smoke test", "committedDate": "2020-01-08T17:33:36Z", "type": "commit"}, {"oid": "0821aed04cb9d488ace39e1d3f9d29ccbfc3162c", "url": "https://github.com/OpenNMS/opennms/commit/0821aed04cb9d488ace39e1d3f9d29ccbfc3162c", "message": "NMS-12372: Add integration tests\n\nTest grpc rpc/sink, setting max buffer size, mutual tls auth", "committedDate": "2020-01-08T19:50:56Z", "type": "commit"}, {"oid": "d841d3d4c5eb0ca6ac01a1e865b31ba16da8de0a", "url": "https://github.com/OpenNMS/opennms/commit/d841d3d4c5eb0ca6ac01a1e865b31ba16da8de0a", "message": "Merge branch 'develop' into jira/NMS-12372", "committedDate": "2020-01-08T21:16:51Z", "type": "commit"}, {"oid": "bdb32a4b46299604def759c6df9af8801ec55de9", "url": "https://github.com/OpenNMS/opennms/commit/bdb32a4b46299604def759c6df9af8801ec55de9", "message": "NMS-12372: More cleanup", "committedDate": "2020-01-09T15:15:34Z", "type": "commit"}, {"oid": "c3cb559dccbb8e58e2c5e63df4060ce68ed1f771", "url": "https://github.com/OpenNMS/opennms/commit/c3cb559dccbb8e58e2c5e63df4060ce68ed1f771", "message": "NMS-12372: More fixes\n\nensure that async sink messages are blocked till they succeeds in sending.\nAdd test case for sink async messages blocking\nAdd health check on minion\nAdd ipc.proto", "committedDate": "2020-01-09T21:45:30Z", "type": "commit"}, {"oid": "14162fc99ecce2efdb2aa94d2da36e1c2bcf7fa9", "url": "https://github.com/OpenNMS/opennms/commit/14162fc99ecce2efdb2aa94d2da36e1c2bcf7fa9", "message": "NMS-12372: Add metrics to GRPC", "committedDate": "2020-01-10T17:20:57Z", "type": "commit"}, {"oid": "8d3c5ef96ff35d426c7f904bf335db00ca7723ec", "url": "https://github.com/OpenNMS/opennms/commit/8d3c5ef96ff35d426c7f904bf335db00ca7723ec", "message": "NMS-12372: Add tracing for gRPC\n\nAlso add basic documentation.", "committedDate": "2020-01-13T22:33:36Z", "type": "forcePushed"}, {"oid": "3036bcee59d2bbfae4dda25589ce6393e967d38c", "url": "https://github.com/OpenNMS/opennms/commit/3036bcee59d2bbfae4dda25589ce6393e967d38c", "message": "NMS-12372: Add tracing for gRPC\n\nAlso add basic documentation.", "committedDate": "2020-01-14T20:59:21Z", "type": "commit"}, {"oid": "3034a5eb45eb6199729d91d81c496b299fc56ce4", "url": "https://github.com/OpenNMS/opennms/commit/3034a5eb45eb6199729d91d81c496b299fc56ce4", "message": "NMS-12372: Update ipc proto for RPC", "committedDate": "2020-01-14T22:39:14Z", "type": "commit"}, {"oid": "3034a5eb45eb6199729d91d81c496b299fc56ce4", "url": "https://github.com/OpenNMS/opennms/commit/3034a5eb45eb6199729d91d81c496b299fc56ce4", "message": "NMS-12372: Update ipc proto for RPC", "committedDate": "2020-01-14T22:39:14Z", "type": "forcePushed"}, {"oid": "0087519cd11ad0e1d0670271de7e0af68f038e37", "url": "https://github.com/OpenNMS/opennms/commit/0087519cd11ad0e1d0670271de7e0af68f038e37", "message": "Merge branch 'develop' into jira/NMS-12372", "committedDate": "2020-01-15T15:06:01Z", "type": "commit"}, {"oid": "b9fefc37d7d169a6d631106ee334296fe2779eb3", "url": "https://github.com/OpenNMS/opennms/commit/b9fefc37d7d169a6d631106ee334296fe2779eb3", "message": "NMS-12372: and some more..", "committedDate": "2020-01-15T16:09:13Z", "type": "commit"}, {"oid": "5970c0185b9b66cbfd73dd8be48a463de3f6c46a", "url": "https://github.com/OpenNMS/opennms/commit/5970c0185b9b66cbfd73dd8be48a463de3f6c46a", "message": "Merge branch 'develop' into jira/NMS-12372", "committedDate": "2020-01-21T13:00:24Z", "type": "commit"}, {"oid": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "url": "https://github.com/OpenNMS/opennms/commit/3a7342eef4f695a5f3e170913f918b26962fbfe7", "message": "NMS-12372: Add opennms-core-ipc-grpc-osgi feature to minion repository", "committedDate": "2020-01-22T21:22:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY4NTc4OQ==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374685789", "bodyText": "Unnecessary changes.", "author": "j-white", "createdAt": "2020-02-04T14:01:07Z", "path": "core/ipc/sink/aws-sqs/server/src/main/java/org/opennms/core/ipc/sink/aws/sqs/server/AmazonSQSMessageConsumerManager.java", "diffHunk": "@@ -28,18 +28,6 @@\n \n package org.opennms.core.ipc.sink.aws.sqs.server;\n \n-import com.amazonaws.services.sqs.AmazonSQS;", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTI4Nw==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374895287", "bodyText": "We should add documentation here that describes the basics of how the client works.", "author": "j-white", "createdAt": "2020-02-04T20:07:47Z", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTUxOA==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374895518", "bodyText": "Use ByteString.wrap instead - bytes wont change.", "author": "j-white", "createdAt": "2020-02-04T20:08:16Z", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNTk2Mw==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375915963", "bodyText": "Looks like  ByteString.wrap is not public.  There is no alternative way of other than copyFrom", "author": "cgorantla", "createdAt": "2020-02-06T15:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkyOTAwNQ==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375929005", "bodyText": "Ack. Missed that.", "author": "j-white", "createdAt": "2020-02-06T16:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTcyOA==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374895728", "bodyText": "If module doesn't have async policy, then block?", "author": "j-white", "createdAt": "2020-02-04T20:08:40Z", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNDY5NA==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375914694", "bodyText": "If module has async policy set then we should block here till we are able to send this message.\nIf module has no async policy set, we should attempt to send now and don't block dispatch.", "author": "cgorantla", "createdAt": "2020-02-06T15:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NTcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NjA2OQ==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374896069", "bodyText": "We should include the module and message id in the log.", "author": "j-white", "createdAt": "2020-02-04T20:09:23Z", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.\n+            if (module.getAsyncPolicy() != null) {\n+                sendBlockingSinkMessage(sinkMessageBuilder.build());\n+            } else {\n+                sendSinkMessage(sinkMessageBuilder.build());\n+            }\n+        }\n+    }\n+\n+    private void sendBlockingSinkMessage(SinkMessage sinkMessage) {\n+        boolean succeeded = sendSinkMessage(sinkMessage);\n+        if (succeeded) {\n+            return;\n+        }\n+        //Recursively try to send sink message until it succeeds.\n+        scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+    private boolean scheduleSinkMessageAfterDelay(SinkMessage sinkMessage) {\n+        ScheduledFuture<Boolean> future = blockingSinkMessageScheduler.schedule(\n+                () -> sendSinkMessage(sinkMessage), SINK_BLOCKING_TIMEOUT, TimeUnit.MILLISECONDS);\n+        try {\n+            boolean succeeded = future.get();\n+            if (succeeded) {\n+                return true;\n+            }\n+        } catch (InterruptedException | ExecutionException e) {\n+            LOG.error(\"Error while attempting to send sink message to gRPC IPC server\", e);", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NjUwNQ==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374896505", "bodyText": "I think we should add a trace or debug level message here.", "author": "j-white", "createdAt": "2020-02-04T20:10:20Z", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.\n+            if (module.getAsyncPolicy() != null) {\n+                sendBlockingSinkMessage(sinkMessageBuilder.build());\n+            } else {\n+                sendSinkMessage(sinkMessageBuilder.build());\n+            }\n+        }\n+    }\n+\n+    private void sendBlockingSinkMessage(SinkMessage sinkMessage) {\n+        boolean succeeded = sendSinkMessage(sinkMessage);\n+        if (succeeded) {\n+            return;\n+        }\n+        //Recursively try to send sink message until it succeeds.\n+        scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+    private boolean scheduleSinkMessageAfterDelay(SinkMessage sinkMessage) {\n+        ScheduledFuture<Boolean> future = blockingSinkMessageScheduler.schedule(\n+                () -> sendSinkMessage(sinkMessage), SINK_BLOCKING_TIMEOUT, TimeUnit.MILLISECONDS);\n+        try {\n+            boolean succeeded = future.get();\n+            if (succeeded) {\n+                return true;\n+            }\n+        } catch (InterruptedException | ExecutionException e) {\n+            LOG.error(\"Error while attempting to send sink message to gRPC IPC server\", e);\n+        }\n+        return scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+\n+    private synchronized boolean sendSinkMessage(SinkMessage sinkMessage) {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            if (sinkStream != null) {\n+                try {\n+                    sinkStream.onNext(sinkMessage);\n+                    return true;\n+                } catch (Throwable e) {\n+                    LOG.error(\"Exception while sending sinkMessage to gRPC IPC server\", e);\n+                }\n+            }\n+        } else {\n+            LOG.info(\"gRPC IPC server is not in ready state\");\n+        }\n+        return false;\n+    }\n+\n+\n+    private void sendMinionHeaders() {\n+        RpcResponseProto rpcHeader = RpcResponseProto.newBuilder()\n+                .setLocation(minionIdentity.getLocation())\n+                .setSystemId(minionIdentity.getId())\n+                .setModuleId(MINION_HEADERS_MODULE)\n+                .setRpcId(minionIdentity.getId())\n+                .build();\n+        sendRpcResponse(rpcHeader);\n+        LOG.info(\"Sending Minion Headers from SystemId {} to gRPC server\", minionIdentity.getId());\n+    }\n+\n+    private void processRpcRequest(RpcRequestProto requestProto) {\n+        long currentTime = requestProto.getExpirationTime();\n+        if (requestProto.getExpirationTime() < currentTime) {\n+            return;", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzAzMw==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374897033", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            minionSpan.setTag(TAG_RPC_FAILED, \"true\");\n          \n          \n            \n                            minionSpan.setTag(TAG_RPC_FAILED, Boolean.TRUE.toString());", "author": "j-white", "createdAt": "2020-02-04T20:11:30Z", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.\n+            if (module.getAsyncPolicy() != null) {\n+                sendBlockingSinkMessage(sinkMessageBuilder.build());\n+            } else {\n+                sendSinkMessage(sinkMessageBuilder.build());\n+            }\n+        }\n+    }\n+\n+    private void sendBlockingSinkMessage(SinkMessage sinkMessage) {\n+        boolean succeeded = sendSinkMessage(sinkMessage);\n+        if (succeeded) {\n+            return;\n+        }\n+        //Recursively try to send sink message until it succeeds.\n+        scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+    private boolean scheduleSinkMessageAfterDelay(SinkMessage sinkMessage) {\n+        ScheduledFuture<Boolean> future = blockingSinkMessageScheduler.schedule(\n+                () -> sendSinkMessage(sinkMessage), SINK_BLOCKING_TIMEOUT, TimeUnit.MILLISECONDS);\n+        try {\n+            boolean succeeded = future.get();\n+            if (succeeded) {\n+                return true;\n+            }\n+        } catch (InterruptedException | ExecutionException e) {\n+            LOG.error(\"Error while attempting to send sink message to gRPC IPC server\", e);\n+        }\n+        return scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+\n+    private synchronized boolean sendSinkMessage(SinkMessage sinkMessage) {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            if (sinkStream != null) {\n+                try {\n+                    sinkStream.onNext(sinkMessage);\n+                    return true;\n+                } catch (Throwable e) {\n+                    LOG.error(\"Exception while sending sinkMessage to gRPC IPC server\", e);\n+                }\n+            }\n+        } else {\n+            LOG.info(\"gRPC IPC server is not in ready state\");\n+        }\n+        return false;\n+    }\n+\n+\n+    private void sendMinionHeaders() {\n+        RpcResponseProto rpcHeader = RpcResponseProto.newBuilder()\n+                .setLocation(minionIdentity.getLocation())\n+                .setSystemId(minionIdentity.getId())\n+                .setModuleId(MINION_HEADERS_MODULE)\n+                .setRpcId(minionIdentity.getId())\n+                .build();\n+        sendRpcResponse(rpcHeader);\n+        LOG.info(\"Sending Minion Headers from SystemId {} to gRPC server\", minionIdentity.getId());\n+    }\n+\n+    private void processRpcRequest(RpcRequestProto requestProto) {\n+        long currentTime = requestProto.getExpirationTime();\n+        if (requestProto.getExpirationTime() < currentTime) {\n+            return;\n+        }\n+        String moduleId = requestProto.getModuleId();\n+        if (Strings.isNullOrEmpty(moduleId)) {\n+            return;\n+        }\n+        LOG.debug(\"Received RPC request with RpcID:{} for module {}\", requestProto.getRpcId(), requestProto.getModuleId());\n+        RpcModule<RpcRequest, RpcResponse> rpcModule = registerdModules.get(moduleId);\n+        if (rpcModule == null) {\n+            return;\n+        }\n+        //Build child span from rpcMessage and start minion span.\n+        Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(requestProto);\n+        Span minionSpan = spanBuilder.start();\n+        setTagsForRpc(requestProto, minionSpan);\n+\n+        RpcRequest rpcRequest = rpcModule.unmarshalRequest(requestProto.getRpcContent().toStringUtf8());\n+        CompletableFuture<RpcResponse> future = rpcModule.execute(rpcRequest);\n+        future.whenComplete((res, ex) -> {\n+            final RpcResponse rpcResponse;\n+            if (ex != null) {\n+                // An exception occurred, store the exception in a new response\n+                LOG.warn(\"An error occured while executing a call in {}.\", rpcModule.getId(), ex);\n+                rpcResponse = rpcModule.createResponseWithException(ex);\n+                minionSpan.log(ex.getMessage());\n+                minionSpan.setTag(TAG_RPC_FAILED, \"true\");", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5NzYyOA==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374897628", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .setRpcContent(ByteString.copyFrom(responseAsString.getBytes()))\n          \n          \n            \n                                .setRpcContent(ByteString.copyFrom(responseAsString, StandardCharsets.UTF_8))\n          \n      \n    \n    \n  \n\navoid copying bytes twice.", "author": "j-white", "createdAt": "2020-02-04T20:12:47Z", "path": "core/ipc/grpc/client/src/main/java/org/opennms/core/ipc/grpc/client/MinionGrpcClient.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.client;\n+\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.CLIENT_PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_CLIENT_PID;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_HOST;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.grpc.client.GrpcClientConstants.TRUST_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_PRODUCER_DOMAIN;\n+import static org.opennms.core.ipc.sink.api.SinkModule.HEARTBEAT_MODULE_ID;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_RPC_FAILED;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLException;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageDispatcherFactory;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.MinionIdentity;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NegotiationType;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class MinionGrpcClient extends AbstractMessageDispatcherFactory<String> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinionGrpcClient.class);\n+    private static final long SINK_BLOCKING_TIMEOUT = 3000;\n+    private static final int SINK_BLOCKING_THREAD_POOL_SIZE = 100;\n+    private ManagedChannel channel;\n+    private OpenNMSIpcGrpc.OpenNMSIpcStub asyncStub;\n+    private Properties properties;\n+    private BundleContext bundleContext;\n+    private MinionIdentity minionIdentity;\n+    private ConfigurationAdmin configAdmin;\n+    private StreamObserver<RpcResponseProto> rpcStream;\n+    private StreamObserver<SinkMessage> sinkStream;\n+    private ConnectivityState currentChannelState;\n+    private MetricRegistry metrics;\n+    private TracerRegistry tracerRegistry;\n+    private final ThreadFactory requestHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-request-handler-%d\")\n+            .build();\n+    private final ThreadFactory blockingSinkMessageThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"blocking-sink-message-%d\")\n+            .build();\n+    private final ExecutorService requestHandlerExecutor = Executors.newCachedThreadPool(requestHandlerThreadFactory);\n+    private final Map<String, RpcModule<RpcRequest, RpcResponse>> registerdModules = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService blockingSinkMessageScheduler = Executors.newScheduledThreadPool(SINK_BLOCKING_THREAD_POOL_SIZE,\n+            blockingSinkMessageThreadFactory);\n+\n+\n+    public MinionGrpcClient(MinionIdentity identity, ConfigurationAdmin configAdmin) {\n+        this.minionIdentity = identity;\n+        this.configAdmin = configAdmin;\n+    }\n+\n+\n+    public void start() throws IOException {\n+        properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_CLIENT_PID);\n+        String host = PropertiesUtils.getProperty(properties, GRPC_HOST, DEFAULT_GRPC_HOST);\n+        int port = PropertiesUtils.getProperty(properties, GRPC_PORT, DEFAULT_GRPC_PORT);\n+        boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+        int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+\n+        NettyChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(host, port)\n+                .keepAliveWithoutCalls(true)\n+                .maxInboundMessageSize(maxInboundMessageSize);\n+\n+        if (tlsEnabled) {\n+            channel = channelBuilder\n+                    .negotiationType(NegotiationType.TLS)\n+                    .sslContext(buildSslContext().build())\n+                    .build();\n+            LOG.info(\"TLS enabled for gRPC\");\n+        } else {\n+            channel = channelBuilder.usePlaintext().build();\n+        }\n+\n+        asyncStub = OpenNMSIpcGrpc.newStub(channel);\n+        initializeRpcStub();\n+        initializeSinkStub();\n+        if (tracerRegistry != null) {\n+            tracerRegistry.init(minionIdentity.getLocation() + \"@\" + minionIdentity.getId());\n+        }\n+        LOG.info(\"Minion at location {} with systemId {} started\", minionIdentity.getLocation(), minionIdentity.getId());\n+\n+    }\n+\n+    private SslContextBuilder buildSslContext() throws SSLException {\n+        SslContextBuilder builder = GrpcSslContexts.forClient();\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        String clientPrivateKeyFilePath = properties.getProperty(CLIENT_PRIVATE_KEY_FILE_PATH);\n+        String trustCertCollectionFilePath = properties.getProperty(TRUST_CERTIFICATE_FILE_PATH);\n+\n+        if (trustCertCollectionFilePath != null) {\n+            builder.trustManager(new File(trustCertCollectionFilePath));\n+        }\n+        if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {\n+            builder.keyManager(new File(clientCertChainFilePath), new File(clientPrivateKeyFilePath));\n+        }\n+        return builder;\n+    }\n+\n+    private void initializeRpcStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            rpcStream = asyncStub.rpcStreaming(new RpcMessageHandler());\n+            // Need to send minion headers to gRPC server in order to register.\n+            sendMinionHeaders();\n+            LOG.info(\"Initialized RPC stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+    private void initializeSinkStub() {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            sinkStream = asyncStub.sinkStreaming(new EmptyMessageReceiver());\n+            LOG.info(\"Initialized Sink stream\");\n+        } else {\n+            LOG.warn(\"gRPC IPC server is not in ready state\");\n+        }\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void bind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            if (registerdModules.containsKey(rpcModule.getId())) {\n+                LOG.warn(\" {} module is already registered\", rpcModule.getId());\n+            } else {\n+                registerdModules.put(rpcModule.getId(), rpcModule);\n+                LOG.info(\"Registered module {} with gRPC IPC client\", rpcModule.getId());\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public void unbind(RpcModule module) throws Exception {\n+        if (module != null) {\n+            final RpcModule<RpcRequest, RpcResponse> rpcModule = (RpcModule<RpcRequest, RpcResponse>) module;\n+            registerdModules.remove(rpcModule.getId());\n+            LOG.info(\"Removing module {} from gRPC IPC client.\", rpcModule.getId());\n+        }\n+    }\n+\n+    private boolean hasChangedToReadyState() {\n+        ConnectivityState prevState = currentChannelState;\n+        return !prevState.equals(ConnectivityState.READY) && getChannelState().equals(ConnectivityState.READY);\n+    }\n+\n+    public void shutdown() {\n+        requestHandlerExecutor.shutdownNow();\n+        blockingSinkMessageScheduler.shutdownNow();\n+        registerdModules.clear();\n+        if (rpcStream != null) {\n+            rpcStream.onCompleted();\n+        }\n+        channel.shutdown();\n+        LOG.info(\"Minion at location {} with systemId {} stopped\", minionIdentity.getLocation(), minionIdentity.getId());\n+    }\n+\n+    public void setBundleContext(BundleContext bundleContext) {\n+        this.bundleContext = bundleContext;\n+    }\n+\n+\n+    @Override\n+    public String getMetricDomain() {\n+        return SINK_METRIC_PRODUCER_DOMAIN;\n+    }\n+\n+    @Override\n+    public BundleContext getBundleContext() {\n+        return bundleContext;\n+    }\n+\n+    @Override\n+    public Tracer getTracer() {\n+        if (tracerRegistry != null) {\n+            return tracerRegistry.getTracer();\n+        }\n+        return GlobalTracer.get();\n+    }\n+\n+    @Override\n+    public MetricRegistry getMetrics() {\n+        if (metrics == null) {\n+            return new MetricRegistry();\n+        }\n+        return metrics;\n+    }\n+\n+    public void setMetrics(MetricRegistry metrics) {\n+        this.metrics = metrics;\n+    }\n+\n+    public TracerRegistry getTracerRegistry() {\n+        return tracerRegistry;\n+    }\n+\n+    public void setTracerRegistry(TracerRegistry tracerRegistry) {\n+        this.tracerRegistry = tracerRegistry;\n+    }\n+\n+    ConnectivityState getChannelState() {\n+        return currentChannelState = channel.getState(true);\n+    }\n+\n+\n+    @Override\n+    public <S extends Message, T extends Message> void dispatch(SinkModule<S, T> module, String metadata, T message) {\n+\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(MessageConsumerManager.LOG_PREFIX)) {\n+            byte[] sinkMessageContent = module.marshal(message);\n+            String messageId = UUID.randomUUID().toString();\n+            SinkMessage.Builder sinkMessageBuilder = SinkMessage.newBuilder()\n+                    .setMessageId(messageId)\n+                    .setLocation(minionIdentity.getLocation())\n+                    .setModuleId(module.getId())\n+                    .setContent(ByteString.copyFrom(sinkMessageContent));\n+\n+            if (module.getId().equals(HEARTBEAT_MODULE_ID)) {\n+                if (rpcStream == null || sinkStream == null || hasChangedToReadyState()) {\n+                    initializeSinkStub();\n+                    initializeRpcStub();\n+                }\n+            }\n+            setTagsForSink(sinkMessageBuilder);\n+            // If module has asyncpolicy, keep attempting to send message.\n+            if (module.getAsyncPolicy() != null) {\n+                sendBlockingSinkMessage(sinkMessageBuilder.build());\n+            } else {\n+                sendSinkMessage(sinkMessageBuilder.build());\n+            }\n+        }\n+    }\n+\n+    private void sendBlockingSinkMessage(SinkMessage sinkMessage) {\n+        boolean succeeded = sendSinkMessage(sinkMessage);\n+        if (succeeded) {\n+            return;\n+        }\n+        //Recursively try to send sink message until it succeeds.\n+        scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+    private boolean scheduleSinkMessageAfterDelay(SinkMessage sinkMessage) {\n+        ScheduledFuture<Boolean> future = blockingSinkMessageScheduler.schedule(\n+                () -> sendSinkMessage(sinkMessage), SINK_BLOCKING_TIMEOUT, TimeUnit.MILLISECONDS);\n+        try {\n+            boolean succeeded = future.get();\n+            if (succeeded) {\n+                return true;\n+            }\n+        } catch (InterruptedException | ExecutionException e) {\n+            LOG.error(\"Error while attempting to send sink message to gRPC IPC server\", e);\n+        }\n+        return scheduleSinkMessageAfterDelay(sinkMessage);\n+    }\n+\n+\n+    private synchronized boolean sendSinkMessage(SinkMessage sinkMessage) {\n+        if (getChannelState().equals(ConnectivityState.READY)) {\n+            if (sinkStream != null) {\n+                try {\n+                    sinkStream.onNext(sinkMessage);\n+                    return true;\n+                } catch (Throwable e) {\n+                    LOG.error(\"Exception while sending sinkMessage to gRPC IPC server\", e);\n+                }\n+            }\n+        } else {\n+            LOG.info(\"gRPC IPC server is not in ready state\");\n+        }\n+        return false;\n+    }\n+\n+\n+    private void sendMinionHeaders() {\n+        RpcResponseProto rpcHeader = RpcResponseProto.newBuilder()\n+                .setLocation(minionIdentity.getLocation())\n+                .setSystemId(minionIdentity.getId())\n+                .setModuleId(MINION_HEADERS_MODULE)\n+                .setRpcId(minionIdentity.getId())\n+                .build();\n+        sendRpcResponse(rpcHeader);\n+        LOG.info(\"Sending Minion Headers from SystemId {} to gRPC server\", minionIdentity.getId());\n+    }\n+\n+    private void processRpcRequest(RpcRequestProto requestProto) {\n+        long currentTime = requestProto.getExpirationTime();\n+        if (requestProto.getExpirationTime() < currentTime) {\n+            return;\n+        }\n+        String moduleId = requestProto.getModuleId();\n+        if (Strings.isNullOrEmpty(moduleId)) {\n+            return;\n+        }\n+        LOG.debug(\"Received RPC request with RpcID:{} for module {}\", requestProto.getRpcId(), requestProto.getModuleId());\n+        RpcModule<RpcRequest, RpcResponse> rpcModule = registerdModules.get(moduleId);\n+        if (rpcModule == null) {\n+            return;\n+        }\n+        //Build child span from rpcMessage and start minion span.\n+        Tracer.SpanBuilder spanBuilder = buildSpanFromRpcMessage(requestProto);\n+        Span minionSpan = spanBuilder.start();\n+        setTagsForRpc(requestProto, minionSpan);\n+\n+        RpcRequest rpcRequest = rpcModule.unmarshalRequest(requestProto.getRpcContent().toStringUtf8());\n+        CompletableFuture<RpcResponse> future = rpcModule.execute(rpcRequest);\n+        future.whenComplete((res, ex) -> {\n+            final RpcResponse rpcResponse;\n+            if (ex != null) {\n+                // An exception occurred, store the exception in a new response\n+                LOG.warn(\"An error occured while executing a call in {}.\", rpcModule.getId(), ex);\n+                rpcResponse = rpcModule.createResponseWithException(ex);\n+                minionSpan.log(ex.getMessage());\n+                minionSpan.setTag(TAG_RPC_FAILED, \"true\");\n+            } else {\n+                // No exception occurred, use the given response\n+                rpcResponse = res;\n+            }\n+            minionSpan.finish();\n+            // Construct response using the same rpcId;\n+            String responseAsString = rpcModule.marshalResponse(rpcResponse);\n+            RpcResponseProto responseProto = RpcResponseProto.newBuilder()\n+                    .setRpcId(requestProto.getRpcId())\n+                    .setSystemId(minionIdentity.getId())\n+                    .setLocation(requestProto.getLocation())\n+                    .setModuleId(requestProto.getModuleId())\n+                    .setRpcContent(ByteString.copyFrom(responseAsString.getBytes()))", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5ODQ3Nw==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374898477", "bodyText": "Would also be nice to have some high level docs here.", "author": "j-white", "createdAt": "2020-02-04T20:14:26Z", "path": "core/ipc/grpc/server/src/main/java/org/opennms/core/ipc/grpc/server/OpennmsGrpcServer.java", "diffHunk": "@@ -0,0 +1,685 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.server;\n+\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_TTL;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PID;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_TTL_PROPERTY;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.SERVER_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_CONSUMER_DOMAIN;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_TIMEOUT;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.Empty;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageConsumerManager;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RemoteExecutionException;\n+import org.opennms.core.rpc.api.RequestTimedOutException;\n+import org.opennms.core.rpc.api.RpcClient;\n+import org.opennms.core.rpc.api.RpcClientFactory;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.rpc.api.RpcResponseHandler;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.Identity;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.JmxReporter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.Server;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.ClientAuth;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslProvider;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.References;\n+import io.opentracing.Scope;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class OpennmsGrpcServer extends AbstractMessageConsumerManager implements RpcClientFactory {", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5OTAwOQ==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r374899009", "bodyText": "How does this iterator behave when the underlying collection changes? Should we clear the entry from the map when new handlers get registered?", "author": "j-white", "createdAt": "2020-02-04T20:15:33Z", "path": "core/ipc/grpc/server/src/main/java/org/opennms/core/ipc/grpc/server/OpennmsGrpcServer.java", "diffHunk": "@@ -0,0 +1,685 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.core.ipc.grpc.server;\n+\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.CLIENT_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_GRPC_TTL;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.DEFAULT_MESSAGE_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_MAX_INBOUND_SIZE;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PID;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_SERVER_PORT;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.GRPC_TTL_PROPERTY;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.PRIVATE_KEY_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.SERVER_CERTIFICATE_FILE_PATH;\n+import static org.opennms.core.ipc.grpc.server.GrpcServerConstants.TLS_ENABLED;\n+import static org.opennms.core.ipc.sink.api.Message.SINK_METRIC_CONSUMER_DOMAIN;\n+import static org.opennms.core.rpc.api.RpcModule.MINION_HEADERS_MODULE;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_LOCATION;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_SYSTEM_ID;\n+import static org.opennms.core.tracing.api.TracerConstants.TAG_TIMEOUT;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.opennms.core.ipc.grpc.common.ConfigUtils;\n+import org.opennms.core.ipc.grpc.common.Empty;\n+import org.opennms.core.ipc.grpc.common.OpenNMSIpcGrpc;\n+import org.opennms.core.ipc.grpc.common.RpcRequestProto;\n+import org.opennms.core.ipc.grpc.common.RpcResponseProto;\n+import org.opennms.core.ipc.grpc.common.SinkMessage;\n+import org.opennms.core.ipc.sink.api.Message;\n+import org.opennms.core.ipc.sink.api.MessageConsumerManager;\n+import org.opennms.core.ipc.sink.api.SinkModule;\n+import org.opennms.core.ipc.sink.common.AbstractMessageConsumerManager;\n+import org.opennms.core.logging.Logging;\n+import org.opennms.core.rpc.api.RemoteExecutionException;\n+import org.opennms.core.rpc.api.RequestTimedOutException;\n+import org.opennms.core.rpc.api.RpcClient;\n+import org.opennms.core.rpc.api.RpcClientFactory;\n+import org.opennms.core.rpc.api.RpcModule;\n+import org.opennms.core.rpc.api.RpcRequest;\n+import org.opennms.core.rpc.api.RpcResponse;\n+import org.opennms.core.rpc.api.RpcResponseHandler;\n+import org.opennms.core.tracing.api.TracerConstants;\n+import org.opennms.core.tracing.api.TracerRegistry;\n+import org.opennms.core.tracing.util.TracingInfoCarrier;\n+import org.opennms.core.utils.PropertiesUtils;\n+import org.opennms.distributed.core.api.Identity;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.JmxReporter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.protobuf.ByteString;\n+\n+import io.grpc.Server;\n+import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.ClientAuth;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;\n+import io.grpc.netty.shaded.io.netty.handler.ssl.SslProvider;\n+import io.grpc.stub.StreamObserver;\n+import io.opentracing.References;\n+import io.opentracing.Scope;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.propagation.Format;\n+import io.opentracing.propagation.TextMapExtractAdapter;\n+import io.opentracing.util.GlobalTracer;\n+\n+public class OpennmsGrpcServer extends AbstractMessageConsumerManager implements RpcClientFactory {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(OpennmsGrpcServer.class);\n+    private ConfigurationAdmin configAdmin;\n+    private Server server;\n+    private String location;\n+    private Identity identity;\n+    private Properties properties;\n+    private long ttl;\n+    private MetricRegistry rpcMetrics;\n+    private MetricRegistry sinkMetrics;\n+    private JmxReporter rpcMetricsReporter;\n+    private JmxReporter sinkMetricsReporter;\n+    private TracerRegistry tracerRegistry;\n+    private AtomicBoolean closed = new AtomicBoolean(false);\n+    private final ThreadFactory responseHandlerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-response-handler-%d\")\n+            .build();\n+    private final ThreadFactory timerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"rpc-timeout-tracker-%d\")\n+            .build();\n+    private final ThreadFactory sinkConsumerThreadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"sink-consumer-%d\")\n+            .build();\n+\n+    // RPC timeout executor thread retrieves elements from delay queue used to timeout rpc requests.\n+    private final ExecutorService rpcTimeoutExecutor = Executors.newSingleThreadExecutor(timerThreadFactory);\n+    // Each RPC response is handled on a new thread which does unmarshalling and returning response to corresponding module.\n+    private final ExecutorService responseHandlerExecutor = Executors.newCachedThreadPool(responseHandlerThreadFactory);\n+    // This map used to maintain all the requests that are sent with unique Id and all the context related to the request.\n+    private final Map<String, RpcResponseHandler> rpcResponseMap = new ConcurrentHashMap<>();\n+    // Delay queue maintains the priority queue of RPC requests and times out the requests if no response was received\n+    // within the delay specified.\n+    private DelayQueue<RpcResponseHandler> rpcTimeoutQueue = new DelayQueue<>();\n+    // Maintains map of minionId and rpc handler for that minion. Used for directed RPC requests.\n+    private Map<String, StreamObserver<RpcRequestProto>> rpcHandlerByMinionId = new HashMap<>();\n+    // Maintains multi element map of location and rpc handlers for that location.\n+    // Used to get one of the rpc handlers for a specific location.\n+    private Multimap<String, StreamObserver<RpcRequestProto>> rpcHandlerByLocation = LinkedListMultimap.create();\n+    // Maintains the state of iteration for the list of minions for a given location.\n+    private Map<Collection<StreamObserver<RpcRequestProto>>, Iterator<StreamObserver<RpcRequestProto>>> rpcHandlerIteratorMap = new HashMap<>();\n+    // Maintains the map of sink modules by it's id.\n+    private final Map<String, SinkModule<?, Message>> sinkModulesById = new ConcurrentHashMap<>();\n+    // Maintains the map of sink consumer executor and by module Id.\n+    private final Map<String, ExecutorService> sinkConsumersByModuleId = new ConcurrentHashMap<>();\n+\n+\n+    public void start() throws IOException {\n+        try (Logging.MDCCloseable mdc = Logging.withPrefixCloseable(RpcClientFactory.LOG_PREFIX)) {\n+            properties = ConfigUtils.getPropertiesFromConfig(configAdmin, GRPC_SERVER_PID);\n+            int port = PropertiesUtils.getProperty(properties, GRPC_SERVER_PORT, DEFAULT_GRPC_PORT);\n+            int maxInboundMessageSize = PropertiesUtils.getProperty(properties, GRPC_MAX_INBOUND_SIZE, DEFAULT_MESSAGE_SIZE);\n+            ttl = PropertiesUtils.getProperty(properties, GRPC_TTL_PROPERTY, DEFAULT_GRPC_TTL);\n+            boolean tlsEnabled = PropertiesUtils.getProperty(properties, TLS_ENABLED, false);\n+\n+            NettyServerBuilder serverBuilder = NettyServerBuilder.forAddress(new InetSocketAddress(port))\n+                    .addService(new OpennmsIpcService())\n+                    .maxInboundMessageSize(maxInboundMessageSize);\n+            if (tlsEnabled) {\n+                SslContextBuilder sslContextBuilder = getSslContextBuilder();\n+                if (sslContextBuilder != null) {\n+                    serverBuilder.sslContext(sslContextBuilder.build());\n+                    LOG.info(\"TLS enabled for gRPC\");\n+                }\n+            }\n+            server = serverBuilder.build();\n+            rpcTimeoutExecutor.execute(this::handleRpcTimeouts);\n+            rpcMetricsReporter = JmxReporter.forRegistry(getRpcMetrics())\n+                    .inDomain(JMX_DOMAIN_RPC)\n+                    .build();\n+            rpcMetricsReporter.start();\n+            sinkMetricsReporter = JmxReporter.forRegistry(getRpcMetrics())\n+                    .inDomain(SINK_METRIC_CONSUMER_DOMAIN)\n+                    .build();\n+            sinkMetricsReporter.start();\n+            server.start();\n+            // Initialize tracer from tracer registry.\n+            if (tracerRegistry != null) {\n+                tracerRegistry.init(identity.getId());\n+            }\n+            LOG.info(\"OpenNMS gRPC server started\");\n+        }\n+    }\n+\n+\n+    private SslContextBuilder getSslContextBuilder() {\n+        String certChainFilePath = properties.getProperty(SERVER_CERTIFICATE_FILE_PATH);\n+        String privateKeyFilePath = properties.getProperty(PRIVATE_KEY_FILE_PATH);\n+        String clientCertChainFilePath = properties.getProperty(CLIENT_CERTIFICATE_FILE_PATH);\n+        if (Strings.isNullOrEmpty(certChainFilePath) || Strings.isNullOrEmpty(privateKeyFilePath)) {\n+            return null;\n+        }\n+\n+        SslContextBuilder sslClientContextBuilder = SslContextBuilder.forServer(new File(certChainFilePath),\n+                new File(privateKeyFilePath));\n+        if (!Strings.isNullOrEmpty(clientCertChainFilePath)) {\n+            sslClientContextBuilder.trustManager(new File(clientCertChainFilePath));\n+            sslClientContextBuilder.clientAuth(ClientAuth.REQUIRE);\n+        }\n+        return GrpcSslContexts.configure(sslClientContextBuilder,\n+                SslProvider.OPENSSL);\n+    }\n+\n+\n+    @Override\n+    protected void startConsumingForModule(SinkModule<?, Message> module) throws Exception {\n+        if (sinkConsumersByModuleId.get(module.getId()) == null) {\n+            int numOfThreads = getNumConsumerThreads(module);\n+            ExecutorService executor = Executors.newFixedThreadPool(numOfThreads, sinkConsumerThreadFactory);\n+            sinkConsumersByModuleId.put(module.getId(), executor);\n+            LOG.info(\"Adding {} consumers for module: {}\", numOfThreads, module.getId());\n+        }\n+        sinkModulesById.putIfAbsent(module.getId(), module);\n+    }\n+\n+    @Override\n+    protected void stopConsumingForModule(SinkModule<?, Message> module) throws Exception {\n+\n+        ExecutorService executor = sinkConsumersByModuleId.get(module.getId());\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+        LOG.info(\"Stopped consumers for module: {}\", module.getId());\n+        sinkModulesById.remove(module.getId());\n+    }\n+\n+    @Override\n+    public <S extends RpcRequest, T extends RpcResponse> RpcClient<S, T> getClient(RpcModule<S, T> module) {\n+\n+        return new RpcClient<S, T>() {\n+            @Override\n+            public CompletableFuture<T> execute(S request) {\n+                if (request.getLocation() == null || request.getLocation().equals(getLocation())) {\n+                    // The request is for the current location, invoke it directly\n+                    return module.execute(request);\n+                }\n+                final Map<String, String> loggingContext = Logging.getCopyOfContextMap();\n+\n+                Span span = getTracer().buildSpan(module.getId()).start();\n+                String marshalRequest = module.marshalRequest(request);\n+                String rpcId = UUID.randomUUID().toString();\n+                CompletableFuture<T> future = new CompletableFuture<T>();\n+                Long timeToLive = request.getTimeToLiveMs();\n+                timeToLive = (timeToLive != null && timeToLive > 0) ? timeToLive : ttl;\n+                long expirationTime = System.currentTimeMillis() + timeToLive;\n+                RpcResponseHandlerImpl responseHandler = new RpcResponseHandlerImpl<S, T>(future,\n+                        module, rpcId, request.getLocation(), expirationTime, span, loggingContext);\n+                rpcResponseMap.put(rpcId, responseHandler);\n+                rpcTimeoutQueue.offer(responseHandler);\n+                RpcRequestProto.Builder builder = RpcRequestProto.newBuilder()\n+                        .setRpcId(rpcId)\n+                        .setLocation(request.getLocation())\n+                        .setModuleId(module.getId())\n+                        .setRpcContent(ByteString.copyFrom(marshalRequest.getBytes()));\n+                if (!Strings.isNullOrEmpty(request.getSystemId())) {\n+                    builder.setSystemId(request.getSystemId());\n+                }\n+                addTracingInfo(request, span, builder);\n+                RpcRequestProto requestProto = builder.build();\n+\n+                boolean succeeded = sendRequest(requestProto);\n+\n+                addMetrics(request, requestProto.getSerializedSize());\n+                if (!succeeded) {\n+                    RpcClientFactory.markFailed(getRpcMetrics(), request.getLocation(), module.getId());\n+                    future.completeExceptionally(new RuntimeException(\"No minion found at location \" + request.getLocation()));\n+                    return future;\n+                }\n+                LOG.debug(\"RPC request from module: {} with RpcId:{} sent to minion at location {}\", module.getId(), rpcId, request.getLocation());\n+                return future;\n+            }\n+\n+            private void addMetrics(RpcRequest request, int messageLen) {\n+                RpcClientFactory.markRpcCount(getRpcMetrics(), request.getLocation(), module.getId());\n+                RpcClientFactory.updateRequestSize(getRpcMetrics(), request.getLocation(), module.getId(), messageLen);\n+            }\n+\n+            private void addTracingInfo(RpcRequest request, Span span, RpcRequestProto.Builder builder) {\n+                //Add tags to span.\n+                span.setTag(TAG_LOCATION, request.getLocation());\n+                if (request.getSystemId() != null) {\n+                    span.setTag(TAG_SYSTEM_ID, request.getSystemId());\n+                }\n+                request.getTracingInfo().forEach(span::setTag);\n+                TracingInfoCarrier tracingInfoCarrier = new TracingInfoCarrier();\n+                getTracer().inject(span.context(), Format.Builtin.TEXT_MAP, tracingInfoCarrier);\n+                // Tracer adds it's own metadata.\n+                tracingInfoCarrier.getTracingInfoMap().forEach(builder::putTracingInfo);\n+                //Add custom tags from RpcRequest.\n+                request.getTracingInfo().forEach(builder::putTracingInfo);\n+            }\n+        };\n+    }\n+\n+\n+    private void handleRpcTimeouts() {\n+        while (!closed.get()) {\n+            try {\n+                RpcResponseHandler responseHandler = rpcTimeoutQueue.take();\n+                if (!responseHandler.isProcessed()) {\n+                    LOG.warn(\"RPC request from module: {} with RpcId:{} timedout \", responseHandler.getRpcModule().getId(),\n+                            responseHandler.getRpcId());\n+                    responseHandlerExecutor.execute(() -> responseHandler.sendResponse(null));\n+                }\n+            } catch (InterruptedException e) {\n+                LOG.info(\"interrupted while waiting for an element from rpcTimeoutQueue\", e);\n+                Thread.currentThread().interrupt();\n+                break;\n+            } catch (Exception e) {\n+                LOG.warn(\"error while sending response from timeout handler\", e);\n+            }\n+        }\n+    }\n+\n+\n+    private void handleResponse(RpcResponseProto responseProto) {\n+\n+        if (Strings.isNullOrEmpty(responseProto.getRpcId())) {\n+            return;\n+        }\n+        // Handle response from the Minion.\n+        RpcResponseHandler responseHandler = rpcResponseMap.get(responseProto.getRpcId());\n+        if (responseHandler != null && responseProto.getRpcContent() != null) {\n+            responseHandler.sendResponse(responseProto.getRpcContent().toStringUtf8());\n+        } else {\n+            LOG.debug(\"Received a response for request for module: {} with RpcId:{}, but no outstanding request was found with this id.\" +\n+                    \"The request may have timed out\", responseProto.getModuleId(), responseProto.getRpcId());\n+        }\n+    }\n+\n+    private boolean sendRequest(RpcRequestProto requestProto) {\n+        StreamObserver<RpcRequestProto> rpcHandler = getRpcHandler(requestProto.getLocation(), requestProto.getSystemId());\n+        if (rpcHandler == null) {\n+            LOG.warn(\"No RPC handlers found for location {}\", requestProto.getLocation());\n+            return false;\n+        }\n+        try {\n+            sendRpcRequest(rpcHandler, requestProto);\n+            return true;\n+        } catch (Throwable e) {\n+            LOG.error(\"Encountered exception while sending request {}\", requestProto, e);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Writing message through stream observer is not thread safe.\n+     */\n+    private synchronized void sendRpcRequest(StreamObserver<RpcRequestProto> rpcHandler, RpcRequestProto rpcMessage) {\n+        rpcHandler.onNext(rpcMessage);\n+    }\n+\n+    private synchronized StreamObserver<RpcRequestProto> getRpcHandler(String location, String systemId) {\n+\n+        if (!Strings.isNullOrEmpty(systemId)) {\n+            return rpcHandlerByMinionId.get(systemId);\n+        }\n+        Collection<StreamObserver<RpcRequestProto>> streamObservers = rpcHandlerByLocation.get(location);\n+        if (streamObservers.isEmpty()) {\n+            return null;\n+        }\n+        Iterator<StreamObserver<RpcRequestProto>> iterator = rpcHandlerIteratorMap.get(streamObservers);\n+        if (iterator == null) {\n+            iterator = Iterables.cycle(streamObservers).iterator();\n+            rpcHandlerIteratorMap.put(streamObservers, iterator);", "originalCommit": "3a7342eef4f695a5f3e170913f918b26962fbfe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzMzM1Mw==", "url": "https://github.com/OpenNMS/opennms/pull/2863#discussion_r375933353", "bodyText": "Handled this differently with location as key and updating iterator in add/remove handler methods.", "author": "cgorantla", "createdAt": "2020-02-06T16:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5OTAwOQ=="}], "type": "inlineReview"}, {"oid": "b2bd4b76e1c0655796921ba9fd9bb41e17b3a606", "url": "https://github.com/OpenNMS/opennms/commit/b2bd4b76e1c0655796921ba9fd9bb41e17b3a606", "message": "NMS-12372: Handle review comments\n\nAdd test for multiple clients to test iteration", "committedDate": "2020-02-06T16:13:40Z", "type": "commit"}, {"oid": "7d6a4ddcfb81d1549803bd1b138b721b18eb1f9e", "url": "https://github.com/OpenNMS/opennms/commit/7d6a4ddcfb81d1549803bd1b138b721b18eb1f9e", "message": "Merge branch 'develop' into jira/NMS-12372", "committedDate": "2020-02-06T16:14:07Z", "type": "commit"}, {"oid": "2cc359b3577591c2d58470088ebaa202fd31fa3e", "url": "https://github.com/OpenNMS/opennms/commit/2cc359b3577591c2d58470088ebaa202fd31fa3e", "message": "NMS-12372: Fix tests compilation on new file.", "committedDate": "2020-02-06T16:36:06Z", "type": "commit"}, {"oid": "2cc359b3577591c2d58470088ebaa202fd31fa3e", "url": "https://github.com/OpenNMS/opennms/commit/2cc359b3577591c2d58470088ebaa202fd31fa3e", "message": "NMS-12372: Fix tests compilation on new file.", "committedDate": "2020-02-06T16:36:06Z", "type": "forcePushed"}, {"oid": "8789cc18b980ad6e8fbc3f6b3a4dc0c7c065fe96", "url": "https://github.com/OpenNMS/opennms/commit/8789cc18b980ad6e8fbc3f6b3a4dc0c7c065fe96", "message": "Merge branch 'develop' into jira/NMS-12372", "committedDate": "2020-02-11T15:11:05Z", "type": "commit"}, {"oid": "db730320838379562394c391974021652b1d7e78", "url": "https://github.com/OpenNMS/opennms/commit/db730320838379562394c391974021652b1d7e78", "message": "Update EmptyMessageReceiver.java", "committedDate": "2020-02-11T16:38:13Z", "type": "commit"}, {"oid": "6d242a3c51f86f33cee7902927117b858c49f322", "url": "https://github.com/OpenNMS/opennms/commit/6d242a3c51f86f33cee7902927117b858c49f322", "message": "Changed 2019 to 2020", "committedDate": "2020-02-11T16:39:04Z", "type": "commit"}, {"oid": "875cf020f871f833dee5ffc9e5c33a9519c62eef", "url": "https://github.com/OpenNMS/opennms/commit/875cf020f871f833dee5ffc9e5c33a9519c62eef", "message": "Changed 2019 to 2020", "committedDate": "2020-02-11T16:40:03Z", "type": "commit"}, {"oid": "61ef757d4846d702eaf5962ebaddcc7f65123bc1", "url": "https://github.com/OpenNMS/opennms/commit/61ef757d4846d702eaf5962ebaddcc7f65123bc1", "message": "Changed 2019 to 2020", "committedDate": "2020-02-11T16:40:40Z", "type": "commit"}, {"oid": "afa3b93fec081485dd7288f3a3ad846f677a498b", "url": "https://github.com/OpenNMS/opennms/commit/afa3b93fec081485dd7288f3a3ad846f677a498b", "message": "Changed 2019 to 2020", "committedDate": "2020-02-11T16:41:28Z", "type": "commit"}, {"oid": "497105f6cbf52f5e4976b38d68ccea5955e39683", "url": "https://github.com/OpenNMS/opennms/commit/497105f6cbf52f5e4976b38d68ccea5955e39683", "message": "Changed 2019 to 2020", "committedDate": "2020-02-11T16:42:01Z", "type": "commit"}, {"oid": "b51a84048e7b1c6b864cda28a6d0d19ba31d09c3", "url": "https://github.com/OpenNMS/opennms/commit/b51a84048e7b1c6b864cda28a6d0d19ba31d09c3", "message": "NMS-12372: Fix review comments", "committedDate": "2020-02-18T18:58:12Z", "type": "commit"}]}