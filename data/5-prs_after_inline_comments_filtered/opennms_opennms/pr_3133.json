{"pr_number": 3133, "pr_title": "NMS-12878: Make backend more resilient", "pr_createdAt": "2020-08-27T14:02:47Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/3133", "timeline": [{"oid": "e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "url": "https://github.com/OpenNMS/opennms/commit/e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "message": "NMS-12878: Make backend more resilient", "committedDate": "2020-08-27T19:23:25Z", "type": "commit"}, {"oid": "e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "url": "https://github.com/OpenNMS/opennms/commit/e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "message": "NMS-12878: Make backend more resilient", "committedDate": "2020-08-27T19:23:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NDYxNQ==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r478674615", "bodyText": "Do we intend to use min (vs max here?). The default value of REFRESH_RATE_LIMIT_MS is 30 seconds.", "author": "j-white", "createdAt": "2020-08-27T20:23:57Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/PerspectiveServiceTracker.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.remotepollerng;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.sysprops.SystemProperties;\n+import org.opennms.netmgt.dao.api.ApplicationDao;\n+import org.opennms.netmgt.dao.api.ServicePerspective;\n+import org.opennms.netmgt.dao.api.SessionUtils;\n+import org.opennms.netmgt.events.api.EventConstants;\n+import org.opennms.netmgt.events.api.annotations.EventHandler;\n+import org.opennms.netmgt.events.api.annotations.EventListener;\n+import org.opennms.netmgt.events.api.model.IEvent;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.DisposableBean;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import com.google.common.collect.Sets;\n+\n+@EventListener(name = \"PerspectiveServiceTracker\")\n+public class PerspectiveServiceTracker implements DisposableBean {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PerspectiveServiceTracker.class);\n+\n+    private static final long REFRESH_RATE_LIMIT_MS = SystemProperties.getLong(\"org.opennms.netmgt.remotepollerng.trackerRefreshRateLimit\", TimeUnit.SECONDS.toMillis(30));\n+\n+    public interface Listener {\n+        void onServicePerspectiveAdded(final ServicePerspectiveRef servicePerspective, final ServicePerspective entity);\n+        void onServicePerspectiveRemoved(final ServicePerspectiveRef servicePerspective);\n+    }\n+\n+    public static class ServicePerspectiveRef {\n+        private final int nodeId;\n+        private final InetAddress ipAddress;\n+        private final String serviceName;\n+        private final String perspectiveLocation;\n+\n+        public ServicePerspectiveRef(final int nodeId,\n+                                     final InetAddress ipAddress,\n+                                     final String serviceName,\n+                                     final String perspectiveLocation) {\n+            this.nodeId = Objects.requireNonNull(nodeId);\n+            this.ipAddress = Objects.requireNonNull(ipAddress);\n+            this.serviceName = Objects.requireNonNull(serviceName);\n+            this.perspectiveLocation = Objects.requireNonNull(perspectiveLocation);\n+        }\n+\n+        public int getNodeId() {\n+            return this.nodeId;\n+        }\n+\n+        public InetAddress getIpAddress() {\n+            return this.ipAddress;\n+        }\n+\n+        public String getServiceName() {\n+            return this.serviceName;\n+        }\n+\n+        public String getPerspectiveLocation() {\n+            return this.perspectiveLocation;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof ServicePerspectiveRef)) {\n+                return false;\n+            }\n+            final ServicePerspectiveRef that = (ServicePerspectiveRef) o;\n+            return Objects.equals(this.nodeId, that.nodeId) &&\n+                   Objects.equals(this.ipAddress, that.ipAddress) &&\n+                   Objects.equals(this.serviceName, that.serviceName) &&\n+                   Objects.equals(this.perspectiveLocation, that.perspectiveLocation);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(this.nodeId, this.ipAddress, this.serviceName, this.perspectiveLocation);\n+        }\n+\n+        public static ServicePerspectiveRef from(final ServicePerspective servicePerspective) {\n+            return new ServicePerspectiveRef(servicePerspective.getService().getNodeId(),\n+                                             servicePerspective.getService().getIpAddress(),\n+                                             servicePerspective.getService().getServiceName(),\n+                                             servicePerspective.getPerspectiveLocation().getLocationName());\n+        }\n+    }\n+\n+    private final SessionUtils sessionUtils;\n+\n+    private final ApplicationDao applicationDao;\n+\n+    private final Set<Session> sessions = Sets.newHashSet();\n+\n+    private final Timer timer = new Timer(\"PerspectiveServiceTracker-Timer\");\n+\n+    @Autowired\n+    public PerspectiveServiceTracker(final SessionUtils sessionUtils,\n+                                     final ApplicationDao applicationDao) {\n+        this.sessionUtils = Objects.requireNonNull(sessionUtils);\n+        this.applicationDao = Objects.requireNonNull(applicationDao);\n+\n+        final long timerIntevalMs = Math.min(REFRESH_RATE_LIMIT_MS, TimeUnit.SECONDS.toMillis(5));", "originalCommit": "e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODk5NDEwMQ==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r478994101", "bodyText": "I think so. This is the polling interval denoting how often it checks for outstanding refresh (those who are not executed immediately due to the rate limit). This should usually be smaller than the rate limit.", "author": "fooker", "createdAt": "2020-08-28T09:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NDYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTAxOTA4OA==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r479019088", "bodyText": "Ah yes, got it. Every 5ms the timer checks if an update is necessary and updates if the last one is older than REFRESH_RATE_LIMIT_MS, right? This way events are handled faster than waiting for REFRESH_RATE_LIMIT_MS.", "author": "christianpape", "createdAt": "2020-08-28T09:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NDYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTA4MDkwMA==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r479080900", "bodyText": "Exactly (beside the check is every 5s not every 5ms)", "author": "fooker", "createdAt": "2020-08-28T10:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NDYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTA4NjQ1MQ==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r479086451", "bodyText": "Right.", "author": "christianpape", "createdAt": "2020-08-28T10:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NDYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NjY5OA==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r478676698", "bodyText": "I'd move the \"org.opennms.netmgt.remotepollerng.trackerRefreshRateLimit\" part to a constant and refer to that instead.", "author": "j-white", "createdAt": "2020-08-27T20:28:06Z", "path": "features/remotepollerng/daemon/src/test/java/org/opennms/netmgt/remotepollerng/RemotePollerdIT.java", "diffHunk": "@@ -215,6 +215,11 @@ public void setUp() throws Exception {\n         locationAwarePollerClient.setRpcTargetHelper(new RpcTargetHelper());\n         locationAwarePollerClient.afterPropertiesSet();\n \n+        System.setProperty(\"org.opennms.netmgt.remotepollerng.trackerRefreshRateLimit\", \"5\");", "originalCommit": "e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODk5NjEwMQ==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r478996101", "bodyText": "Ay", "author": "fooker", "createdAt": "2020-08-28T09:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NjY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3Nzc2NQ==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r478677765", "bodyText": "Every session will create its own transaction and repeat the same DB query. This is not a big problem since there's likely only 1 session, but would be nicer to do that outside the loop.", "author": "j-white", "createdAt": "2020-08-27T20:30:11Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/PerspectiveServiceTracker.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.remotepollerng;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.sysprops.SystemProperties;\n+import org.opennms.netmgt.dao.api.ApplicationDao;\n+import org.opennms.netmgt.dao.api.ServicePerspective;\n+import org.opennms.netmgt.dao.api.SessionUtils;\n+import org.opennms.netmgt.events.api.EventConstants;\n+import org.opennms.netmgt.events.api.annotations.EventHandler;\n+import org.opennms.netmgt.events.api.annotations.EventListener;\n+import org.opennms.netmgt.events.api.model.IEvent;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.DisposableBean;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import com.google.common.collect.Sets;\n+\n+@EventListener(name = \"PerspectiveServiceTracker\")\n+public class PerspectiveServiceTracker implements DisposableBean {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PerspectiveServiceTracker.class);\n+\n+    private static final long REFRESH_RATE_LIMIT_MS = SystemProperties.getLong(\"org.opennms.netmgt.remotepollerng.trackerRefreshRateLimit\", TimeUnit.SECONDS.toMillis(30));\n+\n+    public interface Listener {\n+        void onServicePerspectiveAdded(final ServicePerspectiveRef servicePerspective, final ServicePerspective entity);\n+        void onServicePerspectiveRemoved(final ServicePerspectiveRef servicePerspective);\n+    }\n+\n+    public static class ServicePerspectiveRef {\n+        private final int nodeId;\n+        private final InetAddress ipAddress;\n+        private final String serviceName;\n+        private final String perspectiveLocation;\n+\n+        public ServicePerspectiveRef(final int nodeId,\n+                                     final InetAddress ipAddress,\n+                                     final String serviceName,\n+                                     final String perspectiveLocation) {\n+            this.nodeId = Objects.requireNonNull(nodeId);\n+            this.ipAddress = Objects.requireNonNull(ipAddress);\n+            this.serviceName = Objects.requireNonNull(serviceName);\n+            this.perspectiveLocation = Objects.requireNonNull(perspectiveLocation);\n+        }\n+\n+        public int getNodeId() {\n+            return this.nodeId;\n+        }\n+\n+        public InetAddress getIpAddress() {\n+            return this.ipAddress;\n+        }\n+\n+        public String getServiceName() {\n+            return this.serviceName;\n+        }\n+\n+        public String getPerspectiveLocation() {\n+            return this.perspectiveLocation;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof ServicePerspectiveRef)) {\n+                return false;\n+            }\n+            final ServicePerspectiveRef that = (ServicePerspectiveRef) o;\n+            return Objects.equals(this.nodeId, that.nodeId) &&\n+                   Objects.equals(this.ipAddress, that.ipAddress) &&\n+                   Objects.equals(this.serviceName, that.serviceName) &&\n+                   Objects.equals(this.perspectiveLocation, that.perspectiveLocation);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(this.nodeId, this.ipAddress, this.serviceName, this.perspectiveLocation);\n+        }\n+\n+        public static ServicePerspectiveRef from(final ServicePerspective servicePerspective) {\n+            return new ServicePerspectiveRef(servicePerspective.getService().getNodeId(),\n+                                             servicePerspective.getService().getIpAddress(),\n+                                             servicePerspective.getService().getServiceName(),\n+                                             servicePerspective.getPerspectiveLocation().getLocationName());\n+        }\n+    }\n+\n+    private final SessionUtils sessionUtils;\n+\n+    private final ApplicationDao applicationDao;\n+\n+    private final Set<Session> sessions = Sets.newHashSet();\n+\n+    private final Timer timer = new Timer(\"PerspectiveServiceTracker-Timer\");\n+\n+    @Autowired\n+    public PerspectiveServiceTracker(final SessionUtils sessionUtils,\n+                                     final ApplicationDao applicationDao) {\n+        this.sessionUtils = Objects.requireNonNull(sessionUtils);\n+        this.applicationDao = Objects.requireNonNull(applicationDao);\n+\n+        final long timerIntevalMs = Math.min(REFRESH_RATE_LIMIT_MS, TimeUnit.SECONDS.toMillis(5));\n+        this.timer.schedule(new TimerTask() {\n+            @Override\n+            public void run() {\n+                PerspectiveServiceTracker.this.update(false);\n+            }\n+        }, timerIntevalMs, timerIntevalMs);\n+    }\n+\n+    public AutoCloseable track(final Listener listener) {\n+        final Session session = new Session(listener);\n+        session.update(true);\n+\n+        return session;\n+    }\n+\n+    @Override\n+    public void destroy() throws Exception {\n+        this.timer.cancel();\n+    }\n+\n+    @EventHandler(ueis = {\n+            EventConstants.NODE_GAINED_SERVICE_EVENT_UEI,\n+            EventConstants.SERVICE_DELETED_EVENT_UEI,\n+            EventConstants.NODE_CATEGORY_MEMBERSHIP_CHANGED_EVENT_UEI,\n+            EventConstants.NODE_LOCATION_CHANGED_EVENT_UEI,\n+            EventConstants.NODE_ADDED_EVENT_UEI,\n+            EventConstants.NODE_DELETED_EVENT_UEI,\n+            EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI,\n+            EventConstants.INTERFACE_DELETED_EVENT_UEI,\n+            EventConstants.INTERFACE_REPARENTED_EVENT_UEI,\n+            EventConstants.SUSPEND_POLLING_SERVICE_EVENT_UEI,\n+            EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI,\n+            EventConstants.APPLICATION_CHANGED_EVENT_UEI,\n+            EventConstants.APPLICATION_CREATED_EVENT_UEI,\n+            EventConstants.APPLICATION_DELETED_EVENT_UEI,\n+    })\n+    public void handleEvent(final IEvent event) {\n+        update(true);\n+    }\n+\n+    private void update(final boolean dirty) {\n+        synchronized (PerspectiveServiceTracker.this.sessions) {\n+            try {\n+                PerspectiveServiceTracker.this.sessions.forEach(session -> session.update(dirty));", "originalCommit": "e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTAwMTY3Ng==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r479001676", "bodyText": "But the session is only created if an update is required for that session. By moving it out of the session, it will be created every time. Most of the time, calls to the update method will result in an early return.", "author": "fooker", "createdAt": "2020-08-28T09:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3Nzc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2NjAyMQ==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r478866021", "bodyText": "typo: timerInte>r<valMs", "author": "christianpape", "createdAt": "2020-08-28T06:51:00Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/PerspectiveServiceTracker.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.remotepollerng;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.sysprops.SystemProperties;\n+import org.opennms.netmgt.dao.api.ApplicationDao;\n+import org.opennms.netmgt.dao.api.ServicePerspective;\n+import org.opennms.netmgt.dao.api.SessionUtils;\n+import org.opennms.netmgt.events.api.EventConstants;\n+import org.opennms.netmgt.events.api.annotations.EventHandler;\n+import org.opennms.netmgt.events.api.annotations.EventListener;\n+import org.opennms.netmgt.events.api.model.IEvent;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.DisposableBean;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import com.google.common.collect.Sets;\n+\n+@EventListener(name = \"PerspectiveServiceTracker\")\n+public class PerspectiveServiceTracker implements DisposableBean {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PerspectiveServiceTracker.class);\n+\n+    private static final long REFRESH_RATE_LIMIT_MS = SystemProperties.getLong(\"org.opennms.netmgt.remotepollerng.trackerRefreshRateLimit\", TimeUnit.SECONDS.toMillis(30));\n+\n+    public interface Listener {\n+        void onServicePerspectiveAdded(final ServicePerspectiveRef servicePerspective, final ServicePerspective entity);\n+        void onServicePerspectiveRemoved(final ServicePerspectiveRef servicePerspective);\n+    }\n+\n+    public static class ServicePerspectiveRef {\n+        private final int nodeId;\n+        private final InetAddress ipAddress;\n+        private final String serviceName;\n+        private final String perspectiveLocation;\n+\n+        public ServicePerspectiveRef(final int nodeId,\n+                                     final InetAddress ipAddress,\n+                                     final String serviceName,\n+                                     final String perspectiveLocation) {\n+            this.nodeId = Objects.requireNonNull(nodeId);\n+            this.ipAddress = Objects.requireNonNull(ipAddress);\n+            this.serviceName = Objects.requireNonNull(serviceName);\n+            this.perspectiveLocation = Objects.requireNonNull(perspectiveLocation);\n+        }\n+\n+        public int getNodeId() {\n+            return this.nodeId;\n+        }\n+\n+        public InetAddress getIpAddress() {\n+            return this.ipAddress;\n+        }\n+\n+        public String getServiceName() {\n+            return this.serviceName;\n+        }\n+\n+        public String getPerspectiveLocation() {\n+            return this.perspectiveLocation;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof ServicePerspectiveRef)) {\n+                return false;\n+            }\n+            final ServicePerspectiveRef that = (ServicePerspectiveRef) o;\n+            return Objects.equals(this.nodeId, that.nodeId) &&\n+                   Objects.equals(this.ipAddress, that.ipAddress) &&\n+                   Objects.equals(this.serviceName, that.serviceName) &&\n+                   Objects.equals(this.perspectiveLocation, that.perspectiveLocation);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(this.nodeId, this.ipAddress, this.serviceName, this.perspectiveLocation);\n+        }\n+\n+        public static ServicePerspectiveRef from(final ServicePerspective servicePerspective) {\n+            return new ServicePerspectiveRef(servicePerspective.getService().getNodeId(),\n+                                             servicePerspective.getService().getIpAddress(),\n+                                             servicePerspective.getService().getServiceName(),\n+                                             servicePerspective.getPerspectiveLocation().getLocationName());\n+        }\n+    }\n+\n+    private final SessionUtils sessionUtils;\n+\n+    private final ApplicationDao applicationDao;\n+\n+    private final Set<Session> sessions = Sets.newHashSet();\n+\n+    private final Timer timer = new Timer(\"PerspectiveServiceTracker-Timer\");\n+\n+    @Autowired\n+    public PerspectiveServiceTracker(final SessionUtils sessionUtils,\n+                                     final ApplicationDao applicationDao) {\n+        this.sessionUtils = Objects.requireNonNull(sessionUtils);\n+        this.applicationDao = Objects.requireNonNull(applicationDao);\n+\n+        final long timerIntevalMs = Math.min(REFRESH_RATE_LIMIT_MS, TimeUnit.SECONDS.toMillis(5));", "originalCommit": "e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3NjMxNQ==", "url": "https://github.com/OpenNMS/opennms/pull/3133#discussion_r478876315", "bodyText": "Please also add an entry with description and default value in opennms-base-assembly/src/main/filtered/etc/opennms.properties.", "author": "christianpape", "createdAt": "2020-08-28T07:15:19Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/PerspectiveServiceTracker.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.remotepollerng;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.sysprops.SystemProperties;\n+import org.opennms.netmgt.dao.api.ApplicationDao;\n+import org.opennms.netmgt.dao.api.ServicePerspective;\n+import org.opennms.netmgt.dao.api.SessionUtils;\n+import org.opennms.netmgt.events.api.EventConstants;\n+import org.opennms.netmgt.events.api.annotations.EventHandler;\n+import org.opennms.netmgt.events.api.annotations.EventListener;\n+import org.opennms.netmgt.events.api.model.IEvent;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.DisposableBean;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import com.google.common.collect.Sets;\n+\n+@EventListener(name = \"PerspectiveServiceTracker\")\n+public class PerspectiveServiceTracker implements DisposableBean {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PerspectiveServiceTracker.class);\n+\n+    private static final long REFRESH_RATE_LIMIT_MS = SystemProperties.getLong(\"org.opennms.netmgt.remotepollerng.trackerRefreshRateLimit\", TimeUnit.SECONDS.toMillis(30));", "originalCommit": "e1ff9e7d0a964f4852732fe6ea16dd7e0288b955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9218b4e2b6ee952b1bbcfb289fd4b6eb1cdb6f80", "url": "https://github.com/OpenNMS/opennms/commit/9218b4e2b6ee952b1bbcfb289fd4b6eb1cdb6f80", "message": "NMS-12878: Review comments", "committedDate": "2020-08-28T09:21:33Z", "type": "commit"}, {"oid": "28a374ab9ea61a3aa58e1ba773f620bc456d2a39", "url": "https://github.com/OpenNMS/opennms/commit/28a374ab9ea61a3aa58e1ba773f620bc456d2a39", "message": "Merge remote-tracking branch 'origin/features/rpwm' into jira/NMS-12878", "committedDate": "2020-08-28T09:46:35Z", "type": "commit"}]}