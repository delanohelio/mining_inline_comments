{"pr_number": 2886, "pr_title": "NMS-12423: Add CIDR support for ip address expressions (Classification Rules)", "pr_createdAt": "2020-02-13T09:53:58Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/2886", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzI0Ng==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213246", "bodyText": "Create a CIDR test rule?", "author": "Naicisum", "createdAt": "2020-02-14T01:41:58Z", "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/DefaultClassificationEngineTest.java", "diffHunk": "@@ -94,14 +94,15 @@ public void verifyRuleEngineWithOmnidirectionals() {\n         assertNull(engine.classify(new ClassificationRequestBuilder().withSrcPort(7331).withDstPort(9999).build()));\n     }\n \n+    // TODO MVR add CIDR test\n     @Test\n     public void verifyRuleEngineExtended() {\n         // Define Rule set\n         DefaultClassificationEngine engine = new DefaultClassificationEngine(() -> Lists.newArrayList(\n                 new RuleBuilder().withName(\"SSH\").withDstPort(\"22\").withPosition(1).build(),\n                 new RuleBuilder().withName(\"HTTP_CUSTOM\").withDstAddress(\"192.168.0.1\").withDstPort(\"80\").withPosition(2).build(),\n                 new RuleBuilder().withName(\"HTTP\").withDstPort(\"80\").withPosition(3).build(),\n-                new RuleBuilder().withName(\"DUMMY\").withDstAddress(\"192.168.1.*\").withDstPort(\"8000-9000,80,8080\").withPosition(4).build(),\n+                new RuleBuilder().withName(\"DUMMY\").withDstAddress(\"192.168.1.0-192.168.1.255,10.10.5.3\").withDstPort(\"8000-9000,80,8080\").withPosition(4).build(),", "originalCommit": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzI5OA==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213298", "bodyText": "Test the CIDR rule?", "author": "Naicisum", "createdAt": "2020-02-14T01:42:10Z", "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/DefaultClassificationEngineTest.java", "diffHunk": "@@ -138,6 +139,13 @@ public void verifyRuleEngineExtended() {\n                         .withDstPort(80)\n                         .withDstAddress(\"192.168.0.2\")\n                         .withProtocol(ProtocolType.TCP).build()));\n+        assertEquals(\"DUMMY\", engine.classify(new ClassificationRequestBuilder()\n+                .withLocation(\"Default\")\n+                .withSrcAddress(\"127.0.0.1\")\n+                .withDstAddress(\"10.10.5.3\")\n+                .withSrcPort(5213)\n+                .withDstPort(8080)\n+                .withProtocol(ProtocolType.TCP).build()));", "originalCommit": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213603", "bodyText": "Wouldn't this be true? Value is apart of ipValue on declaration.", "author": "Naicisum", "createdAt": "2020-02-14T01:43:32Z", "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.flows.classification.internal.value;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.opennms.core.network.IPAddress;\n+import org.opennms.core.network.IPAddressRange;\n+\n+public class IpValueTest {\n+\n+    @Test\n+    public void verifyRangedValues() {\n+        final IpValue ipValue = new IpValue(\"10.1.1.1-10.1.1.100\");\n+        final IPAddressRange range = new IPAddressRange(\"10.1.1.1\", \"10.1.1.100\");\n+        for (IPAddress address : range) {\n+            assertThat(ipValue.isInRange(address.toUserString()), is(true));\n+        }\n+    }\n+\n+    @Test\n+    public void verifySingleValue() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(false));\n+    }\n+\n+    @Test\n+    public void verifyMultiValues() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1, 192.168.0.2, 192.168.0.10\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.3\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.4\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.5\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.6\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.7\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.8\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.9\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.10\"), is(true));\n+    }\n+\n+    @Test\n+    public void verifyCIDRValue() {\n+        final IpValue ipValue = new IpValue(\"10.0.0.5,192.168.0.0/24\");\n+        for (IPAddress ipAddress : new IPAddressRange(\"192.168.0.0\", \"192.168.0.255\")) {\n+            assertThat(ipValue.isInRange(ipAddress.toUserString()), is(true));\n+        }\n+        assertThat(ipValue.isInRange(\"10.0.0.5\"), is(false));", "originalCommit": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzgwMA==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213800", "bodyText": "Should also test CIDR values that are not on network address. IE. 10.0.0.0/24 is the same as 10.0.0.1/24 and 10.0.0.255/24", "author": "Naicisum", "createdAt": "2020-02-14T01:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyMzAzMQ==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379323031", "bodyText": "Not sure what you mean with the latest comment.", "author": "mvrueden", "createdAt": "2020-02-14T09:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA2NzUyNw==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381067527", "bodyText": "Not everyone will use the standard CIDR notation of 192.168.0.0/24, some will use 192.168.0.1/24 instead. Both are identical and valid.", "author": "Naicisum", "createdAt": "2020-02-19T04:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2ODY3Mg==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381168672", "bodyText": "Yes, that is true. Internally it is already working as expected, but adding a few more test cases to cover these is a good idea.", "author": "mvrueden", "createdAt": "2020-02-19T09:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxMzg4Mw==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r379213883", "bodyText": "Should test IPV6 CIDR", "author": "Naicisum", "createdAt": "2020-02-14T01:45:11Z", "path": "features/flows/classification/engine/impl/src/test/java/org/opennms/netmgt/flows/classification/internal/value/IpValueTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.flows.classification.internal.value;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.opennms.core.network.IPAddress;\n+import org.opennms.core.network.IPAddressRange;\n+\n+public class IpValueTest {\n+\n+    @Test\n+    public void verifyRangedValues() {\n+        final IpValue ipValue = new IpValue(\"10.1.1.1-10.1.1.100\");\n+        final IPAddressRange range = new IPAddressRange(\"10.1.1.1\", \"10.1.1.100\");\n+        for (IPAddress address : range) {\n+            assertThat(ipValue.isInRange(address.toUserString()), is(true));\n+        }\n+    }\n+\n+    @Test\n+    public void verifySingleValue() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(false));\n+    }\n+\n+    @Test\n+    public void verifyMultiValues() {\n+        final IpValue ipValue = new IpValue(\"192.168.0.1, 192.168.0.2, 192.168.0.10\");\n+        assertThat(ipValue.isInRange(\"192.168.0.0\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.1\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.2\"), is(true));\n+        assertThat(ipValue.isInRange(\"192.168.0.3\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.4\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.5\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.6\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.7\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.8\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.9\"), is(false));\n+        assertThat(ipValue.isInRange(\"192.168.0.10\"), is(true));\n+    }\n+\n+    @Test\n+    public void verifyCIDRValue() {\n+        final IpValue ipValue = new IpValue(\"10.0.0.5,192.168.0.0/24\");\n+        for (IPAddress ipAddress : new IPAddressRange(\"192.168.0.0\", \"192.168.0.255\")) {\n+            assertThat(ipValue.isInRange(ipAddress.toUserString()), is(true));\n+        }\n+        assertThat(ipValue.isInRange(\"10.0.0.5\"), is(false));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyCIDRValueNotAllowedInRange() {\n+        new IpValue(\"192.0.0.0/8-192.168.0.0/24\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyWildcard() {\n+        new IpValue(\"*\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyInvalidIpAddress() {\n+        new IpValue(\"300.400.500.600\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyInvalidIpAddressRanges() {\n+        new IpValue(\"192.168.0.1-a.b.c.d\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void verifyInvalidIpAddressRangeEndIsBefore() {\n+        new IpValue(\"192.168.10.255-192.168.0.1\");\n+    }\n+\n+    @Test\n+    public void verifySingleValueIpV6() {\n+        final IpValue value = new IpValue(\"2001:0DB8:0:CD30::1\");\n+        assertThat(value.isInRange(\"2001:0DB8:0:CD30::1\"), is(true));\n+        assertThat(value.isInRange(\"2001:0DB8:0:CD30::2\"), is(false));\n+        assertThat(value.isInRange(\"192.168.0.1\"), is(false)); // incompatible, should be false", "originalCommit": "45f0c6027321e81a9fff8f427c87ecdfa4dd7447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7628a7037c3cfa22a8eca17f34ddffd9d3a856cc", "url": "https://github.com/OpenNMS/opennms/commit/7628a7037c3cfa22a8eca17f34ddffd9d3a856cc", "message": "NMS-12423: Initial implementation of CIDR expression support", "committedDate": "2020-02-17T12:33:54Z", "type": "commit"}, {"oid": "c02a477c0137e7c16729d56e71302ca684c62510", "url": "https://github.com/OpenNMS/opennms/commit/c02a477c0137e7c16729d56e71302ca684c62510", "message": "NMS-12423: Include CIDR expression in placeholder", "committedDate": "2020-02-17T12:33:54Z", "type": "commit"}, {"oid": "56f1f229301accded056e9a3ecd5d0f97f48a283", "url": "https://github.com/OpenNMS/opennms/commit/56f1f229301accded056e9a3ecd5d0f97f48a283", "message": "NMS-12423: Include CIDR expression in engine test", "committedDate": "2020-02-17T12:33:54Z", "type": "commit"}, {"oid": "f85e94d0aa59196baee90ea9f599b1222a8fe366", "url": "https://github.com/OpenNMS/opennms/commit/f85e94d0aa59196baee90ea9f599b1222a8fe366", "message": "NMS-12423: Fix failing test / test corner cases", "committedDate": "2020-02-17T12:33:54Z", "type": "commit"}, {"oid": "56557dbd21f8e61f21fa869c576da39bd2920e23", "url": "https://github.com/OpenNMS/opennms/commit/56557dbd21f8e61f21fa869c576da39bd2920e23", "message": "NMS-12423: Add cidr support for whats new", "committedDate": "2020-02-17T12:33:54Z", "type": "commit"}, {"oid": "5d62b9ce297114897efe828c5a6d344dd64d6ca9", "url": "https://github.com/OpenNMS/opennms/commit/5d62b9ce297114897efe828c5a6d344dd64d6ca9", "message": "NMS-12423: Add cidr v6 tests and fix cidr v6 expression parsing", "committedDate": "2020-02-17T12:33:55Z", "type": "commit"}, {"oid": "5d62b9ce297114897efe828c5a6d344dd64d6ca9", "url": "https://github.com/OpenNMS/opennms/commit/5d62b9ce297114897efe828c5a6d344dd64d6ca9", "message": "NMS-12423: Add cidr v6 tests and fix cidr v6 expression parsing", "committedDate": "2020-02-17T12:33:55Z", "type": "forcePushed"}, {"oid": "ddf426d7c84d1dd37346fa32c345cc245bef9f54", "url": "https://github.com/OpenNMS/opennms/commit/ddf426d7c84d1dd37346fa32c345cc245bef9f54", "message": "NMS-12423: Remove unused dependency", "committedDate": "2020-02-17T12:35:40Z", "type": "commit"}, {"oid": "afd45f12b7a293b47d993d983559abdf22273eec", "url": "https://github.com/OpenNMS/opennms/commit/afd45f12b7a293b47d993d983559abdf22273eec", "message": "NMS-12423: Fix compilation issue and validate properly", "committedDate": "2020-02-19T12:07:44Z", "type": "commit"}, {"oid": "e02ea7563d0fb02de4fb7d8bf1a521db5e6af31b", "url": "https://github.com/OpenNMS/opennms/commit/e02ea7563d0fb02de4fb7d8bf1a521db5e6af31b", "message": "NMS-12423: Add more tests", "committedDate": "2020-02-19T12:10:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI1NzAyMQ==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381257021", "bodyText": "The examples should be v6 address or the class name is misleading", "author": "fooker", "createdAt": "2020-02-19T12:21:53Z", "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "diffHunk": "@@ -67,26 +71,149 @@ private void parse(final StringValue input) {\n                 }\n                 // Ensure each range is an ip address\n                 for (StringValue rangedValue : rangedValues) {\n-                    verifyIpAddress(rangedValue);\n+                    if (rangedValue.contains(\"/\")) {\n+                        throw new IllegalArgumentException(\"Ranged value may not contain a CIDR expression\");\n+                    }\n                 }\n-                // Verify the range itself\n-                final IPAddressRange range = new IPAddressRange(rangedValues.get(0).getValue(), rangedValues.get(1).getValue());\n-                ranges.add(range);\n+                ranges.add(new IpAddressRange(rangedValues.get(0), rangedValues.get(1)));\n             } else {\n-                verifyIpAddress(eachValue);\n-                ranges.add(new IPAddressRange(eachValue.getValue(), eachValue.getValue()));\n+                ranges.add(new IpAddressRange(eachValue));\n             }\n         }\n     }\n \n     public boolean isInRange(final String address) {\n-        return ranges.stream().anyMatch(r -> r.contains(address));\n+        return ranges.stream().anyMatch(r -> r.isInRange(address));\n     }\n \n-    private static void verifyIpAddress(final StringValue stringValue) {\n-        Objects.requireNonNull(stringValue);\n-        if (!InetAddresses.isInetAddress(stringValue.getValue())) {\n-            throw new IllegalArgumentException(\"Provided ip address '\" + stringValue.getValue() + \"' is invalid\");\n+    private static class IpAddressRange {\n+\n+        private final IpAddressMatcher matcher;\n+\n+        private IpAddressRange(final StringValue from, final StringValue to) {\n+            this.matcher = new IpAddressRangeMatcher(from.getValue(), to.getValue());\n+        }\n+\n+        private IpAddressRange(final StringValue eachValue) {\n+            if (eachValue.contains(\"/\")) {\n+                this.matcher = new IpV6CidrExpressionMatcher(eachValue.getValue());\n+            } else {\n+                this.matcher = new IpAddressRangeMatcher(eachValue.getValue());\n+            }\n+        }\n+\n+        public boolean isInRange(String input) {\n+            return matcher.matches(input);\n+        }\n+    }\n+\n+    private interface IpAddressMatcher {\n+        boolean matches(String address);\n+    }\n+\n+    private static class IpAddressRangeMatcher implements IpAddressMatcher {\n+\n+        private final IPAddressRange range;\n+\n+        private IpAddressRangeMatcher(final String from, final String to) {\n+            verifyIpAddress(from);\n+            verifyIpAddress(to);\n+            this.range = new IPAddressRange(from, to);\n+        }\n+\n+        public IpAddressRangeMatcher(String value) {\n+            verifyIpAddress(value);\n+            this.range = new IPAddressRange(value);\n+        }\n+\n+        @Override\n+        public boolean matches(String address) {\n+            return range.contains(address);\n+        }\n+\n+        private static void verifyIpAddress(final String value) {\n+            Objects.requireNonNull(value);\n+            if (!InetAddresses.isInetAddress(value)) {\n+                throw new IllegalArgumentException(\"Provided ip address '\" + value + \"' is invalid\");\n+            }\n+        }\n+    }\n+\n+    // Inspired by spring-security-web's IpAddressMatcher\n+    public final static class IpV6CidrExpressionMatcher implements IpAddressMatcher {\n+\n+        private final int nMaskBits;\n+        private final InetAddress requiredAddress;\n+\n+        /**\n+         * Takes a specific IP address or a range specified using the\n+         * IP/Netmask (e.g. 192.168.1.0/24 or 202.24.0.0/14).", "originalCommit": "e02ea7563d0fb02de4fb7d8bf1a521db5e6af31b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI3NDYxNw==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381274617", "bodyText": "Yes, that is true.", "author": "mvrueden", "createdAt": "2020-02-19T13:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI1NzAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2MDE0MQ==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381260141", "bodyText": "The calculation of the mask can be moved to the constructor, right?", "author": "fooker", "createdAt": "2020-02-19T12:29:04Z", "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "diffHunk": "@@ -67,26 +71,149 @@ private void parse(final StringValue input) {\n                 }\n                 // Ensure each range is an ip address\n                 for (StringValue rangedValue : rangedValues) {\n-                    verifyIpAddress(rangedValue);\n+                    if (rangedValue.contains(\"/\")) {\n+                        throw new IllegalArgumentException(\"Ranged value may not contain a CIDR expression\");\n+                    }\n                 }\n-                // Verify the range itself\n-                final IPAddressRange range = new IPAddressRange(rangedValues.get(0).getValue(), rangedValues.get(1).getValue());\n-                ranges.add(range);\n+                ranges.add(new IpAddressRange(rangedValues.get(0), rangedValues.get(1)));\n             } else {\n-                verifyIpAddress(eachValue);\n-                ranges.add(new IPAddressRange(eachValue.getValue(), eachValue.getValue()));\n+                ranges.add(new IpAddressRange(eachValue));\n             }\n         }\n     }\n \n     public boolean isInRange(final String address) {\n-        return ranges.stream().anyMatch(r -> r.contains(address));\n+        return ranges.stream().anyMatch(r -> r.isInRange(address));\n     }\n \n-    private static void verifyIpAddress(final StringValue stringValue) {\n-        Objects.requireNonNull(stringValue);\n-        if (!InetAddresses.isInetAddress(stringValue.getValue())) {\n-            throw new IllegalArgumentException(\"Provided ip address '\" + stringValue.getValue() + \"' is invalid\");\n+    private static class IpAddressRange {\n+\n+        private final IpAddressMatcher matcher;\n+\n+        private IpAddressRange(final StringValue from, final StringValue to) {\n+            this.matcher = new IpAddressRangeMatcher(from.getValue(), to.getValue());\n+        }\n+\n+        private IpAddressRange(final StringValue eachValue) {\n+            if (eachValue.contains(\"/\")) {\n+                this.matcher = new IpV6CidrExpressionMatcher(eachValue.getValue());\n+            } else {\n+                this.matcher = new IpAddressRangeMatcher(eachValue.getValue());\n+            }\n+        }\n+\n+        public boolean isInRange(String input) {\n+            return matcher.matches(input);\n+        }\n+    }\n+\n+    private interface IpAddressMatcher {\n+        boolean matches(String address);\n+    }\n+\n+    private static class IpAddressRangeMatcher implements IpAddressMatcher {\n+\n+        private final IPAddressRange range;\n+\n+        private IpAddressRangeMatcher(final String from, final String to) {\n+            verifyIpAddress(from);\n+            verifyIpAddress(to);\n+            this.range = new IPAddressRange(from, to);\n+        }\n+\n+        public IpAddressRangeMatcher(String value) {\n+            verifyIpAddress(value);\n+            this.range = new IPAddressRange(value);\n+        }\n+\n+        @Override\n+        public boolean matches(String address) {\n+            return range.contains(address);\n+        }\n+\n+        private static void verifyIpAddress(final String value) {\n+            Objects.requireNonNull(value);\n+            if (!InetAddresses.isInetAddress(value)) {\n+                throw new IllegalArgumentException(\"Provided ip address '\" + value + \"' is invalid\");\n+            }\n+        }\n+    }\n+\n+    // Inspired by spring-security-web's IpAddressMatcher\n+    public final static class IpV6CidrExpressionMatcher implements IpAddressMatcher {\n+\n+        private final int nMaskBits;\n+        private final InetAddress requiredAddress;\n+\n+        /**\n+         * Takes a specific IP address or a range specified using the\n+         * IP/Netmask (e.g. 192.168.1.0/24 or 202.24.0.0/14).\n+         *\n+         * @param ipAddress the address or range of addresses from which the request must come.\n+         */\n+        public IpV6CidrExpressionMatcher(String ipAddress) {\n+            if (ipAddress.indexOf('/') > 0) {\n+                String[] addressAndMask = StringUtils.split(ipAddress, \"/\");\n+                ipAddress = addressAndMask[0];\n+                nMaskBits = Integer.parseInt(addressAndMask[1]);\n+            } else {\n+                nMaskBits = -1;\n+            }\n+            requiredAddress = parseAddress(ipAddress);\n+            boolean isIpV6 = requiredAddress instanceof Inet6Address;\n+            rangeCheck(nMaskBits, 0, isIpV6 ? 128 : 32);\n+        }\n+\n+        @Override\n+        public boolean matches(String address) {\n+            InetAddress remoteAddress = parseAddress(address);\n+\n+            if (!requiredAddress.getClass().equals(remoteAddress.getClass())) {\n+                return false;\n+            }\n+\n+            if (nMaskBits < 0) {\n+                return remoteAddress.equals(requiredAddress);\n+            }\n+\n+            byte[] remAddr = remoteAddress.getAddress();\n+            byte[] reqAddr = requiredAddress.getAddress();\n+\n+            int oddBits = nMaskBits % 8;\n+            int nMaskBytes = nMaskBits/8 + (oddBits == 0 ? 0 : 1);\n+            byte[] mask = new byte[nMaskBytes];", "originalCommit": "e02ea7563d0fb02de4fb7d8bf1a521db5e6af31b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5f73aa29b0bbdbaed84ed82f189b122decddd50f", "url": "https://github.com/OpenNMS/opennms/commit/5f73aa29b0bbdbaed84ed82f189b122decddd50f", "message": "NMS-12423: Remove comment", "committedDate": "2020-02-19T13:23:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2NTA3OA==", "url": "https://github.com/OpenNMS/opennms/pull/2886#discussion_r381565078", "bodyText": "Is this class even needed? As IpAddressMatcher already dispatches, it can be included directly in the parent class. And it would solve the IpAddressRange vs IPAddressRange conflict.", "author": "fooker", "createdAt": "2020-02-19T21:49:20Z", "path": "features/flows/classification/engine/impl/src/main/java/org/opennms/netmgt/flows/classification/internal/value/IpValue.java", "diffHunk": "@@ -67,26 +71,143 @@ private void parse(final StringValue input) {\n                 }\n                 // Ensure each range is an ip address\n                 for (StringValue rangedValue : rangedValues) {\n-                    verifyIpAddress(rangedValue);\n+                    if (rangedValue.contains(\"/\")) {\n+                        throw new IllegalArgumentException(\"Ranged value may not contain a CIDR expression\");\n+                    }\n                 }\n-                // Verify the range itself\n-                final IPAddressRange range = new IPAddressRange(rangedValues.get(0).getValue(), rangedValues.get(1).getValue());\n-                ranges.add(range);\n+                ranges.add(new IpAddressRange(rangedValues.get(0), rangedValues.get(1)));\n             } else {\n-                verifyIpAddress(eachValue);\n-                ranges.add(new IPAddressRange(eachValue.getValue(), eachValue.getValue()));\n+                ranges.add(new IpAddressRange(eachValue));\n             }\n         }\n     }\n \n     public boolean isInRange(final String address) {\n-        return ranges.stream().anyMatch(r -> r.contains(address));\n+        return ranges.stream().anyMatch(r -> r.isInRange(address));\n     }\n \n-    private static void verifyIpAddress(final StringValue stringValue) {\n-        Objects.requireNonNull(stringValue);\n-        if (!InetAddresses.isInetAddress(stringValue.getValue())) {\n-            throw new IllegalArgumentException(\"Provided ip address '\" + stringValue.getValue() + \"' is invalid\");\n+    private static class IpAddressRange {", "originalCommit": "5f73aa29b0bbdbaed84ed82f189b122decddd50f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c3b3f9e2056fc58d578732ffb2209b38bc59b27b", "url": "https://github.com/OpenNMS/opennms/commit/c3b3f9e2056fc58d578732ffb2209b38bc59b27b", "message": "NMS-12423: Build range from CIDR", "committedDate": "2020-02-28T15:31:41Z", "type": "commit"}]}