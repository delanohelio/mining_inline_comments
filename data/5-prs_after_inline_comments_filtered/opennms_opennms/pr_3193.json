{"pr_number": 3193, "pr_title": "NMS-12949: Persist BMP messages", "pr_createdAt": "2020-10-21T13:49:36Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/3193", "timeline": [{"oid": "b02c0a54ef42b04f6f41a830b55f2f92debc3689", "url": "https://github.com/OpenNMS/opennms/commit/b02c0a54ef42b04f6f41a830b55f2f92debc3689", "message": "NMS-12949: Persist BMP messages", "committedDate": "2020-10-21T21:41:13Z", "type": "commit"}, {"oid": "b02c0a54ef42b04f6f41a830b55f2f92debc3689", "url": "https://github.com/OpenNMS/opennms/commit/b02c0a54ef42b04f6f41a830b55f2f92debc3689", "message": "NMS-12949: Persist BMP messages", "committedDate": "2020-10-21T21:41:13Z", "type": "forcePushed"}, {"oid": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "url": "https://github.com/OpenNMS/opennms/commit/b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "message": "NMS-12952: Persist stats for BMP", "committedDate": "2020-11-18T14:51:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2MDMwMA==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526760300", "bodyText": "I think this cast can be avoided by propagating the type up to the constructor of the factory.", "author": "fooker", "createdAt": "2020-11-19T10:40:48Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/BmpPersistingAdapter.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter;\n+\n+import java.util.stream.Stream;\n+\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.BmpIntegrationAdapter;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.BmpMessageHandler;\n+import org.opennms.netmgt.telemetry.protocols.collection.CollectionSetWithAgent;\n+\n+import com.codahale.metrics.MetricRegistry;\n+\n+public class BmpPersistingAdapter extends BmpIntegrationAdapter {\n+\n+    private final BmpMessageHandler bmpMessagePersister;\n+\n+    public BmpPersistingAdapter(AdapterDefinition adapterConfig, MetricRegistry metricRegistry, BmpMessageHandler messageHandler) {\n+        super(adapterConfig, metricRegistry, messageHandler);\n+        this.bmpMessagePersister = messageHandler;\n+    }\n+\n+    @Override\n+    public Stream<CollectionSetWithAgent> handleCollectionMessage(TelemetryMessageLogEntry messageLogEntry, TelemetryMessageLog messageLog) {\n+        super.handleCollectionMessage(messageLogEntry, messageLog);\n+        BmpPersistenceMessageHandler bmpMessagePersister = (BmpPersistenceMessageHandler) this.bmpMessagePersister;", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2MTA1NA==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526761054", "bodyText": "Adding the location to the context makes things more clean.", "author": "fooker", "createdAt": "2020-11-19T10:41:57Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -664,60 +665,61 @@ private void handleRouteMonitoringMessage(final Transport.Message message,\n \n         // Forward the messages to the handler\n         if (baseAttr != null) {\n-            this.messageHandler.handle(new Message(context.collectorHashId, Type.BASE_ATTRIBUTE, ImmutableList.of(baseAttr)));\n+            this.messageHandler.handle(new Message(context.collectorHashId, Type.BASE_ATTRIBUTE, ImmutableList.of(baseAttr)), location);\n         }\n \n-        this.messageHandler.handle(new Message(context.collectorHashId, Type.UNICAST_PREFIX, unicastPrefixRecords));\n+        this.messageHandler.handle(new Message(context.collectorHashId, Type.UNICAST_PREFIX, unicastPrefixRecords), location);\n     }\n \n     @Override\n-    public void handleMessage(final TelemetryMessageLogEntry messageLogEntry,\n-                              final TelemetryMessageLog messageLog) {\n+    public Stream<CollectionSetWithAgent> handleCollectionMessage(TelemetryMessageLogEntry messageLogEntry, TelemetryMessageLog messageLog) {\n         LOG.trace(\"Parsing packet: {}\", messageLogEntry);\n         final Transport.Message message;\n         try {\n             message = Transport.Message.parseFrom(messageLogEntry.getByteArray());\n         } catch (final InvalidProtocolBufferException e) {\n             LOG.error(\"Invalid message\", e);\n-            return;\n+            return Stream.empty();\n         }\n \n         final String collectorHashId = Record.hash(messageLog.getSystemId());\n-        final String routerHashId = Record.hash(messageLog.getSourceAddress(), Integer.toString(messageLog.getSourcePort()), collectorHashId);\n+        final String routerHashId = Record.hash(messageLog.getSourceAddress(), collectorHashId);\n         final Context context = new Context(messageLog.getSystemId(),\n-                                            collectorHashId,\n-                                            routerHashId,\n-                                            Instant.ofEpochMilli(messageLogEntry.getTimestamp()),\n-                                            InetAddressUtils.addr(messageLog.getSourceAddress()),\n-                                            messageLog.getSourcePort());\n+                collectorHashId,\n+                routerHashId,\n+                Instant.ofEpochMilli(messageLogEntry.getTimestamp()),\n+                InetAddressUtils.addr(messageLog.getSourceAddress()),\n+                messageLog.getSourcePort());\n \n         switch(message.getPacketCase()) {\n             case HEARTBEAT:\n-                handleHeartbeatMessage(message, message.getHeartbeat(), context);\n+                handleHeartbeatMessage(message, message.getHeartbeat(), context, messageLog.getLocation());", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2OTY3MQ==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526769671", "bodyText": "Do we need toString, equals and hashCode?", "author": "fooker", "createdAt": "2020-11-19T10:55:18Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpBaseAttribute.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+\n+@Entity\n+@Table(name = \"bmp_base_attributes\")\n+public class BmpBaseAttribute implements Serializable {\n+\n+\n+    private static final long serialVersionUID = 6992640443613316262L;\n+\n+    @Id\n+    @GeneratedValue(strategy= GenerationType.SEQUENCE, generator = \"bmpBaseAttrsSequence\")\n+    @SequenceGenerator(name = \"bmpBaseAttrsSequence\", sequenceName = \"baseattrsnxtid\")\n+    @Column(name = \"id\", nullable = false)\n+    private Long id;\n+\n+    @Column(name = \"hash_id\", nullable = false)\n+    private String hashId;\n+\n+    @Column(name = \"peer_hash_id\", nullable = false)\n+    private String peerHashId;\n+\n+    @Column(name = \"origin\", nullable = false)\n+    private String origin;\n+\n+    @Column(name = \"as_path\", nullable = false)\n+    private String asPath;\n+\n+    @Column(name = \"as_path_count\", nullable = false)\n+    private Integer asPathCount;\n+\n+    @Column(name = \"origin_as\")\n+    private Long originAs;\n+\n+    @Column(name = \"next_hop\")\n+    private String nextHop;\n+\n+    @Column(name = \"med\")\n+    private Long med;\n+\n+    @Column(name = \"local_pref\")\n+    private Long localPref;\n+\n+    @Column(name = \"aggregator\")\n+    private String aggregator;\n+\n+    @Column(name = \"community_list\")\n+    private String communityList;\n+\n+    @Column(name = \"ext_community_list\")\n+    private String extCommunityList;\n+\n+    @Column(name = \"large_community_list\")\n+    private String largeCommunityList;\n+\n+    @Column(name = \"cluster_list\")\n+    private String clusterList;\n+\n+    @Column(name = \"is_atomic_agg\")\n+    private boolean isAtomicAgg;\n+\n+    @Column(name = \"is_nexthop_ipv4\")\n+    private boolean isNextHopIpv4;\n+\n+    @Column(name = \"last_updated\")\n+    @Temporal(TemporalType.TIMESTAMP)\n+    private Date timestamp;\n+\n+    @Column(name = \"originator_id\")\n+    private String originatorId;\n+\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getHashId() {\n+        return hashId;\n+    }\n+\n+    public void setHashId(String hashId) {\n+        this.hashId = hashId;\n+    }\n+\n+    public String getPeerHashId() {\n+        return peerHashId;\n+    }\n+\n+    public void setPeerHashId(String peerHashId) {\n+        this.peerHashId = peerHashId;\n+    }\n+\n+    public String getOrigin() {\n+        return origin;\n+    }\n+\n+    public void setOrigin(String origin) {\n+        this.origin = origin;\n+    }\n+\n+    public String getAsPath() {\n+        return asPath;\n+    }\n+\n+    public void setAsPath(String asPath) {\n+        this.asPath = asPath;\n+    }\n+\n+    public Integer getAsPathCount() {\n+        return asPathCount;\n+    }\n+\n+    public void setAsPathCount(Integer asPathCount) {\n+        this.asPathCount = asPathCount;\n+    }\n+\n+    public Long getOriginAs() {\n+        return originAs;\n+    }\n+\n+    public void setOriginAs(Long originAs) {\n+        this.originAs = originAs;\n+    }\n+\n+    public String getNextHop() {\n+        return nextHop;\n+    }\n+\n+    public void setNextHop(String nextHop) {\n+        this.nextHop = nextHop;\n+    }\n+\n+    public Long getMed() {\n+        return med;\n+    }\n+\n+    public void setMed(Long med) {\n+        this.med = med;\n+    }\n+\n+    public Long getLocalPref() {\n+        return localPref;\n+    }\n+\n+    public void setLocalPref(Long localPref) {\n+        this.localPref = localPref;\n+    }\n+\n+    public String getAggregator() {\n+        return aggregator;\n+    }\n+\n+    public void setAggregator(String aggregator) {\n+        this.aggregator = aggregator;\n+    }\n+\n+    public String getCommunityList() {\n+        return communityList;\n+    }\n+\n+    public void setCommunityList(String communityList) {\n+        this.communityList = communityList;\n+    }\n+\n+    public String getExtCommunityList() {\n+        return extCommunityList;\n+    }\n+\n+    public void setExtCommunityList(String extCommunityList) {\n+        this.extCommunityList = extCommunityList;\n+    }\n+\n+    public String getLargeCommunityList() {\n+        return largeCommunityList;\n+    }\n+\n+    public void setLargeCommunityList(String largeCommunityList) {\n+        this.largeCommunityList = largeCommunityList;\n+    }\n+\n+    public String getClusterList() {\n+        return clusterList;\n+    }\n+\n+    public void setClusterList(String clusterList) {\n+        this.clusterList = clusterList;\n+    }\n+\n+    public boolean isAtomicAgg() {\n+        return isAtomicAgg;\n+    }\n+\n+    public void setAtomicAgg(boolean atomicAgg) {\n+        isAtomicAgg = atomicAgg;\n+    }\n+\n+    public boolean isNextHopIpv4() {\n+        return isNextHopIpv4;\n+    }\n+\n+    public void setNextHopIpv4(boolean nextHopIpv4) {\n+        isNextHopIpv4 = nextHopIpv4;\n+    }\n+\n+    public Date getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(Date timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public String getOriginatorId() {\n+        return originatorId;\n+    }\n+\n+    public void setOriginatorId(String originatorId) {\n+        this.originatorId = originatorId;\n+    }\n+}", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2OTg3NA==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526769874", "bodyText": "Do we need equals and hashCode?", "author": "fooker", "createdAt": "2020-11-19T10:55:35Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpCollector.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.Transient;\n+\n+@Table(name = \"bmp_collectors\")\n+@Entity\n+public class BmpCollector implements Serializable {\n+\n+    private static final long serialVersionUID = 3094029180922290726L;\n+\n+    @Id\n+    @GeneratedValue(strategy= GenerationType.SEQUENCE, generator = \"bmpCollectorSequence\")\n+    @SequenceGenerator(name = \"bmpCollectorSequence\", sequenceName = \"bmpcollectornxtid\")\n+    @Column(name = \"id\", nullable = false)\n+    private Long id;\n+\n+    @Column(name = \"hash_id\", nullable = false)\n+    private String hashId;\n+\n+    @Column(name = \"state\")\n+    private boolean state;\n+\n+    @Column(name = \"admin_id\", nullable = false)\n+    private String adminId;\n+\n+    @Column(name = \"routers_count\", nullable = false)\n+    private Integer routersCount;\n+\n+    @Column(name = \"last_updated\", nullable = false)\n+    @Temporal(TemporalType.TIMESTAMP)\n+    private Date timestamp;\n+\n+    @Column(name = \"name\")\n+    private String name;\n+\n+    @Column(name = \"ip_address\")\n+    private String ipAddress;\n+\n+    @Column(name = \"routers\")\n+    private String routers;\n+\n+    @OneToMany(mappedBy=\"bmpCollector\")\n+    private Set<BmpRouter> bmpRouters = new LinkedHashSet<>();\n+\n+    @Transient\n+    private String action;\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getHashId() {\n+        return hashId;\n+    }\n+\n+    public void setHashId(String hashId) {\n+        this.hashId = hashId;\n+    }\n+\n+    public boolean isState() {\n+        return state;\n+    }\n+\n+    public void setState(boolean state) {\n+        this.state = state;\n+    }\n+\n+    public String getAdminId() {\n+        return adminId;\n+    }\n+\n+    public void setAdminId(String adminId) {\n+        this.adminId = adminId;\n+    }\n+\n+    public Integer getRoutersCount() {\n+        return routersCount;\n+    }\n+\n+    public void setRoutersCount(Integer routersCount) {\n+        this.routersCount = routersCount;\n+    }\n+\n+    public Date getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(Date timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getIpAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setIpAddress(String ipAddress) {\n+        this.ipAddress = ipAddress;\n+    }\n+\n+    public String getRouters() {\n+        return routers;\n+    }\n+\n+    public void setRouters(String routers) {\n+        this.routers = routers;\n+    }\n+\n+    public Set<BmpRouter> getBmpRouters() {\n+        return bmpRouters;\n+    }\n+\n+    public void setBmpRouters(Set<BmpRouter> bmpRouters) {\n+        this.bmpRouters = bmpRouters;\n+    }\n+\n+    public String getAction() {\n+        return action;\n+    }\n+\n+    public void setAction(String action) {\n+        this.action = action;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BmpCollector{\" +\n+                \"hashId=\" + hashId +\n+                \", state=\" + state +\n+                \", adminId='\" + adminId + '\\'' +\n+                \", routersCount=\" + routersCount +\n+                \", timestamp=\" + timestamp +\n+                \", name='\" + name + '\\'' +\n+                \", ipAddress='\" + ipAddress + '\\'' +\n+                '}';\n+    }\n+}", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MDIwNw==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526770207", "bodyText": "Do we need toString, equals and hashCode?", "author": "fooker", "createdAt": "2020-11-19T10:56:08Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpGlobalIpRib.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.UniqueConstraint;\n+\n+@Entity\n+@Table(name = \"bmp_global_ip_ribs\", uniqueConstraints={@UniqueConstraint(columnNames={\"prefix\", \"recv_origin_as\"})})\n+public class BmpGlobalIpRib implements Serializable {\n+\n+    private static final long serialVersionUID = 8855311705684588626L;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"bmpUnicastSequence\")\n+    @SequenceGenerator(name = \"bmpUnicastSequence\", sequenceName = \"bmpunicastnxtid\")\n+    @Column(name = \"id\", nullable = false)\n+    private Long id;\n+\n+    @Column(name = \"prefix\", nullable = false)\n+    private String prefix;\n+\n+    @Column(name = \"should_delete\", nullable = false)\n+    private boolean shouldDelete;\n+\n+    @Column(name = \"prefix_len\", nullable = false)\n+    private Integer prefixLen;\n+\n+    @Column(name = \"recv_origin_as\", nullable = false)\n+    private Long recvOriginAs;\n+\n+    @Column(name = \"rpki_origin_as\")\n+    private Long rpkiOriginAs;\n+\n+    @Column(name = \"irr_origin_as\")\n+    private Long irrOriginAs;\n+\n+    @Column(name = \"irr_source\")\n+    private String irrSource;\n+\n+    @Column(name = \"last_updated\", nullable = false)\n+    @Temporal(TemporalType.TIMESTAMP)\n+    private Date timeStamp;\n+\n+    @Column(name = \"num_peers\")\n+    private Integer numPeers;\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    public void setPrefix(String prefix) {\n+        this.prefix = prefix;\n+    }\n+\n+    public boolean isShouldDelete() {\n+        return shouldDelete;\n+    }\n+\n+    public void setShouldDelete(boolean shouldDelete) {\n+        this.shouldDelete = shouldDelete;\n+    }\n+\n+    public Integer getPrefixLen() {\n+        return prefixLen;\n+    }\n+\n+    public void setPrefixLen(Integer prefixLen) {\n+        this.prefixLen = prefixLen;\n+    }\n+\n+    public Long getRecvOriginAs() {\n+        return recvOriginAs;\n+    }\n+\n+    public void setRecvOriginAs(Long recvOriginAs) {\n+        this.recvOriginAs = recvOriginAs;\n+    }\n+\n+    public Long getRpkiOriginAs() {\n+        return rpkiOriginAs;\n+    }\n+\n+    public void setRpkiOriginAs(Long rpkiOriginAs) {\n+        this.rpkiOriginAs = rpkiOriginAs;\n+    }\n+\n+    public Long getIrrOriginAs() {\n+        return irrOriginAs;\n+    }\n+\n+    public void setIrrOriginAs(Long irrOriginAs) {\n+        this.irrOriginAs = irrOriginAs;\n+    }\n+\n+    public String getIrrSource() {\n+        return irrSource;\n+    }\n+\n+    public void setIrrSource(String irrSource) {\n+        this.irrSource = irrSource;\n+    }\n+\n+    public Date getTimeStamp() {\n+        return timeStamp;\n+    }\n+\n+    public void setTimeStamp(Date timeStamp) {\n+        this.timeStamp = timeStamp;\n+    }\n+\n+    public Integer getNumPeers() {\n+        return numPeers;\n+    }\n+\n+    public void setNumPeers(Integer numPeers) {\n+        this.numPeers = numPeers;\n+    }\n+}", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MDQ0OQ==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526770449", "bodyText": "Do we need toString, equals and hashCode?", "author": "fooker", "createdAt": "2020-11-19T10:56:30Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpPeer.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+\n+@Entity\n+@Table(name = \"bmp_peers\")\n+public class BmpPeer implements Serializable {\n+\n+    private static final long serialVersionUID = 910756667828959198L;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"bmpPeerSequence\")\n+    @SequenceGenerator(name = \"bmpPeerSequence\", sequenceName = \"bmppeernxtid\")\n+    @Column(name = \"id\", nullable = false)\n+    private Long id;\n+\n+    @Column(name = \"hash_id\", nullable = false)\n+    private String hashId;\n+\n+    @ManyToOne(optional = false, fetch = FetchType.LAZY)\n+    @JoinColumn(name = \"router_hash_id\", referencedColumnName = \"hash_id\", nullable = false)\n+    private BmpRouter bmpRouter;\n+\n+    @Column(name = \"peer_rd\", nullable = false)\n+    private String peerRd;\n+\n+    @Column(name = \"is_ipv4\", nullable = false)\n+    private boolean isIpv4;\n+\n+    @Column(name = \"peer_addr\", nullable = false)\n+    private String peerAddr;\n+\n+    @Column(name = \"name\")\n+    private String name;\n+\n+    @Column(name = \"peer_bgp_id\")\n+    private String peerBgpId;\n+\n+    @Column(name = \"state\", nullable = false)\n+    private boolean state;\n+\n+    @Column(name = \"is_l3vpn_peer\", nullable = false)\n+    private boolean isL3VPNPeer;\n+\n+    @Column(name = \"last_updated\", nullable = false)\n+    @Temporal(TemporalType.TIMESTAMP)\n+    private Date timestamp;\n+\n+    @Column(name = \"is_pre_policy\", nullable = false)\n+    private boolean isPrePolicy;\n+\n+    @Column(name = \"geo_ip_start\")\n+    private String geoIpStart;\n+\n+    @Column(name = \"local_ip\")\n+    private String localIp;\n+\n+    @Column(name = \"local_bgp_id\")\n+    private String localBgpId;\n+\n+    @Column(name = \"local_port\")\n+    private Integer localPort;\n+\n+    @Column(name = \"local_hold_time\")\n+    private Long localHoldTime;\n+\n+    @Column(name = \"local_asn\")\n+    private Long localAsn;\n+\n+    @Column(name = \"remote_port\")\n+    private Integer remotePort;\n+\n+    @Column(name = \"remote_hold_time\")\n+    private Long remoteHoldTime;\n+\n+    @Column(name = \"sent_capabilities\")\n+    private String sentCapabilities;\n+\n+    @Column(name = \"recv_capabilities\")\n+    private String receivedCapabilities;\n+\n+    @Column(name = \"bmp_reason\")\n+    private Integer bmpReason;\n+\n+    @Column(name = \"bgp_err_code\")\n+    private Integer bgpErrCode;\n+\n+    @Column(name = \"error_text\")\n+    private String errorText;\n+\n+    @Column(name = \"is_loc_rib\", nullable = false)\n+    private boolean isLocRib;\n+\n+    @Column(name = \"is_loc_rib_filtered\", nullable = false)\n+    private boolean isLocRibFiltered;\n+\n+    @Column(name = \"table_name\")\n+    private String tableName;\n+\n+    @OneToMany(mappedBy=\"bmpPeer\", cascade = CascadeType.ALL, orphanRemoval=true)\n+    private Set<BmpUnicastPrefix> bmpUnicastPrefixes = new LinkedHashSet<>();\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getHashId() {\n+        return hashId;\n+    }\n+\n+    public void setHashId(String hashId) {\n+        this.hashId = hashId;\n+    }\n+\n+    public BmpRouter getBmpRouter() {\n+        return bmpRouter;\n+    }\n+\n+    public void setBmpRouter(BmpRouter bmpRouter) {\n+        this.bmpRouter = bmpRouter;\n+    }\n+\n+    public String getPeerRd() {\n+        return peerRd;\n+    }\n+\n+    public void setPeerRd(String peerRd) {\n+        this.peerRd = peerRd;\n+    }\n+\n+    public boolean isIpv4() {\n+        return isIpv4;\n+    }\n+\n+    public void setIpv4(boolean ipv4) {\n+        isIpv4 = ipv4;\n+    }\n+\n+    public String getPeerAddr() {\n+        return peerAddr;\n+    }\n+\n+    public void setPeerAddr(String peerAddr) {\n+        this.peerAddr = peerAddr;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getPeerBgpId() {\n+        return peerBgpId;\n+    }\n+\n+    public void setPeerBgpId(String peerBgpId) {\n+        this.peerBgpId = peerBgpId;\n+    }\n+\n+    public boolean isState() {\n+        return state;\n+    }\n+\n+    public void setState(boolean state) {\n+        this.state = state;\n+    }\n+\n+    public boolean isL3VPNPeer() {\n+        return isL3VPNPeer;\n+    }\n+\n+    public void setL3VPNPeer(boolean l3VPNPeer) {\n+        isL3VPNPeer = l3VPNPeer;\n+    }\n+\n+    public Date getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(Date timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public boolean isPrePolicy() {\n+        return isPrePolicy;\n+    }\n+\n+    public void setPrePolicy(boolean prePolicy) {\n+        isPrePolicy = prePolicy;\n+    }\n+\n+    public String getGeoIpStart() {\n+        return geoIpStart;\n+    }\n+\n+    public void setGeoIpStart(String geoIpStart) {\n+        this.geoIpStart = geoIpStart;\n+    }\n+\n+    public String getLocalIp() {\n+        return localIp;\n+    }\n+\n+    public void setLocalIp(String localIp) {\n+        this.localIp = localIp;\n+    }\n+\n+    public String getLocalBgpId() {\n+        return localBgpId;\n+    }\n+\n+    public void setLocalBgpId(String localBgpId) {\n+        this.localBgpId = localBgpId;\n+    }\n+\n+    public Integer getLocalPort() {\n+        return localPort;\n+    }\n+\n+    public void setLocalPort(Integer localPort) {\n+        this.localPort = localPort;\n+    }\n+\n+    public Long getLocalHoldTime() {\n+        return localHoldTime;\n+    }\n+\n+    public void setLocalHoldTime(Long localHoldTime) {\n+        this.localHoldTime = localHoldTime;\n+    }\n+\n+    public Long getLocalAsn() {\n+        return localAsn;\n+    }\n+\n+    public void setLocalAsn(Long localAsn) {\n+        this.localAsn = localAsn;\n+    }\n+\n+    public Integer getRemotePort() {\n+        return remotePort;\n+    }\n+\n+    public void setRemotePort(Integer remotePort) {\n+        this.remotePort = remotePort;\n+    }\n+\n+    public Long getRemoteHoldTime() {\n+        return remoteHoldTime;\n+    }\n+\n+    public void setRemoteHoldTime(Long remoteHoldTime) {\n+        this.remoteHoldTime = remoteHoldTime;\n+    }\n+\n+    public String getSentCapabilities() {\n+        return sentCapabilities;\n+    }\n+\n+    public void setSentCapabilities(String sentCapabilities) {\n+        this.sentCapabilities = sentCapabilities;\n+    }\n+\n+    public String getReceivedCapabilities() {\n+        return receivedCapabilities;\n+    }\n+\n+    public void setReceivedCapabilities(String receivedCapabilities) {\n+        this.receivedCapabilities = receivedCapabilities;\n+    }\n+\n+    public Integer getBmpReason() {\n+        return bmpReason;\n+    }\n+\n+    public void setBmpReason(Integer bmpReason) {\n+        this.bmpReason = bmpReason;\n+    }\n+\n+    public Integer getBgpErrCode() {\n+        return bgpErrCode;\n+    }\n+\n+    public void setBgpErrCode(Integer bgpErrCode) {\n+        this.bgpErrCode = bgpErrCode;\n+    }\n+\n+    public String getErrorText() {\n+        return errorText;\n+    }\n+\n+    public void setErrorText(String errorText) {\n+        this.errorText = errorText;\n+    }\n+\n+    public boolean isLocRib() {\n+        return isLocRib;\n+    }\n+\n+    public void setLocRib(boolean locRib) {\n+        isLocRib = locRib;\n+    }\n+\n+    public boolean isLocRibFiltered() {\n+        return isLocRibFiltered;\n+    }\n+\n+    public void setLocRibFiltered(boolean locRibFiltered) {\n+        isLocRibFiltered = locRibFiltered;\n+    }\n+\n+    public String getTableName() {\n+        return tableName;\n+    }\n+\n+    public void setTableName(String tableName) {\n+        this.tableName = tableName;\n+    }\n+\n+    public Set<BmpUnicastPrefix> getBmpUnicastPrefixes() {\n+        return bmpUnicastPrefixes;\n+    }\n+\n+    public void setBmpUnicastPrefixes(Set<BmpUnicastPrefix> bmpUnicastPrefixes) {\n+        this.bmpUnicastPrefixes.clear();\n+        this.bmpUnicastPrefixes.addAll(bmpUnicastPrefixes);\n+    }\n+}", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MDcyNA==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526770724", "bodyText": "Do we need equals and hashCode?", "author": "fooker", "createdAt": "2020-11-19T10:56:56Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpRouter.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.Transient;\n+\n+@Table(name = \"bmp_routers\")\n+@Entity\n+public class BmpRouter implements Serializable {\n+    private static final long serialVersionUID = -5250630896963730366L;\n+\n+    @Id\n+    @GeneratedValue(strategy= GenerationType.SEQUENCE, generator = \"bmpRouterSequence\")\n+    @SequenceGenerator(name = \"bmpRouterSequence\", sequenceName = \"bmprouternxtid\")\n+    @Column(name = \"id\", nullable = false)\n+    private Long id;\n+\n+    @Column(name = \"hash_id\", nullable = false)\n+    private String hashId;\n+\n+    @Column(name = \"name\", nullable = false)\n+    private String name;\n+\n+    @Column(name = \"ip_address\", nullable = false)\n+    private String ipAddress;\n+\n+    @Column(name = \"router_as\")\n+    private Integer routerAS;\n+\n+    @Column(name = \"last_updated\", nullable = false)\n+    @Temporal(TemporalType.TIMESTAMP)\n+    private Date timestamp;\n+\n+    @Column(name = \"description\")\n+    private String description;\n+\n+    @Column(name = \"state\")\n+    private boolean state;\n+\n+    @Column(name = \"is_passive\")\n+    private boolean isPassive;\n+\n+    @Column(name = \"term_reason_code\")\n+    private Integer termReasonCode;\n+\n+    @Column(name = \"term_reason_text\")\n+    private String termReasonText;\n+\n+    @Column(name = \"term_data\")\n+    private String termData;\n+\n+    @Column(name = \"init_data\")\n+    private String initData;\n+\n+    @Column(name = \"geo_ip_start\")\n+    private String geoIpStart;\n+\n+    @ManyToOne(optional = false, fetch = FetchType.LAZY)\n+    @JoinColumn(name = \"collector_hash_id\", referencedColumnName = \"hash_id\", nullable = false)\n+    private BmpCollector bmpCollector;\n+\n+    @Column(name = \"bgp_id\")\n+    private String bgpId;\n+\n+    @Column(name = \"connection_count\")\n+    private Integer connectionCount;\n+\n+    @OneToMany(mappedBy=\"bmpRouter\")\n+    private Set<BmpPeer> bmpPeers = new LinkedHashSet<>();\n+\n+    @Transient\n+    private String action;\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getHashId() {\n+        return hashId;\n+    }\n+\n+    public void setHashId(String hashId) {\n+        this.hashId = hashId;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getIpAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setIpAddress(String ipAddress) {\n+        this.ipAddress = ipAddress;\n+    }\n+\n+    public Integer getRouterAS() {\n+        return routerAS;\n+    }\n+\n+    public void setRouterAS(Integer routerAS) {\n+        this.routerAS = routerAS;\n+    }\n+\n+    public Date getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(Date timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(String description) {\n+        this.description = description;\n+    }\n+\n+    public boolean isState() {\n+        return state;\n+    }\n+\n+    public void setState(boolean state) {\n+        this.state = state;\n+    }\n+\n+    public boolean isPassive() {\n+        return isPassive;\n+    }\n+\n+    public void setPassive(boolean passive) {\n+        isPassive = passive;\n+    }\n+\n+    public Integer getTermReasonCode() {\n+        return termReasonCode;\n+    }\n+\n+    public void setTermReasonCode(Integer termReasonCode) {\n+        this.termReasonCode = termReasonCode;\n+    }\n+\n+    public String getTermReasonText() {\n+        return termReasonText;\n+    }\n+\n+    public void setTermReasonText(String termReasonText) {\n+        this.termReasonText = termReasonText;\n+    }\n+\n+    public String getTermData() {\n+        return termData;\n+    }\n+\n+    public void setTermData(String termData) {\n+        this.termData = termData;\n+    }\n+\n+    public String getInitData() {\n+        return initData;\n+    }\n+\n+    public void setInitData(String initData) {\n+        this.initData = initData;\n+    }\n+\n+    public String getGeoIpStart() {\n+        return geoIpStart;\n+    }\n+\n+    public void setGeoIpStart(String geoIpStart) {\n+        this.geoIpStart = geoIpStart;\n+    }\n+\n+    public BmpCollector getBmpCollector() {\n+        return bmpCollector;\n+    }\n+\n+    public void setBmpCollector(BmpCollector bmpCollector) {\n+        this.bmpCollector = bmpCollector;\n+    }\n+\n+    public String getBgpId() {\n+        return bgpId;\n+    }\n+\n+    public void setBgpId(String bgpId) {\n+        this.bgpId = bgpId;\n+    }\n+\n+    public Set<BmpPeer> getBmpPeers() {\n+        return bmpPeers;\n+    }\n+\n+    public void setBmpPeers(Set<BmpPeer> bmpPeers) {\n+        this.bmpPeers = bmpPeers;\n+    }\n+\n+    public String getAction() {\n+        return action;\n+    }\n+\n+    public void setAction(String action) {\n+        this.action = action;\n+    }\n+\n+    public Integer getConnectionCount() {\n+        if(connectionCount == null){\n+            return 0;\n+        }\n+        return connectionCount;\n+    }\n+\n+    public void setConnectionCount(Integer connectionCount) {\n+        if(connectionCount < 0) {\n+            connectionCount = 0;\n+        }\n+        this.connectionCount = connectionCount;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BmpRouter{\" +\n+                \"hashId=\" + hashId +\n+                \", name='\" + name + '\\'' +\n+                \", ipAddress='\" + ipAddress + '\\'' +\n+                \", routerAS=\" + routerAS +\n+                \", timestamp=\" + timestamp +\n+                \", description='\" + description + '\\'' +\n+                \", state=\" + state +\n+                \", isPassive=\" + isPassive +\n+                \", termReasonCode=\" + termReasonCode +\n+                \", termReasonText='\" + termReasonText + '\\'' +\n+                \", termData='\" + termData + '\\'' +\n+                \", initData='\" + initData + '\\'' +\n+                \", geoIpStart='\" + geoIpStart + '\\'' +\n+                \", bmpCollector='\" + bmpCollector + '\\'' +\n+                \", bgpId='\" + bgpId + '\\'' +\n+                '}';\n+    }\n+}", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MjAyOQ==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526772029", "bodyText": "Do we need toString, equals and hashCode?", "author": "fooker", "createdAt": "2020-11-19T10:58:57Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpStatReports.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+import javax.persistence.Column;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.SequenceGenerator;\n+\n+public class BmpStatReports implements Serializable {\n+\n+    private static final long serialVersionUID = 7692456270634611593L;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"bmpStatsReportsSequence\")\n+    @SequenceGenerator(name = \"bmpStatsReportsSequence\", sequenceName = \"bmpstatreportsnxtid\")\n+    @Column(name = \"id\", nullable = false)\n+    private Long id;\n+\n+    @Column(name = \"peer_hash_id\", nullable = false)\n+    private String peerHashId;\n+\n+    @Column(name = \"prefixes_rejected\")\n+    private Integer prefixesRejected;\n+\n+    @Column(name = \"known_dup_prefixes\")\n+    private Integer knownDupPrefixes;\n+\n+    @Column(name = \"known_dup_withdraws\")\n+    private Integer knownDupWithdraws;\n+\n+    @Column(name = \"updates_invalid_by_cluster_list\")\n+    private Integer updatesInvalidByClusterList;\n+\n+    @Column(name = \"updates_invalid_by_as_path_loop\")\n+    private Integer updatesInvalidByAsPathLoop;\n+\n+    @Column(name = \"updates_invalid_by_originator_id\")\n+    private Integer updatesInvalidByOriginatorId;\n+\n+    @Column(name = \"updates_invalid_by_as_confed_loop\")\n+    private Integer updatesInvalidByAsConfedLoop;\n+\n+    @Column(name = \"num_routes_adj_rib_in\")\n+    private Long numRoutesAdjRibIn;\n+\n+    @Column(name = \"num_routes_local_rib\")\n+    private Long numROutesLocalRib;\n+\n+    @Column(name = \"timestamp\")\n+    private Date timestamp;\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getPeerHashId() {\n+        return peerHashId;\n+    }\n+\n+    public void setPeerHashId(String peerHashId) {\n+        this.peerHashId = peerHashId;\n+    }\n+\n+    public Integer getPrefixesRejected() {\n+        return prefixesRejected;\n+    }\n+\n+    public void setPrefixesRejected(Integer prefixesRejected) {\n+        this.prefixesRejected = prefixesRejected;\n+    }\n+\n+    public Integer getKnownDupPrefixes() {\n+        return knownDupPrefixes;\n+    }\n+\n+    public void setKnownDupPrefixes(Integer knownDupPrefixes) {\n+        this.knownDupPrefixes = knownDupPrefixes;\n+    }\n+\n+    public Integer getKnownDupWithdraws() {\n+        return knownDupWithdraws;\n+    }\n+\n+    public void setKnownDupWithdraws(Integer knownDupWithdraws) {\n+        this.knownDupWithdraws = knownDupWithdraws;\n+    }\n+\n+    public Integer getUpdatesInvalidByClusterList() {\n+        return updatesInvalidByClusterList;\n+    }\n+\n+    public void setUpdatesInvalidByClusterList(Integer updatesInvalidByClusterList) {\n+        this.updatesInvalidByClusterList = updatesInvalidByClusterList;\n+    }\n+\n+    public Integer getUpdatesInvalidByAsPathLoop() {\n+        return updatesInvalidByAsPathLoop;\n+    }\n+\n+    public void setUpdatesInvalidByAsPathLoop(Integer updatesInvalidByAsPathLoop) {\n+        this.updatesInvalidByAsPathLoop = updatesInvalidByAsPathLoop;\n+    }\n+\n+    public Integer getUpdatesInvalidByOriginatorId() {\n+        return updatesInvalidByOriginatorId;\n+    }\n+\n+    public void setUpdatesInvalidByOriginatorId(Integer updatesInvalidByOriginatorId) {\n+        this.updatesInvalidByOriginatorId = updatesInvalidByOriginatorId;\n+    }\n+\n+    public Integer getUpdatesInvalidByAsConfedLoop() {\n+        return updatesInvalidByAsConfedLoop;\n+    }\n+\n+    public void setUpdatesInvalidByAsConfedLoop(Integer updatesInvalidByAsConfedLoop) {\n+        this.updatesInvalidByAsConfedLoop = updatesInvalidByAsConfedLoop;\n+    }\n+\n+    public Long getNumRoutesAdjRibIn() {\n+        return numRoutesAdjRibIn;\n+    }\n+\n+    public void setNumRoutesAdjRibIn(Long numRoutesAdjRibIn) {\n+        this.numRoutesAdjRibIn = numRoutesAdjRibIn;\n+    }\n+\n+    public Long getNumROutesLocalRib() {\n+        return numROutesLocalRib;\n+    }\n+\n+    public void setNumROutesLocalRib(Long numROutesLocalRib) {\n+        this.numROutesLocalRib = numROutesLocalRib;\n+    }\n+\n+    public Date getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(Date timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+}", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MjQyOA==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526772428", "bodyText": "Does it make sens to store the stats in the database in addition to RRD?", "author": "fooker", "createdAt": "2020-11-19T10:59:37Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpStatReports.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+import javax.persistence.Column;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.SequenceGenerator;\n+\n+public class BmpStatReports implements Serializable {", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MjY2OA==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526772668", "bodyText": "Do we need toString, equals and hashCode?", "author": "fooker", "createdAt": "2020-11-19T10:59:56Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpUnicastPrefix.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+import java.io.Serializable;\n+import java.util.Date;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.Transient;\n+\n+@Entity\n+@Table(name = \"bmp_ip_ribs\")\n+public class BmpUnicastPrefix implements Serializable {\n+\n+\n+    private static final long serialVersionUID = -7783081316304433407L;\n+\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"bmpUnicastSequence\")\n+    @SequenceGenerator(name = \"bmpUnicastSequence\", sequenceName = \"bmpunicastnxtid\")\n+    @Column(name = \"id\", nullable = false)\n+    private Long id;\n+\n+    @Column(name = \"hash_id\", nullable = false)\n+    private String hashId;\n+\n+    @ManyToOne(optional = false, fetch = FetchType.LAZY)\n+    @JoinColumn(name = \"peer_hash_id\", referencedColumnName = \"hash_id\", nullable = false)\n+    private BmpPeer bmpPeer;\n+\n+    @Column(name = \"base_attr_hash_id\", nullable = false)\n+    private String baseAttrHashId;\n+\n+    @Column(name = \"is_ipv4\", nullable = false)\n+    private boolean isIpv4;\n+\n+    @Column(name = \"origin_as\")\n+    private Long originAs;\n+\n+    @Column(name = \"prefix\", nullable = false)\n+    private String prefix;\n+\n+    @Column(name = \"prefix_len\", nullable = false)\n+    private Integer prefixLen;\n+\n+    @Column(name = \"last_updated\", nullable = false)\n+    @Temporal(TemporalType.TIMESTAMP)\n+    private Date timestamp;\n+\n+    @Column(name = \"first_added_timestamp\", nullable = false)\n+    private Date firstAddedTimestamp;\n+\n+    @Column(name = \"is_withdrawn\", nullable = false)\n+    private boolean isWithDrawn;\n+\n+    @Column(name = \"prefix_bits\")\n+    private String prefixBits;\n+\n+    @Column(name = \"path_id\")\n+    private Long pathId;\n+\n+    @Column(name = \"labels\")\n+    private String labels;\n+\n+    @Column(name = \"is_pre_policy\", nullable = false)\n+    private boolean isPrePolicy;\n+\n+    @Column(name = \"is_adj_ribin\", nullable = false)\n+    private boolean isAdjRibIn;\n+\n+    @Transient\n+    private String prevBaseAttrHashId;\n+\n+    @Transient\n+    private boolean prevWithDrawnState;\n+\n+    public Long getId() {\n+        return id;\n+    }\n+\n+    public void setId(Long id) {\n+        this.id = id;\n+    }\n+\n+    public String getHashId() {\n+        return hashId;\n+    }\n+\n+    public void setHashId(String hashId) {\n+        this.hashId = hashId;\n+    }\n+\n+    public String getBaseAttrHashId() {\n+        return baseAttrHashId;\n+    }\n+\n+    public void setBaseAttrHashId(String baseAttrHashId) {\n+        this.baseAttrHashId = baseAttrHashId;\n+    }\n+\n+    public BmpPeer getBmpPeer() {\n+        return bmpPeer;\n+    }\n+\n+    public void setBmpPeer(BmpPeer bmpPeer) {\n+        this.bmpPeer = bmpPeer;\n+    }\n+\n+    public boolean isIpv4() {\n+        return isIpv4;\n+    }\n+\n+    public void setIpv4(boolean ipv4) {\n+        isIpv4 = ipv4;\n+    }\n+\n+    public Long getOriginAs() {\n+        return originAs;\n+    }\n+\n+    public void setOriginAs(Long originAs) {\n+        this.originAs = originAs;\n+    }\n+\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    public void setPrefix(String prefix) {\n+        this.prefix = prefix;\n+    }\n+\n+    public Integer getPrefixLen() {\n+        return prefixLen;\n+    }\n+\n+    public void setPrefixLen(Integer prefixLen) {\n+        this.prefixLen = prefixLen;\n+    }\n+\n+    public Date getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(Date timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public Date getFirstAddedTimestamp() {\n+        return firstAddedTimestamp;\n+    }\n+\n+    public void setFirstAddedTimestamp(Date firstAddedTimestamp) {\n+        this.firstAddedTimestamp = firstAddedTimestamp;\n+    }\n+\n+    public boolean isWithDrawn() {\n+        return isWithDrawn;\n+    }\n+\n+    public void setWithDrawn(boolean withDrawn) {\n+        isWithDrawn = withDrawn;\n+    }\n+\n+    public String getPrefixBits() {\n+        return prefixBits;\n+    }\n+\n+    public void setPrefixBits(String prefixBits) {\n+        this.prefixBits = prefixBits;\n+    }\n+\n+    public Long getPathId() {\n+        return pathId;\n+    }\n+\n+    public void setPathId(Long pathId) {\n+        this.pathId = pathId;\n+    }\n+\n+    public String getLabels() {\n+        return labels;\n+    }\n+\n+    public void setLabels(String labels) {\n+        this.labels = labels;\n+    }\n+\n+    public boolean isPrePolicy() {\n+        return isPrePolicy;\n+    }\n+\n+    public void setPrePolicy(boolean prePolicy) {\n+        isPrePolicy = prePolicy;\n+    }\n+\n+    public boolean isAdjRibIn() {\n+        return isAdjRibIn;\n+    }\n+\n+    public void setAdjRibIn(boolean adjRibIn) {\n+        isAdjRibIn = adjRibIn;\n+    }\n+\n+    public String getPrevBaseAttrHashId() {\n+        return prevBaseAttrHashId;\n+    }\n+\n+    public void setPrevBaseAttrHashId(String prevBaseAttrHashId) {\n+        this.prevBaseAttrHashId = prevBaseAttrHashId;\n+    }\n+\n+    public boolean isPrevWithDrawnState() {\n+        return prevWithDrawnState;\n+    }\n+\n+    public void setPrevWithDrawnState(boolean prevWithDrawnState) {\n+        this.prevWithDrawnState = prevWithDrawnState;\n+    }\n+}", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3Mjk5OA==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526772998", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                List<PrefixByAS> getPrefixesGroupedbyAS();\n          \n          \n            \n                List<PrefixByAS> getPrefixesGroupedByAS();", "author": "fooker", "createdAt": "2020-11-19T11:00:28Z", "path": "features/telemetry/protocols/bmp/persistence/api/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/api/BmpUnicastPrefixDao.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.api;\n+\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import org.opennms.netmgt.dao.api.OnmsDao;\n+\n+public interface BmpUnicastPrefixDao extends OnmsDao<BmpUnicastPrefix, Long> {\n+\n+    BmpUnicastPrefix findByHashId(String hashId);\n+\n+    List<BmpUnicastPrefix> getUnicastPrefixesAfterDate(String hashId, Date time);\n+\n+    List<PrefixByAS> getPrefixesGroupedbyAS();", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3NTU3Mg==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526775572", "bodyText": "Just make this an inline string", "author": "fooker", "createdAt": "2020-11-19T11:04:43Z", "path": "features/telemetry/protocols/bmp/persistence/impl/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/impl/BmpUnicastPrefixDaoImpl.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.persistence.impl;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import org.opennms.core.criteria.Criteria;\n+import org.opennms.core.criteria.CriteriaBuilder;\n+import org.opennms.core.criteria.restrictions.EqRestriction;\n+import org.opennms.core.criteria.restrictions.Restrictions;\n+import org.opennms.netmgt.dao.hibernate.AbstractDaoHibernate;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpUnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpUnicastPrefixDao;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.PrefixByAS;\n+\n+import com.google.common.base.Strings;\n+\n+public class BmpUnicastPrefixDaoImpl extends AbstractDaoHibernate<BmpUnicastPrefix, Long> implements BmpUnicastPrefixDao {\n+\n+    public BmpUnicastPrefixDaoImpl() {\n+        super(BmpUnicastPrefix.class);\n+    }\n+\n+    @Override\n+    public BmpUnicastPrefix findByHashId(String hashId) {\n+        if (Strings.isNullOrEmpty(hashId)) {\n+            return null;\n+        }\n+        Criteria criteria = new Criteria(BmpUnicastPrefix.class);\n+        criteria.addRestriction(new EqRestriction(\"hashId\", hashId));\n+        List<BmpUnicastPrefix> bmpUnicastPrefixes = findMatching(criteria);\n+        if (bmpUnicastPrefixes != null && bmpUnicastPrefixes.size() > 0) {\n+            return bmpUnicastPrefixes.get(0);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<BmpUnicastPrefix> getUnicastPrefixesAfterDate(String hashId, Date time) {\n+        CriteriaBuilder criteriaBuilder = new CriteriaBuilder(BmpUnicastPrefix.class);\n+        criteriaBuilder.alias(\"bmpPeer\", \"bmpPeer\")\n+                .and(Restrictions.eq(\"bmpPeer.hashId\", hashId))\n+                .and(Restrictions.lt(\"bmpPeer.timeStamp\", time));\n+        return findMatching(criteriaBuilder.toCriteria());\n+    }\n+\n+    @Override\n+    public List<PrefixByAS> getPrefixesGroupedbyAS() {\n+        final StringBuilder sql = new StringBuilder();", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkxNTQxOA==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r526915418", "bodyText": "Lovin' it", "author": "fooker", "createdAt": "2020-11-19T14:10:33Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/BmpMessagePersister.java", "diffHunk": "@@ -0,0 +1,687 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter;\n+\n+import java.net.InetAddress;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.collection.api.AttributeType;\n+import org.opennms.netmgt.collection.api.CollectionAgent;\n+import org.opennms.netmgt.collection.api.CollectionAgentFactory;\n+import org.opennms.netmgt.collection.support.builder.CollectionSetBuilder;\n+import org.opennms.netmgt.collection.support.builder.DeferredGenericTypeResource;\n+import org.opennms.netmgt.collection.support.builder.NodeLevelResource;\n+import org.opennms.netmgt.dao.api.InterfaceToNodeCache;\n+import org.opennms.netmgt.dao.api.SessionUtils;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpBaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpBaseAttributeDao;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpCollector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpCollectorDao;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpGlobalIpRib;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpGlobalIpRibDao;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpPeer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpPeerDao;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpRouter;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpRouterDao;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpStatReports;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpUnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpUnicastPrefixDao;\n+import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.PrefixByAS;\n+import org.opennms.netmgt.telemetry.protocols.collection.CollectionSetWithAgent;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+public class BmpMessagePersister implements BmpPersistenceMessageHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpMessagePersister.class);\n+\n+    @Autowired\n+    private BmpCollectorDao bmpCollectorDao;\n+\n+    @Autowired\n+    private BmpRouterDao bmpRouterDao;\n+\n+    @Autowired\n+    private BmpPeerDao bmpPeerDao;\n+\n+    @Autowired\n+    private BmpBaseAttributeDao bmpBaseAttributeDao;\n+\n+    @Autowired\n+    private BmpUnicastPrefixDao bmpUnicastPrefixDao;\n+\n+    @Autowired\n+    private BmpGlobalIpRibDao bmpGlobalIpRibDao;\n+\n+    @Autowired\n+    private SessionUtils sessionUtils;\n+\n+    private CollectionAgentFactory collectionAgentFactory;\n+\n+    @Autowired\n+    private InterfaceToNodeCache interfaceToNodeCache;\n+\n+    private final ThreadFactory threadFactory = new ThreadFactoryBuilder()\n+            .setNameFormat(\"updateGlobalRibs-%d\")\n+            .build();\n+    private final ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(\n+            threadFactory);\n+\n+\n+    private Map<String, Long> updatesByPeer = new ConcurrentHashMap<>();\n+    private Map<String, Long> withdrawsByPeer = new ConcurrentHashMap<>();\n+    private Map<AsnKey, Long> updatesByAsn = new ConcurrentHashMap<>();\n+    private Map<AsnKey, Long> withdrawsByAsn = new ConcurrentHashMap<>();\n+    private Map<PrefixKey, Long> updatesByPrefix = new ConcurrentHashMap<>();\n+    private Map<PrefixKey, Long> withdrawsByPrefix = new ConcurrentHashMap<>();\n+    private ConcurrentLinkedQueue<CollectionSetWithAgent> collectionSetQueue = new ConcurrentLinkedQueue<>();\n+\n+\n+    @Override\n+    public void handle(Message message, String location) {\n+        sessionUtils.withTransaction(() -> {\n+            switch (message.getType()) {\n+                case COLLECTOR:\n+                    List<BmpCollector> bmpCollectors = buildBmpCollectors(message);\n+                    // Update routers state to down when collector is just starting or going into stopped state.\n+                    bmpCollectors.forEach(collector -> {\n+                        if (collector.getAction().equals(Collector.Action.STARTED.value) ||\n+                                collector.getAction().equals(Collector.Action.STOPPED.value)) {\n+                            collector.getBmpRouters().forEach(bmpRouter -> {\n+                                // Set down state for routers.\n+                                bmpRouter.setState(false);\n+                            });\n+                        }\n+                        try {\n+                            bmpCollectorDao.saveOrUpdate(collector);\n+                        } catch (Exception e) {\n+                            LOG.error(\"Exception while persisting BMP collector {}\", collector, e);\n+                        }\n+                    });\n+                    break;\n+                case ROUTER:\n+                    BmpCollector bmpCollector = bmpCollectorDao.findByCollectorHashId(message.getCollectorHashId());\n+                    if (bmpCollector != null) {\n+                        List<BmpRouter> bmpRouters = buildBmpRouters(message, bmpCollector);\n+                        bmpRouters.forEach(router -> {\n+                            Integer connections = router.getConnectionCount();\n+                            // Upon initial router message in INIT/FIRST state,  update all corresponding peer state to down.\n+                            boolean state = !router.getAction().equals(Router.Action.TERM.value);\n+                            if (connections == 0 && state) {\n+                                router.getBmpPeers().forEach(bmpPeer -> {\n+                                    if (bmpPeer.getTimestamp().getTime() < router.getTimestamp().getTime()) {\n+                                        bmpPeer.setState(false);\n+                                    }\n+                                });\n+                            }\n+                            Integer count = state ? ++connections : --connections;", "originalCommit": "b641d4e6eb9c5e64bf746d28e600447e646fd2c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d876bd790e2967c6448bd666dc04071a73240c97", "url": "https://github.com/OpenNMS/opennms/commit/d876bd790e2967c6448bd666dc04071a73240c97", "message": "NMS-12949: Handle review comments", "committedDate": "2020-11-30T21:13:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE4NzgxOQ==", "url": "https://github.com/OpenNMS/opennms/pull/3193#discussion_r533187819", "bodyText": "Oops", "author": "fooker", "createdAt": "2020-12-01T09:07:39Z", "path": "features/telemetry/protocols/bmp/persistence/impl/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/persistence/impl/BmpGlobalIpRibDaoImpl.java", "diffHunk": "@@ -36,7 +36,7 @@\n import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpGlobalIpRib;\n import org.opennms.netmgt.telemetry.protocols.bmp.persistence.api.BmpGlobalIpRibDao;\n \n-public class BmpGlobalIpRibDaoImpl extends AbstractDaoHibernate<BmpGlobalIpRib, Long> implements BmpGlobalIpRibDao {\n+public class    BmpGlobalIpRibDaoImpl extends AbstractDaoHibernate<BmpGlobalIpRib, Long> implements BmpGlobalIpRibDao {", "originalCommit": "d876bd790e2967c6448bd666dc04071a73240c97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "90549259dc8416a1fae053f38e8d4b6a3d079204", "url": "https://github.com/OpenNMS/opennms/commit/90549259dc8416a1fae053f38e8d4b6a3d079204", "message": "NMS-12949: Handle review comments", "committedDate": "2020-12-01T15:47:04Z", "type": "commit"}]}