{"pr_number": 3161, "pr_title": "NMS-12814: Interfaces incorrectly marked as having flows resulting in no data via Helm", "pr_createdAt": "2020-09-17T01:31:11Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/3161", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2MzA5OQ==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r491163099", "bodyText": "@fooker , @christianpape, the test will succeed with this implementation. But It is not clear to me why the system behaves like it does. Why is it green when I implement it that way?\nI assume the checkInterfaces method is implemented wrong. I don't have enough domain knowledge to understand what we need to test for...\nMaybe you can help me out here... Thanks!", "author": "patrick-schweizer", "createdAt": "2020-09-18T20:00:49Z", "path": "features/flows/itests/src/test/java/org/opennms/netmgt/flows/elastic/MarkerCacheIT.java", "diffHunk": "@@ -221,11 +236,81 @@ public void testNMS12740() throws Exception {\n \n             elasticFlowRepository.persist(Lists.newArrayList(getMockFlow(Flow.Direction.EGRESS)), getMockFlowSource());\n \n-            Assert.assertEquals(0,snmpInterfaceDao.findAllHavingIngressFlows(2).size());\n-            Assert.assertEquals(0, snmpInterfaceDao.findAllHavingEgressFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingIngressFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingEgressFlows(2).size());\n \n             // the following call resulted to two wrong entries before, since the wrong query returned entries from other nodes with egress flows\n-            Assert.assertEquals(0, snmpInterfaceDao.findAllHavingFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingFlows(2).size());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldDistinguishBetweenIngressAndEgressWhenDeterminingIfFlowsAreAvailable() throws Exception {\n+        Assert.assertFalse(OnmsSnmpInterface.INGRESS_AND_EGRESS_REQUIRED);\n+\n+        stubFor(post(\"/_bulk\")\n+                .willReturn(aResponse()\n+                        .withStatus(200)\n+                        .withHeader(\"Content-Type\", \"application/json\")));\n+\n+        final ClassificationEngine classificationEngine = new DefaultClassificationEngine(() -> Lists.newArrayList(\n+                new RuleBuilder().withName(\"http\").withDstPort(\"80\").withProtocol(\"tcp,udp\").build(),\n+                new RuleBuilder().withName(\"https\").withDstPort(\"443\").withProtocol(\"tcp,udp\").build()\n+        ), FilterService.NOOP);\n+\n+        final DocumentEnricher documentEnricher = new DocumentEnricher(\n+                new MetricRegistry(), nodeDao, interfaceToNodeCache, sessionUtils, classificationEngine,\n+                new CacheConfigBuilder()\n+                        .withName(\"flows.node\")\n+                        .withMaximumSize(1000)\n+                        .withExpireAfterWrite(300)\n+                        .build());\n+\n+        final JestClientFactory factory = new JestClientFactory();\n+        factory.setHttpClientConfig(new HttpClientConfig.Builder(\"http://localhost:\" + wireMockRule.port()).build());\n+\n+        try (JestClient client = factory.getObject()) {\n+            final ElasticFlowRepository elasticFlowRepository = new ElasticFlowRepository(new MetricRegistry(),\n+                    client, IndexStrategy.MONTHLY, documentEnricher,\n+                    sessionUtils, nodeDao, snmpInterfaceDao,\n+                    new MockIdentity(), new MockTracerRegistry(), new MockDocumentForwarder(), new IndexSettings(),\n+                    mock(SmartQueryService.class));\n+\n+            Assert.assertThat(nodeDao.findAllHavingFlows(), is(empty()));\n+            Assert.assertThat(snmpInterfaceDao.findAllHavingFlows(1), is(empty()));\n+            Assert.assertThat(snmpInterfaceDao.findAllHavingFlows(2), is(empty()));\n+\n+            elasticFlowRepository.persist(Lists.newArrayList(getMockFlow(Flow.Direction.EGRESS)), getMockFlowSource());\n+            checkInterfaces(1, \"192.168.1.1\");\n+            checkInterfaces(2);\n+\n+            elasticFlowRepository.persist(Lists.newArrayList(getMockFlow(Flow.Direction.INGRESS)), getMockFlowSource());\n+            checkInterfaces(1, \"192.168.1.1\", \"192.168.1.1\");\n+            checkInterfaces(2);\n+\n+            elasticFlowRepository.persist(Lists.newArrayList(getMockFlow(Flow.Direction.INGRESS)), getMockFlowSource());\n+            checkInterfaces(1, \"192.168.1.1\", \"192.168.1.1\");\n+            checkInterfaces(2);", "originalCommit": "da7b3a7ddde10090b2fa7b14232946d603c42d75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5OTI2Mw==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r492999263", "bodyText": "Comment / code mismatch (ingress vs egress)", "author": "fooker", "createdAt": "2020-09-22T20:01:31Z", "path": "features/flows/itests/src/test/java/org/opennms/netmgt/flows/elastic/MarkerCacheIT.java", "diffHunk": "@@ -221,11 +232,97 @@ public void testNMS12740() throws Exception {\n \n             elasticFlowRepository.persist(Lists.newArrayList(getMockFlow(Flow.Direction.EGRESS)), getMockFlowSource());\n \n-            Assert.assertEquals(0,snmpInterfaceDao.findAllHavingIngressFlows(2).size());\n-            Assert.assertEquals(0, snmpInterfaceDao.findAllHavingEgressFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingIngressFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingEgressFlows(2).size());\n \n             // the following call resulted to two wrong entries before, since the wrong query returned entries from other nodes with egress flows\n-            Assert.assertEquals(0, snmpInterfaceDao.findAllHavingFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingFlows(2).size());\n         }\n     }\n+\n+    @Test\n+    public void shouldDistinguishBetweenIngressAndEgressWhenDeterminingIfFlowsAreAvailable() throws Exception {\n+        Assert.assertFalse(OnmsSnmpInterface.INGRESS_AND_EGRESS_REQUIRED);\n+\n+        stubFor(post(\"/_bulk\")\n+                .willReturn(aResponse()\n+                        .withStatus(200)\n+                        .withHeader(\"Content-Type\", \"application/json\")));\n+\n+        final ClassificationEngine classificationEngine = new DefaultClassificationEngine(() -> Lists.newArrayList(\n+                new RuleBuilder().withName(\"http\").withDstPort(\"80\").withProtocol(\"tcp,udp\").build(),\n+                new RuleBuilder().withName(\"https\").withDstPort(\"443\").withProtocol(\"tcp,udp\").build()\n+        ), FilterService.NOOP);\n+\n+        final DocumentEnricher documentEnricher = new DocumentEnricher(\n+                new MetricRegistry(), nodeDao, interfaceToNodeCache, sessionUtils, classificationEngine,\n+                new CacheConfigBuilder()\n+                        .withName(\"flows.node\")\n+                        .withMaximumSize(1000)\n+                        .withExpireAfterWrite(300)\n+                        .build());\n+\n+        final JestClientFactory factory = new JestClientFactory();\n+        factory.setHttpClientConfig(new HttpClientConfig.Builder(\"http://localhost:\" + wireMockRule.port()).build());\n+\n+        try (JestClient client = factory.getObject()) {\n+            final ElasticFlowRepository elasticFlowRepository = new ElasticFlowRepository(new MetricRegistry(),\n+                    client, IndexStrategy.MONTHLY, documentEnricher,\n+                    sessionUtils, nodeDao, snmpInterfaceDao,\n+                    new MockIdentity(), new MockTracerRegistry(), new MockDocumentForwarder(), new IndexSettings(),\n+                    mock(SmartQueryService.class));\n+\n+            Integer ingress = 2;\n+            Integer egress = 3;\n+\n+            // no flows persisted -> we shouldn't have any interfaces\n+            expectAllInterfaces();\n+            expectIngressInterfaces();\n+            expectEgressInterfaces();\n+\n+            // persist egress flow", "originalCommit": "c797dd7820ab1f07f690d8ee91e89b5ff31b06da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxNTM1Ng==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r493615356", "bodyText": "fixed", "author": "patrick-schweizer", "createdAt": "2020-09-23T13:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5OTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5OTMzMw==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r492999333", "bodyText": "And the other way around", "author": "fooker", "createdAt": "2020-09-22T20:01:41Z", "path": "features/flows/itests/src/test/java/org/opennms/netmgt/flows/elastic/MarkerCacheIT.java", "diffHunk": "@@ -221,11 +232,97 @@ public void testNMS12740() throws Exception {\n \n             elasticFlowRepository.persist(Lists.newArrayList(getMockFlow(Flow.Direction.EGRESS)), getMockFlowSource());\n \n-            Assert.assertEquals(0,snmpInterfaceDao.findAllHavingIngressFlows(2).size());\n-            Assert.assertEquals(0, snmpInterfaceDao.findAllHavingEgressFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingIngressFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingEgressFlows(2).size());\n \n             // the following call resulted to two wrong entries before, since the wrong query returned entries from other nodes with egress flows\n-            Assert.assertEquals(0, snmpInterfaceDao.findAllHavingFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingFlows(2).size());\n         }\n     }\n+\n+    @Test\n+    public void shouldDistinguishBetweenIngressAndEgressWhenDeterminingIfFlowsAreAvailable() throws Exception {\n+        Assert.assertFalse(OnmsSnmpInterface.INGRESS_AND_EGRESS_REQUIRED);\n+\n+        stubFor(post(\"/_bulk\")\n+                .willReturn(aResponse()\n+                        .withStatus(200)\n+                        .withHeader(\"Content-Type\", \"application/json\")));\n+\n+        final ClassificationEngine classificationEngine = new DefaultClassificationEngine(() -> Lists.newArrayList(\n+                new RuleBuilder().withName(\"http\").withDstPort(\"80\").withProtocol(\"tcp,udp\").build(),\n+                new RuleBuilder().withName(\"https\").withDstPort(\"443\").withProtocol(\"tcp,udp\").build()\n+        ), FilterService.NOOP);\n+\n+        final DocumentEnricher documentEnricher = new DocumentEnricher(\n+                new MetricRegistry(), nodeDao, interfaceToNodeCache, sessionUtils, classificationEngine,\n+                new CacheConfigBuilder()\n+                        .withName(\"flows.node\")\n+                        .withMaximumSize(1000)\n+                        .withExpireAfterWrite(300)\n+                        .build());\n+\n+        final JestClientFactory factory = new JestClientFactory();\n+        factory.setHttpClientConfig(new HttpClientConfig.Builder(\"http://localhost:\" + wireMockRule.port()).build());\n+\n+        try (JestClient client = factory.getObject()) {\n+            final ElasticFlowRepository elasticFlowRepository = new ElasticFlowRepository(new MetricRegistry(),\n+                    client, IndexStrategy.MONTHLY, documentEnricher,\n+                    sessionUtils, nodeDao, snmpInterfaceDao,\n+                    new MockIdentity(), new MockTracerRegistry(), new MockDocumentForwarder(), new IndexSettings(),\n+                    mock(SmartQueryService.class));\n+\n+            Integer ingress = 2;\n+            Integer egress = 3;\n+\n+            // no flows persisted -> we shouldn't have any interfaces\n+            expectAllInterfaces();\n+            expectIngressInterfaces();\n+            expectEgressInterfaces();\n+\n+            // persist egress flow\n+            elasticFlowRepository.persist(Lists.newArrayList(getMockFlow(Flow.Direction.INGRESS)), getMockFlowSource());\n+            expectAllInterfaces(ingress);\n+            expectIngressInterfaces(ingress);\n+            expectEgressInterfaces();\n+\n+            // persist ingress flow", "originalCommit": "c797dd7820ab1f07f690d8ee91e89b5ff31b06da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxNTQ1Mg==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r493615452", "bodyText": "fixed", "author": "patrick-schweizer", "createdAt": "2020-09-23T13:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5OTMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMDc4Nw==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r493000787", "bodyText": "Use SessionUtils instead. It saves you from a lot of boilerplate code", "author": "fooker", "createdAt": "2020-09-22T20:04:29Z", "path": "features/flows/itests/src/test/java/org/opennms/netmgt/flows/elastic/MarkerCacheIT.java", "diffHunk": "@@ -108,6 +116,9 @@\n     @Autowired\n     private InterfaceToNodeCache interfaceToNodeCache;\n \n+    @Autowired\n+    private TransactionTemplate transactionTemplate;", "originalCommit": "c797dd7820ab1f07f690d8ee91e89b5ff31b06da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYwNDM4Nw==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r493604387", "bodyText": "\ud83d\udc4d  fixed", "author": "patrick-schweizer", "createdAt": "2020-09-23T13:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMDc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMTUyOA==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r493001528", "bodyText": "Any reason why these (and others below) are Integer, not int?", "author": "fooker", "createdAt": "2020-09-22T20:05:47Z", "path": "features/flows/itests/src/test/java/org/opennms/netmgt/flows/elastic/MarkerCacheIT.java", "diffHunk": "@@ -221,11 +232,97 @@ public void testNMS12740() throws Exception {\n \n             elasticFlowRepository.persist(Lists.newArrayList(getMockFlow(Flow.Direction.EGRESS)), getMockFlowSource());\n \n-            Assert.assertEquals(0,snmpInterfaceDao.findAllHavingIngressFlows(2).size());\n-            Assert.assertEquals(0, snmpInterfaceDao.findAllHavingEgressFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingIngressFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingEgressFlows(2).size());\n \n             // the following call resulted to two wrong entries before, since the wrong query returned entries from other nodes with egress flows\n-            Assert.assertEquals(0, snmpInterfaceDao.findAllHavingFlows(2).size());\n+            assertEquals(0, snmpInterfaceDao.findAllHavingFlows(2).size());\n         }\n     }\n+\n+    @Test\n+    public void shouldDistinguishBetweenIngressAndEgressWhenDeterminingIfFlowsAreAvailable() throws Exception {\n+        Assert.assertFalse(OnmsSnmpInterface.INGRESS_AND_EGRESS_REQUIRED);\n+\n+        stubFor(post(\"/_bulk\")\n+                .willReturn(aResponse()\n+                        .withStatus(200)\n+                        .withHeader(\"Content-Type\", \"application/json\")));\n+\n+        final ClassificationEngine classificationEngine = new DefaultClassificationEngine(() -> Lists.newArrayList(\n+                new RuleBuilder().withName(\"http\").withDstPort(\"80\").withProtocol(\"tcp,udp\").build(),\n+                new RuleBuilder().withName(\"https\").withDstPort(\"443\").withProtocol(\"tcp,udp\").build()\n+        ), FilterService.NOOP);\n+\n+        final DocumentEnricher documentEnricher = new DocumentEnricher(\n+                new MetricRegistry(), nodeDao, interfaceToNodeCache, sessionUtils, classificationEngine,\n+                new CacheConfigBuilder()\n+                        .withName(\"flows.node\")\n+                        .withMaximumSize(1000)\n+                        .withExpireAfterWrite(300)\n+                        .build());\n+\n+        final JestClientFactory factory = new JestClientFactory();\n+        factory.setHttpClientConfig(new HttpClientConfig.Builder(\"http://localhost:\" + wireMockRule.port()).build());\n+\n+        try (JestClient client = factory.getObject()) {\n+            final ElasticFlowRepository elasticFlowRepository = new ElasticFlowRepository(new MetricRegistry(),\n+                    client, IndexStrategy.MONTHLY, documentEnricher,\n+                    sessionUtils, nodeDao, snmpInterfaceDao,\n+                    new MockIdentity(), new MockTracerRegistry(), new MockDocumentForwarder(), new IndexSettings(),\n+                    mock(SmartQueryService.class));\n+\n+            Integer ingress = 2;", "originalCommit": "c797dd7820ab1f07f690d8ee91e89b5ff31b06da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMjExOQ==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r493002119", "bodyText": "In this case: just inline them or make them real constants (same for the nodeId below.", "author": "fooker", "createdAt": "2020-09-22T20:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxNTcyNg==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r493615726", "bodyText": "Any reason why these (and others below) are Integer, not int?\nnope. fixed.", "author": "patrick-schweizer", "createdAt": "2020-09-23T13:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxNzU0Mw==", "url": "https://github.com/OpenNMS/opennms/pull/3161#discussion_r493617543", "bodyText": "In this case: just inline them or make them real constants (same for the nodeId below.\n\nThe reason I wanted to use a named variable (and not inline) is that it reads easier (\"2\" has no meaning).\nBut they are only used in the scope of the method so I didn't wanted to make it a class constant.\nI made it final as a compromise. Sounds good?", "author": "patrick-schweizer", "createdAt": "2020-09-23T14:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMTUyOA=="}], "type": "inlineReview"}, {"oid": "eb5d05580e4190b9b82c50c711d80dfab5b9f4de", "url": "https://github.com/OpenNMS/opennms/commit/eb5d05580e4190b9b82c50c711d80dfab5b9f4de", "message": "NMS-12814: Interfaces incorrectly marked as having flows resulting in no data via Helm", "committedDate": "2020-09-23T14:49:44Z", "type": "forcePushed"}, {"oid": "6b0da07e276792eaefa972a4992f1044efdfdfb5", "url": "https://github.com/OpenNMS/opennms/commit/6b0da07e276792eaefa972a4992f1044efdfdfb5", "message": "NMS-12814: Interfaces incorrectly marked as having flows resulting in no data via Helm", "committedDate": "2020-09-23T15:12:47Z", "type": "commit"}, {"oid": "6b0da07e276792eaefa972a4992f1044efdfdfb5", "url": "https://github.com/OpenNMS/opennms/commit/6b0da07e276792eaefa972a4992f1044efdfdfb5", "message": "NMS-12814: Interfaces incorrectly marked as having flows resulting in no data via Helm", "committedDate": "2020-09-23T15:12:47Z", "type": "forcePushed"}, {"oid": "7d880ab1a5e4add95d2293dcb2c1877067664383", "url": "https://github.com/OpenNMS/opennms/commit/7d880ab1a5e4add95d2293dcb2c1877067664383", "message": "NMS-12814: Interfaces incorrectly marked as having flows resulting in no data via Helm: fix backport", "committedDate": "2020-09-23T15:39:17Z", "type": "commit"}]}