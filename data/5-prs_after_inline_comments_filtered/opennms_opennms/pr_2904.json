{"pr_number": 2904, "pr_title": "NMS-12424: Add OpenBMP integration", "pr_createdAt": "2020-02-27T14:57:06Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/2904", "timeline": [{"oid": "313bc685672cd82c90519cebcaf4eae0dafcf30d", "url": "https://github.com/OpenNMS/opennms/commit/313bc685672cd82c90519cebcaf4eae0dafcf30d", "message": "NMS-12424: Added OpenBMP messages and adapter skeleton", "committedDate": "2020-02-25T08:50:36Z", "type": "commit"}, {"oid": "7a717b136db44d93d34af305e9e6f22df5c85603", "url": "https://github.com/OpenNMS/opennms/commit/7a717b136db44d93d34af305e9e6f22df5c85603", "message": "NMS-12424: Produce first message types", "committedDate": "2020-02-25T08:50:37Z", "type": "commit"}, {"oid": "fc55e760a7ce247922bc9e37d62fc77d722f2508", "url": "https://github.com/OpenNMS/opennms/commit/fc55e760a7ce247922bc9e37d62fc77d722f2508", "message": "Merge remote-tracking branch 'origin/features/bmp' into jira/NMS-12424", "committedDate": "2020-02-25T12:52:41Z", "type": "commit"}, {"oid": "41b4c2d98299ef6471cc3fa08630d34fcbb32841", "url": "https://github.com/OpenNMS/opennms/commit/41b4c2d98299ef6471cc3fa08630d34fcbb32841", "message": "Merge remote-tracking branch 'origin/features/bmp' into jira/NMS-12424", "committedDate": "2020-02-25T18:28:05Z", "type": "commit"}, {"oid": "be73be14baa75a3af62b0bfbf2188aa16a2d4038", "url": "https://github.com/OpenNMS/opennms/commit/be73be14baa75a3af62b0bfbf2188aa16a2d4038", "message": "NMS-12424: Add heartbeat for BMP listener/parser\n\nThe TCP parser interface is changed to expose lifecycle handling\nmethods. The TCP listener calls thes methods on connects/disconnects.", "committedDate": "2020-02-25T19:10:37Z", "type": "commit"}, {"oid": "0f21dd3da71de128a46db080f96fd9b6c9f5923f", "url": "https://github.com/OpenNMS/opennms/commit/0f21dd3da71de128a46db080f96fd9b6c9f5923f", "message": "NMS-12424: Serialization and deserialization tests for OpenBMP messages.", "committedDate": "2020-02-25T19:24:32Z", "type": "commit"}, {"oid": "ddd9045caee7944f76434899a3db054ebb0af3a3", "url": "https://github.com/OpenNMS/opennms/commit/ddd9045caee7944f76434899a3db054ebb0af3a3", "message": "Merge branch 'jira/NMS-12424' of github.com:OpenNMS/opennms into jira/NMS-12424", "committedDate": "2020-02-25T19:25:05Z", "type": "commit"}, {"oid": "a50f1a7bc8dc8713b9aab545f4badb0d244e8d05", "url": "https://github.com/OpenNMS/opennms/commit/a50f1a7bc8dc8713b9aab545f4badb0d244e8d05", "message": "Add a test for the message headers too.", "committedDate": "2020-02-25T20:23:17Z", "type": "commit"}, {"oid": "bac683b7903409d077ade0cbd417092d47e0ef66", "url": "https://github.com/OpenNMS/opennms/commit/bac683b7903409d077ade0cbd417092d47e0ef66", "message": "NMS-12424: Add unit test to verify generated OpenBMP messages\nfrom the BmpIntegrationAdapter.", "committedDate": "2020-02-26T01:56:01Z", "type": "commit"}, {"oid": "77de895a2f0e3cc8be4fc8c1ac6c838cc49ba1a4", "url": "https://github.com/OpenNMS/opennms/commit/77de895a2f0e3cc8be4fc8c1ac6c838cc49ba1a4", "message": "NMS-12424: beginnings of base_attribute message generation", "committedDate": "2020-02-26T03:10:46Z", "type": "commit"}, {"oid": "2d35e1873c2a13d7be29e1b0e934af1a6a034dd7", "url": "https://github.com/OpenNMS/opennms/commit/2d35e1873c2a13d7be29e1b0e934af1a6a034dd7", "message": "NMS-12424: Fix tests.", "committedDate": "2020-02-26T10:05:55Z", "type": "commit"}, {"oid": "b1e68d6da76b83853961078a48da2bfa1d072940", "url": "https://github.com/OpenNMS/opennms/commit/b1e68d6da76b83853961078a48da2bfa1d072940", "message": "NMS-12424: Fixed startup", "committedDate": "2020-02-26T10:15:22Z", "type": "commit"}, {"oid": "eeaa4ff5cc1b1df1557c187e98301d04a57c6d49", "url": "https://github.com/OpenNMS/opennms/commit/eeaa4ff5cc1b1df1557c187e98301d04a57c6d49", "message": "Merge branch 'jira/NMS-12424' of github.com:OpenNMS/opennms into jira/NMS-12424", "committedDate": "2020-02-26T10:17:24Z", "type": "commit"}, {"oid": "7e19d3c8a62c1cd4abfb7fd4cc9a34f31e16bbcd", "url": "https://github.com/OpenNMS/opennms/commit/7e19d3c8a62c1cd4abfb7fd4cc9a34f31e16bbcd", "message": "NMS-12424: Update protobuf to follow style guide.", "committedDate": "2020-02-26T10:29:57Z", "type": "commit"}, {"oid": "426ef1892435ed89d1cb0074356477fbacb29808", "url": "https://github.com/OpenNMS/opennms/commit/426ef1892435ed89d1cb0074356477fbacb29808", "message": "Merge branch 'jira/NMS-12424' of github.com:OpenNMS/opennms into jira/NMS-12424", "committedDate": "2020-02-26T10:30:20Z", "type": "commit"}, {"oid": "f950b13c7e774daa8efbafe2f6b39a4a395f5892", "url": "https://github.com/OpenNMS/opennms/commit/f950b13c7e774daa8efbafe2f6b39a4a395f5892", "message": "NMS-12424: Make it possible to send multiple messages from\na single incoming message.", "committedDate": "2020-02-26T10:33:50Z", "type": "commit"}, {"oid": "c0f9339765f1479dffbab7518a01b92bfa226c32", "url": "https://github.com/OpenNMS/opennms/commit/c0f9339765f1479dffbab7518a01b92bfa226c32", "message": "NMS-12424: Disable CircleCI for now :)", "committedDate": "2020-02-26T10:35:37Z", "type": "commit"}, {"oid": "729f95a268f73ae62dbadac0416c3726753bbe06", "url": "https://github.com/OpenNMS/opennms/commit/729f95a268f73ae62dbadac0416c3726753bbe06", "message": "NMS-12424: Initiation & Termination message", "committedDate": "2020-02-26T11:53:18Z", "type": "commit"}, {"oid": "ff18a00a92f1295db9a34f50057bf3b4b493cc15", "url": "https://github.com/OpenNMS/opennms/commit/ff18a00a92f1295db9a34f50057bf3b4b493cc15", "message": "NMS-12424: Finished Collector message", "committedDate": "2020-02-26T11:53:38Z", "type": "commit"}, {"oid": "24c1c246ae15ad5658865e723ba3026ba19fbe76", "url": "https://github.com/OpenNMS/opennms/commit/24c1c246ae15ad5658865e723ba3026ba19fbe76", "message": "NMS-12424: Fixed test", "committedDate": "2020-02-26T12:20:35Z", "type": "commit"}, {"oid": "b1d35a8fd5b5ad57dcd23911c4c2c717d7f7033a", "url": "https://github.com/OpenNMS/opennms/commit/b1d35a8fd5b5ad57dcd23911c4c2c717d7f7033a", "message": "NMS-12424: Modified test for router messages", "committedDate": "2020-02-26T12:51:52Z", "type": "commit"}, {"oid": "7c6bbbdb43b9339614a9baf6d34a081ee095e8ca", "url": "https://github.com/OpenNMS/opennms/commit/7c6bbbdb43b9339614a9baf6d34a081ee095e8ca", "message": "NMS-12424: base_attribute and unicast_prefix messages", "committedDate": "2020-02-26T13:25:47Z", "type": "commit"}, {"oid": "c89be009062f8cedd01dfe8b9cdb70a2969a3888", "url": "https://github.com/OpenNMS/opennms/commit/c89be009062f8cedd01dfe8b9cdb70a2969a3888", "message": "NMS-12424: WIP", "committedDate": "2020-02-26T14:05:42Z", "type": "commit"}, {"oid": "9e5e0f30fb0efa778144c361197342e0d5ff23d1", "url": "https://github.com/OpenNMS/opennms/commit/9e5e0f30fb0efa778144c361197342e0d5ff23d1", "message": "NMS-12424: PeerUp done", "committedDate": "2020-02-26T14:51:36Z", "type": "commit"}, {"oid": "e5a46aec24e7e42c3a29a2bd814d03c9bf5e3b50", "url": "https://github.com/OpenNMS/opennms/commit/e5a46aec24e7e42c3a29a2bd814d03c9bf5e3b50", "message": "NMS-12424: Impl some more fields", "committedDate": "2020-02-26T15:40:38Z", "type": "commit"}, {"oid": "a09c4402b298505bf6d0b8a8690c0fa6acf7f60e", "url": "https://github.com/OpenNMS/opennms/commit/a09c4402b298505bf6d0b8a8690c0fa6acf7f60e", "message": "NMS-12424: Set isPrePolicy flag", "committedDate": "2020-02-26T15:41:42Z", "type": "commit"}, {"oid": "78cd754c75f08927dc719bbec1e193663d4a0810", "url": "https://github.com/OpenNMS/opennms/commit/78cd754c75f08927dc719bbec1e193663d4a0810", "message": "NMS-12424: WIP", "committedDate": "2020-02-26T15:51:34Z", "type": "commit"}, {"oid": "aaff6cfbf4630347e2aeb55f860f69993a3d2508", "url": "https://github.com/OpenNMS/opennms/commit/aaff6cfbf4630347e2aeb55f860f69993a3d2508", "message": "NMS-12424: WIP", "committedDate": "2020-02-26T16:02:26Z", "type": "commit"}, {"oid": "fad8bc853db909283fb1b2583c2a898bccf2f04c", "url": "https://github.com/OpenNMS/opennms/commit/fad8bc853db909283fb1b2583c2a898bccf2f04c", "message": "NMS-12424: Added test for peer down", "committedDate": "2020-02-26T16:20:32Z", "type": "commit"}, {"oid": "db097a764813765924cc860ffc80b5923b444c9f", "url": "https://github.com/OpenNMS/opennms/commit/db097a764813765924cc860ffc80b5923b444c9f", "message": "NMS-12424: Add \"opennms.\" as a prefix to the topic names.", "committedDate": "2020-02-26T16:57:17Z", "type": "commit"}, {"oid": "da54d93251cda8d7a46bace8f09e754ec5fc1a91", "url": "https://github.com/OpenNMS/opennms/commit/da54d93251cda8d7a46bace8f09e754ec5fc1a91", "message": "NMS-12424: Add community path attr. support\n\nAlso fix @fooker's test.", "committedDate": "2020-02-26T18:32:56Z", "type": "commit"}, {"oid": "3c2aca4a816874e3627dd5e231f24c5a4956b517", "url": "https://github.com/OpenNMS/opennms/commit/3c2aca4a816874e3627dd5e231f24c5a4956b517", "message": "NMS-12424: Don't throw exceptions for unsupported path attributes ;)", "committedDate": "2020-02-26T22:02:31Z", "type": "commit"}, {"oid": "6490ab0e3f9827bbfb16355a1f6063a206fc610c", "url": "https://github.com/OpenNMS/opennms/commit/6490ab0e3f9827bbfb16355a1f6063a206fc610c", "message": "NMS-12424: Fix things", "committedDate": "2020-02-26T22:08:17Z", "type": "commit"}, {"oid": "707e37e52701f62214cbb97229abf6b2d0182f9d", "url": "https://github.com/OpenNMS/opennms/commit/707e37e52701f62214cbb97229abf6b2d0182f9d", "message": "NMS-12424: Fix things", "committedDate": "2020-02-26T22:26:32Z", "type": "commit"}, {"oid": "464c78b6884be7d45f32baddc29bc0ee625eb072", "url": "https://github.com/OpenNMS/opennms/commit/464c78b6884be7d45f32baddc29bc0ee625eb072", "message": "NMS-12424: Add more missing attribute ids", "committedDate": "2020-02-27T09:07:53Z", "type": "commit"}, {"oid": "b07df6cd1433cdb68c293dac6d64d9db6c388123", "url": "https://github.com/OpenNMS/opennms/commit/b07df6cd1433cdb68c293dac6d64d9db6c388123", "message": "NMS-12424: Fix more inconsistencies.", "committedDate": "2020-02-27T09:48:17Z", "type": "commit"}, {"oid": "57f3f74e32bb6caaed935569172d30874643c0c5", "url": "https://github.com/OpenNMS/opennms/commit/57f3f74e32bb6caaed935569172d30874643c0c5", "message": "NMS-12424: Fix rd", "committedDate": "2020-02-27T10:11:09Z", "type": "commit"}, {"oid": "eb071481a46d468aa23ac5f34fb7d04b1affad1c", "url": "https://github.com/OpenNMS/opennms/commit/eb071481a46d468aa23ac5f34fb7d04b1affad1c", "message": "NMS-12424: Remove prefix", "committedDate": "2020-02-27T10:13:35Z", "type": "commit"}, {"oid": "ab004edb698496a680dbf048e9f0318a3b48d7ab", "url": "https://github.com/OpenNMS/opennms/commit/ab004edb698496a680dbf048e9f0318a3b48d7ab", "message": "NMS-12424: Serialize null longs as 0s", "committedDate": "2020-02-27T11:52:05Z", "type": "commit"}, {"oid": "e5fe6d55c4ccd982de3dd82949e79a3453f0bc41", "url": "https://github.com/OpenNMS/opennms/commit/e5fe6d55c4ccd982de3dd82949e79a3453f0bc41", "message": "NMS-12424: Fixed long handling", "committedDate": "2020-02-27T20:12:25Z", "type": "commit"}, {"oid": "ae29ad62060a5f7e0d0d3284bf4c61987ac8e5a9", "url": "https://github.com/OpenNMS/opennms/commit/ae29ad62060a5f7e0d0d3284bf4c61987ac8e5a9", "message": "NMS-12424: Cleanup", "committedDate": "2020-02-27T20:51:05Z", "type": "commit"}, {"oid": "37d878e786fb6f8478b4d05614263ea357abb6f9", "url": "https://github.com/OpenNMS/opennms/commit/37d878e786fb6f8478b4d05614263ea357abb6f9", "message": "NMS-12424: More path attribute support.", "committedDate": "2020-02-27T23:00:08Z", "type": "commit"}, {"oid": "f16448dc942ccad4acbce854114fc2a2c2525216", "url": "https://github.com/OpenNMS/opennms/commit/f16448dc942ccad4acbce854114fc2a2c2525216", "message": "fix underflow?", "committedDate": "2020-02-27T23:10:59Z", "type": "commit"}, {"oid": "3a872a16cf7ad8691848752c61e2dc3b9e2723ff", "url": "https://github.com/OpenNMS/opennms/commit/3a872a16cf7ad8691848752c61e2dc3b9e2723ff", "message": "NMS-12424: More improved path attribute support.", "committedDate": "2020-02-28T14:38:46Z", "type": "commit"}, {"oid": "fa2c32a7b90ff0ad890cb3e23899034f503cd957", "url": "https://github.com/OpenNMS/opennms/commit/fa2c32a7b90ff0ad890cb3e23899034f503cd957", "message": "NMS-12424: Reference JIRA issue.", "committedDate": "2020-02-28T14:50:18Z", "type": "commit"}, {"oid": "9f626f518049b1493071e145636f0647909a4dec", "url": "https://github.com/OpenNMS/opennms/commit/9f626f518049b1493071e145636f0647909a4dec", "message": "NMS-12424: Cleanup", "committedDate": "2020-02-28T16:17:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMTE1MQ==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385831151", "bodyText": "Can we set a fake source rather than keeping it null? I'm thinking host=0.0.0.0 and port=0", "author": "j-white", "createdAt": "2020-02-28T17:40:36Z", "path": "features/telemetry/common/src/main/java/org/opennms/netmgt/telemetry/common/ipc/TelemetrySinkModule.java", "diffHunk": "@@ -120,17 +120,23 @@ public int getCompletionIntervalMs() {\n \n             @Override\n             public Object key(TelemetryMessage telemetryMessage) {\n-                return telemetryMessage.getSource();", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg3OTMyMg==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386879322", "bodyText": "Done.", "author": "fooker", "createdAt": "2020-03-03T09:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjM2MQ==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385832361", "bodyText": "Use BmpAdapterTools.addressAsStr", "author": "j-white", "createdAt": "2020-02-28T17:43:21Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/BmpTelemetryAdapter.java", "diffHunk": "@@ -111,7 +111,7 @@ public BmpTelemetryAdapter(final AdapterDefinition adapterConfig,\n         builder.withTimestamp(Date.from(timestamp(stats.getPeer().getTimestamp())));\n         builder.withStringAttribute(peerResource, \"bmp\", \"address\", peerAddress);\n         builder.withStringAttribute(peerResource, \"bmp\", \"as\", Long.toString(stats.getPeer().getAs()));\n-        builder.withStringAttribute(peerResource, \"bmp\", \"id\", Long.toString(stats.getPeer().getId()));\n+        builder.withStringAttribute(peerResource, \"bmp\", \"id\", InetAddressUtils.str(address(stats.getPeer().getId())));", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjYwNw==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385832607", "bodyText": "TODO", "author": "j-white", "createdAt": "2020-02-28T17:43:53Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpKafkaProducer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import java.util.Map;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.opennms.core.utils.StringUtils;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+\n+public class BmpKafkaProducer implements BmpMessageHandler {\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpKafkaProducer.class);\n+\n+    private final KafkaProducer<String, String> producer;\n+\n+    public BmpKafkaProducer(final AdapterDefinition adapterConfig) {\n+        this.producer = buildProducer(adapterConfig);\n+    }\n+\n+    private static KafkaProducer<String, String> buildProducer(final AdapterDefinition adapterConfig) {\n+        final Map<String, Object> kafkaConfig = Maps.newHashMap();\n+        for (final Map.Entry<String, String> entry : adapterConfig.getParameterMap().entrySet()) {\n+            StringUtils.truncatePrefix(entry.getKey(), \"kafka.\").ifPresent(key -> {\n+                kafkaConfig.put(key, entry.getValue());\n+            });\n+        }\n+\n+        // TODO fooker: Apply defaults (steal from https://github.com/SNAS/openbmp/blob/1a615a3c75a0143cc87ec70458471f0af67d3929/Server/src/kafka/MsgBusImpl_kafka.cpp#L162)", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUyNTU3Nw==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r387525577", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12574", "author": "fooker", "createdAt": "2020-03-04T08:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjczMA==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385832730", "bodyText": "FIXME", "author": "j-white", "createdAt": "2020-02-28T17:44:07Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpKafkaProducer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import java.util.Map;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.opennms.core.utils.StringUtils;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+\n+public class BmpKafkaProducer implements BmpMessageHandler {\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpKafkaProducer.class);\n+\n+    private final KafkaProducer<String, String> producer;\n+\n+    public BmpKafkaProducer(final AdapterDefinition adapterConfig) {\n+        this.producer = buildProducer(adapterConfig);\n+    }\n+\n+    private static KafkaProducer<String, String> buildProducer(final AdapterDefinition adapterConfig) {\n+        final Map<String, Object> kafkaConfig = Maps.newHashMap();\n+        for (final Map.Entry<String, String> entry : adapterConfig.getParameterMap().entrySet()) {\n+            StringUtils.truncatePrefix(entry.getKey(), \"kafka.\").ifPresent(key -> {\n+                kafkaConfig.put(key, entry.getValue());\n+            });\n+        }\n+\n+        // TODO fooker: Apply defaults (steal from https://github.com/SNAS/openbmp/blob/1a615a3c75a0143cc87ec70458471f0af67d3929/Server/src/kafka/MsgBusImpl_kafka.cpp#L162)\n+\n+        return new KafkaProducer<>(kafkaConfig, new StringSerializer(), new StringSerializer());\n+    }\n+\n+    @Override\n+    public void handle(Message message) {\n+        final StringBuffer buffer = new StringBuffer();\n+        message.serialize(buffer);\n+\n+        final String topic = message.getType().getTopic();\n+        // FIXME: Make prefix configurable", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUzNDczMA==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r387534730", "bodyText": "Implemented.", "author": "fooker", "createdAt": "2020-03-04T09:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzMjczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNTg0NA==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385835844", "bodyText": "This seems like a reasonable fix -  only set properties that are writeable - caveat is that it makes it harder to detect mis-configured properties.\nIf the property is not writeable, maybe we could call some known function on the bean to validate?", "author": "j-white", "createdAt": "2020-02-28T17:50:59Z", "path": "features/telemetry/registry/src/main/java/org/opennms/netmgt/telemetry/protocols/registry/impl/TelemetryServiceRegistryImpl.java", "diffHunk": "@@ -121,7 +121,13 @@ public T getService(BD beanDefinition) {\n             final T service = (T) registration.getServiceFactory().createBean(beanDefinition);\n \n             final BeanWrapper wrapper = PropertyAccessorFactory.forBeanPropertyAccess(service);\n-            wrapper.setPropertyValues(beanDefinition.getParameterMap());\n+//            wrapper.setPropertyValues(beanDefinition.getParameterMap());\n+            // TODO fooker: Workaround for unknown properties in BmpIntegrationAdapter (kafka.*)", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUyNDE0NA==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r387524144", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12573", "author": "fooker", "createdAt": "2020-03-04T08:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNTg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNjY1Nw==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385836657", "bodyText": "TODO: Async DNS resolution. Use address for now and defer to separate JIRA issue?", "author": "j-white", "createdAt": "2020-02-28T17:52:48Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg5MzYwMA==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386893600", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12569", "author": "fooker", "createdAt": "2020-03-03T09:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNjY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNjgwNQ==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385836805", "bodyText": "TODO: Implement not or defer to JIRA?", "author": "j-white", "createdAt": "2020-02-28T17:53:09Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = null;\n+        router.termCode = termination.getReason();\n+\n+        switch (router.termCode) {\n+            case 0:\n+                router.termReason = \"Session administratively closed.  The session might be re-initiated\";\n+                break;\n+            case 1:\n+                router.termReason = \"Unspecified reason\";\n+                break;\n+            case 2:\n+                router.termReason = \"Out of resources.  The router has exhausted resources available for the BMP session\";\n+                break;\n+            case 3:\n+                router.termReason = \"Redundant connection.  The router has determined that this connection is redundant with another one\";\n+                break;\n+            case 4:\n+                router.termReason = \"Session permanently administratively closed, will not be re-initiated\";\n+                break;\n+            default:\n+                router.termReason = \"Unknown reason\";\n+        }\n+\n+        router.initData = null;\n+        router.termData = termination.getMessage();\n+        router.timestamp = context.timestamp;\n+        router.bgpId = null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handlePeerUpNotification(final Transport.Message message,\n+                                          final Transport.PeerUpPacket peerUp,\n+                                          final Context context) {\n+        final Transport.Peer bgpPeer = peerUp.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.UP;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                                bgpPeer.getDistinguisher(),\n+                                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(peerUp.getRecvMsg().getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(peerUp.getRecvMsg().getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = peerUp.getRemotePort();\n+        peer.localAsn = uint32(peerUp.getSendMsg().getAs());\n+        peer.localIp = address(peerUp.getLocalAddress());\n+        peer.localPort = peerUp.getLocalPort();\n+        peer.localBgpId = address(peerUp.getSendMsg().getId());\n+        peer.infoData = peerUp.getMessage();\n+        peer.advertisedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.receivedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.remoteHolddown = uint32(peerUp.getRecvMsg().getHoldTime());\n+        peer.advertisedHolddown = uint32(peerUp.getSendMsg().getHoldTime());\n+        peer.bmpReason = null;\n+        peer.bgpErrorCode = null;\n+        peer.bgpErrorSubcode = null;\n+        peer.errorText = null;\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg5NDg0NQ==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386894845", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12570", "author": "fooker", "createdAt": "2020-03-03T09:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNjgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNzAyOQ==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r385837029", "bodyText": "FIXME: Defer?", "author": "j-white", "createdAt": "2020-02-28T17:53:38Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = null;\n+        router.termCode = termination.getReason();\n+\n+        switch (router.termCode) {\n+            case 0:\n+                router.termReason = \"Session administratively closed.  The session might be re-initiated\";\n+                break;\n+            case 1:\n+                router.termReason = \"Unspecified reason\";\n+                break;\n+            case 2:\n+                router.termReason = \"Out of resources.  The router has exhausted resources available for the BMP session\";\n+                break;\n+            case 3:\n+                router.termReason = \"Redundant connection.  The router has determined that this connection is redundant with another one\";\n+                break;\n+            case 4:\n+                router.termReason = \"Session permanently administratively closed, will not be re-initiated\";\n+                break;\n+            default:\n+                router.termReason = \"Unknown reason\";\n+        }\n+\n+        router.initData = null;\n+        router.termData = termination.getMessage();\n+        router.timestamp = context.timestamp;\n+        router.bgpId = null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handlePeerUpNotification(final Transport.Message message,\n+                                          final Transport.PeerUpPacket peerUp,\n+                                          final Context context) {\n+        final Transport.Peer bgpPeer = peerUp.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.UP;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                                bgpPeer.getDistinguisher(),\n+                                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(peerUp.getRecvMsg().getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(peerUp.getRecvMsg().getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = peerUp.getRemotePort();\n+        peer.localAsn = uint32(peerUp.getSendMsg().getAs());\n+        peer.localIp = address(peerUp.getLocalAddress());\n+        peer.localPort = peerUp.getLocalPort();\n+        peer.localBgpId = address(peerUp.getSendMsg().getId());\n+        peer.infoData = peerUp.getMessage();\n+        peer.advertisedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.receivedCapabilities = \"\"; // TODO: Not parsed right now\n+        peer.remoteHolddown = uint32(peerUp.getRecvMsg().getHoldTime());\n+        peer.advertisedHolddown = uint32(peerUp.getSendMsg().getHoldTime());\n+        peer.bmpReason = null;\n+        peer.bgpErrorCode = null;\n+        peer.bgpErrorSubcode = null;\n+        peer.errorText = null;\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.locRibFiltered = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.tableName = \"\"; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.PEER, ImmutableList.of(peer)));\n+    }\n+\n+    private void handlePeerDownNotification(final Transport.Message message,\n+                                            final Transport.PeerDownPacket peerDown,\n+                                            final Context context) {\n+        final Transport.Peer bgpPeer = peerDown.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.DOWN;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                bgpPeer.getDistinguisher(),\n+                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(bgpPeer.getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(bgpPeer.getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = null;\n+        peer.localAsn = null;\n+        peer.localIp = null;\n+        peer.localPort = null;\n+        peer.localBgpId = null;\n+        peer.infoData = null;\n+        peer.advertisedCapabilities = null;\n+        peer.receivedCapabilities = null;\n+        peer.remoteHolddown = null;\n+        peer.advertisedHolddown = null;\n+        peer.bmpReason = peerDown.getReasonCase().getNumber() - 1;\n+\n+        switch (peerDown.getReasonCase().getNumber()) {\n+            case 2:\n+                peer.bgpErrorCode = peerDown.getLocalBgpNotification().getCode();\n+                peer.bgpErrorSubcode = peerDown.getLocalBgpNotification().getSubcode();\n+                break;\n+            case 4:\n+                peer.bgpErrorCode = peerDown.getRemoteBgpNotification().getCode();\n+                peer.bgpErrorSubcode = peerDown.getRemoteBgpNotification().getSubcode();\n+                break;\n+            default:\n+                peer.bgpErrorCode = null;\n+                peer.bgpErrorSubcode = null;\n+        }\n+\n+        if (peer.bgpErrorCode != null && peer.bgpErrorSubcode != null) {\n+            peer.errorText = Error.from(peer.bgpErrorCode, peer.bgpErrorSubcode).getErrorText();\n+        }\n+\n+        peer.l3vpn = bgpPeer.getType() == Transport.Peer.Type.RD_INSTANCE;\n+        peer.prePolicy = bgpPeer.getFlags().getPolicy() == Transport.Peer.Flags.Policy.PRE_POLICY;\n+        peer.ipv4 = isV4(bgpPeer.getAddress());\n+        peer.locRib = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.locRibFiltered = false; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+        peer.tableName = \"\"; // TODO: Not implemented (see RFC draft-ietf-grow-bmp-loc-rib)\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.PEER, ImmutableList.of(peer)));\n+    }\n+\n+    private void handleStatisticReport(final Transport.Message message,\n+                                       final Transport.StatisticsReportPacket statisticsReport,\n+                                       final Context context) {\n+        final Transport.Peer peer = statisticsReport.getPeer();\n+\n+        final Stat stat = new Stat();\n+        stat.action = Stat.Action.ADD;\n+        stat.sequence = sequence.getAndIncrement();\n+        stat.routerHash = Record.hash(context.sourceAddress.getHostAddress(), Integer.toString(context.sourcePort), context.collectorHashId);\n+        stat.routerIp = context.sourceAddress;\n+        stat.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), stat.routerHash);\n+        stat.peerIp = address(peer.getAddress());\n+        stat.peerAsn = uint32(peer.getAs());\n+        stat.timestamp = timestamp(peer.getTimestamp());\n+        stat.prefixesRejected = statisticsReport.getRejected().getCount();\n+        stat.knownDupPrefixes = statisticsReport.getDuplicatePrefix().getCount();\n+        stat.knownDupWithdraws = statisticsReport.getDuplicateWithdraw().getCount();\n+        stat.invalidClusterList = statisticsReport.getInvalidUpdateDueToClusterListLoop().getCount();\n+        stat.invalidAsPath = statisticsReport.getInvalidUpdateDueToAsPathLoop().getCount();\n+        stat.invalidOriginatorId = statisticsReport.getInvalidUpdateDueToOriginatorId().getCount();\n+        stat.invalidAsConfed = statisticsReport.getInvalidUpdateDueToAsConfedLoop().getCount();\n+        stat.prefixesPrePolicy = statisticsReport.getAdjRibIn().getValue();\n+        stat.prefixesPostPolicy = statisticsReport.getLocRib().getValue();\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.BMP_STAT, ImmutableList.of(stat)));\n+    }\n+\n+    private BaseAttribute toBaseAttributeRecord(final Transport.RouteMonitoringPacket routeMonitoring,\n+                                                final Context context) {\n+        final Transport.Peer peer = routeMonitoring.getPeer();\n+\n+        final BaseAttribute baseAttr = new BaseAttribute();\n+        baseAttr.action = BaseAttribute.Action.ADD; // Action is always ADD - attributes are never withdrawn\n+        baseAttr.sequence = this.sequence.getAndIncrement();\n+        baseAttr.routerHash = context.getRouterHash();\n+        baseAttr.routerIp = context.sourceAddress;\n+        baseAttr.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), baseAttr.routerHash);\n+        baseAttr.peerIp = address(peer.getAddress());\n+        baseAttr.peerAsn = uint32(peer.getAs());\n+        baseAttr.timestamp = context.timestamp;\n+\n+        // Derive the origin of the prefix from the path attributes - default to an empty string if not set\n+        baseAttr.origin = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ORIGIN)\n+                .map(attr -> attr.getOrigin().name().toLowerCase()).orElse(\"\");\n+\n+        // Build the AS path from the path attributes - default to an empty string if not set\n+        // See UpdateMsg::parseAttr_AsPath in the OpenBMP collector for the corresponding logic\n+        baseAttr.asPathCount = 0;\n+\n+        baseAttr.asPath = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.AS_PATH)\n+                .map(asPathAttr -> {\n+                    final StringBuilder asPath = new StringBuilder();\n+\n+                    asPathAttr.getAsPath().getSegmentsList().forEach(segment -> {\n+                        if (Transport.RouteMonitoringPacket.PathAttribute.AsPath.Segment.Type.AS_SET.equals(segment.getType())) {\n+                            asPath.append(\"{\");\n+                        }\n+                        segment.getPathsList().forEach(segmentPath -> {\n+                            asPath.append(segmentPath);\n+                            asPath.append(\" \");\n+                            baseAttr.asPathCount++;\n+                            baseAttr.originAs = uint32(segmentPath);\n+                        });\n+                        if (Transport.RouteMonitoringPacket.PathAttribute.AsPath.Segment.Type.AS_SET.equals(segment.getType())) {\n+                            asPath.append(\"}\");\n+                        }\n+                    });\n+\n+                    return asPath.toString();\n+                })\n+                .orElse(\"\");\n+\n+        // Derive the next hop from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.NEXT_HOP)\n+                .map(attr -> attr.getNextHop().getAddress())\n+                .ifPresent(nextHop -> {\n+                    baseAttr.nextHop = address(nextHop);\n+                    baseAttr.nextHopIpv4 = isV4(nextHop);\n+                });\n+\n+        // Derive the Multi Exit Discriminator (MED) from the path attributes (lower values are preferred)\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.MULTI_EXIT_DISC)\n+                .map(attr -> attr.getMultiExitDisc().getDiscriminator())\n+                .ifPresent(med -> {\n+                    baseAttr.med = uint32(med);\n+                });\n+\n+        // Derive the local preference from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.LOCAL_PREF)\n+                .map(attr -> attr.getLocalPref().getPreference())\n+                .ifPresent(localPref -> {\n+                    baseAttr.localPref = uint32(localPref);\n+                });\n+\n+        // Derive the aggregator from the path attributes\n+        // See UpdateMsg::parseAttr_Aggegator in the OpenBMP collector for the corresponding logic\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.AGGREGATOR)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getAggregator)\n+                .ifPresent(agg -> {\n+                    baseAttr.aggregator = String.format(\"%d %s\", agg.getAs(), BmpAdapterTools.addressAsStr(agg.getAddress()));\n+                });\n+\n+        // Derive the community list from the path attributes\n+        baseAttr.communityList = getPathAttributesOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.COMMUNITY)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getCommunity)\n+                .map(BmpAdapterTools::asAttr)\n+                .collect(Collectors.joining(\" \"));\n+\n+        // Derive the extended community list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.EXTENDED_COMMUNITIES)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getExtendedCommunities)\n+                .ifPresent(extendedCommunities -> {\n+                    baseAttr.extCommunityList = extendedCommunities.getExtendedCommunitiesList().stream()\n+                            .map(extendedCommunity -> String.format(\"%d:%s\",\n+                                    uint32(extendedCommunity.getType()),\n+                                    extendedCommunity.getValue()))\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the cluster list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.CLUSTER_LIST)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getClusterList)\n+                .ifPresent(clusterList -> {\n+                    baseAttr.clusterList = clusterList.getClusterIdList().stream()\n+                            .map(BmpAdapterTools::addressAsStr)\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the large community list from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.LARGE_COMMUNITIES)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getLargeCommunities)\n+                .ifPresent(largeCommunities -> {\n+                    baseAttr.largeCommunityList = largeCommunities.getLargeCommunitiesList().stream()\n+                            .map(largeCommunity -> String.format(\"%d:%d:%d\",\n+                                    uint32(largeCommunity.getGlobalAdministrator()),\n+                                    uint32(largeCommunity.getLocalDataPart1()),\n+                                    uint32(largeCommunity.getLocalDataPart2())))\n+                            .collect(Collectors.joining(\" \"));\n+                });\n+\n+        // Derive the originator id from the path attributes\n+        getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ORIGINATOR_ID)\n+                .map(Transport.RouteMonitoringPacket.PathAttribute::getOriginatorId)\n+                .ifPresent(originatorId -> {\n+                    baseAttr.originatorId = Long.toString(uint32(originatorId));\n+                });\n+\n+        // Set the atomic flag is the atomic aggregate path attribute is present\n+        baseAttr.atomicAgg = getPathAttributeOfType(routeMonitoring, Transport.RouteMonitoringPacket.PathAttribute.ValueCase.ATOMIC_AGGREGATE)\n+                .isPresent();\n+\n+        // Compute hash - fields [ as path, next hop, aggregator, origin, med, local pref, community list, ext community list, peer hash ]\n+        baseAttr.hash = Record.hash(baseAttr.asPath,\n+                                    Record.nullSafeStr(baseAttr.nextHop),\n+                                    baseAttr.aggregator,\n+                                    baseAttr.origin,\n+                                    Record.nullSafeStr(baseAttr.med),\n+                                    Record.nullSafeStr(baseAttr.localPref),\n+                                    baseAttr.communityList,\n+                                    baseAttr.extCommunityList,\n+                                    baseAttr.peerHash);\n+\n+        return baseAttr;\n+    }\n+\n+    private UnicastPrefix toUnicastPrefixRecord(final Transport.RouteMonitoringPacket routeMonitoring,\n+                                                final Transport.RouteMonitoringPacket.Route route,\n+                                                final BaseAttribute baseAttr,\n+                                                final Context context) {\n+        final Transport.Peer peer = routeMonitoring.getPeer();\n+\n+        final UnicastPrefix unicastPrefix = new UnicastPrefix();\n+        unicastPrefix.sequence = this.sequence.incrementAndGet();\n+        unicastPrefix.routerHash = context.getRouterHash();\n+        unicastPrefix.routerIp = context.sourceAddress;\n+        unicastPrefix.peerHash = Record.hash(peer.getAddress(), peer.getDistinguisher(), unicastPrefix.routerHash);\n+        unicastPrefix.peerIp = address(peer.getAddress());\n+        unicastPrefix.peerAsn = uint32(peer.getAs());\n+        unicastPrefix.timestamp = context.timestamp;\n+        unicastPrefix.prefix = address(route.getPrefix());\n+        unicastPrefix.length = route.getLength();\n+        unicastPrefix.ipv4 = isV4(route.getPrefix());\n+        // TODO: Populate path id and labels attributes - see NMS-12560\n+        unicastPrefix.pathId = 0;\n+        unicastPrefix.labels = null;\n+        unicastPrefix.prePolicy = Transport.Peer.Flags.Policy.PRE_POLICY.equals(peer.getFlags().getPolicy());\n+\n+        // Augment with base attributes if present\n+        if (baseAttr != null) {\n+            unicastPrefix.baseAttrHash = baseAttr.hash;\n+            unicastPrefix.origin = baseAttr.origin;\n+            unicastPrefix.asPath = baseAttr.asPath;\n+            unicastPrefix.asPathCount = baseAttr.asPathCount;\n+            unicastPrefix.originAs = baseAttr.originAs;\n+            unicastPrefix.nextHop = baseAttr.nextHop;\n+            unicastPrefix.med = baseAttr.med;\n+            unicastPrefix.localPref = baseAttr.localPref;\n+            unicastPrefix.aggregator = baseAttr.aggregator;\n+            unicastPrefix.communityList = baseAttr.communityList;\n+            unicastPrefix.extCommunityList = baseAttr.extCommunityList;\n+            unicastPrefix.clusterList = baseAttr.clusterList;\n+            unicastPrefix.atomicAgg = baseAttr.atomicAgg;\n+            unicastPrefix.nextHopIpv4 = baseAttr.nextHopIpv4;\n+            unicastPrefix.originatorId = baseAttr.originatorId;\n+            unicastPrefix.largeCommunityList = baseAttr.largeCommunityList;\n+        }\n+        // FIXME: isAdjIn?", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkzNjA1OQ==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386936059", "bodyText": "Implemented.", "author": "fooker", "createdAt": "2020-03-03T10:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgzNzAyOQ=="}], "type": "inlineReview"}, {"oid": "4ec4af07201f097593dde90b449911ee4243c96c", "url": "https://github.com/OpenNMS/opennms/commit/4ec4af07201f097593dde90b449911ee4243c96c", "message": "NMS-12424: Use fake address instead of null source", "committedDate": "2020-03-03T09:17:50Z", "type": "commit"}, {"oid": "50d9be2f85ca875e470fd9d62367481d87c7df21", "url": "https://github.com/OpenNMS/opennms/commit/50d9be2f85ca875e470fd9d62367481d87c7df21", "message": "NMS12424: Cleanup", "committedDate": "2020-03-03T09:17:57Z", "type": "commit"}, {"oid": "50d9be2f85ca875e470fd9d62367481d87c7df21", "url": "https://github.com/OpenNMS/opennms/commit/50d9be2f85ca875e470fd9d62367481d87c7df21", "message": "NMS12424: Cleanup", "committedDate": "2020-03-03T09:17:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg5NjUwMg==", "url": "https://github.com/OpenNMS/opennms/pull/2904#discussion_r386896502", "bodyText": "Deferred to https://issues.opennms.org/browse/NMS-12571", "author": "fooker", "createdAt": "2020-03-03T09:34:41Z", "path": "features/telemetry/protocols/bmp/adapter/src/main/java/org/opennms/netmgt/telemetry/protocols/bmp/adapter/openbmp/BmpIntegrationAdapter.java", "diffHunk": "@@ -0,0 +1,724 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2019 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp;\n+\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.address;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.asAttr;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributeOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.getPathAttributesOfType;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.isV4;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.timestamp;\n+import static org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools.uint32;\n+\n+import java.net.InetAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLog;\n+import org.opennms.netmgt.telemetry.api.adapter.TelemetryMessageLogEntry;\n+import org.opennms.netmgt.telemetry.config.api.AdapterDefinition;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.BmpAdapterTools;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Message;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Record;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.Type;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.BaseAttribute;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Collector;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Peer;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Router;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.Stat;\n+import org.opennms.netmgt.telemetry.protocols.bmp.adapter.openbmp.proto.records.UnicastPrefix;\n+import org.opennms.netmgt.telemetry.protocols.bmp.transport.Transport;\n+import org.opennms.netmgt.telemetry.protocols.collection.AbstractAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+\n+public class BmpIntegrationAdapter extends AbstractAdapter {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(BmpIntegrationAdapter.class);\n+\n+    private final AtomicLong sequence = new AtomicLong();\n+\n+    private final BmpMessageHandler handler;\n+\n+    public enum Error {\n+        // Message Header Error\n+        CONNECTION_NOT_SYNCHRONIZED(\"Connection not synchronized\"),\n+        BAD_MESSAGE_LENGTH(\"Bad message header length\"),\n+        BAD_MESSAGE_TYPE(\"Bad message header type\"),\n+\n+        // Open Message Error\n+        UNSUPPORTED_VERSION_NUMBER(\"Unsupported BGP version\"),\n+        BAD_PEER_AS(\"Incorrect peer AS\"),\n+        BAD_BGP_IDENTIFIER(\"Bad BGP ID\"),\n+        UNSUPPORTED_OPTIONAL_PARAMETER(\"Unsupported optinal parameter\"),\n+        AUTHENTICATION_FAILURE(\"Authentication failure\"),\n+        UNACCEPTABLE_HOLD_TIME(\"Unacceptable hold time\"),\n+\n+        // Update Message Error\n+        MALFORMED_ATTRIBUTE_LIST(\"Malformed attribute list\"),\n+        UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE(\"Unrecognized well known attribute\"),\n+        MISSING_WELL_KNOWN_ATTRIBUTE(\"Missing well known attribute\"),\n+        ATTRIBUTE_FLAGS_ERROR(\"Update attribute flags error\"),\n+        ATTRIBUTE_LENGTH_ERROR(\"Update attribute length error\"),\n+        INVALID_ORIGIN_ATTRIBUTE(\"Invalid origin\"),\n+        ROUTING_LOOP(\"Routing loop\"),\n+        INVALID_NEXT_HOP_ATTRIBUTE(\"Invalid next hop address/attribute\"),\n+        OPTIONAL_ATTRIBUTE_ERROR(\"Update optional attribute error\"),\n+        INVALID_NETWORK_FIELD(\"Invalid network field\"),\n+        MALFORMED_AS_PATH(\"Malformed AS_PATH\"),\n+\n+        // Hold Timer Expired\n+        HOLD_TIMER_EXPIRED(\"Hold timer expired\"),\n+\n+        // FSM Error\n+        FSM_ERROR(\"FSM error\"),\n+\n+        // Cease\n+        MAXIMUM_NUMBER_OF_PREFIXES_REACHED(\"Maximum number of prefixes reached\"),\n+        ADMINISTRATIVE_SHUTDOWN(\"Administrative shutdown\"),\n+        PEER_DECONFIGURED(\"Peer de-configured\"),\n+        ADMINISTRATIVE_RESET(\"Administrative reset\"),\n+        CONNECTION_RESET(\"Connection rejected\"),\n+        OTHER_CONFIGURATION_CHANGE(\"Other configuration change\"),\n+        CONNECTION_COLLISION_RESOLUTION(\"Connection collision resolution\"),\n+        OUT_OF_RESOURCES(\"Maximum number of prefixes reached\"),\n+\n+        UNKNOWN(\"Unknown notification type\"),\n+        ;\n+\n+        private String errorText;\n+\n+        Error(final String errorText) {\n+            this.errorText = errorText;\n+        }\n+\n+        public String getErrorText() {\n+            return errorText;\n+        }\n+\n+        public static Error from(final int code, final int subcode) {\n+            switch ((code << 8) + subcode) {\n+                case (1 << 8) + 1: return CONNECTION_NOT_SYNCHRONIZED;\n+                case (1 << 8) + 2: return BAD_MESSAGE_LENGTH;\n+                case (1 << 8) + 3: return BAD_MESSAGE_TYPE;\n+\n+                case (2 << 8) + 1: return UNSUPPORTED_VERSION_NUMBER;\n+                case (2 << 8) + 2: return BAD_PEER_AS;\n+                case (2 << 8) + 3: return BAD_BGP_IDENTIFIER;\n+                case (2 << 8) + 4: return UNSUPPORTED_OPTIONAL_PARAMETER;\n+                case (2 << 8) + 5: return AUTHENTICATION_FAILURE;\n+                case (2 << 8) + 6: return UNACCEPTABLE_HOLD_TIME;\n+\n+                case (3 << 8) + 1: return MALFORMED_ATTRIBUTE_LIST;\n+                case (3 << 8) + 2: return UNRECOGNIZED_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 3: return MISSING_WELL_KNOWN_ATTRIBUTE;\n+                case (3 << 8) + 4: return ATTRIBUTE_FLAGS_ERROR;\n+                case (3 << 8) + 5: return ATTRIBUTE_LENGTH_ERROR;\n+                case (3 << 8) + 6: return INVALID_ORIGIN_ATTRIBUTE;\n+                case (3 << 8) + 7: return ROUTING_LOOP;\n+                case (3 << 8) + 8: return INVALID_NEXT_HOP_ATTRIBUTE;\n+                case (3 << 8) + 9: return OPTIONAL_ATTRIBUTE_ERROR;\n+                case (3 << 8) + 10: return INVALID_NETWORK_FIELD;\n+                case (3 << 8) + 11: return MALFORMED_AS_PATH;\n+\n+                case (4 << 8) + 1: return HOLD_TIMER_EXPIRED;\n+\n+                case (5 << 8) + 1: return FSM_ERROR;\n+\n+                case (6 << 8) + 1: return MAXIMUM_NUMBER_OF_PREFIXES_REACHED;\n+                case (6 << 8) + 2: return ADMINISTRATIVE_SHUTDOWN;\n+                case (6 << 8) + 3: return PEER_DECONFIGURED;\n+                case (6 << 8) + 4: return ADMINISTRATIVE_RESET;\n+                case (6 << 8) + 5: return CONNECTION_RESET;\n+                case (6 << 8) + 6: return OTHER_CONFIGURATION_CHANGE;\n+                case (6 << 8) + 7: return CONNECTION_COLLISION_RESOLUTION;\n+                case (6 << 8) + 8: return OUT_OF_RESOURCES;\n+\n+                default:\n+                    LOG.warn(\"Unknown Notification Packet Code: {}/{}\", code, subcode);\n+                    return UNKNOWN;\n+            }\n+        }\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = new BmpKafkaProducer(adapterConfig);\n+    }\n+\n+    public BmpIntegrationAdapter(final AdapterDefinition adapterConfig,\n+                                 final MetricRegistry metricRegistry,\n+                                 final BmpMessageHandler handler) {\n+        super(adapterConfig, metricRegistry);\n+        this.handler = Objects.requireNonNull(handler);\n+    }\n+\n+    private void handleHeartbeatMessage(final Transport.Message message,\n+                                        final Transport.Heartbeat heartbeat,\n+                                        final Context context) {\n+        final Collector collector = new Collector();\n+\n+        switch (heartbeat.getMode()) {\n+            case STARTED:\n+                collector.action = Collector.Action.STARTED;\n+                break;\n+            case STOPPED:\n+                collector.action = Collector.Action.STOPPED;\n+                break;\n+            case PERIODIC:\n+                collector.action = Collector.Action.HEARTBEAT;\n+                break;\n+            case CHANGE:\n+                collector.action = Collector.Action.CHANGE;\n+                break;\n+        }\n+\n+        collector.sequence = sequence.getAndIncrement();\n+        collector.adminId = context.adminId;\n+        collector.hash = context.collectorHashId;\n+        collector.routers = Lists.transform(heartbeat.getRoutersList(), BmpAdapterTools::address);\n+        collector.timestamp = context.timestamp;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.COLLECTOR, ImmutableList.of(collector)));\n+    }\n+\n+    private void handleInitiationMessage(final Transport.Message message,\n+                                         final Transport.InitiationPacket initiation,\n+                                         final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.INIT;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = initiation.getSysName();\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = initiation.getSysDesc();\n+        router.termCode = null;\n+        router.termReason = null;\n+        router.initData = initiation.getMessage();\n+        router.termData = null;\n+        router.timestamp = context.timestamp;\n+        router.bgpId = initiation.hasBgpId() ? BmpAdapterTools.address(initiation.getBgpId()) : null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handleTerminationMessage(final Transport.Message message,\n+                                          final Transport.TerminationPacket termination,\n+                                          final Context context) {\n+        final Router router = new Router();\n+        router.action = Router.Action.TERM;\n+        router.sequence = sequence.getAndIncrement();\n+        router.name = null;\n+//        router.name = InetAddressUtils.str(address(??.getAddress())); // TODO: resolve Ip via DNS?\n+        router.hash = context.routerHashId;\n+        router.ipAddress = context.sourceAddress;\n+        router.description = null;\n+        router.termCode = termination.getReason();\n+\n+        switch (router.termCode) {\n+            case 0:\n+                router.termReason = \"Session administratively closed.  The session might be re-initiated\";\n+                break;\n+            case 1:\n+                router.termReason = \"Unspecified reason\";\n+                break;\n+            case 2:\n+                router.termReason = \"Out of resources.  The router has exhausted resources available for the BMP session\";\n+                break;\n+            case 3:\n+                router.termReason = \"Redundant connection.  The router has determined that this connection is redundant with another one\";\n+                break;\n+            case 4:\n+                router.termReason = \"Session permanently administratively closed, will not be re-initiated\";\n+                break;\n+            default:\n+                router.termReason = \"Unknown reason\";\n+        }\n+\n+        router.initData = null;\n+        router.termData = termination.getMessage();\n+        router.timestamp = context.timestamp;\n+        router.bgpId = null;\n+\n+        this.handler.handle(new Message(context.collectorHashId, Type.ROUTER, ImmutableList.of(router)));\n+    }\n+\n+    private void handlePeerUpNotification(final Transport.Message message,\n+                                          final Transport.PeerUpPacket peerUp,\n+                                          final Context context) {\n+        final Transport.Peer bgpPeer = peerUp.getPeer();\n+\n+        final Peer peer = new Peer();\n+        peer.action = Peer.Action.UP;\n+        peer.sequence = sequence.getAndIncrement();\n+        peer.name = InetAddressUtils.str(address(bgpPeer.getAddress())); // TODO: resolve Ip via DNS?\n+        peer.hash = Record.hash(bgpPeer.getAddress(),\n+                                bgpPeer.getDistinguisher(),\n+                                context.routerHashId);\n+        peer.routerHash = context.routerHashId;\n+        peer.remoteBgpId = address(peerUp.getRecvMsg().getId());\n+        peer.routerIp = context.sourceAddress;\n+        peer.timestamp = timestamp(bgpPeer.getTimestamp());\n+        peer.remoteAsn = uint32(peerUp.getRecvMsg().getAs());\n+        peer.remoteIp = address(bgpPeer.getAddress());\n+        peer.peerRd = asAttr((int) bgpPeer.getDistinguisher());\n+        peer.remotePort = peerUp.getRemotePort();\n+        peer.localAsn = uint32(peerUp.getSendMsg().getAs());\n+        peer.localIp = address(peerUp.getLocalAddress());\n+        peer.localPort = peerUp.getLocalPort();\n+        peer.localBgpId = address(peerUp.getSendMsg().getId());\n+        peer.infoData = peerUp.getMessage();\n+        peer.advertisedCapabilities = \"\"; // TODO: Not parsed right now", "originalCommit": "9f626f518049b1493071e145636f0647909a4dec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c61963e234caa1420e9d41ed30fdbee69c33fae0", "url": "https://github.com/OpenNMS/opennms/commit/c61963e234caa1420e9d41ed30fdbee69c33fae0", "message": "NMS-12424: Added Issue references for TODOs", "committedDate": "2020-03-03T09:36:17Z", "type": "commit"}, {"oid": "ad9278205b1531a53eb57dc30075f1e1b29b7bff", "url": "https://github.com/OpenNMS/opennms/commit/ad9278205b1531a53eb57dc30075f1e1b29b7bff", "message": "NSM-12424: Add parsing for adjIn", "committedDate": "2020-03-03T11:02:09Z", "type": "commit"}, {"oid": "ad9278205b1531a53eb57dc30075f1e1b29b7bff", "url": "https://github.com/OpenNMS/opennms/commit/ad9278205b1531a53eb57dc30075f1e1b29b7bff", "message": "NSM-12424: Add parsing for adjIn", "committedDate": "2020-03-03T11:02:09Z", "type": "forcePushed"}, {"oid": "00e3bac15107d0f727dadeb8d69a4e6f7f3e06e7", "url": "https://github.com/OpenNMS/opennms/commit/00e3bac15107d0f727dadeb8d69a4e6f7f3e06e7", "message": "Revert \"NMS-12424: Disable CircleCI for now :)\"\n\nThis reverts commit c0f9339765f1479dffbab7518a01b92bfa226c32.", "committedDate": "2020-03-04T04:05:15Z", "type": "commit"}, {"oid": "6f86cb8a4ca87fbd1711e64bb96c5c04ca964a8e", "url": "https://github.com/OpenNMS/opennms/commit/6f86cb8a4ca87fbd1711e64bb96c5c04ca964a8e", "message": "NMS-12424: Make kafka prefix configurable", "committedDate": "2020-03-04T09:14:13Z", "type": "commit"}, {"oid": "6bb5ce3c576b61dfb0ce755cdba580d27c6fd71d", "url": "https://github.com/OpenNMS/opennms/commit/6bb5ce3c576b61dfb0ce755cdba580d27c6fd71d", "message": "NMS-12424: More deferred TODOs", "committedDate": "2020-03-04T09:14:14Z", "type": "commit"}, {"oid": "0aa7ee7fb58d638c21e23faa7696293ed908e476", "url": "https://github.com/OpenNMS/opennms/commit/0aa7ee7fb58d638c21e23faa7696293ed908e476", "message": "NMS-12424: Dedup code in test", "committedDate": "2020-03-04T09:20:43Z", "type": "commit"}]}