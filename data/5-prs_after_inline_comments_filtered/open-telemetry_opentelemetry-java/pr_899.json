{"pr_number": 899, "pr_title": "Make the HttpTraceContext be more forgiving in the face of invalid data.", "pr_createdAt": "2020-02-20T19:14:33Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/899", "timeline": [{"oid": "f00082890c9db551f6cf96bf2e67df577f9df65d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f00082890c9db551f6cf96bf2e67df577f9df65d", "message": "Make the HttpTraceContext be more forgiving in the face of invalid data.", "committedDate": "2020-02-20T18:58:30Z", "type": "commit"}, {"oid": "9cc1cf943d5d6682cb6bf67ed85e8ca39bdea675", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/9cc1cf943d5d6682cb6bf67ed85e8ca39bdea675", "message": "formatting", "committedDate": "2020-02-20T19:19:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI0NjE5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/899#discussion_r382246190", "bodyText": "If we always return Invalid why do we create exceptions, maybe just simply return Invalid from here.", "author": "bogdandrutu", "createdAt": "2020-02-20T20:42:30Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/HttpTraceContext.java", "diffHunk": "@@ -111,53 +114,66 @@\n   public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n     checkNotNull(carrier, \"carrier\");\n     checkNotNull(getter, \"getter\");\n-    TraceId traceId;\n-    SpanId spanId;\n-    TraceFlags traceFlags;\n     String traceparent = getter.get(carrier, TRACE_PARENT);\n     if (traceparent == null) {\n       return INVALID_SPAN_CONTEXT;\n     }\n+    SpanContext contextFromParentHeader;\n     try {\n-      // TODO(bdrutu): Do we need to verify that version is hex and that for the version\n-      // the length is the expected one?\n-      checkArgument(\n-          traceparent.charAt(TRACE_OPTION_OFFSET - 1) == TRACEPARENT_DELIMITER\n-              && (traceparent.length() == TRACEPARENT_HEADER_SIZE\n-                  || (traceparent.length() > TRACEPARENT_HEADER_SIZE\n-                      && traceparent.charAt(TRACEPARENT_HEADER_SIZE) == TRACEPARENT_DELIMITER))\n-              && traceparent.charAt(SPAN_ID_OFFSET - 1) == TRACEPARENT_DELIMITER\n-              && traceparent.charAt(TRACE_OPTION_OFFSET - 1) == TRACEPARENT_DELIMITER,\n-          \"Missing or malformed TRACEPARENT.\");\n-\n-      traceId = TraceId.fromLowerBase16(traceparent, TRACE_ID_OFFSET);\n-      spanId = SpanId.fromLowerBase16(traceparent, SPAN_ID_OFFSET);\n-      traceFlags = TraceFlags.fromLowerBase16(traceparent, TRACE_OPTION_OFFSET);\n+      contextFromParentHeader = extractContextFromTraceParent(traceparent);\n     } catch (IllegalArgumentException e) {\n-      throw new IllegalArgumentException(\"Invalid traceparent: \" + traceparent, e);\n+      logger.info(\"Unparseable traceparent header. Returning INVALID span context.\");\n+      return INVALID_SPAN_CONTEXT;\n     }\n \n-    String traceState = getter.get(carrier, TRACE_STATE);\n+    String traceStateHeader = getter.get(carrier, TRACE_STATE);\n     try {\n-      if (traceState == null || traceState.isEmpty()) {\n-        return SpanContext.createFromRemoteParent(traceId, spanId, traceFlags, TRACE_STATE_DEFAULT);\n-      }\n-      TraceState.Builder traceStateBuilder = TraceState.builder();\n-      String[] listMembers = TRACESTATE_ENTRY_DELIMITER_SPLIT_PATTERN.split(traceState);\n-      checkArgument(\n-          listMembers.length <= TRACESTATE_MAX_MEMBERS, \"TraceState has too many elements.\");\n-      // Iterate in reverse order because when call builder set the elements is added in the\n-      // front of the list.\n-      for (int i = listMembers.length - 1; i >= 0; i--) {\n-        String listMember = listMembers[i];\n-        int index = listMember.indexOf(TRACESTATE_KEY_VALUE_DELIMITER);\n-        checkArgument(index != -1, \"Invalid TraceState list-member format.\");\n-        traceStateBuilder.set(listMember.substring(0, index), listMember.substring(index + 1));\n+      if (traceStateHeader == null || traceStateHeader.isEmpty()) {\n+        return contextFromParentHeader;\n       }\n+      TraceState state = extractTraceState(traceStateHeader);\n       return SpanContext.createFromRemoteParent(\n-          traceId, spanId, traceFlags, traceStateBuilder.build());\n+          contextFromParentHeader.getTraceId(),\n+          contextFromParentHeader.getSpanId(),\n+          contextFromParentHeader.getTraceFlags(),\n+          state);\n     } catch (IllegalArgumentException e) {\n-      throw new IllegalArgumentException(\"Invalid tracestate: \" + traceState, e);\n+      logger.info(\"Unparseable tracestate header. Returning span context without state.\");\n+      return contextFromParentHeader;\n+    }\n+  }\n+\n+  private static SpanContext extractContextFromTraceParent(String traceparent) {\n+    // TODO(bdrutu): Do we need to verify that version is hex and that\n+    // for the version the length is the expected one?\n+    checkArgument(\n+        traceparent.charAt(TRACE_OPTION_OFFSET - 1) == TRACEPARENT_DELIMITER\n+            && (traceparent.length() == TRACEPARENT_HEADER_SIZE\n+                || (traceparent.length() > TRACEPARENT_HEADER_SIZE\n+                    && traceparent.charAt(TRACEPARENT_HEADER_SIZE) == TRACEPARENT_DELIMITER))\n+            && traceparent.charAt(SPAN_ID_OFFSET - 1) == TRACEPARENT_DELIMITER\n+            && traceparent.charAt(TRACE_OPTION_OFFSET - 1) == TRACEPARENT_DELIMITER,\n+        \"Missing or malformed TRACEPARENT.\");", "originalCommit": "9cc1cf943d5d6682cb6bf67ed85e8ca39bdea675", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI0NzM4MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/899#discussion_r382247381", "bodyText": "It's a great question. And a great answer. I'll make it so.  :)", "author": "jkwatson", "createdAt": "2020-02-20T20:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI0NjE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1NjE0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/899#discussion_r382256148", "bodyText": "cleaned this up a bit to not use exceptions where not currently necessary. We could get rid of some more exception handling by adding methods on the TraceId, SpanId to do format validation without exceptions.", "author": "jkwatson", "createdAt": "2020-02-20T21:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI0NjE5MA=="}], "type": "inlineReview"}, {"oid": "4486f14b9a6c8d39506527a2d978889765be7d62", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4486f14b9a6c8d39506527a2d978889765be7d62", "message": "don't use exceptions where not necessary", "committedDate": "2020-02-20T20:58:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3ODAyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/899#discussion_r382478020", "bodyText": "What about these? Especially a null carrier might make sense if I use a lambda or anonymous inner class as getter that already holds references to the actual carrier.", "author": "Oberon00", "createdAt": "2020-02-21T09:27:56Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/HttpTraceContext.java", "diffHunk": "@@ -111,53 +114,73 @@\n   public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n     checkNotNull(carrier, \"carrier\");", "originalCommit": "4486f14b9a6c8d39506527a2d978889765be7d62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5MDE1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/899#discussion_r382490154", "bodyText": "I think extract(getter.getCarrier(), getter) is more clean than using null here and there", "author": "thisthat", "createdAt": "2020-02-21T09:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3ODAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5MjY5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/899#discussion_r382492698", "bodyText": "I was thinking about:\nHttpResponse resp = ...;\nSpanContext sctx = format.extract(null, (c, key) -> resp.get(key))\nvs\nHttpResponse resp = ...;\nSpanContext sctx = format.extract(resp, (c, key) -> c.get(key))\nI think both are equally valid, and in any case, as mentioned in #895, the API/SDK must not use exceptions for error reporting.", "author": "Oberon00", "createdAt": "2020-02-21T09:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3ODAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1Mzk2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/899#discussion_r382653965", "bodyText": "I agree this is a valid way to call things. But, let's do that as a separate change; please open an issue about it if you feel we need to change this API to support it.", "author": "jkwatson", "createdAt": "2020-02-21T15:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3ODAyMA=="}], "type": "inlineReview"}]}