{"pr_number": 979, "pr_title": "Add B3 propagator", "pr_createdAt": "2020-03-09T17:24:31Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/979", "timeline": [{"oid": "52c620f3933e27ac488bf2965315db9e0c8de040", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/52c620f3933e27ac488bf2965315db9e0c8de040", "message": "add b3 propagator", "committedDate": "2020-03-09T16:08:19Z", "type": "commit"}, {"oid": "1d7718d859c184ea1ca3b052a56a1e2b71d15ca0", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1d7718d859c184ea1ca3b052a56a1e2b71d15ca0", "message": "add support for single combined b3 header", "committedDate": "2020-03-09T16:38:20Z", "type": "commit"}, {"oid": "b2b59aca43fe7ec28ad6d4131ad0c0df67b8292c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b2b59aca43fe7ec28ad6d4131ad0c0df67b8292c", "message": "add logging, refactor to add isValid methods", "committedDate": "2020-03-09T17:22:16Z", "type": "commit"}, {"oid": "b16ef35aa27ec57b3ea8d734e4391e9faa2df4e1", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b16ef35aa27ec57b3ea8d734e4391e9faa2df4e1", "message": "add more tests for single header bounds", "committedDate": "2020-03-09T17:33:55Z", "type": "commit"}, {"oid": "5e463b1234a03e7269096a5b062d11e372da102a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5e463b1234a03e7269096a5b062d11e372da102a", "message": "add tests for sampled flag using true/false", "committedDate": "2020-03-09T19:42:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMzE3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r389923176", "bodyText": "does this need to be a nullable big-b Boolean? Can't it just be a primitive boolean?", "author": "jkwatson", "createdAt": "2020-03-09T19:50:12Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {", "originalCommit": "5e463b1234a03e7269096a5b062d11e372da102a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIxNjY4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390216689", "bodyText": "Pushed an update - there is no need for a Boolean in this case.", "author": "MikeGoldsmith", "createdAt": "2020-03-10T10:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMzE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNDcyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r389924726", "bodyText": "This should be broken up into at least 2 separate methods. This method is definitely too long. One method for the single header case that returns the context, and one for the multi-header case that returns the context will make this code much easier to read. Thanks!", "author": "jkwatson", "createdAt": "2020-03-09T19:53:06Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"StringSplitter\")\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    String traceId;\n+    String spanId;\n+    String sampled;\n+    if (singleHeader) {", "originalCommit": "5e463b1234a03e7269096a5b062d11e372da102a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NjM1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r389946350", "bodyText": "I support this. The TraceContext one is refactored as it was too long and it was (relatively) hard to read.", "author": "carlosalberto", "createdAt": "2020-03-09T20:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNDcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMTY2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390131660", "bodyText": "The first two checks could leverage the StringUtils.isNullOrEmpty(value) method", "author": "thisthat", "createdAt": "2020-03-10T07:28:05Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"StringSplitter\")\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    String traceId;\n+    String spanId;\n+    String sampled;\n+    if (singleHeader) {\n+      String value = getter.get(carrier, COMBINED_HEADER);\n+      if (value == null || value.isEmpty()) {\n+        logger.info(\n+            \"Missing or empty combined header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      // must have between 2 and 4 hyphen delimieted parts:\n+      //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+      // NOTE: we do not use parentSpanId\n+      String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+      if (parts.length < 2 || parts.length > 4) {\n+        logger.info(\n+            \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      traceId = parts[0];\n+      if (!isTraceIdValid(traceId)) {\n+        logger.info(\n+            \"Invalid TraceId in B3 header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      spanId = parts[1];\n+      if (!isSpanIdValid(spanId)) {\n+        logger.info(\n+            \"Invalid SpanId in B3 header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      sampled = parts.length == 3 ? parts[2] : null;\n+    } else {\n+      traceId = getter.get(carrier, TRACE_ID_HEADER);\n+      if (!isTraceIdValid(traceId)) {\n+        logger.info(\n+            \"Invalid TraceId in B3 header: \"\n+                + TRACE_ID_HEADER\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      spanId = getter.get(carrier, SPAN_ID_HEADER);\n+      if (!isSpanIdValid(spanId)) {\n+        logger.info(\n+            \"Invalid SpanId in B3 header: \"\n+                + SPAN_ID_HEADER\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      sampled = getter.get(carrier, SAMPLED_HEADER);\n+    }\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),\n+          SpanId.fromLowerBase16(spanId, 0),\n+          traceFlags,\n+          TraceState.getDefault());\n+    } catch (Exception e) {\n+      logger.log(Level.INFO, \"Error parsing B3 header. Returning INVALID span context.\", e);\n+      return SpanContext.getInvalid();\n+    }\n+  }\n+\n+  private static boolean isTraceIdValid(String value) {\n+    return !(value == null || value.isEmpty() || value.length() > MAX_TRACE_ID_LENGTH);", "originalCommit": "5e463b1234a03e7269096a5b062d11e372da102a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIxNjMyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390216329", "bodyText": "Thanks - I've pushed an update to use StringUtils.", "author": "MikeGoldsmith", "createdAt": "2020-03-10T10:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMTY2MA=="}], "type": "inlineReview"}, {"oid": "e84180529a39a0f559ff61f98d096e1ebbd032ba", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e84180529a39a0f559ff61f98d096e1ebbd032ba", "message": "prefer StringUtils.isNullOrEmpty over indivudual checks", "committedDate": "2020-03-10T10:19:42Z", "type": "commit"}, {"oid": "04c47c6988a24ec479ce286d731a2dcb71777af7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/04c47c6988a24ec479ce286d731a2dcb71777af7", "message": "update constructor to take primitive boolean parameter", "committedDate": "2020-03-10T10:21:23Z", "type": "commit"}, {"oid": "0d519f84264ae7cd82d5997b8e19259bbf2cf12a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0d519f84264ae7cd82d5997b8e19259bbf2cf12a", "message": "refactor extract into single and multi header methods", "committedDate": "2020-03-10T10:35:35Z", "type": "commit"}, {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "message": "move supporession warning to new method", "committedDate": "2020-03-10T11:13:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1ODM1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390658354", "bodyText": "We don't use checker framework so no need to add the comment about non-null.", "author": "bogdandrutu", "createdAt": "2020-03-10T22:57:07Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {", "originalCommit": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNzExOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391037119", "bodyText": "Removed \ud83d\udc4d", "author": "MikeGoldsmith", "createdAt": "2020-03-11T15:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1ODM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTM5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390659399", "bodyText": "You can construct a sampled/notSampled TraceFlags and reuse them.", "author": "bogdandrutu", "createdAt": "2020-03-10T23:00:27Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromMultipleHeaders(\n+      C carrier, Getter<C> getter) {\n+    String traceId = getter.get(carrier, TRACE_ID_HEADER);\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \"\n+              + TRACE_ID_HEADER\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = getter.get(carrier, SPAN_ID_HEADER);\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + SPAN_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = getter.get(carrier, SAMPLED_HEADER);\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();", "originalCommit": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTc4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390659788", "bodyText": "This requires traceId (string) to be 32 hex characters and we only check that the size is not greater than MAX_TRACE_ID_LENGTH.", "author": "bogdandrutu", "createdAt": "2020-03-10T23:01:35Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromMultipleHeaders(\n+      C carrier, Getter<C> getter) {\n+    String traceId = getter.get(carrier, TRACE_ID_HEADER);\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \"\n+              + TRACE_ID_HEADER\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = getter.get(carrier, SPAN_ID_HEADER);\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + SPAN_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = getter.get(carrier, SAMPLED_HEADER);\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),", "originalCommit": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NjIyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391096222", "bodyText": "Pushed change to left pad TraceIds upto max with leading 0's. I added padLeft to StringUtils. Let me know what you think.", "author": "MikeGoldsmith", "createdAt": "2020-03-11T16:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxNzY3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391717673", "bodyText": "As this was fixed along with a test (see https://github.com/open-telemetry/opentelemetry-java/pull/979/files#diff-004fb9fadd7caedae3844dfe8b040186R137) I'm marking this as resolved.", "author": "carlosalberto", "createdAt": "2020-03-12T15:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDAyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390660025", "bodyText": "Should we have 2 propagators: legacy + single-header? I think that simplifies the code. We can do it later.", "author": "bogdandrutu", "createdAt": "2020-03-10T23:02:20Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {", "originalCommit": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzODgzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391038830", "bodyText": "Created #999 to track breaking single and multiple header implementations.", "author": "MikeGoldsmith", "createdAt": "2020-03-11T15:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDQ2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390660465", "bodyText": "Based on my understanding sampled is present if parts.length is 3 or 4 :)", "author": "bogdandrutu", "createdAt": "2020-03-10T23:03:41Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;", "originalCommit": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0MDk5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391040997", "bodyText": "You're correct. We need to check the sampled string if we have three or more items in the array.", "author": "MikeGoldsmith", "createdAt": "2020-03-11T15:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDQ2NQ=="}], "type": "inlineReview"}, {"oid": "c8265db69379df1067ba45f0ba04adc628095249", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c8265db69379df1067ba45f0ba04adc628095249", "message": "use constant sampled/not sampled TraceFalgs", "committedDate": "2020-03-11T15:01:27Z", "type": "commit"}, {"oid": "b586a07ae100c38f5827a4fc0f340d3a421d59ae", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b586a07ae100c38f5827a4fc0f340d3a421d59ae", "message": "remove unnecessary generic type checks", "committedDate": "2020-03-11T15:02:43Z", "type": "commit"}, {"oid": "84d15f37376e442e03b8975f0e2a899aa8c2588f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/84d15f37376e442e03b8975f0e2a899aa8c2588f", "message": "use sampled string if there are 3 or 4 items in the array", "committedDate": "2020-03-11T15:22:38Z", "type": "commit"}, {"oid": "194ba936639b44ac2d2beb8fd8270e3851d91fd2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/194ba936639b44ac2d2beb8fd8270e3851d91fd2", "message": "pad traceID upto 32 chars if needed\n\n- adds StringUtils.padString and tests", "committedDate": "2020-03-11T16:20:55Z", "type": "commit"}, {"oid": "fd1a041f43bb7bdeba1a695eadee4e8728e10d43", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/fd1a041f43bb7bdeba1a695eadee4e8728e10d43", "message": "fix padLeft unit tests", "committedDate": "2020-03-11T16:30:53Z", "type": "commit"}, {"oid": "7d755e94c116d404e8d452fab3a65b224ed21569", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7d755e94c116d404e8d452fab3a65b224ed21569", "message": "update padLeft method & param descriptions", "committedDate": "2020-03-11T16:33:01Z", "type": "commit"}]}