{"pr_number": 1052, "pr_title": "Add Prometheus exporter", "pr_createdAt": "2020-03-29T19:05:35Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052", "timeline": [{"oid": "14879494bd0fbe790f9a4cdf74f87a13d35a8fd4", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/14879494bd0fbe790f9a4cdf74f87a13d35a8fd4", "message": "Add Prometheus exporter\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-29T19:33:52Z", "type": "forcePushed"}, {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0f65842028d39e3f176e73a9913d78d7e87cc015", "message": "Add Prometheus exporter\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-29T19:53:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MzgwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399943807", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n          \n          \n            \n             * Summary} will be converted to two {@link Sample}s (sum and count) plus the number of Percentile values {@code", "author": "thisthat", "createdAt": "2020-03-30T06:00:29Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code", "originalCommit": "0f65842028d39e3f176e73a9913d78d7e87cc015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NjE2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399946163", "bodyText": "Given the Javadoc at the beginning of the class, I would expect a join by an underscore.\nFurthermore, one less string replace \ud83d\ude09\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);\n          \n          \n            \n                return Collector.sanitizeMetricName(instrumentationLibraryName + \"_\" + descriptorMetricName);", "author": "thisthat", "createdAt": "2020-03-30T06:08:06Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n+ * Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);", "originalCommit": "0f65842028d39e3f176e73a9913d78d7e87cc015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDE5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399950190", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          new MetricFamilySamples.Sample(\n          \n          \n            \n                          new Sample(", "author": "thisthat", "createdAt": "2020-03-30T06:20:00Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n+ * Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {\n+    final List<Sample> samples =\n+        new ArrayList<>(estimateNumSamples(points.size(), descriptor.getType()));\n+\n+    List<String> constLabelNames = Collections.emptyList();\n+    List<String> constLabelValues = Collections.emptyList();\n+    if (descriptor.getConstantLabels().size() != 0) {\n+      constLabelNames = new ArrayList<>(descriptor.getConstantLabels().size());\n+      constLabelValues = new ArrayList<>(descriptor.getConstantLabels().size());\n+      for (Map.Entry<String, String> entry : descriptor.getConstantLabels().entrySet()) {\n+        constLabelNames.add(toLabelName(entry.getKey()));\n+        constLabelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+      }\n+    }\n+\n+    for (Point point : points) {\n+      List<String> labelNames = Collections.emptyList();\n+      List<String> labelValues = Collections.emptyList();\n+      if (constLabelNames.size() + point.getLabels().size() != 0) {\n+        labelNames =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelNames.addAll(constLabelNames);\n+        labelValues =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelValues.addAll(constLabelValues);\n+\n+        for (Map.Entry<String, String> entry : point.getLabels().entrySet()) {\n+          // TODO: Use a cache(map) of converted label names to avoid sanitization multiple times\n+          // for the same label key.\n+          labelNames.add(toLabelName(entry.getKey()));\n+          labelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+        }\n+      }\n+\n+      switch (descriptor.getType()) {\n+        case MONOTONIC_DOUBLE:\n+        case NON_MONOTONIC_DOUBLE:\n+          DoublePoint doublePoint = (DoublePoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, doublePoint.getValue()));\n+          break;\n+        case MONOTONIC_LONG:\n+        case NON_MONOTONIC_LONG:\n+          LongPoint longPoint = (LongPoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, longPoint.getValue()));\n+          break;\n+        case SUMMARY:\n+          SummaryPoint summaryPoint = (SummaryPoint) point;\n+          samples.add(\n+              new MetricFamilySamples.Sample(", "originalCommit": "0f65842028d39e3f176e73a9913d78d7e87cc015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDM5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399950397", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          new MetricFamilySamples.Sample(\n          \n          \n            \n                          new Sample(", "author": "thisthat", "createdAt": "2020-03-30T06:20:35Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n+ * Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {\n+    final List<Sample> samples =\n+        new ArrayList<>(estimateNumSamples(points.size(), descriptor.getType()));\n+\n+    List<String> constLabelNames = Collections.emptyList();\n+    List<String> constLabelValues = Collections.emptyList();\n+    if (descriptor.getConstantLabels().size() != 0) {\n+      constLabelNames = new ArrayList<>(descriptor.getConstantLabels().size());\n+      constLabelValues = new ArrayList<>(descriptor.getConstantLabels().size());\n+      for (Map.Entry<String, String> entry : descriptor.getConstantLabels().entrySet()) {\n+        constLabelNames.add(toLabelName(entry.getKey()));\n+        constLabelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+      }\n+    }\n+\n+    for (Point point : points) {\n+      List<String> labelNames = Collections.emptyList();\n+      List<String> labelValues = Collections.emptyList();\n+      if (constLabelNames.size() + point.getLabels().size() != 0) {\n+        labelNames =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelNames.addAll(constLabelNames);\n+        labelValues =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelValues.addAll(constLabelValues);\n+\n+        for (Map.Entry<String, String> entry : point.getLabels().entrySet()) {\n+          // TODO: Use a cache(map) of converted label names to avoid sanitization multiple times\n+          // for the same label key.\n+          labelNames.add(toLabelName(entry.getKey()));\n+          labelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+        }\n+      }\n+\n+      switch (descriptor.getType()) {\n+        case MONOTONIC_DOUBLE:\n+        case NON_MONOTONIC_DOUBLE:\n+          DoublePoint doublePoint = (DoublePoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, doublePoint.getValue()));\n+          break;\n+        case MONOTONIC_LONG:\n+        case NON_MONOTONIC_LONG:\n+          LongPoint longPoint = (LongPoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, longPoint.getValue()));\n+          break;\n+        case SUMMARY:\n+          SummaryPoint summaryPoint = (SummaryPoint) point;\n+          samples.add(\n+              new MetricFamilySamples.Sample(\n+                  name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, summaryPoint.getCount()));\n+          samples.add(\n+              new MetricFamilySamples.Sample(", "originalCommit": "0f65842028d39e3f176e73a9913d78d7e87cc015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDY2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399950661", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new MetricFamilySamples.Sample(\n          \n          \n            \n                            new Sample(", "author": "thisthat", "createdAt": "2020-03-30T06:21:14Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n+ * Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {\n+    final List<Sample> samples =\n+        new ArrayList<>(estimateNumSamples(points.size(), descriptor.getType()));\n+\n+    List<String> constLabelNames = Collections.emptyList();\n+    List<String> constLabelValues = Collections.emptyList();\n+    if (descriptor.getConstantLabels().size() != 0) {\n+      constLabelNames = new ArrayList<>(descriptor.getConstantLabels().size());\n+      constLabelValues = new ArrayList<>(descriptor.getConstantLabels().size());\n+      for (Map.Entry<String, String> entry : descriptor.getConstantLabels().entrySet()) {\n+        constLabelNames.add(toLabelName(entry.getKey()));\n+        constLabelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+      }\n+    }\n+\n+    for (Point point : points) {\n+      List<String> labelNames = Collections.emptyList();\n+      List<String> labelValues = Collections.emptyList();\n+      if (constLabelNames.size() + point.getLabels().size() != 0) {\n+        labelNames =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelNames.addAll(constLabelNames);\n+        labelValues =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelValues.addAll(constLabelValues);\n+\n+        for (Map.Entry<String, String> entry : point.getLabels().entrySet()) {\n+          // TODO: Use a cache(map) of converted label names to avoid sanitization multiple times\n+          // for the same label key.\n+          labelNames.add(toLabelName(entry.getKey()));\n+          labelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+        }\n+      }\n+\n+      switch (descriptor.getType()) {\n+        case MONOTONIC_DOUBLE:\n+        case NON_MONOTONIC_DOUBLE:\n+          DoublePoint doublePoint = (DoublePoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, doublePoint.getValue()));\n+          break;\n+        case MONOTONIC_LONG:\n+        case NON_MONOTONIC_LONG:\n+          LongPoint longPoint = (LongPoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, longPoint.getValue()));\n+          break;\n+        case SUMMARY:\n+          SummaryPoint summaryPoint = (SummaryPoint) point;\n+          samples.add(\n+              new MetricFamilySamples.Sample(\n+                  name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, summaryPoint.getCount()));\n+          samples.add(\n+              new MetricFamilySamples.Sample(\n+                  name + SAMPLE_SUFFIX_SUM, labelNames, labelValues, summaryPoint.getSum()));\n+          List<ValueAtPercentile> valueAtPercentiles = summaryPoint.getPercentileValues();\n+          List<String> labelNamesWithQuantile = new ArrayList<>(labelNames.size());\n+          labelNamesWithQuantile.addAll(labelNames);\n+          labelNamesWithQuantile.add(LABEL_NAME_QUANTILE);\n+          for (ValueAtPercentile valueAtPercentile : valueAtPercentiles) {\n+            List<String> labelValuesWithQuantile = new ArrayList<>(labelValues.size());\n+            labelValuesWithQuantile.addAll(labelValues);\n+            labelValuesWithQuantile.add(doubleToGoString(valueAtPercentile.getPercentile()));\n+            samples.add(\n+                new MetricFamilySamples.Sample(", "originalCommit": "0f65842028d39e3f176e73a9913d78d7e87cc015", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MzUwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399953505", "bodyText": "This is not clear to me. Maybe \"Sets the metric producer for the collector\"?", "author": "thisthat", "createdAt": "2020-03-30T06:29:29Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/PrometheusCollector.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.export.MetricProducer;\n+import io.prometheus.client.Collector;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public final class PrometheusCollector extends Collector {\n+  private final MetricProducer metricProducer;\n+\n+  private PrometheusCollector(MetricProducer metricProducer) {\n+    this.metricProducer = metricProducer;\n+  }\n+\n+  @Override\n+  public List<MetricFamilySamples> collect() {\n+    Collection<MetricData> allMetrics = metricProducer.getAllMetrics();\n+    List<MetricFamilySamples> allSamples = new ArrayList<>(allMetrics.size());\n+    for (MetricData metricData : allMetrics) {\n+      allSamples.add(MetricAdapter.toMetricFamilySamples(metricData));\n+    }\n+    return allSamples;\n+  }\n+\n+  /**\n+   * Returns a new builder instance for this exporter.\n+   *\n+   * @return a new builder instance for this exporter.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private MetricProducer metricProducer;\n+\n+    /**\n+     * Sets the managed chanel to use when communicating with the backend. Required.", "originalCommit": "0f65842028d39e3f176e73a9913d78d7e87cc015", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMjAxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r400532016", "bodyText": "I failed on copy-paste test :)", "author": "bogdandrutu", "createdAt": "2020-03-30T22:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MzUwNQ=="}], "type": "inlineReview"}, {"oid": "b797b42a82857395d141c3dac2966c5d54c6e17c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b797b42a82857395d141c3dac2966c5d54c6e17c", "message": "Add Prometheus exporter\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-30T22:21:21Z", "type": "forcePushed"}, {"oid": "f1235283e62c6f9973ad15062c69e1c0f696b1cd", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f1235283e62c6f9973ad15062c69e1c0f696b1cd", "message": "Add Prometheus exporter\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-30T22:23:11Z", "type": "forcePushed"}, {"oid": "f8d7ab7e52f40bfb7c6cc37d9c0249fdc32c4fc3", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f8d7ab7e52f40bfb7c6cc37d9c0249fdc32c4fc3", "message": "Add Prometheus exporter\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-30T22:27:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY1MTE4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r400651187", "bodyText": "Since it is required, should this method check for not null?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  this.metricProducer = metricProducer;\n          \n          \n            \n            \t  Utils.checkNotNull(metricProducer, \"metricProducer\");\n          \n          \n            \n                  this.metricProducer = metricProducer;", "author": "thisthat", "createdAt": "2020-03-31T05:26:01Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/PrometheusCollector.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.export.MetricProducer;\n+import io.prometheus.client.Collector;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public final class PrometheusCollector extends Collector {\n+  private final MetricProducer metricProducer;\n+\n+  private PrometheusCollector(MetricProducer metricProducer) {\n+    this.metricProducer = metricProducer;\n+  }\n+\n+  @Override\n+  public List<MetricFamilySamples> collect() {\n+    Collection<MetricData> allMetrics = metricProducer.getAllMetrics();\n+    List<MetricFamilySamples> allSamples = new ArrayList<>(allMetrics.size());\n+    for (MetricData metricData : allMetrics) {\n+      allSamples.add(MetricAdapter.toMetricFamilySamples(metricData));\n+    }\n+    return allSamples;\n+  }\n+\n+  /**\n+   * Returns a new builder instance for this exporter.\n+   *\n+   * @return a new builder instance for this exporter.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private MetricProducer metricProducer;\n+\n+    /**\n+     * Sets the metric producer for the collector. Required.\n+     *\n+     * @param metricProducer the {@link MetricProducer} to use.\n+     * @return this builder's instance.\n+     */\n+    public Builder setMetricProducer(MetricProducer metricProducer) {\n+      this.metricProducer = metricProducer;", "originalCommit": "f8d7ab7e52f40bfb7c6cc37d9c0249fdc32c4fc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0MTgxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r401041819", "bodyText": "Done in the build to ensure that it was called before calling build (required semantic).", "author": "bogdandrutu", "createdAt": "2020-03-31T16:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY1MTE4Nw=="}], "type": "inlineReview"}, {"oid": "90a54dddb10ae4d393584495d152ac1b2c576e1e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/90a54dddb10ae4d393584495d152ac1b2c576e1e", "message": "Add Prometheus exporter\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-31T16:13:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMTg4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r401211883", "bodyText": "this method is gigantic. Would be good to refactor it into smaller chunks.", "author": "jkwatson", "createdAt": "2020-03-31T20:59:38Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two {@link Sample}s (sum and count) plus the number of Percentile\n+ * values {@code Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    // Use \"_\" here even though the right way would be to use \".\" in general, but \".\" will be\n+    // replaced with \"_\" anyway so one less replace call.\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \"_\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {", "originalCommit": "90a54dddb10ae4d393584495d152ac1b2c576e1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTY5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r401319690", "bodyText": "A bit of splitting :)", "author": "bogdandrutu", "createdAt": "2020-04-01T02:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMTg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMjU4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r401212583", "bodyText": "not sure if it might read better to have return numPoints; as the default block in the switch.", "author": "jkwatson", "createdAt": "2020-03-31T21:00:57Z", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two {@link Sample}s (sum and count) plus the number of Percentile\n+ * values {@code Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    // Use \"_\" here even though the right way would be to use \".\" in general, but \".\" will be\n+    // replaced with \"_\" anyway so one less replace call.\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \"_\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {\n+    final List<Sample> samples =\n+        new ArrayList<>(estimateNumSamples(points.size(), descriptor.getType()));\n+\n+    List<String> constLabelNames = Collections.emptyList();\n+    List<String> constLabelValues = Collections.emptyList();\n+    if (descriptor.getConstantLabels().size() != 0) {\n+      constLabelNames = new ArrayList<>(descriptor.getConstantLabels().size());\n+      constLabelValues = new ArrayList<>(descriptor.getConstantLabels().size());\n+      for (Map.Entry<String, String> entry : descriptor.getConstantLabels().entrySet()) {\n+        constLabelNames.add(toLabelName(entry.getKey()));\n+        constLabelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+      }\n+    }\n+\n+    for (Point point : points) {\n+      List<String> labelNames = Collections.emptyList();\n+      List<String> labelValues = Collections.emptyList();\n+      if (constLabelNames.size() + point.getLabels().size() != 0) {\n+        labelNames =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelNames.addAll(constLabelNames);\n+        labelValues =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelValues.addAll(constLabelValues);\n+\n+        for (Map.Entry<String, String> entry : point.getLabels().entrySet()) {\n+          // TODO: Use a cache(map) of converted label names to avoid sanitization multiple times\n+          // for the same label key.\n+          labelNames.add(toLabelName(entry.getKey()));\n+          labelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+        }\n+      }\n+\n+      switch (descriptor.getType()) {\n+        case MONOTONIC_DOUBLE:\n+        case NON_MONOTONIC_DOUBLE:\n+          DoublePoint doublePoint = (DoublePoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, doublePoint.getValue()));\n+          break;\n+        case MONOTONIC_LONG:\n+        case NON_MONOTONIC_LONG:\n+          LongPoint longPoint = (LongPoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, longPoint.getValue()));\n+          break;\n+        case SUMMARY:\n+          SummaryPoint summaryPoint = (SummaryPoint) point;\n+          samples.add(\n+              new Sample(\n+                  name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, summaryPoint.getCount()));\n+          samples.add(\n+              new Sample(name + SAMPLE_SUFFIX_SUM, labelNames, labelValues, summaryPoint.getSum()));\n+          List<ValueAtPercentile> valueAtPercentiles = summaryPoint.getPercentileValues();\n+          List<String> labelNamesWithQuantile = new ArrayList<>(labelNames.size());\n+          labelNamesWithQuantile.addAll(labelNames);\n+          labelNamesWithQuantile.add(LABEL_NAME_QUANTILE);\n+          for (ValueAtPercentile valueAtPercentile : valueAtPercentiles) {\n+            List<String> labelValuesWithQuantile = new ArrayList<>(labelValues.size());\n+            labelValuesWithQuantile.addAll(labelValues);\n+            labelValuesWithQuantile.add(doubleToGoString(valueAtPercentile.getPercentile()));\n+            samples.add(\n+                new Sample(\n+                    name,\n+                    labelNamesWithQuantile,\n+                    labelValuesWithQuantile,\n+                    valueAtPercentile.getValue()));\n+          }\n+          break;\n+      }\n+    }\n+    return samples;\n+  }\n+\n+  // Converts a label keys to a label names. Sanitizes the label keys.\n+  static String toLabelName(String labelKey) {\n+    return Collector.sanitizeMetricName(labelKey);\n+  }\n+\n+  private static int estimateNumSamples(int numPoints, Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return numPoints;\n+      case SUMMARY:\n+        // count + sum + estimated 2 percentiles (default MinMaxSumCount aggregator).\n+        return numPoints * 4;\n+    }\n+    return numPoints;", "originalCommit": "90a54dddb10ae4d393584495d152ac1b2c576e1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1610e8af68ed809478064be9befc1068bf92cfb", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b1610e8af68ed809478064be9befc1068bf92cfb", "message": "Add Prometheus exporter\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-04-01T02:18:32Z", "type": "commit"}, {"oid": "99f54a81b40305e634196da305c75bcb5055d8d5", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/99f54a81b40305e634196da305c75bcb5055d8d5", "message": "Split toSample\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-04-01T02:22:38Z", "type": "commit"}, {"oid": "99f54a81b40305e634196da305c75bcb5055d8d5", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/99f54a81b40305e634196da305c75bcb5055d8d5", "message": "Split toSample\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-04-01T02:22:38Z", "type": "forcePushed"}]}