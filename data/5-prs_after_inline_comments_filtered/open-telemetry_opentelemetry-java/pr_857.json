{"pr_number": 857, "pr_title": "Move Aggregation and connect it with Aggregator.", "pr_createdAt": "2020-02-13T20:25:23Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/857", "timeline": [{"oid": "c7fb653a5f2e7df696ff932c8f1e20654cf160bf", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c7fb653a5f2e7df696ff932c8f1e20654cf160bf", "message": "Move Aggregation and connect it with Aggregator.\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-02-13T20:24:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwODkzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/857#discussion_r379108932", "bodyText": "I think this is a no-op check, since the array that is created will always be non-null.", "author": "jkwatson", "createdAt": "2020-02-13T20:45:26Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.aggregator.DoubleSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.LongSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.NoopAggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor.Type;\n+import javax.annotation.concurrent.Immutable;\n+\n+public class Aggregations {\n+\n+  /**\n+   * Aggregation that calculates sum of recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation sum() {\n+    return Sum.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates count of recorded measurements (the number of recorded\n+   * measurements).\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation count() {\n+    return Count.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates distribution stats on recorded measurements. Distribution includes\n+   * sum, count, histogram, and sum of squared deviations.\n+   *\n+   * <p>The boundaries for the buckets in the underlying histogram needs to be sorted.\n+   *\n+   * @param bucketBoundaries bucket boundaries to use for distribution.\n+   * @return a new {@code Distribution}.\n+   * @since 0.1.0\n+   */\n+  public static Aggregation distributionWithExplicitBounds(Double... bucketBoundaries) {\n+    return new Distribution(bucketBoundaries);\n+  }\n+\n+  /**\n+   * Aggregation that calculates the last value of all recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation lastValue() {\n+    return LastValue.INSTANCE;\n+  }\n+\n+  @Immutable\n+  private enum Sum implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      return instrumentValueType == InstrumentValueType.LONG\n+          ? LongSumAggregator.getFactory()\n+          : DoubleSumAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      switch (instrumentType) {\n+        case COUNTER_MONOTONIC:\n+        case MEASURE_ABSOLUTE:\n+        case OBSERVER_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.MONOTONIC_LONG\n+              : Type.MONOTONIC_DOUBLE;\n+        case COUNTER_NON_MONOTONIC:\n+        case MEASURE_NON_ABSOLUTE:\n+        case OBSERVER_NON_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.NON_MONOTONIC_LONG\n+              : Type.NON_MONOTONIC_DOUBLE;\n+      }\n+      throw new IllegalArgumentException(\"This should not happen\");\n+    }\n+\n+    @Override\n+    public boolean availableForInstrument(InstrumentType instrumentType) {\n+      // Available for all instruments.\n+      return true;\n+    }\n+  }\n+\n+  @Immutable\n+  private enum Count implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      // TODO: Implement count aggregator and use it here.\n+      return NoopAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      return Type.MONOTONIC_LONG;\n+    }\n+\n+    @Override\n+    public boolean availableForInstrument(InstrumentType instrumentType) {\n+      // It is not available for Observer instruments.\n+      return instrumentType != InstrumentType.OBSERVER_MONOTONIC\n+          && instrumentType != InstrumentType.OBSERVER_NON_MONOTONIC;\n+    }\n+  }\n+\n+  @Immutable\n+  private static final class Distribution implements Aggregation {\n+    private final AggregatorFactory factory;\n+\n+    Distribution(Double... bucketBoundaries) {\n+      Utils.checkNotNull(bucketBoundaries, \"bucketBoundaries\");", "originalCommit": "c7fb653a5f2e7df696ff932c8f1e20654cf160bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMjcxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/857#discussion_r379112719", "bodyText": "done.", "author": "bogdandrutu", "createdAt": "2020-02-13T20:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwODkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwOTQyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/857#discussion_r379109423", "bodyText": "change message to \"Unsupported instrument/value types\"", "author": "jkwatson", "createdAt": "2020-02-13T20:46:34Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.aggregator.DoubleSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.LongSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.NoopAggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor.Type;\n+import javax.annotation.concurrent.Immutable;\n+\n+public class Aggregations {\n+\n+  /**\n+   * Aggregation that calculates sum of recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation sum() {\n+    return Sum.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates count of recorded measurements (the number of recorded\n+   * measurements).\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation count() {\n+    return Count.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates distribution stats on recorded measurements. Distribution includes\n+   * sum, count, histogram, and sum of squared deviations.\n+   *\n+   * <p>The boundaries for the buckets in the underlying histogram needs to be sorted.\n+   *\n+   * @param bucketBoundaries bucket boundaries to use for distribution.\n+   * @return a new {@code Distribution}.\n+   * @since 0.1.0\n+   */\n+  public static Aggregation distributionWithExplicitBounds(Double... bucketBoundaries) {\n+    return new Distribution(bucketBoundaries);\n+  }\n+\n+  /**\n+   * Aggregation that calculates the last value of all recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation lastValue() {\n+    return LastValue.INSTANCE;\n+  }\n+\n+  @Immutable\n+  private enum Sum implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      return instrumentValueType == InstrumentValueType.LONG\n+          ? LongSumAggregator.getFactory()\n+          : DoubleSumAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      switch (instrumentType) {\n+        case COUNTER_MONOTONIC:\n+        case MEASURE_ABSOLUTE:\n+        case OBSERVER_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.MONOTONIC_LONG\n+              : Type.MONOTONIC_DOUBLE;\n+        case COUNTER_NON_MONOTONIC:\n+        case MEASURE_NON_ABSOLUTE:\n+        case OBSERVER_NON_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.NON_MONOTONIC_LONG\n+              : Type.NON_MONOTONIC_DOUBLE;\n+      }\n+      throw new IllegalArgumentException(\"This should not happen\");", "originalCommit": "c7fb653a5f2e7df696ff932c8f1e20654cf160bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMjc1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/857#discussion_r379112751", "bodyText": "done.", "author": "bogdandrutu", "createdAt": "2020-02-13T20:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwOTQyMw=="}], "type": "inlineReview"}, {"oid": "72c17683b674c355de503e1a092c60629df22456", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/72c17683b674c355de503e1a092c60629df22456", "message": "Add tests for Sum aggregation\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-02-13T20:47:42Z", "type": "commit"}, {"oid": "7b14b88c2f36c8a2d8c1c2df141031b52ab9ad4d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7b14b88c2f36c8a2d8c1c2df141031b52ab9ad4d", "message": "Add more tests and fix comments\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-02-13T20:55:06Z", "type": "forcePushed"}, {"oid": "b7b0b982d101b08719fa7bae8cd878b84d5ab1e1", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b7b0b982d101b08719fa7bae8cd878b84d5ab1e1", "message": "Add more tests and fix comments\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-02-13T20:58:36Z", "type": "commit"}, {"oid": "b7b0b982d101b08719fa7bae8cd878b84d5ab1e1", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b7b0b982d101b08719fa7bae8cd878b84d5ab1e1", "message": "Add more tests and fix comments\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-02-13T20:58:36Z", "type": "forcePushed"}]}