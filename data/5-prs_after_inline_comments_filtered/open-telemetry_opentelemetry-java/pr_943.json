{"pr_number": 943, "pr_title": "Add aggregators for double & long MinMaxSumCount aggregations", "pr_createdAt": "2020-02-27T21:15:46Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/943", "timeline": [{"oid": "435989e9d87cada7e5adb8d9840dbaf4d65ef966", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/435989e9d87cada7e5adb8d9840dbaf4d65ef966", "message": "Add aggregators for double & long MinMaxSumCount aggregations", "committedDate": "2020-02-27T21:13:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxODE2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385418168", "bodyText": "I think we can use min/max as primitives and rely on the count == 0 to know if any event was recorded. This removes couple of boxing operations.", "author": "bogdandrutu", "createdAt": "2020-02-27T22:53:51Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCount.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+@ThreadSafe\n+public final class DoubleMinMaxSumCount extends AbstractAggregator {\n+\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new DoubleMinMaxSumCount();\n+        }\n+      };\n+\n+  // The current value. This controls its own internal thread-safety via method access. Don't\n+  // try to use its fields directly.\n+  private final DoubleSummary current = new DoubleSummary();\n+\n+  public static AggregatorFactory getFactory() {\n+    return AGGREGATOR_FACTORY;\n+  }\n+\n+  @Override\n+  void doMergeAndReset(Aggregator target) {\n+    DoubleMinMaxSumCount other = (DoubleMinMaxSumCount) target;\n+\n+    DoubleSummary copy = current.copyAndReset();\n+    other.current.update(copy);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Point toPoint(long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+    return current.toPoint(startEpochNanos, epochNanos, labels);\n+  }\n+\n+  @Override\n+  public void recordDouble(double value) {\n+    current.record(value);\n+  }\n+\n+  private static final class DoubleSummary {\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @GuardedBy(\"lock\")\n+    private double sum = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private long count = 0;\n+\n+    @Nullable\n+    @GuardedBy(\"lock\")\n+    private Double min = null;\n+\n+    @Nullable\n+    @GuardedBy(\"lock\")\n+    private Double max = null;\n+\n+    private void update(DoubleSummary summary) {\n+      lock.writeLock().lock();\n+      try {\n+        this.count += summary.count;\n+        this.sum += summary.sum;\n+        if (this.min == null) {\n+          this.min = summary.min;\n+        } else if (summary.min != null) {\n+          this.min = Math.min(summary.min, this.min);\n+        }\n+        if (this.max == null) {\n+          this.max = summary.max;\n+        } else if (summary.max != null) {\n+          this.max = Math.max(summary.max, this.max);\n+        }\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    private void record(double value) {\n+      lock.writeLock().lock();\n+      try {\n+        count++;\n+        sum += value;\n+        min = min == null ? value : Math.min(value, min);\n+        max = max == null ? value : Math.max(value, max);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    private DoubleSummary copyAndReset() {\n+      DoubleSummary copy = new DoubleSummary();\n+      lock.writeLock().lock();\n+      try {\n+        copy.count = count;\n+        copy.sum = sum;\n+        copy.min = min;\n+        copy.max = max;\n+        count = 0;\n+        sum = 0;\n+        min = null;\n+        max = null;\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+      return copy;\n+    }\n+\n+    private SummaryPoint toPoint(\n+        long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+      lock.readLock().lock();\n+      try {\n+        return SummaryPoint.create(\n+            startEpochNanos,\n+            epochNanos,\n+            labels,\n+            count,\n+            sum,\n+            min == null || max == null // note: min & max will be null or not null together.", "originalCommit": "435989e9d87cada7e5adb8d9840dbaf4d65ef966", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ0NTY2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385445666", "bodyText": "excellent idea. will make it so.", "author": "jkwatson", "createdAt": "2020-02-28T00:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxODE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ1MTU1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385451550", "bodyText": "@jkwatson I am able to come with these ideas only if I have small PRs :). No seriously I would have not been able to see this in 1000 lines PR :)", "author": "bogdandrutu", "createdAt": "2020-02-28T00:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxODE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3ODM3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385478372", "bodyText": "It's all good. Sometimes I need to build the full solution to make sure I understand it; I'm happy to go back and PR in chunks after the fact.", "author": "jkwatson", "createdAt": "2020-02-28T02:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxODE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMDc4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385420786", "bodyText": "what about just:\ncurrent.mergeAndReset(other.current)\n    private void mergeAndReset(DoubleSummary target) {\n      long count;\n      double sum;\n      double min;\n      double max;\n      lock.writeLock().lock();\n      try {\n        count = this.count;\n        sum = this.sum;\n        min = this.min;\n        max = this.max;\n        this.count = 0;\n        this.sum = 0;\n        this.min = 0;\n        this.max = 0;\n      } finally {\n        lock.writeLock().unlock();\n      }\n      target.update(count, sum, min, max);\n    }\n\n    private void update(long count, double sum, double min, double max) {\n      if (count == 0) {\n        return;  // nothing to do\n      }\n      lock.writeLock().lock();\n      try {\n        this.count += count;\n        this.sum += sum;\n        this.min = Math.min(min, this.min);\n        this.max = Math.max(max, this.max);\n      } finally {\n        lock.writeLock().unlock();\n      }\n    }", "author": "bogdandrutu", "createdAt": "2020-02-27T23:01:13Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCount.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+@ThreadSafe\n+public final class DoubleMinMaxSumCount extends AbstractAggregator {\n+\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new DoubleMinMaxSumCount();\n+        }\n+      };\n+\n+  // The current value. This controls its own internal thread-safety via method access. Don't\n+  // try to use its fields directly.\n+  private final DoubleSummary current = new DoubleSummary();\n+\n+  public static AggregatorFactory getFactory() {\n+    return AGGREGATOR_FACTORY;\n+  }\n+\n+  @Override\n+  void doMergeAndReset(Aggregator target) {\n+    DoubleMinMaxSumCount other = (DoubleMinMaxSumCount) target;\n+\n+    DoubleSummary copy = current.copyAndReset();\n+    other.current.update(copy);", "originalCommit": "435989e9d87cada7e5adb8d9840dbaf4d65ef966", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ0NjIwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385446200", "bodyText": "I like this idea. I'll try it out.", "author": "jkwatson", "createdAt": "2020-02-28T00:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMDc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxNDY1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385814651", "bodyText": "This is the only issue left", "author": "bogdandrutu", "createdAt": "2020-02-28T17:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMDc4Ng=="}], "type": "inlineReview"}, {"oid": "0251c1eea19855938d357bdb6b59a9871f7aa0ca", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0251c1eea19855938d357bdb6b59a9871f7aa0ca", "message": "use the count to signal un-set min/max values", "committedDate": "2020-02-28T15:39:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MDE5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385770196", "bodyText": "Return null if no values?", "author": "bogdandrutu", "createdAt": "2020-02-28T15:47:00Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCount.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+@ThreadSafe\n+public final class DoubleMinMaxSumCount extends AbstractAggregator {\n+\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new DoubleMinMaxSumCount();\n+        }\n+      };\n+\n+  // The current value. This controls its own internal thread-safety via method access. Don't\n+  // try to use its fields directly.\n+  private final DoubleSummary current = new DoubleSummary();\n+\n+  public static AggregatorFactory getFactory() {\n+    return AGGREGATOR_FACTORY;\n+  }\n+\n+  @Override\n+  void doMergeAndReset(Aggregator target) {\n+    DoubleMinMaxSumCount other = (DoubleMinMaxSumCount) target;\n+\n+    DoubleSummary copy = current.copyAndReset();\n+    other.current.update(copy);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Point toPoint(long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+    return current.toPoint(startEpochNanos, epochNanos, labels);\n+  }\n+\n+  @Override\n+  public void recordDouble(double value) {\n+    current.record(value);\n+  }\n+\n+  private static final class DoubleSummary {\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @GuardedBy(\"lock\")\n+    private double sum = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private long count = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private double min = Double.POSITIVE_INFINITY;\n+\n+    @GuardedBy(\"lock\")\n+    private double max = Double.NEGATIVE_INFINITY;\n+\n+    private void update(DoubleSummary summary) {\n+      lock.writeLock().lock();\n+      try {\n+        this.count += summary.count;\n+        this.sum += summary.sum;\n+        this.min = Math.min(summary.min, this.min);\n+        this.max = Math.max(summary.max, this.max);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    private void record(double value) {\n+      lock.writeLock().lock();\n+      try {\n+        count++;\n+        sum += value;\n+        min = Math.min(value, min);\n+        max = Math.max(value, max);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    private DoubleSummary copyAndReset() {\n+      DoubleSummary copy = new DoubleSummary();\n+      lock.writeLock().lock();\n+      try {\n+        copy.count = count;\n+        copy.sum = sum;\n+        copy.min = min;\n+        copy.max = max;\n+        count = 0;\n+        sum = 0;\n+        min = Double.POSITIVE_INFINITY;\n+        max = Double.NEGATIVE_INFINITY;\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+      return copy;\n+    }\n+\n+    private SummaryPoint toPoint(\n+        long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+      lock.readLock().lock();\n+      try {\n+        return SummaryPoint.create(\n+            startEpochNanos,\n+            epochNanos,\n+            labels,\n+            count,\n+            sum,\n+            count == 0", "originalCommit": "0251c1eea19855938d357bdb6b59a9871f7aa0ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MjA5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385772097", "bodyText": "yes yes yes. not sure why I didn't do that the first time around.", "author": "jkwatson", "createdAt": "2020-02-28T15:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MDE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MzMyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385773323", "bodyText": "Get the instance via the factory and add a private ctor to the class, so to enforce usage of the factory :)", "author": "bogdandrutu", "createdAt": "2020-02-28T15:52:29Z", "path": "sdk/src/jmh/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCountBenchmark.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Benchmark)\n+public class DoubleMinMaxSumCountBenchmark {\n+\n+  private DoubleMinMaxSumCount aggregator;\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    aggregator = new DoubleMinMaxSumCount();", "originalCommit": "0251c1eea19855938d357bdb6b59a9871f7aa0ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3Mzg0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385773842", "bodyText": "sure thing.", "author": "jkwatson", "createdAt": "2020-02-28T15:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MzMyMw=="}], "type": "inlineReview"}, {"oid": "463eec111868dcebfbbd356c5c2d36c660cf9c1d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/463eec111868dcebfbbd356c5c2d36c660cf9c1d", "message": "make the aggregator constructors private; use the factories for access", "committedDate": "2020-02-28T16:29:19Z", "type": "commit"}, {"oid": "25e023b642d83f1044ee89a0782793cd2e750a13", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/25e023b642d83f1044ee89a0782793cd2e750a13", "message": "simplify the merge and reset", "committedDate": "2020-02-28T17:13:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyMTM1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385821352", "bodyText": "if this.count == 0 you can return immediately.", "author": "bogdandrutu", "createdAt": "2020-02-28T17:19:09Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCount.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+@ThreadSafe\n+public final class DoubleMinMaxSumCount extends AbstractAggregator {\n+\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new DoubleMinMaxSumCount();\n+        }\n+      };\n+\n+  // The current value. This controls its own internal thread-safety via method access. Don't\n+  // try to use its fields directly.\n+  private final DoubleSummary current = new DoubleSummary();\n+\n+  public static AggregatorFactory getFactory() {\n+    return AGGREGATOR_FACTORY;\n+  }\n+\n+  private DoubleMinMaxSumCount() {}\n+\n+  @Override\n+  void doMergeAndReset(Aggregator target) {\n+    DoubleMinMaxSumCount other = (DoubleMinMaxSumCount) target;\n+    current.mergeAndReset(other.current);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Point toPoint(long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+    return current.toPoint(startEpochNanos, epochNanos, labels);\n+  }\n+\n+  @Override\n+  public void recordDouble(double value) {\n+    current.record(value);\n+  }\n+\n+  private static final class DoubleSummary {\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @GuardedBy(\"lock\")\n+    private double sum = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private long count = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private double min = Double.POSITIVE_INFINITY;\n+\n+    @GuardedBy(\"lock\")\n+    private double max = Double.NEGATIVE_INFINITY;\n+\n+    private void record(double value) {\n+      lock.writeLock().lock();\n+      try {\n+        count++;\n+        sum += value;\n+        min = Math.min(value, min);\n+        max = Math.max(value, max);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    public void mergeAndReset(DoubleSummary other) {\n+      long myCount;\n+      double mySum;\n+      double myMin;\n+      double myMax;\n+      lock.writeLock().lock();\n+      try {\n+        myCount = this.count;\n+        mySum = this.sum;\n+        myMin = this.min;\n+        myMax = this.max;\n+        this.count = 0;\n+        this.sum = 0;\n+        this.min = Long.MAX_VALUE;\n+        this.max = Long.MIN_VALUE;\n+      } finally {\n+        lock.writeLock().unlock();\n+      }", "originalCommit": "25e023b642d83f1044ee89a0782793cd2e750a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyNDMyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385824326", "bodyText": "true true", "author": "jkwatson", "createdAt": "2020-02-28T17:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyMTM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyNTkyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385825921", "bodyText": "also, the default values are wrong here.  fixing.", "author": "jkwatson", "createdAt": "2020-02-28T17:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyMTM1Mg=="}], "type": "inlineReview"}, {"oid": "5a7b895fc1abbb531fef0794b5046e462e8fddb2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5a7b895fc1abbb531fef0794b5046e462e8fddb2", "message": "early return & fix the default double values.", "committedDate": "2020-02-28T17:27:32Z", "type": "commit"}]}