{"pr_number": 1458, "pr_title": "feat(extensions): ot-tracer propagator", "pr_createdAt": "2020-07-24T00:05:21Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458", "timeline": [{"oid": "65ef9a2314f83e30a676970022600df3a651efea", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/65ef9a2314f83e30a676970022600df3a651efea", "message": "fix googleJavaFormat", "committedDate": "2020-07-24T00:11:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTUzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r459869533", "bodyText": "I think generally we shouldn't reference implementation of other propagators here. Should we promote to a top-level class, maybe HexIdUtils?", "author": "anuraaga", "createdAt": "2020-07-24T06:15:14Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.extensions.trace.propagation.B3PropagatorExtractor.Util;", "originalCommit": "c3fefefcd0fa1a1de0f3abc68b54b06d7f338526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4ODgzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r459888834", "bodyText": "Sure, I'll refactor out the utils class then. It makes the B3 interface pretty sparse as a result.", "author": "FrankSpitulski", "createdAt": "2020-07-24T07:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2MjI4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460262283", "bodyText": "Refactored", "author": "FrankSpitulski", "createdAt": "2020-07-24T20:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzODkyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r459838920", "bodyText": "Please write a javadoc for the class", "author": "iNikem", "createdAt": "2020-07-24T03:45:19Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.extensions.trace.propagation.B3PropagatorExtractor.Util;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {", "originalCommit": "c3fefefcd0fa1a1de0f3abc68b54b06d7f338526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2MjE1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460262152", "bodyText": "I included a javadoc, but I don't have a link to the spec so I referenced the lightstep implementation. Maybe @carlosalberto has a link to the spec?", "author": "FrankSpitulski", "createdAt": "2020-07-24T20:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzODkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1NjI4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460556287", "bodyText": "We don't have a Spec IIRC Having a simple Javadoc explaining the very basics should be enough.", "author": "carlosalberto", "createdAt": "2020-07-26T18:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzODkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwMjgxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r461102818", "bodyText": "done", "author": "FrankSpitulski", "createdAt": "2020-07-27T18:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzODkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTY1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349651", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class PropagatorUtils {\n          \n          \n            \n            final class PropagatorUtils {", "author": "anuraaga", "createdAt": "2020-07-25T01:50:10Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/PropagatorUtils.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+@Immutable\n+public class PropagatorUtils {", "originalCommit": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTcxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349715", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(carrier).hasSize(0);\n          \n          \n            \n                assertThat(carrier).isEmpty();", "author": "anuraaga", "createdAt": "2020-07-25T01:50:45Z", "path": "extensions/trace_propagators/src/test/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagatorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class OtTracerPropagatorTest {\n+\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+  private static final String TRACE_ID_BASE16 = \"ff000000000000000000000000000041\";\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String SHORT_TRACE_ID_BASE16 = \"ff00000000000000\";\n+  private static final TraceId SHORT_TRACE_ID =\n+      TraceId.fromLowerBase16(StringUtils.padLeft(SHORT_TRACE_ID_BASE16, 32), 0);\n+  private static final String SPAN_ID_BASE16 = \"ff00000000000041\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final byte SAMPLED_TRACE_OPTIONS_BYTES = 1;\n+  private static final TraceFlags SAMPLED_TRACE_OPTIONS =\n+      TraceFlags.fromByte(SAMPLED_TRACE_OPTIONS_BYTES);\n+  private static final Setter<Map<String, String>> setter = Map::put;\n+  private static final Getter<Map<String, String>> getter =\n+      new Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final OtTracerPropagator propagator = OtTracerPropagator.getInstance();\n+\n+  @Rule public ExpectedException thrown = ExpectedException.none();\n+\n+  private static SpanContext getSpanContext(Context context) {\n+    return TracingContextUtils.getSpan(context).getContext();\n+  }\n+\n+  private static Context withSpanContext(SpanContext spanContext, Context context) {\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @Test\n+  public void inject_invalidContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(\n+                TraceId.getInvalid(),\n+                SpanId.getInvalid(),\n+                SAMPLED_TRACE_OPTIONS,\n+                TraceState.builder().set(\"foo\", \"bar\").build()),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier).hasSize(0);", "originalCommit": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTgyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349827", "bodyText": "I would just inline for better readability, this separation doesn't really improve maintenance", "author": "anuraaga", "createdAt": "2020-07-25T01:52:03Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Lightstep propagation protocol. See <a\n+ * href=https://github.com/lightstep/lightstep-tracer-java-common/blob/master/common/src/main/java/com/lightstep/tracer/shared/TextMapPropagator.java>Lightstep\n+ * TextMapPropagator</a>.\n+ */\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {\n+\n+  private static final String OT_TRACER = \"ot-tracer-\";", "originalCommit": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTg0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349844", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static final String TRACE_ID_HEADER = OT_TRACER + \"traceid\";\n          \n          \n            \n              static final String TRACE_ID_HEADER = \"ot-tracer-traceid\";", "author": "anuraaga", "createdAt": "2020-07-25T01:52:14Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Lightstep propagation protocol. See <a\n+ * href=https://github.com/lightstep/lightstep-tracer-java-common/blob/master/common/src/main/java/com/lightstep/tracer/shared/TextMapPropagator.java>Lightstep\n+ * TextMapPropagator</a>.\n+ */\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {\n+\n+  private static final String OT_TRACER = \"ot-tracer-\";\n+  static final String TRACE_ID_HEADER = OT_TRACER + \"traceid\";", "originalCommit": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTg3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349875", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static final String SPAN_ID_HEADER = OT_TRACER + \"spanid\";\n          \n          \n            \n              static final String SPAN_ID_HEADER = \"ot-tracer-spanid\";", "author": "anuraaga", "createdAt": "2020-07-25T01:52:32Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Lightstep propagation protocol. See <a\n+ * href=https://github.com/lightstep/lightstep-tracer-java-common/blob/master/common/src/main/java/com/lightstep/tracer/shared/TextMapPropagator.java>Lightstep\n+ * TextMapPropagator</a>.\n+ */\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {\n+\n+  private static final String OT_TRACER = \"ot-tracer-\";\n+  static final String TRACE_ID_HEADER = OT_TRACER + \"traceid\";\n+  static final String SPAN_ID_HEADER = OT_TRACER + \"spanid\";", "originalCommit": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTg5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349895", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static final String SAMPLED_HEADER = OT_TRACER + \"sampled\";\n          \n          \n            \n              static final String SAMPLED_HEADER = \"ot-tracer-sampled\";", "author": "anuraaga", "createdAt": "2020-07-25T01:52:43Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Lightstep propagation protocol. See <a\n+ * href=https://github.com/lightstep/lightstep-tracer-java-common/blob/master/common/src/main/java/com/lightstep/tracer/shared/TextMapPropagator.java>Lightstep\n+ * TextMapPropagator</a>.\n+ */\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {\n+\n+  private static final String OT_TRACER = \"ot-tracer-\";\n+  static final String TRACE_ID_HEADER = OT_TRACER + \"traceid\";\n+  static final String SPAN_ID_HEADER = OT_TRACER + \"spanid\";\n+  static final String SAMPLED_HEADER = OT_TRACER + \"sampled\";", "originalCommit": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTk1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349954", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Test\n          \n          \n            \n              public void fieldsList() {\n          \n          \n            \n                assertThat(propagator.fields())\n          \n          \n            \n                    .containsExactly(\n          \n          \n            \n                        OtTracerPropagator.TRACE_ID_HEADER,\n          \n          \n            \n                        OtTracerPropagator.SPAN_ID_HEADER,\n          \n          \n            \n                        OtTracerPropagator.SAMPLED_HEADER);\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              @Test\n          \n          \n            \n              public void headerNames() {\n          \n          \n            \n                assertThat(OtTracerPropagator.TRACE_ID_HEADER).isEqualTo(\"ot-tracer-traceid\");\n          \n          \n            \n                assertThat(OtTracerPropagator.SPAN_ID_HEADER).isEqualTo(\"ot-tracer-spanid\");\n          \n          \n            \n                assertThat(OtTracerPropagator.SAMPLED_HEADER).isEqualTo(\"ot-tracer-sampled\");\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nThese tests are basically equivalent to the code, just checking constants, don't think they provide value.", "author": "anuraaga", "createdAt": "2020-07-25T01:53:27Z", "path": "extensions/trace_propagators/src/test/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagatorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class OtTracerPropagatorTest {\n+\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+  private static final String TRACE_ID_BASE16 = \"ff000000000000000000000000000041\";\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String SHORT_TRACE_ID_BASE16 = \"ff00000000000000\";\n+  private static final TraceId SHORT_TRACE_ID =\n+      TraceId.fromLowerBase16(StringUtils.padLeft(SHORT_TRACE_ID_BASE16, 32), 0);\n+  private static final String SPAN_ID_BASE16 = \"ff00000000000041\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final byte SAMPLED_TRACE_OPTIONS_BYTES = 1;\n+  private static final TraceFlags SAMPLED_TRACE_OPTIONS =\n+      TraceFlags.fromByte(SAMPLED_TRACE_OPTIONS_BYTES);\n+  private static final Setter<Map<String, String>> setter = Map::put;\n+  private static final Getter<Map<String, String>> getter =\n+      new Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final OtTracerPropagator propagator = OtTracerPropagator.getInstance();\n+\n+  @Rule public ExpectedException thrown = ExpectedException.none();\n+\n+  private static SpanContext getSpanContext(Context context) {\n+    return TracingContextUtils.getSpan(context).getContext();\n+  }\n+\n+  private static Context withSpanContext(SpanContext spanContext, Context context) {\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @Test\n+  public void inject_invalidContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(\n+                TraceId.getInvalid(),\n+                SpanId.getInvalid(),\n+                SAMPLED_TRACE_OPTIONS,\n+                TraceState.builder().set(\"foo\", \"bar\").build()),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier).hasSize(0);\n+  }\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SAMPLED_HEADER, \"true\");\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        (Setter<Map<String, String>>) (ignored, key, value) -> carrier.put(key, value));\n+    assertThat(carrier).containsEntry(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SAMPLED_HEADER, \"true\");\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SAMPLED_HEADER, \"false\");\n+  }\n+\n+  @Test\n+  public void extract_Nothing() {\n+    // Context remains untouched.\n+    assertThat(\n+            propagator.extract(Context.current(), Collections.<String, String>emptyMap(), Map::get))\n+        .isSameInstanceAs(Context.current());\n+  }\n+\n+  @Test\n+  public void extract_SampledContext_Int() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_SampledContext_Bool() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, \"true\");\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.FALSE_INT);\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_SampledContext_Int_Short_TraceId() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, SHORT_TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                SHORT_TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_SampledContext_Bool_Short_TraceId() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, SHORT_TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, \"true\");\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                SHORT_TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_NotSampledContext_Short_TraceId() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, SHORT_TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.FALSE_INT);\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                SHORT_TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(OtTracerPropagator.TRACE_ID_HEADER, \"abcdefghijklmnopabcdefghijklmnop\");\n+    invalidHeaders.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    invalidHeaders.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+    assertThat(getSpanContext(propagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16 + \"00\");\n+    invalidHeaders.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    invalidHeaders.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+    assertThat(getSpanContext(propagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    invalidHeaders.put(OtTracerPropagator.SPAN_ID_HEADER, \"abcdefghijklmnop\");\n+    invalidHeaders.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+    assertThat(getSpanContext(propagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    invalidHeaders.put(OtTracerPropagator.SPAN_ID_HEADER, \"abcdefghijklmnop\" + \"00\");\n+    invalidHeaders.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+    assertThat(getSpanContext(propagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void fieldsList() {\n+    assertThat(propagator.fields())\n+        .containsExactly(\n+            OtTracerPropagator.TRACE_ID_HEADER,\n+            OtTracerPropagator.SPAN_ID_HEADER,\n+            OtTracerPropagator.SAMPLED_HEADER);\n+  }\n+\n+  @Test\n+  public void headerNames() {\n+    assertThat(OtTracerPropagator.TRACE_ID_HEADER).isEqualTo(\"ot-tracer-traceid\");\n+    assertThat(OtTracerPropagator.SPAN_ID_HEADER).isEqualTo(\"ot-tracer-spanid\");\n+    assertThat(OtTracerPropagator.SAMPLED_HEADER).isEqualTo(\"ot-tracer-sampled\");\n+  }\n+", "originalCommit": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTk5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349992", "bodyText": "Does Map::get not work?", "author": "anuraaga", "createdAt": "2020-07-25T01:54:07Z", "path": "extensions/trace_propagators/src/test/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagatorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class OtTracerPropagatorTest {\n+\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+  private static final String TRACE_ID_BASE16 = \"ff000000000000000000000000000041\";\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String SHORT_TRACE_ID_BASE16 = \"ff00000000000000\";\n+  private static final TraceId SHORT_TRACE_ID =\n+      TraceId.fromLowerBase16(StringUtils.padLeft(SHORT_TRACE_ID_BASE16, 32), 0);\n+  private static final String SPAN_ID_BASE16 = \"ff00000000000041\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final byte SAMPLED_TRACE_OPTIONS_BYTES = 1;\n+  private static final TraceFlags SAMPLED_TRACE_OPTIONS =\n+      TraceFlags.fromByte(SAMPLED_TRACE_OPTIONS_BYTES);\n+  private static final Setter<Map<String, String>> setter = Map::put;\n+  private static final Getter<Map<String, String>> getter =", "originalCommit": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1NDU5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460354594", "bodyText": "It probably does, I copied the b3 tests so it needs to be fixed there too.", "author": "FrankSpitulski", "createdAt": "2020-07-25T02:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1NzUwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460557507", "bodyText": "I'd rename this to PropagatorsCommon or even Common,  as it has utility methods but it also has actual fields used by the implementations.", "author": "carlosalberto", "createdAt": "2020-07-26T18:17:02Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/PropagatorUtils.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+@Immutable\n+final class PropagatorUtils {", "originalCommit": "0291997ccf21f6f7a7917a0cef1cf8a1de6c65cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1NzU4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460557587", "bodyText": "Also, I'd add a comment saying this class is used by both the B3/OT propagators only.", "author": "carlosalberto", "createdAt": "2020-07-26T18:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1NzUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwMjY4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r461102680", "bodyText": "done", "author": "FrankSpitulski", "createdAt": "2020-07-27T18:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1NzUwNw=="}], "type": "inlineReview"}, {"oid": "f4e84699deb822ba9929913ced199fb1216a3c40", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f4e84699deb822ba9929913ced199fb1216a3c40", "message": "feat(extensions): ot-tracer propagator\n\nsupports propagation headers used by lightstep tracers", "committedDate": "2020-07-27T21:23:26Z", "type": "commit"}, {"oid": "f4e84699deb822ba9929913ced199fb1216a3c40", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f4e84699deb822ba9929913ced199fb1216a3c40", "message": "feat(extensions): ot-tracer propagator\n\nsupports propagation headers used by lightstep tracers", "committedDate": "2020-07-27T21:23:26Z", "type": "forcePushed"}]}