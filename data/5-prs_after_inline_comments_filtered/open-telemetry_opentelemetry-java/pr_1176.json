{"pr_number": 1176, "pr_title": "add end to end test for zipkin exporter", "pr_createdAt": "2020-05-05T11:31:41Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176", "timeline": [{"oid": "fc0f61d3310bb2a4b308b0ca343884ede353d7cc", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/fc0f61d3310bb2a4b308b0ca343884ede353d7cc", "message": "add zipkin-junit dependency, moved jaeger-client test dependency to trace_propagators as only required there", "committedDate": "2020-05-05T11:12:45Z", "type": "commit"}, {"oid": "a02f768b7ab8a8a34d5517e61c84a2334b16bef4", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a02f768b7ab8a8a34d5517e61c84a2334b16bef4", "message": "added end to end test for the zipkin exporter", "committedDate": "2020-05-05T11:13:34Z", "type": "commit"}, {"oid": "4c8992243b4aa7571675b10de121628432d25211", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4c8992243b4aa7571675b10de121628432d25211", "message": "removed typo", "committedDate": "2020-05-05T11:15:32Z", "type": "commit"}, {"oid": "a371ed67fa789e3322867c700815960a689f0785", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a371ed67fa789e3322867c700815960a689f0785", "message": "resolved merge conflicts, force zipkin exporter build.gradle to override version of zipkin-junit", "committedDate": "2020-05-05T12:12:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTk0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420475941", "bodyText": "typically when I write tests like this, I add a second method directly over and under it so that you can see the translation. This helps people understand the intent and any surprising things such as annotation naming choices or missed timestamp resolutions.\nto do that, I would move attributes and annotations to locals here so that you can see everything without too much scrolling. the ID constants which are fine to be up top and plus you'd use these for zipkin also.", "author": "codefromthecrypt", "createdAt": "2020-05-05T23:57:05Z", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.PROTO3)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.THRIFT)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.THRIFT)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.JSON_V1)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0))\n+        .isEqualTo(ZipkinSpanExporter.generateSpan(spanData, localEndpoint));\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {", "originalCommit": "a371ed67fa789e3322867c700815960a689f0785", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzOTMwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r421839303", "bodyText": "I've not gone overboard on the tidying up, but I added a method to build the Zipkin span underneath the OTel span", "author": "jarebudev", "createdAt": "2020-05-07T22:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NjQ1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420476456", "bodyText": "interesting using nanos resolution, but will leave that aside..\nwhen you add a method that generates the zipkin span, probably moving these timestamps to constants will help, and show that in zipkin they are /1000", "author": "codefromthecrypt", "createdAt": "2020-05-05T23:58:52Z", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.PROTO3)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.THRIFT)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.THRIFT)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.JSON_V1)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0))\n+        .isEqualTo(ZipkinSpanExporter.generateSpan(spanData, localEndpoint));\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {\n+    return SpanData.newBuilder()\n+        .setTraceId(TraceId.fromLowerBase16(TRACE_ID, 0))\n+        .setSpanId(SpanId.fromLowerBase16(SPAN_ID, 0))\n+        .setParentSpanId(SpanId.fromLowerBase16(PARENT_SPAN_ID, 0))\n+        .setTraceFlags(TraceFlags.builder().setIsSampled(true).build())\n+        .setStatus(Status.OK)\n+        .setKind(Span.Kind.SERVER)\n+        .setHasRemoteParent(true)\n+        .setName(\"Recv.helloworld.Greeter.SayHello\")\n+        .setStartEpochNanos(1505855794_194009601L)", "originalCommit": "a371ed67fa789e3322867c700815960a689f0785", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjEwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420626104", "bodyText": "ZipkinExporterConfiguration.builder()\n            .setSender(\n                URLConnectionSender.newBuilder()\n                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n                    .encoding(Encoding.JSON)\n                    .build())\n            .setServiceName(SERVICE_NAME)\n            .setEncoder(SpanBytesEncoder.PROTO3)\n            .build();\n\nlooking like it can be method with 4 parameters instead of duplicating it", "author": "DotSpy", "createdAt": "2020-05-06T08:31:33Z", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.PROTO3)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.THRIFT)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.THRIFT)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.JSON_V1)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()", "originalCommit": "a371ed67fa789e3322867c700815960a689f0785", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNzk2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r421837962", "bodyText": "While tidying the test up I extracted this into its own method", "author": "jarebudev", "createdAt": "2020-05-07T22:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjEwNA=="}], "type": "inlineReview"}, {"oid": "e0f28a8af6ec15443139037c6ba66670ffca018d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e0f28a8af6ec15443139037c6ba66670ffca018d", "message": "resolved merge conflicts", "committedDate": "2020-05-07T21:45:44Z", "type": "commit"}, {"oid": "bccb1e56cebb5b6ff4e9045d60b8819e9d400887", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/bccb1e56cebb5b6ff4e9045d60b8819e9d400887", "message": "tidied up dependency declaration", "committedDate": "2020-05-07T21:49:44Z", "type": "commit"}, {"oid": "185e05e7772931f20215260bb9f9383758db4b58", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/185e05e7772931f20215260bb9f9383758db4b58", "message": "added local method to build zipkin span to aid readability", "committedDate": "2020-05-07T22:36:03Z", "type": "commit"}, {"oid": "3f1f6fefaa0c677a09a57fd6bc9a032fac2d0f1d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3f1f6fefaa0c677a09a57fd6bc9a032fac2d0f1d", "message": "Merge branch 'master' into 1110_add_end_to_end_test_for_zipkin_exporter", "committedDate": "2020-05-07T22:37:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NzY3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r421897676", "bodyText": "for the purpose of \"find\", etc either make this a constant or use the same form as below? 1505855799000000L + 465726528L using the same value representation helps see what's different in the formats", "author": "codefromthecrypt", "createdAt": "2020-05-08T02:14:42Z", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.PROTO3, SpanBytesEncoder.PROTO3);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.THRIFT, SpanBytesEncoder.THRIFT);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.JSON, SpanBytesEncoder.JSON_V1);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.JSON, SpanBytesEncoder.PROTO3);\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  private static ZipkinExporterConfiguration buildZipkinExporterConfiguration(\n+      String endpoint, Encoding encoding, SpanBytesEncoder encoder) {\n+    return ZipkinExporterConfiguration.builder()\n+        .setSender(URLConnectionSender.newBuilder().endpoint(endpoint).encoding(encoding).build())\n+        .setServiceName(SERVICE_NAME)\n+        .setEncoder(encoder)\n+        .build();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0)).isEqualTo(buildZipkinSpan());\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {\n+    return SpanData.newBuilder()\n+        .setTraceId(TraceId.fromLowerBase16(TRACE_ID, 0))\n+        .setSpanId(SpanId.fromLowerBase16(SPAN_ID, 0))\n+        .setParentSpanId(SpanId.fromLowerBase16(PARENT_SPAN_ID, 0))\n+        .setTraceFlags(TraceFlags.builder().setIsSampled(true).build())\n+        .setStatus(Status.OK)\n+        .setKind(Kind.SERVER)\n+        .setHasRemoteParent(true)\n+        .setName(\"Recv.helloworld.Greeter.SayHello\")\n+        .setStartEpochNanos(1505855794_194009601L)\n+        .setAttributes(attributes)\n+        .setTotalAttributeCount(attributes.size())\n+        .setTimedEvents(annotations)\n+        .setLinks(Collections.<SpanData.Link>emptyList())\n+        .setEndEpochNanos(1505855799_465726528L)", "originalCommit": "3f1f6fefaa0c677a09a57fd6bc9a032fac2d0f1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE1NzUyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r422157524", "bodyText": "thanks, i've extracted these into constants now, should be good to go :)", "author": "jarebudev", "createdAt": "2020-05-08T13:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NzY3Ng=="}], "type": "inlineReview"}, {"oid": "ab15cc5aca88730fb06a088d8e9d18c69290ee8b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ab15cc5aca88730fb06a088d8e9d18c69290ee8b", "message": "extracted timestamps into constants and use consistent form", "committedDate": "2020-05-08T13:53:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE3NDExNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r422174117", "bodyText": "looks good. actually the annotations themselves we can revisit, but in any case this E to E makes future discussions easier.", "author": "codefromthecrypt", "createdAt": "2020-05-08T14:26:08Z", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final String SPAN_NAME = \"Recv.helloworld.Greeter.SayHello\";\n+  private static final long START_EPOCH_NANOS = 1505855794_194009601L;\n+  private static final long END_EPOCH_NANOS = 1505855799_465726528L;\n+  private static final long RECEIVED_TIMESTAMP_NANOS = 1505855799_433901068L;\n+  private static final long SENT_TIMESTAMP_NANOS = 1505855799_459486280L;\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              RECEIVED_TIMESTAMP_NANOS, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              SENT_TIMESTAMP_NANOS, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.PROTO3, SpanBytesEncoder.PROTO3);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.THRIFT, SpanBytesEncoder.THRIFT);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.JSON, SpanBytesEncoder.JSON_V1);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.JSON, SpanBytesEncoder.PROTO3);\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  private static ZipkinExporterConfiguration buildZipkinExporterConfiguration(\n+      String endpoint, Encoding encoding, SpanBytesEncoder encoder) {\n+    return ZipkinExporterConfiguration.builder()\n+        .setSender(URLConnectionSender.newBuilder().endpoint(endpoint).encoding(encoding).build())\n+        .setServiceName(SERVICE_NAME)\n+        .setEncoder(encoder)\n+        .build();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0)).isEqualTo(buildZipkinSpan());\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {\n+    return SpanData.newBuilder()\n+        .setTraceId(TraceId.fromLowerBase16(TRACE_ID, 0))\n+        .setSpanId(SpanId.fromLowerBase16(SPAN_ID, 0))\n+        .setParentSpanId(SpanId.fromLowerBase16(PARENT_SPAN_ID, 0))\n+        .setTraceFlags(TraceFlags.builder().setIsSampled(true).build())\n+        .setStatus(Status.OK)\n+        .setKind(Kind.SERVER)\n+        .setHasRemoteParent(true)\n+        .setName(SPAN_NAME)\n+        .setStartEpochNanos(START_EPOCH_NANOS)\n+        .setAttributes(attributes)\n+        .setTotalAttributeCount(attributes.size())\n+        .setTimedEvents(annotations)\n+        .setLinks(Collections.<SpanData.Link>emptyList())\n+        .setEndEpochNanos(END_EPOCH_NANOS)\n+        .setHasEnded(true);\n+  }\n+\n+  private static Span buildZipkinSpan() {\n+    return Span.newBuilder()\n+        .traceId(TRACE_ID)\n+        .parentId(PARENT_SPAN_ID)\n+        .id(SPAN_ID)\n+        .kind(Span.Kind.SERVER)\n+        .name(SPAN_NAME)\n+        .timestamp(START_EPOCH_NANOS / 1000)\n+        .duration((END_EPOCH_NANOS / 1000) - (START_EPOCH_NANOS / 1000))\n+        .localEndpoint(localEndpoint)\n+        .addAnnotation(RECEIVED_TIMESTAMP_NANOS / 1000, \"RECEIVED\")", "originalCommit": "ab15cc5aca88730fb06a088d8e9d18c69290ee8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}