{"pr_number": 1658, "pr_title": "Add an OpenTelemetry context mechanism.", "pr_createdAt": "2020-09-17T09:34:45Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658", "timeline": [{"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8611ed9598eb530ef81f8e737f93fc265cb0c544", "message": "Add an OpenTelemetry context mechanism.", "committedDate": "2020-09-17T09:22:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Nzc2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490447766", "bodyText": "Nice work.\nWhat is the motivation for exposing the root?  When is this useful?", "author": "tylerbenson", "createdAt": "2020-09-17T17:50:17Z", "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {\n+\n+  /** Returns the root {@link Context} which all other {@link Context} are derived from. */\n+  public static Context root() {", "originalCommit": "8611ed9598eb530ef81f8e737f93fc265cb0c544", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2NDQ5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490564496", "bodyText": "Same comment. I'd be happier if we don't expose it now, in order to keep things simple.", "author": "carlosalberto", "createdAt": "2020-09-17T21:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Nzc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMjgwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490622801", "bodyText": "We use it in instrumentation unfortunately. We're not supposed to, but there are cases where our automatic propagation doesn't work correctly and we have to force a new local root\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/7e41b516ee793f2cb12c4f0893ec00c66837f7ee/instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/HttpServerTracer.java#L257", "author": "anuraaga", "createdAt": "2020-09-17T23:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Nzc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NDk3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490644976", "bodyText": "Any reason to call it root?  Perhaps empty makes more sense?", "author": "tylerbenson", "createdAt": "2020-09-18T01:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Nzc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwNzAzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r496307030", "bodyText": "Sorry I missed this comment - @tylerbenson I'm not sure about empty because a context override could change the default context to include something (needed if someone needs to stuff mutable state in there). I could rename to defaultContext() (not default() because Java), but any thoughts on which sounds best?", "author": "anuraaga", "createdAt": "2020-09-29T00:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Nzc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0OTUzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490449536", "bodyText": "Do we need all the overrides at this point? I'd like to figure out how minimal we can make this API for starters.", "author": "jkwatson", "createdAt": "2020-09-17T17:53:28Z", "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {\n+\n+  /** Returns the root {@link Context} which all other {@link Context} are derived from. */\n+  public static Context root() {\n+    return storage().rootContext();\n+  }\n+\n+  /** Return the context associated with the current scope. */\n+  public static Context current() {\n+    return storage().current();\n+  }\n+\n+  /**\n+   * Returns the default {@link ContextStorage} used to attach {@link Context}s to scopes of\n+   * execution. Should only be used when defining your own {@link ContextStorage} in case you want\n+   * to delegate functionality to the default implementation.\n+   */\n+  public static ContextStorage threadLocalStorage() {\n+    return ThreadLocalContextStorage.INSTANCE;\n+  }\n+\n+  static ContextStorage storage() {\n+    return LazyStorage.storage;\n+  }\n+\n+  private final PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries;\n+\n+  private Context(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries) {\n+    this.entries = entries;\n+  }\n+\n+  Context() {\n+    entries = null;\n+  }\n+\n+  /**\n+   * Returns the value stored in this {@link Context} for the given {@link ContextKey}, or {@code\n+   * null} if there is no value for the key in this context.\n+   */\n+  @Nullable\n+  public <V> V getValue(ContextKey<V> key) {\n+    // Because withValue enforces the value for a key is its type, this is always safe.\n+    @SuppressWarnings(\"unchecked\")\n+    V value = (V) PersistentHashArrayMappedTrie.get(entries, key);\n+    return value;\n+  }\n+\n+  /**\n+   * Returns a new context with the given key value set.\n+   *\n+   * <pre>{@code\n+   * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+   * withCredential.run(new Runnable() {\n+   *   public void run() {\n+   *      readUserRecords(userId, CRED_KEY.get());\n+   *   }\n+   * });\n+   * }</pre>\n+   *\n+   * <p>Note that multiple calls to {@link #withValue(ContextKey, Object)} can be chained together.\n+   * That is,\n+   *\n+   * <pre>\n+   * context.withValues(K1, V1, K2, V2);\n+   * // is the same as\n+   * context.withValue(K1, V1).withValue(K2, V2);\n+   * </pre>\n+   *\n+   * <p>Nonetheless, {@link Context} should not be treated like a general purpose map with a large\n+   * number of keys and values \u2014 combine multiple related items together into a single key instead\n+   * of separating them. But if the items are unrelated, have separate keys for them.\n+   */\n+  public <V> Context withValue(ContextKey<V> k1, V v1) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2> Context withValues(ContextKey<V1> k1, V1 v1, ContextKey<V2> k2, V2 v2) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2, V3> Context withValues(", "originalCommit": "8611ed9598eb530ef81f8e737f93fc265cb0c544", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMzUxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490623519", "bodyText": "I'm ok with removing for now - but IIRC we did already have a case of adding two values at the same time in instrumentation. That doesn't mean the chaining mechanism is that much worse, but a bit less efficiency.\nFWIW, I was half-jokingly thinking of going up to 5 values to have something \"better\" than gRPC API :P", "author": "anuraaga", "createdAt": "2020-09-17T23:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0OTUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2NTA1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490565057", "bodyText": "+1. Definitely something I've always wanted to have in grpc.Context", "author": "carlosalberto", "createdAt": "2020-09-17T21:12:22Z", "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {\n+\n+  /** Returns the root {@link Context} which all other {@link Context} are derived from. */\n+  public static Context root() {\n+    return storage().rootContext();\n+  }\n+\n+  /** Return the context associated with the current scope. */\n+  public static Context current() {\n+    return storage().current();\n+  }\n+\n+  /**\n+   * Returns the default {@link ContextStorage} used to attach {@link Context}s to scopes of\n+   * execution. Should only be used when defining your own {@link ContextStorage} in case you want\n+   * to delegate functionality to the default implementation.\n+   */\n+  public static ContextStorage threadLocalStorage() {\n+    return ThreadLocalContextStorage.INSTANCE;\n+  }\n+\n+  static ContextStorage storage() {\n+    return LazyStorage.storage;\n+  }\n+\n+  private final PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries;\n+\n+  private Context(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries) {\n+    this.entries = entries;\n+  }\n+\n+  Context() {\n+    entries = null;\n+  }\n+\n+  /**\n+   * Returns the value stored in this {@link Context} for the given {@link ContextKey}, or {@code\n+   * null} if there is no value for the key in this context.\n+   */\n+  @Nullable\n+  public <V> V getValue(ContextKey<V> key) {\n+    // Because withValue enforces the value for a key is its type, this is always safe.\n+    @SuppressWarnings(\"unchecked\")\n+    V value = (V) PersistentHashArrayMappedTrie.get(entries, key);\n+    return value;\n+  }\n+\n+  /**\n+   * Returns a new context with the given key value set.\n+   *\n+   * <pre>{@code\n+   * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+   * withCredential.run(new Runnable() {\n+   *   public void run() {\n+   *      readUserRecords(userId, CRED_KEY.get());\n+   *   }\n+   * });\n+   * }</pre>\n+   *\n+   * <p>Note that multiple calls to {@link #withValue(ContextKey, Object)} can be chained together.\n+   * That is,\n+   *\n+   * <pre>\n+   * context.withValues(K1, V1, K2, V2);\n+   * // is the same as\n+   * context.withValue(K1, V1).withValue(K2, V2);\n+   * </pre>\n+   *\n+   * <p>Nonetheless, {@link Context} should not be treated like a general purpose map with a large\n+   * number of keys and values \u2014 combine multiple related items together into a single key instead\n+   * of separating them. But if the items are unrelated, have separate keys for them.\n+   */\n+  public <V> Context withValue(ContextKey<V> k1, V v1) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2> Context withValues(ContextKey<V1> k1, V1 v1, ContextKey<V2> k2, V2 v2) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2, V3> Context withValues(\n+      ContextKey<V1> k1, V1 v1, ContextKey<V2> k2, V2 v2, ContextKey<V3> k3, V3 v3) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k3, v3);\n+    return new Context(newEntries);\n+  }\n+\n+  /**\n+   * Create a new context with the given key value set.\n+   *\n+   * <p>For more than 4 key-value pairs, note that multiple calls to {@link #withValue} can be\n+   * chained together. That is,\n+   *\n+   * <pre>\n+   * context.withValues(K1, V1, K2, V2);\n+   * // is the same as\n+   * context.withValue(K1, V1).withValue(K2, V2);\n+   * </pre>\n+   *\n+   * <p>Nonetheless, {@link Context} should not be treated like a general purpose map with a large\n+   * number of keys and values \u2014 combine multiple related items together into a single key instead\n+   * of separating them. But if the items are unrelated, have separate keys for them.\n+   */\n+  public <V1, V2, V3, V4> Context withValues(\n+      ContextKey<V1> k1,\n+      V1 v1,\n+      ContextKey<V2> k2,\n+      V2 v2,\n+      ContextKey<V3> k3,\n+      V3 v3,\n+      ContextKey<V4> k4,\n+      V4 v4) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k3, v3);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k4, v4);\n+    return new Context(newEntries);\n+  }\n+\n+  /**\n+   * Attaches this {@link Context}, making it the current {@link Context} and returns a {@link\n+   * Scope} which corresponds to the scope of execution this context is attached for. {@link\n+   * Context#current()} will return this {@link Context} until {@link Scope#close()} is called.\n+   * {@link Scope#close()} must be called to properly restore the previous context from before this\n+   * scope of execution or context will not work correctly. It is recommended to use\n+   * try-with-resources to call {@link Scope#close()} automatically.\n+   *\n+   * <pre>{@code\n+   * Context prevCtx = Context.current();\n+   * try (Scope ignored = ctx.attach()) {\n+   *   assert Context.current() == ctx;\n+   *   ...\n+   * }\n+   * assert Context.current() == prevCtx;\n+   * }</pre>\n+   */\n+  public Scope attach() {", "originalCommit": "8611ed9598eb530ef81f8e737f93fc265cb0c544", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA0NjQ4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r491046485", "bodyText": "Can we make this an interface, now that we're going to java 8?", "author": "jkwatson", "createdAt": "2020-09-18T16:01:14Z", "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {", "originalCommit": "8611ed9598eb530ef81f8e737f93fc265cb0c544", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5OTEyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495499125", "bodyText": "thoughts on this, @anuraaga ?", "author": "jkwatson", "createdAt": "2020-09-26T21:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA0NjQ4NQ=="}], "type": "inlineReview"}, {"oid": "e4babaaa0f7d6661bbcbc34cb067b4ce6884e1d1", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e4babaaa0f7d6661bbcbc34cb067b4ce6884e1d1", "message": "Moar", "committedDate": "2020-09-19T06:26:57Z", "type": "commit"}, {"oid": "100d8b316d9ac0423be859966aa898af5592efd4", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/100d8b316d9ac0423be859966aa898af5592efd4", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into opentelemetry-context", "committedDate": "2020-09-19T06:27:02Z", "type": "commit"}, {"oid": "a0321790bb864763b2196fff38fdaef51836b550", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a0321790bb864763b2196fff38fdaef51836b550", "message": "Extracted interfaces", "committedDate": "2020-09-19T06:44:57Z", "type": "commit"}, {"oid": "704b76a7216a3ed0ccd75e7ac8007f33fa2edfe0", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/704b76a7216a3ed0ccd75e7ac8007f33fa2edfe0", "message": "More context", "committedDate": "2020-09-23T04:55:40Z", "type": "commit"}, {"oid": "c2c7436d3565d001bb47a624be889b41ed2a0c8e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c2c7436d3565d001bb47a624be889b41ed2a0c8e", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into opentelemetry-context", "committedDate": "2020-09-25T06:04:56Z", "type": "commit"}, {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1e0d13fb568688705ec462a7f1cb025021d66467", "message": "Cleanup / tests", "committedDate": "2020-09-25T09:10:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1NzExNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r494857117", "bodyText": "When using storage override with immutable contexts, this is where there can be gaps - you pick one context propagation mechanism and go with it.\nHowever, since Context is an interface now it would be fairly simple to allow providers to implement that too to close this gap without any breaking changes. We do still need a default context, DefaultContext here for users of libraries with no context propagation mechanism.", "author": "anuraaga", "createdAt": "2020-09-25T09:15:04Z", "path": "extensions/context/src/grpcInOtelTest/java/io/opentelemetry/context/GrpcInOtelTest.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+class GrpcInOtelTest {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\");\n+\n+  private static final io.grpc.Context.Key<String> FOOD = io.grpc.Context.key(\"food\");\n+  private static final io.grpc.Context.Key<String> COUNTRY = io.grpc.Context.key(\"country\");\n+\n+  private static ExecutorService otherThread;\n+\n+  @BeforeAll\n+  static void setUp() {\n+    otherThread = Executors.newSingleThreadExecutor();\n+  }\n+\n+  @AfterAll\n+  static void tearDown() {\n+    otherThread.shutdown();\n+  }\n+\n+  @Test\n+  void grpcOtelMix() {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    assertThat(COUNTRY.get()).isNull();\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").attach()) {\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+\n+        io.grpc.Context context2 = io.grpc.Context.current().withValue(FOOD, \"cheese\");\n+        assertThat(FOOD.get()).isNull();\n+        io.grpc.Context toRestore = context2.attach();\n+        try {\n+          assertThat(FOOD.get()).isEqualTo(\"cheese\");\n+          assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+          assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+        } finally {\n+          context2.detach(toRestore);\n+        }\n+      }\n+    } finally {\n+      grpcContext.detach(root);\n+    }\n+  }\n+\n+  @Test\n+  void grpcWrap() throws Exception {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").attach()) {\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+        AtomicReference<String> grpcValue = new AtomicReference<>();\n+        AtomicReference<String> otelValue = new AtomicReference<>();\n+        Runnable runnable =\n+            () -> {\n+              grpcValue.set(COUNTRY.get());\n+              otelValue.set(Context.current().getValue(ANIMAL));\n+            };\n+        otherThread.submit(runnable).get();\n+        assertThat(grpcValue).hasValue(null);\n+        assertThat(otelValue).hasValue(null);\n+\n+        otherThread.submit(io.grpc.Context.current().wrap(runnable)).get();\n+        assertThat(grpcValue).hasValue(\"japan\");\n+\n+        // Since gRPC context is inside the OTel context, propagating gRPC context does not", "originalCommit": "1e0d13fb568688705ec462a7f1cb025021d66467", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1ODQzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r494858438", "bodyText": "To make this easier without SPI we can add a static method that, when called close to app startup, does similar configuration (probably similar to what setResource type of things will end up at in the future). Left it out for now so this currently isn't completely trivial.", "author": "anuraaga", "createdAt": "2020-09-25T09:17:31Z", "path": "extensions/context/src/main/java/io/opentelemetry/context/ContextStorage.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+/**\n+ * The storage for storing and retrieving the current {@link Context}.\n+ *\n+ * <p>If you want to implement your own storage or add some hooks when a {@link Context} is attached", "originalCommit": "1e0d13fb568688705ec462a7f1cb025021d66467", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1ODk3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r494858975", "bodyText": "I'm not convinced this is actually faster than a normal CoW array for our propagation cases. Will benchmark and examine that in the future.", "author": "anuraaga", "createdAt": "2020-09-25T09:18:33Z", "path": "extensions/context/src/main/java/io/opentelemetry/context/PersistentHashArrayMappedTrie.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2017 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * A persistent (copy-on-write) hash tree/trie. Collisions are handled linearly. Delete is not\n+ * supported, but replacement is. The implementation favors simplicity and low memory allocation\n+ * during insertion. Although the asymptotics are good, it is optimized for small sizes like less\n+ * than 20; \"unbelievably large\" would be 100.\n+ *\n+ * <p>Inspired by popcnt-based compression seen in Ideal Hash Trees, Phil Bagwell (2000). The rest\n+ * of the implementation is ignorant of/ignores the paper.\n+ */\n+final class PersistentHashArrayMappedTrie {", "originalCommit": "1e0d13fb568688705ec462a7f1cb025021d66467", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwMzg3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495103872", "bodyText": "very minor: you can get rid of the brackets here", "author": "jkwatson", "createdAt": "2020-09-25T16:34:09Z", "path": "extensions/context/src/test/java/io/opentelemetry/context/ContextTest.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+@SuppressWarnings(\"ClassCanBeStatic\")\n+class ContextTest {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\");\n+  private static final ContextKey<Object> BAG = ContextKey.named(\"bag\");\n+  private static final ContextKey<String> FOOD = ContextKey.named(\"food\");\n+  private static final ContextKey<Integer> COOKIES = ContextKey.named(\"cookies\");\n+\n+  private static final Context CAT = Context.current().withValues(ANIMAL, \"cat\");\n+\n+  // Make sure all tests clean up\n+  @AfterEach\n+  void tearDown() {\n+    assertThat(Context.current()).isEqualTo(Context.root());\n+  }\n+\n+  @Test\n+  void startsWithRoot() {\n+    assertThat(Context.current()).isEqualTo(Context.root());\n+  }\n+\n+  @Test\n+  void canBeAttached() {\n+    Context context = Context.current().withValues(ANIMAL, \"cat\");\n+    assertThat(Context.current().getValue(ANIMAL)).isNull();\n+    try (Scope ignored = context.attach()) {\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+      try (Scope ignored2 = Context.root().attach()) {\n+        assertThat(Context.current().getValue(ANIMAL)).isNull();\n+      }\n+\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+    }\n+    assertThat(Context.current().getValue(ANIMAL)).isNull();\n+  }\n+\n+  @Test\n+  void attachSameTwice() {\n+    Context context = Context.current().withValues(ANIMAL, \"cat\");\n+    assertThat(Context.current().getValue(ANIMAL)).isNull();\n+    try (Scope ignored = context.attach()) {\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+      try (Scope ignored2 = context.attach()) {\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+      }\n+\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+    }\n+    assertThat(Context.current().getValue(ANIMAL)).isNull();\n+  }\n+\n+  @Test\n+  void newThreadStartsWithRoot() throws Exception {\n+    Context context = Context.current().withValues(ANIMAL, \"cat\");\n+    try (Scope ignored = context.attach()) {\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+      AtomicReference<Context> current = new AtomicReference<>();\n+      Thread thread =\n+          new Thread(\n+              () -> {", "originalCommit": "1e0d13fb568688705ec462a7f1cb025021d66467", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwODE0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495108146", "bodyText": "I think this needs to change to be \"wrap\"", "author": "jkwatson", "createdAt": "2020-09-25T16:42:33Z", "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@linkplain #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>{@code\n+ * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ * withCredential.wrap(new Runnable() {\n+ *   public void run() {\n+ *      readUserRecords(userId, CRED_KEY.get());\n+ *   }\n+ * }).run();\n+ * }</pre>\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ *   <li>Attaching Context from a different ancestor will cause information in the current Context\n+ *       to be lost. This should generally be avoided.\n+ * </ul>\n+ */\n+public interface Context {\n+\n+  /** Return the context associated with the current scope. */\n+  static Context current() {\n+    Context current = ContextStorage.get().current();\n+    return current != null ? current : root();\n+  }\n+\n+  /**\n+   * Returns the root {@link Context} which all other {@link DefaultContext} are derived from.\n+   *\n+   * <p>It should generally not be required to use the root {@link Context} directly - instead, use\n+   * {@link Context#current()} to operate on the current {@link Context}. Only use this method if\n+   * you are absolutely sure you need to disregard the current {@link Context} - this almost always\n+   * is only a workaround hiding an underlying context propagation issue.\n+   */\n+  static Context root() {\n+    return DefaultContext.ROOT;\n+  }\n+\n+  /**\n+   * Returns the value stored in this {@link Context} for the given {@link DefaultContextKey}, or\n+   * {@code null} if there is no value for the key in this context.\n+   */\n+  @Nullable\n+  <V> V getValue(ContextKey<V> key);\n+\n+  /**\n+   * Returns a new context with the given key value set.\n+   *\n+   * <pre>{@code\n+   * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+   * withCredential.run(new Runnable() {", "originalCommit": "1e0d13fb568688705ec462a7f1cb025021d66467", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAyMjgzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r496022833", "bodyText": "@anuraaga ?", "author": "jkwatson", "createdAt": "2020-09-28T15:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwODE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwNjQ3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r496306473", "bodyText": "@jkwatson I think this is addressed, maybe you found an older commit?", "author": "anuraaga", "createdAt": "2020-09-29T00:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwODE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExOTM0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495119348", "bodyText": "I might be missing something, but I don't see this being used anywhere.", "author": "jkwatson", "createdAt": "2020-09-25T17:03:41Z", "path": "extensions/context/src/grpcInOtelTest/java/io/grpc/override/ContextStorageOverride.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.override;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextKey;\n+import io.opentelemetry.context.Scope;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+public class ContextStorageOverride extends Context.Storage {", "originalCommit": "1e0d13fb568688705ec462a7f1cb025021d66467", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEyMjM1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495122359", "bodyText": "Never mind. I read the grpc docs and see how this works. Let's add an annotation so that IDEA doesn't suggest deleting it. :)", "author": "jkwatson", "createdAt": "2020-09-25T17:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxOTMzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495419336", "bodyText": "Because it's public I don't think IntelliJ will try to delete it (if it was suggesting me an annotation I'd add it since don't know what it is :P). Added a comment though", "author": "anuraaga", "createdAt": "2020-09-26T05:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5OTE5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495499194", "bodyText": "interesting. IDEA was marking it as unused for me. :hmmm:", "author": "jkwatson", "createdAt": "2020-09-26T21:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExOTM0OA=="}], "type": "inlineReview"}, {"oid": "a95c49dfb9acb47e0d010615400a181d64eadeac", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a95c49dfb9acb47e0d010615400a181d64eadeac", "message": "Move and cleanups", "committedDate": "2020-09-26T05:57:19Z", "type": "commit"}, {"oid": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "message": "Brackets", "committedDate": "2020-09-28T05:08:53Z", "type": "commit"}, {"oid": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "message": "Brackets", "committedDate": "2020-09-28T05:08:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTc1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495691757", "bodyText": "Added this extension point to allow customizing the implementation of a key to match a storage.", "author": "anuraaga", "createdAt": "2020-09-28T05:09:45Z", "path": "context/src/main/java/io/opentelemetry/context/ContextStorage.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+/**\n+ * The storage for storing and retrieving the current {@link Context}.\n+ *\n+ * <p>If you want to implement your own storage or add some hooks when a {@link Context} is attached\n+ * and restored, you should use {@link ContextStorageProvider}. Here's an example that sets MDC\n+ * before {@link Context} is attached:\n+ *\n+ * <pre>{@code\n+ * > public class MyStorage implements ContextStorageProvider {\n+ * >\n+ * >   @Override\n+ * >   public ContextStorage get() {\n+ * >     ContextStorage threadLocalStorage = Context.threadLocalStorage();\n+ * >     return new RequestContextStorage() {\n+ * >       @Override\n+ * >       public Scope T attach(Context toAttach) {\n+ * >         Context current = current();\n+ * >         setMdc(toAttach);\n+ * >         Scope scope = threadLocalStorage.attach(toAttach);\n+ * >         return () -> {\n+ * >           clearMdc();\n+ * >           setMdc(current);\n+ * >           scope.close();\n+ * >         }\n+ * >       }\n+ * >\n+ * >       @Override\n+ * >       public Context current() {\n+ * >         return threadLocalStorage.current();\n+ * >       }\n+ * >     }\n+ * >   }\n+ * > }\n+ * }</pre>\n+ */\n+public interface ContextStorage {\n+\n+  /**\n+   * Returns the {@link ContextStorage} being used by this application. This is only for use when\n+   * integrating with other context propagation mechanisms and not meant for direct use. To attach\n+   * or detach a {@link Context} in an application, use {@link Context#makeCurrent()} and {@link\n+   * Scope#close()}.\n+   */\n+  static ContextStorage get() {\n+    return LazyStorage.storage;\n+  }\n+\n+  /**\n+   * Sets the specified {@link Context} as the current {@link Context} and returns a {@link Scope}\n+   * representing the scope of execution. {@link Scope#close()} must be called when the current\n+   * {@link Context} should be restored to what it was before attaching {@code toAttach}.\n+   */\n+  Scope attach(Context toAttach);\n+\n+  /**\n+   * Returns the current {@link DefaultContext}. If no {@link DefaultContext} has been attached yet,\n+   * this will be the {@linkplain Context#root()} root context}.\n+   */\n+  Context current();\n+\n+  /**\n+   * Returns a {@link ContextKey} for the given name. This is only useful when integrating with a\n+   * separate context propagation mechanism, where\n+   */\n+  default <T> ContextKey<T> contextKey(String name) {", "originalCommit": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTg3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495691874", "bodyText": "Works", "author": "anuraaga", "createdAt": "2020-09-28T05:10:05Z", "path": "context/src/otelAsGrpcTest/java/io/opentelemetry/context/OtelAsGrpcTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+class OtelAsGrpcTest {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\");\n+\n+  private static final io.grpc.Context.Key<String> FOOD = io.grpc.Context.key(\"food\");\n+  private static final io.grpc.Context.Key<String> COUNTRY = io.grpc.Context.key(\"country\");\n+\n+  private static ExecutorService otherThread;\n+\n+  @BeforeAll\n+  static void setUp() {\n+    otherThread = Executors.newSingleThreadExecutor();\n+  }\n+\n+  @AfterAll\n+  static void tearDown() {\n+    otherThread.shutdown();\n+  }\n+\n+  @Test\n+  void grpcOtelMix() {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    assertThat(COUNTRY.get()).isNull();\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").makeCurrent()) {\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+\n+        io.grpc.Context context2 = io.grpc.Context.current().withValue(FOOD, \"cheese\");\n+        assertThat(FOOD.get()).isNull();\n+        io.grpc.Context toRestore = context2.attach();\n+        try {\n+          assertThat(FOOD.get()).isEqualTo(\"cheese\");\n+          assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+          assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+        } finally {\n+          context2.detach(toRestore);\n+        }\n+      }\n+    } finally {\n+      grpcContext.detach(root);\n+    }\n+  }\n+\n+  @Test\n+  void grpcWrap() throws Exception {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").makeCurrent()) {\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+        AtomicReference<String> grpcValue = new AtomicReference<>();\n+        AtomicReference<String> otelValue = new AtomicReference<>();\n+        Runnable runnable =\n+            () -> {\n+              grpcValue.set(COUNTRY.get());\n+              otelValue.set(Context.current().getValue(ANIMAL));\n+            };\n+        otherThread.submit(runnable).get();\n+        assertThat(grpcValue).hasValue(null);\n+        assertThat(otelValue).hasValue(null);\n+\n+        otherThread.submit(io.grpc.Context.current().wrap(runnable)).get();\n+        assertThat(grpcValue).hasValue(\"japan\");\n+        assertThat(otelValue).hasValue(\"cat\");\n+      }\n+    } finally {\n+      grpcContext.detach(root);\n+    }\n+  }\n+\n+  @Test\n+  void otelWrap() throws Exception {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").makeCurrent()) {\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+        AtomicReference<String> grpcValue = new AtomicReference<>();\n+        AtomicReference<String> otelValue = new AtomicReference<>();\n+        Runnable runnable =\n+            () -> {\n+              grpcValue.set(COUNTRY.get());\n+              otelValue.set(Context.current().getValue(ANIMAL));\n+            };\n+        otherThread.submit(runnable).get();\n+        assertThat(grpcValue).hasValue(null);\n+        assertThat(otelValue).hasValue(null);\n+\n+        otherThread.submit(Context.current().wrap(runnable)).get();\n+\n+        assertThat(grpcValue).hasValue(\"japan\");", "originalCommit": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "37c1b97ef8597b5e79fe5db4b0d2729b34637cfa", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/37c1b97ef8597b5e79fe5db4b0d2729b34637cfa", "message": "Add example for brave context interop", "committedDate": "2020-09-29T08:42:28Z", "type": "commit"}, {"oid": "4799c6d6cf117545ec8ec6e451bc17a0beaaa10e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4799c6d6cf117545ec8ec6e451bc17a0beaaa10e", "message": "Brave in OTel", "committedDate": "2020-09-29T09:02:41Z", "type": "commit"}, {"oid": "6f5338aa9cf78ea26552f90d0656df618dc47275", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6f5338aa9cf78ea26552f90d0656df618dc47275", "message": "Spotless", "committedDate": "2020-09-29T09:05:58Z", "type": "commit"}, {"oid": "01fab50e4a285f2207a80adf59df227c6e6f3f49", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/01fab50e4a285f2207a80adf59df227c6e6f3f49", "message": "Missing folder", "committedDate": "2020-09-30T02:13:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyMTMxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r497621315", "bodyText": "Is DefaultContext really the expected one? Shouldn't be Context instead?", "author": "carlosalberto", "createdAt": "2020-09-30T15:54:57Z", "path": "context/src/main/java/io/opentelemetry/context/ContextStorageProvider.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Executor;\n+\n+/**\n+ * A Java SPI (Service Provider Interface) to allow replacing the default {@link ContextStorage}.\n+ * This can be useful if, for example, you want to store OpenTelemetry {@link DefaultContext} in\n+ * another context propagation system. For example, the returned {@link ContextStorage} could\n+ * delegate to methods in\n+ *\n+ * <p><a\n+ * href=\"https://javadoc.io/doc/com.linecorp.armeria/armeria-javadoc/latest/com/linecorp/armeria/common/RequestContext.html\">{@code\n+ * com.linecorp.armeria.common.RequestContext}</a>, <a\n+ * href=\"https://grpc.github.io/grpc-java/javadoc/io/grpc/Context.html\">{@code\n+ * io.grpc.context.Context}</a>, or <a\n+ * href=\"https://download.eclipse.org/microprofile/microprofile-context-propagation-1.0.2/apidocs/org/eclipse/microprofile/context/ThreadContext.html\">{@code\n+ * org.eclipse.microprofile.context.ThreadContext}</a>\n+ *\n+ * <p>if you are already using one of those systems in your application. Then you would not have to\n+ * use methods like {@link Context#wrap(Executor)} and can use your current system instead.\n+ */\n+public interface ContextStorageProvider {\n+\n+  /** Returns the {@link ContextStorage} to use to store {@link DefaultContext}. */", "originalCommit": "01fab50e4a285f2207a80adf59df227c6e6f3f49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2MzQ4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r497863483", "bodyText": "Doh thought I caught all these, thanks!", "author": "anuraaga", "createdAt": "2020-09-30T23:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyMTMxNQ=="}], "type": "inlineReview"}, {"oid": "e1e7c5c24ed178bb0ff78e79f6bc88ed1251ce99", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e1e7c5c24ed178bb0ff78e79f6bc88ed1251ce99", "message": "Another", "committedDate": "2020-09-30T23:55:35Z", "type": "commit"}, {"oid": "2f665d63f6ad49abd30e6629b791411a58600946", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2f665d63f6ad49abd30e6629b791411a58600946", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into opentelemetry-context", "committedDate": "2020-10-05T07:39:39Z", "type": "commit"}, {"oid": "c614e13e6dd02b729cafa351e7300762ea4aa90e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c614e13e6dd02b729cafa351e7300762ea4aa90e", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into opentelemetry-context", "committedDate": "2020-10-05T07:41:30Z", "type": "commit"}, {"oid": "62131e2fddcb97276babe3c5b2262c4259102223", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/62131e2fddcb97276babe3c5b2262c4259102223", "message": "Spotless", "committedDate": "2020-10-05T07:41:44Z", "type": "commit"}]}