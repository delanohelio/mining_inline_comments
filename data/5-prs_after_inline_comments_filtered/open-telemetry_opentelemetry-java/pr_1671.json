{"pr_number": 1671, "pr_title": "support aws eks attributes", "pr_createdAt": "2020-09-22T02:53:00Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671", "timeline": [{"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3551a5ad1a2ebfcafee3999ec45af793161e4e0b", "message": "support aws eks attributes", "committedDate": "2020-09-22T02:48:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2NTQ0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r492465449", "bodyText": "Should be able to do one call to get a config map instead of listing\nhttps://docs.openshift.com/container-platform/3.7/rest_api/api/v1.ConfigMap.html#Get-api-v1-namespaces-namespace-configmaps-name", "author": "anuraaga", "createdAt": "2020-09-22T04:16:11Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/EksHelper.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+class EksHelper {\n+\n+  private static final Logger logger = Logger.getLogger(EksHelper.class.getName());\n+\n+  private static final String NAMESPACE_KUBE_SYSTEM = \"kube-system\";\n+  private static final String NAMESPACE_AWS_CLOUDWATCH = \"amazon-cloudwatch\";\n+  private static final String EKS_CONFIGMAP = \"aws-auth\";\n+  private static final String CLOUDWATCH_CONFIGMAP = \"cluster-info\";\n+  private static final String CLUSTER_NAME_KEY = \"cluster.name\";\n+\n+  @Nullable private final CoreV1Api k8sApi;\n+\n+  public EksHelper() {\n+    CoreV1Api k8sApi = null;\n+    try {\n+      ApiClient client = Config.defaultClient();\n+      Configuration.setDefaultApiClient(client);\n+      k8sApi = new CoreV1Api();\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"Failed to init k8s client API, sdk is not running on EKS.\");\n+    }\n+    this.k8sApi = k8sApi;\n+  }\n+\n+  @VisibleForTesting\n+  public EksHelper(CoreV1Api k8sApi) {\n+    this.k8sApi = k8sApi;\n+  }\n+\n+  boolean isEks() {\n+    if (k8sApi == null) {\n+      return false;\n+    }\n+\n+    try {\n+      V1ConfigMapList configMapList =\n+          k8sApi.listNamespacedConfigMap(\n+              NAMESPACE_KUBE_SYSTEM, null, null, null, null, null, null, null, null, null);\n+\n+      if (configMapList == null) {\n+        logger.log(Level.INFO, \"Failed to get configmap of namespace %s.\", NAMESPACE_KUBE_SYSTEM);\n+        return false;\n+      }\n+\n+      for (V1ConfigMap item : configMapList.getItems()) {", "originalCommit": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0MDQ2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494740460", "bodyText": "yeah, seems k8s client sdk does not support accurate query, will change to call restful api directly", "author": "wangzlei", "createdAt": "2020-09-25T04:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2NTQ0OQ=="}], "type": "inlineReview"}, {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "message": "call k8s api by java native sdk", "committedDate": "2020-09-25T03:55:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDg4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494754889", "bodyText": "Nothing particularly restful, let's call it just HttpClient or JdkHttpClient", "author": "anuraaga", "createdAt": "2020-09-25T05:26:40Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0NzI5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495247295", "bodyText": "Change to JdkHttpClient", "author": "wangzlei", "createdAt": "2020-09-25T21:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTUzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494755531", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return String.format(\"Bearer %s\", content);\n          \n          \n            \n                  return \"Bearer \" + content;\n          \n      \n    \n    \n  \n\nAvoid String.format since it's slow performance and rarely that much more readable", "author": "anuraaga", "createdAt": "2020-09-25T05:29:10Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0NzczOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495247738", "bodyText": "ok, will change all of String.format to '+'", "author": "wangzlei", "createdAt": "2020-09-25T21:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDAzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760033", "bodyText": "Let's avoid doing anything if keyStore is null due to an error. So I guess in the caller,\nKeyStore keyStore = getK8sKeystore(keystorePath);\nif (keyStore != null) { ((HttpsURLConnection))connection.setSslSocketFactory(buildSslSocketFactory(keyStore));", "author": "anuraaga", "createdAt": "2020-09-25T05:45:47Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0ODI4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495248283", "bodyText": "fix in next commit", "author": "wangzlei", "createdAt": "2020-09-25T21:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDM2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760363", "bodyText": "This is an internal class, let's assume it's not null", "author": "anuraaga", "createdAt": "2020-09-25T05:47:01Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDQ5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760496", "bodyText": "This is an internal class, let's keep the logic more direct - we can assume not null means not empty, these are passed by our code, not users", "author": "anuraaga", "createdAt": "2020-09-25T05:47:31Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDU3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760573", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n          \n          \n            \n                    connection = new URL(urlStr).openConnection();", "author": "anuraaga", "createdAt": "2020-09-25T05:47:48Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTI3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495249270", "bodyText": "check the doc, have to use this style:\nconnection = (HttpsURLConnection) new URL(urlStr).openConnection();\nand\nconnection = (HttpURLConnection) new URL(urlStr).openConnection();", "author": "wangzlei", "createdAt": "2020-09-25T21:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDYwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760607", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    connection = (HttpURLConnection) new URL(urlStr).openConnection();\n          \n          \n            \n                    connection = new URL(urlStr).openConnection();", "author": "anuraaga", "createdAt": "2020-09-25T05:47:54Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDY2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760666", "bodyText": "Check the urlStr is https before", "author": "anuraaga", "createdAt": "2020-09-25T05:48:07Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTY2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495249661", "bodyText": "fix in next commit", "author": "wangzlei", "createdAt": "2020-09-25T21:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MTQ3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494761470", "bodyText": "Can clean up a bit I think\nFile caFile = new File(caFilePath); // Oh by the way, let's rename this variable from keystorePath :)\nif (!caFile.exists()) {\n  return null;\n}\n\ntry (InputStream certStream = new FileInputStream(caFile)) {\n  KeyStore trustStore = KeyStore.getInstance()\n  ...\n\n  return trustStore;\n} catch ()\n// No need for finally :)", "author": "anuraaga", "createdAt": "2020-09-25T05:50:47Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Unable to load K8s client token: %s\", e));\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {\n+    InputStream certificateFile = null;\n+    try {\n+      KeyStore trustStore = null;\n+      File caFile = new File(keyStorePath);\n+\n+      if (caFile.exists()) {", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1MDkyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495250929", "bodyText": "ok", "author": "wangzlei", "createdAt": "2020-09-25T21:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MTU4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494761584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      throw new IllegalArgumentException(\"K8s cert file contained no certificates.\");\n          \n          \n            \n                      return null;", "author": "anuraaga", "createdAt": "2020-09-25T05:51:12Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Unable to load K8s client token: %s\", e));\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {\n+    InputStream certificateFile = null;\n+    try {\n+      KeyStore trustStore = null;\n+      File caFile = new File(keyStorePath);\n+\n+      if (caFile.exists()) {\n+        trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        trustStore.load(null, null);\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n+\n+        certificateFile = new FileInputStream(caFile);\n+        Collection<? extends Certificate> certificates =\n+            certificateFactory.generateCertificates(certificateFile);\n+\n+        if (certificates.isEmpty()) {\n+          throw new IllegalArgumentException(\"K8s cert file contained no certificates.\");", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MjAxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494762010", "bodyText": "I switched the logging to FINE recently - since resource attributes are still a nice-to-have and not must, we should only log for debug logging and not as warnings.", "author": "anuraaga", "createdAt": "2020-09-25T05:52:40Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MjU4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494762588", "bodyText": "Offline you mentioned trouble testing HTTPS. Yeah it looks like wiremock only supports Java keystore, but not a certificate file. Armeria's mock server supports certificate files well so we'll probably switch to it, for now can leave a TODO", "author": "anuraaga", "createdAt": "2020-09-25T05:54:52Z", "path": "sdk_extensions/aws_v1_support/src/test/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClientTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.any;\n+import static com.github.tomakehurst.wiremock.client.WireMock.equalTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.ok;\n+import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.github.tomakehurst.wiremock.junit.WireMockClassRule;\n+import com.google.common.collect.ImmutableMap;\n+import java.io.IOException;\n+import java.util.Map;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+public class RestfulClientTest {\n+\n+  @ClassRule\n+  public static WireMockClassRule server = new WireMockClassRule(wireMockConfig().dynamicPort());", "originalCommit": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e369a2a52dfff991f4899d5425257147965d60ec", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e369a2a52dfff991f4899d5425257147965d60ec", "message": "fix code review", "committedDate": "2020-09-25T21:41:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NDE1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495394156", "bodyText": "Ah sorry in that case let cast to HttpUrlConnection here - the variable is that type so it's weird using a different one when casting.", "author": "anuraaga", "createdAt": "2020-09-26T02:43:18Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();", "originalCommit": "e369a2a52dfff991f4899d5425257147965d60ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMzQzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495413435", "bodyText": "yeah, here can also be HttpURLConnection", "author": "wangzlei", "createdAt": "2020-09-26T04:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NDY2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495394661", "bodyText": "Here also FINE, I think this is the block that's hit when the server doesn't exist at all (matters more when we switch Ec2Resource to this new class)", "author": "anuraaga", "createdAt": "2020-09-26T02:44:30Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);", "originalCommit": "e369a2a52dfff991f4899d5425257147965d60ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NTIzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495395236", "bodyText": "Package private", "author": "anuraaga", "createdAt": "2020-09-26T02:45:59Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {", "originalCommit": "e369a2a52dfff991f4899d5425257147965d60ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NTcxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495395717", "bodyText": "Move this into EksResource it's k8s specific", "author": "anuraaga", "createdAt": "2020-09-26T02:47:05Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen. \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: \" + e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {", "originalCommit": "e369a2a52dfff991f4899d5425257147965d60ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMzk1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495413959", "bodyText": "move method to EksResource", "author": "wangzlei", "createdAt": "2020-09-26T04:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NjA4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495396087", "bodyText": "Rename to not be k8s since it's just about client TLS trusted cert.\ngetKeystoreForTrustedCert(String certPath) for example", "author": "anuraaga", "createdAt": "2020-09-26T02:48:10Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen. \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: \" + e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return \"Bearer \" + content;\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"Unable to load K8s client token: \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {", "originalCommit": "e369a2a52dfff991f4899d5425257147965d60ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMzk0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495413944", "bodyText": "update code to generic getKeystoreForTrustedCert", "author": "wangzlei", "createdAt": "2020-09-26T04:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NjA4Nw=="}], "type": "inlineReview"}, {"oid": "1133693bec062259e1766554e501b56244417d27", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1133693bec062259e1766554e501b56244417d27", "message": "fix code review", "committedDate": "2020-09-26T04:37:36Z", "type": "commit"}, {"oid": "be35b8cb91f0c5170ad11ced929a64985c2fb22a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/be35b8cb91f0c5170ad11ced929a64985c2fb22a", "message": "fix code review", "committedDate": "2020-09-26T04:41:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNzc5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495417790", "bodyText": "Ah good catch - if we need index let's just use traditional for loop. for(int i = 0; I < ...", "author": "anuraaga", "createdAt": "2020-09-26T05:28:19Z", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod, String urlStr, Map<String, String> requestPropertyMap, String certPath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getKeystoreForTrustedCert(certPath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.FINE, \"JdkHttpClient fetch string failed.\", e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen.\", e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception.\", e);\n+    }\n+    return null;\n+  }\n+\n+  private static KeyStore getKeystoreForTrustedCert(String certPath) {\n+    try (FileInputStream fis = new FileInputStream(certPath)) {\n+      KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+      trustStore.load(null, null);\n+      CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n+\n+      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(fis);\n+\n+      int i = 0;\n+      for (Certificate certificate : certificates) {", "originalCommit": "be35b8cb91f0c5170ad11ced929a64985c2fb22a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5ODExMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495498110", "bodyText": "Collection does not support random access, have to convert it to Array. Here I also fell code looks ugly, if we have other way to name the cert in for loop, I would prefer not call Collection.toArray().", "author": "wangzlei", "createdAt": "2020-09-26T21:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNzc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU0OTAxMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495549012", "bodyText": "Ah was thinking collection has it as opposed to iterable. In that case no worries.", "author": "anuraaga", "createdAt": "2020-09-27T09:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNzc5MA=="}], "type": "inlineReview"}]}