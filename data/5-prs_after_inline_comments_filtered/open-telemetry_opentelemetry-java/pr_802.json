{"pr_number": 802, "pr_title": "Refactor the tracer registry logic in a shared class", "pr_createdAt": "2020-01-27T19:04:32Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/802", "timeline": [{"oid": "b55211d749a422788b284fe12fc00b680fd40a96", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b55211d749a422788b284fe12fc00b680fd40a96", "message": "Refactor the tracer registry logic in a shared class\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-01-27T19:03:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371509687", "bodyText": "I think all of this code can be replaced with a call to registry.putIfAbsent(instrumentationLibraryInfo, newComponent(instrumentationLibraryInfo)) if you declare the registry as a ConcurrentMap and then the additional lock will be unnecessary.", "author": "jkwatson", "createdAt": "2020-01-27T22:07:03Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.internal;\n+\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Base class for all the registry classes (Tracer, Meter, etc.).\n+ *\n+ * @param <V> the type of the registered value.\n+ */\n+public abstract class ComponentRegistry<V> {\n+  private final Object lock = new Object();\n+  private final Map<InstrumentationLibraryInfo, V> registry = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Returns the registered value associated with this name and {@code null} version if any,\n+   * otherwise creates a new instance and associates it with the given name and {@code null}\n+   * version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @return the registered value associated with this name and {@code null} version.\n+   */\n+  public V get(String instrumentationName) {\n+    return get(instrumentationName, null);\n+  }\n+\n+  /**\n+   * Returns the registered value associated with this name and version if any, otherwise creates a\n+   * new instance and associates it with the given name and version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @param instrumentationVersion the version of the instrumentation library.\n+   * @return the registered value associated with this name and version.\n+   */\n+  public V get(String instrumentationName, @Nullable String instrumentationVersion) {\n+    InstrumentationLibraryInfo instrumentationLibraryInfo =\n+        InstrumentationLibraryInfo.create(instrumentationName, instrumentationVersion);\n+    V tracer = registry.get(instrumentationLibraryInfo);\n+    if (tracer == null) {\n+      synchronized (lock) {\n+        // Re-check if the value was added since the previous check, this can happen if multiple\n+        // threads try to access the same named tracer during the same time. This way we ensure that\n+        // we create only one TracerSdk per name.\n+        tracer = registry.get(instrumentationLibraryInfo);\n+        if (tracer != null) {\n+          // A different thread already added the named Tracer, just reuse.\n+          return tracer;\n+        }\n+        tracer = newComponent(instrumentationLibraryInfo);\n+        registry.put(instrumentationLibraryInfo, tracer);\n+      }\n+    }", "originalCommit": "b55211d749a422788b284fe12fc00b680fd40a96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMDc2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371530760", "bodyText": "note: You have to return registry.get(instrumentationLibraryInfo); as the result. ;)", "author": "jkwatson", "createdAt": "2020-01-27T23:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1ODgzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371558831", "bodyText": "So I'd personally prefer to\n\nNot having to create a new InstrumentationLibraryInfo object per get() call.\nNot to do registry.putIfAbsent(instrumentationLibraryInfo, newComponent(instrumentationLibraryInfo)) as we would also be creating a new component (I wish putIfAbsent() took a lambda ;) )\n\nProbably by doing so we would need to do more work, but we would avoid a few allocations ;)", "author": "carlosalberto", "createdAt": "2020-01-28T00:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3ODQwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371578406", "bodyText": "Something something java 8!!\nThe trade-off is with putIfAbsent we don't block. I'd personally prefer non blocking, but that's me.\nMaybe a hybrid where we putIfAbsent if the first one returns null?", "author": "jkwatson", "createdAt": "2020-01-28T01:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5OTU1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371599558", "bodyText": "@carlosalberto if we use the InstrumentationLibraryInfo as the key, how do you prevent creation of one? You could create a String key from the pieces, but that ends up creating a StringBuffer instead of the key object. Either way, if you have named tracers like this, then you'll have to create something for the key, no?", "author": "jkwatson", "createdAt": "2020-01-28T03:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MjU3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371892571", "bodyText": "This PR does not change the logic, it just moves it to be shared. I think all observations are good and having this library shared helps us doing the improvements once.", "author": "bogdandrutu", "createdAt": "2020-01-28T15:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzkwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371893900", "bodyText": "That's fair. When this gets merged, I'll put in a quick PR to simplify the logic and make it less blocking.", "author": "jkwatson", "createdAt": "2020-01-28T15:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}], "type": "inlineReview"}]}