{"pr_number": 1380, "pr_title": "Implemented base zPages classes and TraceZ zPage", "pr_createdAt": "2020-06-29T15:47:57Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380", "timeline": [{"oid": "accdd4b4c870cee12aa33bf6310bc268067b8600", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/accdd4b4c870cee12aa33bf6310bc268067b8600", "message": "Javadoc description update (#16)\n\n* Minor javadoc wording update", "committedDate": "2020-06-29T14:36:07Z", "type": "forcePushed"}, {"oid": "9ca81bc037a1d7b9384f74d24e62846cc8007972", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/9ca81bc037a1d7b9384f74d24e62846cc8007972", "message": "Implemented a span processor for the TraceZ zPage", "committedDate": "2020-06-29T18:47:15Z", "type": "commit"}, {"oid": "86c6db8d38c11c292eab92d71cbcf4b8503a2615", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/86c6db8d38c11c292eab92d71cbcf4b8503a2615", "message": "Implemented aggregation logic for running and latency based spans,\nsummary table generation with running span logic", "committedDate": "2020-06-29T18:47:27Z", "type": "commit"}, {"oid": "66bafe20481caadd4b4ee541edb4dfedae896148", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/66bafe20481caadd4b4ee541edb4dfedae896148", "message": "Implemented aggregation logic for error based spans", "committedDate": "2020-06-29T18:51:00Z", "type": "commit"}, {"oid": "af80d27e7921040258e294956774b5dc1e3681d3", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/af80d27e7921040258e294956774b5dc1e3681d3", "message": "Finished implementation of TraceZ zPage summary table", "committedDate": "2020-06-29T18:51:28Z", "type": "commit"}, {"oid": "d2eb7be705e2a5702de0761258988604fad7d3e0", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d2eb7be705e2a5702de0761258988604fad7d3e0", "message": "Finished implementation of HttpHandler, HttpServer, and TraceZ zPage", "committedDate": "2020-06-29T18:52:19Z", "type": "commit"}, {"oid": "d2eb7be705e2a5702de0761258988604fad7d3e0", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d2eb7be705e2a5702de0761258988604fad7d3e0", "message": "Finished implementation of HttpHandler, HttpServer, and TraceZ zPage", "committedDate": "2020-06-29T18:52:19Z", "type": "forcePushed"}, {"oid": "219d3834e2e4021936f241613e016523e3f5a0b9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/219d3834e2e4021936f241613e016523e3f5a0b9", "message": "Refactored the sdk_contrib folder to follow updated syntax", "committedDate": "2020-06-29T19:15:32Z", "type": "commit"}, {"oid": "219d3834e2e4021936f241613e016523e3f5a0b9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/219d3834e2e4021936f241613e016523e3f5a0b9", "message": "Refactored the sdk_contrib folder to follow updated syntax", "committedDate": "2020-06-29T19:15:32Z", "type": "forcePushed"}, {"oid": "febc45317c659821b15b59945661476e92e9811e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/febc45317c659821b15b59945661476e92e9811e", "message": "Merge branch 'master' into master", "committedDate": "2020-06-29T19:30:06Z", "type": "commit"}, {"oid": "425e436b9954219329b0b54327cdc2ca3493a287", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/425e436b9954219329b0b54327cdc2ca3493a287", "message": "Removed duplicate function", "committedDate": "2020-06-29T19:37:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxMzU3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447213579", "bodyText": "rather than synchronizing everything, what do you think about using a ConcurrentMap implementation?", "author": "jkwatson", "createdAt": "2020-06-29T19:49:58Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new HashMap<>();\n+    completedSpanCache = new HashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    synchronized (this) {", "originalCommit": "425e436b9954219329b0b54327cdc2ca3493a287", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1NDg4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447254888", "bodyText": "Yeah, that seems to be better here. However, if we impose a max value on the number of spans, then I'll have to decide how to best evict spans, and I might build my own data structure for that.", "author": "williamhu99", "createdAt": "2020-06-29T21:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxMzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzIwOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447263208", "bodyText": "On second thought, I might use an EvictingQueue.", "author": "williamhu99", "createdAt": "2020-06-29T21:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxMzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODAwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448048009", "bodyText": "caffeine is pretty small and a great library, would consider it if we end up with an LRU. We want to keep dependencies light but I would definitely want a good cache implementation backing a span processor that hits every span.", "author": "anuraaga", "createdAt": "2020-07-01T00:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxMzU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDA5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447214090", "bodyText": "It looks like this completedSpanCache will grow without bounds. We need to make sure that we don't hold references to these spans indefinitely.", "author": "jkwatson", "createdAt": "2020-06-29T19:50:51Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new HashMap<>();\n+    completedSpanCache = new HashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    synchronized (this) {\n+      runningSpanCache.put(span.getSpanContext().getSpanId(), span);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    SpanId id = span.getSpanContext().getSpanId();\n+    synchronized (this) {\n+      runningSpanCache.remove(id);\n+      if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+        completedSpanCache.put(id, span);", "originalCommit": "425e436b9954219329b0b54327cdc2ca3493a287", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1MzYxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447253614", "bodyText": "What should the maximum size be? OpenCensus uses Integer.MAX_VALUE.", "author": "williamhu99", "createdAt": "2020-06-29T21:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MTkzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447261936", "bodyText": "It looks like 10 per bucket to me:  https://github.com/census-instrumentation/opencensus-java/blob/68e19edba8da513d20d2b62f6803463fcb02fd4f/impl_core/src/main/java/io/opencensus/implcore/trace/export/InProcessSampledSpanStoreImpl.java#L42\nWhere are you seeing Integer.MAX_VALUE?", "author": "jkwatson", "createdAt": "2020-06-29T21:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzgwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447263809", "bodyText": "For the running span store, they use Integer.MAX_VALUE. Are we interested in keeping 10 per latency bucket and 5 per error bucket?", "author": "williamhu99", "createdAt": "2020-06-29T21:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NDQyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447264426", "bodyText": "ah, yeah, I'm not worried about the running spans. They will be naturally limited by the SDK itself.", "author": "jkwatson", "createdAt": "2020-06-29T21:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NzA2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447267066", "bodyText": "Ah, I see. Then, I'll go ahead and modify the implementation to use 10 and 5 per bucket for the completed spans.", "author": "williamhu99", "createdAt": "2020-06-29T21:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNDM4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448614380", "bodyText": "I updated the implementation with a class similar to what OpenCensus uses. Let me know what you think!", "author": "williamhu99", "createdAt": "2020-07-01T21:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNTM1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447215355", "bodyText": "It would probably be better not to link to this. If it gets moved, then every zpage view in the world will be broken. Better would be to have it hosted internal to the module.", "author": "jkwatson", "createdAt": "2020-06-29T19:53:18Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  /**\n+   * Constructs a new {@code TracezZPageHandler}.\n+   *\n+   * @return a new {@code TracezZPageHandler}.\n+   */\n+  static TracezZPageHandler create(@javax.annotation.Nullable TracezDataAggregator dataAggregator) {\n+    return new TracezZPageHandler(dataAggregator);\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintWriter} {@code out}. Content emited by this function should\n+   * be enclosed by <head></head> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintWriter out) {\n+    out.write(\"<style>\");\n+    out.write(ZPageStyle.style);\n+    out.write(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintWriter out, Formatter formatter) {\n+    // First row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.write(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.write(\"</tr>\");\n+\n+    // Second row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1></th>\");\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[%s]</b></th>\",\n+          LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundaries));\n+    }\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.write(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter {@link Formatter} for formatting HTML expressions.\n+   * @param spanName The name of the corresponding span.\n+   * @param numOfSamples The number of samples of the corresponding span.\n+   * @param type The type of the corresponding span (running, latency, error).\n+   * @param subtype The sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintWriter out,\n+      Formatter formatter,\n+      String spanName,\n+      int numOfSamples,\n+      SampleType type,\n+      int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      formatter.format(\n+          \"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?%s=%s&%s=%d&%s=%d\\\">%d</a></td>\",\n+          PARAM_SPAN_NAME,\n+          URLEncoder.encode(spanName, \"UTF-8\"),\n+          PARAM_SAMPLE_TYPE,\n+          type.getValue(),\n+          PARAM_SAMPLE_SUB_TYPE,\n+          subtype,\n+          numOfSamples);\n+    } else if (numOfSamples < 0) {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintWriter} {@code\n+   * out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private void emitSummaryTable(PrintWriter out, Formatter formatter)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out, formatter);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundaries, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        formatter.format(\"<tr style=\\\"background-color: %s\\\">\", ZEBRA_STRIPE_COLOR);\n+      } else {\n+        out.write(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      formatter.format(\"<td>%s</td>\", htmlEscaper().escape(spanName));\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, formatter, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundaries)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundaries)\n+                : 0;\n+        emitSummaryTableCell(\n+            out, formatter, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, formatter, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      Formatter formatter, String spanName, int count, SampleType type) {\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: %s </b></p>\", htmlEscaper().escape(spanName));\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Number of %s: %d </b></p>\",\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\",\n+        count);\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintWriter out, Formatter formatter, Collection<SpanData> spans) {\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.write(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.write(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.write(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintWriter out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.write(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.write(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintWriter out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.write(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);\n+    attributes.forEach(\n+        new KeyValueConsumer<AttributeValue>() {\n+          @Override\n+          public void consume(String key, AttributeValue value) {\n+            if (!first.getAndSet(false)) {\n+              stringBuilder.append(\", \");\n+            }\n+            stringBuilder.append(key);\n+            stringBuilder.append(\"=\");\n+            stringBuilder.append(value.toString());\n+          }\n+        });\n+    stringBuilder.append(\"}\");\n+    return stringBuilder.toString();\n+  }\n+\n+  private static String renderEvent(Event event) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(event.getName());\n+    if (!event.getAttributes().isEmpty()) {\n+      stringBuilder.append(\" | \");\n+      stringBuilder.append(renderAttributes(event.getAttributes()));\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  /**\n+   * Emits HTML body content to the {@link PrintWriter} {@code out}. Content emited by this function\n+   * should be enclosed by <body></body> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private void emitHtmlBody(Map<String, String> queryMap, PrintWriter out)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      out.write(\"OpenTelemetry implementation not available.\");\n+      return;\n+    }\n+    // Link to OpenTelemetry Logo\n+    out.write(\n+        \"<img style=\\\"height: 90px;\\\"\"\n+            + \"src=\\\"https://opentelemetry.io/img/logos/opentelemetry-horizontal-color.png\\\" />\");", "originalCommit": "425e436b9954219329b0b54327cdc2ca3493a287", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ2MTM3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447461377", "bodyText": "Another possibility is to use data:image/png;base64 encoding", "author": "thisthat", "createdAt": "2020-06-30T07:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNTM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MDY4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447960684", "bodyText": "Thanks for the suggestion, changed to use base64 encoding", "author": "wtyanan", "createdAt": "2020-06-30T20:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNTM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447222722", "bodyText": "I'm pretty hesitant to depend on anything in the com.sun namespace. There is no guarentee that all JDKs will support this, or that these classes will be around in the future.", "author": "jkwatson", "createdAt": "2020-06-29T20:07:12Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;", "originalCommit": "425e436b9954219329b0b54327cdc2ca3493a287", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIzMjA4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447232088", "bodyText": "Is there any suggested alternative of a HttpServer? OpenCensus also used this way of implementation and seems like major JDKs supports this", "author": "wtyanan", "createdAt": "2020-06-29T20:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI0Mzg4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447243885", "bodyText": "I'm not saying we can't use it..it just gives me pause. If we go ahead with this, we should make the documentation super clear about the dependency on a JRE/JDK that has these classes included.", "author": "jkwatson", "createdAt": "2020-06-29T20:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NzU3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447877570", "bodyText": "I spent some time researching this, and after consulting with some long-time JVM/JDK gurus (well, one guru: @kittylyst), I think this is fine. We should still document it, but I think this will be just fine, especially as a extension module.", "author": "jkwatson", "createdAt": "2020-06-30T18:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDA0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448050041", "bodyText": "I see the dependency in build.gradle, I guess either way we're requiring it as a dependency, not relying on the JDK? Want to make sure I didn't miss something", "author": "anuraaga", "createdAt": "2020-07-01T00:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAzMTE5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449031190", "bodyText": "I included the dependency so that VSCode didn't give me any errors (it's complaining about the same issue as com.sun is not standard in all JDKs), does that help with the issue with JDK as well?", "author": "wtyanan", "createdAt": "2020-07-02T14:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2NDM4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449164388", "bodyText": "yeah, interesting that this is also published to maven central. Pretty old datestamp on that release, but it does look to be the same code built-in to JDK 11, at least with a cursory examination of the classes.", "author": "jkwatson", "createdAt": "2020-07-02T17:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ2MjAzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447462031", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019, OpenTelemetry Authors\n          \n          \n            \n             * Copyright 2020, OpenTelemetry Authors", "author": "thisthat", "createdAt": "2020-06-30T07:16:32Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors", "originalCommit": "425e436b9954219329b0b54327cdc2ca3493a287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ2MzUwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447463505", "bodyText": "SimpleSpanProcessor uses this env var. I suggest using your own name, e.g. otel.zpages.export.sampled", "author": "thisthat", "createdAt": "2020-06-30T07:19:19Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.", "originalCommit": "425e436b9954219329b0b54327cdc2ca3493a287", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNDAwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448614009", "bodyText": "Updated the env var", "author": "williamhu99", "createdAt": "2020-07-01T21:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ2MzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczMDUzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447730532", "bodyText": "Return a copy perhaps?", "author": "carlosalberto", "createdAt": "2020-06-30T14:32:10Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new HashMap<>();\n+    completedSpanCache = new HashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    synchronized (this) {\n+      runningSpanCache.put(span.getSpanContext().getSpanId(), span);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    SpanId id = span.getSpanContext().getSpanId();\n+    synchronized (this) {\n+      runningSpanCache.remove(id);\n+      if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+        completedSpanCache.put(id, span);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // Do nothing.\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Returns a Collection of all running spans for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link io.opentelemetry.sdk.trace.ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getRunningSpans() {\n+    synchronized (this) {\n+      return runningSpanCache.values();\n+    }\n+  }\n+\n+  /**\n+   * Returns a Collection of all completed spans for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link io.opentelemetry.sdk.trace.ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getCompletedSpans() {", "originalCommit": "425e436b9954219329b0b54327cdc2ca3493a287", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f282f241ab9e6b4223576ab376dfca7543c3a8f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0f282f241ab9e6b4223576ab376dfca7543c3a8f", "message": "Changed inline base64 images", "committedDate": "2020-06-30T20:29:14Z", "type": "commit"}, {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "message": "Fixed copyright statement", "committedDate": "2020-06-30T20:33:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0MzY5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448043699", "bodyText": "Looks like can be package private", "author": "anuraaga", "createdAt": "2020-07-01T00:01:25Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+public final class TracezDataAggregator {", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzg2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448613865", "bodyText": "Changed to package private!", "author": "williamhu99", "createdAt": "2020-07-01T21:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0MzY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDEzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448044130", "bodyText": "Should we have a cap on the size of this? running spans seems small, but worried about the size of completed spans.", "author": "anuraaga", "createdAt": "2020-07-01T00:02:55Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+public final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDgzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448044835", "bodyText": "Looks like we have a dependency on Guava. How about using immutable collections (e.g. ImmutableSortedSet) for all of these?", "author": "anuraaga", "createdAt": "2020-07-01T00:05:41Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+public final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMzc1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448613757", "bodyText": "I'm open to using the immutable collections, but I'll wait for you to take a look at the new code in case something changes.", "author": "williamhu99", "createdAt": "2020-07-01T21:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NjYwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448046606", "bodyText": "@jkwatson What do you think about adding .getStatus to ReadableSpan (I guess it should really have all the getters?). Going through toSpanData just to check if the span is ok seems off.", "author": "anuraaga", "createdAt": "2020-07-01T00:11:33Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+public final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    Collection<ReadableSpan> allCompletedSpans = spanProcessor.getCompletedSpans();\n+    for (ReadableSpan span : allCompletedSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link io.opentelemetry.sdk.trace.data.SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * A class of boundaries for the latency buckets. The completed spans with a status of {@link\n+   * io.opentelemetry.trace.Status#OK} are categorized into one of these buckets om the traceZ\n+   * zPage.\n+   */\n+  public enum LatencyBoundaries {\n+    /** Stores finished successful requests of duration within the interval [0, 10us). */\n+    ZERO_MICROSx10(0, TimeUnit.MICROSECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10us, 100us). */\n+    MICROSx10_MICROSx100(TimeUnit.MICROSECONDS.toNanos(10), TimeUnit.MICROSECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration within the interval [100us, 1ms). */\n+    MICROSx100_MILLIx1(TimeUnit.MICROSECONDS.toNanos(100), TimeUnit.MILLISECONDS.toNanos(1)),\n+\n+    /** Stores finished successful requests of duration within the interval [1ms, 10ms). */\n+    MILLIx1_MILLIx10(TimeUnit.MILLISECONDS.toNanos(1), TimeUnit.MILLISECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10ms, 100ms). */\n+    MILLIx10_MILLIx100(TimeUnit.MILLISECONDS.toNanos(10), TimeUnit.MILLISECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration within the interval [100ms, 1sec). */\n+    MILLIx100_SECONDx1(TimeUnit.MILLISECONDS.toNanos(100), TimeUnit.SECONDS.toNanos(1)),\n+\n+    /** Stores finished successful requests of duration within the interval [1sec, 10sec). */\n+    SECONDx1_SECONDx10(TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10sec, 100sec). */\n+    SECONDx10_SECONDx100(TimeUnit.SECONDS.toNanos(10), TimeUnit.SECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration greater than or equal to 100sec. */\n+    SECONDx100_MAX(TimeUnit.SECONDS.toNanos(100), Long.MAX_VALUE);\n+\n+    private final long latencyLowerBound;\n+    private final long latencyUpperBound;\n+\n+    /**\n+     * Constructs a {@code LatencyBoundaries} with the given boundaries and label.\n+     *\n+     * @param latencyLowerBound the latency lower bound of the bucket.\n+     * @param latencyUpperBound the latency upper bound of the bucket.\n+     */\n+    LatencyBoundaries(long latencyLowerBound, long latencyUpperBound) {\n+      this.latencyLowerBound = latencyLowerBound;\n+      this.latencyUpperBound = latencyUpperBound;\n+    }\n+\n+    /**\n+     * Returns the latency lower bound of the bucket.\n+     *\n+     * @return the latency lower bound of the bucket.\n+     */\n+    public long getLatencyLowerBound() {\n+      return latencyLowerBound;\n+    }\n+\n+    /**\n+     * Returns the latency upper bound of the bucket.\n+     *\n+     * @return the latency upper bound of the bucket.\n+     */\n+    public long getLatencyUpperBound() {\n+      return latencyUpperBound;\n+    }\n+  }\n+\n+  /**\n+   * Returns a Map of counts for the {@link io.opentelemetry.trace.Status#OK} spans within\n+   * [lowerBound, upperBound) {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a Map of span counts for each span name within the bounds.\n+   */\n+  public Map<String, Integer> getSpanLatencyCounts(long lowerBound, long upperBound) {\n+    Collection<ReadableSpan> allCompletedSpans = spanProcessor.getCompletedSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allCompletedSpans) {\n+      if (span.toSpanData().getStatus().isOk()", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNTEyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448615122", "bodyText": "That sounds totally reasonble to me.", "author": "jkwatson", "createdAt": "2020-07-01T21:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODkyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448048929", "bodyText": "I see there is mention about capping the size of this map, but in general I'm sort of concerned about the design of the class if it's based on keeping a map of all completed spans. Can we incrementally update data structures in this class instead? Keeping running spans as a map is ok I think since it should be bounded and avoids having to both incrementally update and revert structures, but if I'm not missing it, it seems that all the structures computed from this map can be inlined and updated incrementally instead?\nOf course if going with incremental, the comment about Immutable goes away :)", "author": "anuraaga", "createdAt": "2020-07-01T00:20:32Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMjQ1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448612452", "bodyText": "I've updated the completedSpanCache to limit the number of latency and error spans. I'm not quite sure what you mean by updating the cache incrementally, but I hope the new changes address some of your concerns.", "author": "williamhu99", "createdAt": "2020-07-01T20:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4MjQ0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448682441", "bodyText": "So for example, we have a method getSpanNames, instead of iterating over running /completed spans, the processor can be something like\nTracezSpanProcessor\n\nprivate final Set<String> spanNames;\n\nonStart(span) {\n  spanNames.add(span.name);\n}\n\nonEnd(span) {\n  spanNames.add(span.name);\n}\n\nAnd getSpanNames can just return that directly. From what I can tell, the information is mostly sets of names and counts, so I think we could do a similar approach for all of them (I didn't do a deep dive though so let me know if I missed something).\nWith the cap on the cache, things are still much safer, but if we keep track of the metrics themselves without storing spans, we wouldn't even need to worry about it, and I guess have better metrics? What do you think?", "author": "anuraaga", "createdAt": "2020-07-02T00:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4MzE3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448683175", "bodyText": "Ah, I notice with the new code, actually names is using this pattern. Can't we apply something similar to all the metrics?", "author": "anuraaga", "createdAt": "2020-07-02T00:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQwNDgwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r450404805", "bodyText": "This makes sense for span names, so I'll go ahead and modify the implementation. For other metrics (counts in particular), what exactly did you have in mind? I'm not opposed to maintaining separate list for spans and counts, but I feel like this results in a bunch of repeated information. In addition, a few of the functions in TracezDataAggregator filter by span name or latency. Should a separate list be maintained for each of these functions?", "author": "williamhu99", "createdAt": "2020-07-06T18:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDY0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448050647", "bodyText": "Let's use try / resources, think there's plenty of room for exceptions in the middle causing a leak.", "author": "anuraaga", "createdAt": "2020-07-01T00:27:13Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  /**\n+   * Constructs a new {@code TracezZPageHandler}.\n+   *\n+   * @return a new {@code TracezZPageHandler}.\n+   */\n+  static TracezZPageHandler create(@javax.annotation.Nullable TracezDataAggregator dataAggregator) {\n+    return new TracezZPageHandler(dataAggregator);\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintWriter} {@code out}. Content emited by this function should\n+   * be enclosed by <head></head> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintWriter out) {\n+    out.write(\"<style>\");\n+    out.write(ZPageStyle.style);\n+    out.write(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintWriter out, Formatter formatter) {\n+    // First row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.write(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.write(\"</tr>\");\n+\n+    // Second row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1></th>\");\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[%s]</b></th>\",\n+          LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundaries));\n+    }\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.write(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter {@link Formatter} for formatting HTML expressions.\n+   * @param spanName The name of the corresponding span.\n+   * @param numOfSamples The number of samples of the corresponding span.\n+   * @param type The type of the corresponding span (running, latency, error).\n+   * @param subtype The sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintWriter out,\n+      Formatter formatter,\n+      String spanName,\n+      int numOfSamples,\n+      SampleType type,\n+      int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      formatter.format(\n+          \"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?%s=%s&%s=%d&%s=%d\\\">%d</a></td>\",\n+          PARAM_SPAN_NAME,\n+          URLEncoder.encode(spanName, \"UTF-8\"),\n+          PARAM_SAMPLE_TYPE,\n+          type.getValue(),\n+          PARAM_SAMPLE_SUB_TYPE,\n+          subtype,\n+          numOfSamples);\n+    } else if (numOfSamples < 0) {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintWriter} {@code\n+   * out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private void emitSummaryTable(PrintWriter out, Formatter formatter)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out, formatter);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundaries, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        formatter.format(\"<tr style=\\\"background-color: %s\\\">\", ZEBRA_STRIPE_COLOR);\n+      } else {\n+        out.write(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      formatter.format(\"<td>%s</td>\", htmlEscaper().escape(spanName));\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, formatter, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundaries)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundaries)\n+                : 0;\n+        emitSummaryTableCell(\n+            out, formatter, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, formatter, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      Formatter formatter, String spanName, int count, SampleType type) {\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: %s </b></p>\", htmlEscaper().escape(spanName));\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Number of %s: %d </b></p>\",\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\",\n+        count);\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintWriter out, Formatter formatter, Collection<SpanData> spans) {\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.write(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.write(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.write(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintWriter out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.write(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.write(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintWriter out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.write(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);\n+    attributes.forEach(\n+        new KeyValueConsumer<AttributeValue>() {\n+          @Override\n+          public void consume(String key, AttributeValue value) {\n+            if (!first.getAndSet(false)) {\n+              stringBuilder.append(\", \");\n+            }\n+            stringBuilder.append(key);\n+            stringBuilder.append(\"=\");\n+            stringBuilder.append(value.toString());\n+          }\n+        });\n+    stringBuilder.append(\"}\");\n+    return stringBuilder.toString();\n+  }\n+\n+  private static String renderEvent(Event event) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(event.getName());\n+    if (!event.getAttributes().isEmpty()) {\n+      stringBuilder.append(\" | \");\n+      stringBuilder.append(renderAttributes(event.getAttributes()));\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  /**\n+   * Emits HTML body content to the {@link PrintWriter} {@code out}. Content emited by this function\n+   * should be enclosed by <body></body> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private void emitHtmlBody(Map<String, String> queryMap, PrintWriter out)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      out.write(\"OpenTelemetry implementation not available.\");\n+      return;\n+    }\n+    // Link to OpenTelemetry Logo\n+    out.write(\n+        \"<img style=\\\"height: 90px;\\\"\"\n+            + \"src=\\\"data:image/png;base64,\"\n+            + ZPageLogo.logoBase64\n+            + \"\\\" />\");\n+    out.write(\"<h1>TraceZ Summary</h1>\");\n+    Formatter formatter = new Formatter(out, Locale.US);\n+    emitSummaryTable(out, formatter);\n+    // spanName will be null if the query parameter doesn't exist in the URL\n+    String spanName = queryMap.get(PARAM_SPAN_NAME);\n+    if (spanName != null) {\n+      // Show detailed information for the corresponding span\n+      String typeStr = queryMap.get(PARAM_SAMPLE_TYPE);\n+      if (typeStr != null) {\n+        List<SpanData> spans = null;\n+        SampleType type = SampleType.fromString(typeStr);\n+        if (type == SampleType.UNKNOWN) {\n+          // Type of sample is garbage value\n+          return;\n+        } else if (type == SampleType.RUNNING) {\n+          // Display running span\n+          spans = dataAggregator.getRunningSpans(spanName);\n+          Collections.sort(spans, new SpanDataComparator(/* incremental= */ true));\n+        } else {\n+          String subtypeStr = queryMap.get(PARAM_SAMPLE_SUB_TYPE);\n+          if (subtypeStr != null) {\n+            int subtype = Integer.parseInt(subtypeStr);\n+            if (type == SampleType.LATENCY) {\n+              if (subtype < 0 || subtype >= LatencyBoundaries.values().length) {\n+                // N/A or out-of-bound check for latency based subtype, valid values: [0, 8]\n+                return;\n+              }\n+              // Display latency based span\n+              LatencyBoundaries latencyBoundary = LatencyBoundaries.values()[subtype];\n+              spans =\n+                  dataAggregator.getOkSpans(\n+                      spanName,\n+                      latencyBoundary.getLatencyLowerBound(),\n+                      latencyBoundary.getLatencyUpperBound());\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            } else {\n+              if (subtype < 0 || subtype >= CanonicalCode.values().length) {\n+                // N/A or out-of-bound cueck for error based subtype, valid values: [0, 15]\n+                return;\n+              }\n+              // Display error based span\n+              spans = dataAggregator.getErrorSpans(spanName);\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            }\n+          }\n+        }\n+        out.write(\"<h2>Span Details</h2>\");\n+        emitSpanNameAndCount(formatter, spanName, spans == null ? 0 : spans.size(), type);\n+\n+        if (spans != null) {\n+          emitSpanDetails(out, formatter, spans);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void emitHtml(Map<String, String> queryMap, OutputStream outputStream) {\n+    // PrintWriter for emiting HTML contents\n+    PrintWriter out =", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMDU3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449130577", "bodyText": "Used try resources in the latest commit, could you check if it is correct?", "author": "wtyanan", "createdAt": "2020-07-02T16:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MTc5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448051791", "bodyText": "Think we can keep this package private since the server class registers it. We could also have a factory that returns SpanProcessor if that seems useful without exposing the implementation class", "author": "anuraaga", "createdAt": "2020-07-01T00:31:36Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTY3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448611678", "bodyText": "Changed the class to package private", "author": "williamhu99", "createdAt": "2020-07-01T20:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjAyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448052028", "bodyText": "Import @Nullable", "author": "anuraaga", "createdAt": "2020-07-01T00:32:27Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjA3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448052076", "bodyText": "Group static finals together above normal final field", "author": "anuraaga", "createdAt": "2020-07-01T00:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjIwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448052207", "bodyText": "@Nullable on parameter", "author": "anuraaga", "createdAt": "2020-07-01T00:33:13Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjI1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448052257", "bodyText": "The class is package private, I think we can make the constructor package private and remove this factory", "author": "anuraaga", "createdAt": "2020-07-01T00:33:26Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  /**\n+   * Constructs a new {@code TracezZPageHandler}.\n+   *\n+   * @return a new {@code TracezZPageHandler}.\n+   */\n+  static TracezZPageHandler create(@javax.annotation.Nullable TracezDataAggregator dataAggregator) {", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzI0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448053246", "bodyText": "Think we can just use PrintStream since we're going to an OutputStream anyways.\nAlso I'd leave the BufferedWriter or BufferedOutputStream out here and let callers pass it in, they may not want the buffering.", "author": "anuraaga", "createdAt": "2020-07-01T00:37:11Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  /**\n+   * Constructs a new {@code TracezZPageHandler}.\n+   *\n+   * @return a new {@code TracezZPageHandler}.\n+   */\n+  static TracezZPageHandler create(@javax.annotation.Nullable TracezDataAggregator dataAggregator) {\n+    return new TracezZPageHandler(dataAggregator);\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintWriter} {@code out}. Content emited by this function should\n+   * be enclosed by <head></head> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintWriter out) {\n+    out.write(\"<style>\");\n+    out.write(ZPageStyle.style);\n+    out.write(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintWriter out, Formatter formatter) {\n+    // First row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.write(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.write(\"</tr>\");\n+\n+    // Second row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1></th>\");\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[%s]</b></th>\",\n+          LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundaries));\n+    }\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.write(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter {@link Formatter} for formatting HTML expressions.\n+   * @param spanName The name of the corresponding span.\n+   * @param numOfSamples The number of samples of the corresponding span.\n+   * @param type The type of the corresponding span (running, latency, error).\n+   * @param subtype The sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintWriter out,\n+      Formatter formatter,\n+      String spanName,\n+      int numOfSamples,\n+      SampleType type,\n+      int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      formatter.format(\n+          \"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?%s=%s&%s=%d&%s=%d\\\">%d</a></td>\",\n+          PARAM_SPAN_NAME,\n+          URLEncoder.encode(spanName, \"UTF-8\"),\n+          PARAM_SAMPLE_TYPE,\n+          type.getValue(),\n+          PARAM_SAMPLE_SUB_TYPE,\n+          subtype,\n+          numOfSamples);\n+    } else if (numOfSamples < 0) {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintWriter} {@code\n+   * out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private void emitSummaryTable(PrintWriter out, Formatter formatter)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out, formatter);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundaries, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        formatter.format(\"<tr style=\\\"background-color: %s\\\">\", ZEBRA_STRIPE_COLOR);\n+      } else {\n+        out.write(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      formatter.format(\"<td>%s</td>\", htmlEscaper().escape(spanName));\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, formatter, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundaries)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundaries)\n+                : 0;\n+        emitSummaryTableCell(\n+            out, formatter, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, formatter, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      Formatter formatter, String spanName, int count, SampleType type) {\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: %s </b></p>\", htmlEscaper().escape(spanName));\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Number of %s: %d </b></p>\",\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\",\n+        count);\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintWriter out, Formatter formatter, Collection<SpanData> spans) {\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.write(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.write(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.write(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintWriter out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.write(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.write(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintWriter out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.write(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);\n+    attributes.forEach(\n+        new KeyValueConsumer<AttributeValue>() {\n+          @Override\n+          public void consume(String key, AttributeValue value) {\n+            if (!first.getAndSet(false)) {\n+              stringBuilder.append(\", \");\n+            }\n+            stringBuilder.append(key);\n+            stringBuilder.append(\"=\");\n+            stringBuilder.append(value.toString());\n+          }\n+        });\n+    stringBuilder.append(\"}\");\n+    return stringBuilder.toString();\n+  }\n+\n+  private static String renderEvent(Event event) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(event.getName());\n+    if (!event.getAttributes().isEmpty()) {\n+      stringBuilder.append(\" | \");\n+      stringBuilder.append(renderAttributes(event.getAttributes()));\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  /**\n+   * Emits HTML body content to the {@link PrintWriter} {@code out}. Content emited by this function\n+   * should be enclosed by <body></body> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private void emitHtmlBody(Map<String, String> queryMap, PrintWriter out)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      out.write(\"OpenTelemetry implementation not available.\");\n+      return;\n+    }\n+    // Link to OpenTelemetry Logo\n+    out.write(\n+        \"<img style=\\\"height: 90px;\\\"\"\n+            + \"src=\\\"data:image/png;base64,\"\n+            + ZPageLogo.logoBase64\n+            + \"\\\" />\");\n+    out.write(\"<h1>TraceZ Summary</h1>\");\n+    Formatter formatter = new Formatter(out, Locale.US);\n+    emitSummaryTable(out, formatter);\n+    // spanName will be null if the query parameter doesn't exist in the URL\n+    String spanName = queryMap.get(PARAM_SPAN_NAME);\n+    if (spanName != null) {\n+      // Show detailed information for the corresponding span\n+      String typeStr = queryMap.get(PARAM_SAMPLE_TYPE);\n+      if (typeStr != null) {\n+        List<SpanData> spans = null;\n+        SampleType type = SampleType.fromString(typeStr);\n+        if (type == SampleType.UNKNOWN) {\n+          // Type of sample is garbage value\n+          return;\n+        } else if (type == SampleType.RUNNING) {\n+          // Display running span\n+          spans = dataAggregator.getRunningSpans(spanName);\n+          Collections.sort(spans, new SpanDataComparator(/* incremental= */ true));\n+        } else {\n+          String subtypeStr = queryMap.get(PARAM_SAMPLE_SUB_TYPE);\n+          if (subtypeStr != null) {\n+            int subtype = Integer.parseInt(subtypeStr);\n+            if (type == SampleType.LATENCY) {\n+              if (subtype < 0 || subtype >= LatencyBoundaries.values().length) {\n+                // N/A or out-of-bound check for latency based subtype, valid values: [0, 8]\n+                return;\n+              }\n+              // Display latency based span\n+              LatencyBoundaries latencyBoundary = LatencyBoundaries.values()[subtype];\n+              spans =\n+                  dataAggregator.getOkSpans(\n+                      spanName,\n+                      latencyBoundary.getLatencyLowerBound(),\n+                      latencyBoundary.getLatencyUpperBound());\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            } else {\n+              if (subtype < 0 || subtype >= CanonicalCode.values().length) {\n+                // N/A or out-of-bound cueck for error based subtype, valid values: [0, 15]\n+                return;\n+              }\n+              // Display error based span\n+              spans = dataAggregator.getErrorSpans(spanName);\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            }\n+          }\n+        }\n+        out.write(\"<h2>Span Details</h2>\");\n+        emitSpanNameAndCount(formatter, spanName, spans == null ? 0 : spans.size(), type);\n+\n+        if (spans != null) {\n+          emitSpanDetails(out, formatter, spans);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void emitHtml(Map<String, String> queryMap, OutputStream outputStream) {\n+    // PrintWriter for emiting HTML contents\n+    PrintWriter out =\n+        new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream, Charsets.UTF_8)));", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzUxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448053514", "bodyText": "parseQueryMap", "author": "anuraaga", "createdAt": "2020-07-01T00:38:13Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** An {@link HttpHanlder} that will be used to render HTML pages using any {@code ZPageHandler}. */\n+final class ZPageHttpHandler implements HttpHandler {\n+  // The corresponding ZPageHandler for the zPage (e.g. TracezZPageHandler)\n+  private final ZPageHandler zpageHandler;\n+\n+  /** Constructs a new {@code ZPageHttpHandler}. */\n+  ZPageHttpHandler(ZPageHandler zpageHandler) {\n+    this.zpageHandler = zpageHandler;\n+  }\n+\n+  /**\n+   * Build a query map from the {@code uri}.\n+   *\n+   * @param uri the {@link URI} for buiding the query map\n+   * @return the query map built based on the @{code uri}\n+   */\n+  @VisibleForTesting\n+  static ImmutableMap<String, String> queryMapBuilder(URI uri) {", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448053822", "bodyText": "It's mysterious that a get method has a side effect like registering a span processor. We should at least document this in the javadoc.", "author": "anuraaga", "createdAt": "2020-07-01T00:39:33Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      TracezZPageHandler.create(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile boolean isTracezSpanProcesserAdded = false;\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (!isTracezSpanProcesserAdded) {\n+      synchronized (mutex) {\n+        if (isTracezSpanProcesserAdded) {\n+          return;\n+        }\n+        TracerSdkProvider tracerProvider = OpenTelemetrySdk.getTracerProvider();\n+        tracerProvider.addSpanProcessor(tracezSpanProcessor);\n+        isTracezSpanProcesserAdded = true;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns a {@code ZPageHandler} for tracing debug. The page displays information about all\n+   * running spans and all sampled spans based on latency and error.\n+   *\n+   * <p>It displays a summary table which contains one row for each span name and data about number\n+   * of running and sampled spans.\n+   *\n+   * <p>Clicking on a cell in the table with a number that is greater than zero will display\n+   * detailed information about that span.\n+   *\n+   * @return a {@code ZPageHandler} for tracing debug.\n+   */\n+  public static ZPageHandler getTracezZPageHandler() {\n+    addTracezSpanProcessor();", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3OTU2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449179564", "bodyText": "I agree. I think this method should be renamed to createAndRegister...", "author": "jkwatson", "createdAt": "2020-07-02T17:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTc3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449185770", "bodyText": "How about createTracezZPageHandler ? It will be called to register the handler to the server", "author": "wtyanan", "createdAt": "2020-07-02T18:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NzE0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449187141", "bodyText": "Actually, I think get... makes some sense since tracezZPageHandler is already constructed/created, I did add documentation stating the side effect", "author": "wtyanan", "createdAt": "2020-07-02T18:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4ODYwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449188604", "bodyText": "Should we really be registering it for the user? Can't they register it themselves, so there isn't this hidden side-effect on a method called 'get'? In Java, a method called 'get...' should not have side-effects, except in extraordinary circumstances.", "author": "jkwatson", "createdAt": "2020-07-02T18:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4OTA3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449189071", "bodyText": "Does this even need to return anything? Could it just be \"registerHandler\" or something?", "author": "jkwatson", "createdAt": "2020-07-02T18:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MDEwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449190104", "bodyText": "This spanProcessor is not related to the user as it's only used by TraceZ zPage, we've discussed this in design doc", "author": "wtyanan", "createdAt": "2020-07-02T18:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MTU1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449191554", "bodyText": "I can also change the way of implementing these sets of functions to \"registerTracezHandler\" and register the handler to the server", "author": "wtyanan", "createdAt": "2020-07-02T18:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMzczOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449313738", "bodyText": "Cool that there's a design doc! Can you make it public?", "author": "anuraaga", "createdAt": "2020-07-02T23:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDQwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449624401", "bodyText": "@anuraaga I've shared it with the email address on your GitHub account!", "author": "wtyanan", "createdAt": "2020-07-03T15:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzMzI0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449633248", "bodyText": "Thanks I can see it! But I still have concerns - OpenTelemetry is an open project so all design docs must be open without needing access or even a Google account. The doc should persist even past internship periods, etc.\nCan you at least make the current doc public to anyone? It's not ideal since Docs is often blocked in China but better than current private sharing. Even better may be to copy it into a otep so it lives in open source\nhttps://github.com/open-telemetry/oteps\nAs an aside, go/bluedoc has great formatting for the content, but a version needs to be made with similar content that is markdown for work in open source in a GitHub-first manner. If you can help with that, it will make it a lot easier for the company to contribute to OSS.\nLet me know if you need any more guidance on this.", "author": "anuraaga", "createdAt": "2020-07-03T15:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcxNzI1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449717259", "bodyText": "Thanks! I'll talk with my intern host regarding this!", "author": "wtyanan", "createdAt": "2020-07-03T23:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNDIyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r450224224", "bodyText": "Due to recent updates, there's no longer a way to make a google doc public from a corp account. So we have two choices: share another doc from your personal account, or share the doc as a markdown file in the repo. I think the latter option makes more sense.", "author": "v-y-l", "createdAt": "2020-07-06T13:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxMDQ5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r450610495", "bodyText": "Thanks for the clarification, yeah markdown seems to make a lot of sense.\n@jkwatson I notice the oteps repo is mainly for spec additions so maybe not for language SDK design docs. Do you think any of these make sense?\n\nopen-telemetry/opentelemetry-java/docs (current repo, docs subfolder to keep design docs for posterity)\nopen-telemetry/opentelemetry-java-docs (java-specific docs repo)\nopen-telemetry/docs/java (docs repo that can have language, or whatever, subfolders)", "author": "anuraaga", "createdAt": "2020-07-07T04:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwOTc0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451409747", "bodyText": "Filed #1397 for this", "author": "anuraaga", "createdAt": "2020-07-08T09:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkxOTE0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453919142", "bodyText": "We will make adjustments to our design docs and make a public markdown version of them around the end of the term", "author": "wtyanan", "createdAt": "2020-07-13T20:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1Mzk5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448053999", "bodyText": "Could just use AtomicBoolean instead of double-check", "author": "anuraaga", "createdAt": "2020-07-01T00:40:14Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      TracezZPageHandler.create(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile boolean isTracezSpanProcesserAdded = false;\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (!isTracezSpanProcesserAdded) {", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NDgzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448054834", "bodyText": "Just an aside, I won't ever start a ZPageServer in my apps :) And will register this directly into my preferred web server, such as Armeria.\nI don't see anything in the design that prevents it and it looks good, but wanted to make sure it's on people's minds :) The only point was about the BufferedWriter which I wouldn't want to use in conjunction with a different server framework.", "author": "anuraaga", "createdAt": "2020-07-01T00:43:20Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHandler.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import java.io.OutputStream;\n+import java.util.Map;\n+\n+/**\n+ * The main interface for all zPages. All zPages should implement this interface to allow the HTTP\n+ * server implementation to support these pages.\n+ */\n+public abstract class ZPageHandler {", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3ODQwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449178400", "bodyText": "It does make me think that we should create a Servlet that does all this stuff, so it would be super easy to plug in to any standard JEE server.", "author": "jkwatson", "createdAt": "2020-07-02T17:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NDgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTEyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448055128", "bodyText": "Do you want to trim anything?", "author": "anuraaga", "createdAt": "2020-07-01T00:44:27Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** An {@link HttpHanlder} that will be used to render HTML pages using any {@code ZPageHandler}. */\n+final class ZPageHttpHandler implements HttpHandler {\n+  // The corresponding ZPageHandler for the zPage (e.g. TracezZPageHandler)\n+  private final ZPageHandler zpageHandler;\n+\n+  /** Constructs a new {@code ZPageHttpHandler}. */\n+  ZPageHttpHandler(ZPageHandler zpageHandler) {\n+    this.zpageHandler = zpageHandler;\n+  }\n+\n+  /**\n+   * Build a query map from the {@code uri}.\n+   *\n+   * @param uri the {@link URI} for buiding the query map\n+   * @return the query map built based on the @{code uri}\n+   */\n+  @VisibleForTesting\n+  static ImmutableMap<String, String> queryMapBuilder(URI uri) {\n+    String queryStrings = uri.getQuery();\n+    if (queryStrings == null) {\n+      return ImmutableMap.of();\n+    }\n+    Map<String, String> queryMap = new HashMap<String, String>();\n+    for (String param : Splitter.on(\"&\").split(queryStrings)) {\n+      List<String> keyValuePair = Splitter.on(\"=\").splitToList(param);\n+      if (keyValuePair.size() > 1) {\n+        queryMap.put(keyValuePair.get(0), keyValuePair.get(1));", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExODkzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449118931", "bodyText": "I went ahead and trimmed both key and value to prevent accidental white space", "author": "wtyanan", "createdAt": "2020-07-02T16:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTUyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448055527", "bodyText": "Unit", "author": "anuraaga", "createdAt": "2020-07-01T00:45:53Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/ZPageServerTest.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** UNit tests for {@link ZPageServer}. */", "originalCommit": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTYwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448055603", "bodyText": "Or just delete this line, it's obvious from the class name ZPageServerTest", "author": "anuraaga", "createdAt": "2020-07-01T00:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTMzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448611331", "bodyText": "Fixed the typo", "author": "williamhu99", "createdAt": "2020-07-01T20:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTUyNw=="}], "type": "inlineReview"}, {"oid": "d7f4904b36b7176c0bbe4c6e692766d4f45fd142", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d7f4904b36b7176c0bbe4c6e692766d4f45fd142", "message": "Modified the TracezSpanProcessor to only allow for a limited number of completed spans (#17)\n\n* Modified the TracezSpanProcessor to only allow for a limited number of completed spans\r\n\r\n* Renamed count functions and reduced logic in addToBucket", "committedDate": "2020-07-01T20:06:40Z", "type": "commit"}, {"oid": "50fe3f13357bd56373e0ed29bc12ab9366958f99", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/50fe3f13357bd56373e0ed29bc12ab9366958f99", "message": "Fixed typos and turned SpanProcessor and DataAggregator to package private", "committedDate": "2020-07-01T20:54:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448616302", "bodyText": "This file is getting really big. I'd pull the inner classes out to the top level (but keep them package access).", "author": "jkwatson", "createdAt": "2020-07-01T21:06:40Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    spanNames.addAll(spanProcessor.getCompletedSpanCache().keySet());\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link io.opentelemetry.sdk.trace.data.SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * A class of boundaries for the latency buckets. The completed spans with a status of {@link\n+   * io.opentelemetry.trace.Status#OK} are categorized into one of these buckets om the traceZ\n+   * zPage.\n+   */\n+  enum LatencyBoundaries {\n+    /** Stores finished successful requests of duration within the interval [0, 10us). */\n+    ZERO_MICROSx10(0, TimeUnit.MICROSECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10us, 100us). */\n+    MICROSx10_MICROSx100(TimeUnit.MICROSECONDS.toNanos(10), TimeUnit.MICROSECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration within the interval [100us, 1ms). */\n+    MICROSx100_MILLIx1(TimeUnit.MICROSECONDS.toNanos(100), TimeUnit.MILLISECONDS.toNanos(1)),\n+\n+    /** Stores finished successful requests of duration within the interval [1ms, 10ms). */\n+    MILLIx1_MILLIx10(TimeUnit.MILLISECONDS.toNanos(1), TimeUnit.MILLISECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10ms, 100ms). */\n+    MILLIx10_MILLIx100(TimeUnit.MILLISECONDS.toNanos(10), TimeUnit.MILLISECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration within the interval [100ms, 1sec). */\n+    MILLIx100_SECONDx1(TimeUnit.MILLISECONDS.toNanos(100), TimeUnit.SECONDS.toNanos(1)),\n+\n+    /** Stores finished successful requests of duration within the interval [1sec, 10sec). */\n+    SECONDx1_SECONDx10(TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10sec, 100sec). */\n+    SECONDx10_SECONDx100(TimeUnit.SECONDS.toNanos(10), TimeUnit.SECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration greater than or equal to 100sec. */\n+    SECONDx100_MAX(TimeUnit.SECONDS.toNanos(100), Long.MAX_VALUE);\n+\n+    private final long latencyLowerBound;\n+    private final long latencyUpperBound;\n+\n+    /**\n+     * Constructs a {@code LatencyBoundaries} with the given boundaries and label.\n+     *\n+     * @param latencyLowerBound the latency lower bound of the bucket.\n+     * @param latencyUpperBound the latency upper bound of the bucket.\n+     */\n+    LatencyBoundaries(long latencyLowerBound, long latencyUpperBound) {\n+      this.latencyLowerBound = latencyLowerBound;\n+      this.latencyUpperBound = latencyUpperBound;\n+    }\n+\n+    /**\n+     * Returns the latency lower bound of the bucket.\n+     *\n+     * @return the latency lower bound of the bucket.\n+     */\n+    long getLatencyLowerBound() {\n+      return latencyLowerBound;\n+    }\n+\n+    /**\n+     * Returns the latency upper bound of the bucket.\n+     *\n+     * @return the latency upper bound of the bucket.\n+     */\n+    long getLatencyUpperBound() {\n+      return latencyUpperBound;\n+    }\n+  }\n+\n+  static final class SpanBuckets {", "originalCommit": "50fe3f13357bd56373e0ed29bc12ab9366958f99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY0NDc2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448644765", "bodyText": "This leads to a bunch of warnings\nwarning: auxiliary class SpanBuckets in /usr/local/google/home/wilhu/Documents/opentelemetry-java/sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java should not be accessed from outside its own source file\n\nthat cause the build to fail. Should I instead create a separate file for them?", "author": "williamhu99", "createdAt": "2020-07-01T22:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY0NTYwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448645601", "bodyText": "I've never seen an error like this before. How did you do the class move?", "author": "jkwatson", "createdAt": "2020-07-01T22:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY0Njk4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448646985", "bodyText": "I just moved the classes outside. They're on the same level as TracezDataAggregator.", "author": "williamhu99", "createdAt": "2020-07-01T22:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY0NzczMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448647733", "bodyText": "oh, they should definitely be in their own file. Sorry, I missed your question. Java allows having multiple top-level classes in the same file, but it is definitely strongly frowned upon.", "author": "jkwatson", "createdAt": "2020-07-01T22:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1MDQyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448650429", "bodyText": "Which approach should I implement?\n\nLeave the LatencyBoundaries class within TracezDataAggregator and pull the SpanBuckets class out\nPull both classes out and create a new file with the LatencyBoundaries class in SpanBuckets\nPull both classes out and create two new files (one for each class)", "author": "williamhu99", "createdAt": "2020-07-01T22:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1Mjc0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448652746", "bodyText": "I would definitely go with one file per class in this case. It's easier to understand (and test) smaller chunks of code when they aren't all in the same file.", "author": "jkwatson", "createdAt": "2020-07-01T22:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MDc5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448660796", "bodyText": "BTW, if you're using IDEA, you should just be able to use the move refactoring and have the IDE manage all the details for you.", "author": "jkwatson", "createdAt": "2020-07-01T23:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3OTI5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448679290", "bodyText": "Alright, I separated the classes. I didn't write any new unit tests for TracezSpanBuckets because the two classes that call the functions are already fully tested.", "author": "williamhu99", "createdAt": "2020-07-02T00:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg=="}], "type": "inlineReview"}, {"oid": "12c333ad251caf3b180b60a03b29e218d0b0a57c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/12c333ad251caf3b180b60a03b29e218d0b0a57c", "message": "Separated SpanBuckets and LatencyBoundaries from TracezDataAggregator", "committedDate": "2020-07-01T23:55:23Z", "type": "commit"}, {"oid": "1f409ad2b855aa77d5acbb617e444594fbd03825", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1f409ad2b855aa77d5acbb617e444594fbd03825", "message": "Switched to PrintStream, removed bufferWritter, removed factory and changed to package private constructor, added documentation for getTracerzHandler behavior, and other small fixes", "committedDate": "2020-07-02T16:29:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2ODk3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449168976", "bodyText": "no need for a fully qualified name here. please import it.", "author": "jkwatson", "createdAt": "2020-07-02T17:30:26Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());\n+      synchronized (this) {\n+        completedSpanCache.get(span.getName()).addToBucket(span);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // Do nothing.\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Returns a Collection of all running spans for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link io.opentelemetry.sdk.trace.ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getRunningSpans() {\n+    return runningSpanCache.values();\n+  }\n+\n+  /**\n+   * Returns a Collection of all completed spans for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link io.opentelemetry.sdk.trace.ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getCompletedSpans() {\n+    Collection<ReadableSpan> completedSpans = new ArrayList<>();\n+    synchronized (this) {\n+      for (TracezSpanBuckets buckets : completedSpanCache.values()) {\n+        completedSpans.addAll(buckets.getSpans());\n+      }\n+    }\n+    return completedSpans;\n+  }\n+\n+  /**\n+   * Returns the completed span cache for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Map of String to {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanBuckets}.\n+   */\n+  public Map<String, TracezSpanBuckets> getCompletedSpanCache() {\n+    synchronized (this) {\n+      return completedSpanCache;\n+    }\n+  }\n+\n+  /**\n+   * Returns a new Builder for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a new {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder class for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}. */\n+  public static final class Builder extends ConfigBuilder<Builder> {\n+\n+    private static final String KEY_SAMPLED = \"otel.zpages.export.sampled\";\n+    private static final boolean DEFAULT_EXPORT_ONLY_SAMPLED = true;\n+    private boolean sampled = DEFAULT_EXPORT_ONLY_SAMPLED;\n+\n+    private Builder() {}\n+\n+    /**\n+     * Sets the configuration values from the given configuration map for only the available keys.\n+     * This method looks for the following keys:\n+     *\n+     * <ul>\n+     *   <li>{@code otel.zpages.export.sampled}: to set whether only sampled spans should be\n+     *       exported.\n+     * </ul>\n+     *\n+     * @param configMap {@link Map} holding the configuration values.\n+     * @return this.\n+     */\n+    @VisibleForTesting\n+    @Override\n+    protected Builder fromConfigMap(\n+        Map<String, String> configMap, NamingConvention namingConvention) {\n+      configMap = namingConvention.normalize(configMap);\n+      Boolean boolValue = getBooleanProperty(KEY_SAMPLED, configMap);\n+      if (boolValue != null) {\n+        return this.setExportOnlySampled(boolValue);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Sets whether only sampled spans should be exported.\n+     *\n+     * <p>Default value is {@code true}.\n+     *\n+     * @see Builder#DEFAULT_EXPORT_ONLY_SAMPLED\n+     * @param sampled report only sampled spans.\n+     * @return this.\n+     */\n+    public Builder setExportOnlySampled(boolean sampled) {\n+      this.sampled = sampled;\n+      return this;\n+    }\n+\n+    /**\n+     * Returns a new {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+     *\n+     * @return a new {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+     */\n+    public io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor build() {", "originalCommit": "1f409ad2b855aa77d5acbb617e444594fbd03825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyNTU1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451725552", "bodyText": "Done", "author": "williamhu99", "createdAt": "2020-07-08T17:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2ODk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDA5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449170095", "bodyText": "this method isn't used anywhere, I don't think", "author": "jkwatson", "createdAt": "2020-07-02T17:32:35Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          latencyBuckets.get(bucket).add(span);\n+          return;\n+        }\n+      }\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {\n+    Map<LatencyBoundaries, Integer> latencyCounts = new EnumMap<>(LatencyBoundaries.class);\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  public Map<CanonicalCode, Integer> getErrorCanonicalCodeToCountMap() {", "originalCommit": "1f409ad2b855aa77d5acbb617e444594fbd03825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQwNjI3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r450406270", "bodyText": "Yeah, it isn't. I'll remove it.", "author": "williamhu99", "createdAt": "2020-07-06T18:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDA5NQ=="}], "type": "inlineReview"}, {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/db2b2fa2bec72903224aa5ac5a18e553b52b643b", "message": "Fixed package name", "committedDate": "2020-07-02T17:33:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDg3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449170879", "bodyText": "There's a bunch of fully-qualified names in docs throughout this PR. Let's make sure to use the imports and remove the FQNs when we can.", "author": "jkwatson", "createdAt": "2020-07-02T17:34:08Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.", "originalCommit": "1f409ad2b855aa77d5acbb617e444594fbd03825", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3Mjc5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r450472797", "bodyText": "Removed the FQNs from the span processor and data aggregator", "author": "williamhu99", "createdAt": "2020-07-06T20:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MDg5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449180895", "bodyText": "there is no need for an Atomic instance to also be volatile. And, it should be declared final.", "author": "jkwatson", "createdAt": "2020-07-02T17:54:01Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      new TracezZPageHandler(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile AtomicBoolean isTracezSpanProcesserAdded = new AtomicBoolean(false);", "originalCommit": "db2b2fa2bec72903224aa5ac5a18e553b52b643b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjY1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449186654", "bodyText": "If you're guarding this with the check to the AtomicBoolean, is there much to be gained by additional synchronizing here? Also, if we really do need a lock, we should implement it with one of the higher-level concurrency primitives build-in to the JDK, like a ReentrantLock", "author": "jkwatson", "createdAt": "2020-07-02T18:05:04Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      new TracezZPageHandler(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile AtomicBoolean isTracezSpanProcesserAdded = new AtomicBoolean(false);\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (isTracezSpanProcesserAdded.compareAndSet(false, true)) {\n+      synchronized (mutex) {", "originalCommit": "db2b2fa2bec72903224aa5ac5a18e553b52b643b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5ODU5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449198593", "bodyText": "I think no lock is required here after the change", "author": "wtyanan", "createdAt": "2020-07-02T18:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Njk5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449186999", "bodyText": "I think this method can be private, yes?", "author": "jkwatson", "createdAt": "2020-07-02T18:05:40Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      new TracezZPageHandler(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile AtomicBoolean isTracezSpanProcesserAdded = new AtomicBoolean(false);\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (isTracezSpanProcesserAdded.compareAndSet(false, true)) {\n+      synchronized (mutex) {\n+        TracerSdkProvider tracerProvider = OpenTelemetrySdk.getTracerProvider();\n+        tracerProvider.addSpanProcessor(tracezSpanProcessor);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns a {@code ZPageHandler} for tracing debug. The page displays information about all\n+   * running spans and all sampled spans based on latency and error.\n+   *\n+   * <p>It displays a summary table which contains one row for each span name and data about number\n+   * of running and sampled spans.\n+   *\n+   * <p>Clicking on a cell in the table with a number that is greater than zero will display\n+   * detailed information about that span.\n+   *\n+   * <p>This method will add the TracezSpanProcessor to the tracerProvider, it should only be called\n+   * once.\n+   *\n+   * @return a {@code ZPageHandler} for tracing debug.\n+   */\n+  public static ZPageHandler getTracezZPageHandler() {\n+    addTracezSpanProcessor();\n+    return tracezZPageHandler;\n+  }\n+\n+  /**\n+   * Registers all zPages to the given {@link HttpServer} {@code server}.\n+   *\n+   * @param server the server that exports the zPages.\n+   */\n+  public static void registerAllPagesToHttpServer(HttpServer server) {", "originalCommit": "db2b2fa2bec72903224aa5ac5a18e553b52b643b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5OTE1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449199154", "bodyText": "I think it should be public. User should be able to call this function to register the zpages to their own server", "author": "wtyanan", "createdAt": "2020-07-02T18:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Njk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMjg5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449202898", "bodyText": "Hm. There are 3 public methods on this class. Do we need all 3? I see 2 of them documented in the javadoc, so maybe the 3rd (getTracezZpageHandler()) can be private?", "author": "jkwatson", "createdAt": "2020-07-02T18:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Njk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwNDEwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449204107", "bodyText": "I've updated getTracezZPageHandler to registerTracezZPageHandler and it can be private, I made it public initially because I wanted to test the \"add span processor only once\" behavior, should I make it private and get rid of the test?", "author": "wtyanan", "createdAt": "2020-07-02T18:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Njk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwNTM5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449205391", "bodyText": "If you want to test that behavior, then make it package-access, and mark it as @VisibleForTesting. Thanks!", "author": "jkwatson", "createdAt": "2020-07-02T18:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Njk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Nzg5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449187898", "bodyText": "is it really worth throwing an exception if two threads try to stop the server? Seems like it should just be a no-op.", "author": "jkwatson", "createdAt": "2020-07-02T18:07:27Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      new TracezZPageHandler(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile AtomicBoolean isTracezSpanProcesserAdded = new AtomicBoolean(false);\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (isTracezSpanProcesserAdded.compareAndSet(false, true)) {\n+      synchronized (mutex) {\n+        TracerSdkProvider tracerProvider = OpenTelemetrySdk.getTracerProvider();\n+        tracerProvider.addSpanProcessor(tracezSpanProcessor);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns a {@code ZPageHandler} for tracing debug. The page displays information about all\n+   * running spans and all sampled spans based on latency and error.\n+   *\n+   * <p>It displays a summary table which contains one row for each span name and data about number\n+   * of running and sampled spans.\n+   *\n+   * <p>Clicking on a cell in the table with a number that is greater than zero will display\n+   * detailed information about that span.\n+   *\n+   * <p>This method will add the TracezSpanProcessor to the tracerProvider, it should only be called\n+   * once.\n+   *\n+   * @return a {@code ZPageHandler} for tracing debug.\n+   */\n+  public static ZPageHandler getTracezZPageHandler() {\n+    addTracezSpanProcessor();\n+    return tracezZPageHandler;\n+  }\n+\n+  /**\n+   * Registers all zPages to the given {@link HttpServer} {@code server}.\n+   *\n+   * @param server the server that exports the zPages.\n+   */\n+  public static void registerAllPagesToHttpServer(HttpServer server) {\n+    // For future zPages, register them to the server in here\n+    server.createContext(\n+        tracezZPageHandler.getUrlPath(), new ZPageHttpHandler(getTracezZPageHandler()));\n+  }\n+\n+  /** Method for stopping the {@link HttpServer} {@code server}. */\n+  private static void stop() {\n+    synchronized (mutex) {\n+      checkState(server != null, \"The HttpServer is already stopped.\");", "originalCommit": "db2b2fa2bec72903224aa5ac5a18e553b52b643b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMDE4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449200185", "bodyText": "Changed to no-op", "author": "wtyanan", "createdAt": "2020-07-02T18:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Nzg5OA=="}], "type": "inlineReview"}, {"oid": "69224884e0e7ecd9f2aa1909b802ee8824380053", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/69224884e0e7ecd9f2aa1909b802ee8824380053", "message": "Changed way of registering handlers, changed atomicBoolean to final, removed unnecessary lock", "committedDate": "2020-07-02T18:36:55Z", "type": "commit"}, {"oid": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/63bc912c7a1a04b9cb51c4d87ca61a73468d911a", "message": "Changed registerTracezZPageHandler to package private", "committedDate": "2020-07-02T19:10:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449312083", "bodyText": "I think it may have gotten hidden by GitHub so linking again to my comment on incrementality, sorry if it's a double-notification\n#1380 (comment)\nI'm wondering whether we can incrementally update data structures that keep the information we want to return instead of storing ReadableSpan itself.\nFor example, in the processor, something like\n// NB: Too bad we can't use LongAdder without vendoring it...\nprivate final ConcurrentHashMap<String, Map<LatencyBoundaries, AtomicInteger>> spanNameLatencyBoundaryCounts = new ConcurrentHashMap<>\n\nonEnd() {\n  latencyCounts = spanNameLatencyBoundaryCounts.computeIfAbsent(span.getName(),\n // Prepopulated with AtomicInteger for each boundary \n LatencyBoundaries.createEnumMap())\n  LatencyBoundaries boundary = LatencyBoundaries.get(span.getLatencyNanos());\n  latencyCounts.get(boundary).incrementAndGet();\n}\n\nThis doesn't seem too complex, and will have all the information. Currently, with NUM_SAMPLES_PER_LATENCY_BUCKET the count is max 10 for any bucket if I'm not mistaken, is that what we want to report on the zpage? @jkwatson does this approach seem reasonable? I may be missing something that blocks it - I was actually initially most worried about getSpanLatencyCounts(long lowerBound, long upperBound) but I don't see it used in the PR anymore.\nAlso an aside, it's curious opentelemetry isn't using the opentelemetry API itself for gathering these metrics :)", "author": "anuraaga", "createdAt": "2020-07-02T23:45:16Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          latencyBuckets.get(bucket).add(span);\n+          return;\n+        }\n+      }\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {", "originalCommit": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3NDI4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r450474287", "bodyText": "If we go with this, should I remove getSpanLatencyCounts(long lowerBound, long upperBound)? I initially created this function as I wasn't sure how much filtering the package needed.", "author": "williamhu99", "createdAt": "2020-07-06T20:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyMTM5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r450521395", "bodyText": "So while implementing this, I've run into the issue of separating OK spans from error spans. The TracezSpanBuckets class was implemented to make this simpler, so if we want to incrementally maintain the count maps, then it makes more sense to have the TracezSpanBuckets class keep track of the counts, as it's already tracking the spans. I still am not sure whether this is entirely necessary, given that creating the count map from the spans is not difficult (see getLatencyBoundariesToCountMap() in TracezSpanBuckets). I'd appreciate other opinions on this!", "author": "williamhu99", "createdAt": "2020-07-06T22:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwOTEyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r450609125", "bodyText": "Since getSpanLatencyCounts(long lowerBound, long upperBound) seems unused seems fine to remove it.\n\nTracezSpanBuckets class keep track of the counts, as it's already tracking the spans\n\nThe idea is for TracezSpanBuckets to not track spans - if we do that, we get complete metrics (instead of being bounded to 10 or whatever constant we end up with) and it means spans can get cleaned up as quickly as possible, we'd only be keeping track of counts here not whole spans which have lots of data associated with them and even with the capped map is waste of resources IMO.\nThough before doing that, I'd suggest also investigating the OpenTelemetry metrics API to see if it has anything we can use. It might not, but I'm suspecting we haven't taken a good look yet. For example, the buckets we're implementing seem suspiciously similar to a histogram aggregation\nhttps://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java#L66\nI think it should be possible to record latencies as doubles with the span name as a label and use aggregations to power our views. If OTel can't dogfood it's own metrics API we're in some trouble \ud83d\ude05", "author": "anuraaga", "createdAt": "2020-07-07T04:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1NDAyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451054023", "bodyText": "Histogram aggregation doesn't seem to be implemented for OpenTelemetry yet (the class is calling no-op functions). If I'm understanding your suggestion correctly, you want to replace the buckets class with data structures in the span processor class that individually track the metrics. This would reduce the size of the data stored, as spans are large objects, and allow for more than just the most recent 10/5 spans.\nThe problem I have with this is that the /tracez zPage needs pretty much all of the span information. The zPage supports a details section that displays the ID's, events, etc. of the spans within a cell of the table. I don't think it makes much sense to track all of these individually instead of the span itself, as I can't imagine much memory would be saved. But perhaps I'm missing something here. Could I schedule a call to go over your thoughts?", "author": "williamhu99", "createdAt": "2020-07-07T18:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNDEzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451204134", "bodyText": "Thanks for the context, didn't realize there's a details page too (seems to be missing from the design doc). In that case we can stick with the current approach. It's a bit weird since the numbers seem like they'll all converge to 10 naturally, but guess the numbers aren't actually the main feature here.", "author": "anuraaga", "createdAt": "2020-07-07T23:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNTI1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451305253", "bodyText": "Yeah, sorry about that. I've been meaning to update my design doc. Will definitely do so before adding it to the README.", "author": "williamhu99", "createdAt": "2020-07-08T06:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNTExMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449315110", "bodyText": "Can you add private static final constants for the splitters?", "author": "anuraaga", "createdAt": "2020-07-02T23:58:26Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** An {@link HttpHanlder} that will be used to render HTML pages using any {@code ZPageHandler}. */\n+final class ZPageHttpHandler implements HttpHandler {\n+  // The corresponding ZPageHandler for the zPage (e.g. TracezZPageHandler)\n+  private final ZPageHandler zpageHandler;\n+\n+  /** Constructs a new {@code ZPageHttpHandler}. */\n+  ZPageHttpHandler(ZPageHandler zpageHandler) {\n+    this.zpageHandler = zpageHandler;\n+  }\n+\n+  /**\n+   * Build a query map from the {@code uri}.\n+   *\n+   * @param uri the {@link URI} for buiding the query map\n+   * @return the query map built based on the @{code uri}\n+   */\n+  @VisibleForTesting\n+  static ImmutableMap<String, String> parseQueryMap(URI uri) {\n+    String queryStrings = uri.getQuery();\n+    if (queryStrings == null) {\n+      return ImmutableMap.of();\n+    }\n+    Map<String, String> queryMap = new HashMap<String, String>();\n+    for (String param : Splitter.on(\"&\").split(queryStrings)) {", "originalCommit": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDU3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449624578", "bodyText": "Do you mean the parameter names?", "author": "wtyanan", "createdAt": "2020-07-03T15:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzMTM5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449631394", "bodyText": "I mean extracting constants for Splitter e.g.\nprivate static final Splitter QUERY_SPLITTER = Splitter.on('&').trimValues()\nSplitter is an immutable class, instantiating the same object over and over is wasteful. We may not care for a very cold path, for example something that happens once during server startup but parsing query is fairly common.", "author": "anuraaga", "createdAt": "2020-07-03T15:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNTE3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449315174", "bodyText": "Instead of manual trim, use Splitter.trimResults", "author": "anuraaga", "createdAt": "2020-07-02T23:58:49Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** An {@link HttpHanlder} that will be used to render HTML pages using any {@code ZPageHandler}. */\n+final class ZPageHttpHandler implements HttpHandler {\n+  // The corresponding ZPageHandler for the zPage (e.g. TracezZPageHandler)\n+  private final ZPageHandler zpageHandler;\n+\n+  /** Constructs a new {@code ZPageHttpHandler}. */\n+  ZPageHttpHandler(ZPageHandler zpageHandler) {\n+    this.zpageHandler = zpageHandler;\n+  }\n+\n+  /**\n+   * Build a query map from the {@code uri}.\n+   *\n+   * @param uri the {@link URI} for buiding the query map\n+   * @return the query map built based on the @{code uri}\n+   */\n+  @VisibleForTesting\n+  static ImmutableMap<String, String> parseQueryMap(URI uri) {\n+    String queryStrings = uri.getQuery();\n+    if (queryStrings == null) {\n+      return ImmutableMap.of();\n+    }\n+    Map<String, String> queryMap = new HashMap<String, String>();\n+    for (String param : Splitter.on(\"&\").split(queryStrings)) {\n+      List<String> keyValuePair = Splitter.on(\"=\").splitToList(param);\n+      if (keyValuePair.size() > 1) {\n+        queryMap.put(keyValuePair.get(0).trim(), keyValuePair.get(1).trim());", "originalCommit": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8ed29a76c2231f626d1c25c710176b388552925a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8ed29a76c2231f626d1c25c710176b388552925a", "message": "Fixed javadoc styling and wording", "committedDate": "2020-07-03T14:57:08Z", "type": "commit"}, {"oid": "be0d55da38a949b219e61ac840b47e0e2b33bf75", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/be0d55da38a949b219e61ac840b47e0e2b33bf75", "message": "Added constants for splitters, changed httpserver to compileOnly dependency", "committedDate": "2020-07-06T14:36:38Z", "type": "commit"}, {"oid": "be0d55da38a949b219e61ac840b47e0e2b33bf75", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/be0d55da38a949b219e61ac840b47e0e2b33bf75", "message": "Added constants for splitters, changed httpserver to compileOnly dependency", "committedDate": "2020-07-06T14:36:38Z", "type": "forcePushed"}, {"oid": "ff9247b059b0177ab2d5c20ac9b5396c5b651941", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ff9247b059b0177ab2d5c20ac9b5396c5b651941", "message": "Removed FQNs from backend files", "committedDate": "2020-07-06T18:47:36Z", "type": "commit"}, {"oid": "bd282171464124becadbf182e113537e9714fd0a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/bd282171464124becadbf182e113537e9714fd0a", "message": "Removed style errors", "committedDate": "2020-07-06T19:13:33Z", "type": "commit"}, {"oid": "fb41a8b36765212860795818dc51f6d0ce926d6b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/fb41a8b36765212860795818dc51f6d0ce926d6b", "message": "Updated TracezSpanProcessor to maintain a set of span names incrementally", "committedDate": "2020-07-06T21:58:26Z", "type": "commit"}, {"oid": "8b46dd90f80985b0f500647c879f494eec0ea6b6", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8b46dd90f80985b0f500647c879f494eec0ea6b6", "message": "Added visibleForTesting tag, adjusted HTML expression", "committedDate": "2020-07-07T17:25:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwODc2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451108768", "bodyText": "This method isn't being used. Can we remove it?", "author": "jkwatson", "createdAt": "2020-07-07T19:58:07Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    spanNames.addAll(spanProcessor.getCompletedSpanCache().keySet());\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of counts for the {@link Status#OK} spans within [lowerBound, upperBound) {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a Map of span counts for each span name within the bounds.\n+   */\n+  public Map<String, Integer> getSpanLatencyCounts(long lowerBound, long upperBound) {", "originalCommit": "bd282171464124becadbf182e113537e9714fd0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2MzQ3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451163473", "bodyText": "Removed it", "author": "williamhu99", "createdAt": "2020-07-07T21:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwODc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDI2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451110263", "bodyText": "I don't think we need all this synchronization if we're using a ConcurrentMap, do we?", "author": "jkwatson", "createdAt": "2020-07-07T20:01:04Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());\n+      synchronized (this) {\n+        completedSpanCache.get(span.getName()).addToBucket(span);", "originalCommit": "8b46dd90f80985b0f500647c879f494eec0ea6b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEzMjIyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451132226", "bodyText": "The addToBucket function adds to an EvictingQueue, which doesn't seem to be thread-safe.", "author": "williamhu99", "createdAt": "2020-07-07T20:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDEzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451140138", "bodyText": "Shouldn't you make the TracezSpanBuckets handle it's own thread-safety, then?\nAlso, it is generally a bad practice to synchronize on this as it introduces the possibility that some other class will synchronize on the same instance, and possibly introduce a deadlock. Any manual synchronziation blocks must use a private final instance variable to lock on.", "author": "jkwatson", "createdAt": "2020-07-07T21:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTY4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451195685", "bodyText": "Changed the synchronization targets and made TracezSpanBuckets thread-safe!", "author": "williamhu99", "createdAt": "2020-07-07T23:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDI2Mw=="}], "type": "inlineReview"}, {"oid": "99497ac199471542c047e3a66613defed7c1a691", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/99497ac199471542c047e3a66613defed7c1a691", "message": "Merge branch 'master' of github.com:williamhu99/opentelemetry-java into master", "committedDate": "2020-07-07T21:43:50Z", "type": "commit"}, {"oid": "9ee432fa707c5a9741d69cdb4b5769c25983462a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/9ee432fa707c5a9741d69cdb4b5769c25983462a", "message": "Removed unused functions in the data aggregator", "committedDate": "2020-07-07T21:48:23Z", "type": "commit"}, {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "message": "Made TracezSpanBuckets thread-safe", "committedDate": "2020-07-07T23:16:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNDQ4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451204488", "bodyText": "How about using resources instead of base64 encoding into source? Makes it much easier to update the logo when needed / view it in IDE, etc.", "author": "anuraaga", "createdAt": "2020-07-07T23:46:38Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /** OpenTelemetry logo in base64 encoding. */\n+  static String logoBase64 =", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg5MDcxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451890711", "bodyText": "Sorry I missed this comment, should I import the image from an actual .png file, then encode it to base64?", "author": "wtyanan", "createdAt": "2020-07-09T00:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNDQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg5MTY1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451891655", "bodyText": "Yeah I think it makes maintaining the image file itself easier since it's double clickable after cloning", "author": "anuraaga", "createdAt": "2020-07-09T00:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNDQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNzM4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451207388", "bodyText": "Remove public for this non-public class", "author": "anuraaga", "createdAt": "2020-07-07T23:56:09Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNzUzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451207532", "bodyText": "Use entrySet instead of keySet", "author": "anuraaga", "createdAt": "2020-07-07T23:56:46Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    return spanProcessor.getSpanNames();\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  public Map<String, Map<LatencyBoundaries, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundaries, Integer>> numSpansPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODE4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451208188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Collection<ReadableSpan> allCompletedSpans =\n          \n          \n            \n                    completedSpanCache.containsKey(spanName)\n          \n          \n            \n                        ? completedSpanCache.get(spanName).getOkSpans()\n          \n          \n            \n                        : Collections.<ReadableSpan>emptyList();\n          \n          \n            \n                TracezSpanBuckes buckets = completedSpanCache.get(spanName);\n          \n          \n            \n                if (buckets == null) {\n          \n          \n            \n                  return Collections.emptyList();\n          \n          \n            \n                }\n          \n          \n            \n                Collection<ReadableSpan> = buckets.getOkSpans();\n          \n      \n    \n    \n  \n\nAvoid both containsKey and get, e.g., looking up the map twice.", "author": "anuraaga", "createdAt": "2020-07-07T23:59:07Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    return spanProcessor.getSpanNames();\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  public Map<String, Map<LatencyBoundaries, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundaries, Integer>> numSpansPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {\n+      numSpansPerName.put(name, completedSpanCache.get(name).getLatencyBoundariesToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Collection<ReadableSpan> allCompletedSpans =\n+        completedSpanCache.containsKey(spanName)\n+            ? completedSpanCache.get(spanName).getOkSpans()\n+            : Collections.<ReadableSpan>emptyList();", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODQwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451208401", "bodyText": "Ditto", "author": "anuraaga", "createdAt": "2020-07-07T23:59:50Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    return spanProcessor.getSpanNames();\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  public Map<String, Map<LatencyBoundaries, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundaries, Integer>> numSpansPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {\n+      numSpansPerName.put(name, completedSpanCache.get(name).getLatencyBoundariesToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Collection<ReadableSpan> allCompletedSpans =\n+        completedSpanCache.containsKey(spanName)\n+            ? completedSpanCache.get(spanName).getOkSpans()\n+            : Collections.<ReadableSpan>emptyList();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allCompletedSpans) {\n+      if (span.getLatencyNanos() >= lowerBound && span.getLatencyNanos() < upperBound) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of error span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of error span counts for each span name.\n+   */\n+  public Map<String, Integer> getErrorSpanCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Integer> numErrorsPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODUyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451208520", "bodyText": "Ditto", "author": "anuraaga", "createdAt": "2020-07-08T00:00:15Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    return spanProcessor.getSpanNames();\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  public Map<String, Map<LatencyBoundaries, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundaries, Integer>> numSpansPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {\n+      numSpansPerName.put(name, completedSpanCache.get(name).getLatencyBoundariesToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Collection<ReadableSpan> allCompletedSpans =\n+        completedSpanCache.containsKey(spanName)\n+            ? completedSpanCache.get(spanName).getOkSpans()\n+            : Collections.<ReadableSpan>emptyList();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allCompletedSpans) {\n+      if (span.getLatencyNanos() >= lowerBound && span.getLatencyNanos() < upperBound) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of error span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of error span counts for each span name.\n+   */\n+  public Map<String, Integer> getErrorSpanCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Integer> numErrorsPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {\n+      numErrorsPerName.put(name, completedSpanCache.get(name).getErrorSpans().size());\n+    }\n+    return numErrorsPerName;\n+  }\n+\n+  /**\n+   * Returns a List of error spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getErrorSpans(String spanName) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Collection<ReadableSpan> allCompletedSpans =", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODYzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451208632", "bodyText": "Ditto", "author": "anuraaga", "createdAt": "2020-07-08T00:00:35Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzE5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217193", "bodyText": "Use ImmutableMap instead of HashMap to make clear the buckets can be accessed without threadsafety (not the queue), the maps themselves are fully initialized in the constructor.", "author": "anuraaga", "createdAt": "2020-07-08T00:33:51Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzM3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217378", "bodyText": "Synchronize on the queue, not the map (above suggestion about ImmutableMap is to make clear that this is safe)", "author": "anuraaga", "createdAt": "2020-07-08T00:34:40Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNzkyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451227927", "bodyText": "Though I am worried about the performance impact of this synchronization, if it's just one latency bucket it's better, but I think it's pretty common for a server to only have a single method and serve huge QPS with similar latency (think an authentication server). The contention here seems like it could get pretty huge, possibly breaking the tenet that observability must not be intrusive.\nIt seems like a pretty small amount of code to implement a non-blocking ring buffer, if not in this PR can you make sure to try it in another that also adds a JMH? I don't think there's a need to have the bucket size match opencensus if there's a reason we find for a different.\nfinal class SpanBucket {\n  // power of 2 means Integer.MAX_VALUE % BUCKET_SIZE = BUCKET_SIZE - 1 the maximum remainder, and\n  // we will loop back to 0.\n  private static final int BUCKET_SIZE = 16; \n  private final Span[] spans = new Span[BUCKET_SIZE];\n  private final AtomicInteger index = new AtomicInteger();\n\n  void add(Span span) {\n    spans[UnsignedInts.remainder(index.getAndIncrement(), BUCKET_SIZE)] = span;\n  }\n\n  int size() {\n    for (int i = BUCKET_SIZE - 1; i >= 0; i--) {\n      if (spans[i] != null) {\n        return i + 1;\n      }\n    }\n    return 0;\n  }\n  \n  void addTo(List<Span> result) {\n    for (int i = 0; i < BUCKET_SIZE; i++) {\n      Span span = spans[i];\n      if (span != null) {\n        result.add(span);\n      } else {\n        break;\n      }\n    }\n  }", "author": "anuraaga", "createdAt": "2020-07-08T01:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1ODc0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451858746", "bodyText": "Added a SpanBucket class to replace the EvictingQueue!", "author": "williamhu99", "createdAt": "2020-07-08T22:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzU4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217587", "bodyText": "Name this LatencyBoundary, an enum name should be what each item is, not what the group is.", "author": "anuraaga", "createdAt": "2020-07-08T00:35:31Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/LatencyBoundaries.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A class of boundaries for the latency buckets. The completed spans with a status of {@link\n+ * io.opentelemetry.trace.Status#OK} are categorized into one of these buckets om the traceZ zPage.\n+ */\n+enum LatencyBoundaries {", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzc3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217773", "bodyText": "Ditto", "author": "anuraaga", "createdAt": "2020-07-08T00:36:08Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);\n+          }\n+          return;\n+        }\n+      }\n+    }\n+    synchronized (errorBuckets) {\n+      errorBuckets.get(status.getCanonicalCode()).add(span);", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzg0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217843", "bodyText": "I think it's worth having LatencyBoundary.get(long latencyNanos) to return the boundary to make this code a bit more simple.", "author": "anuraaga", "createdAt": "2020-07-08T00:36:29Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxOTU3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451219578", "bodyText": "Recommend returning List, there doesn't seem to be a reason to use a more limited type especially for an internal class", "author": "anuraaga", "createdAt": "2020-07-08T00:43:23Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);\n+          }\n+          return;\n+        }\n+      }\n+    }\n+    synchronized (errorBuckets) {\n+      errorBuckets.get(status.getCanonicalCode()).add(span);\n+    }\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {\n+    Map<LatencyBoundaries, Integer> latencyCounts = new EnumMap<>(LatencyBoundaries.class);\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  public Collection<ReadableSpan> getOkSpans() {", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMDEyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451220128", "bodyText": "I believe this has a chance of throwing ConcurrentModificationException, you should just do\nsynchronized(latencyBucket) {\n  okSpans.addAll(latencyBucket);\n}\n\nwhich will work after following the other comments.", "author": "anuraaga", "createdAt": "2020-07-08T00:45:36Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);\n+          }\n+          return;\n+        }\n+      }\n+    }\n+    synchronized (errorBuckets) {\n+      errorBuckets.get(status.getCanonicalCode()).add(span);\n+    }\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {\n+    Map<LatencyBoundaries, Integer> latencyCounts = new EnumMap<>(LatencyBoundaries.class);\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  public Collection<ReadableSpan> getOkSpans() {\n+    Collection<ReadableSpan> okSpans = new ArrayList<>();\n+    for (EvictingQueue<ReadableSpan> latencyBucket : latencyBuckets.values()) {\n+      okSpans.addAll(new ArrayList<>(latencyBucket));", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMTQ2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451221468", "bodyText": "Should be able to remove this synchronization, it's a concurrent map and each bucket handles its own thread safety", "author": "anuraaga", "createdAt": "2020-07-08T00:50:48Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+    synchronized (spanNames) {\n+      spanNames.add(span.getName());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());\n+      completedSpanCache.get(span.getName()).addToBucket(span);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // Do nothing.\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Returns a Collection of all running spans for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getRunningSpans() {\n+    return runningSpanCache.values();\n+  }\n+\n+  /**\n+   * Returns a Collection of all completed spans for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getCompletedSpans() {\n+    Collection<ReadableSpan> completedSpans = new ArrayList<>();\n+    synchronized (this) {", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyOTY3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451229674", "bodyText": "Sorry for back and forth, now realizing we do need to keep track of the spans I think it'd be ok to not keep track of span names incrementally, like your previous approach. Better not to worry about synchronization here if possible.", "author": "anuraaga", "createdAt": "2020-07-08T01:23:29Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+    synchronized (spanNames) {\n+      spanNames.add(span.getName());", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDQwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451230402", "bodyText": ".putIfAbsent is only Java 8 (hmm strange that animal sniffer isn't catching this). Anyways, we don't need to care it'll only be called once, just use .put", "author": "anuraaga", "createdAt": "2020-07-08T01:26:16Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1ODMwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451758305", "bodyText": "Based on the documentation, ConcurrentMap in Java 7 supports putIfAbsent.", "author": "williamhu99", "createdAt": "2020-07-08T18:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg2ODM2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451868364", "bodyText": "Thanks I never noticed it has a different API on Java 7! Here let's still stick with put since we don't need the behavior (any span will only pass through here once)", "author": "anuraaga", "createdAt": "2020-07-08T22:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTIyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451231225", "bodyText": "Ditto, we'll want to do a double-checked lock\nTracezSpanBuckets buckets = completedSpanCache.get(span.getName());\nif (buckets == null) {\n  synchronized (completedSpanCache) {\n    buckets = completedSpanCache.get(span.getName());\n    if (buckets == null) {\n      buckets = new TracezSpanBuckets();\n      completedSpanCache.put(span.getName(), buckets);\n    }\n  }\n}\nbuckets.addToBucket(span);", "author": "anuraaga", "createdAt": "2020-07-08T01:29:34Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+    synchronized (spanNames) {\n+      spanNames.add(span.getName());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTgyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451761824", "bodyText": "Is this still the preferable implementation when completedSpanCache is a ConcurrentMap?", "author": "williamhu99", "createdAt": "2020-07-08T19:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc3NDc3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451774771", "bodyText": "Honestly, I'm not sure it matters all that much. The worst case scenario would be that we miss a couple of spans at startup time. I'd prefer to keep the code simpler, since this is a non-critical code path (temporary losses are totally fine, since we're only keeping a few spans anyway).", "author": "jkwatson", "createdAt": "2020-07-08T19:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg2ODUzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451868532", "bodyText": "Yup sorry didn't realize the ConcurrentMap method, this LGTM", "author": "anuraaga", "createdAt": "2020-07-08T22:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMjkyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451232927", "bodyText": "Since performance of this page isn't a big deal, it's not too bad but reconsider using Formatter, it's orders of magnitude slower than concatenation and while useful for formatting floating points, otherwise is not doing much more than concatenation. It's generally good practice to just never use String.format / Formatter and not worry about the performance tradeoff.", "author": "anuraaga", "createdAt": "2020-07-08T01:36:11Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,594 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param formatter a {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out, Formatter formatter) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1MjgzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451552836", "bodyText": "So doing out.print() and concatenate the variables is a better choice if no formatting is required then?", "author": "wtyanan", "createdAt": "2020-07-08T13:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyMDc1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451620758", "bodyText": "Yeah I would say it's a better default - otherwise you have to make a judgment call on performance vs readability, but I think the readability gain from printf is usually very low (interpolated strings would be a different story, eventually they'll be in Java and hopefully fast to make up for decades ;) )", "author": "anuraaga", "createdAt": "2020-07-08T15:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNjIxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451626215", "bodyText": "Got it, I will remove unnecessary Formatter and change them to concatenate", "author": "wtyanan", "createdAt": "2020-07-08T15:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMjkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNDg1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451234853", "bodyText": "Prefer @MockitoRule", "author": "anuraaga", "createdAt": "2020-07-08T01:43:42Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(JUnit4.class)\n+public final class TracezZPageHandlerTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";\n+  private static final String FINISHED_SPAN_TWO = \"FinishedSpanTwo\";\n+  private static final String RUNNING_SPAN = \"RunningSpan\";\n+  private static final String LATENCY_SPAN = \"LatencySpan\";\n+  private static final String ERROR_SPAN = \"ErrorSpan\";\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYzMTk0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451631941", "bodyText": "I think, even better, is just to use the mockito runner, and put the @mock annotation on the fields you want to be mocked.", "author": "jkwatson", "createdAt": "2020-07-08T15:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNDg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNDkzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451234935", "bodyText": "statics before non-statics", "author": "anuraaga", "createdAt": "2020-07-08T01:44:04Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(JUnit4.class)\n+public final class TracezZPageHandlerTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNTE2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451235165", "bodyText": "Think there's a assertThat(counts).isEmpty()", "author": "anuraaga", "createdAt": "2020-07-08T01:45:01Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames().size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getSpanNames should still return a set with 2 span names */\n+    names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_noSpans() {\n+    /* getRunningSpanCounts should return a an empty map */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpanCounts should return a map with 1 span name */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(3);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpanCounts should return a map with 2 different span names */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(2);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span1.end();\n+    /* getRunningSpanCounts should return a map with 1 unique span name */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span2.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_noSpans() {\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getRunningSpans_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpans should return a List with all 3 spans */\n+    List<SpanData> spans = dataAggregator.getRunningSpans(SPAN_NAME_ONE);\n+    assertThat(spans.size()).isEqualTo(3);\n+    assertThat(spans).contains(((ReadableSpan) span1).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span2).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span3).toSpanData());\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getRunningSpans_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpans should return a List with only the corresponding span */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE))\n+        .containsExactly(((ReadableSpan) span1).toSpanData());\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO))\n+        .containsExactly(((ReadableSpan) span2).toSpanData());\n+    span1.end();\n+    span2.end();\n+    /* getRunningSpans should return an empty List for each span name */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Map<String, Map<LatencyBoundaries, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noCompletedSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Span span = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Map<String, Map<LatencyBoundaries, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    span.end();\n+    assertThat(counts.size()).isEqualTo(0);", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNTI2Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451235267", "bodyText": "Remove assertions on empty map they're redundant.", "author": "anuraaga", "createdAt": "2020-07-08T01:45:15Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames().size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getSpanNames should still return a set with 2 span names */\n+    names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_noSpans() {\n+    /* getRunningSpanCounts should return a an empty map */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpanCounts should return a map with 1 span name */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(3);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpanCounts should return a map with 2 different span names */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(2);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span1.end();\n+    /* getRunningSpanCounts should return a map with 1 unique span name */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span2.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_noSpans() {\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getRunningSpans_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpans should return a List with all 3 spans */\n+    List<SpanData> spans = dataAggregator.getRunningSpans(SPAN_NAME_ONE);\n+    assertThat(spans.size()).isEqualTo(3);\n+    assertThat(spans).contains(((ReadableSpan) span1).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span2).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span3).toSpanData());\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getRunningSpans_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpans should return a List with only the corresponding span */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE))\n+        .containsExactly(((ReadableSpan) span1).toSpanData());\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO))\n+        .containsExactly(((ReadableSpan) span2).toSpanData());\n+    span1.end();\n+    span2.end();\n+    /* getRunningSpans should return an empty List for each span name */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Map<String, Map<LatencyBoundaries, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noCompletedSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Span span = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Map<String, Map<LatencyBoundaries, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    span.end();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();", "originalCommit": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c5e819e5002423825612086b48fb3009758f0a18", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c5e819e5002423825612086b48fb3009758f0a18", "message": "Changed test to use Mockitorule, removed unnecessary Formatter, unrolled attribute value", "committedDate": "2020-07-08T15:20:14Z", "type": "commit"}, {"oid": "19b16d77cdfac95ea86ba01a892c43bf9f2f8a6c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/19b16d77cdfac95ea86ba01a892c43bf9f2f8a6c", "message": "Changed test with @Mock to use Mockito test runner", "committedDate": "2020-07-08T20:13:50Z", "type": "commit"}, {"oid": "2647c45615c8e5690f5ca6ac63d2e298e44e34b7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2647c45615c8e5690f5ca6ac63d2e298e44e34b7", "message": "Renamed LatencyBoundaries to LatencyBoundary and cleaned up code", "committedDate": "2020-07-08T21:15:53Z", "type": "commit"}, {"oid": "eea8895802c79bed039af92344761d4154dfb3e8", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/eea8895802c79bed039af92344761d4154dfb3e8", "message": "Merge branch 'master' of github.com:williamhu99/opentelemetry-java into master", "committedDate": "2020-07-08T21:16:04Z", "type": "commit"}, {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/88a703b4591e804e3804e5e8e8459d24244a2d27", "message": "Replaced the EvictingQueue with a faster SpanBucket class and modified checks in TracezDataAggregatorTest", "committedDate": "2020-07-08T22:38:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg2OTk5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451869993", "bodyText": "Since package private, remove public", "author": "anuraaga", "createdAt": "2020-07-08T22:57:54Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/LatencyBoundary.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A class of boundaries for the latency buckets. The completed spans with a status of {@link\n+ * io.opentelemetry.trace.Status#OK} are categorized into one of these buckets om the traceZ zPage.\n+ */\n+enum LatencyBoundary {\n+  /** Stores finished successful requests of duration within the interval [0, 10us). */\n+  ZERO_MICROSx10(0, TimeUnit.MICROSECONDS.toNanos(10)),\n+\n+  /** Stores finished successful requests of duration within the interval [10us, 100us). */\n+  MICROSx10_MICROSx100(TimeUnit.MICROSECONDS.toNanos(10), TimeUnit.MICROSECONDS.toNanos(100)),\n+\n+  /** Stores finished successful requests of duration within the interval [100us, 1ms). */\n+  MICROSx100_MILLIx1(TimeUnit.MICROSECONDS.toNanos(100), TimeUnit.MILLISECONDS.toNanos(1)),\n+\n+  /** Stores finished successful requests of duration within the interval [1ms, 10ms). */\n+  MILLIx1_MILLIx10(TimeUnit.MILLISECONDS.toNanos(1), TimeUnit.MILLISECONDS.toNanos(10)),\n+\n+  /** Stores finished successful requests of duration within the interval [10ms, 100ms). */\n+  MILLIx10_MILLIx100(TimeUnit.MILLISECONDS.toNanos(10), TimeUnit.MILLISECONDS.toNanos(100)),\n+\n+  /** Stores finished successful requests of duration within the interval [100ms, 1sec). */\n+  MILLIx100_SECONDx1(TimeUnit.MILLISECONDS.toNanos(100), TimeUnit.SECONDS.toNanos(1)),\n+\n+  /** Stores finished successful requests of duration within the interval [1sec, 10sec). */\n+  SECONDx1_SECONDx10(TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toNanos(10)),\n+\n+  /** Stores finished successful requests of duration within the interval [10sec, 100sec). */\n+  SECONDx10_SECONDx100(TimeUnit.SECONDS.toNanos(10), TimeUnit.SECONDS.toNanos(100)),\n+\n+  /** Stores finished successful requests of duration greater than or equal to 100sec. */\n+  SECONDx100_MAX(TimeUnit.SECONDS.toNanos(100), Long.MAX_VALUE);\n+\n+  private final long latencyLowerBound;\n+  private final long latencyUpperBound;\n+\n+  /**\n+   * Constructs a {@code LatencyBoundaries} with the given boundaries and label.\n+   *\n+   * @param latencyLowerBound the latency lower bound of the bucket.\n+   * @param latencyUpperBound the latency upper bound of the bucket.\n+   */\n+  LatencyBoundary(long latencyLowerBound, long latencyUpperBound) {\n+    this.latencyLowerBound = latencyLowerBound;\n+    this.latencyUpperBound = latencyUpperBound;\n+  }\n+\n+  /**\n+   * Returns the latency lower bound of the bucket.\n+   *\n+   * @return the latency lower bound of the bucket.\n+   */\n+  public long getLatencyLowerBound() {", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MTQxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451871410", "bodyText": "Nit let's go ahead and initialize this in the constructor too a bit confusing when some is initialized as field and other in constructor", "author": "anuraaga", "createdAt": "2020-07-08T23:02:17Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/SpanBucket.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.primitives.UnsignedInts;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+final class SpanBucket {\n+  // A power of 2 means Integer.MAX_VALUE % bucketSize = bucketSize - 1, so the index will always\n+  // loop back to 0.\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+\n+  private final ReadableSpan[] spans;\n+  private final AtomicInteger index = new AtomicInteger();", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MjM1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451872351", "bodyText": "With your new implementation, I don't think we need this synchronization anywhere in this file :)", "author": "anuraaga", "createdAt": "2020-07-08T23:05:14Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private final ImmutableMap<LatencyBoundary, SpanBucket> latencyBuckets;\n+  private final ImmutableMap<CanonicalCode, SpanBucket> errorBuckets;\n+\n+  TracezSpanBuckets() {\n+    ImmutableMap.Builder<LatencyBoundary, SpanBucket> latencyBucketsBuilder =\n+        ImmutableMap.builder();\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyBucketsBuilder.put(bucket, new SpanBucket(/* isLatencyBucket= */ true));\n+    }\n+    latencyBuckets = latencyBucketsBuilder.build();\n+    ImmutableMap.Builder<CanonicalCode, SpanBucket> errorBucketsBuilder = ImmutableMap.builder();\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBucketsBuilder.put(code, new SpanBucket(/* isLatencyBucket= */ false));\n+      }\n+    }\n+    errorBuckets = errorBucketsBuilder.build();\n+  }\n+\n+  void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      SpanBucket latencyBucket =\n+          latencyBuckets.get(LatencyBoundary.getBoundary(span.getLatencyNanos()));\n+      synchronized (latencyBucket) {", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3NDA4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451874086", "bodyText": "This looks like a constant don't need to format", "author": "anuraaga", "createdAt": "2020-07-08T23:10:36Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundary to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundary, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundaryStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+      out.print(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[\"\n+              + LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundary)\n+              + \"]</b></th>\");\n+    }\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.print(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param spanName the name of the corresponding span.\n+   * @param numOfSamples the number of samples of the corresponding span.\n+   * @param type the type of the corresponding span (running, latency, error).\n+   * @param subtype the sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintStream out, String spanName, int numOfSamples, SampleType type, int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?\");\n+      out.print(PARAM_SPAN_NAME + \"=\" + URLEncoder.encode(spanName, \"UTF-8\"));\n+      out.print(\"&\" + PARAM_SAMPLE_TYPE + \"=\" + type.getValue());\n+      out.print(\"&\" + PARAM_SAMPLE_SUB_TYPE + \"=\" + subtype);\n+      out.print(\"\\\">\" + numOfSamples + \"</a></td>\");\n+    } else if (numOfSamples < 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintStream} {@code\n+   * out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private void emitSummaryTable(PrintStream out) throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundary, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        out.print(\"<tr style=\\\"background-color: \" + ZEBRA_STRIPE_COLOR + \"\\\">\");\n+      } else {\n+        out.print(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      out.print(\"<td>\" + htmlEscaper().escape(spanName) + \"</td>\");\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundary)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundary)\n+                : 0;\n+        emitSummaryTableCell(out, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      PrintStream out, String spanName, int count, SampleType type) {\n+    out.print(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: \" + htmlEscaper().escape(spanName) + \" </b></p>\");\n+    String typeString =\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\";\n+    out.print(\"<p class=\\\"align-center\\\"><b> Number of \" + typeString + \": \" + count + \" </b></p>\");\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintStream out, Formatter formatter, Collection<SpanData> spans) {\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.print(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.print(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.print(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintStream out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3OTc1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451879753", "bodyText": "You can add first as a boolean field of the anonymous KeyValueConsumer instead of using AtomicBoolean though it could be a bit more readable to separate out a named class which you pass the StringBuilder in explicitly", "author": "anuraaga", "createdAt": "2020-07-08T23:28:34Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundary to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundary, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundaryStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+      out.print(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[\"\n+              + LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundary)\n+              + \"]</b></th>\");\n+    }\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.print(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param spanName the name of the corresponding span.\n+   * @param numOfSamples the number of samples of the corresponding span.\n+   * @param type the type of the corresponding span (running, latency, error).\n+   * @param subtype the sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintStream out, String spanName, int numOfSamples, SampleType type, int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?\");\n+      out.print(PARAM_SPAN_NAME + \"=\" + URLEncoder.encode(spanName, \"UTF-8\"));\n+      out.print(\"&\" + PARAM_SAMPLE_TYPE + \"=\" + type.getValue());\n+      out.print(\"&\" + PARAM_SAMPLE_SUB_TYPE + \"=\" + subtype);\n+      out.print(\"\\\">\" + numOfSamples + \"</a></td>\");\n+    } else if (numOfSamples < 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintStream} {@code\n+   * out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private void emitSummaryTable(PrintStream out) throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundary, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        out.print(\"<tr style=\\\"background-color: \" + ZEBRA_STRIPE_COLOR + \"\\\">\");\n+      } else {\n+        out.print(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      out.print(\"<td>\" + htmlEscaper().escape(spanName) + \"</td>\");\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundary)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundary)\n+                : 0;\n+        emitSummaryTableCell(out, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      PrintStream out, String spanName, int count, SampleType type) {\n+    out.print(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: \" + htmlEscaper().escape(spanName) + \" </b></p>\");\n+    String typeString =\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\";\n+    out.print(\"<p class=\\\"align-center\\\"><b> Number of \" + typeString + \": \" + count + \" </b></p>\");\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintStream out, Formatter formatter, Collection<SpanData> spans) {\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.print(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.print(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.print(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintStream out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.print(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.print(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintStream out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.print(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM5NTk0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r452395949", "bodyText": "The first field allows the overridden consume function to print something different for the first of all KeyValueConsumers. Wouldn't making it a boolean field within each KeyValueConsumer defeat its purpose?", "author": "williamhu99", "createdAt": "2020-07-09T18:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3OTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMzU3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r452533572", "bodyText": "Nah, there's only one KeyValueConsumer (there's only one execution of new KeyValueConsumer - using a field means accessing this variable doesn't use the thread-safe atomicboolean, which isn't needed here.", "author": "anuraaga", "createdAt": "2020-07-09T22:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3OTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU0OTk4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r452549989", "bodyText": "I see. I moved it into the KeyValueConsumer.", "author": "williamhu99", "createdAt": "2020-07-09T23:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3OTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MDA1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451880056", "bodyText": "Use java.util.Logger not system.err", "author": "anuraaga", "createdAt": "2020-07-08T23:29:34Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundary to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundary, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundaryStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+      out.print(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[\"\n+              + LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundary)\n+              + \"]</b></th>\");\n+    }\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.print(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param spanName the name of the corresponding span.\n+   * @param numOfSamples the number of samples of the corresponding span.\n+   * @param type the type of the corresponding span (running, latency, error).\n+   * @param subtype the sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintStream out, String spanName, int numOfSamples, SampleType type, int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?\");\n+      out.print(PARAM_SPAN_NAME + \"=\" + URLEncoder.encode(spanName, \"UTF-8\"));\n+      out.print(\"&\" + PARAM_SAMPLE_TYPE + \"=\" + type.getValue());\n+      out.print(\"&\" + PARAM_SAMPLE_SUB_TYPE + \"=\" + subtype);\n+      out.print(\"\\\">\" + numOfSamples + \"</a></td>\");\n+    } else if (numOfSamples < 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintStream} {@code\n+   * out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private void emitSummaryTable(PrintStream out) throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundary, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        out.print(\"<tr style=\\\"background-color: \" + ZEBRA_STRIPE_COLOR + \"\\\">\");\n+      } else {\n+        out.print(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      out.print(\"<td>\" + htmlEscaper().escape(spanName) + \"</td>\");\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundary)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundary)\n+                : 0;\n+        emitSummaryTableCell(out, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      PrintStream out, String spanName, int count, SampleType type) {\n+    out.print(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: \" + htmlEscaper().escape(spanName) + \" </b></p>\");\n+    String typeString =\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\";\n+    out.print(\"<p class=\\\"align-center\\\"><b> Number of \" + typeString + \": \" + count + \" </b></p>\");\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintStream out, Formatter formatter, Collection<SpanData> spans) {\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.print(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.print(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.print(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintStream out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.print(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.print(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintStream out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.print(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);\n+    attributes.forEach(\n+        new KeyValueConsumer<AttributeValue>() {\n+          @Override\n+          public void consume(String key, AttributeValue value) {\n+            if (!first.getAndSet(false)) {\n+              stringBuilder.append(\", \");\n+            }\n+            stringBuilder.append(key);\n+            stringBuilder.append(\"=\");\n+            switch (value.getType()) {\n+              case STRING:\n+                stringBuilder.append(value.getStringValue());\n+                break;\n+              case BOOLEAN:\n+                stringBuilder.append(value.getBooleanValue());\n+                break;\n+              case LONG:\n+                stringBuilder.append(value.getLongValue());\n+                break;\n+              case DOUBLE:\n+                stringBuilder.append(value.getDoubleValue());\n+                break;\n+              case STRING_ARRAY:\n+                stringBuilder.append(value.getStringArrayValue().toString());\n+                break;\n+              case BOOLEAN_ARRAY:\n+                stringBuilder.append(value.getBooleanArrayValue().toString());\n+                break;\n+              case LONG_ARRAY:\n+                stringBuilder.append(value.getLongArrayValue().toString());\n+                break;\n+              case DOUBLE_ARRAY:\n+                stringBuilder.append(value.getDoubleArrayValue().toString());\n+                break;\n+            }\n+          }\n+        });\n+    stringBuilder.append(\"}\");\n+    return stringBuilder.toString();\n+  }\n+\n+  private static String renderEvent(Event event) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(event.getName());\n+    if (!event.getAttributes().isEmpty()) {\n+      stringBuilder.append(\" | \");\n+      stringBuilder.append(renderAttributes(event.getAttributes()));\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  /**\n+   * Emits HTML body content to the {@link PrintStream} {@code out}. Content emitted by this\n+   * function should be enclosed by <body></body> tag.\n+   *\n+   * @param queryMap the map containing URL query parameters.s\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private void emitHtmlBody(Map<String, String> queryMap, PrintStream out)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      out.print(\"OpenTelemetry implementation not available.\");\n+      return;\n+    }\n+    // Link to OpenTelemetry Logo\n+    out.print(\n+        \"<img style=\\\"height: 90px;\\\" src=\\\"data:image/png;base64,\"\n+            + ZPageLogo.logoBase64\n+            + \"\\\" />\");\n+    out.print(\"<h1>TraceZ Summary</h1>\");\n+    emitSummaryTable(out);\n+    // spanName will be null if the query parameter doesn't exist in the URL\n+    String spanName = queryMap.get(PARAM_SPAN_NAME);\n+    if (spanName != null) {\n+      // Convert spanName with URL encoding\n+      spanName = URLEncoder.encode(spanName, \"UTF-8\");\n+      // Show detailed information for the corresponding span\n+      String typeStr = queryMap.get(PARAM_SAMPLE_TYPE);\n+      if (typeStr != null) {\n+        List<SpanData> spans = null;\n+        SampleType type = SampleType.fromString(typeStr);\n+        if (type == SampleType.UNKNOWN) {\n+          // Type of sample is garbage value\n+          return;\n+        } else if (type == SampleType.RUNNING) {\n+          // Display running span\n+          spans = dataAggregator.getRunningSpans(spanName);\n+          Collections.sort(spans, new SpanDataComparator(/* incremental= */ true));\n+        } else {\n+          String subtypeStr = queryMap.get(PARAM_SAMPLE_SUB_TYPE);\n+          if (subtypeStr != null) {\n+            int subtype = Integer.parseInt(subtypeStr);\n+            if (type == SampleType.LATENCY) {\n+              if (subtype < 0 || subtype >= LatencyBoundary.values().length) {\n+                // N/A or out-of-bound check for latency based subtype, valid values: [0, 8]\n+                return;\n+              }\n+              // Display latency based span\n+              LatencyBoundary latencyBoundary = LatencyBoundary.values()[subtype];\n+              spans =\n+                  dataAggregator.getOkSpans(\n+                      spanName,\n+                      latencyBoundary.getLatencyLowerBound(),\n+                      latencyBoundary.getLatencyUpperBound());\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            } else {\n+              if (subtype < 0 || subtype >= CanonicalCode.values().length) {\n+                // N/A or out-of-bound cueck for error based subtype, valid values: [0, 15]\n+                return;\n+              }\n+              // Display error based span\n+              spans = dataAggregator.getErrorSpans(spanName);\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            }\n+          }\n+        }\n+        out.print(\"<h2>Span Details</h2>\");\n+        emitSpanNameAndCount(out, spanName, spans == null ? 0 : spans.size(), type);\n+\n+        if (spans != null) {\n+          Formatter formatter = new Formatter(out, Locale.US);\n+          emitSpanDetails(out, formatter, spans);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void emitHtml(Map<String, String> queryMap, OutputStream outputStream) {\n+    // PrintStream for emiting HTML contents\n+    try (PrintStream out = new PrintStream(outputStream, /* autoFlush= */ false, \"UTF-8\")) {\n+      out.print(\"<!DOCTYPE html>\");\n+      out.print(\"<html lang=\\\"en\\\">\");\n+      out.print(\"<head>\");\n+      out.print(\"<meta charset=\\\"UTF-8\\\">\");\n+      out.print(\n+          \"<link rel=\\\"shortcut icon\\\" href=\\\"data:image/png;base64,\"\n+              + ZPageLogo.faviconBase64\n+              + \"\\\" type=\\\"image/png\\\">\");\n+      out.print(\n+          \"<link href=\\\"https://fonts.googleapis.com/css?family=Open+Sans:300\\\"\"\n+              + \"rel=\\\"stylesheet\\\">\");\n+      out.print(\n+          \"<link href=\\\"https://fonts.googleapis.com/css?family=Roboto\\\" rel=\\\"stylesheet\\\">\");\n+      out.print(\"<title>TraceZ</title>\");\n+      emitHtmlStyle(out);\n+      out.print(\"</head>\");\n+      out.print(\"<body>\");\n+      try {\n+        emitHtmlBody(queryMap, out);\n+      } catch (Throwable t) {\n+        out.print(\"Error while generating HTML: \" + t.toString());\n+      }\n+      out.print(\"</body>\");\n+      out.print(\"</html>\");\n+    } catch (Throwable t) {\n+      System.err.print(\"Error while generating HTML: \" + t.toString());", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MDU3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451880576", "bodyText": "Static before non-static", "author": "anuraaga", "createdAt": "2020-07-08T23:31:16Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MDkwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451880905", "bodyText": "Don't need to check size, you can check contents directly, e.g,\nassertThat(names).containsExactly(SPAN_NAME_ONE, SPAN_NAME_TWO)\nApplies throughout PR", "author": "anuraaga", "createdAt": "2020-07-08T23:32:17Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Before\n+  public void setup() {\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames()).isEmpty();\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MTA1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451881053", "bodyText": "Map assert also has containsExactly", "author": "anuraaga", "createdAt": "2020-07-08T23:32:46Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Before\n+  public void setup() {\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames()).isEmpty();\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getSpanNames should still return a set with 2 span names */\n+    names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_noSpans() {\n+    /* getRunningSpanCounts should return a an empty map */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpanCounts should return a map with 1 span name */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(3);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpanCounts should return a map with 2 different span names */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(2);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span1.end();\n+    /* getRunningSpanCounts should return a map with 1 unique span name */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MTI1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451881258", "bodyText": "assertThat(counts).isEmpty() and remove following", "author": "anuraaga", "createdAt": "2020-07-08T23:33:25Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Before\n+  public void setup() {\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames()).isEmpty();\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getSpanNames should still return a set with 2 span names */\n+    names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_noSpans() {\n+    /* getRunningSpanCounts should return a an empty map */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpanCounts should return a map with 1 span name */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(3);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpanCounts should return a map with 2 different span names */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(2);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span1.end();\n+    /* getRunningSpanCounts should return a map with 1 unique span name */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span2.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_noSpans() {\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE)).isEmpty();\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO)).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpans should return a List with all 3 spans */\n+    List<SpanData> spans = dataAggregator.getRunningSpans(SPAN_NAME_ONE);\n+    assertThat(spans.size()).isEqualTo(3);\n+    assertThat(spans).contains(((ReadableSpan) span1).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span2).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span3).toSpanData());\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE)).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpans should return a List with only the corresponding span */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE))\n+        .containsExactly(((ReadableSpan) span1).toSpanData());\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO))\n+        .containsExactly(((ReadableSpan) span2).toSpanData());\n+    span1.end();\n+    span2.end();\n+    /* getRunningSpans should return an empty List for each span name */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE)).isEmpty();\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO)).isEmpty();\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Map<String, Map<LatencyBoundary, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    assertThat(counts.size()).isEqualTo(0);", "originalCommit": "88a703b4591e804e3804e5e8e8459d24244a2d27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fee6378c49a085fb6ce72b38b4c739b0d4812cff", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/fee6378c49a085fb6ce72b38b4c739b0d4812cff", "message": "Addressed additional comments", "committedDate": "2020-07-09T18:02:35Z", "type": "commit"}, {"oid": "a3934318c1146974a786cb3918291c85d5d32a4e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a3934318c1146974a786cb3918291c85d5d32a4e", "message": "Migrated images to resources, used logger to log errors, and other minor fixes", "committedDate": "2020-07-09T19:18:39Z", "type": "commit"}, {"oid": "0b2357f4fa00e697080807f0e65b3d9406e6a0b9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0b2357f4fa00e697080807f0e65b3d9406e6a0b9", "message": "Moved a variable to within a class in TracezZPageHandler", "committedDate": "2020-07-09T23:33:40Z", "type": "commit"}, {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/be61de27eddf89762857a3b6b5ef997a18e85014", "message": "Made a small fix to scope", "committedDate": "2020-07-09T23:35:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDE2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140166", "bodyText": "Think this was missed as part of a different comment - you don't need to synchronize anymore", "author": "anuraaga", "createdAt": "2020-07-11T01:45:51Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private final ImmutableMap<LatencyBoundary, SpanBucket> latencyBuckets;\n+  private final ImmutableMap<CanonicalCode, SpanBucket> errorBuckets;\n+\n+  TracezSpanBuckets() {\n+    ImmutableMap.Builder<LatencyBoundary, SpanBucket> latencyBucketsBuilder =\n+        ImmutableMap.builder();\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyBucketsBuilder.put(bucket, new SpanBucket(/* isLatencyBucket= */ true));\n+    }\n+    latencyBuckets = latencyBucketsBuilder.build();\n+    ImmutableMap.Builder<CanonicalCode, SpanBucket> errorBucketsBuilder = ImmutableMap.builder();\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBucketsBuilder.put(code, new SpanBucket(/* isLatencyBucket= */ false));\n+      }\n+    }\n+    errorBuckets = errorBucketsBuilder.build();\n+  }\n+\n+  void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      latencyBuckets.get(LatencyBoundary.getBoundary(span.getLatencyNanos())).add(span);\n+      return;\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  Map<LatencyBoundary, Integer> getLatencyBoundaryToCountMap() {\n+    Map<LatencyBoundary, Integer> latencyCounts = new EnumMap<>(LatencyBoundary.class);\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  List<ReadableSpan> getOkSpans() {\n+    List<ReadableSpan> okSpans = new ArrayList<>();\n+    for (SpanBucket latencyBucket : latencyBuckets.values()) {\n+      synchronized (latencyBucket) {", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDE5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140191", "bodyText": "Ditto", "author": "anuraaga", "createdAt": "2020-07-11T01:46:10Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private final ImmutableMap<LatencyBoundary, SpanBucket> latencyBuckets;\n+  private final ImmutableMap<CanonicalCode, SpanBucket> errorBuckets;\n+\n+  TracezSpanBuckets() {\n+    ImmutableMap.Builder<LatencyBoundary, SpanBucket> latencyBucketsBuilder =\n+        ImmutableMap.builder();\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyBucketsBuilder.put(bucket, new SpanBucket(/* isLatencyBucket= */ true));\n+    }\n+    latencyBuckets = latencyBucketsBuilder.build();\n+    ImmutableMap.Builder<CanonicalCode, SpanBucket> errorBucketsBuilder = ImmutableMap.builder();\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBucketsBuilder.put(code, new SpanBucket(/* isLatencyBucket= */ false));\n+      }\n+    }\n+    errorBuckets = errorBucketsBuilder.build();\n+  }\n+\n+  void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      latencyBuckets.get(LatencyBoundary.getBoundary(span.getLatencyNanos())).add(span);\n+      return;\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  Map<LatencyBoundary, Integer> getLatencyBoundaryToCountMap() {\n+    Map<LatencyBoundary, Integer> latencyCounts = new EnumMap<>(LatencyBoundary.class);\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  List<ReadableSpan> getOkSpans() {\n+    List<ReadableSpan> okSpans = new ArrayList<>();\n+    for (SpanBucket latencyBucket : latencyBuckets.values()) {\n+      synchronized (latencyBucket) {\n+        latencyBucket.addTo(okSpans);\n+      }\n+    }\n+    return okSpans;\n+  }\n+\n+  List<ReadableSpan> getErrorSpans() {\n+    List<ReadableSpan> errorSpans = new ArrayList<>();\n+    for (SpanBucket errorBucket : errorBuckets.values()) {\n+      synchronized (errorSpans) {", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDQwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140409", "bodyText": "Collections.emptyList", "author": "anuraaga", "createdAt": "2020-07-11T01:48:35Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    spanNames.addAll(spanProcessor.getCompletedSpanCache().keySet());\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  Map<String, Map<LatencyBoundary, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundary, Integer>> numSpansPerName = new HashMap<>();\n+    for (Entry<String, TracezSpanBuckets> cacheEntry : completedSpanCache.entrySet()) {\n+      numSpansPerName.put(\n+          cacheEntry.getKey(), cacheEntry.getValue().getLatencyBoundaryToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    TracezSpanBuckets buckets = completedSpanCache.get(spanName);\n+    if (buckets == null) {\n+      return new ArrayList<>();", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NTk1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453855956", "bodyText": "There's an error with immutability vs mutability if we revert back to Collections.emptyList. Should I change the function signature to return an immutable list?", "author": "williamhu99", "createdAt": "2020-07-13T18:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkxMDc1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453910752", "bodyText": "If we're ok with guava, then yes.  \ud83d\udc4d", "author": "jkwatson", "createdAt": "2020-07-13T20:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzNjc2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453936761", "bodyText": "Oh, turns out there's another way to do it as well! You can resolve this comment along with the one below.", "author": "williamhu99", "createdAt": "2020-07-13T21:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzOTM4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453939383", "bodyText": "I'll wait to resolve until it's been changed. ;)", "author": "jkwatson", "createdAt": "2020-07-13T21:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0MzEzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453943139", "bodyText": "Sounds good. I already pushed the change, so I hope it updates in the repo soon.", "author": "williamhu99", "createdAt": "2020-07-13T21:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDUxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140519", "bodyText": "I don't think this is actually visible for testing it's overriding a protected method so so is protected", "author": "anuraaga", "createdAt": "2020-07-11T01:49:56Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.put(span.getSpanContext().getSpanId(), span);\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());\n+      completedSpanCache.get(span.getName()).addToBucket(span);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // Do nothing.\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Returns a Collection of all running spans for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link ReadableSpan}.\n+   */\n+  Collection<ReadableSpan> getRunningSpans() {\n+    return runningSpanCache.values();\n+  }\n+\n+  /**\n+   * Returns a Collection of all completed spans for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link ReadableSpan}.\n+   */\n+  Collection<ReadableSpan> getCompletedSpans() {\n+    Collection<ReadableSpan> completedSpans = new ArrayList<>();\n+    for (TracezSpanBuckets buckets : completedSpanCache.values()) {\n+      completedSpans.addAll(buckets.getSpans());\n+    }\n+    return completedSpans;\n+  }\n+\n+  /**\n+   * Returns the completed span cache for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Map of String to {@link TracezSpanBuckets}.\n+   */\n+  Map<String, TracezSpanBuckets> getCompletedSpanCache() {\n+    return completedSpanCache;\n+  }\n+\n+  /**\n+   * Returns a new Builder for {@link TracezSpanProcessor}.\n+   *\n+   * @return a new {@link TracezSpanProcessor}.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder class for {@link TracezSpanProcessor}. */\n+  public static final class Builder extends ConfigBuilder<Builder> {\n+\n+    private static final String KEY_SAMPLED = \"otel.zpages.export.sampled\";\n+    private static final boolean DEFAULT_EXPORT_ONLY_SAMPLED = true;\n+    private boolean sampled = DEFAULT_EXPORT_ONLY_SAMPLED;\n+\n+    private Builder() {}\n+\n+    /**\n+     * Sets the configuration values from the given configuration map for only the available keys.\n+     * This method looks for the following keys:\n+     *\n+     * <ul>\n+     *   <li>{@code otel.zpages.export.sampled}: to set whether only sampled spans should be\n+     *       exported.\n+     * </ul>\n+     *\n+     * @param configMap {@link Map} holding the configuration values.\n+     * @return this.\n+     */\n+    @VisibleForTesting", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDc5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140795", "bodyText": "Why are these commented?", "author": "anuraaga", "createdAt": "2020-07-11T01:52:23Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBucketsTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+\n+/** Unit tests for {@link TracezSpanBuckets}. */\n+@RunWith(JUnit4.class)\n+public class TracezSpanBucketsTest {\n+  @Mock private ReadableSpan readableSpan;\n+  @Mock private SpanData spanData;\n+\n+  @Test\n+  public void addToBucket_moreThanTenLatencySamples() {\n+    /*", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODA4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453858089", "bodyText": "Not sure why this file is here, but it wasn't meant to be pushed. I'll delete it.", "author": "williamhu99", "createdAt": "2020-07-13T18:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTE3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453141177", "bodyText": "Don't use mocks for collections. Incidentally noticed this always returns null for any key, are we missing test coverage related to query parameters?", "author": "anuraaga", "createdAt": "2020-07-11T01:56:10Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public final class TracezZPageHandlerTest {\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";\n+  private static final String FINISHED_SPAN_TWO = \"FinishedSpanTwo\";\n+  private static final String RUNNING_SPAN = \"RunningSpan\";\n+  private static final String LATENCY_SPAN = \"LatencySpan\";\n+  private static final String ERROR_SPAN = \"ErrorSpan\";\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  @Mock Map<String, String> queryMap;", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY2MTA2Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453661067", "bodyText": "I'll keep this queryMap mock as it is not used to test query parameter behaviors, I'll include more test covering query parameters and construct a new queryMap separately", "author": "wtyanan", "createdAt": "2020-07-13T13:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTIzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453141239", "bodyText": "Collections.emptyList", "author": "anuraaga", "createdAt": "2020-07-11T01:56:56Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    spanNames.addAll(spanProcessor.getCompletedSpanCache().keySet());\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  Map<String, Map<LatencyBoundary, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundary, Integer>> numSpansPerName = new HashMap<>();\n+    for (Entry<String, TracezSpanBuckets> cacheEntry : completedSpanCache.entrySet()) {\n+      numSpansPerName.put(\n+          cacheEntry.getKey(), cacheEntry.getValue().getLatencyBoundaryToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    TracezSpanBuckets buckets = completedSpanCache.get(spanName);\n+    if (buckets == null) {\n+      return new ArrayList<>();\n+    }\n+    Collection<ReadableSpan> allOkSpans = buckets.getOkSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allOkSpans) {\n+      if (span.getLatencyNanos() >= lowerBound && span.getLatencyNanos() < upperBound) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of error span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of error span counts for each span name.\n+   */\n+  Map<String, Integer> getErrorSpanCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Integer> numErrorsPerName = new HashMap<>();\n+    for (Entry<String, TracezSpanBuckets> cacheEntry : completedSpanCache.entrySet()) {\n+      numErrorsPerName.put(cacheEntry.getKey(), cacheEntry.getValue().getErrorSpans().size());\n+    }\n+    return numErrorsPerName;\n+  }\n+\n+  /**\n+   * Returns a List of error spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getErrorSpans(String spanName) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    TracezSpanBuckets buckets = completedSpanCache.get(spanName);\n+    if (buckets == null) {\n+      return new ArrayList<>();", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODI3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453858279", "bodyText": "Same response as above", "author": "williamhu99", "createdAt": "2020-07-13T18:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTQ3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453141478", "bodyText": "Remove", "author": "anuraaga", "createdAt": "2020-07-11T01:59:42Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());\n+      t.printStackTrace();", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1NjUxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453656513", "bodyText": "Should I remove the printStackTrace() ? or the Logger entirely", "author": "wtyanan", "createdAt": "2020-07-13T13:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1ODMyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453658327", "bodyText": "Printstacktrace, it just outputs to stdout but we want our messages to go through logging so users have more control over them.", "author": "anuraaga", "createdAt": "2020-07-13T13:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE5MTc4MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453191781", "bodyText": "Sorry realized this should be AtomicReferenceArray\nhttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReferenceArray.html\nShould just replace the array accesses with .set / .get", "author": "anuraaga", "createdAt": "2020-07-11T12:46:21Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/SpanBucket.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.primitives.UnsignedInts;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+final class SpanBucket {\n+  // A power of 2 means Integer.MAX_VALUE % bucketSize = bucketSize - 1, so the index will always\n+  // loop back to 0.\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+\n+  private final ReadableSpan[] spans;\n+  private final AtomicInteger index;\n+  private final int bucketSize;\n+\n+  SpanBucket(boolean isLatencyBucket) {\n+    bucketSize = isLatencyBucket ? LATENCY_BUCKET_SIZE : ERROR_BUCKET_SIZE;\n+    spans = new ReadableSpan[bucketSize];", "originalCommit": "be61de27eddf89762857a3b6b5ef997a18e85014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2495cf9e375d75a2103c41a8eafeefac7c075930", "message": "Removed printStackTrace, added test for query parameter", "committedDate": "2020-07-13T14:35:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMzY0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453713640", "bodyText": "Generally, the idiomatic way to access a logger is to make the Logger a static field of this class.", "author": "jkwatson", "createdAt": "2020-07-13T14:59:51Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())", "originalCommit": "2495cf9e375d75a2103c41a8eafeefac7c075930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxOTIxMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453719212", "bodyText": "Changed to static field", "author": "wtyanan", "createdAt": "2020-07-13T15:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMzY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNDMzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453714332", "bodyText": "rather than logging the toString, it's more useful to log the entire exception. there is an overload that let's you pass in the exception itself, and let the logging framework/formatter deal with how to display it.", "author": "jkwatson", "createdAt": "2020-07-13T15:00:45Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());", "originalCommit": "2495cf9e375d75a2103c41a8eafeefac7c075930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxOTQwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453719405", "bodyText": "Used Logger.log(level, message, throwable) instead", "author": "wtyanan", "createdAt": "2020-07-13T15:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNDMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNDc1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453714758", "bodyText": "What will the caller end up doing with an empty string? Will it just cause another excpetion higher up the stack?", "author": "jkwatson", "createdAt": "2020-07-13T15:01:18Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());\n+      return \"\";", "originalCommit": "2495cf9e375d75a2103c41a8eafeefac7c075930", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNzQwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453717404", "bodyText": "The image will appear broken on the page (since the source will be an empty string) and error message is logged. No other exception will happen as I don't think a broken/not found image should crash the entire page.", "author": "wtyanan", "createdAt": "2020-07-13T15:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNDc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyMDE3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453720171", "bodyText": "ok!", "author": "jkwatson", "createdAt": "2020-07-13T15:08:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNDc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNTI1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453715257", "bodyText": "all the same comments apply down here, of course.", "author": "jkwatson", "createdAt": "2020-07-13T15:01:59Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());\n+      return \"\";\n+    }\n+  }\n+\n+  /**\n+   * Get OpenTelemetry favicon in base64 encoding.\n+   *\n+   * @return OpenTelemetry favicon in base64 encoding.\n+   */\n+  public static String getFaviconBase64() {\n+    try {\n+\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"favicon.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());\n+      return \"\";", "originalCommit": "2495cf9e375d75a2103c41a8eafeefac7c075930", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "648a8b4e162f0f0cd0278bb75d496b68d2d119b7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/648a8b4e162f0f0cd0278bb75d496b68d2d119b7", "message": "Changed logger to static field, used log method to log detailed stackTrace", "committedDate": "2020-07-13T15:16:27Z", "type": "commit"}, {"oid": "d6113ea096e3eeff312e83ed53a2c68428230fe7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d6113ea096e3eeff312e83ed53a2c68428230fe7", "message": "Made minor fixes", "committedDate": "2020-07-13T18:54:38Z", "type": "commit"}, {"oid": "23e17281b03d570809a69e8f9c3ef01180c325e1", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/23e17281b03d570809a69e8f9c3ef01180c325e1", "message": "Resolved unmodifiable list error with getOkSpans and getErrorSpans", "committedDate": "2020-07-13T21:02:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDIwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454014209", "bodyText": "In general, you should think of mockito as a hack, a very important hack, but still one that uses bytecode manipulation to circumvent normal Java for testing (now adays it can even mock out final classes, wow). For normal containers even in tests it's best to avoid that (can just pass ImmutableMap.of() without much loss in expressiveness).\nDon't forget that this now ties down the implementation - .isEmpty returns false for this map even though you're trying to test the empty map case, so it's not correct and we're just sort of lucky the test passes.", "author": "anuraaga", "createdAt": "2020-07-13T23:51:36Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public final class TracezZPageHandlerTest {\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";\n+  private static final String FINISHED_SPAN_TWO = \"FinishedSpanTwo\";\n+  private static final String RUNNING_SPAN = \"RunningSpan\";\n+  private static final String LATENCY_SPAN = \"LatencySpan\";\n+  private static final String ERROR_SPAN = \"ErrorSpan\";\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  @Mock Map<String, String> queryMap;", "originalCommit": "23e17281b03d570809a69e8f9c3ef01180c325e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyMTU0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454421547", "bodyText": "Thanks for the explanation! Seems like I don't need mockito here then, should I change the runner back to JUnit4 runner?", "author": "wtyanan", "createdAt": "2020-07-14T14:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyOTMzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454729336", "bodyText": "Sure", "author": "anuraaga", "createdAt": "2020-07-15T01:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyOTQ1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454729459", "bodyText": "Ah just noticed - either way, you definitely shouldn't ever have both the runner and the rule but looks like you can remove both", "author": "anuraaga", "createdAt": "2020-07-15T01:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczMDM5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454730394", "bodyText": "So if in case I need to use @mock, only mockito rule with JUni4 runner is sufficient?", "author": "wtyanan", "createdAt": "2020-07-15T01:06:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczMDY0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454730641", "bodyText": "Yeah either mockito rule + junit4 runner or mockito runner, but not both. Which one is a matter of personal preference.", "author": "anuraaga", "createdAt": "2020-07-15T01:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczMTAwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454731005", "bodyText": "Got it, I got confused by one of the previous comment regarding this.", "author": "wtyanan", "createdAt": "2020-07-15T01:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDQwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454014402", "bodyText": "I saw a third .get on subsampletype or something but see only two query parameters in this test so guessing we're missing one more test case.", "author": "anuraaga", "createdAt": "2020-07-13T23:52:24Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public final class TracezZPageHandlerTest {\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";\n+  private static final String FINISHED_SPAN_TWO = \"FinishedSpanTwo\";\n+  private static final String RUNNING_SPAN = \"RunningSpan\";\n+  private static final String LATENCY_SPAN = \"LatencySpan\";\n+  private static final String ERROR_SPAN = \"ErrorSpan\";\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  @Mock Map<String, String> queryMap;\n+\n+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Before\n+  public void setup() {\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void summaryTable_emitRowForEachSpan() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Span finishedSpan1 = tracer.spanBuilder(FINISHED_SPAN_ONE).startSpan();\n+    Span finishedSpan2 = tracer.spanBuilder(FINISHED_SPAN_TWO).startSpan();\n+    finishedSpan1.end();\n+    finishedSpan2.end();\n+\n+    Span runningSpan = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+\n+    Span latencySpan = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions = EndSpanOptions.builder().setEndTimestamp(10002L).build();\n+    latencySpan.end(endOptions);\n+\n+    Span errorSpan = tracer.spanBuilder(ERROR_SPAN).startSpan();\n+    errorSpan.setStatus(CanonicalCode.INVALID_ARGUMENT.toStatus());\n+    errorSpan.end();\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Emit a row for all types of spans\n+    assertThat(output.toString()).contains(FINISHED_SPAN_ONE);\n+    assertThat(output.toString()).contains(FINISHED_SPAN_TWO);\n+    assertThat(output.toString()).contains(RUNNING_SPAN);\n+    assertThat(output.toString()).contains(LATENCY_SPAN);\n+    assertThat(output.toString()).contains(ERROR_SPAN);\n+\n+    runningSpan.end();\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForRunningSpans() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Span runningSpan1 = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+    Span runningSpan2 = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+    Span runningSpan3 = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+    Span finishedSpan = tracer.spanBuilder(FINISHED_SPAN_ONE).startSpan();\n+    finishedSpan.end();\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Link for running span with 3 running\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + RUNNING_SPAN + \"&ztype=0&zsubtype=0\\\">3\");\n+    // No link for finished spans\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + FINISHED_SPAN_ONE + \"&ztype=0&subtype=0\\\"\");\n+\n+    runningSpan1.end();\n+    runningSpan2.end();\n+    runningSpan3.end();\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForLatencyBasedSpans_NoneForEmptyBoundary() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // No link for boundary 0\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=0\\\"\");\n+    // No link for boundary 1\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=1\\\"\");\n+    // No link for boundary 2\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=2\\\"\");\n+    // No link for boundary 3\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=3\\\"\");\n+    // No link for boundary 4\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=4\\\"\");\n+    // No link for boundary 5\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=5\\\"\");\n+    // No link for boundary 6\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=6\\\"\");\n+    // No link for boundary 7\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=7\\\"\");\n+    // No link for boundary 8\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=8\\\"\");\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForLatencyBasedSpans_OnePerBoundary() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    // Boundary 0, >1us\n+    Span latencySpanSubtype0 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions0 = EndSpanOptions.builder().setEndTimestamp(1002L).build();\n+    latencySpanSubtype0.end(endOptions0);\n+    // Boundary 1, >10us\n+    Span latencySpanSubtype1 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions1 = EndSpanOptions.builder().setEndTimestamp(10002L).build();\n+    latencySpanSubtype1.end(endOptions1);\n+    // Boundary 2, >100us\n+    Span latencySpanSubtype2 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions2 = EndSpanOptions.builder().setEndTimestamp(100002L).build();\n+    latencySpanSubtype2.end(endOptions2);\n+    // Boundary 3, >1ms\n+    Span latencySpanSubtype3 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions3 = EndSpanOptions.builder().setEndTimestamp(1000002L).build();\n+    latencySpanSubtype3.end(endOptions3);\n+    // Boundary 4, >10ms\n+    Span latencySpanSubtype4 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions4 = EndSpanOptions.builder().setEndTimestamp(10000002L).build();\n+    latencySpanSubtype4.end(endOptions4);\n+    // Boundary 5, >100ms\n+    Span latencySpanSubtype5 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions5 = EndSpanOptions.builder().setEndTimestamp(100000002L).build();\n+    latencySpanSubtype5.end(endOptions5);\n+    // Boundary 6, >1s\n+    Span latencySpanSubtype6 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions6 = EndSpanOptions.builder().setEndTimestamp(1000000002L).build();\n+    latencySpanSubtype6.end(endOptions6);\n+    // Boundary 7, >10s\n+    Span latencySpanSubtype7 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions7 = EndSpanOptions.builder().setEndTimestamp(10000000002L).build();\n+    latencySpanSubtype7.end(endOptions7);\n+    // Boundary 8, >100s\n+    Span latencySpanSubtype8 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions8 = EndSpanOptions.builder().setEndTimestamp(100000000002L).build();\n+    latencySpanSubtype8.end(endOptions8);\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Link for boundary 0\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=0\\\">1\");\n+    // Link for boundary 1\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=1\\\">1\");\n+    // Link for boundary 2\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=2\\\">1\");\n+    // Link for boundary 3\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=3\\\">1\");\n+    // Link for boundary 4\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=4\\\">1\");\n+    // Link for boundary 5\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=5\\\">1\");\n+    // Link for boundary 6\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=6\\\">1\");\n+    // Link for boundary 7\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=7\\\">1\");\n+    // Link for boundary 8\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=8\\\">1\");\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForLatencyBasedSpans_MultipleForOneBoundary() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    // 4 samples in boundary 5, >100ms\n+    Span latencySpan100ms1 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions1 = EndSpanOptions.builder().setEndTimestamp(112931232L).build();\n+    latencySpan100ms1.end(endOptions1);\n+    Span latencySpan100ms2 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions2 = EndSpanOptions.builder().setEndTimestamp(138694322L).build();\n+    latencySpan100ms2.end(endOptions2);\n+    Span latencySpan100ms3 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions3 = EndSpanOptions.builder().setEndTimestamp(154486482L).build();\n+    latencySpan100ms3.end(endOptions3);\n+    Span latencySpan100ms4 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions4 = EndSpanOptions.builder().setEndTimestamp(194892582L).build();\n+    latencySpan100ms4.end(endOptions4);\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Link for boundary 5 with 4 samples\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=5\\\">4\");\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForErrorSpans() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Span errorSpan1 = tracer.spanBuilder(ERROR_SPAN).startSpan();\n+    Span errorSpan2 = tracer.spanBuilder(ERROR_SPAN).startSpan();\n+    Span errorSpan3 = tracer.spanBuilder(ERROR_SPAN).startSpan();\n+    Span finishedSpan = tracer.spanBuilder(FINISHED_SPAN_ONE).startSpan();\n+    errorSpan1.setStatus(CanonicalCode.CANCELLED.toStatus());\n+    errorSpan2.setStatus(CanonicalCode.ABORTED.toStatus());\n+    errorSpan3.setStatus(CanonicalCode.DEADLINE_EXCEEDED.toStatus());\n+    errorSpan1.end();\n+    errorSpan2.end();\n+    errorSpan3.end();\n+    finishedSpan.end();\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Link for error based spans with 3 samples\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + ERROR_SPAN + \"&ztype=2&zsubtype=0\\\">3\");\n+    // No link for Status{#OK} spans\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + FINISHED_SPAN_ONE + \"&ztype=2&subtype=0\\\"\");\n+  }\n+\n+  @Test\n+  public void spanDetails_emitSpanNameCorrectly() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Map<String, String> queryMapWithSpanName = new HashMap<String, String>();\n+    queryMapWithSpanName.put(\"zspanname\", FINISHED_SPAN_ONE);\n+    queryMapWithSpanName.put(\"ztype\", \"1\");", "originalCommit": "23e17281b03d570809a69e8f9c3ef01180c325e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "317876f331e4ba8e870f05d8b24b0d3b0304f86a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/317876f331e4ba8e870f05d8b24b0d3b0304f86a", "message": "Changed map @Mock to empty map, added more test", "committedDate": "2020-07-14T20:32:37Z", "type": "commit"}, {"oid": "842629c3e3f13e3aac897fa24841ea9d6df3fc84", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/842629c3e3f13e3aac897fa24841ea9d6df3fc84", "message": "Changed test runner", "committedDate": "2020-07-15T01:27:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0ODQ3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r455148477", "bodyText": "I'd love to have unit tests on this class specifically, but that can be in a follow-up PR.", "author": "jkwatson", "createdAt": "2020-07-15T15:39:47Z", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/SpanBucket.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.primitives.UnsignedInts;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+final class SpanBucket {", "originalCommit": "842629c3e3f13e3aac897fa24841ea9d6df3fc84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}