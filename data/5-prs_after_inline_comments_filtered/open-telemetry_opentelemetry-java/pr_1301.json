{"pr_number": 1301, "pr_title": "Add AWS X-Ray propagator", "pr_createdAt": "2020-06-01T22:31:10Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NDY0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433564642", "bodyText": "Nit let's line break before .build()", "author": "anuraaga", "createdAt": "2020-06-02T00:56:36Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMjYzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434902635", "bodyText": "will fix in rev2", "author": "shengxil", "createdAt": "2020-06-03T22:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NDY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NTE5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433565199", "bodyText": "Put in visibility order public (none here), package private, private.", "author": "anuraaga", "createdAt": "2020-06-02T00:58:53Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NTI4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433565288", "bodyText": "Since SDK depends on Guava, I think it's ok for extensions to as well since it's basically free. So can add @VisibleForTesting", "author": "anuraaga", "createdAt": "2020-06-02T00:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NTE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMjYyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434902626", "bodyText": "will fix in rev2", "author": "shengxil", "createdAt": "2020-06-03T22:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NTE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NjA1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433566050", "bodyText": "Can you run ./gradlew googleJavaFormat?", "author": "anuraaga", "createdAt": "2020-06-02T01:02:22Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMjYzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434902630", "bodyText": "will do in rev2", "author": "shengxil", "createdAt": "2020-06-03T22:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NjA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NzA5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433567099", "bodyText": "Can we add tracestate as additional params too? Not sure we'd prefer tracestate= some serialized string or put the KV's directly (probably need to dedupe against our known keys if the latter).\nIf not now, let's add a TODO to revisit it we shouldn't just drop it if possible.", "author": "anuraaga", "createdAt": "2020-06-02T01:06:59Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4NTMxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434885317", "bodyText": "I'll add a TODO here since we are discussing whether we will put the OT first 8 digit in trace state. I'd do them together.", "author": "shengxil", "createdAt": "2020-06-03T22:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NzA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2Nzc0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433567740", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                checkNotNull(carrier, \"carrier\");\n          \n          \n            \n                checkNotNull(getter, \"getter\");\n          \n          \n            \n                Objects.requireNonNull(carrier, \"carrier\");\n          \n          \n            \n                Objects.requireNonNull(getter, \"getter\");", "author": "anuraaga", "createdAt": "2020-06-02T01:09:39Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMjY1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434902651", "bodyText": "will fix in rev2", "author": "shengxil", "createdAt": "2020-06-03T22:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2Nzc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2ODA4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433568087", "bodyText": "As per 3) should we avoid throwing on null?\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/error-handling.md#basic-error-handling-principles", "author": "anuraaga", "createdAt": "2020-06-02T01:10:58Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4NzkwOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434887908", "bodyText": "I'm aligning with the default propagator and the official b3/jaeger propagator. How about we keep the same behavior here and create a separate issue to change all propagators?", "author": "shengxil", "createdAt": "2020-06-03T22:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2ODA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2ODkwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433568909", "bodyText": "Think it's better to use .getSpan(context) and check span.getContext().isValid(). From what I can tell, this current method may return an invalid span too, so either we check both null and valid or just valid.", "author": "anuraaga", "createdAt": "2020-06-02T01:14:29Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMjY1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434902659", "bodyText": "will check valid to align with the default propagator.", "author": "shengxil", "createdAt": "2020-06-03T22:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2ODkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2OTI2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433569261", "bodyText": "Instead of a large catch-all exception, only catch where an exception could happen. Even if we're worried about missing something, this isn't the right layer to have a catch-all.", "author": "anuraaga", "createdAt": "2020-06-02T01:15:57Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2OTgwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433569803", "bodyText": "I'm not sure if internal package is really meant for use from contrib, but similar to above, since this is SDK, we may as well just use Guava and Strings.isNullOrEmpty", "author": "anuraaga", "createdAt": "2020-06-02T01:18:17Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5MDMxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434890310", "bodyText": "Agree we can drop internal package usages. will fix in rev2", "author": "shengxil", "createdAt": "2020-06-03T22:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2OTgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3MjUzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433572534", "bodyText": "We want our instrumentation to have as low an impact on user app's performance as possible so we should take care in optimizing especially parse logic.\nThis is probably the most optimized version\nhttps://github.com/openzipkin/zipkin-aws/blob/master/brave-propagation-aws/src/main/java/brave/propagation/aws/AWSExtractor.java#L72\nEven if that's too complex, we can still get a lot of improvement by avoiding .split in favor of indexOf and substring, I don't think we need to use split at all here (the warning is valid :) )", "author": "anuraaga", "createdAt": "2020-06-02T01:28:47Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String[] parts = traceHeader.split(String.valueOf(TRACE_HEADER_DELIMITER));", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5NjQ5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434896496", "bodyText": "JDK has a specialized optimization on splitting by single character, which doesn't use regex. See SO post and JDK implementation. Hence I don't think changing to the extractor or substring will make noticeable performance improvement that worths the trade of readability.", "author": "shengxil", "createdAt": "2020-06-03T22:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3MjUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMjgzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434902831", "bodyText": "It's not about the regex but the allocation of an array is still significant, especially since we don't need it. On the flip side, the change in readability also shouldn't be significant.", "author": "anuraaga", "createdAt": "2020-06-03T22:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3MjUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NjIxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436186216", "bodyText": "Ok that makes sense. Fixing in rev3", "author": "shengxil", "createdAt": "2020-06-05T22:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3MjUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3MjYxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433572610", "bodyText": "When avoiding split we should also inline the key/value parse here to avoid allocating arrays", "author": "anuraaga", "createdAt": "2020-06-02T01:29:07Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String[] parts = traceHeader.split(String.valueOf(TRACE_HEADER_DELIMITER));\n+      TraceId traceId = TraceId.getInvalid();\n+      SpanId spanId = SpanId.getInvalid();\n+      TraceFlags traceFlags = null;\n+\n+      for (String part : parts) {\n+        String[] keyAndValue = extractKeyAndValue(part);", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5NjQ4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434896483", "bodyText": "Same as above", "author": "shengxil", "createdAt": "2020-06-03T22:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3MjYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3Mjg4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433572882", "bodyText": "Think we can put them in tracestate, related to above comment. We should do both or neither though not just one.", "author": "anuraaga", "createdAt": "2020-06-02T01:30:09Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String[] parts = traceHeader.split(String.valueOf(TRACE_HEADER_DELIMITER));\n+      TraceId traceId = TraceId.getInvalid();\n+      SpanId spanId = SpanId.getInvalid();\n+      TraceFlags traceFlags = null;\n+\n+      for (String part : parts) {\n+        String[] keyAndValue = extractKeyAndValue(part);\n+        if (keyAndValue == null) {\n+          continue;\n+        }\n+        String key = keyAndValue[0];\n+        String value = keyAndValue[1];\n+\n+        switch (key) {\n+          case TRACE_ID_KEY:\n+            traceId = parseTraceId(value);\n+            break;\n+          case PARENT_ID_KEY:\n+            spanId = parseSpanId(value);\n+            break;\n+          case SAMPLED_FLAG_KEY:\n+            traceFlags = parseTraceFlag(value);\n+            break;\n+          default:\n+            // Ignoring the arbitrary TraceHeader keys in OpenTelemetry", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5Njc4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434896788", "bodyText": "I'll put a TODO for now", "author": "shengxil", "createdAt": "2020-06-03T22:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3Mjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NDk3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433574976", "bodyText": "char flag = xraySampledFlag.charAt(0);\nif (flag == IS_SAMPLED)\netc", "author": "anuraaga", "createdAt": "2020-06-02T01:37:55Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String[] parts = traceHeader.split(String.valueOf(TRACE_HEADER_DELIMITER));\n+      TraceId traceId = TraceId.getInvalid();\n+      SpanId spanId = SpanId.getInvalid();\n+      TraceFlags traceFlags = null;\n+\n+      for (String part : parts) {\n+        String[] keyAndValue = extractKeyAndValue(part);\n+        if (keyAndValue == null) {\n+          continue;\n+        }\n+        String key = keyAndValue[0];\n+        String value = keyAndValue[1];\n+\n+        switch (key) {\n+          case TRACE_ID_KEY:\n+            traceId = parseTraceId(value);\n+            break;\n+          case PARENT_ID_KEY:\n+            spanId = parseSpanId(value);\n+            break;\n+          case SAMPLED_FLAG_KEY:\n+            traceFlags = parseTraceFlag(value);\n+            break;\n+          default:\n+            // Ignoring the arbitrary TraceHeader keys in OpenTelemetry\n+            break;\n+        }\n+      }\n+\n+      if (!traceId.isValid()) {\n+        logger.info(\n+            \"Invalid TraceId in X-Ray trace header: '\"\n+                + TRACE_HEADER_KEY\n+                + \"' with value \"\n+                + traceHeader\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      if (!spanId.isValid()) {\n+        logger.info(\n+            \"Invalid ParentId in X-Ray trace header: '\"\n+                + TRACE_HEADER_KEY\n+                + \"' with value \"\n+                + traceHeader\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      return SpanContext\n+          .createFromRemoteParent(traceId, spanId, traceFlags, TraceState.getDefault());\n+    } catch (Exception e) {\n+      logger.log(Level.INFO, \"Error parsing X-Ray trace header. \"\n+          + \"Returning INVALID span context.\", e);\n+      return SpanContext.getInvalid();\n+    }\n+  }\n+\n+  @Nullable\n+  private static String[] extractKeyAndValue(String keyValueString) {\n+    keyValueString = keyValueString.trim();\n+    if (StringUtils.isNullOrEmpty(keyValueString)) {\n+      throw new IllegalArgumentException(\"Invalid key value pair: \" + keyValueString);\n+    }\n+\n+    String[] keyAndValue = keyValueString.split(String.valueOf(KV_DELIMITER));\n+    if (keyAndValue.length != 2) {\n+      throw new IllegalArgumentException(\"Invalid key value pair: \" + keyValueString);\n+    }\n+\n+    if (keyAndValue[0].isEmpty() || keyAndValue[1].isEmpty()) {\n+      throw new IllegalArgumentException(\"Invalid key value pair: \" + keyValueString);\n+    }\n+\n+    return keyAndValue;\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static TraceId parseTraceId(String xrayTraceId) {\n+    String[] parts = xrayTraceId.split(String.valueOf(TRACE_ID_DELIMITER));\n+    if (parts.length != 3) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    if (!parts[0].equals(TRACE_ID_VERSION) ||\n+        parts[1].length() != TRACE_ID_FIRST_PART_LENGTH ||\n+        parts[2].length() != TRACE_ID_SECOND_PART_LENGTH) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // X-Ray trace id format is 1-{8 digit hex}-{24 digit hex}\n+    return TraceId.fromLowerBase16(parts[1] + parts[2], 0);\n+  }\n+\n+  private static SpanId parseSpanId(String xrayParentId) {\n+    if (xrayParentId.length() != PARENT_ID_LENGTH) {\n+      return SpanId.getInvalid();\n+    }\n+\n+    return SpanId.fromLowerBase16(xrayParentId, 0);\n+  }\n+\n+  private static TraceFlags parseTraceFlag(String xraySampledFlag) {\n+    if (xraySampledFlag.length() != SAMPLED_FLAG_LENGTH) {\n+      throw new IllegalArgumentException(\"Invalid Sampling flag: \" + xraySampledFlag);\n+    }\n+", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5NzcwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434897702", "bodyText": "Will fix in rev2. But I want to keep the length check since Sampled=123 is invalid in X-Ray context.", "author": "shengxil", "createdAt": "2020-06-03T22:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NDk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3Njk0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433576945", "bodyText": "I'd inline the strings, or have constants for the various forms. It's more readable and avoids the issue of now we need a test for this test helper.", "author": "anuraaga", "createdAt": "2020-06-02T01:45:39Z", "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMjY3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434902679", "bodyText": "Will fix in rev2.", "author": "shengxil", "createdAt": "2020-06-03T22:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3Njk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NzY1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433577654", "bodyText": "This test doesn't seem to reflect reality and I don't think it actually verifies anything. We've already verified in our other tests that carrier is passed to the setter. So I think we can remove the test.", "author": "anuraaga", "createdAt": "2020-06-02T01:48:34Z", "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        new Setter<Map<String, String>>() {\n+          @Override\n+          public void set(Map<String, String> ignored, String key, String value) {", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMTIwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434901201", "bodyText": "Will remove in rev2.", "author": "shengxil", "createdAt": "2020-06-03T22:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NzY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODE0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433578145", "bodyText": "Nit I'd put the success cases above the error cases.", "author": "anuraaga", "createdAt": "2020-06-02T01:50:28Z", "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        new Setter<Map<String, String>>() {\n+          @Override\n+          public void set(Map<String, String> ignored, String key, String value) {\n+            carrier.put(key, value);\n+          }\n+        });\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"0\"));\n+  }\n+\n+  @Test\n+  public void extract_EmptyHeaderValue() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_NotEnoughParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_TooManyParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc:dd:ee\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            \"abcdefghijklmnopabcdefghijklmnop\", SPAN_ID_BASE16, \"0\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16 + \"00\", SPAN_ID_BASE16, \"0\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16, \"abcdefghijklmnop\", \"0\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16, SPAN_ID_BASE16 + \"00\", \"0\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(TRACE_ID_BASE16, SPAN_ID_BASE16, \"\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16, SPAN_ID_BASE16, \"10220\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags_NonNumeric() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16, SPAN_ID_BASE16, \"abcdefr\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_SampledContext() {", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMTE5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434901192", "bodyText": "Will fix in rev2.", "author": "shengxil", "createdAt": "2020-06-03T22:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODM1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433578358", "bodyText": "Here especially, don't use a helper method or even a constant, inlining the header will make much more readable what the test is checking.", "author": "anuraaga", "createdAt": "2020-06-02T01:51:20Z", "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        new Setter<Map<String, String>>() {\n+          @Override\n+          public void set(Map<String, String> ignored, String key, String value) {\n+            carrier.put(key, value);\n+          }\n+        });\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"0\"));\n+  }\n+\n+  @Test\n+  public void extract_EmptyHeaderValue() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_NotEnoughParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_TooManyParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc:dd:ee\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMTU0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r434901548", "bodyText": "will fix in rev2", "author": "shengxil", "createdAt": "2020-06-03T22:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODY1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433578654", "bodyText": "I think these two tests are supposed to use semicolon instead of colon.", "author": "anuraaga", "createdAt": "2020-06-02T01:52:31Z", "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        new Setter<Map<String, String>>() {\n+          @Override\n+          public void set(Map<String, String> ignored, String key, String value) {\n+            carrier.put(key, value);\n+          }\n+        });\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"0\"));\n+  }\n+\n+  @Test\n+  public void extract_EmptyHeaderValue() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_NotEnoughParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc\");", "originalCommit": "aa348632a26dcdd8f734835f2043f4fbb51da52c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NDc1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r435584756", "bodyText": "The tests are actually invalid. They are copied from B3Propagator tests. I'll remove them.", "author": "shengxil", "createdAt": "2020-06-04T22:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyODcxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r435028713", "bodyText": "I agree with aligning with the other propagators in behavior, like the NPE behavior, but we don't need to copy the implementation details if they can be better. The default propagator has this pattern since it initially had a bug where valid wasn't checked and that was tacked on, but it should have been cleaner. Let's be clean here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Span span = TracingContextUtils.getSpanWithoutDefault(context);\n          \n          \n            \n                if (span == null || !span.getContext().isValid()) {\n          \n          \n            \n                Span span = TracingContextUtils.getSpan(context);\n          \n          \n            \n                if (!span.getContext().isValid()) {", "author": "anuraaga", "createdAt": "2020-06-04T06:50:39Z", "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See\n+ *\n+ * <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>\n+ *\n+ * .\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null || !span.getContext().isValid()) {", "originalCommit": "24ac33119453937bc530fb51347ed61319c8d7df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0Mjk2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437042961", "bodyText": "will fix", "author": "shengxil", "createdAt": "2020-06-08T22:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyODcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzA3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233079", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n          \n          \n            \n             *     .addHttpTextFormat(new AWSXRayPropagator())\n          \n          \n            \n                   .build());", "author": "anuraaga", "createdAt": "2020-06-06T03:23:34Z", "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());", "originalCommit": "251a2db38077303f70ee0061fd9861db142d00e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0Mjk1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437042954", "bodyText": "will fix", "author": "shengxil", "createdAt": "2020-06-08T22:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzM3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233375", "bodyText": "Cool", "author": "anuraaga", "createdAt": "2020-06-06T03:28:13Z", "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final char TRACE_ID_LENGTH = 35;\n+  private static final char TRACE_ID_VERSION = '1';\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_DELIMITER_INDEX_1 = 1;\n+  private static final int TRACE_ID_DELIMITER_INDEX_2 = 10;\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null || !span.getContext().isValid()) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId =\n+        String.valueOf(TRACE_ID_VERSION)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+    // TODO: Add OT trace state to the X-Ray trace header\n+\n+    String traceHeader =\n+        TRACE_ID_KEY\n+            + KV_DELIMITER\n+            + xrayTraceId\n+            + TRACE_HEADER_DELIMITER\n+            + PARENT_ID_KEY\n+            + KV_DELIMITER\n+            + parentId\n+            + TRACE_HEADER_DELIMITER\n+            + SAMPLED_FLAG_KEY\n+            + KV_DELIMITER\n+            + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    Objects.requireNonNull(carrier, \"carrier\");\n+    Objects.requireNonNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+    if (Strings.isNullOrEmpty(traceHeader)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    TraceId traceId = TraceId.getInvalid();\n+    SpanId spanId = SpanId.getInvalid();\n+    TraceFlags traceFlags = TraceFlags.getDefault();\n+\n+    int pos = 0;\n+    while (pos < traceHeader.length()) {\n+      int delimiterIndex = traceHeader.indexOf(TRACE_HEADER_DELIMITER, pos);\n+      final String part;\n+      if (delimiterIndex >= 0) {\n+        part = traceHeader.substring(pos, delimiterIndex);\n+        pos = delimiterIndex + 1;\n+      } else {\n+        // Last part.\n+        part = traceHeader.substring(pos);\n+        pos = traceHeader.length();\n+      }\n+      String trimmedPart = part.trim();\n+      int equalsIndex = trimmedPart.indexOf(KV_DELIMITER);\n+      if (equalsIndex < 0) {\n+        logger.info(\n+            \"Error parsing X-Ray trace header. Invalid key value pair: \"\n+                + part\n+                + \" Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String value = trimmedPart.substring(equalsIndex + 1);\n+\n+      if (trimmedPart.startsWith(TRACE_ID_KEY)) {\n+        traceId = parseTraceId(value);\n+      } else if (trimmedPart.startsWith(PARENT_ID_KEY)) {\n+        spanId = parseSpanId(value);\n+      } else if (trimmedPart.startsWith(SAMPLED_FLAG_KEY)) {\n+        traceFlags = parseTraceFlag(value);\n+      }\n+      // TODO: Put the arbitrary TraceHeader keys in OT trace state\n+    }\n+\n+    if (!traceId.isValid()) {\n+      logger.info(\n+          \"Invalid TraceId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (!spanId.isValid()) {\n+      logger.info(\n+          \"Invalid ParentId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (traceFlags == null) {\n+      logger.info(\n+          \"Invalid Sampling flag in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    return SpanContext.createFromRemoteParent(traceId, spanId, traceFlags, TraceState.getDefault());\n+  }\n+\n+  private static TraceId parseTraceId(String xrayTraceId) {\n+    if (xrayTraceId.length() != TRACE_ID_LENGTH) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check version trace id version\n+    if (xrayTraceId.charAt(0) != TRACE_ID_VERSION) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check delimiters", "originalCommit": "251a2db38077303f70ee0061fd9861db142d00e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzQ1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233454", "bodyText": "Recommend instead having inline constants for different types of trace headers, e.g.\nTRACE_HEADER_SAMPLED = \"Root=11241341413441;Parent=12312134;Sampled=1\"\nTRACE_HEADER_UNSAMPLED = \"Root=11241341413441;Parent=12312134;Sampled=0\"\nThere's some duplication, but since this is testdata, not business logic, doesn't really affect maintenance. But it has a nice benefit that anyone, including people not familiar with X-Ray, can easily see what an X-Ray header is supposed to look like.", "author": "anuraaga", "createdAt": "2020-06-06T03:29:54Z", "path": "contrib/trace_propagators/src/test/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.contrib.trace.propagation.AwsXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AwsXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String TRACE_ID_XRAY =\n+      \"1-\" + TRACE_ID_BASE16.substring(0, 8) + \"-\" + TRACE_ID_BASE16.substring(8);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG =\n+      TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AwsXRayPropagator xrayPropagator = new AwsXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");", "originalCommit": "251a2db38077303f70ee0061fd9861db142d00e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0Mjg2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437042865", "bodyText": "ok that's fair. will fix", "author": "shengxil", "createdAt": "2020-06-08T22:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzU1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233552", "bodyText": "Couple more test cases\n\nValid header with keys in different oder\nValid header with additional params. We strip this right now but need to make sure this propagator can read any valid header", "author": "anuraaga", "createdAt": "2020-06-06T03:31:21Z", "path": "contrib/trace_propagators/src/test/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.contrib.trace.propagation.AwsXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AwsXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String TRACE_ID_XRAY =\n+      \"1-\" + TRACE_ID_BASE16.substring(0, 8) + \"-\" + TRACE_ID_BASE16.substring(8);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG =\n+      TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AwsXRayPropagator xrayPropagator = new AwsXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+  }\n+\n+  @Test\n+  public void extract_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_NotSampledContext() {", "originalCommit": "251a2db38077303f70ee0061fd9861db142d00e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MDc1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436240757", "bodyText": "Ah can we also add a test where we inject and there's some trace state? Documents that we ignore for now and will give a target to update when actually implementing it.", "author": "anuraaga", "createdAt": "2020-06-06T05:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0Mjg3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437042872", "bodyText": "Sure, will add those tests", "author": "shengxil", "createdAt": "2020-06-08T22:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzY0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233645", "bodyText": "Isn't this branch an invalid header?", "author": "anuraaga", "createdAt": "2020-06-06T03:33:08Z", "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final char TRACE_ID_LENGTH = 35;\n+  private static final char TRACE_ID_VERSION = '1';\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_DELIMITER_INDEX_1 = 1;\n+  private static final int TRACE_ID_DELIMITER_INDEX_2 = 10;\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null || !span.getContext().isValid()) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId =\n+        String.valueOf(TRACE_ID_VERSION)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+    // TODO: Add OT trace state to the X-Ray trace header\n+\n+    String traceHeader =\n+        TRACE_ID_KEY\n+            + KV_DELIMITER\n+            + xrayTraceId\n+            + TRACE_HEADER_DELIMITER\n+            + PARENT_ID_KEY\n+            + KV_DELIMITER\n+            + parentId\n+            + TRACE_HEADER_DELIMITER\n+            + SAMPLED_FLAG_KEY\n+            + KV_DELIMITER\n+            + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    Objects.requireNonNull(carrier, \"carrier\");\n+    Objects.requireNonNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+    if (Strings.isNullOrEmpty(traceHeader)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    TraceId traceId = TraceId.getInvalid();\n+    SpanId spanId = SpanId.getInvalid();\n+    TraceFlags traceFlags = TraceFlags.getDefault();\n+\n+    int pos = 0;\n+    while (pos < traceHeader.length()) {\n+      int delimiterIndex = traceHeader.indexOf(TRACE_HEADER_DELIMITER, pos);\n+      final String part;\n+      if (delimiterIndex >= 0) {\n+        part = traceHeader.substring(pos, delimiterIndex);\n+        pos = delimiterIndex + 1;\n+      } else {\n+        // Last part.\n+        part = traceHeader.substring(pos);\n+        pos = traceHeader.length();\n+      }\n+      String trimmedPart = part.trim();\n+      int equalsIndex = trimmedPart.indexOf(KV_DELIMITER);\n+      if (equalsIndex < 0) {\n+        logger.info(\n+            \"Error parsing X-Ray trace header. Invalid key value pair: \"\n+                + part\n+                + \" Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String value = trimmedPart.substring(equalsIndex + 1);\n+\n+      if (trimmedPart.startsWith(TRACE_ID_KEY)) {\n+        traceId = parseTraceId(value);\n+      } else if (trimmedPart.startsWith(PARENT_ID_KEY)) {\n+        spanId = parseSpanId(value);\n+      } else if (trimmedPart.startsWith(SAMPLED_FLAG_KEY)) {\n+        traceFlags = parseTraceFlag(value);\n+      }\n+      // TODO: Put the arbitrary TraceHeader keys in OT trace state\n+    }\n+\n+    if (!traceId.isValid()) {\n+      logger.info(\n+          \"Invalid TraceId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (!spanId.isValid()) {\n+      logger.info(\n+          \"Invalid ParentId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (traceFlags == null) {\n+      logger.info(\n+          \"Invalid Sampling flag in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    return SpanContext.createFromRemoteParent(traceId, spanId, traceFlags, TraceState.getDefault());\n+  }\n+\n+  private static TraceId parseTraceId(String xrayTraceId) {\n+    if (xrayTraceId.length() != TRACE_ID_LENGTH) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check version trace id version\n+    if (xrayTraceId.charAt(0) != TRACE_ID_VERSION) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check delimiters\n+    if (xrayTraceId.charAt(TRACE_ID_DELIMITER_INDEX_1) != TRACE_ID_DELIMITER\n+        || xrayTraceId.charAt(TRACE_ID_DELIMITER_INDEX_2) != TRACE_ID_DELIMITER) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    String epochPart =\n+        xrayTraceId.substring(TRACE_ID_DELIMITER_INDEX_1 + 1, TRACE_ID_DELIMITER_INDEX_2);\n+    String uniquePart = xrayTraceId.substring(TRACE_ID_DELIMITER_INDEX_2 + 1, TRACE_ID_LENGTH);\n+\n+    try {\n+      // X-Ray trace id format is 1-{8 digit hex}-{24 digit hex}\n+      return TraceId.fromLowerBase16(epochPart + uniquePart, 0);\n+    } catch (Exception e) {\n+      return TraceId.getInvalid();\n+    }\n+  }\n+\n+  private static SpanId parseSpanId(String xrayParentId) {\n+    if (xrayParentId.length() != PARENT_ID_LENGTH) {\n+      return SpanId.getInvalid();\n+    }\n+\n+    try {\n+      return SpanId.fromLowerBase16(xrayParentId, 0);\n+    } catch (Exception e) {\n+      return SpanId.getInvalid();\n+    }\n+  }\n+\n+  @Nullable\n+  private static TraceFlags parseTraceFlag(String xraySampledFlag) {\n+    if (xraySampledFlag.length() != SAMPLED_FLAG_LENGTH) {\n+      // Returning null as there is no invalid trace flag defined.\n+      return null;\n+    }\n+\n+    char flag = xraySampledFlag.charAt(0);\n+    if (flag == IS_SAMPLED) {\n+      return TraceFlags.builder().setIsSampled(true).build();\n+    } else if (flag == NOT_SAMPLED) {\n+      return TraceFlags.builder().setIsSampled(false).build();\n+    } else {\n+      try {\n+        return TraceFlags.fromLowerBase16(xraySampledFlag, 0);", "originalCommit": "251a2db38077303f70ee0061fd9861db142d00e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MjgwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437042803", "bodyText": "Oops it should be.", "author": "shengxil", "createdAt": "2020-06-08T22:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0Mjg4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437042880", "bodyText": "Oops it should be.", "author": "shengxil", "createdAt": "2020-06-08T22:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzY5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233690", "bodyText": "I don't think this tests anything different from _Size. But having a test with one character that isn't 0 or 1 seems important", "author": "anuraaga", "createdAt": "2020-06-06T03:34:10Z", "path": "contrib/trace_propagators/src/test/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.contrib.trace.propagation.AwsXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AwsXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String TRACE_ID_XRAY =\n+      \"1-\" + TRACE_ID_BASE16.substring(0, 8) + \"-\" + TRACE_ID_BASE16.substring(8);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG =\n+      TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AwsXRayPropagator xrayPropagator = new AwsXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+  }\n+\n+  @Test\n+  public void extract_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_EmptyHeaderValue() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        \"Root=abcdefghijklmnopabcdefghijklmnop;Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        \"Root=\" + TRACE_ID_XRAY + \"00\" + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=abcdefghijklmnop;Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \"00\" + \";Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=10220\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags_NonNumeric() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=abcdefr\");", "originalCommit": "251a2db38077303f70ee0061fd9861db142d00e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0Mjg4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437042889", "bodyText": "will change to \"a\"", "author": "shengxil", "createdAt": "2020-06-08T22:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjA1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436422056", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final char TRACE_ID_LENGTH = 35;\n          \n          \n            \n              private static final int TRACE_ID_LENGTH = 35;", "author": "anuraaga", "createdAt": "2020-06-08T01:21:36Z", "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final char TRACE_ID_LENGTH = 35;", "originalCommit": "251a2db38077303f70ee0061fd9861db142d00e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MjkxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437042911", "bodyText": "will fix", "author": "shengxil", "createdAt": "2020-06-08T22:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MDI4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437740287", "bodyText": "If you made the TRACE_ID_VERSION a string, you could avoid the String.valueOf call above, and just use startsWith for this call. Might read a little cleaner in both cases.", "author": "jkwatson", "createdAt": "2020-06-09T21:45:11Z", "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator())\n+ *     .build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final int TRACE_ID_LENGTH = 35;\n+  private static final char TRACE_ID_VERSION = '1';\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_DELIMITER_INDEX_1 = 1;\n+  private static final int TRACE_ID_DELIMITER_INDEX_2 = 10;\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpan(context);\n+    if (!span.getContext().isValid()) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId =\n+        String.valueOf(TRACE_ID_VERSION)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+    // TODO: Add OT trace state to the X-Ray trace header\n+\n+    String traceHeader =\n+        TRACE_ID_KEY\n+            + KV_DELIMITER\n+            + xrayTraceId\n+            + TRACE_HEADER_DELIMITER\n+            + PARENT_ID_KEY\n+            + KV_DELIMITER\n+            + parentId\n+            + TRACE_HEADER_DELIMITER\n+            + SAMPLED_FLAG_KEY\n+            + KV_DELIMITER\n+            + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    Objects.requireNonNull(carrier, \"carrier\");\n+    Objects.requireNonNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+    if (Strings.isNullOrEmpty(traceHeader)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    TraceId traceId = TraceId.getInvalid();\n+    SpanId spanId = SpanId.getInvalid();\n+    TraceFlags traceFlags = TraceFlags.getDefault();\n+\n+    int pos = 0;\n+    while (pos < traceHeader.length()) {\n+      int delimiterIndex = traceHeader.indexOf(TRACE_HEADER_DELIMITER, pos);\n+      final String part;\n+      if (delimiterIndex >= 0) {\n+        part = traceHeader.substring(pos, delimiterIndex);\n+        pos = delimiterIndex + 1;\n+      } else {\n+        // Last part.\n+        part = traceHeader.substring(pos);\n+        pos = traceHeader.length();\n+      }\n+      String trimmedPart = part.trim();\n+      int equalsIndex = trimmedPart.indexOf(KV_DELIMITER);\n+      if (equalsIndex < 0) {\n+        logger.info(\n+            \"Error parsing X-Ray trace header. Invalid key value pair: \"\n+                + part\n+                + \" Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String value = trimmedPart.substring(equalsIndex + 1);\n+\n+      if (trimmedPart.startsWith(TRACE_ID_KEY)) {\n+        traceId = parseTraceId(value);\n+      } else if (trimmedPart.startsWith(PARENT_ID_KEY)) {\n+        spanId = parseSpanId(value);\n+      } else if (trimmedPart.startsWith(SAMPLED_FLAG_KEY)) {\n+        traceFlags = parseTraceFlag(value);\n+      }\n+      // TODO: Put the arbitrary TraceHeader keys in OT trace state\n+    }\n+\n+    if (!traceId.isValid()) {\n+      logger.info(\n+          \"Invalid TraceId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (!spanId.isValid()) {\n+      logger.info(\n+          \"Invalid ParentId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (traceFlags == null) {\n+      logger.info(\n+          \"Invalid Sampling flag in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    return SpanContext.createFromRemoteParent(traceId, spanId, traceFlags, TraceState.getDefault());\n+  }\n+\n+  private static TraceId parseTraceId(String xrayTraceId) {\n+    if (xrayTraceId.length() != TRACE_ID_LENGTH) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check version trace id version\n+    if (xrayTraceId.charAt(0) != TRACE_ID_VERSION) {", "originalCommit": "6f9491783f0e41f1acc9d7a7ae2e12c777253d1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/43f42068d2aeea5639b357c4f1e6a291aed4c120", "message": "Add AWS X-Ray propagator", "committedDate": "2020-06-09T23:51:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTczMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437849732", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n          \n          \n            \n              // Visible for testing\n          \n          \n            \n              static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";", "author": "anuraaga", "createdAt": "2020-06-10T04:13:49Z", "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator())\n+ *     .build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";", "originalCommit": "43f42068d2aeea5639b357c4f1e6a291aed4c120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTk5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437849991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Strings.isNullOrEmpty(traceHeader)) {\n          \n          \n            \n                if (traceHeader == null || traceHeader.isEmpty()) {\n          \n      \n    \n    \n  \n\nFor just this one line I guess we may as well inline this rather than worry about guava or helper methods etc. Alternatively, we don't really need the empty check as an empty string is invalid and will always work with our below logic but it'd be somewhat less optimal. Not sure if a getter will return empty strings often enough for us to worry about it though.", "author": "anuraaga", "createdAt": "2020-06-10T04:15:04Z", "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator())\n+ *     .build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final int TRACE_ID_LENGTH = 35;\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_DELIMITER_INDEX_1 = 1;\n+  private static final int TRACE_ID_DELIMITER_INDEX_2 = 10;\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpan(context);\n+    if (!span.getContext().isValid()) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId =\n+        TRACE_ID_VERSION\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+    // TODO: Add OT trace state to the X-Ray trace header\n+\n+    String traceHeader =\n+        TRACE_ID_KEY\n+            + KV_DELIMITER\n+            + xrayTraceId\n+            + TRACE_HEADER_DELIMITER\n+            + PARENT_ID_KEY\n+            + KV_DELIMITER\n+            + parentId\n+            + TRACE_HEADER_DELIMITER\n+            + SAMPLED_FLAG_KEY\n+            + KV_DELIMITER\n+            + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    Objects.requireNonNull(carrier, \"carrier\");\n+    Objects.requireNonNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+    if (Strings.isNullOrEmpty(traceHeader)) {", "originalCommit": "43f42068d2aeea5639b357c4f1e6a291aed4c120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MDc1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437850754", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.google.common.annotations.VisibleForTesting;\n          \n          \n            \n            import com.google.common.base.Strings;", "author": "anuraaga", "createdAt": "2020-06-10T04:18:25Z", "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;", "originalCommit": "43f42068d2aeea5639b357c4f1e6a291aed4c120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "18be88b9cd084ed330a4cc099af5d780d327b7cb", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/18be88b9cd084ed330a4cc099af5d780d327b7cb", "message": "Add AWS X-Ray propagator", "committedDate": "2020-06-10T18:35:38Z", "type": "commit"}, {"oid": "18be88b9cd084ed330a4cc099af5d780d327b7cb", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/18be88b9cd084ed330a4cc099af5d780d327b7cb", "message": "Add AWS X-Ray propagator", "committedDate": "2020-06-10T18:35:38Z", "type": "forcePushed"}]}