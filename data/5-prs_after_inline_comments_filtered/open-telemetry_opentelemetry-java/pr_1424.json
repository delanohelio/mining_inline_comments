{"pr_number": 1424, "pr_title": "Added unit tests for SpanBucket", "pr_createdAt": "2020-07-16T18:29:44Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424", "timeline": [{"oid": "a7c750e392ea0f2ad58ca4e7337d29f7f167259a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a7c750e392ea0f2ad58ca4e7337d29f7f167259a", "message": "Added unit tests for SpanBucket", "committedDate": "2020-07-16T17:33:38Z", "type": "commit"}, {"oid": "62f9dfbd11770b14ab425d2ca7baf0bd7efd0420", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/62f9dfbd11770b14ab425d2ca7baf0bd7efd0420", "message": "Included a comment to make the last test more clear", "committedDate": "2020-07-16T18:10:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0NjU3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456046578", "bodyText": "shouldn't we wait on the countDownLatch before starting the work? Right now, the latch isn't being used to ensure concurrency at all.", "author": "jkwatson", "createdAt": "2020-07-16T20:06:10Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    final int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch countDownLatch = new CountDownLatch(numberOfThreads);\n+    List<Thread> workers = new ArrayList<>();\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      workers.add(\n+          new Thread(\n+              () -> {\n+                for (int j = 0; j < numberOfSpans; j++) {", "originalCommit": "62f9dfbd11770b14ab425d2ca7baf0bd7efd0420", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMTY4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456121683", "bodyText": "Yeah, sorry about that! I was basing the implementation off another OTel class. I've updated the test to ensure checking for concurrency.", "author": "williamhu99", "createdAt": "2020-07-16T22:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0NjU3OA=="}], "type": "inlineReview"}, {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/14ccbcce2d5d452552e9ceff407059258f248b3e", "message": "Rewrote the concurrency test", "committedDate": "2020-07-16T22:50:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456122362", "bodyText": "I don't know if this line would ever be visible inside a background thread.", "author": "jkwatson", "createdAt": "2020-07-16T22:53:57Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();\n+                } catch (InterruptedException e) {\n+                  Assert.fail(e.getMessage());", "originalCommit": "14ccbcce2d5d452552e9ceff407059258f248b3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyNDE3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456124171", "bodyText": "Would logging the exception be better?", "author": "williamhu99", "createdAt": "2020-07-16T22:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyNDYxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456124610", "bodyText": "can you test out what happens if the exception gets thrown in the method? It might work the way you expect; I'm not sure how junit deals with this case.", "author": "jkwatson", "createdAt": "2020-07-16T23:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyNjQwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456126407", "bodyText": "The assertion doesn't seem to do anything. The test continues and eventually times out.", "author": "williamhu99", "createdAt": "2020-07-16T23:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTk5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456135998", "bodyText": "I just replaced the assert with a return statement. The test should fail from time limit or a lack of enough spans if anything does go wrong.", "author": "williamhu99", "createdAt": "2020-07-16T23:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjU4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456122582", "bodyText": "because we're relying on this, we should put a timeout on the test annotation, just in case things go badly awry. That way, we won't hang indefinitely waiting for things to finish.", "author": "jkwatson", "createdAt": "2020-07-16T22:54:31Z", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();", "originalCommit": "14ccbcce2d5d452552e9ceff407059258f248b3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "612f851266d6dc1c21936e40a65e9d4881509596", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/612f851266d6dc1c21936e40a65e9d4881509596", "message": "Removed assertion from exception and added a time limit for the concurrency test case", "committedDate": "2020-07-16T23:35:34Z", "type": "commit"}]}