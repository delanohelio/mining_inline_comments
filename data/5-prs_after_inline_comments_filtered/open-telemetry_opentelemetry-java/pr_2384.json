{"pr_number": 2384, "pr_title": "Remove AbstractBoundInstrument, move mapping logic to Aggregator", "pr_createdAt": "2020-12-22T01:05:22Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/2384", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQxMjUwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2384#discussion_r547412502", "bodyText": "tiny nit: might rename this variable to boundAggregator", "author": "jkwatson", "createdAt": "2020-12-22T17:44:05Z", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/SynchronousInstrumentAccumulator.java", "diffHunk": "@@ -14,45 +14,41 @@\n import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantLock;\n-import java.util.function.Function;\n \n-final class SynchronousInstrumentAccumulator<B extends AbstractBoundInstrument> {\n-  private final ConcurrentHashMap<Labels, B> boundLabels;\n+final class SynchronousInstrumentAccumulator {\n+  private final ConcurrentHashMap<Labels, Aggregator> aggregatorLabels;\n   private final ReentrantLock collectLock;\n   private final InstrumentProcessor instrumentProcessor;\n-  private final Function<Aggregator, B> boundFactory;\n \n-  SynchronousInstrumentAccumulator(\n-      InstrumentProcessor instrumentProcessor, Function<Aggregator, B> boundFactory) {\n-    this.boundFactory = boundFactory;\n-    boundLabels = new ConcurrentHashMap<>();\n+  SynchronousInstrumentAccumulator(InstrumentProcessor instrumentProcessor) {\n+    aggregatorLabels = new ConcurrentHashMap<>();\n     collectLock = new ReentrantLock();\n     this.instrumentProcessor = instrumentProcessor;\n   }\n \n-  public B bind(Labels labels) {\n+  Aggregator bind(Labels labels) {\n     Objects.requireNonNull(labels, \"labels\");\n-    B binding = boundLabels.get(labels);\n-    if (binding != null && binding.bind()) {\n+    Aggregator aggregator = aggregatorLabels.get(labels);\n+    if (aggregator != null && aggregator.acquire()) {\n       // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n-      return binding;\n+      return aggregator;\n     }\n \n     // Missing entry or no longer mapped, try to add a new entry.\n-    binding = boundFactory.apply(instrumentProcessor.getAggregator());\n+    aggregator = instrumentProcessor.getAggregator();\n     while (true) {\n-      B oldBound = boundLabels.putIfAbsent(labels, binding);\n+      Aggregator oldBound = aggregatorLabels.putIfAbsent(labels, aggregator);", "originalCommit": "6ace95bac3ec54cbd46a10d8a2ed70a47fdf77d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQzNDAxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2384#discussion_r547434014", "bodyText": "Done.", "author": "bogdandrutu", "createdAt": "2020-12-22T18:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQxMjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQxNTAzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2384#discussion_r547415039", "bodyText": "could we add a verification that there is nothing bound at this point? Not sure if that would require dipping into the internals, but it seems like a valuable assertion to be able to make.", "author": "jkwatson", "createdAt": "2020-12-22T17:49:03Z", "path": "sdk/metrics/src/test/java/io/opentelemetry/sdk/metrics/SynchronousInstrumentAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.metrics.aggregation.Aggregations;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentDescriptor;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n+import io.opentelemetry.sdk.resources.Resource;\n+import org.junit.jupiter.api.Test;\n+\n+public class SynchronousInstrumentAccumulatorTest {\n+  private static final InstrumentDescriptor DESCRIPTOR =\n+      InstrumentDescriptor.create(\n+          \"name\", \"description\", \"unit\", InstrumentType.COUNTER, InstrumentValueType.DOUBLE);\n+  private final MeterProviderSharedState providerSharedState =\n+      MeterProviderSharedState.create(TestClock.create(), Resource.getEmpty());\n+  private final MeterSharedState meterSharedState =\n+      MeterSharedState.create(InstrumentationLibraryInfo.create(\"test\", \"1.0\"));\n+\n+  @Test\n+  void sameAggregator_ForSameLabelSet() {\n+    SynchronousInstrumentAccumulator accumulator =\n+        new SynchronousInstrumentAccumulator(\n+            InstrumentProcessor.getCumulativeAllLabels(\n+                DESCRIPTOR, providerSharedState, meterSharedState, Aggregations.count()));\n+    Aggregator aggregator = accumulator.bind(Labels.of(\"K\", \"V\"));\n+    Aggregator duplicateAggregator = accumulator.bind(Labels.of(\"K\", \"V\"));\n+    try {\n+      assertThat(duplicateAggregator).isSameAs(aggregator);\n+      accumulator.collectAll();\n+      Aggregator anotherDuplicateAggregator = accumulator.bind(Labels.of(\"K\", \"V\"));\n+      try {\n+        assertThat(anotherDuplicateAggregator).isEqualTo(aggregator);\n+      } finally {\n+        anotherDuplicateAggregator.release();\n+      }\n+    } finally {\n+      aggregator.release();\n+      aggregator.release();", "originalCommit": "6ace95bac3ec54cbd46a10d8a2ed70a47fdf77d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQzNzQyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2384#discussion_r547437427", "bodyText": "So it is a bit of logic implied here. But because all of them are same instance based on the assertions in the test, just trying to unmap will confirm that the aggregator is no longer referenced (in use). This will unfortunately get a bit into internals and calling collectAll will not work anymore after this, but for testing is good enough.", "author": "bogdandrutu", "createdAt": "2020-12-22T18:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQxNTAzOQ=="}], "type": "inlineReview"}, {"oid": "6d7064ca345ad841ff7b8b41124ae7f0b0b2b46d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6d7064ca345ad841ff7b8b41124ae7f0b0b2b46d", "message": "Remove AbstractBoundInstrument, move mapping logic to Aggregator\n\nRemove one allocation when calling instruments without bounds.\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-22T18:19:39Z", "type": "commit"}, {"oid": "3d626d6837348cf905070b12b3afc61773904840", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3d626d6837348cf905070b12b3afc61773904840", "message": "Fix review comments\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-22T18:30:05Z", "type": "commit"}, {"oid": "3d626d6837348cf905070b12b3afc61773904840", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3d626d6837348cf905070b12b3afc61773904840", "message": "Fix review comments\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-22T18:30:05Z", "type": "forcePushed"}]}