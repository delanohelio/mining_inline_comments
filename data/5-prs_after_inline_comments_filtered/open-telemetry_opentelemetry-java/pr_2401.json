{"pr_number": 2401, "pr_title": "Add autoconfiguration wrapper artifact", "pr_createdAt": "2020-12-23T08:40:00Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401", "timeline": [{"oid": "ba20433307b8a4a61757a7c3c329d5209457dea2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ba20433307b8a4a61757a7c3c329d5209457dea2", "message": "Add autoconfiguration wrapper artifact", "committedDate": "2020-12-23T08:38:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzgxMjIxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r547812217", "bodyText": "Will need to add linkage error guards to return better error messages for when a configuration option is set but implementation not available.", "author": "anuraaga", "createdAt": "2020-12-23T08:41:23Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/OpenTelemetrySdkAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.api.baggage.propagation.W3CBaggagePropagator;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.common.AttributesBuilder;\n+import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;\n+import io.opentelemetry.context.propagation.ContextPropagators;\n+import io.opentelemetry.context.propagation.TextMapPropagator;\n+import io.opentelemetry.exporter.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporter.jaeger.JaegerGrpcSpanExporterBuilder;\n+import io.opentelemetry.exporter.jaeger.thrift.JaegerThriftSpanExporter;\n+import io.opentelemetry.exporter.jaeger.thrift.JaegerThriftSpanExporterBuilder;\n+import io.opentelemetry.exporter.logging.LoggingSpanExporter;\n+import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporter;\n+import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporterBuilder;\n+import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporter;\n+import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporterBuilder;\n+import io.opentelemetry.exporter.prometheus.PrometheusCollector;\n+import io.opentelemetry.exporter.zipkin.ZipkinSpanExporter;\n+import io.opentelemetry.exporter.zipkin.ZipkinSpanExporterBuilder;\n+import io.opentelemetry.extension.trace.propagation.AwsXRayPropagator;\n+import io.opentelemetry.extension.trace.propagation.B3Propagator;\n+import io.opentelemetry.extension.trace.propagation.JaegerPropagator;\n+import io.opentelemetry.extension.trace.propagation.OtTracerPropagator;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.autoconfigure.spi.SdkMeterProviderConfigurer;\n+import io.opentelemetry.sdk.autoconfigure.spi.SdkTracerProviderConfigurer;\n+import io.opentelemetry.sdk.metrics.SdkMeterProvider;\n+import io.opentelemetry.sdk.metrics.SdkMeterProviderBuilder;\n+import io.opentelemetry.sdk.metrics.export.IntervalMetricReader;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.SdkTracerProvider;\n+import io.opentelemetry.sdk.trace.SdkTracerProviderBuilder;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.config.TraceConfig;\n+import io.opentelemetry.sdk.trace.config.TraceConfigBuilder;\n+import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;\n+import io.opentelemetry.sdk.trace.export.BatchSpanProcessorBuilder;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.sdk.trace.samplers.Sampler;\n+import io.prometheus.client.exporter.HTTPServer;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.ServiceLoader;\n+\n+public final class OpenTelemetrySdkAutoConfiguration {\n+\n+  public static OpenTelemetrySdk initialize() {\n+    ConfigProperties config = ConfigProperties.get();\n+\n+    AttributesBuilder resourceAttributes = Attributes.builder();\n+    config.getCommaSeparatedMap(\"otel.resource.attributes\").forEach(resourceAttributes::put);\n+    Resource resource = Resource.getDefault().merge(Resource.create(resourceAttributes.build()));\n+\n+    SdkMeterProviderBuilder meterProviderBuilder = SdkMeterProvider.builder().setResource(resource);\n+    for (SdkMeterProviderConfigurer configurer :\n+        ServiceLoader.load(SdkMeterProviderConfigurer.class)) {\n+      configurer.configure(meterProviderBuilder);\n+    }\n+    SdkMeterProvider meterProvider = meterProviderBuilder.build();\n+\n+    List<String> exporterNames = config.getCommaSeparatedValues(\"otel.exporter\");\n+    boolean metricsConfigured = false;\n+    for (String exporterName : exporterNames) {\n+      exporterName = exporterName.toLowerCase(Locale.ROOT);\n+      switch (exporterName) {\n+        case \"otlp\":\n+        case \"otlp_metrics\":\n+          if (metricsConfigured) {\n+            throw new IllegalStateException(\n+                \"Multiple metrics exporters configured. Only one metrics exporter can be \"\n+                    + \"configured at a time.\");\n+          }\n+          configureOtlpMetrics(config, meterProvider);\n+          metricsConfigured = true;\n+          break;\n+        case \"prometheus\":\n+          if (metricsConfigured) {\n+            throw new IllegalStateException(\n+                \"Multiple metrics exporters configured. Only one metrics exporter can be \"\n+                    + \"configured at a time.\");\n+          }\n+          configurePrometheusMetrics(config, meterProvider);\n+          metricsConfigured = true;\n+          break;\n+        default:\n+          // Ignore\n+      }\n+    }\n+\n+    SdkTracerProviderBuilder tracerProviderBuilder =\n+        SdkTracerProvider.builder()\n+            .setResource(resource)\n+            .setTraceConfig(configureTraceConfig(config));\n+\n+    List<SpanExporter> spanExporters = new ArrayList<>();\n+    for (String exporterName : exporterNames) {\n+      exporterName = exporterName.toLowerCase(Locale.ROOT);\n+      switch (exporterName) {\n+        case \"otlp\":\n+        case \"otlp_span\":\n+          spanExporters.add(configureOtlpSpans(config));\n+          break;\n+        case \"jaeger\":\n+          spanExporters.add(configureJaeger(config));\n+          break;\n+        case \"jaeger-thrift\":\n+          spanExporters.add(configureJaegerThrift(config));\n+          break;\n+        case \"zipkin\":\n+          spanExporters.add(configureZipkin(config));\n+          break;\n+        case \"logging\":\n+          spanExporters.add(new LoggingSpanExporter());\n+          break;\n+        default:\n+          // Ignore\n+      }\n+    }\n+\n+    if (!spanExporters.isEmpty()) {\n+      tracerProviderBuilder.addSpanProcessor(configureSpanProcessor(config, spanExporters));\n+    }\n+\n+    for (SdkTracerProviderConfigurer configurer :\n+        ServiceLoader.load(SdkTracerProviderConfigurer.class)) {\n+      configurer.configure(tracerProviderBuilder);\n+    }\n+\n+    List<TextMapPropagator> propagators = new ArrayList<>();\n+    for (String propagatorName : config.getCommaSeparatedValues(\"otel.propagators\")) {\n+      switch (propagatorName) {\n+        case \"tracecontext\":\n+          propagators.add(W3CTraceContextPropagator.getInstance());\n+          break;\n+        case \"baggage\":\n+          propagators.add(W3CBaggagePropagator.getInstance());\n+          break;\n+        case \"b3\":\n+          propagators.add(B3Propagator.getInstance());\n+          break;\n+        case \"b3multi\":\n+          propagators.add(B3Propagator.builder().injectMultipleHeaders().build());\n+          break;\n+        case \"jaeger\":\n+          propagators.add(JaegerPropagator.getInstance());\n+          break;\n+        case \"ottracer\":\n+          propagators.add(OtTracerPropagator.getInstance());\n+          break;\n+        case \"xray\":\n+          propagators.add(AwsXRayPropagator.getInstance());\n+          break;\n+        default:\n+          // Ignore\n+      }\n+    }\n+\n+    return OpenTelemetrySdk.builder()\n+        .setTracerProvider(tracerProviderBuilder.build())\n+        .setPropagators(ContextPropagators.create(TextMapPropagator.composite(propagators)))\n+        .build();\n+  }\n+\n+  private static void configureOtlpMetrics(\n+      ConfigProperties config, SdkMeterProvider meterProvider) {\n+    OtlpGrpcMetricExporterBuilder builder = OtlpGrpcMetricExporter.builder();", "originalCommit": "ba20433307b8a4a61757a7c3c329d5209457dea2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2OTU1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r548069556", "bodyText": "I think I'd break each of these methods out into their own class so it's clear how to add new ones to the auto-config, rather than having to dig into this beast to find them. :)", "author": "jkwatson", "createdAt": "2020-12-23T17:27:18Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/OpenTelemetrySdkAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.api.baggage.propagation.W3CBaggagePropagator;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.common.AttributesBuilder;\n+import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;\n+import io.opentelemetry.context.propagation.ContextPropagators;\n+import io.opentelemetry.context.propagation.TextMapPropagator;\n+import io.opentelemetry.exporter.jaeger.JaegerGrpcSpanExporter;\n+import io.opentelemetry.exporter.jaeger.JaegerGrpcSpanExporterBuilder;\n+import io.opentelemetry.exporter.jaeger.thrift.JaegerThriftSpanExporter;\n+import io.opentelemetry.exporter.jaeger.thrift.JaegerThriftSpanExporterBuilder;\n+import io.opentelemetry.exporter.logging.LoggingSpanExporter;\n+import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporter;\n+import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporterBuilder;\n+import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporter;\n+import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporterBuilder;\n+import io.opentelemetry.exporter.prometheus.PrometheusCollector;\n+import io.opentelemetry.exporter.zipkin.ZipkinSpanExporter;\n+import io.opentelemetry.exporter.zipkin.ZipkinSpanExporterBuilder;\n+import io.opentelemetry.extension.trace.propagation.AwsXRayPropagator;\n+import io.opentelemetry.extension.trace.propagation.B3Propagator;\n+import io.opentelemetry.extension.trace.propagation.JaegerPropagator;\n+import io.opentelemetry.extension.trace.propagation.OtTracerPropagator;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.autoconfigure.spi.SdkMeterProviderConfigurer;\n+import io.opentelemetry.sdk.autoconfigure.spi.SdkTracerProviderConfigurer;\n+import io.opentelemetry.sdk.metrics.SdkMeterProvider;\n+import io.opentelemetry.sdk.metrics.SdkMeterProviderBuilder;\n+import io.opentelemetry.sdk.metrics.export.IntervalMetricReader;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.SdkTracerProvider;\n+import io.opentelemetry.sdk.trace.SdkTracerProviderBuilder;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.sdk.trace.config.TraceConfig;\n+import io.opentelemetry.sdk.trace.config.TraceConfigBuilder;\n+import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;\n+import io.opentelemetry.sdk.trace.export.BatchSpanProcessorBuilder;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.sdk.trace.samplers.Sampler;\n+import io.prometheus.client.exporter.HTTPServer;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.ServiceLoader;\n+\n+public final class OpenTelemetrySdkAutoConfiguration {\n+\n+  public static OpenTelemetrySdk initialize() {\n+    ConfigProperties config = ConfigProperties.get();\n+\n+    AttributesBuilder resourceAttributes = Attributes.builder();\n+    config.getCommaSeparatedMap(\"otel.resource.attributes\").forEach(resourceAttributes::put);\n+    Resource resource = Resource.getDefault().merge(Resource.create(resourceAttributes.build()));\n+\n+    SdkMeterProviderBuilder meterProviderBuilder = SdkMeterProvider.builder().setResource(resource);\n+    for (SdkMeterProviderConfigurer configurer :\n+        ServiceLoader.load(SdkMeterProviderConfigurer.class)) {\n+      configurer.configure(meterProviderBuilder);\n+    }\n+    SdkMeterProvider meterProvider = meterProviderBuilder.build();\n+\n+    List<String> exporterNames = config.getCommaSeparatedValues(\"otel.exporter\");\n+    boolean metricsConfigured = false;\n+    for (String exporterName : exporterNames) {\n+      exporterName = exporterName.toLowerCase(Locale.ROOT);\n+      switch (exporterName) {\n+        case \"otlp\":\n+        case \"otlp_metrics\":\n+          if (metricsConfigured) {\n+            throw new IllegalStateException(\n+                \"Multiple metrics exporters configured. Only one metrics exporter can be \"\n+                    + \"configured at a time.\");\n+          }\n+          configureOtlpMetrics(config, meterProvider);\n+          metricsConfigured = true;\n+          break;\n+        case \"prometheus\":\n+          if (metricsConfigured) {\n+            throw new IllegalStateException(\n+                \"Multiple metrics exporters configured. Only one metrics exporter can be \"\n+                    + \"configured at a time.\");\n+          }\n+          configurePrometheusMetrics(config, meterProvider);\n+          metricsConfigured = true;\n+          break;\n+        default:\n+          // Ignore\n+      }\n+    }\n+\n+    SdkTracerProviderBuilder tracerProviderBuilder =\n+        SdkTracerProvider.builder()\n+            .setResource(resource)\n+            .setTraceConfig(configureTraceConfig(config));\n+\n+    List<SpanExporter> spanExporters = new ArrayList<>();\n+    for (String exporterName : exporterNames) {\n+      exporterName = exporterName.toLowerCase(Locale.ROOT);\n+      switch (exporterName) {\n+        case \"otlp\":\n+        case \"otlp_span\":\n+          spanExporters.add(configureOtlpSpans(config));\n+          break;\n+        case \"jaeger\":\n+          spanExporters.add(configureJaeger(config));\n+          break;\n+        case \"jaeger-thrift\":\n+          spanExporters.add(configureJaegerThrift(config));\n+          break;\n+        case \"zipkin\":\n+          spanExporters.add(configureZipkin(config));\n+          break;\n+        case \"logging\":\n+          spanExporters.add(new LoggingSpanExporter());\n+          break;\n+        default:\n+          // Ignore\n+      }\n+    }\n+\n+    if (!spanExporters.isEmpty()) {\n+      tracerProviderBuilder.addSpanProcessor(configureSpanProcessor(config, spanExporters));\n+    }\n+\n+    for (SdkTracerProviderConfigurer configurer :\n+        ServiceLoader.load(SdkTracerProviderConfigurer.class)) {\n+      configurer.configure(tracerProviderBuilder);\n+    }\n+\n+    List<TextMapPropagator> propagators = new ArrayList<>();\n+    for (String propagatorName : config.getCommaSeparatedValues(\"otel.propagators\")) {\n+      switch (propagatorName) {\n+        case \"tracecontext\":\n+          propagators.add(W3CTraceContextPropagator.getInstance());\n+          break;\n+        case \"baggage\":\n+          propagators.add(W3CBaggagePropagator.getInstance());\n+          break;\n+        case \"b3\":\n+          propagators.add(B3Propagator.getInstance());\n+          break;\n+        case \"b3multi\":\n+          propagators.add(B3Propagator.builder().injectMultipleHeaders().build());\n+          break;\n+        case \"jaeger\":\n+          propagators.add(JaegerPropagator.getInstance());\n+          break;\n+        case \"ottracer\":\n+          propagators.add(OtTracerPropagator.getInstance());\n+          break;\n+        case \"xray\":\n+          propagators.add(AwsXRayPropagator.getInstance());\n+          break;\n+        default:\n+          // Ignore\n+      }\n+    }\n+\n+    return OpenTelemetrySdk.builder()\n+        .setTracerProvider(tracerProviderBuilder.build())\n+        .setPropagators(ContextPropagators.create(TextMapPropagator.composite(propagators)))\n+        .build();\n+  }\n+\n+  private static void configureOtlpMetrics(", "originalCommit": "ba20433307b8a4a61757a7c3c329d5209457dea2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIxNjM5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r548216392", "bodyText": "this could also be due to a restrictive security manager", "author": "jkwatson", "createdAt": "2020-12-23T20:37:18Z", "path": "api/all/src/main/java/io/opentelemetry/api/GlobalOpenTelemetry.java", "diffHunk": "@@ -115,4 +122,25 @@ public static Tracer getTracer(String instrumentationName, String instrumentatio\n   public static ContextPropagators getPropagators() {\n     return get().getPropagators();\n   }\n+\n+  @Nullable\n+  private static OpenTelemetry maybeAutoConfigure() {\n+    final Class<?> openTelemetrySdkAutoConfiguration;\n+    try {\n+      openTelemetrySdkAutoConfiguration =\n+          Class.forName(\"io.opentelemetry.sdk.autoconfigure.OpenTelemetrySdkAutoConfiguration\");\n+    } catch (ClassNotFoundException e) {\n+      return null;\n+    }\n+\n+    try {\n+      Method initialize = openTelemetrySdkAutoConfiguration.getMethod(\"initialize\");\n+      return (OpenTelemetry) initialize.invoke(null);\n+    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+      throw new IllegalStateException(\n+          \"OpenTelemetrySdkAutoConfiguration detected on classpath \"\n+              + \"but could not invoke initialize method. This is a bug in OpenTelemetry.\",", "originalCommit": "ba20433307b8a4a61757a7c3c329d5209457dea2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMyMTI4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r548321287", "bodyText": "For a public method, as far as I know there wouldn't be any situation that could be blocked by security manager, is there one?", "author": "anuraaga", "createdAt": "2020-12-23T23:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIxNjM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3MTk1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r548371953", "bodyText": "I thought security managers could block all reflection, but I wouldn't swear to it.", "author": "jkwatson", "createdAt": "2020-12-24T03:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIxNjM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQwODQwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r551408403", "bodyText": "Yes, a security manager can block all reflection, even for public methods, and even just calls to \"getMethod\", although I would suspect that's extremely rare these days.", "author": "jkwatson", "createdAt": "2021-01-04T16:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIxNjM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzOTY3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552339675", "bodyText": "Had no idea - do you think I should change the message? Wondering how realistic it is to disable public reflection vs adding noise to this code.", "author": "anuraaga", "createdAt": "2021-01-06T03:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIxNjM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM1NTY5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552355691", "bodyText": "Maybe just \"This could be a bug in OpenTelemetry\" ?  Really, it doesn't matter all that much.", "author": "jkwatson", "createdAt": "2021-01-06T03:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIxNjM5Mg=="}], "type": "inlineReview"}, {"oid": "78d46ea1b225ed90ac1f89ddb0768731be09dd84", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/78d46ea1b225ed90ac1f89ddb0768731be09dd84", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into autoconfigurre", "committedDate": "2020-12-24T05:40:48Z", "type": "commit"}, {"oid": "3603143a63f8a6bb00419a6faf16d2154399b252", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3603143a63f8a6bb00419a6faf16d2154399b252", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into autoconfigurre", "committedDate": "2020-12-25T02:28:54Z", "type": "commit"}, {"oid": "0410fef78c167fb016e603a0ff753e080792ba1c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0410fef78c167fb016e603a0ff753e080792ba1c", "message": "WIP", "committedDate": "2020-12-25T05:03:23Z", "type": "commit"}, {"oid": "65c31d43b4b46f338eb508ac71310ced502b00bc", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/65c31d43b4b46f338eb508ac71310ced502b00bc", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into autoconfigurre", "committedDate": "2020-12-29T04:16:36Z", "type": "commit"}, {"oid": "a72eee183bc45cfcf4fb01f4755c11ac1ec6c990", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a72eee183bc45cfcf4fb01f4755c11ac1ec6c990", "message": "WIP", "committedDate": "2020-12-29T04:33:45Z", "type": "commit"}, {"oid": "d696dac3a0a6fe1b7f1d9f84302958be78d10409", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d696dac3a0a6fe1b7f1d9f84302958be78d10409", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into autoconfigurre", "committedDate": "2021-01-04T05:12:37Z", "type": "commit"}, {"oid": "c8c857c5279d5ce0e23b08e94455cbd5f7996bb0", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c8c857c5279d5ce0e23b08e94455cbd5f7996bb0", "message": "WIP", "committedDate": "2021-01-04T05:24:20Z", "type": "commit"}, {"oid": "e032f4c8ecb09768ee9f7ea7c90140a5eec88c6c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e032f4c8ecb09768ee9f7ea7c90140a5eec88c6c", "message": "WIP", "committedDate": "2021-01-04T06:17:28Z", "type": "commit"}, {"oid": "7e0d223ccf17ee21ad9877abd7dcd726c5d691f8", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7e0d223ccf17ee21ad9877abd7dcd726c5d691f8", "message": "WIP", "committedDate": "2021-01-04T06:34:55Z", "type": "commit"}, {"oid": "8c670b4e9959db8b2426d6bc88189876364cca3f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8c670b4e9959db8b2426d6bc88189876364cca3f", "message": "Mostly done", "committedDate": "2021-01-04T09:27:14Z", "type": "commit"}, {"oid": "c83836bdb66e7caf54158b205efc6af9d1f435da", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c83836bdb66e7caf54158b205efc6af9d1f435da", "message": "Propagator classpath", "committedDate": "2021-01-04T09:34:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIwMDg0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r551200845", "bodyText": "Unlike the first commit with PoC, I haven't removed the API SPI yet, that we would do in a separate PR.", "author": "anuraaga", "createdAt": "2021-01-04T09:28:11Z", "path": "api/all/src/main/java/io/opentelemetry/api/GlobalOpenTelemetry.java", "diffHunk": "@@ -48,6 +51,13 @@ public static OpenTelemetry get() {\n     if (globalOpenTelemetry == null) {\n       synchronized (mutex) {\n         if (globalOpenTelemetry == null) {\n+\n+          OpenTelemetry autoConfigured = maybeAutoConfigure();\n+          if (autoConfigured != null) {\n+            set(autoConfigured);\n+            return autoConfigured;\n+          }\n+\n           OpenTelemetryFactory openTelemetryFactory = Utils.loadSpi(OpenTelemetryFactory.class);", "originalCommit": "8c670b4e9959db8b2426d6bc88189876364cca3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIwMTY1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r551201654", "bodyText": "I'm hoping to link to a docs page from here rather than outlining all properties here - presuably autoconfiguration users are the last to read the javadocs", "author": "anuraaga", "createdAt": "2021-01-04T09:29:45Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/OpenTelemetrySdkAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.common.AttributesBuilder;\n+import io.opentelemetry.context.propagation.ContextPropagators;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.metrics.SdkMeterProvider;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.SdkTracerProvider;\n+import java.util.List;\n+import java.util.Locale;\n+\n+/**\n+ * Auto-configuration for the OpenTelemetry SDK. As an alternative to programmatically configuring\n+ * the SDK using {@link OpenTelemetrySdk#builder()}, this package can be used to automatically\n+ * configure the SDK using environment properties specified by OpenTelemetry.", "originalCommit": "8c670b4e9959db8b2426d6bc88189876364cca3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d92ee268d92c02f7785739b207e007224df7f84", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7d92ee268d92c02f7785739b207e007224df7f84", "message": "Finish", "committedDate": "2021-01-05T04:34:45Z", "type": "commit"}, {"oid": "955c59e6b2f12abd5156d33361b73bd825cce597", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/955c59e6b2f12abd5156d33361b73bd825cce597", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into autoconfigurre", "committedDate": "2021-01-05T04:35:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0NTM2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552145364", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * prefer to use system properties for configuration, but this may be useful to register components\n          \n          \n            \n             * prefer to use system properties or environment variables for configuration, but this may be useful to register components", "author": "jkwatson", "createdAt": "2021-01-05T19:26:59Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/spi/SdkTracerProviderConfigurer.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure.spi;\n+\n+import io.opentelemetry.sdk.trace.SdkTracerProviderBuilder;\n+\n+/**\n+ * A service provider interface (SPI) for performing additional programmatic configuration of a\n+ * {@link SdkTracerProviderBuilder} during initialization. When using auto-configuration, you should\n+ * prefer to use system properties for configuration, but this may be useful to register components", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0NzgwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552147804", "bodyText": "this should be up above the static methods", "author": "jkwatson", "createdAt": "2021-01-05T19:31:43Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/ConfigProperties.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+class ConfigProperties {\n+\n+  static ConfigProperties get() {\n+    return new ConfigProperties(System.getProperties(), System.getenv());\n+  }\n+\n+  // Visible for testing\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  static ConfigProperties createForTest(Map<String, String> properties) {\n+    return new ConfigProperties((Map) properties, Collections.emptyMap());\n+  }\n+\n+  private final Map<String, String> config;", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3ODI2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552278264", "bodyText": "Heh - I'm going to have trouble getting used to fields being so far from the constructor :P", "author": "anuraaga", "createdAt": "2021-01-06T00:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0NzgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMyODgyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552328827", "bodyText": "that's why static methods should go at the bottom of the class \ud83d\ude01", "author": "trask", "createdAt": "2021-01-06T02:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0NzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0ODU1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552148551", "bodyText": "the left map could be Map<?,?> then you don't have to cast above.", "author": "jkwatson", "createdAt": "2021-01-05T19:33:17Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/ConfigProperties.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+class ConfigProperties {\n+\n+  static ConfigProperties get() {\n+    return new ConfigProperties(System.getProperties(), System.getenv());\n+  }\n+\n+  // Visible for testing\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  static ConfigProperties createForTest(Map<String, String> properties) {\n+    return new ConfigProperties((Map) properties, Collections.emptyMap());\n+  }\n+\n+  private final Map<String, String> config;\n+\n+  private ConfigProperties(\n+      Map<Object, Object> systemProperties, Map<String, String> environmentVariables) {", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3NDc2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552174764", "bodyText": "small nit. if you have an entry like =f it's technically missing the key, not the value. ;)", "author": "jkwatson", "createdAt": "2021-01-05T20:25:43Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/ConfigProperties.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+class ConfigProperties {\n+\n+  static ConfigProperties get() {\n+    return new ConfigProperties(System.getProperties(), System.getenv());\n+  }\n+\n+  // Visible for testing\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  static ConfigProperties createForTest(Map<String, String> properties) {\n+    return new ConfigProperties((Map) properties, Collections.emptyMap());\n+  }\n+\n+  private final Map<String, String> config;\n+\n+  private ConfigProperties(\n+      Map<Object, Object> systemProperties, Map<String, String> environmentVariables) {\n+    Map<String, String> config = new HashMap<>();\n+    environmentVariables.forEach(\n+        (name, value) -> config.put(name.toLowerCase(Locale.ROOT).replace('_', '.'), value));\n+    systemProperties.forEach(\n+        (key, value) -> config.put(((String) key).toLowerCase(Locale.ROOT), (String) value));\n+\n+    this.config = config;\n+  }\n+\n+  @Nullable\n+  String getString(String name) {\n+    return config.get(name);\n+  }\n+\n+  @Nullable\n+  @SuppressWarnings(\"UnusedException\")\n+  Integer getInt(String name) {\n+    String value = config.get(name);\n+    if (value == null || value.isEmpty()) {\n+      return null;\n+    }\n+    try {\n+      return Integer.parseInt(value);\n+    } catch (NumberFormatException ex) {\n+      throw newInvalidPropertyException(name, value, \"integer\");\n+    }\n+  }\n+\n+  @Nullable\n+  @SuppressWarnings(\"UnusedException\")\n+  Long getLong(String name) {\n+    String value = config.get(name);\n+    if (value == null || value.isEmpty()) {\n+      return null;\n+    }\n+    try {\n+      return Long.parseLong(value);\n+    } catch (NumberFormatException ex) {\n+      throw newInvalidPropertyException(name, value, \"long\");\n+    }\n+  }\n+\n+  @Nullable\n+  @SuppressWarnings(\"UnusedException\")\n+  Double getDouble(String name) {\n+    String value = config.get(name);\n+    if (value == null || value.isEmpty()) {\n+      return null;\n+    }\n+    try {\n+      return Double.parseDouble(value);\n+    } catch (NumberFormatException ex) {\n+      throw newInvalidPropertyException(name, value, \"double\");\n+    }\n+  }\n+\n+  List<String> getCommaSeparatedValues(String name) {\n+    String value = config.get(name);\n+    if (value == null) {\n+      return Collections.emptyList();\n+    }\n+    return Arrays.stream(value.split(\",\"))\n+        .map(String::trim)\n+        .filter(s -> !s.isEmpty())\n+        .collect(Collectors.toList());\n+  }\n+\n+  Map<String, String> getCommaSeparatedMap(String name) {\n+    return getCommaSeparatedValues(name).stream()\n+        .map(\n+            keyValuePair ->\n+                Arrays.stream(keyValuePair.split(\"=\", 2))\n+                    .map(String::trim)\n+                    .filter(s -> !s.isEmpty())\n+                    .collect(Collectors.toList()))\n+        .map(\n+            splitKeyValuePairs -> {\n+              if (splitKeyValuePairs.size() != 2) {\n+                throw new ConfigurationException(\n+                    \"Map property key missing value: \" + name + \"=\" + config.get(name));", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3NTIyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552175224", "bodyText": "These 4 lines of code could be extracted to a method like \"filterBlanksAndNulls\" and re-used above at line 96-99", "author": "jkwatson", "createdAt": "2021-01-05T20:26:42Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/ConfigProperties.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+class ConfigProperties {\n+\n+  static ConfigProperties get() {\n+    return new ConfigProperties(System.getProperties(), System.getenv());\n+  }\n+\n+  // Visible for testing\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+  static ConfigProperties createForTest(Map<String, String> properties) {\n+    return new ConfigProperties((Map) properties, Collections.emptyMap());\n+  }\n+\n+  private final Map<String, String> config;\n+\n+  private ConfigProperties(\n+      Map<Object, Object> systemProperties, Map<String, String> environmentVariables) {\n+    Map<String, String> config = new HashMap<>();\n+    environmentVariables.forEach(\n+        (name, value) -> config.put(name.toLowerCase(Locale.ROOT).replace('_', '.'), value));\n+    systemProperties.forEach(\n+        (key, value) -> config.put(((String) key).toLowerCase(Locale.ROOT), (String) value));\n+\n+    this.config = config;\n+  }\n+\n+  @Nullable\n+  String getString(String name) {\n+    return config.get(name);\n+  }\n+\n+  @Nullable\n+  @SuppressWarnings(\"UnusedException\")\n+  Integer getInt(String name) {\n+    String value = config.get(name);\n+    if (value == null || value.isEmpty()) {\n+      return null;\n+    }\n+    try {\n+      return Integer.parseInt(value);\n+    } catch (NumberFormatException ex) {\n+      throw newInvalidPropertyException(name, value, \"integer\");\n+    }\n+  }\n+\n+  @Nullable\n+  @SuppressWarnings(\"UnusedException\")\n+  Long getLong(String name) {\n+    String value = config.get(name);\n+    if (value == null || value.isEmpty()) {\n+      return null;\n+    }\n+    try {\n+      return Long.parseLong(value);\n+    } catch (NumberFormatException ex) {\n+      throw newInvalidPropertyException(name, value, \"long\");\n+    }\n+  }\n+\n+  @Nullable\n+  @SuppressWarnings(\"UnusedException\")\n+  Double getDouble(String name) {\n+    String value = config.get(name);\n+    if (value == null || value.isEmpty()) {\n+      return null;\n+    }\n+    try {\n+      return Double.parseDouble(value);\n+    } catch (NumberFormatException ex) {\n+      throw newInvalidPropertyException(name, value, \"double\");\n+    }\n+  }\n+\n+  List<String> getCommaSeparatedValues(String name) {\n+    String value = config.get(name);\n+    if (value == null) {\n+      return Collections.emptyList();\n+    }\n+    return Arrays.stream(value.split(\",\"))\n+        .map(String::trim)\n+        .filter(s -> !s.isEmpty())\n+        .collect(Collectors.toList());\n+  }\n+\n+  Map<String, String> getCommaSeparatedMap(String name) {\n+    return getCommaSeparatedValues(name).stream()\n+        .map(\n+            keyValuePair ->\n+                Arrays.stream(keyValuePair.split(\"=\", 2))\n+                    .map(String::trim)\n+                    .filter(s -> !s.isEmpty())\n+                    .collect(Collectors.toList()))", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4MDI3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552180270", "bodyText": "I don't think this is necessary or useful. No one should be using default serialization for anything, anywhere.", "author": "jkwatson", "createdAt": "2021-01-05T20:37:37Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/ConfigurationException.java", "diffHunk": "@@ -0,0 +1,16 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+/** An exception that is thrown if the user-provided configuration is invalid. */\n+public final class ConfigurationException extends RuntimeException {\n+\n+  private static final long serialVersionUID = 4717640118051490483L;", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI4MTUzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552281532", "bodyText": "I think Java throws a warning which fails our build if I don't have it (agree no one should serialize it :)\nwarning: [serial] serializable class ConfigurationException has no definition of serialVersionUID", "author": "anuraaga", "createdAt": "2021-01-06T00:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4MDI3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM1NjAxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552356010", "bodyText": "that must be an errorprone warning. I can't imagine that javac would emit that.", "author": "jkwatson", "createdAt": "2021-01-06T03:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4MDI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4MjkxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552182916", "bodyText": "it's a little annoying that this same check has to be done twice, but I don't see any easy away around it without some sort of ugly nesting of switch statements", "author": "jkwatson", "createdAt": "2021-01-05T20:43:19Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/MetricExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporter;\n+import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporterBuilder;\n+import io.opentelemetry.exporter.prometheus.PrometheusCollector;\n+import io.opentelemetry.sdk.metrics.SdkMeterProvider;\n+import io.opentelemetry.sdk.metrics.export.IntervalMetricReader;\n+import io.prometheus.client.exporter.HTTPServer;\n+import java.io.IOException;\n+import java.util.Collections;\n+\n+final class MetricExporterConfiguration {\n+\n+  static boolean configureExporter(\n+      String name,\n+      ConfigProperties config,\n+      boolean metricsAlreadyRegistered,\n+      SdkMeterProvider meterProvider) {\n+    switch (name) {\n+      case \"otlp\":\n+      case \"otlp_metrics\":\n+        if (metricsAlreadyRegistered) {", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4NDgyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552184827", "bodyText": "I guess you could do:\n    switch (name) {\n      case \"otlp\":\n      case \"otlp_metrics\":\n      case \"prometheus\":\n        if (metricsAlreadyRegistered) {\n          throw new ConfigurationException(\n              \"Multiple metrics exporters configured. Only one metrics exporter can be \"\n                  + \"configured at a time.\");\n        }\n        if (\"prometheus\".equals(name)) {\n          configurePrometheusMetrics(config, meterProvider);\n          return true;\n        }\n        configureOtlpMetrics(config, meterProvider);\n        return true;\n      default:\n        return false;\n    }\n\nbut I don't know if that's really much better.", "author": "jkwatson", "createdAt": "2021-01-05T20:47:07Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/MetricExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporter;\n+import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporterBuilder;\n+import io.opentelemetry.exporter.prometheus.PrometheusCollector;\n+import io.opentelemetry.sdk.metrics.SdkMeterProvider;\n+import io.opentelemetry.sdk.metrics.export.IntervalMetricReader;\n+import io.prometheus.client.exporter.HTTPServer;\n+import java.io.IOException;\n+import java.util.Collections;\n+\n+final class MetricExporterConfiguration {\n+\n+  static boolean configureExporter(\n+      String name,\n+      ConfigProperties config,\n+      boolean metricsAlreadyRegistered,\n+      SdkMeterProvider meterProvider) {\n+    switch (name) {\n+      case \"otlp\":\n+      case \"otlp_metrics\":\n+        if (metricsAlreadyRegistered) {\n+          throw new ConfigurationException(\n+              \"Multiple metrics exporters configured. Only one metrics exporter can be \"\n+                  + \"configured at a time.\");\n+        }\n+        configureOtlpMetrics(config, meterProvider);\n+        return true;\n+      case \"prometheus\":\n+        if (metricsAlreadyRegistered) {\n+          throw new ConfigurationException(\n+              \"Multiple metrics exporters configured. Only one metrics exporter can be \"\n+                  + \"configured at a time.\");\n+        }\n+        configurePrometheusMetrics(config, meterProvider);\n+        return true;\n+      default:\n+        return false;\n+    }", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4Nzc4MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552187781", "bodyText": "I really really don't like that the previous code mutates the set and we're relying on that fact here. That was super surprising to me...in fact, I was sure this line was a bug until I dug into the implementations.\nEven if it ends up being uglier, I'd very strongly prefer it if we didn't have hidden side-effects in the code like this.", "author": "jkwatson", "createdAt": "2021-01-05T20:53:02Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/OpenTelemetrySdkAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.common.AttributesBuilder;\n+import io.opentelemetry.context.propagation.ContextPropagators;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.metrics.SdkMeterProvider;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.SdkTracerProvider;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+/**\n+ * Auto-configuration for the OpenTelemetry SDK. As an alternative to programmatically configuring\n+ * the SDK using {@link OpenTelemetrySdk#builder()}, this package can be used to automatically\n+ * configure the SDK using environment properties specified by OpenTelemetry.\n+ */\n+public final class OpenTelemetrySdkAutoConfiguration {\n+\n+  /**\n+   * Returns an {@link OpenTelemetrySdk} automatically initialized through recognized system\n+   * properties and environment variables.\n+   */\n+  public static OpenTelemetrySdk initialize() {\n+    ConfigProperties config = ConfigProperties.get();\n+    ContextPropagators propagators = PropagatorConfiguration.configurePropagators(config);\n+\n+    Resource resource = configureResource(config);\n+\n+    Set<String> exporterNames =\n+        new LinkedHashSet<>(config.getCommaSeparatedValues(\"otel.exporter\"));\n+\n+    configureMeterProvider(resource, exporterNames, config);\n+\n+    SdkTracerProvider tracerProvider =\n+        TracerProviderConfiguration.configureTracerProvider(resource, exporterNames, config);\n+\n+    if (!exporterNames.isEmpty()) {", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3NTI5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552275298", "bodyText": "Yeah I mention it in a spec issue too :)\nopen-telemetry/opentelemetry-specification#1318 (comment)\nDo you see an alternative? Should I mutate a handledExportNames with .add instead?", "author": "anuraaga", "createdAt": "2021-01-06T00:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4Nzc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMxMjU4MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552312581", "bodyText": "You could return an updated copy of the set, maybe?", "author": "jkwatson", "createdAt": "2021-01-06T01:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4Nzc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzODk1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552338954", "bodyText": "It's tricky since already returning a tracerprovider from one of them. It's a bit of duplication but I went with exposing the recognized names and checking eagerly instead of mutations.", "author": "anuraaga", "createdAt": "2021-01-06T03:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4Nzc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4OTQ4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552189482", "bodyText": "\ud83d\udc4e", "author": "jkwatson", "createdAt": "2021-01-05T20:56:19Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/TracerProviderConfiguration.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.sdk.autoconfigure.spi.SdkTracerProviderConfigurer;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.SdkTracerProvider;\n+import io.opentelemetry.sdk.trace.SdkTracerProviderBuilder;\n+import io.opentelemetry.sdk.trace.config.TraceConfig;\n+import io.opentelemetry.sdk.trace.config.TraceConfigBuilder;\n+import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;\n+import io.opentelemetry.sdk.trace.export.BatchSpanProcessorBuilder;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.sdk.trace.samplers.Sampler;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+\n+final class TracerProviderConfiguration {\n+\n+  static SdkTracerProvider configureTracerProvider(\n+      Resource resource, Set<String> exporterNames, ConfigProperties config) {\n+    SdkTracerProviderBuilder tracerProviderBuilder =\n+        SdkTracerProvider.builder()\n+            .setResource(resource)\n+            .setTraceConfig(configureTraceConfig(config));\n+\n+    // Run user configuration before setting exporters from environment to allow user span\n+    // processors to effect export.\n+    for (SdkTracerProviderConfigurer configurer :\n+        ServiceLoader.load(SdkTracerProviderConfigurer.class)) {\n+      configurer.configure(tracerProviderBuilder);\n+    }\n+\n+    List<SpanExporter> spanExporters = new ArrayList<>();\n+    for (String name : new ArrayList<>(exporterNames)) {\n+      SpanExporter exporter = SpanExporterConfiguration.configureExporter(name, config);\n+      if (exporter != null) {\n+        spanExporters.add(exporter);\n+        exporterNames.remove(name);", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5MzEzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552193139", "bodyText": "I didn't even realize that this was a thing that end-users could do. Is this desirable behavior?", "author": "jkwatson", "createdAt": "2021-01-05T21:03:51Z", "path": "sdk-extensions/autoconfigure/src/test/java/io/opentelemetry/sdk/autoconfigure/OpenTelemetrySdkAutoConfigurationTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.opentelemetry.api.trace.attributes.SemanticAttributes;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.Collections;\n+import org.junit.jupiter.api.Test;\n+\n+class OpenTelemetrySdkAutoConfigurationTest {\n+\n+  @Test\n+  void resourcePrioritizesUser() {\n+    Resource resource =\n+        OpenTelemetrySdkAutoConfiguration.configureResource(\n+            ConfigProperties.createForTest(\n+                Collections.singletonMap(\"otel.resource.attributes\", \"telemetry.sdk.name=test\")));\n+    assertThat(resource.getAttributes().get(SemanticAttributes.TELEMETRY_SDK_NAME))", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI4Mjk5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552282998", "bodyText": "I think we'll need it for service name? I don't think a user should do something bad but it seems to make sense semantically to prioritize them if they do go to the effort.", "author": "anuraaga", "createdAt": "2021-01-06T00:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5MzEzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc5MTkzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552791932", "bodyText": "I don't know if it's generally desirable or not, but it certainly is the way it works today, so have a test for it is good. :)", "author": "jkwatson", "createdAt": "2021-01-06T16:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5MzEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5NDIwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552194201", "bodyText": "It'll be nice to convert to the logunit code!", "author": "jkwatson", "createdAt": "2021-01-05T21:05:53Z", "path": "sdk-extensions/autoconfigure/src/testConfigError/java/io/opentelemetry/sdk/autoconfigure/ConfigErrorTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import io.opentelemetry.api.GlobalOpenTelemetry;\n+import io.opentelemetry.context.propagation.ContextPropagators;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+import org.junit.jupiter.api.Test;\n+import org.junitpioneer.jupiter.SetSystemProperty;\n+\n+// All tests fail due to config errors so never register a global. We can test everything here\n+// without separating test sets.\n+class ConfigErrorTest {\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.exporter\", value = \"otlp_metrics,prometheus\")\n+  void multipleMetricExportersPrometheusThrows() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\n+            \"Multiple metrics exporters configured. \"\n+                + \"Only one metrics exporter can be configured at a time.\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.exporter\", value = \"prometheus,otlp_metrics\")\n+  void multipleMetricExportersOtlpThrows() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\n+            \"Multiple metrics exporters configured. \"\n+                + \"Only one metrics exporter can be configured at a time.\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.propagators\", value = \"cat\")\n+  void invalidPropagator() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\"Unrecognized value for otel.propagators: cat\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.trace.sampler\", value = \"traceidratio\")\n+  void missingTraceIdRatio() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\n+            \"otel.trace.sampler=traceidratio but otel.trace.sampler.arg is not provided. \"\n+                + \"Set otel.trace.sampler.arg to a value in the range [0.0, 1.0].\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.trace.sampler\", value = \"traceidratio\")\n+  @SetSystemProperty(key = \"otel.trace.sampler.arg\", value = \"bar\")\n+  void invalidTraceIdRatio() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\"Invalid value for property otel.trace.sampler.arg=bar. Must be a double.\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.trace.sampler\", value = \"parentbased_traceidratio\")\n+  void missingTraceIdRatioWithParent() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\n+            \"otel.trace.sampler=parentbased_traceidratio but otel.trace.sampler.arg is \"\n+                + \"not provided. Set otel.trace.sampler.arg to a value in the range [0.0, 1.0].\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.trace.sampler\", value = \"parentbased_traceidratio\")\n+  @SetSystemProperty(key = \"otel.trace.sampler.arg\", value = \"bar\")\n+  void invalidTraceIdRatioWithParent() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\"Invalid value for property otel.trace.sampler.arg=bar. Must be a double.\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.trace.sampler\", value = \"cat\")\n+  void invalidSampler() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\"Unrecognized value for otel.trace.sampler: cat\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.exporter\", value = \"otlp,cat,dog\")\n+  void invalidExporter() {\n+    assertThatThrownBy(OpenTelemetrySdkAutoConfiguration::initialize)\n+        .isInstanceOf(ConfigurationException.class)\n+        .hasMessage(\"Unrecognized value for otel.exporter: cat,dog\");\n+  }\n+\n+  @Test\n+  @SetSystemProperty(key = \"otel.exporter\", value = \"bar\")\n+  void globalOpenTelemetryWhenError() {\n+    Logger logger = Logger.getLogger(GlobalOpenTelemetry.class.getName());\n+    AtomicReference<LogRecord> logged = new AtomicReference<>();\n+    Handler handler =", "originalCommit": "955c59e6b2f12abd5156d33361b73bd825cce597", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "113951f8ef7fad172ad24758388e4e1079196715", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/113951f8ef7fad172ad24758388e4e1079196715", "message": "Cleanup", "committedDate": "2021-01-06T00:20:59Z", "type": "commit"}, {"oid": "e27dc42c9e3a7fe15000bb14179dfcdd8484a180", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e27dc42c9e3a7fe15000bb14179dfcdd8484a180", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into autoconfigurre", "committedDate": "2021-01-06T00:21:05Z", "type": "commit"}, {"oid": "83a5bd830ec7173f6bb7b0c1230005213ed83874", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/83a5bd830ec7173f6bb7b0c1230005213ed83874", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into autoconfigurre", "committedDate": "2021-01-06T00:34:01Z", "type": "commit"}, {"oid": "a1eb9420975e9db3040b42312cb1b1be63cd41e7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a1eb9420975e9db3040b42312cb1b1be63cd41e7", "message": "Cleanup", "committedDate": "2021-01-06T03:04:21Z", "type": "commit"}, {"oid": "31853bcbf53b2d6af0dfb4d122fb9c683de0649b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/31853bcbf53b2d6af0dfb4d122fb9c683de0649b", "message": "Not visible", "committedDate": "2021-01-06T03:05:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc5ODI5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552798299", "bodyText": "this is a good solution. thanks!", "author": "jkwatson", "createdAt": "2021-01-06T16:48:18Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/OpenTelemetrySdkAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.common.AttributesBuilder;\n+import io.opentelemetry.context.propagation.ContextPropagators;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.metrics.SdkMeterProvider;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.SdkTracerProvider;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+/**\n+ * Auto-configuration for the OpenTelemetry SDK. As an alternative to programmatically configuring\n+ * the SDK using {@link OpenTelemetrySdk#builder()}, this package can be used to automatically\n+ * configure the SDK using environment properties specified by OpenTelemetry.\n+ */\n+public final class OpenTelemetrySdkAutoConfiguration {\n+\n+  /**\n+   * Returns an {@link OpenTelemetrySdk} automatically initialized through recognized system\n+   * properties and environment variables.\n+   */\n+  public static OpenTelemetrySdk initialize() {\n+    ConfigProperties config = ConfigProperties.get();\n+    ContextPropagators propagators = PropagatorConfiguration.configurePropagators(config);\n+\n+    Resource resource = configureResource(config);\n+\n+    Set<String> exporterNames =\n+        new LinkedHashSet<>(config.getCommaSeparatedValues(\"otel.exporter\"));\n+\n+    Set<String> unrecognizedExporters = new LinkedHashSet<>(exporterNames);\n+    unrecognizedExporters.removeAll(SpanExporterConfiguration.RECOGNIZED_NAMES);\n+    unrecognizedExporters.removeAll(MetricExporterConfiguration.RECOGNIZED_NAMES);", "originalCommit": "31853bcbf53b2d6af0dfb4d122fb9c683de0649b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc5OTc0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552799741", "bodyText": "stuff like this is a good argument for extracting the keys into constants, but that can be done as a separate step later, for sure.", "author": "jkwatson", "createdAt": "2021-01-06T16:49:47Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/TracerProviderConfiguration.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import io.opentelemetry.sdk.autoconfigure.spi.SdkTracerProviderConfigurer;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.SdkTracerProvider;\n+import io.opentelemetry.sdk.trace.SdkTracerProviderBuilder;\n+import io.opentelemetry.sdk.trace.config.TraceConfig;\n+import io.opentelemetry.sdk.trace.config.TraceConfigBuilder;\n+import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;\n+import io.opentelemetry.sdk.trace.export.BatchSpanProcessorBuilder;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.sdk.trace.samplers.Sampler;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+\n+final class TracerProviderConfiguration {\n+\n+  static SdkTracerProvider configureTracerProvider(\n+      Resource resource, Set<String> exporterNames, ConfigProperties config) {\n+    SdkTracerProviderBuilder tracerProviderBuilder =\n+        SdkTracerProvider.builder()\n+            .setResource(resource)\n+            .setTraceConfig(configureTraceConfig(config));\n+\n+    // Run user configuration before setting exporters from environment to allow user span\n+    // processors to effect export.\n+    for (SdkTracerProviderConfigurer configurer :\n+        ServiceLoader.load(SdkTracerProviderConfigurer.class)) {\n+      configurer.configure(tracerProviderBuilder);\n+    }\n+\n+    List<SpanExporter> spanExporters = new ArrayList<>();\n+    for (String name : new ArrayList<>(exporterNames)) {\n+      SpanExporter exporter = SpanExporterConfiguration.configureExporter(name, config);\n+      if (exporter != null) {\n+        spanExporters.add(exporter);\n+      }\n+    }\n+\n+    if (!spanExporters.isEmpty()) {\n+      tracerProviderBuilder.addSpanProcessor(configureSpanProcessor(config, spanExporters));\n+    }\n+\n+    SdkTracerProvider tracerProvider = tracerProviderBuilder.build();\n+    Runtime.getRuntime().addShutdownHook(new Thread(tracerProvider::shutdown));\n+    return tracerProvider;\n+  }\n+\n+  // VisibleForTesting\n+  static BatchSpanProcessor configureSpanProcessor(\n+      ConfigProperties config, List<SpanExporter> exporters) {\n+    SpanExporter exporter = SpanExporter.composite(exporters);\n+    BatchSpanProcessorBuilder builder = BatchSpanProcessor.builder(exporter);\n+\n+    Long scheduleDelayMillis = config.getLong(\"otel.bsp.schedule.delay.millis\");\n+    if (scheduleDelayMillis != null) {\n+      builder.setScheduleDelayMillis(scheduleDelayMillis);\n+    }\n+\n+    Integer maxQueue = config.getInt(\"otel.bsp.max.queue.size\");\n+    if (maxQueue != null) {\n+      builder.setMaxQueueSize(maxQueue);\n+    }\n+\n+    Integer maxExportBatch = config.getInt(\"otel.bsp.max.export.batch.size\");\n+    if (maxExportBatch != null) {\n+      builder.setMaxExportBatchSize(maxExportBatch);\n+    }\n+\n+    Integer timeout = config.getInt(\"otel.bsp.export.timeout.millis\");\n+    if (timeout != null) {\n+      builder.setExporterTimeoutMillis(timeout);\n+    }\n+\n+    return builder.build();\n+  }\n+\n+  // Visible for testing\n+  static TraceConfig configureTraceConfig(ConfigProperties config) {\n+    TraceConfigBuilder builder = TraceConfig.getDefault().toBuilder();\n+\n+    String sampler = config.getString(\"otel.trace.sampler\");\n+    if (sampler != null) {\n+      builder.setSampler(configureSampler(sampler, config));\n+    }\n+\n+    Integer maxAttrs = config.getInt(\"otel.span.attribute.count.limit\");\n+    if (maxAttrs != null) {\n+      builder.setMaxNumberOfAttributes(maxAttrs);\n+    }\n+\n+    Integer maxEvents = config.getInt(\"otel.span.event.count.limit\");\n+    if (maxEvents != null) {\n+      builder.setMaxNumberOfEvents(maxEvents);\n+    }\n+\n+    Integer maxLinks = config.getInt(\"otel.span.link.count.limit\");\n+    if (maxLinks != null) {\n+      builder.setMaxNumberOfLinks(maxLinks);\n+    }\n+\n+    return builder.build();\n+  }\n+\n+  // Visible for testing\n+  static Sampler configureSampler(String sampler, ConfigProperties config) {\n+    switch (sampler) {\n+      case \"always_on\":\n+        return Sampler.alwaysOn();\n+      case \"always_off\":\n+        return Sampler.alwaysOff();\n+      case \"traceidratio\":\n+        {\n+          Double ratio = config.getDouble(\"otel.trace.sampler.arg\");\n+          if (ratio == null) {\n+            throw new ConfigurationException(\n+                \"otel.trace.sampler=traceidratio but otel.trace.sampler.arg is not provided. \"", "originalCommit": "31853bcbf53b2d6af0dfb4d122fb9c683de0649b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjgwMjI0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552802244", "bodyText": "I don't think this supression is needed any more.", "author": "jkwatson", "createdAt": "2021-01-06T16:52:19Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/ConfigProperties.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+class ConfigProperties {\n+\n+  private final Map<String, String> config;\n+\n+  static ConfigProperties get() {\n+    return new ConfigProperties(System.getProperties(), System.getenv());\n+  }\n+\n+  // Visible for testing\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})", "originalCommit": "31853bcbf53b2d6af0dfb4d122fb9c683de0649b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjgwMjQ4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2401#discussion_r552802487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @SuppressWarnings({\"unchecked\", \"rawtypes\"})", "author": "jkwatson", "createdAt": "2021-01-06T16:52:31Z", "path": "sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/ConfigProperties.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.autoconfigure;\n+\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+class ConfigProperties {\n+\n+  private final Map<String, String> config;\n+\n+  static ConfigProperties get() {\n+    return new ConfigProperties(System.getProperties(), System.getenv());\n+  }\n+\n+  // Visible for testing\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})", "originalCommit": "31853bcbf53b2d6af0dfb4d122fb9c683de0649b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c386a4ded2cd87ab7dc808b8a5698892c9283a7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5c386a4ded2cd87ab7dc808b8a5698892c9283a7", "message": "Update sdk-extensions/autoconfigure/src/main/java/io/opentelemetry/sdk/autoconfigure/ConfigProperties.java\n\nCo-authored-by: John Watson <jkwatson@gmail.com>", "committedDate": "2021-01-07T02:40:56Z", "type": "commit"}, {"oid": "183cfdc89bf0799c40e0a4a8d4a1f0c3f1ef95dc", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/183cfdc89bf0799c40e0a4a8d4a1f0c3f1ef95dc", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into autoconfigurre", "committedDate": "2021-01-07T02:51:21Z", "type": "commit"}, {"oid": "06048d494d7cb3a37231d64682299d67e1b9d5ce", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/06048d494d7cb3a37231d64682299d67e1b9d5ce", "message": "More merge", "committedDate": "2021-01-07T02:52:02Z", "type": "commit"}]}