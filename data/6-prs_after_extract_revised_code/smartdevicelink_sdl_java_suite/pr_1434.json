{"pr_number": 1434, "pr_title": "Feature/0296 possibility to update video streaming capabilities", "pr_createdAt": "2020-08-05T22:27:53Z", "pr_url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434", "timeline": [{"oid": "6c587df8e627e07a209f4893f1c2fb08faebf401", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/6c587df8e627e07a209f4893f1c2fb08faebf401", "message": "[0296]\n- Codestyle fix", "committedDate": "2020-11-13T13:12:57Z", "type": "commit"}, {"oid": "c8bdb2055d323105a913a4efd7e60ec6641445e2", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c8bdb2055d323105a913a4efd7e60ec6641445e2", "message": "[0296]\n- Codestyle fix", "committedDate": "2020-11-13T13:42:35Z", "type": "commit"}, {"oid": "9da111ab1a6ecb2480cbac2a609ed7dcb6b09361", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9da111ab1a6ecb2480cbac2a609ed7dcb6b09361", "message": "[0296]\n- Codestyle fix", "committedDate": "2020-11-13T13:47:41Z", "type": "commit"}, {"oid": "2395b68325685bcf2e04b14a0480b2e78867c2d1", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/2395b68325685bcf2e04b14a0480b2e78867c2d1", "message": "[0296]\n- Remove SdlProxyBase.java", "committedDate": "2020-11-16T10:04:43Z", "type": "commit"}, {"oid": "e26866274b08973baf549493a6deee097748e1ab", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e26866274b08973baf549493a6deee097748e1ab", "message": "[0296]\n- Remove unneeded public API changes", "committedDate": "2020-11-16T10:25:16Z", "type": "commit"}, {"oid": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3263ce13badd6e9d5b70025bc6ba5305bc758798", "message": "[0296]\n- Fix Tests", "committedDate": "2020-11-18T09:13:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1NDQ3Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539954472", "bodyText": "@kostyaBoss can you move line 936 right below line 925 (after the last entry for GENERAL_ADDITIONAL_CAPABILITY_LIST)?", "author": "santhanamk", "createdAt": "2020-12-10T08:04:00Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -912,11 +918,23 @@ public void onVoiceCommandSelected() {\n         GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n         GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n \n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 7b3f5dc70..df18d66aa 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -923,17 +923,15 @@ public class TestValues {\n         GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n \n         GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n \n         GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n-        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n \n         GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n         GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1NTEyMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539955120", "bodyText": "@kostyaBoss you can delete line 926 as it duplicates line 925.", "author": "santhanamk", "createdAt": "2020-12-10T08:05:08Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -912,11 +918,23 @@ public void onVoiceCommandSelected() {\n         GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n         GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 7b3f5dc70..df18d66aa 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -923,17 +923,15 @@ public class TestValues {\n         GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n \n         GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n \n         GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n-        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n \n         GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n         GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1Nzc3MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539957771", "bodyText": "@kostyaBoss you can remove the blank line on line 932 so all of GENERAL_VIDEOSTREAMINGCAPABILITY are grouped together.", "author": "santhanamk", "createdAt": "2020-12-10T08:09:54Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -912,11 +918,23 @@ public void onVoiceCommandSelected() {\n         GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n         GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n ", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 7b3f5dc70..df18d66aa 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -923,17 +923,15 @@ public class TestValues {\n         GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n \n         GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n \n         GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n         GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n-        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n \n         GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n         GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk2NDc3OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539964778", "bodyText": "@kostyaBoss are you able to do a reference.put(VideoStreamingCapability.KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES...) on line 91 to get it onto the reference object?", "author": "santhanamk", "createdAt": "2020-12-10T08:21:42Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/datatypes/VideoStreamingCapabilityTests.java", "diffHunk": "@@ -68,11 +71,15 @@ public void testRpcValues() {\n         assertNull(TestValues.NULL, msg.getDiagonalScreenSize());\n         assertNull(TestValues.NULL, msg.getPixelPerInch());\n         assertNull(TestValues.NULL, msg.getScale());\n+        assertNull(TestValues.NULL, msg.getAdditionalVideoStreamingCapabilities());\n     }\n \n     public void testJson() {\n         JSONObject reference = new JSONObject();\n \n+        msg.setAdditionalVideoStreamingCapabilities(null);", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk1MzQ1Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r541953452", "bodyText": "@santanamk\nThe \"testJson\" throws an exception while serializing using raw serializeJSON method, though while using it in real life everything goes fine. This is produced because of the different serializeJSON(byte protocolVersion) method and additional logic it has inside. If we put there  reference.put(VideoStreamingCapability.KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES...) it will constantly lead to the stackOverflowExceptions. On the other hand - I was unable to provide some substitution for this.\nOn the other hand, I am making them null to avoid this problem in the tests\nPrevious comment link\n#1434 (comment)", "author": "kboskin", "createdAt": "2020-12-13T16:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk2NDc3OA=="}], "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/datatypes/VideoStreamingCapabilityTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/datatypes/VideoStreamingCapabilityTests.java\nindex 101eaca97..5993ed69e 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/datatypes/VideoStreamingCapabilityTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/datatypes/VideoStreamingCapabilityTests.java\n\n@@ -76,9 +76,7 @@ public class VideoStreamingCapabilityTests extends TestCase {\n \n     public void testJson() {\n         JSONObject reference = new JSONObject();\n-\n         msg.setAdditionalVideoStreamingCapabilities(null);\n-        assertNull(msg.getAdditionalVideoStreamingCapabilities());\n \n         try {\n             reference.put(VideoStreamingCapability.KEY_MAX_BITRATE, TestValues.GENERAL_INT);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk2ODA5Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539968093", "bodyText": "@kostyaBoss do you need to add unit tests here?", "author": "santhanamk", "createdAt": "2020-12-10T08:27:11Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/streaming/video/SdlRemoteDisplayTest.java", "diffHunk": "@@ -106,6 +106,11 @@ protected void onCreate(Bundle savedInstanceState) {\n \n         }\n \n+        @Override\n+        public void onViewResized(int width, int height) {\n+", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0NjczNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r541946736", "bodyText": "@santanamk previously we've agreed to skip them", "author": "kboskin", "createdAt": "2020-12-13T15:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk2ODA5Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3MjYzNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539972635", "bodyText": "@kostyaBoss on lines 139-140 you are calling setSurface twice.  Is it necessary?", "author": "santhanamk", "createdAt": "2020-12-10T08:34:21Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -133,9 +135,16 @@ public void start() throws Exception {\n                 inputSurface = prepareVideoEncoder();\n \n                 // Create a virtual display that will output to our encoder.\n-                virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n-                        streamingParams.getResolution().getResolutionWidth(), streamingParams.getResolution().getResolutionHeight(),\n-                        streamingParams.getDisplayDensity(), inputSurface, DisplayManager.VIRTUAL_DISPLAY_FLAG_PRESENTATION);\n+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n+                    virtualDisplay.setSurface(null);", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 1a59baab1..fe0d958be 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -136,7 +136,6 @@ public class VirtualDisplayEncoder {\n \n                 // Create a virtual display that will output to our encoder.\n                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n-                    virtualDisplay.setSurface(null);\n                     virtualDisplay.setSurface(inputSurface);\n                 }\n                 else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3Njk0MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539976941", "bodyText": "@kostyaBoss in the onError method do you need to print out the info or do any other logging/exception handling?", "author": "santhanamk", "createdAt": "2020-12-10T08:41:16Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -192,6 +213,35 @@ public void onNotified(RPCNotification notification) {\n         }\n     };\n \n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+\n+            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+            // means only scale received\n+            if (castedCapability.getPreferredResolution() == null &&\n+                    castedCapability.getScale() != null &&\n+                    castedCapability.getScale() != 0 &&\n+                    VideoStreamManager.this.parameters != null\n+                    && VideoStreamManager.this.parameters.getResolution() != null) {\n+                // set cached resolution\n+                castedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+            }\n+            params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+            VideoStreamManager.this.parameters = params;\n+\n+            VideoStreamManager.this.withPendingRestart = true;\n+\n+            virtualDisplayEncoder.setStreamingParams(params);\n+            stopStreaming(true);\n+        }\n+\n+        @Override\n+        public void onError(String info) { }", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex f91004200..fb529c7e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -239,7 +240,9 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         }\n \n         @Override\n-        public void onError(String info) { }\n+        public void onError(String info) {\n+            Log.i(TAG, \"onError: \" + info);\n+        }\n     };\n \n     // MANAGER APIs\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3ODQ4Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539978483", "bodyText": "@kostyaBoss on lines 336-338 please format the comments so it lines up with the comments on the previous lines (lines 331-335)", "author": "santhanamk", "createdAt": "2020-12-10T08:43:38Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -274,6 +325,31 @@ public void onError(String info) {\n         }\n     }\n \n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex f91004200..fb529c7e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -333,9 +336,9 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n      *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n      *                           works best for the currently connected module.\n-     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param encrypted         a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange    constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange     constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n      */\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n         Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NDA1Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539994052", "bodyText": "@kostyaBoss I generated this file using the generator tool located at: https://github.com/smartdevicelink/sdl_java_suite/tree/master/generator\nI see differences between the generated file and this file.  Can you please generate this file using the tool?", "author": "santhanamk", "createdAt": "2020-12-10T09:06:54Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.smartdevicelink.proxy.rpc;", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0ODU0NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r541948544", "bodyText": "@santanamk, unfortunately, I was unable to generate this file. The exception I've got from the generator is\n12-13 17:35 - Generator - CRITICAL - Invalid XML file content: /Users/KBoskin/Desktop/luxoft/rpc_spec/MOBILE_API.xml, Unknown type 'VideoStreamingCapability'\nThe base I've used for 0296 spec API was \thttps://github.com/LuxoftSDL/rpc_spec.git", "author": "kboskin", "createdAt": "2020-12-13T15:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NDA1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b567009082a70f9bb8203743a70aa2ee9343bf96", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\nindex 31f33125d..3b30f5584 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n\n@@ -9,7 +9,7 @@ import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import java.util.Hashtable;\n \n /**\n- * @since SmartDeviceLink 7.0\n+ * @since SmartDeviceLink 7.1\n  */\n public class AppCapability extends RPCStruct {\n     public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NTg2OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539995868", "bodyText": "@kostyaBoss on line 53 you can change 7.0 to 7.0.0 (from the code generator tool).", "author": "santhanamk", "createdAt": "2020-12-10T09:09:33Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -49,6 +49,10 @@\n     public static final String KEY_DIAGONAL_SCREEN_SIZE = \"diagonalScreenSize\";\n     public static final String KEY_PIXEL_PER_INCH = \"pixelPerInch\";\n     public static final String KEY_SCALE = \"scale\";\n+    /**\n+     * @since SmartDeviceLink 7.0", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex a0e5a3760..cea900ce0 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -50,7 +50,7 @@ public class VideoStreamingCapability extends RPCStruct {\n     public static final String KEY_PIXEL_PER_INCH = \"pixelPerInch\";\n     public static final String KEY_SCALE = \"scale\";\n     /**\n-     * @since SmartDeviceLink 7.0\n+     * @since SmartDeviceLink 7.0.0\n      */\n     public static final String KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES = \"additionalVideoStreamingCapabilities\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NjcxNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539996717", "bodyText": "@kostyaBoss above line 193 please include (from the code generator tool):\n\"    /**\n* Sets the additionalVideoStreamingCapabilities.\n*\n* @param additionalVideoStreamingCapabilities\n* {\"array_min_size\": 1, \"array_max_size\": 100}\n* @SInCE SmartDeviceLink 7.0.0\n*/\"", "author": "santhanamk", "createdAt": "2020-12-10T09:10:49Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -180,4 +184,14 @@ public VideoStreamingCapability setScale(Double scale) {\n         setValue(KEY_SCALE, scale);\n         return this;\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n+        return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n+    }\n+", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex a0e5a3760..cea900ce0 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -186,12 +186,26 @@ public class VideoStreamingCapability extends RPCStruct {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n+    /**\n+     * Gets the additionalVideoStreamingCapabilities.\n+     *\n+     * @return List\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0\n+     */\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n     }\n \n-    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> capabilities) {\n-        setValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, capabilities);\n+    /**\n+     * Sets the additionalVideoStreamingCapabilities.\n+     *\n+     * @param additionalVideoStreamingCapabilities\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0\n+     */\n+    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> additionalVideoStreamingCapabilities) {\n+        setValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, additionalVideoStreamingCapabilities);\n         return this;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NzEwMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539997102", "bodyText": "@kostyaBoss on line 193 you can change the param name to additionalVideoStreamingCapabilities (code generator tool).", "author": "santhanamk", "createdAt": "2020-12-10T09:11:28Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -180,4 +184,14 @@ public VideoStreamingCapability setScale(Double scale) {\n         setValue(KEY_SCALE, scale);\n         return this;\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n+        return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n+    }\n+\n+    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> capabilities) {", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex a0e5a3760..cea900ce0 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -186,12 +186,26 @@ public class VideoStreamingCapability extends RPCStruct {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n+    /**\n+     * Gets the additionalVideoStreamingCapabilities.\n+     *\n+     * @return List\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0\n+     */\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n     }\n \n-    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> capabilities) {\n-        setValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, capabilities);\n+    /**\n+     * Sets the additionalVideoStreamingCapabilities.\n+     *\n+     * @param additionalVideoStreamingCapabilities\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0\n+     */\n+    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> additionalVideoStreamingCapabilities) {\n+        setValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, additionalVideoStreamingCapabilities);\n         return this;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NzY1NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539997654", "bodyText": "@kostyaBoss above line 188 you can add these lines (code generator tool):\n\"    /**\n* Gets the additionalVideoStreamingCapabilities.\n*\n* @return List\n* {\"array_min_size\": 1, \"array_max_size\": 100}\n* @SInCE SmartDeviceLink 7.0.0\n*/\"", "author": "santhanamk", "createdAt": "2020-12-10T09:12:15Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -180,4 +184,14 @@ public VideoStreamingCapability setScale(Double scale) {\n         setValue(KEY_SCALE, scale);\n         return this;\n     }\n+", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex a0e5a3760..cea900ce0 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -186,12 +186,26 @@ public class VideoStreamingCapability extends RPCStruct {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n+    /**\n+     * Gets the additionalVideoStreamingCapabilities.\n+     *\n+     * @return List\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0\n+     */\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n     }\n \n-    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> capabilities) {\n-        setValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, capabilities);\n+    /**\n+     * Sets the additionalVideoStreamingCapabilities.\n+     *\n+     * @param additionalVideoStreamingCapabilities\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0\n+     */\n+    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> additionalVideoStreamingCapabilities) {\n+        setValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, additionalVideoStreamingCapabilities);\n         return this;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5OTY3NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r539999674", "bodyText": "@kostyaBoss I generated this file using the generator tool located at: https://github.com/smartdevicelink/sdl_java_suite/tree/master/generator\nI see differences between the generated file and this file.  Can you please generate this file using the tool?", "author": "santhanamk", "createdAt": "2020-12-10T09:15:16Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.smartdevicelink.proxy.rpc.enums;", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0OTExOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r541949118", "bodyText": "@santanamk, unfortunately, I was unable to generate this file. The exception I've got from the generator is\n12-13 17:35 - Generator - CRITICAL - Invalid XML file content: /Users/KBoskin/Desktop/luxoft/rpc_spec/MOBILE_API.xml, Unknown type 'VideoStreamingCapability'\nThe base I've used for 0296 spec API was https://github.com/LuxoftSDL/rpc_spec.git", "author": "kboskin", "createdAt": "2020-12-13T15:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5OTY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\nindex 7285edae6..79969528c 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n\n@@ -1,7 +1,39 @@\n+/*\n+ * Copyright (c) 2021 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n package com.smartdevicelink.proxy.rpc.enums;\n \n /**\n- * @since SmartDeviceLink 7.0\n+ * @since SmartDeviceLink 7.1.0\n  * Enumerations of all available app capability types\n  */\n public enum AppCapabilityType {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzMjg2NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r540332865", "bodyText": "@kostyaBoss Per the proposal, startRemoteDisplayStream should be defined as public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange streamingRange).\nYour definition is different because you take in two VideoStreamingRanges instead of just one.  Do you need to change yours to match up with the proposal?", "author": "santhanamk", "createdAt": "2020-12-10T16:53:35Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -274,6 +325,31 @@ public void onError(String info) {\n         }\n     }\n \n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0OTM3MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r541949371", "bodyText": "@santanamk in the proposal it was just a section where a preview example was provided. To keep libraries mirroring each other we've agreed to make this method accept two arguments", "author": "kboskin", "createdAt": "2020-12-13T15:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzMjg2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex f91004200..fb529c7e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -333,9 +336,9 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n      *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n      *                           works best for the currently connected module.\n-     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param encrypted         a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange    constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange     constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n      */\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n         Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzNTE1NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r540335154", "bodyText": "@kostyaBoss Per the proposal, isImageResolutionInRange should be defined as public Boolean isImageResolutionInRange(VideoStreamingRange range, ImageResolution currentResolution).\nYour definition is different because you take in two Resolution objects instead of just the VideoStreamingRange object. Do you need to change yours to match up with the proposal?", "author": "santhanamk", "createdAt": "2020-12-10T16:56:40Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -648,6 +773,101 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0OTUxMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r541949513", "bodyText": "@santanamk in the proposal it was just a section where a preview example was provided. To keep libraries mirroring each other we've agreed to make this method accept two arguments", "author": "kboskin", "createdAt": "2020-12-13T15:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzNTE1NA=="}], "type": "inlineReview", "revised_code": {"commit": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex f91004200..e90705519 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -848,10 +865,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n                 return false;\n             }\n+            return true;\n+        } else {\n+            return false;\n         }\n-\n-        // TODO check what if dev provided invalid constraints\n-        return true;\n     }\n \n     public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzNjU1NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r540336555", "bodyText": "@kostyaBoss Per the proposal, isAspectRatioInRange should be defined as public Boolean isAspectRatioInRange(VideoStreamingRange range, ImageResolution currentResolution).\nYour definition is different because you take in an AspectRatio object instead of a VideoStreamingRange object. Do you need to change yours to match up with the proposal?", "author": "santhanamk", "createdAt": "2020-12-10T16:58:20Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -648,6 +773,101 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {", "originalCommit": "3263ce13badd6e9d5b70025bc6ba5305bc758798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk0OTY0Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r541949646", "bodyText": "@santanamk in the proposal it was just a section where a preview example was provided. To keep libraries mirroring each other we've agreed to make this method accept two arguments", "author": "kboskin", "createdAt": "2020-12-13T15:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzNjU1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex f91004200..e90705519 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -848,10 +865,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n                 return false;\n             }\n+            return true;\n+        } else {\n+            return false;\n         }\n-\n-        // TODO check what if dev provided invalid constraints\n-        return true;\n     }\n \n     public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n"}}, {"oid": "b4f78f57f6940dc76232ae3b067b5709a486c439", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/b4f78f57f6940dc76232ae3b067b5709a486c439", "message": "[0297]\n- Fix PR comments", "committedDate": "2020-12-13T16:09:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NjUyMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r543776523", "bodyText": "@kostyaBoss On line 194 after the @ it should be since instead of sInCe.", "author": "santhanamk", "createdAt": "2020-12-16T00:02:15Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -186,12 +186,26 @@ public VideoStreamingCapability setScale(Double scale) {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n+    /**\n+     * Gets the additionalVideoStreamingCapabilities.\n+     *\n+     * @return List\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0", "originalCommit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b567009082a70f9bb8203743a70aa2ee9343bf96", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex cea900ce0..7db1eeaf6 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -191,7 +191,7 @@ public class VideoStreamingCapability extends RPCStruct {\n      *\n      * @return List\n      * {\"array_min_size\": 1, \"array_max_size\": 100}\n-     * @SInCE SmartDeviceLink 7.0.0\n+     * @since SmartDeviceLink 7.0.0\n      */\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NjgxMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r543776812", "bodyText": "@kostyaBoss On line 205 after the @ it should be since instead of SInCE.", "author": "santhanamk", "createdAt": "2020-12-16T00:02:59Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -186,12 +186,26 @@ public VideoStreamingCapability setScale(Double scale) {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n+    /**\n+     * Gets the additionalVideoStreamingCapabilities.\n+     *\n+     * @return List\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0\n+     */\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n     }\n \n-    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> capabilities) {\n-        setValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, capabilities);\n+    /**\n+     * Sets the additionalVideoStreamingCapabilities.\n+     *\n+     * @param additionalVideoStreamingCapabilities\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @SInCE SmartDeviceLink 7.0.0", "originalCommit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b567009082a70f9bb8203743a70aa2ee9343bf96", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex cea900ce0..7db1eeaf6 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -191,7 +191,7 @@ public class VideoStreamingCapability extends RPCStruct {\n      *\n      * @return List\n      * {\"array_min_size\": 1, \"array_max_size\": 100}\n-     * @SInCE SmartDeviceLink 7.0.0\n+     * @since SmartDeviceLink 7.0.0\n      */\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MTc2NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r543781764", "bodyText": "@kostyaBoss I checked out your code generator tool: https://github.com/LuxoftSDL/rpc_spec.git\nLines 3273-3296 define the VideoStreamingCapability struct.  If you place your AppCapability XML below that struct then you should be able to generate it.  Also the XML for AppCapabilityType (enum) should be placed above AppCapability XML when you do this.", "author": "santhanamk", "createdAt": "2020-12-16T00:15:52Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.smartdevicelink.proxy.rpc;", "originalCommit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjU0ODQ3Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r552548473", "bodyText": "@santanamk I've tried this but didn't work for me. Will try rolling back the data manually", "author": "kboskin", "createdAt": "2021-01-06T12:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MTc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0NjAyNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r553146024", "bodyText": "@kostyaBoss I generated the AppCapability.java file using your generator tool.  There are a lot of differences between the generated AppCapability.java file and the one you are using.  I have attached the generated AppCapability.java here.   It is a .txt file but you can rename the extension to .java.\nAppCapability.txt", "author": "santhanamk", "createdAt": "2021-01-07T07:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MTc2NA=="}], "type": "inlineReview", "revised_code": {"commit": "b567009082a70f9bb8203743a70aa2ee9343bf96", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\nindex 31f33125d..3b30f5584 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n\n@@ -9,7 +9,7 @@ import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import java.util.Hashtable;\n \n /**\n- * @since SmartDeviceLink 7.0\n+ * @since SmartDeviceLink 7.1\n  */\n public class AppCapability extends RPCStruct {\n     public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5NTk1MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r543795950", "bodyText": "@kostyaBoss I generated this file using the code generator tool, and see a few differences between the file I am generating and yours.\nCan you regenerate this?  An extra step here is under the <enum name=FunctionID> tag you will need to define an element like this <element name=\"OnAppCapabilityUpdatedID\" value = \"32791\" hexvalue=\"8017\" since=\"7.1\"/> around line 3082 in the MOBILE_API.xml.", "author": "santhanamk", "createdAt": "2020-12-16T00:52:25Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.smartdevicelink.proxy.rpc;", "originalCommit": "b4f78f57f6940dc76232ae3b067b5709a486c439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjU1ODA4NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r552558084", "bodyText": "@santanamk I've tried this but didn't work for me. Will try rolling back the data manually. Original XML had this already included", "author": "kboskin", "createdAt": "2021-01-06T12:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5NTk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0NzkwNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r553147904", "bodyText": "@kostyaBoss  I generated the OnAppCapabilityUpdated.java file using your generator tool. There are a lot of differences between the generated OnAppCapabilityUpdated.java file and the one you are using. I have attached the generated OnAppCapabilityUpdated.java file\nOnAppCapabilityUpdated.txt\nhere. It is a .txt file but you can rename the extension to .java.", "author": "santhanamk", "createdAt": "2021-01-07T07:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5NTk1MA=="}], "type": "inlineReview", "revised_code": {"commit": "c4baa702f08326bf11b62ca21dd0ac24e77b1484", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\nindex 92f82c1b2..00ff6509c 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\n\n@@ -1,51 +1,112 @@\n+/*\n+ * Copyright (c) 2017 - 2021, SmartDeviceLink Consortium, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the SmartDeviceLink Consortium Inc. nor the names of\n+ * its contributors may be used to endorse or promote products derived\n+ * from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n package com.smartdevicelink.proxy.rpc;\n \n+import androidx.annotation.NonNull;\n+\n import com.smartdevicelink.protocol.enums.FunctionID;\n import com.smartdevicelink.proxy.RPCNotification;\n \n import java.util.Hashtable;\n \n /**\n- *\n- * @since Smart Device Link 7.0\n  * A notification to inform SDL Core that a specific app capability has changed.\n+ *\n+ * <p><b>Parameter List</b></p>\n+ *\n+ * <table border=\"1\" rules=\"all\">\n+ *  <tr>\n+ *      <th>Param Name</th>\n+ *      <th>Type</th>\n+ *      <th>Description</th>\n+ *      <th>Required</th>\n+ *      <th>Notes</th>\n+ *      <th>Version Available</th>\n+ *  </tr>\n+ *  <tr>\n+ *      <td>appCapability</td>\n+ *      <td>AppCapability</td>\n+ *      <td>The app capability that has been updated</td>\n+ *      <td>Y</td>\n+ *      <td></td>\n+ *      <td></td>\n+ *  </tr>\n+ * </table>\n+ *\n+ * @since SmartDeviceLink 7.1.0\n  */\n-\n public class OnAppCapabilityUpdated extends RPCNotification {\n     public static final String KEY_APP_CAPABILITY = \"appCapability\";\n \n     /**\n-     * Constructs a newly allocated OnAppCapabilityUpdated object\n+     * Constructs a new OnAppCapabilityUpdated object\n      */\n     public OnAppCapabilityUpdated() {\n         super(FunctionID.ON_APP_CAPABILITY_UPDATED.toString());\n     }\n \n     /**\n-     *<p>Constructs a newly allocated OnAppCapabilityUpdated object indicated by the Hashtable parameter</p>\n-     *@param hash The Hashtable to use\n+     * Constructs a new OnAppCapabilityUpdated object indicated by the Hashtable parameter\n+     *\n+     * @param hash The Hashtable to use\n      */\n     public OnAppCapabilityUpdated(Hashtable<String, Object> hash) {\n         super(hash);\n     }\n \n-    public OnAppCapabilityUpdated(AppCapability capability) {\n+    /**\n+     * Constructs a new OnAppCapabilityUpdated object\n+     *\n+     * @param appCapability The app capability that has been updated\n+     */\n+    public OnAppCapabilityUpdated(@NonNull AppCapability appCapability) {\n         this();\n-        setAppCapability(capability);\n+        setAppCapability(appCapability);\n     }\n \n     /**\n-     * @param capability\n-     * The app capability that has been updated\n+     * Sets the appCapability.\n+     *\n+     * @param appCapability The app capability that has been updated\n      */\n-    public void setAppCapability(AppCapability capability) {\n-        setParameters(KEY_APP_CAPABILITY, capability);\n+    public OnAppCapabilityUpdated setAppCapability(@NonNull AppCapability appCapability) {\n+        setParameters(KEY_APP_CAPABILITY, appCapability);\n+        return this;\n     }\n \n-\n     /**\n-     * @return AppCapability\n-     * The app capability that has been updated\n+     * Gets the appCapability.\n+     *\n+     * @return AppCapability The app capability that has been updated\n      */\n     public AppCapability getAppCapability() {\n         return (AppCapability) getObject(AppCapability.class, KEY_APP_CAPABILITY);\n"}}, {"oid": "b567009082a70f9bb8203743a70aa2ee9343bf96", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/b567009082a70f9bb8203743a70aa2ee9343bf96", "message": "[0296]\n- Add documentation on AppCapability", "committedDate": "2021-01-06T12:28:29Z", "type": "commit"}, {"oid": "c4baa702f08326bf11b62ca21dd0ac24e77b1484", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c4baa702f08326bf11b62ca21dd0ac24e77b1484", "message": "[0296]\n- Applied generated code", "committedDate": "2021-01-11T11:14:26Z", "type": "commit"}, {"oid": "5f5da45a6a88e026b2b71fdf3368745f8990afbb", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/5f5da45a6a88e026b2b71fdf3368745f8990afbb", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "committedDate": "2021-01-28T11:49:06Z", "type": "commit"}, {"oid": "a4757db072a6e879de6eb220ffb5c2946e5dee78", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a4757db072a6e879de6eb220ffb5c2946e5dee78", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/datatypes/VideoStreamingCapabilityTests.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n#\tbase/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n#\tbase/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "committedDate": "2021-02-02T16:18:01Z", "type": "commit"}, {"oid": "11dda53863c1f1d48e86257606c9d2e91becb716", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/11dda53863c1f1d48e86257606c9d2e91becb716", "message": "[0293]\n- Fix mr conflicts", "committedDate": "2021-02-02T18:06:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUzNjkzNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570536937", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @since SmartDeviceLink 7.0.0\n          \n          \n            \n                 * @since SmartDeviceLink 7.1.0", "author": "RHenigan", "createdAt": "2021-02-04T20:54:48Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -50,6 +50,10 @@\n     public static final String KEY_PIXEL_PER_INCH = \"pixelPerInch\";\n     public static final String KEY_SCALE = \"scale\";\n     public static final String KEY_PREFERRED_FPS = \"preferredFPS\";\n+    /**\n+     * @since SmartDeviceLink 7.0.0", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex 954d8ef94..fe8432558 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -51,7 +51,7 @@ public class VideoStreamingCapability extends RPCStruct {\n     public static final String KEY_SCALE = \"scale\";\n     public static final String KEY_PREFERRED_FPS = \"preferredFPS\";\n     /**\n-     * @since SmartDeviceLink 7.0.0\n+     * @since SmartDeviceLink 7.1.0\n      */\n     public static final String KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES = \"additionalVideoStreamingCapabilities\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUzNzUwMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570537502", "bodyText": "Can you move this annotation to below the comment block?", "author": "RHenigan", "createdAt": "2021-02-04T20:55:50Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -182,6 +186,30 @@ public VideoStreamingCapability setScale(Double scale) {\n         return this;\n     }\n \n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex 954d8ef94..fe8432558 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -186,14 +186,15 @@ public class VideoStreamingCapability extends RPCStruct {\n         return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+\n     /**\n      * Gets the additionalVideoStreamingCapabilities.\n      *\n      * @return List\n      * {\"array_min_size\": 1, \"array_max_size\": 100}\n-     * @since SmartDeviceLink 7.0.0\n+     * @since SmartDeviceLink 7.1.0\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUzNzYwMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570537603", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @since SmartDeviceLink 7.0.0\n          \n          \n            \n                 * @since SmartDeviceLink 7.1.0", "author": "RHenigan", "createdAt": "2021-02-04T20:55:59Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -182,6 +186,30 @@ public VideoStreamingCapability setScale(Double scale) {\n         return this;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    /**\n+     * Gets the additionalVideoStreamingCapabilities.\n+     *\n+     * @return List\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @since SmartDeviceLink 7.0.0", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex 954d8ef94..fe8432558 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -186,14 +186,15 @@ public class VideoStreamingCapability extends RPCStruct {\n         return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+\n     /**\n      * Gets the additionalVideoStreamingCapabilities.\n      *\n      * @return List\n      * {\"array_min_size\": 1, \"array_max_size\": 100}\n-     * @since SmartDeviceLink 7.0.0\n+     * @since SmartDeviceLink 7.1.0\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUzNzY5MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570537691", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @since SmartDeviceLink 7.0.0\n          \n          \n            \n                 * @since SmartDeviceLink 7.1.0", "author": "RHenigan", "createdAt": "2021-02-04T20:56:09Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -182,6 +186,30 @@ public VideoStreamingCapability setScale(Double scale) {\n         return this;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    /**\n+     * Gets the additionalVideoStreamingCapabilities.\n+     *\n+     * @return List\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @since SmartDeviceLink 7.0.0\n+     */\n+    public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n+        return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n+    }\n+\n+    /**\n+     * Sets the additionalVideoStreamingCapabilities.\n+     *\n+     * @param additionalVideoStreamingCapabilities\n+     * {\"array_min_size\": 1, \"array_max_size\": 100}\n+     * @since SmartDeviceLink 7.0.0", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex 954d8ef94..fe8432558 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -186,14 +186,15 @@ public class VideoStreamingCapability extends RPCStruct {\n         return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+\n     /**\n      * Gets the additionalVideoStreamingCapabilities.\n      *\n      * @return List\n      * {\"array_min_size\": 1, \"array_max_size\": 100}\n-     * @since SmartDeviceLink 7.0.0\n+     * @since SmartDeviceLink 7.1.0\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n         return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUzODA3Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570538076", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *      <td>Used as a descriptor of what data to expect in this struct. The corresponding param tothis enum should be included and the only other param included.</td>\n          \n          \n            \n             *      <td>Used as a descriptor of what data to expect in this struct. The corresponding param to this enum should be included and the only other param included.</td>", "author": "RHenigan", "createdAt": "2021-02-04T20:56:53Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright (c) 2017 - 2021, SmartDeviceLink Consortium, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the SmartDeviceLink Consortium Inc. nor the names of\n+ * its contributors may be used to endorse or promote products derived\n+ * from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.smartdevicelink.proxy.rpc;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.smartdevicelink.proxy.RPCStruct;\n+import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n+\n+import java.util.Hashtable;\n+\n+/**\n+ *\n+ * <p><b>Parameter List</b></p>\n+ *\n+ * <table border=\"1\" rules=\"all\">\n+ *  <tr>\n+ *      <th>Param Name</th>\n+ *      <th>Type</th>\n+ *      <th>Description</th>\n+ *      <th>Required</th>\n+ *      <th>Notes</th>\n+ *      <th>Version Available</th>\n+ *  </tr>\n+ *  <tr>\n+ *      <td>appCapabilityType</td>\n+ *      <td>AppCapabilityType</td>\n+ *      <td>Used as a descriptor of what data to expect in this struct. The corresponding param tothis enum should be included and the only other param included.</td>", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\nindex d72a9836a..213a4a758 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n\n@@ -54,7 +54,7 @@ import java.util.Hashtable;\n  *  <tr>\n  *      <td>appCapabilityType</td>\n  *      <td>AppCapabilityType</td>\n- *      <td>Used as a descriptor of what data to expect in this struct. The corresponding param tothis enum should be included and the only other param included.</td>\n+ *      <td>Used as a descriptor of what data to expect in this struct. The corresponding param to this enum should be included and the only other param included.</td>\n  *      <td>Y</td>\n  *      <td></td>\n  *      <td></td>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDUzOTAxMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570539011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since SmartDeviceLink 7.0\n          \n          \n            \n             * @since SmartDeviceLink 7.1.0", "author": "RHenigan", "createdAt": "2021-02-04T20:58:31Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.smartdevicelink.proxy.rpc.enums;\n+\n+/**\n+ * @since SmartDeviceLink 7.0", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\nindex 7285edae6..79969528c 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n\n@@ -1,7 +1,39 @@\n+/*\n+ * Copyright (c) 2021 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n package com.smartdevicelink.proxy.rpc.enums;\n \n /**\n- * @since SmartDeviceLink 7.0\n+ * @since SmartDeviceLink 7.1.0\n  * Enumerations of all available app capability types\n  */\n public enum AppCapabilityType {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0MDY2OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570540669", "bodyText": "This File is missing the copyright because the generator was not used to create this file, Can you try again to generate this file using the generator as the PR for the rpc_spec has changed since you last tried?", "author": "RHenigan", "createdAt": "2021-02-04T21:01:43Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.smartdevicelink.proxy.rpc.enums;", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\nindex 7285edae6..79969528c 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n\n@@ -1,7 +1,39 @@\n+/*\n+ * Copyright (c) 2021 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n package com.smartdevicelink.proxy.rpc.enums;\n \n /**\n- * @since SmartDeviceLink 7.0\n+ * @since SmartDeviceLink 7.1.0\n  * Enumerations of all available app capability types\n  */\n public enum AppCapabilityType {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0MjI3MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570542271", "bodyText": "This Deprecated method does not exist on master or develop and is not being used in this PR.\nThis method should be removed.", "author": "RHenigan", "createdAt": "2021-02-04T21:04:48Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -216,6 +227,45 @@ public void update(VideoStreamingCapability capability, String vehicleMake) {\n             this.frameRate = Math.min(this.frameRate, capability.getPreferredFPS());\n         }\n \n+        // This should be the last call as it will return out once a suitable format is found\n+        final List<VideoStreamingFormat> formats = capability.getSupportedFormats();\n+        if(formats != null && formats.size()>0){\n+            for(VideoStreamingFormat format : formats){\n+                for(int i = 0; i < currentlySupportedFormats.length; i ++){\n+                    if(currentlySupportedFormats[i].equals(format) ){\n+                        this.format = format;\n+                        return;\n+                    }\n+                }\n+            }\n+            DebugTool.logWarning(TAG, \"The VideoStreamingFormat has not been updated because none of the provided formats are supported.\");\n+\n+            //TODO In the future we should set format to null, but might be a breaking change\n+            // For now, format will remain whatever was set prior to this update\n+        }\n+\n+    }\n+\n+    /**\n+     * Update the values contained in the capability that should have been returned through the SystemCapabilityManager.\n+     * This update will use the most preferred streaming format from the module.\n+     * @param capability the video streaming capability returned from the SystemCapabilityManager\n+     * @see com.smartdevicelink.managers.lifecycle.SystemCapabilityManager\n+     * @see VideoStreamingCapability\n+     */\n+    @Deprecated\n+    public void update(VideoStreamingCapability capability){", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex a67fe1c1b..4c541c835 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -246,48 +248,6 @@ public class VideoStreamingParameters {\n \n     }\n \n-    /**\n-     * Update the values contained in the capability that should have been returned through the SystemCapabilityManager.\n-     * This update will use the most preferred streaming format from the module.\n-     * @param capability the video streaming capability returned from the SystemCapabilityManager\n-     * @see com.smartdevicelink.managers.lifecycle.SystemCapabilityManager\n-     * @see VideoStreamingCapability\n-     */\n-    @Deprecated\n-    public void update(VideoStreamingCapability capability){\n-        if(capability.getMaxBitrate()!=null){ this.bitrate = capability.getMaxBitrate() * 1000; } // NOTE: the unit of maxBitrate in getSystemCapability is kbps.\n-        scale = DEFAULT_SCALE;\n-        if(capability.getScale() != null) { scale = capability.getScale(); }\n-        if (capability.getDiagonalScreenSize() != null) { preferredDiagonal = capability.getDiagonalScreenSize(); }\n-        ImageResolution resolution = capability.getPreferredResolution();\n-        if(resolution!=null){\n-\n-            if(resolution.getResolutionHeight()!=null && resolution.getResolutionHeight() > 0){ this.resolution.setResolutionHeight((int)(resolution.getResolutionHeight() / scale)); }\n-            if(resolution.getResolutionWidth()!=null && resolution.getResolutionWidth() > 0){ this.resolution.setResolutionWidth((int)(resolution.getResolutionWidth() / scale)); }\n-        }\n-\n-        // This should be the last call as it will return out once a suitable format is found\n-        final List<VideoStreamingFormat> formats = capability.getSupportedFormats();\n-        if (formats != null && formats.size() > 0) {\n-            if (this.format != null && formats.contains(this.format)) {\n-                return; // given format is supported, so no need to change.\n-            }\n-            for (VideoStreamingFormat format : formats) {\n-                for (VideoStreamingFormat currentlySupportedFormat : currentlySupportedFormats) {\n-                    if (currentlySupportedFormat.equals(format)) {\n-                        this.format = format;\n-                        return;\n-                    }\n-                }\n-            }\n-            DebugTool.logWarning(TAG, \"The VideoStreamingFormat has not been updated because none of the provided formats are supported.\");\n-\n-            //TODO In the future we should set format to null, but might be a breaking change\n-            // For now, format will remain whatever was set prior to this update\n-        }\n-\n-    }\n-\n     public void setDisplayDensity(int displayDensity) {\n         this.displayDensity = displayDensity;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0NDE4NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570544184", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (capability.getDiagonalScreenSize() != null) { preferredDiagonal = capability.getDiagonalScreenSize(); }\n          \n          \n            \n                    if (capability.getDiagonalScreenSize() != null) {\n          \n          \n            \n                        preferredDiagonal = capability.getDiagonalScreenSize(); \n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nTo maintain consistent formatting", "author": "RHenigan", "createdAt": "2021-02-04T21:08:20Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -186,12 +194,15 @@ public void update(VideoStreamingCapability capability, String vehicleMake) {\n             int capableBitrateInKb = Math.min(Integer.MAX_VALUE / 1000, capability.getMaxBitrate());\n             this.bitrate = Math.min(this.bitrate, capableBitrateInKb * 1000);\n         } // NOTE: the unit of maxBitrate in getSystemCapability is kbps.\n-        double scale = DEFAULT_SCALE;\n-        // For resolution and scale, the capability values should be taken rather than parameters specified by developers.\n         if (capability.getScale() != null) {\n             scale = capability.getScale();\n         }\n+        if (capability.getDiagonalScreenSize() != null) { preferredDiagonal = capability.getDiagonalScreenSize(); }", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex a67fe1c1b..c6b4aa921 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -197,7 +197,9 @@ public class VideoStreamingParameters {\n         if (capability.getScale() != null) {\n             scale = capability.getScale();\n         }\n-        if (capability.getDiagonalScreenSize() != null) { preferredDiagonal = capability.getDiagonalScreenSize(); }\n+        if (capability.getDiagonalScreenSize() != null) {\n+            preferredDiagonal = capability.getDiagonalScreenSize();\n+        }\n         ImageResolution resolution = capability.getPreferredResolution();\n         if (capability.getAdditionalVideoStreamingCapabilities() != null &&\n                 !capability.getAdditionalVideoStreamingCapabilities().isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0NjU2OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570546569", "bodyText": "This does not match the proposal and should replace AspectRatio aspectRatio with Double minAspectRatio and Double maxAspectRatio\nFrom the proposal:\npublic class VideoStreamingRange {\nprivate Resolution minResolution;\nprivate Resolution maxResolution;\nprivate Double minAspectRatio;\nprivate Double maxAspectRatio;\nprivate Double minScreenDiagonal;\n}", "author": "RHenigan", "createdAt": "2021-02-04T21:12:48Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minResolution;\n+    private Resolution maxResolution;\n+    private Double minScreenDiagonal;\n+    private AspectRatio aspectRatio;\n+\n+    public VideoStreamingRange(\n+            Resolution minResolution,\n+            Resolution maxResolution,\n+            Double minScreenDiagonal,\n+            AspectRatio aspectRatio\n+    ) {", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc0MDM4Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r572740386", "bodyText": "@RHenigan Thanks for your reply, these were the code examples, and to make the IOS/Android libraries mirroring each other. The @santhanamk, @akaremo have approved these changes as well previously, let me know if we still need to move forward strictly with the proposal", "author": "kboskin", "createdAt": "2021-02-09T09:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0NjU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE3OTE5Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573179192", "bodyText": "@kostyaBoss This does not appear to mirror the iOS implementation, the iOS implementation has these 5 properties:\n@property (nonatomic, assign) float minimumAspectRatio;\n\n// The maximum supported normalized aspect ratio, Min value is 1\n@property (nonatomic, assign) float maximumAspectRatio;\n\n// The minimum supported diagonal screen size in inches, defaults to 0 (0 matches any size)\n@property (nonatomic, assign) float minimumDiagonal;\n\n// The minimum resolution to support, it overrides .minimumAspectRatio\n@property (nonatomic, strong, nullable) SDLImageResolution *minimumResolution;\n\n// The maximum resolution to support, it overrides .maximumAspectRatio\n@property (nonatomic, strong, nullable) SDLImageResolution *maximumResolution;\n\nThis class should be updated to match the proposal and the iOS implementation", "author": "RHenigan", "createdAt": "2021-02-09T19:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0NjU2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "3c831a35cc1dff28d55ffcf39580f78f8977db22", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex 6f5f06c31..049ee96af 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -4,21 +4,25 @@ public class VideoStreamingRange {\n     private Resolution minResolution;\n     private Resolution maxResolution;\n     private Double minScreenDiagonal;\n-    private AspectRatio aspectRatio;\n+    private Double minAspectRatio;\n+    private Double maxAspectRatio;\n \n     public VideoStreamingRange(\n             Resolution minResolution,\n             Resolution maxResolution,\n             Double minScreenDiagonal,\n-            AspectRatio aspectRatio\n+            Double minAspectRatio,\n+            Double maxAspectRatio\n     ) {\n         this.minResolution = minResolution;\n         this.maxResolution = maxResolution;\n         this.minScreenDiagonal = minScreenDiagonal;\n-        this.aspectRatio = aspectRatio;\n+        this.minAspectRatio = minAspectRatio;\n+        this.maxAspectRatio = maxAspectRatio;\n     }\n \n-    private VideoStreamingRange() { }\n+    private VideoStreamingRange() {\n+    }\n \n     public Resolution getMinResolution() {\n         return minResolution;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0NzAwMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570547000", "bodyText": "When VideoSrteamingRange is updated to match the proposal this class should no longer be needed", "author": "RHenigan", "createdAt": "2021-02-04T21:13:37Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/AspectRatio.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class AspectRatio {", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc0MTE2OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r572741168", "bodyText": "@RHenigan Thanks for your reply, linking this comment with the conversation above #1434 (comment)", "author": "kboskin", "createdAt": "2021-02-09T09:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0NzAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzE4MTE1Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573181157", "bodyText": "@kostyaBoss Please refer to the conversation above #1434 comment", "author": "RHenigan", "createdAt": "2021-02-09T19:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0NzAwMA=="}], "type": "inlineReview", "revised_code": {"commit": "3c831a35cc1dff28d55ffcf39580f78f8977db22", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/AspectRatio.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/AspectRatio.java\ndeleted file mode 100644\nindex 131f700d5..000000000\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/AspectRatio.java\n+++ /dev/null\n\n@@ -1,19 +0,0 @@\n-package com.smartdevicelink.managers.video.resolution;\n-\n-public class AspectRatio {\n-    private Double minAspectRatio;\n-    private Double maxAspectRatio;\n-\n-    public AspectRatio(Double minAspectRatio, Double maxAspectRatio) {\n-        this.minAspectRatio = minAspectRatio;\n-        this.maxAspectRatio = maxAspectRatio;\n-    }\n-\n-    public Double getMinAspectRatio() {\n-        return minAspectRatio;\n-    }\n-\n-    public Double getMaxAspectRatio() {\n-        return maxAspectRatio;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU0NzY1MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570547650", "bodyText": "Can you fix the formatting in this if statement?", "author": "RHenigan", "createdAt": "2021-02-04T21:14:55Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -203,9 +205,15 @@ public void run() {\n                     inputSurface = prepareVideoEncoder();\n \n                     // Create a virtual display that will output to our encoder.\n+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && virtualDisplay != null) {", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 48edc7bd7..237b1051e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -205,9 +206,9 @@ public class VirtualDisplayEncoder {\n                     inputSurface = prepareVideoEncoder();\n \n                     // Create a virtual display that will output to our encoder.\n-                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n-                    virtualDisplay.setSurface(inputSurface);\n-                }\n+                    if (Build.VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n+                        virtualDisplay.setSurface(inputSurface);\n+                    }\n                 else {\n                     // recreate after stop in most of cases\n                     virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1ODg5OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570558899", "bodyText": "Why was this changed to use 1920x1080 instead of the resolution defined in the streaming parameters?", "author": "RHenigan", "createdAt": "2021-02-04T21:34:51Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -203,9 +205,15 @@ public void run() {\n                     inputSurface = prepareVideoEncoder();\n \n                     // Create a virtual display that will output to our encoder.\n+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n+                    virtualDisplay.setSurface(inputSurface);\n+                }\n+                else {\n+                    // recreate after stop in most of cases\n                     virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n-                            streamingParams.getResolution().getResolutionWidth(), streamingParams.getResolution().getResolutionHeight(),\n+                            predefinedWidth, predefinedHeight,", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc0MzQ4MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r572743481", "bodyText": "@RHenigan there are platform limitations on changing the size of the VirtualDispay itself. To make the display resizable we should avoid recreating it. Hence there was decided to create the display with 1920x1080 parameters and resize the view inside. I believe the 1920x1080 canvas resolution should cover all possible HMI displays", "author": "kboskin", "createdAt": "2021-02-09T09:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg2Njc1Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r572866757", "bodyText": "@kostyaBoss This is untrue. There could, for example, be portrait orientation streams: https://cdn.arstechnica.net/wp-content/uploads/2021/02/2021-Ford-Mustang-Mach-E-charging-screens-1-1440x1920.jpg", "author": "joeljfischer", "createdAt": "2021-02-09T13:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY1NjM4Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573656383", "bodyText": "@joeljfischer Thanks for sharing this, let me explain the case which is the root cause. While testing it was discovered that there might come from the HMI resolution bigger than actual (which was used to start the streaming process). If this happens, according to Android platform specification and proposal's needs (do not stop the streaming process and restart it/do not stop encoding) we should not set the new size to VirtualDisplay object, but only work with the view inside. If the view is smaller comparing to VirtualDisplay canvas on the encoding level the \"black\" pixels will be filtered out by codec. Hence, it was decided to hardcode the 1920x1080 resolution for starting the display.\nI can rollback this to previous values (getting initial w/h from capability) but in this case, if the new capabilities will come with a higher resolution comparing to VD w/h defined previously the image will be cropped by the width of the VD\nPreviously, while testing this implementation internally there was an input that on HMI there will be no control on the user input and the user can set the new capability with higher resolution eventually\nShould I revert the change? Please, let me know the next steps decided regarding this item", "author": "kboskin", "createdAt": "2021-02-10T11:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk3OTY3Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573979672", "bodyText": "Hello @kostyaBoss per the proposal the video streaming process should be stopped and restarted. and this change should be reverted\nhttps://github.com/smartdevicelink/sdl_evolution/blob/master/assets/proposals/0296-Update-video-streaming-capabilities-during-ignition-cycle/Resolution_Switching.svg", "author": "RHenigan", "createdAt": "2021-02-10T18:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1ODg5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 48edc7bd7..237b1051e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -205,9 +206,9 @@ public class VirtualDisplayEncoder {\n                     inputSurface = prepareVideoEncoder();\n \n                     // Create a virtual display that will output to our encoder.\n-                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n-                    virtualDisplay.setSurface(inputSurface);\n-                }\n+                    if (Build.VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n+                        virtualDisplay.setSurface(inputSurface);\n+                    }\n                 else {\n                     // recreate after stop in most of cases\n                     virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1OTg2Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570559866", "bodyText": "Can you remove this import and use DebugTool instead of android Log", "author": "RHenigan", "createdAt": "2021-02-04T21:36:33Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -36,6 +36,7 @@\n import android.content.Context;\n import android.os.SystemClock;\n import android.util.DisplayMetrics;\n+import android.util.Log;", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex a1f0129bd..9f2fe60e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -36,7 +36,6 @@ import android.annotation.TargetApi;\n import android.content.Context;\n import android.os.SystemClock;\n import android.util.DisplayMetrics;\n-import android.util.Log;\n import android.view.Display;\n import android.view.InputDevice;\n import android.view.MotionEvent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MDIxMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570560211", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n          \n          \n            \n                    if (majorProtocolVersion >= 5 && !isCapabilitySupported) {", "author": "RHenigan", "createdAt": "2021-02-04T21:37:06Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,45 +363,95 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex a1f0129bd..9f2fe60e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -367,7 +365,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n         configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MDUyMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570560523", "bodyText": "This commented block should not be included in the changed", "author": "RHenigan", "createdAt": "2021-02-04T21:37:40Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,45 +363,95 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n-        if (majorProtocolVersion >= 5) {\n-            if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n-                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-                    @Override\n-                    public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n-                    }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n \n-                    @Override\n-                    public void onError(String info) {\n-                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n-                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-                    }\n-                }, false);\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+//\n+//    // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+//        if (majorProtocolVersion >= 5) {\n+//        if (internalInterface.getSystemCapabilityManager() != null) {\n+//            final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n+//            internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+//                @Override\n+//                public void onCapabilityRetrieved(Object capability) {\n+//                    params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n+//                    startStreaming(params, encrypted);\n+//                }", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex a1f0129bd..9f2fe60e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -367,7 +365,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n         configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MDkxNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570560915", "bodyText": "empty else statement should be removed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        } else { }\n          \n          \n            \n                                        }", "author": "RHenigan", "createdAt": "2021-02-04T21:38:20Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,45 +363,95 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n-        if (majorProtocolVersion >= 5) {\n-            if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n-                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-                    @Override\n-                    public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n-                    }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n \n-                    @Override\n-                    public void onError(String info) {\n-                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n-                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-                    }\n-                }, false);\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+//\n+//    // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+//        if (majorProtocolVersion >= 5) {\n+//        if (internalInterface.getSystemCapabilityManager() != null) {\n+//            final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n+//            internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+//                @Override\n+//                public void onCapabilityRetrieved(Object capability) {\n+//                    params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n+//                    startStreaming(params, encrypted);\n+//                }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {\n+            if (majorProtocolVersion >= 5) {\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                        @Override\n+                        public void onCapabilityRetrieved(Object capability) {\n+                            VideoStreamingParameters params = new VideoStreamingParameters();\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                            VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                            params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+                            if (listOfStreamingRanges != null) {\n+                                // filtering\n+                                castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                        getSupportedCapabilities(\n+                                                listOfStreamingRanges,\n+                                                castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                        )\n+                                );\n+                            } else { }", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex a1f0129bd..9f2fe60e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -367,7 +365,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n         configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU2MjExNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r570562117", "bodyText": "Can you fix the formatting here, this line should not be indented", "author": "RHenigan", "createdAt": "2021-02-04T21:40:35Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -367,28 +501,32 @@ private void startEncoder() {\n      *\n      * @see #resumeStreaming()\n      */\n-    public void stopStreaming() {\n-        if (remoteDisplay != null) {\n+    public void stopStreaming(boolean withPendingRestart) {\n+        if (remoteDisplay != null && !withPendingRestart) {\n             remoteDisplay.stop();\n+                this.withPendingRestart = false;", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex a1f0129bd..9f2fe60e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -504,10 +488,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     public void stopStreaming(boolean withPendingRestart) {\n         if (remoteDisplay != null && !withPendingRestart) {\n             remoteDisplay.stop();\n-                this.withPendingRestart = false;\n+            this.withPendingRestart = false;\n         }\n         if (this.isStreaming()) {\n-            if (virtualDisplayEncoder!=null){\n+            if (virtualDisplayEncoder != null) {\n                 virtualDisplayEncoder.shutDown(withPendingRestart);\n             }\n             stateMachine.transitionToState(StreamingStateMachine.PAUSED);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQwMDcwNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r572400707", "bodyText": "Currently with this implementation we do not update the existing parameters with the capabilities received. This was the goal of SDL 0323\nIf the parameters sent to this method are not null we still want to update them based on the capabilities received.\nI propose removing the check if parameters are null if (parameters == null) { and create params just before calling getCapability()\nfinal VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);", "author": "RHenigan", "createdAt": "2021-02-08T21:54:02Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,45 +363,95 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n-        if (majorProtocolVersion >= 5) {\n-            if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n-                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-                    @Override\n-                    public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n-                    }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n \n-                    @Override\n-                    public void onError(String info) {\n-                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n-                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-                    }\n-                }, false);\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+//\n+//    // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+//        if (majorProtocolVersion >= 5) {\n+//        if (internalInterface.getSystemCapabilityManager() != null) {\n+//            final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n+//            internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+//                @Override\n+//                public void onCapabilityRetrieved(Object capability) {\n+//                    params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n+//                    startStreaming(params, encrypted);\n+//                }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {", "originalCommit": "11dda53863c1f1d48e86257606c9d2e91becb716", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjUxMjgzNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r572512834", "bodyText": "Hi @RHenigan, in terms of SDL 0323, your suggested change above looks good to me. Thanks.", "author": "shiniwat", "createdAt": "2021-02-09T02:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQwMDcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzU4NDAxMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573584013", "bodyText": "@RHenigan could you please check if the suggested implementation for this case is suitable?", "author": "kboskin", "createdAt": "2021-02-10T09:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQwMDcwNw=="}], "type": "inlineReview", "revised_code": {"commit": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex a1f0129bd..9f2fe60e0 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -367,7 +365,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n         configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n"}}, {"oid": "859057a09c27b8e2a4addcbc6c802f29b211dd77", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/859057a09c27b8e2a4addcbc6c802f29b211dd77", "message": "[0296]\n- Fix Pr comments", "committedDate": "2021-02-09T10:55:42Z", "type": "commit"}, {"oid": "529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "message": "[0296]\n- Remove unused methods", "committedDate": "2021-02-09T10:58:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzIwMDAxMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573200010", "bodyText": "This will cause all apps to subscribe for VideoStreamingCapabilities even apps that dont use the Video Streaming feature. In the changes for VideoStreamManager you are adding a OnSystemCapabilityListener for VideoStreamingCapabilities.\nI dont believe this change to BaseSystemCapabilityManager is needed.", "author": "RHenigan", "createdAt": "2021-02-09T20:06:00Z", "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java", "diffHunk": "@@ -90,6 +90,7 @@\n         this.cachedSystemCapabilities = new HashMap<>();\n         this.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n         this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.VIDEO_STREAMING, true);", "originalCommit": "529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\nindex c94f7193c..cfb2176df 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n\n@@ -90,7 +90,6 @@ abstract class BaseSystemCapabilityManager {\n         this.cachedSystemCapabilities = new HashMap<>();\n         this.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n         this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n-        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.VIDEO_STREAMING, true);\n         this.shouldConvertDeprecatedDisplayCapabilities = true;\n         this.currentHMILevel = HMILevel.HMI_NONE;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzIwNDMzMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573204331", "bodyText": "This is a public method on a public class and would technically be a breaking change.\nPlease revert the changes to shutdown() and deprecate it.\nThen implement shutdown(boolean withPendingRestart)", "author": "RHenigan", "createdAt": "2021-02-09T20:13:12Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -217,7 +226,7 @@ public void run() {\n         }\n     }\n \n-    public void shutDown() {\n+    public void shutDown(boolean withPendingRestart) {", "originalCommit": "529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 237b1051e..c97cd61b2 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -226,6 +226,48 @@ public class VirtualDisplayEncoder {\n         }\n     }\n \n+    @Deprecated\n+    public void shutDown() {\n+        if (!initPassed) {\n+            DebugTool.logError(TAG, \"VirtualDisplayEncoder was not properly initialized with the init() method.\");\n+            return;\n+        }\n+        try {\n+            // cleanup GLES stuff\n+            if (mCaptureThread != null) {\n+                mCaptureThread.stopAsync();\n+                try {\n+                    mCaptureThread.join();\n+                } catch(InterruptedException e) {\n+\n+                }\n+                mCaptureThread = null;\n+            }\n+            if (encoderThread != null) {\n+                encoderThread.interrupt();\n+                encoderThread = null;\n+            }\n+\n+            if (mVideoEncoder != null) {\n+                mVideoEncoder.stop();\n+                mVideoEncoder.release();\n+                mVideoEncoder = null;\n+            }\n+\n+            if (virtualDisplay != null) {\n+                virtualDisplay.release();\n+                virtualDisplay = null;\n+            }\n+\n+            if (inputSurface != null) {\n+                inputSurface.release();\n+                inputSurface = null;\n+            }\n+        } catch (Exception ex) {\n+            DebugTool.logError(TAG, \"shutDown() failed\");\n+        }\n+    }\n+\n     public void shutDown(boolean withPendingRestart) {\n         if (!initPassed) {\n             DebugTool.logError(TAG, \"VirtualDisplayEncoder was not properly initialized with the init() method.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzI0Njg2NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573246864", "bodyText": "This is a public method on a public class and would technically be a breaking change.\nPlease revert the changes to stopStreaming() and deprecate it.\nThen implement stopStreaming(boolean withPendingRestart)", "author": "RHenigan", "createdAt": "2021-02-09T21:17:15Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -367,28 +485,32 @@ private void startEncoder() {\n      *\n      * @see #resumeStreaming()\n      */\n-    public void stopStreaming() {\n-        if (remoteDisplay != null) {\n+    public void stopStreaming(boolean withPendingRestart) {", "originalCommit": "529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 9f2fe60e0..e90705519 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -480,6 +480,22 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         }\n     }\n \n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    @Deprecated\n+    public void stopStreaming() {\n+        if (remoteDisplay != null) {\n+            remoteDisplay.stop();\n+        }\n+        if (virtualDisplayEncoder != null) {\n+            virtualDisplayEncoder.shutDown();\n+        }\n+        stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n+    }\n+\n     /**\n      * Stops streaming from the remote display. To restart, call\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzI1NzQ3NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573257475", "bodyText": "Why was this change made? to convert from the touchCoord value to the MotionEvent pointer wouldnt we still want to multiple by the scalar value?", "author": "RHenigan", "createdAt": "2021-02-09T21:34:06Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -608,7 +737,7 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n             long eventTime = sdlMotionEvent.eventTime;\n             pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n             if (pointer != null) {\n-                pointer.setCoords(touchCoord.getX() * touchScalar[0], touchCoord.getY() * touchScalar[1]);\n+                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);", "originalCommit": "529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 9f2fe60e0..e90705519 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -737,7 +753,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             long eventTime = sdlMotionEvent.eventTime;\n             pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n             if (pointer != null) {\n-                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n+                pointer.setCoords(touchCoord.getX() * touchScalar[0], touchCoord.getY() * touchScalar[1]);\n             }\n \n             MotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzI3NTMwNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573275307", "bodyText": "For this logic we should be verifying that the ranges constraints are correct and then if the current aspect ratio meets those constraints. with the current implementation we are only checking the currentAspectRatio if the constraints are incorrect\n        if (aspectRatioMax > aspectRatioMin && aspectRatioMin > 0) {\n            return currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax;\n        }\n        else {\n            return false;\n        }", "author": "RHenigan", "createdAt": "2021-02-09T22:00:19Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +774,101 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n+        Double aspectRatioMin = aspectRatio.getMinAspectRatio();\n+        Double aspectRatioMax = aspectRatio.getMaxAspectRatio();\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n+            if (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "originalCommit": "529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 9f2fe60e0..e90705519 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -849,10 +865,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n                 return false;\n             }\n+            return true;\n+        } else {\n+            return false;\n         }\n-\n-        // TODO check what if dev provided invalid constraints\n-        return true;\n     }\n \n     public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzI3OTc5NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r573279794", "bodyText": "This TODO should be resolved before completion of this card, based on the iOS implementation we should return false if the range and constraints are invalid\nif (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n                return false;\n            }\n\n            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n                return false;\n            }\n\n            return true;\n        } else {\n            return false;\n        }", "author": "RHenigan", "createdAt": "2021-02-09T22:04:37Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +774,101 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints", "originalCommit": "529cd7459374012b3ec0b41e4a6e0bbd962aacbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 9f2fe60e0..e90705519 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -849,10 +865,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n                 return false;\n             }\n+            return true;\n+        } else {\n+            return false;\n         }\n-\n-        // TODO check what if dev provided invalid constraints\n-        return true;\n     }\n \n     public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n"}}, {"oid": "ad4e19bd2605be894df97e0603bcd43c2cf5482e", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ad4e19bd2605be894df97e0603bcd43c2cf5482e", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities", "committedDate": "2021-02-10T09:51:57Z", "type": "commit"}, {"oid": "331ea3dfa64f2033ba19dba697ac23ac75ff1380", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/331ea3dfa64f2033ba19dba697ac23ac75ff1380", "message": "[0296]\n- Fix PR comments", "committedDate": "2021-02-10T10:52:07Z", "type": "commit"}, {"oid": "aaba8bbdf752ee5f91461be26177f0cc33cad244", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/aaba8bbdf752ee5f91461be26177f0cc33cad244", "message": "[0296]\n- Fix tests", "committedDate": "2021-02-10T17:18:23Z", "type": "commit"}, {"oid": "1cbe9e7213f1d9f9a8c591f27e5400ad935d9441", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/1cbe9e7213f1d9f9a8c591f27e5400ad935d9441", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "committedDate": "2021-02-10T17:43:36Z", "type": "commit"}, {"oid": "3c831a35cc1dff28d55ffcf39580f78f8977db22", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3c831a35cc1dff28d55ffcf39580f78f8977db22", "message": "[0296]\n- Remove aspect ration class\n- Fix builder", "committedDate": "2021-02-10T18:20:25Z", "type": "commit"}, {"oid": "3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "message": "[0296]\n- Revert predefined display", "committedDate": "2021-02-10T18:46:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAxMDg5NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574010894", "bodyText": "Should we also add an update for preferredDiagonalScreenSize if it is available to this method?\nif (!params.preferredDiagonal != null) {\n    this.preferredDiagonal = params.preferredDiagonal\n}", "author": "RHenigan", "createdAt": "2021-02-10T19:24:01Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -166,6 +170,10 @@ public void update(VideoStreamingParameters params) {\n             if (params.format != null) {\n                 this.format = params.format;\n             }\n+", "originalCommit": "3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA0OTE5Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574049192", "bodyText": "@JulianKast I've modified the code a little bit to match with the primitive type", "author": "kboskin", "createdAt": "2021-02-10T20:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAxMDg5NA=="}], "type": "inlineReview", "revised_code": {"commit": "87fe074595b540ce4f7bab8e90923e44b3243945", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex 4c541c835..69a3c1d40 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -171,6 +171,10 @@ public class VideoStreamingParameters {\n                 this.format = params.format;\n             }\n \n+            if (params.preferredDiagonal != 0.0) {\n+                this.preferredDiagonal = params.preferredDiagonal;\n+            }\n+\n             if (!params.additionalCapabilities.isEmpty()) {\n                 this.additionalCapabilities = params.additionalCapabilities;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAxMzAxNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574013016", "bodyText": "I feel we should add this check back in, if the format is already set we do not need to iterate over the rest of them\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(formats != null && formats.size()>0){\n          \n          \n            \n                    if(formats != null && formats.size()>0){\n          \n          \n            \n                        if (this.format != null && formats.contains(this.format)) {\n          \n          \n            \n                            return; // given format is supported, so no need to change.\n          \n          \n            \n                        }", "author": "RHenigan", "createdAt": "2021-02-10T19:27:19Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -218,13 +231,10 @@ public void update(VideoStreamingCapability capability, String vehicleMake) {\n \n         // This should be the last call as it will return out once a suitable format is found\n         final List<VideoStreamingFormat> formats = capability.getSupportedFormats();\n-        if (formats != null && formats.size() > 0) {\n-            if (this.format != null && formats.contains(this.format)) {\n-                return; // given format is supported, so no need to change.\n-            }\n-            for (VideoStreamingFormat format : formats) {\n-                for (VideoStreamingFormat currentlySupportedFormat : currentlySupportedFormats) {\n-                    if (currentlySupportedFormat.equals(format)) {\n+        if(formats != null && formats.size()>0){", "originalCommit": "3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA1NTE5OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574055198", "bodyText": "Hello @kostyaBoss for this change you have the same if statement twice now\nif (formats != null && formats.size() > 0) {\n            if (this.format != null && formats.contains(this.format)) {\n                return; // given format is supported, so no need to change.\n            }\n        }\n\n        if(formats != null && formats.size()>0){\n            for(VideoStreamingFormat format : formats){\n                for(int i = 0; i < currentlySupportedFormats.length; i ++){\n                    if(currentlySupportedFormats[i].equals(format) ){\n                        this.format = format;\n                        return;\n                    }\n                }\n            }\nDebugTool.logWarning(TAG, \"The VideoStreamingFormat has not been updated because none of the provided formats are supported.\");\n\n            //TODO In the future we should set format to null, but might be a breaking change\n            // For now, format will remain whatever was set prior to this update\n}\n\nand can be simplified\nif (formats != null && formats.size() > 0) {\n            if (this.format != null && formats.contains(this.format)) {\n                return; // given format is supported, so no need to change.\n            }\n            for (VideoStreamingFormat format : formats) {\n                for (VideoStreamingFormat currentlySupportedFormat : currentlySupportedFormats) {\n                    if (currentlySupportedFormat.equals(format)) {\n                        this.format = format;\n                        return;\n                    }\n                }\n            }\n            DebugTool.logWarning(TAG, \"The VideoStreamingFormat has not been updated because none of the provided formats are supported.\");\n\n            //TODO In the future we should set format to null, but might be a breaking change\n            // For now, format will remain whatever was set prior to this update\n        }", "author": "RHenigan", "createdAt": "2021-02-10T20:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAxMzAxNg=="}], "type": "inlineReview", "revised_code": {"commit": "87fe074595b540ce4f7bab8e90923e44b3243945", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex 4c541c835..69a3c1d40 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -231,6 +235,13 @@ public class VideoStreamingParameters {\n \n         // This should be the last call as it will return out once a suitable format is found\n         final List<VideoStreamingFormat> formats = capability.getSupportedFormats();\n+\n+        if (formats != null && formats.size() > 0) {\n+            if (this.format != null && formats.contains(this.format)) {\n+                return; // given format is supported, so no need to change.\n+            }\n+        }\n+\n         if(formats != null && formats.size()>0){\n             for(VideoStreamingFormat format : formats){\n                 for(int i = 0; i < currentlySupportedFormats.length; i ++){\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAxNzM3Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574017372", "bodyText": "I believe these lines can be removed\nif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n        getVideoStreamingParams();\n}\ncheckState();\n\nWhen we call processCapabilitiesWithPendingStart() then the params will be setup properly based on the capabilities", "author": "RHenigan", "createdAt": "2021-02-10T19:34:00Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -274,6 +325,31 @@ public void onError(String info) {\n         }\n     }\n \n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted         a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange    constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange     constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();", "originalCommit": "3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87fe074595b540ce4f7bab8e90923e44b3243945", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex f7614e63b..4ade04f7a 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -344,10 +344,6 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-            getVideoStreamingParams();\n-        }\n-        checkState();\n         processCapabilitiesWithPendingStart(encrypted, parameters);\n     }\n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAxNzg4Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574017887", "bodyText": "I believe these lines can be removed\nif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n        getVideoStreamingParams();\n}\ncheckState();\n\nWhen we call processCapabilitiesWithPendingStart() then the params will be setup properly based on the capabilities", "author": "RHenigan", "createdAt": "2021-02-10T19:34:50Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +360,62 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();", "originalCommit": "3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87fe074595b540ce4f7bab8e90923e44b3243945", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex f7614e63b..4ade04f7a 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -369,10 +365,6 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-            getVideoStreamingParams();\n-        }\n-        checkState();\n         processCapabilitiesWithPendingStart(encrypted, parameters);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAyMTMwOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574021309", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    VideoStreamingParameters params = new VideoStreamingParameters();\n          \n      \n    \n    \n  \n\nBy removing this line the params created at the begining of processCapabilitiesWithPendingStart will be used and then will be updated based on the capability retrieved", "author": "RHenigan", "createdAt": "2021-02-10T19:40:02Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +360,62 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters) {\n+        final VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n         if (majorProtocolVersion >= 5) {\n             if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n                 internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                     @Override\n                     public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n+                        VideoStreamingParameters params = new VideoStreamingParameters();", "originalCommit": "3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87fe074595b540ce4f7bab8e90923e44b3243945", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex f7614e63b..4ade04f7a 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -369,10 +365,6 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-            getVideoStreamingParams();\n-        }\n-        checkState();\n         processCapabilitiesWithPendingStart(encrypted, parameters);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAyNDIzMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574024231", "bodyText": "To maintain alignment with the iOS library and since the proposal is to Stop the Video stream and then start it again I recommend that we should not add a PAUSED state and should use the STOPPED state where appropriate", "author": "RHenigan", "createdAt": "2021-02-10T19:44:53Z", "path": "base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java", "diffHunk": "@@ -37,12 +37,12 @@\n import java.lang.annotation.RetentionPolicy;\n \n public class StreamingStateMachine {\n-    @IntDef({NONE, READY, STARTED, STOPPED, ERROR})\n+    @IntDef({NONE, READY, STARTED, STOPPED, ERROR, PAUSED})", "originalCommit": "3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAzOTExNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574039116", "bodyText": "@RHenigan this was requested by @joeljfischer previously. Are you sure we should remove this state?", "author": "kboskin", "createdAt": "2021-02-10T20:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAyNDIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA3MDgzNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574070837", "bodyText": "@kostyaBoss although this matter was discussed in the review it is not reflected in the final proposal and since the VideoStreamService should be stopped and then started again in this use case I believe that STOPPED state should be used.", "author": "RHenigan", "createdAt": "2021-02-10T20:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAyNDIzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5ae9087f6733950414cdcc28f8efc97c9b3dac1e", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java b/base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java\nindex 6eb6fe3e3..67929d4dd 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java\n\n@@ -37,12 +37,12 @@ import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n \n public class StreamingStateMachine {\n-    @IntDef({NONE, READY, STARTED, STOPPED, ERROR, PAUSED})\n+    @IntDef({NONE, READY, STARTED, STOPPED, ERROR})\n     @Retention(RetentionPolicy.SOURCE)\n     public @interface StreamingState {\n     }\n \n-    public static final int NONE = 0x00, READY = 0x30, STARTED = 0x60, STOPPED = 0x90, ERROR = 0xC0, PAUSED = 0xF0;\n+    public static final int NONE = 0x00, READY = 0x30, STARTED = 0x60, STOPPED = 0x90, ERROR = 0xC0;\n \n     private @StreamingState\n     int state = NONE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAyNTc3Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574025773", "bodyText": "Fix the formatting of this else statement so it is inline with the correct if statement", "author": "RHenigan", "createdAt": "2021-02-10T19:47:21Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -203,9 +204,15 @@ public void run() {\n                     inputSurface = prepareVideoEncoder();\n \n                     // Create a virtual display that will output to our encoder.\n+                    if (Build.VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n+                        virtualDisplay.setSurface(inputSurface);\n+                    }\n+                else {", "originalCommit": "3c10fd78c9d04406de86b4e3c1134a5fbd3e8e91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87fe074595b540ce4f7bab8e90923e44b3243945", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 22d4f9017..8f4c47e26 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -206,13 +206,12 @@ public class VirtualDisplayEncoder {\n                     // Create a virtual display that will output to our encoder.\n                     if (Build.VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n                         virtualDisplay.setSurface(inputSurface);\n+                    } else {\n+                        // recreate after stop in most of cases\n+                        virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n+                                streamingParams.getResolution().getResolutionWidth(), streamingParams.getResolution().getResolutionHeight(),\n+                                streamingParams.getDisplayDensity(), inputSurface, DisplayManager.VIRTUAL_DISPLAY_FLAG_PRESENTATION);\n                     }\n-                else {\n-                    // recreate after stop in most of cases\n-                    virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n-                            streamingParams.getResolution().getResolutionWidth(), streamingParams.getResolution().getResolutionHeight(),\n-                            streamingParams.getDisplayDensity(), inputSurface, DisplayManager.VIRTUAL_DISPLAY_FLAG_PRESENTATION);\n-                }\n \n                     startEncoder();\n                 }\n"}}, {"oid": "87fe074595b540ce4f7bab8e90923e44b3243945", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/87fe074595b540ce4f7bab8e90923e44b3243945", "message": "[0296]\n- Fix PR comments", "committedDate": "2021-02-10T20:19:33Z", "type": "commit"}, {"oid": "f0350d01ae3e44697fedd8c8d319e59a6ef05019", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f0350d01ae3e44697fedd8c8d319e59a6ef05019", "message": "[0296]\n- Simplify format processing", "committedDate": "2021-02-10T20:39:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA3NDE1MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574074150", "bodyText": "@kostyaBoss As the VideoStreamService will be stopped and restarted, we can still dispose of the virtualDisplay in this case as it will be recreated when the VideoStreamService starts again.\nSince this is the case we do not need a new shutDown method and can continue to use the old one", "author": "RHenigan", "createdAt": "2021-02-10T21:02:19Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -258,6 +265,47 @@ public void shutDown() {\n         }\n     }\n \n+    public void shutDown(boolean withPendingRestart) {\n+        if (!initPassed) {\n+            DebugTool.logError(TAG, \"VirtualDisplayEncoder was not properly initialized with the init() method.\");\n+            return;\n+        }\n+        try {\n+            // cleanup GLES stuff\n+            if (mCaptureThread != null) {\n+                mCaptureThread.stopAsync();\n+                try {\n+                    mCaptureThread.join();\n+                } catch(InterruptedException e) {\n+\n+                }\n+                mCaptureThread = null;\n+            }\n+            if (encoderThread != null) {\n+                encoderThread.interrupt();\n+                encoderThread = null;\n+            }\n+\n+            if (mVideoEncoder != null) {\n+                mVideoEncoder.stop();\n+                mVideoEncoder.release();\n+                mVideoEncoder = null;\n+            }\n+\n+            if (virtualDisplay != null && !withPendingRestart) {", "originalCommit": "f0350d01ae3e44697fedd8c8d319e59a6ef05019", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA5NDY4Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574094686", "bodyText": "@RHenigan Thanks for your reply. I still think we should not dispose thevirturalDisplay because it leads to disposal of the view (overridden by the developer) bonded to virtualDisplay and as a result, leads to loss of the state each time when new capability will come (because the view is reflectively re-instantiated and bounded to the virtualDisplay on the system level).\nIndeed, according to the proposal, we should restart the service, but as for me, it doesn't seem like expected behaviour to have the state lost but not kept after all the things have been adjusted.\nFor e.x if the developer will override the view with the WebView component inside -> the current web page on the new capability would be lost and the user will be forced to renavigate there\nPlease, let me know the next steps required assuming posted examples and arguments", "author": "kboskin", "createdAt": "2021-02-10T21:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA3NDE1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgyNjg2Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574826863", "bodyText": "Hello @kostyaBoss after further discussion with the team it would fall on the developer to save the state of their presentation class that is extending the SdlRemoteDisplay. the library would then still dispose of the virtualDisplay and when the presentation is reinstantiated the developer should have the saved state available.\nIf the library is to handle the state of the stream there would need to be a change to the proposal", "author": "RHenigan", "createdAt": "2021-02-11T21:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDA3NDE1MA=="}], "type": "inlineReview", "revised_code": {"commit": "7511035d76584cf000a5809cc1b96643c4902a8f", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 8f4c47e26..3db682b14 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -265,47 +264,6 @@ public class VirtualDisplayEncoder {\n         }\n     }\n \n-    public void shutDown(boolean withPendingRestart) {\n-        if (!initPassed) {\n-            DebugTool.logError(TAG, \"VirtualDisplayEncoder was not properly initialized with the init() method.\");\n-            return;\n-        }\n-        try {\n-            // cleanup GLES stuff\n-            if (mCaptureThread != null) {\n-                mCaptureThread.stopAsync();\n-                try {\n-                    mCaptureThread.join();\n-                } catch(InterruptedException e) {\n-\n-                }\n-                mCaptureThread = null;\n-            }\n-            if (encoderThread != null) {\n-                encoderThread.interrupt();\n-                encoderThread = null;\n-            }\n-\n-            if (mVideoEncoder != null) {\n-                mVideoEncoder.stop();\n-                mVideoEncoder.release();\n-                mVideoEncoder = null;\n-            }\n-\n-            if (virtualDisplay != null && !withPendingRestart) {\n-                virtualDisplay.release();\n-                virtualDisplay = null;\n-            }\n-\n-            if (inputSurface != null) {\n-                inputSurface.release();\n-                inputSurface = null;\n-            }\n-        } catch (Exception ex) {\n-            DebugTool.logError(TAG, \"shutDown() failed\");\n-        }\n-    }\n-\n     /**\n      * setupGLES: create offscreen surface and surface texture.\n      * @param Width\n"}}, {"oid": "5ae9087f6733950414cdcc28f8efc97c9b3dac1e", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/5ae9087f6733950414cdcc28f8efc97c9b3dac1e", "message": "[0296]\n- Remove paused state", "committedDate": "2021-02-11T20:32:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc3NjU5Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574776592", "bodyText": "This will cause an error when called here because the HMI is not FULL yet. I recommned moving this to the hmiListener onNotified method\nif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel())) {\n                    if (VideoStreamManager.this.parameters == null) {\n                        getVideoStreamingParams();\n                    }\n                    internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n }", "author": "RHenigan", "createdAt": "2021-02-11T19:40:00Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -209,7 +259,8 @@ public VideoStreamManager(ISdl internalInterface) {\n         internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n         // Listen for HMILevel changes\n         internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\n+        // Listen for SystemCapabilityType VIDEO_STREAMING\n+        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);", "originalCommit": "f0350d01ae3e44697fedd8c8d319e59a6ef05019", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a96a475a7329b4023af345838be42bc5b11996c", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 4ade04f7a..33de744bd 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -259,8 +262,6 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n         // Listen for HMILevel changes\n         internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-        // Listen for SystemCapabilityType VIDEO_STREAMING\n-        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n         stateMachine = new StreamingStateMachine();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc3Nzk3Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574777972", "bodyText": "to avoid an exception when calling startRemoteDisplayStream i recommend setting listOfStreamingRanges as an empty ArrayList with a starting size of 1\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<VideoStreamingRange> listOfStreamingRanges;\n          \n          \n            \n                private List<VideoStreamingRange> listOfStreamingRanges = new ArrayList<>(1);", "author": "RHenigan", "createdAt": "2021-02-11T19:42:22Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -101,10 +106,15 @@\n     private OnHMIStatus currentOnHMIStatus;\n     private final StreamingStateMachine stateMachine;\n     private VideoStreamingParameters parameters;\n+    private VideoStreamingCapability originalCapability;\n     private IVideoStreamListener streamListener;\n     private boolean isTransportAvailable = false;\n+    private Integer majorProtocolVersion;\n+    private List<VideoStreamingRange> listOfStreamingRanges;", "originalCommit": "f0350d01ae3e44697fedd8c8d319e59a6ef05019", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a96a475a7329b4023af345838be42bc5b11996c", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 4ade04f7a..33de744bd 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -110,7 +110,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     private IVideoStreamListener streamListener;\n     private boolean isTransportAvailable = false;\n     private Integer majorProtocolVersion;\n-    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private List<VideoStreamingRange> listOfStreamingRanges = new ArrayList(1);\n     private boolean hasStarted;\n     private String vehicleMake = null;\n     private boolean isEncrypted = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc5NTY2OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574795669", "bodyText": "This should be split into two seperate setters, setMaxAspectRatio and setMinAspectRatio", "author": "RHenigan", "createdAt": "2021-02-11T20:11:35Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minResolution;\n+    private Resolution maxResolution;\n+    private Double minScreenDiagonal;\n+    private Double minAspectRatio;\n+    private Double maxAspectRatio;\n+\n+    public VideoStreamingRange(\n+            Resolution minResolution,\n+            Resolution maxResolution,\n+            Double minScreenDiagonal,\n+            Double minAspectRatio,\n+            Double maxAspectRatio\n+    ) {\n+        this.minResolution = minResolution;\n+        this.maxResolution = maxResolution;\n+        this.minScreenDiagonal = minScreenDiagonal;\n+        this.minAspectRatio = minAspectRatio;\n+        this.maxAspectRatio = maxAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinResolution() {\n+        return minResolution;\n+    }\n+\n+    public Resolution getMaxResolution() {\n+        return maxResolution;\n+    }\n+\n+    public Double getMinScreenDiagonal() {\n+        return minScreenDiagonal;\n+    }\n+\n+    public Double getMinAspectRatio() {\n+        return minAspectRatio;\n+    }\n+\n+    public Double getMaxAspectRatio() {\n+        return maxAspectRatio;\n+    }\n+\n+    public static class Builder {\n+        private VideoStreamingRange range = new VideoStreamingRange();\n+        private Double maxAspectRatio;\n+\n+        public Builder setMinSupportedResolution(Resolution minSupportedResolution) {\n+            range.minResolution = minSupportedResolution;\n+            return this;\n+        }\n+\n+        public Builder setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+            range.maxResolution = maxSupportedResolution;\n+            return this;\n+        }\n+\n+        public Builder setMinScreenDiagonal(Double minScreenDiagonal) {\n+            range.minScreenDiagonal = minScreenDiagonal;\n+            return this;\n+        }\n+        public Builder setAspectRatio(Double minAspectRatio, Double maxAspectRatio) {", "originalCommit": "f0350d01ae3e44697fedd8c8d319e59a6ef05019", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgxNzkyOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574817928", "bodyText": "@RHenigan wouldn't it produce the case when the higher or lower boundary can be not configured?", "author": "kboskin", "createdAt": "2021-02-11T20:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc5NTY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgyMzI5NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574823295", "bodyText": "the same would then be true for the Resolution min and max, in the isImageResolutionInRange method we have null checks to handle this, the same should be added to the isAspectRatioInRange method.", "author": "RHenigan", "createdAt": "2021-02-11T21:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDc5NTY2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7511035d76584cf000a5809cc1b96643c4902a8f", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex 049ee96af..3b3b7bb5d 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -62,8 +62,12 @@ public class VideoStreamingRange {\n             range.minScreenDiagonal = minScreenDiagonal;\n             return this;\n         }\n-        public Builder setAspectRatio(Double minAspectRatio, Double maxAspectRatio) {\n+        public Builder setMinAspectRatio(Double minAspectRatio) {\n             range.minAspectRatio = minAspectRatio;\n+            return this;\n+        }\n+\n+        public Builder setMaxAspectRation(Double maxAspectRatio) {\n             range.maxAspectRatio = maxAspectRatio;\n             return this;\n         }\n"}}, {"oid": "6a96a475a7329b4023af345838be42bc5b11996c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/6a96a475a7329b4023af345838be42bc5b11996c", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-02-11T21:03:30Z", "type": "commit"}, {"oid": "7511035d76584cf000a5809cc1b96643c4902a8f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/7511035d76584cf000a5809cc1b96643c4902a8f", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-02-11T21:39:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDg0NjE5Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574846197", "bodyText": "@kostyaBoss I noticed a bug while testing RTP where on resize the protocol would change back to RAW (the default value)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        VideoStreamingParameters params = new VideoStreamingParameters();\n          \n          \n            \n                       VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n          \n      \n    \n    \n  \n\nThis fixes the issue as the previously set parameters will be used and then updated based on the capability received", "author": "RHenigan", "createdAt": "2021-02-11T21:41:44Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -192,6 +214,37 @@ public void onNotified(RPCNotification notification) {\n         }\n     };\n \n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();", "originalCommit": "6a96a475a7329b4023af345838be42bc5b11996c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39e217cddb6367def452380743edb67a2df027a6", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 33de744bd..ed57975e3 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -217,7 +217,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n         @Override\n         public void onCapabilityRetrieved(Object capability) {\n-            VideoStreamingParameters params = new VideoStreamingParameters();\n+           VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n \n             VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDg0ODEzOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574848138", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public Builder setMaxAspectRation(Double maxAspectRatio) {\n          \n          \n            \n                    public Builder setMaxAspectRatio(Double maxAspectRatio) {", "author": "RHenigan", "createdAt": "2021-02-11T21:45:10Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minResolution;\n+    private Resolution maxResolution;\n+    private Double minScreenDiagonal;\n+    private Double minAspectRatio;\n+    private Double maxAspectRatio;\n+\n+    public VideoStreamingRange(\n+            Resolution minResolution,\n+            Resolution maxResolution,\n+            Double minScreenDiagonal,\n+            Double minAspectRatio,\n+            Double maxAspectRatio\n+    ) {\n+        this.minResolution = minResolution;\n+        this.maxResolution = maxResolution;\n+        this.minScreenDiagonal = minScreenDiagonal;\n+        this.minAspectRatio = minAspectRatio;\n+        this.maxAspectRatio = maxAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinResolution() {\n+        return minResolution;\n+    }\n+\n+    public Resolution getMaxResolution() {\n+        return maxResolution;\n+    }\n+\n+    public Double getMinScreenDiagonal() {\n+        return minScreenDiagonal;\n+    }\n+\n+    public Double getMinAspectRatio() {\n+        return minAspectRatio;\n+    }\n+\n+    public Double getMaxAspectRatio() {\n+        return maxAspectRatio;\n+    }\n+\n+    public static class Builder {\n+        private VideoStreamingRange range = new VideoStreamingRange();\n+        private Double maxAspectRatio;\n+\n+        public Builder setMinSupportedResolution(Resolution minSupportedResolution) {\n+            range.minResolution = minSupportedResolution;\n+            return this;\n+        }\n+\n+        public Builder setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+            range.maxResolution = maxSupportedResolution;\n+            return this;\n+        }\n+\n+        public Builder setMinScreenDiagonal(Double minScreenDiagonal) {\n+            range.minScreenDiagonal = minScreenDiagonal;\n+            return this;\n+        }\n+        public Builder setMinAspectRatio(Double minAspectRatio) {\n+            range.minAspectRatio = minAspectRatio;\n+            return this;\n+        }\n+\n+        public Builder setMaxAspectRation(Double maxAspectRatio) {", "originalCommit": "7511035d76584cf000a5809cc1b96643c4902a8f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b9085044879f3132e2cf3fe56ad83c8822b82a0", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex 3b3b7bb5d..2e8a4ff6c 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -67,7 +67,7 @@ public class VideoStreamingRange {\n             return this;\n         }\n \n-        public Builder setMaxAspectRation(Double maxAspectRatio) {\n+        public Builder setMaxAspectRatio(Double maxAspectRatio) {\n             range.maxAspectRatio = maxAspectRatio;\n             return this;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDg1ODI1NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r574858255", "bodyText": "We should add a null check for originalAdditionalCapabilities, it is possible for the HMI to send additionalVideoStreamingCapabilities as null and if that is the case there will be a NPE here", "author": "RHenigan", "createdAt": "2021-02-11T22:03:36Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +780,101 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {", "originalCommit": "7511035d76584cf000a5809cc1b96643c4902a8f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "717e68f447dc27e5866547e03d355cbb5179152b", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 484bf1777..fcedcbb51 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -804,35 +804,37 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n \n             Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n             Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+            if (originalAdditionalCapabilities != null && !originalAdditionalCapabilities.isEmpty()) {\n \n-            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n-                double diagonal;\n-                if (capability.getPreferredResolution() == null\n-                        || capability.getPreferredResolution().getResolutionHeight() == null\n-                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n-                    continue;\n-                }\n-                if (capability.getDiagonalScreenSize() == null) {\n-                    diagonal = parameters.getPreferredDiagonal();\n-                } else {\n-                    diagonal = capability.getDiagonalScreenSize();\n-                }\n+                for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                    double diagonal;\n+                    if (capability.getPreferredResolution() == null\n+                            || capability.getPreferredResolution().getResolutionHeight() == null\n+                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                        continue;\n+                    }\n+                    if (capability.getDiagonalScreenSize() == null) {\n+                        diagonal = parameters.getPreferredDiagonal();\n+                    } else {\n+                        diagonal = capability.getDiagonalScreenSize();\n+                    }\n \n-                if (range.getMinScreenDiagonal() > diagonal) {\n-                    continue;\n-                }\n+                    if (range.getMinScreenDiagonal() > diagonal) {\n+                        continue;\n+                    }\n \n-                if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n-                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n+                        if (constraintHeightMax == null && constraintHeightMin == null) {\n+                            continue;\n+                        }\n+                    }\n+\n+                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n                         continue;\n                     }\n-                }\n \n-                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n-                    continue;\n+                    validCapabilities.add(capability);\n                 }\n-\n-                validCapabilities.add(capability);\n             }\n         }\n \n"}}, {"oid": "39e217cddb6367def452380743edb67a2df027a6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/39e217cddb6367def452380743edb67a2df027a6", "message": "Update android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\nCo-authored-by: Robert Henigan <heniganr1@gmail.com>", "committedDate": "2021-02-11T22:26:01Z", "type": "commit"}, {"oid": "9b9085044879f3132e2cf3fe56ad83c8822b82a0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9b9085044879f3132e2cf3fe56ad83c8822b82a0", "message": "Update android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\nCo-authored-by: Robert Henigan <heniganr1@gmail.com>", "committedDate": "2021-02-11T22:26:26Z", "type": "commit"}, {"oid": "717e68f447dc27e5866547e03d355cbb5179152b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/717e68f447dc27e5866547e03d355cbb5179152b", "message": "[0296]\n- Add null check", "committedDate": "2021-02-11T22:29:08Z", "type": "commit"}, {"oid": "8be00fae441f2a7de8b22764f8da3cd020098e87", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8be00fae441f2a7de8b22764f8da3cd020098e87", "message": "Merge branch 'feature/0296_possibility_to_update_video_streaming_capabilities' of https://github.com/LuxoftSDL/sdl_java_suite into feature/0296_possibility_to_update_video_streaming_capabilities", "committedDate": "2021-02-11T22:34:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTQ1MzAwNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r575453007", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated();\n          \n          \n            \n                                    OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated();\n          \n          \n            \n                                    onAppCapabilityUpdated.setAppCapability(appCapability);\n          \n      \n    \n    \n  \n\n@kostyaBoss the negotiate list of VideoStreamingCapabilities are not being sent back to the hmi, currently the OnAppCapabilityUpdated rpc is empty", "author": "RHenigan", "createdAt": "2021-02-12T18:50:37Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +357,57 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters) {\n+        final VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n         if (majorProtocolVersion >= 5) {\n             if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n                 internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                     @Override\n                     public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability) capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                        params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+\n+                        if (listOfStreamingRanges != null) {\n+                            // filtering\n+                            castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                            );\n+                        }\n+                        AppCapability appCapability = new AppCapability();\n+                        appCapability.setVideoStreamingCapability(castedCapability);\n+\n+                        OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated();", "originalCommit": "8be00fae441f2a7de8b22764f8da3cd020098e87", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8cb97c8a0afa47fe3e3b7e3cae24933e7836ac26", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 415196d24..7df44e40a 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -405,7 +405,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n                         AppCapability appCapability = new AppCapability();\n                         appCapability.setVideoStreamingCapability(castedCapability);\n \n-                        OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated();\n+                        OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(appCapability);\n                         internalInterface.sendRPC(onAppCapabilityUpdated);\n                         startStreaming(params, isEncrypted);\n                     }\n"}}, {"oid": "8cb97c8a0afa47fe3e3b7e3cae24933e7836ac26", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8cb97c8a0afa47fe3e3b7e3cae24933e7836ac26", "message": "[0296]\n- Send appCapability", "committedDate": "2021-02-12T18:53:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTQ1OTQ4Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r575459482", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    appCapability.setVideoStreamingCapability(castedCapability);\n          \n          \n            \n                                    appCapability.setAppCapabilityType(AppCapabilityType.VIDEO_STREAMING);\n          \n          \n            \n                                    appCapability.setVideoStreamingCapability(castedCapability);\n          \n      \n    \n    \n  \n\n@kostyaBoss AppCapabilityType also needs to be set", "author": "RHenigan", "createdAt": "2021-02-12T19:02:37Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +357,57 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters) {\n+        final VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n         if (majorProtocolVersion >= 5) {\n             if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n                 internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                     @Override\n                     public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability) capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                        params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+\n+                        if (listOfStreamingRanges != null) {\n+                            // filtering\n+                            castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                            );\n+                        }\n+                        AppCapability appCapability = new AppCapability();\n+                        appCapability.setVideoStreamingCapability(castedCapability);", "originalCommit": "8cb97c8a0afa47fe3e3b7e3cae24933e7836ac26", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "27affe53901b2401a0eecfa62b0d1a37868ab761", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 7df44e40a..318f91ee2 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -402,7 +403,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n                                     )\n                             );\n                         }\n-                        AppCapability appCapability = new AppCapability();\n+                        AppCapability appCapability = new AppCapability(AppCapabilityType.VIDEO_STREAMING);\n                         appCapability.setVideoStreamingCapability(castedCapability);\n \n                         OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(appCapability);\n"}}, {"oid": "27affe53901b2401a0eecfa62b0d1a37868ab761", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/27affe53901b2401a0eecfa62b0d1a37868ab761", "message": "[0296]\n- Send appCapability type", "committedDate": "2021-02-12T19:04:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjM1NjI2Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r576356266", "bodyText": "@kostyaBoss Now that we have reverted the change to the shutdown method of VirtualDisplayEncoder do we still need this change here?\nIf not I believe all changes in this file can be reverted", "author": "RHenigan", "createdAt": "2021-02-15T18:02:04Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -203,9 +204,14 @@ public void run() {\n                     inputSurface = prepareVideoEncoder();\n \n                     // Create a virtual display that will output to our encoder.\n-                    virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n-                            streamingParams.getResolution().getResolutionWidth(), streamingParams.getResolution().getResolutionHeight(),\n-                            streamingParams.getDisplayDensity(), inputSurface, DisplayManager.VIRTUAL_DISPLAY_FLAG_PRESENTATION);\n+                    if (Build.VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP && virtualDisplay != null) {", "originalCommit": "27affe53901b2401a0eecfa62b0d1a37868ab761", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "07cad3e9ced2b256970ecf988ec5273944915409", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 3db682b14..7c8df5b98 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -204,14 +203,9 @@ public class VirtualDisplayEncoder {\n                     inputSurface = prepareVideoEncoder();\n \n                     // Create a virtual display that will output to our encoder.\n-                    if (Build.VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP && virtualDisplay != null) {\n-                        virtualDisplay.setSurface(inputSurface);\n-                    } else {\n-                        // recreate after stop in most of cases\n-                        virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n-                                streamingParams.getResolution().getResolutionWidth(), streamingParams.getResolution().getResolutionHeight(),\n-                                streamingParams.getDisplayDensity(), inputSurface, DisplayManager.VIRTUAL_DISPLAY_FLAG_PRESENTATION);\n-                    }\n+                    virtualDisplay = mDisplayManager.createVirtualDisplay(TAG,\n+                            streamingParams.getResolution().getResolutionWidth(), streamingParams.getResolution().getResolutionHeight(),\n+                            streamingParams.getDisplayDensity(), inputSurface, DisplayManager.VIRTUAL_DISPLAY_FLAG_PRESENTATION);\n \n                     startEncoder();\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjM2MzA4NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r576363084", "bodyText": "Hello @kostyaBoss I dont this that this should be made public as this should only ever be called with TRUE from within the library and for any cases where the developer would be calling this method with FALSE I believe it would be better to use the existing stopStreaming method.\nI propose removing the deprecated annotation from the existing stopStreaming method and making this method private", "author": "RHenigan", "createdAt": "2021-02-15T18:19:06Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -377,18 +488,37 @@ public void stopStreaming() {\n         stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n     }\n \n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    public void stopStreaming(boolean withPendingRestart) {", "originalCommit": "27affe53901b2401a0eecfa62b0d1a37868ab761", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "07cad3e9ced2b256970ecf988ec5273944915409", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 318f91ee2..b9941f97b 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -493,7 +492,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      *\n      * @see #resumeStreaming()\n      */\n-    public void stopStreaming(boolean withPendingRestart) {\n+    private void stopStreaming(boolean withPendingRestart) {\n         if (remoteDisplay != null && !withPendingRestart) {\n             remoteDisplay.stop();\n             this.withPendingRestart = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjM2NDI4OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r576364289", "bodyText": "If the proposed changes are made for the stopStreaming methods, this change can be reverted", "author": "RHenigan", "createdAt": "2021-02-15T18:22:11Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -397,7 +527,7 @@ public void resumeStreaming() {\n     @Override\n     @RestrictTo(RestrictTo.Scope.LIBRARY)\n     public void dispose() {\n-        stopStreaming();\n+        stopStreaming(false);", "originalCommit": "27affe53901b2401a0eecfa62b0d1a37868ab761", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "07cad3e9ced2b256970ecf988ec5273944915409", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 318f91ee2..b9941f97b 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -527,7 +526,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     @Override\n     @RestrictTo(RestrictTo.Scope.LIBRARY)\n     public void dispose() {\n-        stopStreaming(false);\n+        stopStreaming();\n \n         hapticManager = null;\n         remoteDisplay = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjM2NDgyMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r576364822", "bodyText": "Currently if a capability matches both ranges then it will be added twice to validCapabilities, We should see if the capability is already in validCapabilities before adding it.\nif (!validCapabilities.contains(capability)) {\n    validCapabilities.add(capability);\n}", "author": "RHenigan", "createdAt": "2021-02-15T18:23:38Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +781,103 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+            if (originalAdditionalCapabilities != null && !originalAdditionalCapabilities.isEmpty()) {\n+\n+                for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                    double diagonal;\n+                    if (capability.getPreferredResolution() == null\n+                            || capability.getPreferredResolution().getResolutionHeight() == null\n+                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                        continue;\n+                    }\n+                    if (capability.getDiagonalScreenSize() == null) {\n+                        diagonal = parameters.getPreferredDiagonal();\n+                    } else {\n+                        diagonal = capability.getDiagonalScreenSize();\n+                    }\n+\n+                    if (range.getMinScreenDiagonal() > diagonal) {\n+                        continue;\n+                    }\n+\n+                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n+                        if (constraintHeightMax == null && constraintHeightMin == null) {\n+                            continue;\n+                        }\n+                    }\n+\n+                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                        continue;\n+                    }\n+\n+                    validCapabilities.add(capability);", "originalCommit": "27affe53901b2401a0eecfa62b0d1a37868ab761", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "07cad3e9ced2b256970ecf988ec5273944915409", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 318f91ee2..b9941f97b 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -834,7 +833,9 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n                         continue;\n                     }\n \n-                    validCapabilities.add(capability);\n+                    if (!validCapabilities.contains(capability)) {\n+                        validCapabilities.add(capability);\n+                    }\n                 }\n             }\n         }\n"}}, {"oid": "07cad3e9ced2b256970ecf988ec5273944915409", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/07cad3e9ced2b256970ecf988ec5273944915409", "message": "[0296]\n- Fix PR comments", "committedDate": "2021-02-15T18:37:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQzMjIzNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r576432236", "bodyText": "This should refer back to stopStreaming() instead of stopStreaming(boolean withPendingRestart)", "author": "RHenigan", "createdAt": "2021-02-15T21:33:49Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -377,18 +487,37 @@ public void stopStreaming() {\n         stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n     }\n \n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    private void stopStreaming(boolean withPendingRestart) {\n+        if (remoteDisplay != null && !withPendingRestart) {\n+            remoteDisplay.stop();\n+            this.withPendingRestart = false;\n+        }\n+        if (this.isStreaming()) {\n+            if (virtualDisplayEncoder != null) {\n+                virtualDisplayEncoder.shutDown();\n+            }\n+            stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n+            stopVideoStream();\n+        }\n+    }\n+\n     /**\n      * Resumes streaming after calling\n      *\n      * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n      * followed by a call to\n-     * @see #stopStreaming()\n+     * @see #stopStreaming(boolean withPendingRestart)", "originalCommit": "07cad3e9ced2b256970ecf988ec5273944915409", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e5930f18a6befcf6b5d47b0e3051641502d46fa8", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex b9941f97b..274c1714b 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -511,7 +510,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      *\n      * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n      * followed by a call to\n-     * @see #stopStreaming(boolean withPendingRestart)\n+     * @see #stopStreaming()\n      */\n     public void resumeStreaming() {\n         int currentState = stateMachine.getState();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQzMzUzMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r576433533", "bodyText": "The proposal was not very clear on what properties should get set on OnAppCapabilityUpdated.appCapability. videoStreamingCapability so we have decided we should not set the root videoStreamingCapability but only the additionalVideoStreamingCapabilities as outlined below:\n\nMobile checks both the root videoStreamingCapability and the additionalVideoStreamingCapabilities to see which ones it can support.\nMobile sends an OnAppCapabilityUpdated with only the VideoStreamingCapability.additionalVideoStreamingCapabilities parameter set. The  additionalVideoStreamingCapabilities should be set with all the capabilities it can support as determined by step 1.", "author": "RHenigan", "createdAt": "2021-02-15T21:35:03Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +358,57 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters) {\n+        final VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n         if (majorProtocolVersion >= 5) {\n             if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n                 internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                     @Override\n                     public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability) capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                        params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+\n+                        if (listOfStreamingRanges != null) {\n+                            // filtering\n+                            castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                            );\n+                        }\n+                        AppCapability appCapability = new AppCapability(AppCapabilityType.VIDEO_STREAMING);\n+                        appCapability.setVideoStreamingCapability(castedCapability);", "originalCommit": "07cad3e9ced2b256970ecf988ec5273944915409", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzAyOTM4OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r577029388", "bodyText": "Hello @kostyaBoss, per this comment:\n\nMobile checks both the root videoStreamingCapability and the additionalVideoStreamingCapabilities to see which ones it can support.\n\nWe should update getSupportedCapabilities(List<VideoStreamingRange>, List<VideoStreamingCapability>) to instead be getSupportedCapabilities(List<VideoStreamingRange>, VideoStreamingCapability)\nthe VideoStreamingCapability that is passed in will contain a VideoStreamingCapability at the root level as well as the list of additionalVideoStreamingCapabilities. We should be comparing the VideoStreamingCapability at the root level against the ranges as well as the list of additionalVideoStreamingCapabilities.\nCurrently the implementation is only comparing the list of additionalVideoStreamingCapabilities against the ranges.", "author": "RHenigan", "createdAt": "2021-02-16T18:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQzMzUzMw=="}], "type": "inlineReview", "revised_code": {"commit": "e5930f18a6befcf6b5d47b0e3051641502d46fa8", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex b9941f97b..274c1714b 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -394,17 +394,16 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n                         params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n                         VideoStreamManager.this.parameters = params;\n \n+                        VideoStreamingCapability capabilityToSend = new VideoStreamingCapability();\n                         if (listOfStreamingRanges != null) {\n                             // filtering\n-                            castedCapability.setAdditionalVideoStreamingCapabilities(\n-                                    getSupportedCapabilities(\n-                                            listOfStreamingRanges,\n-                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n-                                    )\n-                            );\n+                            capabilityToSend.setAdditionalVideoStreamingCapabilities(getSupportedCapabilities(\n+                                    listOfStreamingRanges,\n+                                    castedCapability.getAdditionalVideoStreamingCapabilities()\n+                            ));\n                         }\n                         AppCapability appCapability = new AppCapability(AppCapabilityType.VIDEO_STREAMING);\n-                        appCapability.setVideoStreamingCapability(castedCapability);\n+                        appCapability.setVideoStreamingCapability(capabilityToSend);\n \n                         OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(appCapability);\n                         internalInterface.sendRPC(onAppCapabilityUpdated);\n"}}, {"oid": "e5930f18a6befcf6b5d47b0e3051641502d46fa8", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e5930f18a6befcf6b5d47b0e3051641502d46fa8", "message": "[0296]\n- Implement latest cr's", "committedDate": "2021-02-16T10:02:40Z", "type": "commit"}, {"oid": "c53b422522d37fe3c3af7a118176b8505d98513a", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c53b422522d37fe3c3af7a118176b8505d98513a", "message": "[0238]\n- Fix PR comments", "committedDate": "2021-02-17T16:45:06Z", "type": "commit"}, {"oid": "d85f46863c14a37646a3972727fcaa6bb6fa6cfe", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/d85f46863c14a37646a3972727fcaa6bb6fa6cfe", "message": "[0238]\n- Apply stackOverFlow fix suggestion", "committedDate": "2021-02-18T16:35:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODY0OTM2OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r578649369", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!validCapabilities.contains(capability)) {\n          \n          \n            \n                                capability.setAdditionalVideoStreamingCapabilities(null);\n          \n          \n            \n                                if (!validCapabilities.contains(capability)) {\n          \n      \n    \n    \n  \n\nHello @kostyaBoss to avoid the edge case I discussed earlier from happening within the manager and to align to the iOS implementation we should set the additionalCapability of any capability to be added to null before it is added.", "author": "RHenigan", "createdAt": "2021-02-18T18:24:05Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +779,98 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            VideoStreamingCapability rootCapability\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        allCapabilities.add(rootCapability);\n+\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+            if (allCapabilities != null && !allCapabilities.isEmpty()) {\n+\n+                for (VideoStreamingCapability capability : allCapabilities) {\n+                    double diagonal;\n+                    if (capability.getPreferredResolution() == null\n+                            || capability.getPreferredResolution().getResolutionHeight() == null\n+                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                        continue;\n+                    }\n+                    if (capability.getDiagonalScreenSize() == null) {\n+                        diagonal = parameters.getPreferredDiagonal();\n+                    } else {\n+                        diagonal = capability.getDiagonalScreenSize();\n+                    }\n+\n+                    if (range.getMinScreenDiagonal() > diagonal) {\n+                        continue;\n+                    }\n+\n+                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n+                        if (constraintHeightMax == null && constraintHeightMin == null) {\n+                            continue;\n+                        }\n+                    }\n+\n+                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                        continue;\n+                    }\n+\n+                    if (!validCapabilities.contains(capability)) {", "originalCommit": "d85f46863c14a37646a3972727fcaa6bb6fa6cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39882aea315dd01f2cf6508438259362c36b3ad0", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex a91fb1c0b..87d98c192 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -790,7 +790,9 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n-        allCapabilities.add(rootCapability);\n+        if (allCapabilities != null){\n+            allCapabilities.add(rootCapability);\n+        }\n \n         for (VideoStreamingRange range: ranges) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODcwNjQ2MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r578706461", "bodyText": "@kostyaBoss this will cause an NPE is getAdditionalVideoStreamingCapabilities is null", "author": "RHenigan", "createdAt": "2021-02-18T19:56:31Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +779,98 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            VideoStreamingCapability rootCapability\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        allCapabilities.add(rootCapability);", "originalCommit": "d85f46863c14a37646a3972727fcaa6bb6fa6cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "39882aea315dd01f2cf6508438259362c36b3ad0", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex a91fb1c0b..87d98c192 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -790,7 +790,9 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n-        allCapabilities.add(rootCapability);\n+        if (allCapabilities != null){\n+            allCapabilities.add(rootCapability);\n+        }\n \n         for (VideoStreamingRange range: ranges) {\n \n"}}, {"oid": "39882aea315dd01f2cf6508438259362c36b3ad0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/39882aea315dd01f2cf6508438259362c36b3ad0", "message": "[0238]\n- Fix PR comments", "committedDate": "2021-02-18T20:26:01Z", "type": "commit"}, {"oid": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e7d650626c12c6d78d779e1047ece9d0f62c5fde", "message": "[0238]\n- Fix failing test", "committedDate": "2021-02-18T20:47:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDUzMjQwOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r580532408", "bodyText": "To maintain code style throughout the library please update this call to a single line rather than split the parameters across different lines.", "author": "RHenigan", "createdAt": "2021-02-22T19:32:53Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -139,12 +151,20 @@ public void onServiceStarted(SdlSession session, SessionType type, boolean isEnc\n         @Override\n         public void onServiceEnded(SdlSession session, SessionType type) {\n             if (SessionType.NAV.equals(type)) {\n-                stopVideoStream();\n-                if (remoteDisplay != null) {\n-                    stopStreaming();\n+                if (remoteDisplay !=null){\n+                    stopStreaming(withPendingRestart);\n                 }\n                 stateMachine.transitionToState(StreamingStateMachine.NONE);\n                 transitionToState(SETTING_UP);\n+\n+                if (withPendingRestart){\n+                    VideoStreamManager manager = VideoStreamManager.this;\n+                    manager.internalInterface.startVideoService(", "originalCommit": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 87d98c192..cdec1f9c9 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -159,11 +161,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n \n                 if (withPendingRestart){\n                     VideoStreamManager manager = VideoStreamManager.this;\n-                    manager.internalInterface.startVideoService(\n-                            manager.getLastCachedStreamingParameters(),\n-                            manager.isEncrypted,\n-                            withPendingRestart\n-                    );\n+                    manager.internalInterface.startVideoService(manager.getLastCachedStreamingParameters(), manager.isEncrypted, withPendingRestart);\n                 }\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDUzNDEwMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r580534100", "bodyText": "To maintain code style throughout the library please update this call to a single line rather than split the parameters across different lines.", "author": "RHenigan", "createdAt": "2021-02-22T19:35:01Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +358,56 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters) {\n+        final VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n         if (majorProtocolVersion >= 5) {\n             if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n                 internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                     @Override\n                     public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability) capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                        params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+\n+                        VideoStreamingCapability capabilityToSend = new VideoStreamingCapability();\n+                        if (listOfStreamingRanges != null) {\n+                            // filtering\n+                            capabilityToSend.setAdditionalVideoStreamingCapabilities(getSupportedCapabilities(", "originalCommit": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 87d98c192..cdec1f9c9 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -360,7 +359,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      */\n     @Deprecated\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, supportedPortraitStreamingRange, supportedLandscapeStreamingRange);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDUzNDY0MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r580534640", "bodyText": "If range is null this will cause an NPE", "author": "RHenigan", "createdAt": "2021-02-22T19:35:53Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +779,101 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            VideoStreamingCapability rootCapability\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities != null){\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();", "originalCommit": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 87d98c192..cdec1f9c9 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -783,50 +783,59 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         return parameters;\n     }\n \n-    private List<VideoStreamingCapability> getSupportedCapabilities(\n-            List<VideoStreamingRange> ranges,\n-            VideoStreamingCapability rootCapability\n-    ){\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (rootCapability == null || allCapabilities == null){\n+            return null;\n+        }\n         if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n         }\n \n-        for (VideoStreamingRange range: ranges) {\n-\n-            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n-            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n-            if (allCapabilities != null && !allCapabilities.isEmpty()) {\n-\n-                for (VideoStreamingCapability capability : allCapabilities) {\n-                    double diagonal;\n-                    if (capability.getPreferredResolution() == null\n-                            || capability.getPreferredResolution().getResolutionHeight() == null\n-                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n-                        continue;\n-                    }\n-                    if (capability.getDiagonalScreenSize() == null) {\n-                        diagonal = parameters.getPreferredDiagonal();\n-                    } else {\n-                        diagonal = capability.getDiagonalScreenSize();\n-                    }\n-\n-                    if (range.getMinScreenDiagonal() > diagonal) {\n-                        continue;\n-                    }\n-\n-                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n-                        if (constraintHeightMax == null && constraintHeightMin == null) {\n-                            continue;\n-                        }\n-                    }\n+        if (this.supportedLandscapeStreamingRange == null && this.supportedPortraitStreamingRange == null){\n+            for (VideoStreamingCapability capability: allCapabilities) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+            }\n \n-                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n-                        continue;\n-                    }\n+            validCapabilities.addAll(allCapabilities);\n+        } else if (supportedLandscapeStreamingRange != null && supportedPortraitStreamingRange == null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.LANDSCAPE){\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (supportedLandscapeStreamingRange == null && supportedPortraitStreamingRange != null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.PORTRAIT) {\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (isZeroRange(supportedPortraitStreamingRange) && isZeroRange(supportedLandscapeStreamingRange)) {\n+            return null;\n+        }else {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                ImageResolution imageResolution = capability.getPreferredResolution();\n+                boolean matches = false;\n+                switch (determineResolutionType(imageResolution)) {\n+                    case SQUARE:\n+                        matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                        break;\n+                    case PORTRAIT:\n+                        matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                        break;\n+                    case LANDSCAPE:\n+                        matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                        break;\n+                    default:\n+                        break;\n+                }\n \n+                if (matches) {\n                     capability.setAdditionalVideoStreamingCapabilities(null);\n                     if (!validCapabilities.contains(capability)) {\n                         validCapabilities.add(capability);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDUzNDg3MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r580534870", "bodyText": "To maintain code style throughout the library please update this method signature to a single line rather than split the parameters across different lines.", "author": "RHenigan", "createdAt": "2021-02-22T19:36:16Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +779,101 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(", "originalCommit": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 87d98c192..cdec1f9c9 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -783,50 +783,59 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         return parameters;\n     }\n \n-    private List<VideoStreamingCapability> getSupportedCapabilities(\n-            List<VideoStreamingRange> ranges,\n-            VideoStreamingCapability rootCapability\n-    ){\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (rootCapability == null || allCapabilities == null){\n+            return null;\n+        }\n         if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n         }\n \n-        for (VideoStreamingRange range: ranges) {\n-\n-            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n-            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n-            if (allCapabilities != null && !allCapabilities.isEmpty()) {\n-\n-                for (VideoStreamingCapability capability : allCapabilities) {\n-                    double diagonal;\n-                    if (capability.getPreferredResolution() == null\n-                            || capability.getPreferredResolution().getResolutionHeight() == null\n-                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n-                        continue;\n-                    }\n-                    if (capability.getDiagonalScreenSize() == null) {\n-                        diagonal = parameters.getPreferredDiagonal();\n-                    } else {\n-                        diagonal = capability.getDiagonalScreenSize();\n-                    }\n-\n-                    if (range.getMinScreenDiagonal() > diagonal) {\n-                        continue;\n-                    }\n-\n-                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n-                        if (constraintHeightMax == null && constraintHeightMin == null) {\n-                            continue;\n-                        }\n-                    }\n+        if (this.supportedLandscapeStreamingRange == null && this.supportedPortraitStreamingRange == null){\n+            for (VideoStreamingCapability capability: allCapabilities) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+            }\n \n-                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n-                        continue;\n-                    }\n+            validCapabilities.addAll(allCapabilities);\n+        } else if (supportedLandscapeStreamingRange != null && supportedPortraitStreamingRange == null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.LANDSCAPE){\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (supportedLandscapeStreamingRange == null && supportedPortraitStreamingRange != null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.PORTRAIT) {\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (isZeroRange(supportedPortraitStreamingRange) && isZeroRange(supportedLandscapeStreamingRange)) {\n+            return null;\n+        }else {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                ImageResolution imageResolution = capability.getPreferredResolution();\n+                boolean matches = false;\n+                switch (determineResolutionType(imageResolution)) {\n+                    case SQUARE:\n+                        matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                        break;\n+                    case PORTRAIT:\n+                        matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                        break;\n+                    case LANDSCAPE:\n+                        matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                        break;\n+                    default:\n+                        break;\n+                }\n \n+                if (matches) {\n                     capability.setAdditionalVideoStreamingCapabilities(null);\n                     if (!validCapabilities.contains(capability)) {\n                         validCapabilities.add(capability);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDUzNTY0MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r580535640", "bodyText": "To maintain code style throughout the library please update this method signature to a single line rather than split the parameters across different lines.", "author": "RHenigan", "createdAt": "2021-02-22T19:37:26Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minResolution;\n+    private Resolution maxResolution;\n+    private Double minScreenDiagonal;\n+    private Double minAspectRatio;\n+    private Double maxAspectRatio;\n+\n+    public VideoStreamingRange(", "originalCommit": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex 2e8a4ff6c..32aa99915 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -7,13 +7,7 @@ public class VideoStreamingRange {\n     private Double minAspectRatio;\n     private Double maxAspectRatio;\n \n-    public VideoStreamingRange(\n-            Resolution minResolution,\n-            Resolution maxResolution,\n-            Double minScreenDiagonal,\n-            Double minAspectRatio,\n-            Double maxAspectRatio\n-    ) {\n+    public VideoStreamingRange(Resolution minResolution, Resolution maxResolution, Double minScreenDiagonal, Double minAspectRatio, Double maxAspectRatio) {\n         this.minResolution = minResolution;\n         this.maxResolution = maxResolution;\n         this.minScreenDiagonal = minScreenDiagonal;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDUzODI3Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r580538273", "bodyText": "A Builder is not necessary for this class and should be removed.\nsetters should be added. This class should be a very simple data structure.\nTo keep the setters chainable you can return VideoStreamingRange, i.e.\npublic VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n        this.minResolution = minSupportedResolution;\n        return this;\n    }", "author": "RHenigan", "createdAt": "2021-02-22T19:41:42Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minResolution;\n+    private Resolution maxResolution;\n+    private Double minScreenDiagonal;\n+    private Double minAspectRatio;\n+    private Double maxAspectRatio;\n+\n+    public VideoStreamingRange(\n+            Resolution minResolution,\n+            Resolution maxResolution,\n+            Double minScreenDiagonal,\n+            Double minAspectRatio,\n+            Double maxAspectRatio\n+    ) {\n+        this.minResolution = minResolution;\n+        this.maxResolution = maxResolution;\n+        this.minScreenDiagonal = minScreenDiagonal;\n+        this.minAspectRatio = minAspectRatio;\n+        this.maxAspectRatio = maxAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinResolution() {\n+        return minResolution;\n+    }\n+\n+    public Resolution getMaxResolution() {\n+        return maxResolution;\n+    }\n+\n+    public Double getMinScreenDiagonal() {\n+        return minScreenDiagonal;\n+    }\n+\n+    public Double getMinAspectRatio() {\n+        return minAspectRatio;\n+    }\n+\n+    public Double getMaxAspectRatio() {\n+        return maxAspectRatio;\n+    }\n+\n+    public static class Builder {", "originalCommit": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex 2e8a4ff6c..32aa99915 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -7,13 +7,7 @@ public class VideoStreamingRange {\n     private Double minAspectRatio;\n     private Double maxAspectRatio;\n \n-    public VideoStreamingRange(\n-            Resolution minResolution,\n-            Resolution maxResolution,\n-            Double minScreenDiagonal,\n-            Double minAspectRatio,\n-            Double maxAspectRatio\n-    ) {\n+    public VideoStreamingRange(Resolution minResolution, Resolution maxResolution, Double minScreenDiagonal, Double minAspectRatio, Double maxAspectRatio) {\n         this.minResolution = minResolution;\n         this.maxResolution = maxResolution;\n         this.minScreenDiagonal = minScreenDiagonal;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDU1NzAyMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r580557023", "bodyText": "After Aligning changes with the iOS library there are some cases that were not accounted for or not aligned between the two libraries. Mainly these changes are to decide what it means if the developer set a null range or a range where the Resolutions are (0, 0) and how to handle these cases.\n\nIf both supportedPortraitStreamingRange and supportedLandscapeStreamingRange are not set or set to null by the developer, then the mobile library will support all VideoStreamingCapabilities returned by the module. This is done to ensure that streaming works as intended for developers who don't update the library to add the supportedPortraitStreamingRange and supportedLandscapeStreamingRange parameters.\nTo disable either supportedPortraitStreamingRange or supportedLandscapeStreamingRange, the developer has to set a VideoStreamingRange with the minimumResolution and maximumResolution set to 0 width and 0 height. If the developer chooses to disable both supportedPortraitStreamingRange and supportedLandscapeStreamingRange, video will not stream.\nIf supportedPortraitStreamingRange is not set or was set to null then the library will assume that all VideoStreamingCapabilities with a portrait aspect ratio are supported. The same is true if supportedLandscapeStreamingRange is not set; the library will assume that all VideoStreamingCapabilities with a landscape aspect ratio are supported.\n\nFor point 3) please refer to the iOS implementation on how to determine if a capability is a portrait or landscape capability\nmatchVideoCapability and isCapability in this file\nas well as SDLImageResolutionKind in this file", "author": "RHenigan", "createdAt": "2021-02-22T20:10:54Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +779,101 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            VideoStreamingCapability rootCapability\n+    ){", "originalCommit": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 87d98c192..cdec1f9c9 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -783,50 +783,59 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         return parameters;\n     }\n \n-    private List<VideoStreamingCapability> getSupportedCapabilities(\n-            List<VideoStreamingRange> ranges,\n-            VideoStreamingCapability rootCapability\n-    ){\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (rootCapability == null || allCapabilities == null){\n+            return null;\n+        }\n         if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n         }\n \n-        for (VideoStreamingRange range: ranges) {\n-\n-            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n-            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n-            if (allCapabilities != null && !allCapabilities.isEmpty()) {\n-\n-                for (VideoStreamingCapability capability : allCapabilities) {\n-                    double diagonal;\n-                    if (capability.getPreferredResolution() == null\n-                            || capability.getPreferredResolution().getResolutionHeight() == null\n-                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n-                        continue;\n-                    }\n-                    if (capability.getDiagonalScreenSize() == null) {\n-                        diagonal = parameters.getPreferredDiagonal();\n-                    } else {\n-                        diagonal = capability.getDiagonalScreenSize();\n-                    }\n-\n-                    if (range.getMinScreenDiagonal() > diagonal) {\n-                        continue;\n-                    }\n-\n-                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n-                        if (constraintHeightMax == null && constraintHeightMin == null) {\n-                            continue;\n-                        }\n-                    }\n+        if (this.supportedLandscapeStreamingRange == null && this.supportedPortraitStreamingRange == null){\n+            for (VideoStreamingCapability capability: allCapabilities) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+            }\n \n-                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n-                        continue;\n-                    }\n+            validCapabilities.addAll(allCapabilities);\n+        } else if (supportedLandscapeStreamingRange != null && supportedPortraitStreamingRange == null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.LANDSCAPE){\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (supportedLandscapeStreamingRange == null && supportedPortraitStreamingRange != null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.PORTRAIT) {\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (isZeroRange(supportedPortraitStreamingRange) && isZeroRange(supportedLandscapeStreamingRange)) {\n+            return null;\n+        }else {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                ImageResolution imageResolution = capability.getPreferredResolution();\n+                boolean matches = false;\n+                switch (determineResolutionType(imageResolution)) {\n+                    case SQUARE:\n+                        matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                        break;\n+                    case PORTRAIT:\n+                        matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                        break;\n+                    case LANDSCAPE:\n+                        matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                        break;\n+                    default:\n+                        break;\n+                }\n \n+                if (matches) {\n                     capability.setAdditionalVideoStreamingCapabilities(null);\n                     if (!validCapabilities.contains(capability)) {\n                         validCapabilities.add(capability);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDU2NTUyNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r580565526", "bodyText": "Hello @kostyaBoss per this comment\nIf the developer uses this methos we should assume that the ranges are null and there for all capabilities would be supported.", "author": "RHenigan", "createdAt": "2021-02-22T20:24:46Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +358,56 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){", "originalCommit": "e7d650626c12c6d78d779e1047ece9d0f62c5fde", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 87d98c192..cdec1f9c9 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -360,7 +359,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      */\n     @Deprecated\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, supportedPortraitStreamingRange, supportedLandscapeStreamingRange);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n"}}, {"oid": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-02-23T16:27:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjIzMDExMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582230110", "bodyText": "This enum will only be fore use inside of the library and because of this we should add a @RestrictTo annotation\n@RestrictTo(RestrictTo.Scope.LIBRARY)", "author": "RHenigan", "createdAt": "2021-02-24T19:12:02Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/ImageResolutionKind.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public enum ImageResolutionKind {", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/ImageResolutionKind.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/ImageResolutionKind.java\nindex cc8a034f6..55c77f15a 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/ImageResolutionKind.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/ImageResolutionKind.java\n\n@@ -1,5 +1,8 @@\n package com.smartdevicelink.managers.video.resolution;\n \n+import androidx.annotation.RestrictTo;\n+\n+@RestrictTo(RestrictTo.Scope.LIBRARY)\n public enum ImageResolutionKind {\n     PORTRAIT, LANDSCAPE, SQUARE, UNDEFINED\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjIzMTI4Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582231282", "bodyText": "This should be a float value as it is a ratio\n float ratio = resolution.getResolutionWidth().floatValue() / resolution.getResolutionHeight().floatValue();\nIf we change ratio to a float we will also have to change ratioSquard from ratio ^ 2 to ratio * ratio", "author": "RHenigan", "createdAt": "2021-02-24T19:13:57Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -864,16 +917,32 @@ public Boolean isAspectRatioInRange(Double aspectRatioMin, Double aspectRatioMax\n \n         Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n \n-        if (aspectRatioMax != null &&\n-                aspectRatioMin != null &&\n-                aspectRatioMax > aspectRatioMin &&\n-                aspectRatioMin > 0) {\n+        if (aspectRatioMax != null && aspectRatioMin != null && aspectRatioMax > aspectRatioMin && aspectRatioMin > 0) {\n             return currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax;\n         } else {\n             return false;\n         }\n     }\n \n+    private ImageResolutionKind determineResolutionType(ImageResolution resolution) {\n+        if (resolution == null) {\n+            return ImageResolutionKind.UNDEFINED;\n+        }\n+        if (resolution.getResolutionHeight() == null || resolution.getResolutionWidth() == null || resolution.getResolutionWidth() <= 0 || resolution.getResolutionHeight() <= 0) {\n+            return ImageResolutionKind.UNDEFINED;\n+        }\n+        int ratio = resolution.getResolutionWidth() / resolution.getResolutionHeight();", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -931,8 +930,8 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         if (resolution.getResolutionHeight() == null || resolution.getResolutionWidth() == null || resolution.getResolutionWidth() <= 0 || resolution.getResolutionHeight() <= 0) {\n             return ImageResolutionKind.UNDEFINED;\n         }\n-        int ratio = resolution.getResolutionWidth() / resolution.getResolutionHeight();\n-        float ratioSquared = ratio ^ 2;\n+        float ratio = resolution.getResolutionWidth().floatValue() / resolution.getResolutionHeight().floatValue();\n+        float ratioSquared = ratio * ratio;\n         float tolerance = 0.001f;\n         if (ratioSquared < 1.0 - tolerance) {\n             return ImageResolutionKind.PORTRAIT;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjIzNDg3OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582234878", "bodyText": "If rootCapability is null this null check will be too late as the line above will throw an npe when calling rootCapability.getAdditionalVideoStreamingCapabilities()", "author": "RHenigan", "createdAt": "2021-02-24T19:19:34Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -783,50 +783,59 @@ public VideoStreamingParameters getLastCachedStreamingParameters() {\n         return parameters;\n     }\n \n-    private List<VideoStreamingCapability> getSupportedCapabilities(\n-            List<VideoStreamingRange> ranges,\n-            VideoStreamingCapability rootCapability\n-    ){\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (rootCapability == null || allCapabilities == null){", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -786,10 +779,15 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n-        if (rootCapability == null || allCapabilities == null){\n+        if (allCapabilities == null){\n             return null;\n         }\n+\n         if (allCapabilities != null){\n             rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjIzNTUwNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582235504", "bodyText": "In this case we can return validCapabilities right after adding all capabilities", "author": "RHenigan", "createdAt": "2021-02-24T19:20:30Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -783,50 +783,59 @@ public VideoStreamingParameters getLastCachedStreamingParameters() {\n         return parameters;\n     }\n \n-    private List<VideoStreamingCapability> getSupportedCapabilities(\n-            List<VideoStreamingRange> ranges,\n-            VideoStreamingCapability rootCapability\n-    ){\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (rootCapability == null || allCapabilities == null){\n+            return null;\n+        }\n         if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n         }\n \n-        for (VideoStreamingRange range: ranges) {\n-\n-            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n-            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n-            if (allCapabilities != null && !allCapabilities.isEmpty()) {\n-\n-                for (VideoStreamingCapability capability : allCapabilities) {\n-                    double diagonal;\n-                    if (capability.getPreferredResolution() == null\n-                            || capability.getPreferredResolution().getResolutionHeight() == null\n-                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n-                        continue;\n-                    }\n-                    if (capability.getDiagonalScreenSize() == null) {\n-                        diagonal = parameters.getPreferredDiagonal();\n-                    } else {\n-                        diagonal = capability.getDiagonalScreenSize();\n-                    }\n-\n-                    if (range.getMinScreenDiagonal() > diagonal) {\n-                        continue;\n-                    }\n-\n-                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n-                        if (constraintHeightMax == null && constraintHeightMin == null) {\n-                            continue;\n-                        }\n-                    }\n+        if (this.supportedLandscapeStreamingRange == null && this.supportedPortraitStreamingRange == null){\n+            for (VideoStreamingCapability capability: allCapabilities) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+            }\n \n-                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n-                        continue;\n-                    }\n+            validCapabilities.addAll(allCapabilities);", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -786,10 +779,15 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n-        if (rootCapability == null || allCapabilities == null){\n+        if (allCapabilities == null){\n             return null;\n         }\n+\n         if (allCapabilities != null){\n             rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjIzNzEzNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582237134", "bodyText": "Per part 3 of this comment\nwe should be adding all Portrait capabilities if the developer passes a null portrait range\nif (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.PORTRAIT)", "author": "RHenigan", "createdAt": "2021-02-24T19:23:06Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -783,50 +783,59 @@ public VideoStreamingParameters getLastCachedStreamingParameters() {\n         return parameters;\n     }\n \n-    private List<VideoStreamingCapability> getSupportedCapabilities(\n-            List<VideoStreamingRange> ranges,\n-            VideoStreamingCapability rootCapability\n-    ){\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (rootCapability == null || allCapabilities == null){\n+            return null;\n+        }\n         if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n         }\n \n-        for (VideoStreamingRange range: ranges) {\n-\n-            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n-            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n-            if (allCapabilities != null && !allCapabilities.isEmpty()) {\n-\n-                for (VideoStreamingCapability capability : allCapabilities) {\n-                    double diagonal;\n-                    if (capability.getPreferredResolution() == null\n-                            || capability.getPreferredResolution().getResolutionHeight() == null\n-                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n-                        continue;\n-                    }\n-                    if (capability.getDiagonalScreenSize() == null) {\n-                        diagonal = parameters.getPreferredDiagonal();\n-                    } else {\n-                        diagonal = capability.getDiagonalScreenSize();\n-                    }\n-\n-                    if (range.getMinScreenDiagonal() > diagonal) {\n-                        continue;\n-                    }\n-\n-                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n-                        if (constraintHeightMax == null && constraintHeightMin == null) {\n-                            continue;\n-                        }\n-                    }\n+        if (this.supportedLandscapeStreamingRange == null && this.supportedPortraitStreamingRange == null){\n+            for (VideoStreamingCapability capability: allCapabilities) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+            }\n \n-                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n-                        continue;\n-                    }\n+            validCapabilities.addAll(allCapabilities);\n+        } else if (supportedLandscapeStreamingRange != null && supportedPortraitStreamingRange == null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.LANDSCAPE){", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -786,10 +779,15 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n-        if (rootCapability == null || allCapabilities == null){\n+        if (allCapabilities == null){\n             return null;\n         }\n+\n         if (allCapabilities != null){\n             rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjIzNzM0MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582237340", "bodyText": "Per part 3 of this comment\nwe should be adding all landscape capabilities if the developer passes a null landscape range\nif (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.LANDSCAPE)", "author": "RHenigan", "createdAt": "2021-02-24T19:23:25Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -783,50 +783,59 @@ public VideoStreamingParameters getLastCachedStreamingParameters() {\n         return parameters;\n     }\n \n-    private List<VideoStreamingCapability> getSupportedCapabilities(\n-            List<VideoStreamingRange> ranges,\n-            VideoStreamingCapability rootCapability\n-    ){\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (rootCapability == null || allCapabilities == null){\n+            return null;\n+        }\n         if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n         }\n \n-        for (VideoStreamingRange range: ranges) {\n-\n-            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n-            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n-            if (allCapabilities != null && !allCapabilities.isEmpty()) {\n-\n-                for (VideoStreamingCapability capability : allCapabilities) {\n-                    double diagonal;\n-                    if (capability.getPreferredResolution() == null\n-                            || capability.getPreferredResolution().getResolutionHeight() == null\n-                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n-                        continue;\n-                    }\n-                    if (capability.getDiagonalScreenSize() == null) {\n-                        diagonal = parameters.getPreferredDiagonal();\n-                    } else {\n-                        diagonal = capability.getDiagonalScreenSize();\n-                    }\n-\n-                    if (range.getMinScreenDiagonal() > diagonal) {\n-                        continue;\n-                    }\n-\n-                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n-                        if (constraintHeightMax == null && constraintHeightMin == null) {\n-                            continue;\n-                        }\n-                    }\n+        if (this.supportedLandscapeStreamingRange == null && this.supportedPortraitStreamingRange == null){\n+            for (VideoStreamingCapability capability: allCapabilities) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+            }\n \n-                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n-                        continue;\n-                    }\n+            validCapabilities.addAll(allCapabilities);\n+        } else if (supportedLandscapeStreamingRange != null && supportedPortraitStreamingRange == null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.LANDSCAPE){\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (supportedLandscapeStreamingRange == null && supportedPortraitStreamingRange != null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.PORTRAIT) {", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -786,10 +779,15 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n-        if (rootCapability == null || allCapabilities == null){\n+        if (allCapabilities == null){\n             return null;\n         }\n+\n         if (allCapabilities != null){\n             rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI0MDU4Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582240587", "bodyText": "This should not be an else condition, in the event that one of the ranges are null and the other isn't then we still need to check the capabilities against the non-null range.", "author": "RHenigan", "createdAt": "2021-02-24T19:28:07Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -783,50 +783,59 @@ public VideoStreamingParameters getLastCachedStreamingParameters() {\n         return parameters;\n     }\n \n-    private List<VideoStreamingCapability> getSupportedCapabilities(\n-            List<VideoStreamingRange> ranges,\n-            VideoStreamingCapability rootCapability\n-    ){\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (rootCapability == null || allCapabilities == null){\n+            return null;\n+        }\n         if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n         }\n \n-        for (VideoStreamingRange range: ranges) {\n-\n-            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n-            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n-            if (allCapabilities != null && !allCapabilities.isEmpty()) {\n-\n-                for (VideoStreamingCapability capability : allCapabilities) {\n-                    double diagonal;\n-                    if (capability.getPreferredResolution() == null\n-                            || capability.getPreferredResolution().getResolutionHeight() == null\n-                            || capability.getPreferredResolution().getResolutionWidth() == null) {\n-                        continue;\n-                    }\n-                    if (capability.getDiagonalScreenSize() == null) {\n-                        diagonal = parameters.getPreferredDiagonal();\n-                    } else {\n-                        diagonal = capability.getDiagonalScreenSize();\n-                    }\n-\n-                    if (range.getMinScreenDiagonal() > diagonal) {\n-                        continue;\n-                    }\n-\n-                    if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())) {\n-                        if (constraintHeightMax == null && constraintHeightMin == null) {\n-                            continue;\n-                        }\n-                    }\n+        if (this.supportedLandscapeStreamingRange == null && this.supportedPortraitStreamingRange == null){\n+            for (VideoStreamingCapability capability: allCapabilities) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+            }\n \n-                    if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n-                        continue;\n-                    }\n+            validCapabilities.addAll(allCapabilities);\n+        } else if (supportedLandscapeStreamingRange != null && supportedPortraitStreamingRange == null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.LANDSCAPE){\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (supportedLandscapeStreamingRange == null && supportedPortraitStreamingRange != null) {\n+            for (VideoStreamingCapability capability : allCapabilities) {\n+                if (determineResolutionType(capability.getPreferredResolution()) == ImageResolutionKind.PORTRAIT) {\n+                    capability.setAdditionalVideoStreamingCapabilities(null);\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        } else if (isZeroRange(supportedPortraitStreamingRange) && isZeroRange(supportedLandscapeStreamingRange)) {\n+            return null;\n+        }else {", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjgwNDIwMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582804200", "bodyText": "@RHenigan Hi! I am a little bit confused with this comment because from my understanding the null-safety is covered by the lines 803-817. Please, let me know If I am missing something - I will be ready to introduce the fix ASAP", "author": "kboskin", "createdAt": "2021-02-25T12:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI0MDU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjg2NjAyNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582866026", "bodyText": "Helo @kostyaBoss,\nlines 803-817 here are checking if only one of the ranges is null, If one range is null then capabilities of that type are added to valid capabilities. But after that we still need to check against the non-null range and compare the capabilities to that range.\ni.e.\nlandScapeRange == null and portraitRange != null\nAll the landScape Capabilities are added to validCapabilities\nNow we need to compare the capabilities received to the portraitRange that the developer has defined\nAdd any capabilities that match the portraitRange to validCapabilities\nAnd the reverse would also need to happen if landScapeRange != null and portraitRange == null\nWith that being the case, I think this method can be simplified, looking at the iOS implementation here\ngetSupportedCapability would iterate over the list of capabilities\nIdentify the ImageResoultionType\ncall inRange with the capability and the correct Range\nand inRange will return true if the range is null or the range matches, and false if the range does not match or is ZeroRange", "author": "RHenigan", "createdAt": "2021-02-25T14:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI0MDU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjg4NTMzOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582885339", "bodyText": "@RHenigan thanks for the detailed reply, checking now", "author": "kboskin", "createdAt": "2021-02-25T14:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI0MDU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjkxNzkwMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582917903", "bodyText": "@RHenigan could you please confirm the changes are suitable? Pushed the latest version into this PR", "author": "kboskin", "createdAt": "2021-02-25T15:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI0MDU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -786,10 +779,15 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n \n         List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n         List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n-        if (rootCapability == null || allCapabilities == null){\n+        if (allCapabilities == null){\n             return null;\n         }\n+\n         if (allCapabilities != null){\n             rootCapability.setAdditionalVideoStreamingCapabilities(null);\n             allCapabilities.add(rootCapability);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI0MjU2Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582242563", "bodyText": "These values are getting set twice right after each other, I think it is better to leave the setting of these two values to the configureGlobalParameters method", "author": "RHenigan", "createdAt": "2021-02-24T19:31:09Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -340,8 +338,9 @@ public void onError(String info) {\n      * @param portraitRange     constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n      */\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n-        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n-        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        this.supportedPortraitStreamingRange = portraitRange;\n+        this.supportedLandscapeStreamingRange = landscapeRange;", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -338,8 +338,6 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      * @param portraitRange     constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n      */\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n-        this.supportedPortraitStreamingRange = portraitRange;\n-        this.supportedLandscapeStreamingRange = landscapeRange;\n         configureGlobalParameters(context, remoteDisplayClass, isEncrypted, portraitRange, landscapeRange);\n         if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI0NTAwOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582245008", "bodyText": "If the developer continues to use this method we should pass null ranges", "author": "RHenigan", "createdAt": "2021-02-24T19:35:01Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -360,7 +359,7 @@ public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteD\n      */\n     @Deprecated\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, supportedPortraitStreamingRange, supportedLandscapeStreamingRange);", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -359,7 +357,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      */\n     @Deprecated\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, supportedPortraitStreamingRange, supportedLandscapeStreamingRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI0NzAyMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r582247022", "bodyText": "With the proposed changes we should allow these values to be set to null as this will indicate that all ranges or all ranges of that type are supported\nthis.supportedPortraitStreamingRange = portraitRange;\nthis.supportedLandscapeStreamingRange = landscapeRange;", "author": "RHenigan", "createdAt": "2021-02-24T19:37:59Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -370,13 +369,17 @@ public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteD\n         processCapabilitiesWithPendingStart(encrypted, parameters);\n     }\n \n-    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange portraitRange, VideoStreamingRange landscapeRange) {\n         this.context = new WeakReference<>(context);\n         this.remoteDisplayClass = remoteDisplayClass;\n         this.isEncrypted = encrypted;\n         this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-        if (listOfStreamingRange != null) {\n-            this.listOfStreamingRanges = listOfStreamingRange;\n+        if (portraitRange != null) {", "originalCommit": "81fa63cda1c4084fff46d12a7e3ec1aa89865e90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex cdec1f9c9..fc5146c6e 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -374,13 +372,8 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         this.remoteDisplayClass = remoteDisplayClass;\n         this.isEncrypted = encrypted;\n         this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-        if (portraitRange != null) {\n-            this.supportedPortraitStreamingRange = portraitRange;\n-        }\n-\n-        if (landscapeRange != null) {\n-            this.supportedLandscapeStreamingRange = landscapeRange;\n-        }\n+        this.supportedPortraitStreamingRange = portraitRange;\n+        this.supportedLandscapeStreamingRange = landscapeRange;\n     }\n \n \n"}}, {"oid": "a9a023933eb6a12f7ec37823422f048dfcb8f796", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a9a023933eb6a12f7ec37823422f048dfcb8f796", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-02-25T12:43:44Z", "type": "commit"}, {"oid": "175f8974f0f73be5a09b223dc3cc7971850f1536", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/175f8974f0f73be5a09b223dc3cc7971850f1536", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-02-25T15:16:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzEwMjk3MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r583102970", "bodyText": "A Null range will indicate no restrictions on the capabilities send so it should return true in this case", "author": "RHenigan", "createdAt": "2021-02-25T19:23:02Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +771,155 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return false;", "originalCommit": "175f8974f0f73be5a09b223dc3cc7971850f1536", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 0643b20de..69a187553 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -825,7 +827,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             return false;\n         }\n         if (range == null) {\n-            return false;\n+            return true;\n         }\n \n         if (isZeroRange(range)){\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzExMTI1Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r583111253", "bodyText": "In the unlikely event that the developer has:\n\ndisabled both portrait and landscape streaming ranges by setting the min/max to 0\nhas set a portrait and landscape range that that is not supported by the module\nWe should not send an OnAppCapabilityUpdated notification and we transition the state machine to stopped, since we will not stream the video\n\nif (capabilityToSend.getAdditionalVideoStreamingCapabilities() == null) {\n    stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n    return;\n}\n.......", "author": "RHenigan", "createdAt": "2021-02-25T19:36:39Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +354,52 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange portraitRange, VideoStreamingRange landscapeRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        this.supportedPortraitStreamingRange = portraitRange;\n+        this.supportedLandscapeStreamingRange = landscapeRange;\n+    }\n+\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters) {\n+        final VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n         if (majorProtocolVersion >= 5) {\n             if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n                 internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                     @Override\n                     public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability) capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                        params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+\n+                        VideoStreamingCapability capabilityToSend = new VideoStreamingCapability();\n+                        capabilityToSend.setAdditionalVideoStreamingCapabilities(getSupportedCapabilities(castedCapability));", "originalCommit": "175f8974f0f73be5a09b223dc3cc7971850f1536", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 0643b20de..69a187553 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -392,14 +392,16 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n                         VideoStreamingCapability capabilityToSend = new VideoStreamingCapability();\n                         capabilityToSend.setAdditionalVideoStreamingCapabilities(getSupportedCapabilities(castedCapability));\n \n+                        if (capabilityToSend.getAdditionalVideoStreamingCapabilities() == null) {\n+                            stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n+                            return;\n+                        }\n                         AppCapability appCapability = new AppCapability(AppCapabilityType.VIDEO_STREAMING);\n                         appCapability.setVideoStreamingCapability(capabilityToSend);\n \n                         OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(appCapability);\n                         internalInterface.sendRPC(onAppCapabilityUpdated);\n-                        if (capabilityToSend.getAdditionalVideoStreamingCapabilities() != null) {\n-                            startStreaming(params, isEncrypted);\n-                        }\n+                        startStreaming(params, isEncrypted);\n                     }\n \n                     @Override\n"}}, {"oid": "682c15692a3c666d3e27163cb309a619e8f5fbfa", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/682c15692a3c666d3e27163cb309a619e8f5fbfa", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "committedDate": "2021-02-25T20:13:40Z", "type": "commit"}, {"oid": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-02-25T20:22:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzczMTQxNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r583731415", "bodyText": "Hello @kostyaBoss\nTo maintain alignment with the iOS library this method should be moved to the VideoStreamingRange class and only take in the ImageResolution as a parameter\npublic Boolean isImageResolutionInRange(ImageResolution imageResolution) {}", "author": "RHenigan", "createdAt": "2021-02-26T15:45:34Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +773,155 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return true;\n+        }\n+\n+        if (isZeroRange(range)){\n+            return false;\n+        }\n+\n+        if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())){\n+            return false;\n+        }\n+\n+        if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())){\n+            return false;\n+        }\n+\n+        double diagonal;\n+        if (capability.getDiagonalScreenSize() == null) {\n+            diagonal = parameters.getPreferredDiagonal();\n+        } else {\n+            diagonal = capability.getDiagonalScreenSize();\n+        }\n+\n+        if (range.getMinScreenDiagonal() > diagonal) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isZeroRange(VideoStreamingRange range){\n+        if (range == null || range.getMaxResolution() == null || range.getMinResolution() == null){\n+            return true;\n+        }\n+        return isZeroResolution(range.getMaxResolution()) && isZeroResolution(range.getMinResolution());\n+    }\n+\n+    private boolean isZeroResolution(Resolution resolution){\n+        if (resolution == null) {\n+            return true;\n+        }\n+        return resolution.getResolutionHeight() != null && resolution.getResolutionWidth() != null && resolution.getResolutionHeight() <= 0 && resolution.getResolutionWidth() <= 0;\n+    }\n+\n+    private Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {", "originalCommit": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18dd57cd46b201064099dd25ebd0831299d2c44b", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 69a187553..5fd0ce283 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -834,11 +843,11 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             return false;\n         }\n \n-        if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())){\n+        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n             return false;\n         }\n \n-        if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())){\n+        if (!range.isAspectRatioInRange(capability.getPreferredResolution())){\n             return false;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzczMjE0NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r583732144", "bodyText": "Hello @kostyaBoss\nTo maintain alignment with the iOS library this method should be moved to the VideoStreamingRange class and only take in the aspect ratio as a parameter\npublic Boolean isAspectRatioInRange(Double aspectRatio) {}", "author": "RHenigan", "createdAt": "2021-02-26T15:46:38Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +773,155 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return true;\n+        }\n+\n+        if (isZeroRange(range)){\n+            return false;\n+        }\n+\n+        if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())){\n+            return false;\n+        }\n+\n+        if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())){\n+            return false;\n+        }\n+\n+        double diagonal;\n+        if (capability.getDiagonalScreenSize() == null) {\n+            diagonal = parameters.getPreferredDiagonal();\n+        } else {\n+            diagonal = capability.getDiagonalScreenSize();\n+        }\n+\n+        if (range.getMinScreenDiagonal() > diagonal) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isZeroRange(VideoStreamingRange range){\n+        if (range == null || range.getMaxResolution() == null || range.getMinResolution() == null){\n+            return true;\n+        }\n+        return isZeroResolution(range.getMaxResolution()) && isZeroResolution(range.getMinResolution());\n+    }\n+\n+    private boolean isZeroResolution(Resolution resolution){\n+        if (resolution == null) {\n+            return true;\n+        }\n+        return resolution.getResolutionHeight() != null && resolution.getResolutionWidth() != null && resolution.getResolutionHeight() <= 0 && resolution.getResolutionWidth() <= 0;\n+    }\n+\n+    private Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public Boolean isAspectRatioInRange(Double aspectRatioMin, Double aspectRatioMax, ImageResolution currentResolution) {", "originalCommit": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18dd57cd46b201064099dd25ebd0831299d2c44b", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 69a187553..5fd0ce283 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -834,11 +843,11 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             return false;\n         }\n \n-        if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())){\n+        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n             return false;\n         }\n \n-        if (!isAspectRatioInRange(range.getMinAspectRatio(), range.getMaxAspectRatio(), capability.getPreferredResolution())){\n+        if (!range.isAspectRatioInRange(capability.getPreferredResolution())){\n             return false;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzczNTk2Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r583735963", "bodyText": "Hello @kostyaBoss,\nTo maintain alignment with the iOS library we should update these parameter names to the names listed below, the getter and setter methods should also have titles updated to match the new parameter names.\nprivate Double minimumAspectRatio;\nprivate Double maximumAspectRatio;\nprivate Double minimumDiagonal;\nprivate Resolution minimumResolution;\nprivate Resolution maximumResolution;\n\ngetMinimumAspectRatio(){}\n.....\ngetMaximumResolution(){}\nsetMinimumAspectRatio(){}\n.....\nsetMaximumResolution(){}", "author": "RHenigan", "createdAt": "2021-02-26T15:52:04Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minResolution;\n+    private Resolution maxResolution;\n+    private Double minScreenDiagonal;\n+    private Double minAspectRatio;\n+    private Double maxAspectRatio;", "originalCommit": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18dd57cd46b201064099dd25ebd0831299d2c44b", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex 32aa99915..fa0216c5d 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -1,65 +1,101 @@\n package com.smartdevicelink.managers.video.resolution;\n \n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n public class VideoStreamingRange {\n-    private Resolution minResolution;\n-    private Resolution maxResolution;\n-    private Double minScreenDiagonal;\n-    private Double minAspectRatio;\n-    private Double maxAspectRatio;\n-\n-    public VideoStreamingRange(Resolution minResolution, Resolution maxResolution, Double minScreenDiagonal, Double minAspectRatio, Double maxAspectRatio) {\n-        this.minResolution = minResolution;\n-        this.maxResolution = maxResolution;\n-        this.minScreenDiagonal = minScreenDiagonal;\n-        this.minAspectRatio = minAspectRatio;\n-        this.maxAspectRatio = maxAspectRatio;\n+    private Resolution minimumResolution;\n+    private Resolution maximumResolution;\n+    private Double minimumDiagonal;\n+    private Double minimumAspectRatio;\n+    private Double maximumAspectRatio;\n+\n+    public VideoStreamingRange(Resolution minimumResolution, Resolution maximumResolution, Double minimumDiagonal, Double minimumAspectRatio, Double maximumAspectRatio) {\n+        this.minimumResolution = minimumResolution;\n+        this.maximumResolution = maximumResolution;\n+        this.minimumDiagonal = minimumDiagonal;\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        this.maximumAspectRatio = maximumAspectRatio;\n     }\n \n     private VideoStreamingRange() {\n     }\n \n-    public Resolution getMinResolution() {\n-        return minResolution;\n+    public Resolution getMinimumResolution() {\n+        return minimumResolution;\n     }\n \n-    public Resolution getMaxResolution() {\n-        return maxResolution;\n+    public Resolution getMaximumResolution() {\n+        return maximumResolution;\n     }\n \n-    public Double getMinScreenDiagonal() {\n-        return minScreenDiagonal;\n+    public Double getMinimumDiagonal() {\n+        return minimumDiagonal;\n     }\n \n-    public Double getMinAspectRatio() {\n-        return minAspectRatio;\n+    public Double getMinimumAspectRatio() {\n+        return minimumAspectRatio;\n     }\n \n-    public Double getMaxAspectRatio() {\n-        return maxAspectRatio;\n+    public Double getMaximumAspectRatio() {\n+        return maximumAspectRatio;\n     }\n \n     public VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n-        this.minResolution = minSupportedResolution;\n+        this.minimumResolution = minSupportedResolution;\n         return this;\n     }\n \n     public VideoStreamingRange setMaxSupportedResolution(Resolution maxSupportedResolution) {\n-        this.maxResolution = maxSupportedResolution;\n+        this.maximumResolution = maxSupportedResolution;\n         return this;\n     }\n \n-    public VideoStreamingRange setMinScreenDiagonal(Double minScreenDiagonal) {\n-        this.minScreenDiagonal = minScreenDiagonal;\n+    public VideoStreamingRange setMinimumDiagonal(Double minimumDiagonal) {\n+        this.minimumDiagonal = minimumDiagonal;\n         return this;\n     }\n \n-    public VideoStreamingRange setMinAspectRatio(Double minAspectRatio) {\n-        this.minAspectRatio = minAspectRatio;\n+    public VideoStreamingRange setMinimumAspectRatio(Double minimumAspectRatio) {\n+        this.minimumAspectRatio = minimumAspectRatio;\n         return this;\n     }\n \n-    public VideoStreamingRange setMaxAspectRatio(Double maxAspectRatio) {\n-        this.maxAspectRatio = maxAspectRatio;\n+    public VideoStreamingRange setMaximumAspectRatio(Double maximumAspectRatio) {\n+        this.maximumAspectRatio = maximumAspectRatio;\n         return this;\n     }\n+\n+    public Boolean isImageResolutionInRange(ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maximumResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minimumResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maximumResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minimumResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public Boolean isAspectRatioInRange(ImageResolution currentResolution) {\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (maximumAspectRatio != null && minimumAspectRatio != null && maximumAspectRatio > minimumAspectRatio && minimumAspectRatio > 0) {\n+            return currentAspectRatio >= minimumAspectRatio && currentAspectRatio <= maximumAspectRatio;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzc1MzkzNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r583753936", "bodyText": "Hello @kostyaBoss,\nI want to make sure that the documentation surrounding this method is clear to the developer. Please see the documentation below, to better align with the iOS library I also recommend change the parameter names from landscapeRange and portraitRange to supportedLandscapeStreamingRange and supportedPortraitStreamingRange\n/**\n     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n     * Two ranges (supportedLandscapeStreamingRange and supportedLandscapeStreamingRange) can be provided with image dimension ranges and aspect ratio ranges that your remoteDisplay class supports.\n     * If the module's screen size for your app changes during streaming (i.e. to a collapsed view, split screen, preview mode, or picture-in-picture), your remoteDisplay will be resized to the new screen size.\n     * If either range is `null`, the default is to support all streaming ranges of that format (landscape or portrait).\n     * If you wish to disable support for streaming in a given format (landscape or portrait), set a VideoStreamingRange with all `0` values.\n     *\n     * NOTE If both supportedLandscapeStreamingRange and supportedLandscapeStreamingRange are disabled then the video will not stream.\n     *\n     * Any changes to screen size will notify the onViewResized method you have implemented in your remoteDisplay class.\n     *\n     *\n     * @param context            a context that can be used to create the remote display\n     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n     *                           works best for the currently connected module.\n     * @param encrypted         a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n     * @param supportedLandscapeStreamingRange      constraints for vehicle display : min/max aspect ratio, min/max resolutions, max diagonal size.\n     * @param supportedLandscapeStreamingRange      constraints for vehicle display : min/max aspect ratio, min/max resolutions, max diagonal size.\n     */", "author": "RHenigan", "createdAt": "2021-02-26T16:17:59Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -274,6 +324,26 @@ public void onError(String info) {\n         }\n     }\n \n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted         a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange    constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange     constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {", "originalCommit": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18dd57cd46b201064099dd25ebd0831299d2c44b", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 69a187553..5fd0ce283 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -326,6 +326,15 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n \n     /**\n      * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     * Two ranges (supportedLandscapeStreamingRange and supportedLandscapeStreamingRange) can be provided with image dimension ranges and aspect ratio ranges that your remoteDisplay class supports.\n+     * If the module's screen size for your app changes during streaming (i.e. to a collapsed view, split screen, preview mode, or picture-in-picture), your remoteDisplay will be resized to the new screen size.\n+     * If either range is `null`, the default is to support all streaming ranges of that format (landscape or portrait).\n+     * If you wish to disable support for streaming in a given format (landscape or portrait), set a VideoStreamingRange with all `0` values.\n+     *\n+     * NOTE If both supportedLandscapeStreamingRange and supportedLandscapeStreamingRange are disabled then the video will not stream.\n+     *\n+     * Any changes to screen size will notify the onViewResized method you have implemented in your remoteDisplay class.\n+     *\n      *\n      * @param context            a context that can be used to create the remote display\n      * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzc1ODkzMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r583758932", "bodyText": "@kostyaBoss\nPlease update the documentation above to include the afterPendingRestart parameter\n@param afterPendingRestart specify true when the videoService is starting again after the display has been resized", "author": "RHenigan", "createdAt": "2021-02-26T16:25:13Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java", "diffHunk": "@@ -155,7 +155,7 @@ void startVideoService(boolean isEncrypted, VideoStreamingParameters parameters)\n      * @param isEncrypted Specify true if packets on this service have to be encrypted\n      * @param parameters  VideoStreamingParameters that are desired. Does not guarantee this is what will be accepted.\n      */\n-    private void tryStartVideoStream(boolean isEncrypted, VideoStreamingParameters parameters) {\n+    private void tryStartVideoStream(boolean isEncrypted, VideoStreamingParameters parameters, boolean afterPendingRestart) {", "originalCommit": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18dd57cd46b201064099dd25ebd0831299d2c44b", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java\nindex fbe02db98..1b54b0e1f 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java\n\n@@ -153,6 +154,7 @@ public class LifecycleManager extends BaseLifecycleManager {\n      * Only information from codecs, width and height are used during video format negotiation.\n      *\n      * @param isEncrypted Specify true if packets on this service have to be encrypted\n+     * @param afterPendingRestart specify true when the videoService is starting again after the display has been resized\n      * @param parameters  VideoStreamingParameters that are desired. Does not guarantee this is what will be accepted.\n      */\n     private void tryStartVideoStream(boolean isEncrypted, VideoStreamingParameters parameters, boolean afterPendingRestart) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzc1OTAxMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r583759012", "bodyText": "@kostyaBoss\nPlease update the documentation above to include the afterPendingRestart parameter\n@param afterPendingRestart specify true when the videoService is starting again after the display has been resized", "author": "RHenigan", "createdAt": "2021-02-26T16:25:19Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java", "diffHunk": "@@ -134,7 +134,7 @@ void onTransportDisconnected(String info, boolean availablePrimary, BaseTranspor\n      * @param parameters  the desired video streaming parameters\n      */\n     @Override\n-    void startVideoService(boolean isEncrypted, VideoStreamingParameters parameters) {\n+    void startVideoService(boolean isEncrypted, VideoStreamingParameters parameters, boolean afterPendingRestart) {", "originalCommit": "0fbbf300e8c968d33f35d04c57450dbb8b6d670f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18dd57cd46b201064099dd25ebd0831299d2c44b", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java\nindex fbe02db98..1b54b0e1f 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java\n\n@@ -131,6 +131,7 @@ public class LifecycleManager extends BaseLifecycleManager {\n      * When it returns it will attempt to store the accepted parameters if available.\n      *\n      * @param isEncrypted if the service should be encrypted\n+     * @param afterPendingRestart specify true when the videoService is starting again after the display has been resized\n      * @param parameters  the desired video streaming parameters\n      */\n     @Override\n"}}, {"oid": "18dd57cd46b201064099dd25ebd0831299d2c44b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/18dd57cd46b201064099dd25ebd0831299d2c44b", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-02-27T15:35:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkyNjQ3Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r585926476", "bodyText": "Hello @kostyaBoss,\nper the proposal revisions can you update this to take in the aspectRatio?\npublic Boolean isAspectRatioInRange(Double aspectRatio)", "author": "RHenigan", "createdAt": "2021-03-02T21:34:58Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minimumResolution;\n+    private Resolution maximumResolution;\n+    private Double minimumDiagonal;\n+    private Double minimumAspectRatio;\n+    private Double maximumAspectRatio;\n+\n+    public VideoStreamingRange(Resolution minimumResolution, Resolution maximumResolution, Double minimumDiagonal, Double minimumAspectRatio, Double maximumAspectRatio) {\n+        this.minimumResolution = minimumResolution;\n+        this.maximumResolution = maximumResolution;\n+        this.minimumDiagonal = minimumDiagonal;\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        this.maximumAspectRatio = maximumAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinimumResolution() {\n+        return minimumResolution;\n+    }\n+\n+    public Resolution getMaximumResolution() {\n+        return maximumResolution;\n+    }\n+\n+    public Double getMinimumDiagonal() {\n+        return minimumDiagonal;\n+    }\n+\n+    public Double getMinimumAspectRatio() {\n+        return minimumAspectRatio;\n+    }\n+\n+    public Double getMaximumAspectRatio() {\n+        return maximumAspectRatio;\n+    }\n+\n+    public VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n+        this.minimumResolution = minSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+        this.maximumResolution = maxSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumDiagonal(Double minimumDiagonal) {\n+        this.minimumDiagonal = minimumDiagonal;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumAspectRatio(Double minimumAspectRatio) {\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaximumAspectRatio(Double maximumAspectRatio) {\n+        this.maximumAspectRatio = maximumAspectRatio;\n+        return this;\n+    }\n+\n+    public Boolean isImageResolutionInRange(ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maximumResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minimumResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maximumResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minimumResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public Boolean isAspectRatioInRange(ImageResolution currentResolution) {", "originalCommit": "18dd57cd46b201064099dd25ebd0831299d2c44b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "adf067bb9019f085ed852f6112488a1b5bffc353", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex fa0216c5d..b35833397 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -87,12 +87,9 @@ public class VideoStreamingRange {\n         }\n     }\n \n-    public Boolean isAspectRatioInRange(ImageResolution currentResolution) {\n-\n-        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n-\n+    public Boolean isAspectRatioInRange(Double aspectRatio) {\n         if (maximumAspectRatio != null && minimumAspectRatio != null && maximumAspectRatio > minimumAspectRatio && minimumAspectRatio > 0) {\n-            return currentAspectRatio >= minimumAspectRatio && currentAspectRatio <= maximumAspectRatio;\n+            return aspectRatio >= minimumAspectRatio && aspectRatio <= maximumAspectRatio;\n         } else {\n             return false;\n         }\n"}}, {"oid": "adf067bb9019f085ed852f6112488a1b5bffc353", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/adf067bb9019f085ed852f6112488a1b5bffc353", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-03-03T13:12:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjY2OTc5MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r586669790", "bodyText": "Here we should also be checking if the list is empty,\nIf no ranges are supported the video should not be streamed", "author": "RHenigan", "createdAt": "2021-03-03T18:18:46Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +363,54 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange portraitRange, VideoStreamingRange landscapeRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        this.supportedPortraitStreamingRange = portraitRange;\n+        this.supportedLandscapeStreamingRange = landscapeRange;\n+    }\n+\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters) {\n+        final VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n         if (majorProtocolVersion >= 5) {\n             if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n                 internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                     @Override\n                     public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability) capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                        params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+\n+                        VideoStreamingCapability capabilityToSend = new VideoStreamingCapability();\n+                        capabilityToSend.setAdditionalVideoStreamingCapabilities(getSupportedCapabilities(castedCapability));\n+\n+                        if (capabilityToSend.getAdditionalVideoStreamingCapabilities() == null) {", "originalCommit": "adf067bb9019f085ed852f6112488a1b5bffc353", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 12513d25c..96fb7fde7 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -401,7 +401,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n                         VideoStreamingCapability capabilityToSend = new VideoStreamingCapability();\n                         capabilityToSend.setAdditionalVideoStreamingCapabilities(getSupportedCapabilities(castedCapability));\n \n-                        if (capabilityToSend.getAdditionalVideoStreamingCapabilities() == null) {\n+                        if (capabilityToSend.getAdditionalVideoStreamingCapabilities() == null || capabilityToSend.getAdditionalVideoStreamingCapabilities().isEmpty()) {\n                             stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n                             return;\n                         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjY4NTEyNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r586685127", "bodyText": "This should return false, the developer can set the minResolution or maxResolution in the range to null if they choose to only compare against aspectRatio and/or screen diagonal\nA range will be considered disabled if the minResolution and maxResolution are explicitly set to (0 width, 0 height)", "author": "RHenigan", "createdAt": "2021-03-03T18:40:53Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +782,124 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return true;\n+        }\n+\n+        if (isZeroRange(range)){\n+            return false;\n+        }\n+\n+        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n+            return false;\n+        }\n+\n+        ImageResolution resolution = capability.getPreferredResolution();\n+        Double currentAspectRatio = Double.valueOf(resolution.getResolutionWidth()) / Double.valueOf(resolution.getResolutionHeight());\n+        if (!range.isAspectRatioInRange(currentAspectRatio)){\n+            return false;\n+        }\n+\n+        double diagonal;\n+        if (capability.getDiagonalScreenSize() == null) {\n+            diagonal = parameters.getPreferredDiagonal();\n+        } else {\n+            diagonal = capability.getDiagonalScreenSize();\n+        }\n+\n+        if (range.getMinimumDiagonal() > diagonal) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isZeroRange(VideoStreamingRange range){\n+        if (range == null || range.getMaximumResolution() == null || range.getMinimumResolution() == null){\n+            return true;", "originalCommit": "adf067bb9019f085ed852f6112488a1b5bffc353", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 12513d25c..96fb7fde7 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -843,8 +843,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             return false;\n         }\n \n-        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n-            return false;\n+        if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n+            if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {\n+                return false;\n+            }\n         }\n \n         ImageResolution resolution = capability.getPreferredResolution();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjY4NTM0NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r586685344", "bodyText": "This should return false, the developer can set the minResolution or maxResolution in the range to null if they choose to only compare against aspectRatio and/or screen diagonal\nA range will be considered disabled if the minResolution and maxResolution are explicitly set to (0 width, 0 height)", "author": "RHenigan", "createdAt": "2021-03-03T18:41:12Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +782,124 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return true;\n+        }\n+\n+        if (isZeroRange(range)){\n+            return false;\n+        }\n+\n+        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n+            return false;\n+        }\n+\n+        ImageResolution resolution = capability.getPreferredResolution();\n+        Double currentAspectRatio = Double.valueOf(resolution.getResolutionWidth()) / Double.valueOf(resolution.getResolutionHeight());\n+        if (!range.isAspectRatioInRange(currentAspectRatio)){\n+            return false;\n+        }\n+\n+        double diagonal;\n+        if (capability.getDiagonalScreenSize() == null) {\n+            diagonal = parameters.getPreferredDiagonal();\n+        } else {\n+            diagonal = capability.getDiagonalScreenSize();\n+        }\n+\n+        if (range.getMinimumDiagonal() > diagonal) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isZeroRange(VideoStreamingRange range){\n+        if (range == null || range.getMaximumResolution() == null || range.getMinimumResolution() == null){\n+            return true;\n+        }\n+        return isZeroResolution(range.getMaximumResolution()) && isZeroResolution(range.getMinimumResolution());\n+    }\n+\n+    private boolean isZeroResolution(Resolution resolution){\n+        if (resolution == null) {\n+            return true;", "originalCommit": "adf067bb9019f085ed852f6112488a1b5bffc353", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 12513d25c..96fb7fde7 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -843,8 +843,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             return false;\n         }\n \n-        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n-            return false;\n+        if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n+            if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {\n+                return false;\n+            }\n         }\n \n         ImageResolution resolution = capability.getPreferredResolution();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjcwNDI4Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r586704282", "bodyText": "The developer can set the minAspectRatio or maxAspectRatio in the range to null if they choose to only compare against resolution and/or screen diagonal\nThis method should first check if both maximumAspectRatio and minimumAspectRatio are null and if they are null then it should return true\nThen it should check if the given ratio is in range.\npublic Boolean isAspectRatioInRange(Double aspectRatio) {\n        if (maximumAspectRatio == null && minimumAspectRatio == null) {\n            return true;\n        }\n\n        boolean isInRange = true;\n        if (minimumAspectRatio != null) {\n            isInRange = aspectRatio >= minimumAspectRatio;\n        }\n        if (isInRange && maximumAspectRatio != null) {\n            isInRange = aspectRatio <= maximumAspectRatio;\n        }\n        return isInRange;\n    }", "author": "RHenigan", "createdAt": "2021-03-03T19:08:08Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minimumResolution;\n+    private Resolution maximumResolution;\n+    private Double minimumDiagonal;\n+    private Double minimumAspectRatio;\n+    private Double maximumAspectRatio;\n+\n+    public VideoStreamingRange(Resolution minimumResolution, Resolution maximumResolution, Double minimumDiagonal, Double minimumAspectRatio, Double maximumAspectRatio) {\n+        this.minimumResolution = minimumResolution;\n+        this.maximumResolution = maximumResolution;\n+        this.minimumDiagonal = minimumDiagonal;\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        this.maximumAspectRatio = maximumAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinimumResolution() {\n+        return minimumResolution;\n+    }\n+\n+    public Resolution getMaximumResolution() {\n+        return maximumResolution;\n+    }\n+\n+    public Double getMinimumDiagonal() {\n+        return minimumDiagonal;\n+    }\n+\n+    public Double getMinimumAspectRatio() {\n+        return minimumAspectRatio;\n+    }\n+\n+    public Double getMaximumAspectRatio() {\n+        return maximumAspectRatio;\n+    }\n+\n+    public VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n+        this.minimumResolution = minSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+        this.maximumResolution = maxSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumDiagonal(Double minimumDiagonal) {\n+        this.minimumDiagonal = minimumDiagonal;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumAspectRatio(Double minimumAspectRatio) {\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaximumAspectRatio(Double maximumAspectRatio) {\n+        this.maximumAspectRatio = maximumAspectRatio;\n+        return this;\n+    }\n+\n+    public Boolean isImageResolutionInRange(ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maximumResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minimumResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maximumResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minimumResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public Boolean isAspectRatioInRange(Double aspectRatio) {", "originalCommit": "adf067bb9019f085ed852f6112488a1b5bffc353", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex b35833397..b2a395469 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -73,6 +73,23 @@ public class VideoStreamingRange {\n         Integer constraintWidthMin = minimumResolution.getResolutionWidth();\n         Integer resolutionHeight = currentResolution.getResolutionHeight();\n         Integer resolutionWidth = currentResolution.getResolutionWidth();\n+\n+        if (currentResolution == null) {\n+            return false;\n+        }\n+\n+        if (minimumResolution == null && maximumResolution == null) {\n+            return true;\n+        }\n+\n+        if (minimumResolution == null || (minimumResolution.getResolutionWidth() == 0 && minimumResolution.getResolutionHeight() == 0)) {\n+            return false;\n+        }\n+\n+        if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n+            return false;\n+        }\n+\n         if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n             if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n                 return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjcxMzAzMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r586713031", "bodyText": "MinDiagonal could be null if the developer does not want to specify a minimumDiagonal, we should make sure the minimumDiagonal is not null before comparign and if the minimumDiagonal is null it means the developer does not want to restrict capabilities based on this field\nif (range.getMinimumDiagonal() != null && range.getMinimumDiagonal() > diagonal) {\n     return false;\n}", "author": "RHenigan", "createdAt": "2021-03-03T19:21:52Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +782,124 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return true;\n+        }\n+\n+        if (isZeroRange(range)){\n+            return false;\n+        }\n+\n+        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n+            return false;\n+        }\n+\n+        ImageResolution resolution = capability.getPreferredResolution();\n+        Double currentAspectRatio = Double.valueOf(resolution.getResolutionWidth()) / Double.valueOf(resolution.getResolutionHeight());\n+        if (!range.isAspectRatioInRange(currentAspectRatio)){\n+            return false;\n+        }\n+\n+        double diagonal;\n+        if (capability.getDiagonalScreenSize() == null) {\n+            diagonal = parameters.getPreferredDiagonal();\n+        } else {\n+            diagonal = capability.getDiagonalScreenSize();\n+        }\n+\n+        if (range.getMinimumDiagonal() > diagonal) {", "originalCommit": "adf067bb9019f085ed852f6112488a1b5bffc353", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 12513d25c..96fb7fde7 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -843,8 +843,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             return false;\n         }\n \n-        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n-            return false;\n+        if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n+            if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {\n+                return false;\n+            }\n         }\n \n         ImageResolution resolution = capability.getPreferredResolution();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjcxNjI0Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r586716242", "bodyText": "The developer can set the minResolution and maxResolution in the range to null if they choose to only compare against aspectRatio and/or screen diagonal,\nIf both are null we should not perform this check\nif (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n         if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {\n             return false;\n            }\n         }", "author": "RHenigan", "createdAt": "2021-03-03T19:26:54Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +782,124 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return true;\n+        }\n+\n+        if (isZeroRange(range)){\n+            return false;\n+        }\n+\n+        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){", "originalCommit": "adf067bb9019f085ed852f6112488a1b5bffc353", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 12513d25c..96fb7fde7 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -843,8 +843,10 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n             return false;\n         }\n \n-        if (!range.isImageResolutionInRange(capability.getPreferredResolution())){\n-            return false;\n+        if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n+            if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {\n+                return false;\n+            }\n         }\n \n         ImageResolution resolution = capability.getPreferredResolution();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njc1NDAwMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r586754000", "bodyText": "A few additional checks should be made here,\nif the passed resolution is null we should return false (no resolution received from the capability)\nif both the minimumResolution and maximumResolution are null we should return true (the developer does not want to use resolution for the range)\nIf one of the reolutions (minimumResolution and maximumResolution) is null or set to 0 values it should return false (only one of the resolutions is null or the resolution has 0 values)\n        if (currentResolution == null) {\n            return false;\n        }\n\n        if (minimumResolution == null && maximumResolution == null) {\n            return true;\n        }\n\n        if (minimumResolution == null || (minimumResolution.getResolutionWidth() == 0 && minimumResolution.getResolutionHeight() == 0)) {\n            return false;\n        }\n\n        if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n            return false;\n        }", "author": "RHenigan", "createdAt": "2021-03-03T20:26:26Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minimumResolution;\n+    private Resolution maximumResolution;\n+    private Double minimumDiagonal;\n+    private Double minimumAspectRatio;\n+    private Double maximumAspectRatio;\n+\n+    public VideoStreamingRange(Resolution minimumResolution, Resolution maximumResolution, Double minimumDiagonal, Double minimumAspectRatio, Double maximumAspectRatio) {\n+        this.minimumResolution = minimumResolution;\n+        this.maximumResolution = maximumResolution;\n+        this.minimumDiagonal = minimumDiagonal;\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        this.maximumAspectRatio = maximumAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinimumResolution() {\n+        return minimumResolution;\n+    }\n+\n+    public Resolution getMaximumResolution() {\n+        return maximumResolution;\n+    }\n+\n+    public Double getMinimumDiagonal() {\n+        return minimumDiagonal;\n+    }\n+\n+    public Double getMinimumAspectRatio() {\n+        return minimumAspectRatio;\n+    }\n+\n+    public Double getMaximumAspectRatio() {\n+        return maximumAspectRatio;\n+    }\n+\n+    public VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n+        this.minimumResolution = minSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+        this.maximumResolution = maxSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumDiagonal(Double minimumDiagonal) {\n+        this.minimumDiagonal = minimumDiagonal;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumAspectRatio(Double minimumAspectRatio) {\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaximumAspectRatio(Double maximumAspectRatio) {\n+        this.maximumAspectRatio = maximumAspectRatio;\n+        return this;\n+    }\n+\n+    public Boolean isImageResolutionInRange(ImageResolution currentResolution) {\n+", "originalCommit": "adf067bb9019f085ed852f6112488a1b5bffc353", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzY0NDM5Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r587644392", "bodyText": "Hello @kostyaBoss, these checks should happen before initializing these local variables to avoid a NPE on maximumResolution.getResolutionHeight() or minimumResolution.getResolutionHeight()\nInteger constraintHeightMax = maximumResolution.getResolutionHeight();\nInteger constraintHeightMin = minimumResolution.getResolutionHeight();\nInteger constraintWidthMax = maximumResolution.getResolutionWidth();\nInteger constraintWidthMin = minimumResolution.getResolutionWidth();\nInteger resolutionHeight = currentResolution.getResolutionHeight();\nInteger resolutionWidth = currentResolution.getResolutionWidth();", "author": "RHenigan", "createdAt": "2021-03-04T16:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njc1NDAwMA=="}], "type": "inlineReview", "revised_code": {"commit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex b35833397..b2a395469 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -73,6 +73,23 @@ public class VideoStreamingRange {\n         Integer constraintWidthMin = minimumResolution.getResolutionWidth();\n         Integer resolutionHeight = currentResolution.getResolutionHeight();\n         Integer resolutionWidth = currentResolution.getResolutionWidth();\n+\n+        if (currentResolution == null) {\n+            return false;\n+        }\n+\n+        if (minimumResolution == null && maximumResolution == null) {\n+            return true;\n+        }\n+\n+        if (minimumResolution == null || (minimumResolution.getResolutionWidth() == 0 && minimumResolution.getResolutionHeight() == 0)) {\n+            return false;\n+        }\n+\n+        if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n+            return false;\n+        }\n+\n         if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n             if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n                 return false;\n"}}, {"oid": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "message": "[0296]\n- Fix pr comments", "committedDate": "2021-03-04T11:45:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzYzNzk3NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r587637974", "bodyText": "We need to adjust the resolution here based on the scale of the capability, a helper method can be added and we can call it with the capability we are testing against\nprivate Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n        \n        ...\n\n        if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n            if (!range.isImageResolutionInRange(makeScaledImageResolution(capability))) {\n                return false;\n            }\n        }\n        \n        ...\n\n}\n\nprivate ImageResolution makeScaledImageResolution(VideoStreamingCapability capability) {\n        if (capability.getScale() == null) {\n            return capability.getPreferredResolution();\n        } else {\n            double scaledWidth = (double) capability.getPreferredResolution().getResolutionWidth() / capability.getScale();\n            double scaledHeight = (double) capability.getPreferredResolution().getResolutionHeight() / capability.getScale();\n            return new ImageResolution((int) scaledWidth, (int) scaledHeight);\n        }\n    }", "author": "RHenigan", "createdAt": "2021-03-04T16:49:22Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +782,126 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return true;\n+        }\n+\n+        if (isZeroRange(range)){\n+            return false;\n+        }\n+\n+        if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n+            if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {", "originalCommit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 96fb7fde7..41af28cb1 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -844,15 +845,17 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         }\n \n         if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n-            if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {\n+            if (!range.isImageResolutionInRange(makeScaledImageResolution(capability))) {\n                 return false;\n             }\n         }\n \n         ImageResolution resolution = capability.getPreferredResolution();\n-        Double currentAspectRatio = Double.valueOf(resolution.getResolutionWidth()) / Double.valueOf(resolution.getResolutionHeight());\n-        if (!range.isAspectRatioInRange(currentAspectRatio)){\n-            return false;\n+        if (resolution != null) {\n+            Double currentAspectRatio = normalizeAspectRatio(resolution);\n+            if (!range.isAspectRatioInRange(currentAspectRatio)){\n+                return false;\n+            }\n         }\n \n         double diagonal;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzY0MDIwNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r587640206", "bodyText": "We need to normalize the aspectRatio, a helper method can be added and we can call it with the resolution we get from the capability\nprivate Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n        \n        ...\n\n        ImageResolution resolution = capability.getPreferredResolution();\n        if (resolution != null) {\n            Double currentAspectRatio = normalizeAspectRatio(resolution);\n            if (!range.isAspectRatioInRange(currentAspectRatio)){\n                return false;\n            }\n        }\n        \n        ...\n        \n}\n\nprivate Double normalizeAspectRatio(ImageResolution resolution) {\n        double width = resolution.getResolutionWidth();\n        double height = resolution.getResolutionHeight();\n\n        if (width <= 0.0 || height <= 0.0) {\n            return 0.0;\n        } else if (width < height) {\n            return height/width;\n        } else if (width > height) {\n            return width/height;\n        } else {\n            return 1.0;\n        }\n    }", "author": "RHenigan", "createdAt": "2021-03-04T16:52:00Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -645,6 +782,126 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n         return motionEventList;\n     }\n \n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(VideoStreamingCapability rootCapability){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+        if (rootCapability == null){\n+            return null;\n+        }\n+\n+        List<VideoStreamingCapability> allCapabilities = rootCapability.getAdditionalVideoStreamingCapabilities();\n+        if (allCapabilities == null){\n+            return null;\n+        }\n+\n+        if (allCapabilities != null){\n+            rootCapability.setAdditionalVideoStreamingCapabilities(null);\n+            allCapabilities.add(rootCapability);\n+        }\n+\n+        for (VideoStreamingCapability capability : allCapabilities) {\n+            ImageResolution imageResolution = capability.getPreferredResolution();\n+            boolean matches = false;\n+            switch (determineResolutionType(imageResolution)) {\n+                case SQUARE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange) || inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case PORTRAIT:\n+                    matches = inRange(capability, this.supportedPortraitStreamingRange);\n+                    break;\n+                case LANDSCAPE:\n+                    matches = inRange(capability, this.supportedLandscapeStreamingRange);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            if (matches) {\n+                capability.setAdditionalVideoStreamingCapabilities(null);\n+                if (!validCapabilities.contains(capability)) {\n+                    validCapabilities.add(capability);\n+                }\n+            }\n+        }\n+\n+        return validCapabilities;\n+    }\n+\n+    private Boolean inRange(VideoStreamingCapability capability, VideoStreamingRange range){\n+        if (capability == null) {\n+            return false;\n+        }\n+        if (range == null) {\n+            return true;\n+        }\n+\n+        if (isZeroRange(range)){\n+            return false;\n+        }\n+\n+        if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n+            if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {\n+                return false;\n+            }\n+        }\n+\n+        ImageResolution resolution = capability.getPreferredResolution();\n+        Double currentAspectRatio = Double.valueOf(resolution.getResolutionWidth()) / Double.valueOf(resolution.getResolutionHeight());", "originalCommit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 96fb7fde7..41af28cb1 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -844,15 +845,17 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n         }\n \n         if (range.getMinimumResolution() != null || range.getMaximumResolution() != null) {\n-            if (!range.isImageResolutionInRange(capability.getPreferredResolution())) {\n+            if (!range.isImageResolutionInRange(makeScaledImageResolution(capability))) {\n                 return false;\n             }\n         }\n \n         ImageResolution resolution = capability.getPreferredResolution();\n-        Double currentAspectRatio = Double.valueOf(resolution.getResolutionWidth()) / Double.valueOf(resolution.getResolutionHeight());\n-        if (!range.isAspectRatioInRange(currentAspectRatio)){\n-            return false;\n+        if (resolution != null) {\n+            Double currentAspectRatio = normalizeAspectRatio(resolution);\n+            if (!range.isAspectRatioInRange(currentAspectRatio)){\n+                return false;\n+            }\n         }\n \n         double diagonal;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzY0MTM3MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r587641370", "bodyText": "This was a typo on my previous comment\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n          \n          \n            \n                    if (maximumResolution == null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {", "author": "RHenigan", "createdAt": "2021-03-04T16:53:18Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minimumResolution;\n+    private Resolution maximumResolution;\n+    private Double minimumDiagonal;\n+    private Double minimumAspectRatio;\n+    private Double maximumAspectRatio;\n+\n+    public VideoStreamingRange(Resolution minimumResolution, Resolution maximumResolution, Double minimumDiagonal, Double minimumAspectRatio, Double maximumAspectRatio) {\n+        this.minimumResolution = minimumResolution;\n+        this.maximumResolution = maximumResolution;\n+        this.minimumDiagonal = minimumDiagonal;\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        this.maximumAspectRatio = maximumAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinimumResolution() {\n+        return minimumResolution;\n+    }\n+\n+    public Resolution getMaximumResolution() {\n+        return maximumResolution;\n+    }\n+\n+    public Double getMinimumDiagonal() {\n+        return minimumDiagonal;\n+    }\n+\n+    public Double getMinimumAspectRatio() {\n+        return minimumAspectRatio;\n+    }\n+\n+    public Double getMaximumAspectRatio() {\n+        return maximumAspectRatio;\n+    }\n+\n+    public VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n+        this.minimumResolution = minSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+        this.maximumResolution = maxSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumDiagonal(Double minimumDiagonal) {\n+        this.minimumDiagonal = minimumDiagonal;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumAspectRatio(Double minimumAspectRatio) {\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaximumAspectRatio(Double maximumAspectRatio) {\n+        this.maximumAspectRatio = maximumAspectRatio;\n+        return this;\n+    }\n+\n+    public Boolean isImageResolutionInRange(ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maximumResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minimumResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maximumResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minimumResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+\n+        if (currentResolution == null) {\n+            return false;\n+        }\n+\n+        if (minimumResolution == null && maximumResolution == null) {\n+            return true;\n+        }\n+\n+        if (minimumResolution == null || (minimumResolution.getResolutionWidth() == 0 && minimumResolution.getResolutionHeight() == 0)) {\n+            return false;\n+        }\n+\n+        if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {", "originalCommit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex b2a395469..1ffc572b2 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -86,7 +86,7 @@ public class VideoStreamingRange {\n             return false;\n         }\n \n-        if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n+        if (maximumResolution == null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n             return false;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzY0NDgyMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r587644823", "bodyText": "Unit tests should be added for this method", "author": "RHenigan", "createdAt": "2021-03-04T16:57:21Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minimumResolution;\n+    private Resolution maximumResolution;\n+    private Double minimumDiagonal;\n+    private Double minimumAspectRatio;\n+    private Double maximumAspectRatio;\n+\n+    public VideoStreamingRange(Resolution minimumResolution, Resolution maximumResolution, Double minimumDiagonal, Double minimumAspectRatio, Double maximumAspectRatio) {\n+        this.minimumResolution = minimumResolution;\n+        this.maximumResolution = maximumResolution;\n+        this.minimumDiagonal = minimumDiagonal;\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        this.maximumAspectRatio = maximumAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinimumResolution() {\n+        return minimumResolution;\n+    }\n+\n+    public Resolution getMaximumResolution() {\n+        return maximumResolution;\n+    }\n+\n+    public Double getMinimumDiagonal() {\n+        return minimumDiagonal;\n+    }\n+\n+    public Double getMinimumAspectRatio() {\n+        return minimumAspectRatio;\n+    }\n+\n+    public Double getMaximumAspectRatio() {\n+        return maximumAspectRatio;\n+    }\n+\n+    public VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n+        this.minimumResolution = minSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+        this.maximumResolution = maxSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumDiagonal(Double minimumDiagonal) {\n+        this.minimumDiagonal = minimumDiagonal;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumAspectRatio(Double minimumAspectRatio) {\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaximumAspectRatio(Double maximumAspectRatio) {\n+        this.maximumAspectRatio = maximumAspectRatio;\n+        return this;\n+    }\n+\n+    public Boolean isImageResolutionInRange(ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maximumResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minimumResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maximumResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minimumResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+\n+        if (currentResolution == null) {\n+            return false;\n+        }\n+\n+        if (minimumResolution == null && maximumResolution == null) {\n+            return true;\n+        }\n+\n+        if (minimumResolution == null || (minimumResolution.getResolutionWidth() == 0 && minimumResolution.getResolutionHeight() == 0)) {\n+            return false;\n+        }\n+\n+        if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n+            return false;\n+        }\n+\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public Boolean isAspectRatioInRange(Double aspectRatio) {", "originalCommit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex b2a395469..1ffc572b2 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -86,7 +86,7 @@ public class VideoStreamingRange {\n             return false;\n         }\n \n-        if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n+        if (maximumResolution == null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n             return false;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzY0NTEzMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r587645130", "bodyText": "Unit tests should be added for this method", "author": "RHenigan", "createdAt": "2021-03-04T16:57:41Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minimumResolution;\n+    private Resolution maximumResolution;\n+    private Double minimumDiagonal;\n+    private Double minimumAspectRatio;\n+    private Double maximumAspectRatio;\n+\n+    public VideoStreamingRange(Resolution minimumResolution, Resolution maximumResolution, Double minimumDiagonal, Double minimumAspectRatio, Double maximumAspectRatio) {\n+        this.minimumResolution = minimumResolution;\n+        this.maximumResolution = maximumResolution;\n+        this.minimumDiagonal = minimumDiagonal;\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        this.maximumAspectRatio = maximumAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinimumResolution() {\n+        return minimumResolution;\n+    }\n+\n+    public Resolution getMaximumResolution() {\n+        return maximumResolution;\n+    }\n+\n+    public Double getMinimumDiagonal() {\n+        return minimumDiagonal;\n+    }\n+\n+    public Double getMinimumAspectRatio() {\n+        return minimumAspectRatio;\n+    }\n+\n+    public Double getMaximumAspectRatio() {\n+        return maximumAspectRatio;\n+    }\n+\n+    public VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n+        this.minimumResolution = minSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+        this.maximumResolution = maxSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumDiagonal(Double minimumDiagonal) {\n+        this.minimumDiagonal = minimumDiagonal;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumAspectRatio(Double minimumAspectRatio) {\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaximumAspectRatio(Double maximumAspectRatio) {\n+        this.maximumAspectRatio = maximumAspectRatio;\n+        return this;\n+    }\n+\n+    public Boolean isImageResolutionInRange(ImageResolution currentResolution) {", "originalCommit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex b2a395469..1ffc572b2 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -86,7 +86,7 @@ public class VideoStreamingRange {\n             return false;\n         }\n \n-        if (maximumResolution != null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n+        if (maximumResolution == null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n             return false;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzY1NDYzNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r587654634", "bodyText": "Can we add a log message here so the developer is aware of why the video has not streamed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n          \n          \n            \n                                        stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n          \n          \n            \n                                        DebugTool.logError(TAG, \"The Video stream was not started because there were no supported video streaming capabilities, please double check that the VideoStreamRanges provided are not disabled ranges\");", "author": "RHenigan", "createdAt": "2021-03-04T17:07:53Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -284,25 +363,54 @@ public void onError(String info) {\n      *                           works best for the currently connected module.\n      * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n      */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null, null);\n         boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n         if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n             DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n             stateMachine.transitionToState(StreamingStateMachine.ERROR);\n             return;\n         }\n-        // regardless of VideoStreamingParameters are specified or not, we should refer to VideoStreamingCapability.\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange portraitRange, VideoStreamingRange landscapeRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        this.supportedPortraitStreamingRange = portraitRange;\n+        this.supportedLandscapeStreamingRange = landscapeRange;\n+    }\n+\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters) {\n+        final VideoStreamingParameters params = (parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n         if (majorProtocolVersion >= 5) {\n             if (internalInterface.getSystemCapabilityManager() != null) {\n-                final VideoStreamingParameters params = ( parameters == null) ? new VideoStreamingParameters() : new VideoStreamingParameters(parameters);\n                 internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                     @Override\n                     public void onCapabilityRetrieved(Object capability) {\n-                        params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                        startStreaming(params, encrypted);\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability) capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                        params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+\n+                        VideoStreamingCapability capabilityToSend = new VideoStreamingCapability();\n+                        capabilityToSend.setAdditionalVideoStreamingCapabilities(getSupportedCapabilities(castedCapability));\n+\n+                        if (capabilityToSend.getAdditionalVideoStreamingCapabilities() == null || capabilityToSend.getAdditionalVideoStreamingCapabilities().isEmpty()) {\n+                            stateMachine.transitionToState(StreamingStateMachine.STOPPED);", "originalCommit": "62fd8528ddd76d992bd3b2b56b0d02c2961da7a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 96fb7fde7..41af28cb1 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -403,6 +403,7 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n \n                         if (capabilityToSend.getAdditionalVideoStreamingCapabilities() == null || capabilityToSend.getAdditionalVideoStreamingCapabilities().isEmpty()) {\n                             stateMachine.transitionToState(StreamingStateMachine.STOPPED);\n+                            DebugTool.logError(TAG, \"The Video stream was not started because there were no supported video streaming capabilities, please double check that the VideoStreamRanges provided are not disabled ranges\");\n                             return;\n                         }\n                         AppCapability appCapability = new AppCapability(AppCapabilityType.VIDEO_STREAMING);\n"}}, {"oid": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/1c6ee23ef3da181426be970b3459e39249f0ddf1", "message": "[0296]\n- Fix pr comments\n- Add tests", "committedDate": "2021-03-05T11:15:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODM3NzE2MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r588377161", "bodyText": "@kostyaBoss, Please add more unit tests here,\nThere should be tests for\ntestResolutionOutOfRange\ntestAspectRatioOutOfRange\ntestResolutionWithNullResolutionRange (Range resolutions are set to null and should return true)\ntestAspectRatioWithNullAspectRatioRange (Range aspect Ratios are set to null and should return true)\ntestResolutionWithDisabledResolutionRange (Range resolutions have 0 width and height values and should return false)\ntestResolutionWithDisabledAspectRatioRange (Range aspectRatios have 0 values and should return false)", "author": "RHenigan", "createdAt": "2021-03-05T15:20:54Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamingRangeTests.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package com.smartdevicelink.managers.video;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import com.smartdevicelink.managers.video.resolution.Resolution;\n+import com.smartdevicelink.managers.video.resolution.VideoStreamingRange;\n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n+import junit.framework.TestCase;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class VideoStreamingRangeTests extends TestCase {\n+\n+    VideoStreamingRange testRange;\n+    Resolution minResolution;\n+    Resolution maxResolution;\n+    Double minimumDiagonal;\n+    Double minimumAspectRatio;\n+    Double maximumAspectRatio;\n+\n+    @Before\n+    public void setUp() {\n+        minResolution = new Resolution(640, 480);\n+        maxResolution = new Resolution(1920, 1080);\n+        minimumDiagonal = 3.3;\n+        minimumAspectRatio = 1.0;\n+        maximumAspectRatio = 2.0;\n+        testRange = new VideoStreamingRange(minResolution, maxResolution, minimumDiagonal, minimumAspectRatio, maximumAspectRatio);\n+    }\n+", "originalCommit": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c790274460a219b2630b0fa2bf02b5bb5f89ba5a", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamingRangeTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamingRangeTests.java\nindex 66cdace06..12ed8675e 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamingRangeTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamingRangeTests.java\n\n@@ -12,6 +12,8 @@ import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n \n+import java.util.Random;\n+\n @RunWith(AndroidJUnit4.class)\n public class VideoStreamingRangeTests extends TestCase {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODM3OTQ3Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r588379477", "bodyText": "Hello @kostyaBoss,\none comment was missed in the last commit, These lines can potentially throw NPEs\nInteger constraintHeightMax = maximumResolution.getResolutionHeight();\nInteger constraintHeightMin = minimumResolution.getResolutionHeight();\nInteger constraintWidthMax = maximumResolution.getResolutionWidth();\nInteger constraintWidthMin = minimumResolution.getResolutionWidth();\nInteger resolutionHeight = currentResolution.getResolutionHeight();\nInteger resolutionWidth = currentResolution.getResolutionWidth();\n\nBecause of this, these checks should be performed first.\n        if (currentResolution == null) {\n            return false;\n        }\n\n        if (minimumResolution == null && maximumResolution == null) {\n            return true;\n        }\n\n        if (minimumResolution == null || (minimumResolution.getResolutionWidth() == 0 && minimumResolution.getResolutionHeight() == 0)) {\n            return false;\n        }\n\n        if (maximumResolution == null || (maximumResolution.getResolutionWidth() == 0 && maximumResolution.getResolutionHeight() == 0)) {\n            return false;\n        }", "author": "RHenigan", "createdAt": "2021-03-05T15:23:27Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+import com.smartdevicelink.proxy.rpc.ImageResolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minimumResolution;\n+    private Resolution maximumResolution;\n+    private Double minimumDiagonal;\n+    private Double minimumAspectRatio;\n+    private Double maximumAspectRatio;\n+\n+    public VideoStreamingRange(Resolution minimumResolution, Resolution maximumResolution, Double minimumDiagonal, Double minimumAspectRatio, Double maximumAspectRatio) {\n+        this.minimumResolution = minimumResolution;\n+        this.maximumResolution = maximumResolution;\n+        this.minimumDiagonal = minimumDiagonal;\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        this.maximumAspectRatio = maximumAspectRatio;\n+    }\n+\n+    private VideoStreamingRange() {\n+    }\n+\n+    public Resolution getMinimumResolution() {\n+        return minimumResolution;\n+    }\n+\n+    public Resolution getMaximumResolution() {\n+        return maximumResolution;\n+    }\n+\n+    public Double getMinimumDiagonal() {\n+        return minimumDiagonal;\n+    }\n+\n+    public Double getMinimumAspectRatio() {\n+        return minimumAspectRatio;\n+    }\n+\n+    public Double getMaximumAspectRatio() {\n+        return maximumAspectRatio;\n+    }\n+\n+    public VideoStreamingRange setMinSupportedResolution(Resolution minSupportedResolution) {\n+        this.minimumResolution = minSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaxSupportedResolution(Resolution maxSupportedResolution) {\n+        this.maximumResolution = maxSupportedResolution;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumDiagonal(Double minimumDiagonal) {\n+        this.minimumDiagonal = minimumDiagonal;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMinimumAspectRatio(Double minimumAspectRatio) {\n+        this.minimumAspectRatio = minimumAspectRatio;\n+        return this;\n+    }\n+\n+    public VideoStreamingRange setMaximumAspectRatio(Double maximumAspectRatio) {\n+        this.maximumAspectRatio = maximumAspectRatio;\n+        return this;\n+    }\n+\n+    public Boolean isImageResolutionInRange(ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maximumResolution.getResolutionHeight();", "originalCommit": "1c6ee23ef3da181426be970b3459e39249f0ddf1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c790274460a219b2630b0fa2bf02b5bb5f89ba5a", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex 1ffc572b2..f94220eef 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -67,14 +67,7 @@ public class VideoStreamingRange {\n \n     public Boolean isImageResolutionInRange(ImageResolution currentResolution) {\n \n-        Integer constraintHeightMax = maximumResolution.getResolutionHeight();\n-        Integer constraintHeightMin = minimumResolution.getResolutionHeight();\n-        Integer constraintWidthMax = maximumResolution.getResolutionWidth();\n-        Integer constraintWidthMin = minimumResolution.getResolutionWidth();\n-        Integer resolutionHeight = currentResolution.getResolutionHeight();\n-        Integer resolutionWidth = currentResolution.getResolutionWidth();\n-\n-        if (currentResolution == null) {\n+        if (currentResolution == null || (currentResolution.getResolutionHeight() == null && currentResolution.getResolutionWidth() == null)) {\n             return false;\n         }\n \n"}}, {"oid": "c790274460a219b2630b0fa2bf02b5bb5f89ba5a", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c790274460a219b2630b0fa2bf02b5bb5f89ba5a", "message": "[0296]\n- Add tests\n- Fix npes", "committedDate": "2021-03-08T20:17:22Z", "type": "commit"}, {"oid": "56f6cc7531d742da67b8637e2c5ba65f3ba9e4a9", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/56f6cc7531d742da67b8637e2c5ba65f3ba9e4a9", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities", "committedDate": "2021-03-08T21:06:48Z", "type": "commit"}, {"oid": "038c990437f55d991bc03fb2d89a3321e87995d5", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/038c990437f55d991bc03fb2d89a3321e87995d5", "message": "[0293]\n- Fix PR comments", "committedDate": "2021-03-08T21:19:05Z", "type": "commit"}, {"oid": "577df30f19db0bb1234a41cd4ae2ae9f22a9d296", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/577df30f19db0bb1234a41cd4ae2ae9f22a9d296", "message": "[0296]\n- Fix PR comments", "committedDate": "2021-03-08T22:20:30Z", "type": "commit"}, {"oid": "5d30ae0fa3e9f99081a3edc8bd56d36fed318004", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/5d30ae0fa3e9f99081a3edc8bd56d36fed318004", "message": "[poc/unknown-enums]\n    - Fix Button capabilities logging\n    - Improve lifecycle management and version retrieving for RAI\n    - Fix NPE for responses if SDLVersion is passed as null", "committedDate": "2020-04-30T12:35:09Z", "type": "commit"}, {"oid": "0958db7f962f1fdb0c1154aaac5c0807f4acba1a", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/0958db7f962f1fdb0c1154aaac5c0807f4acba1a", "message": "[poc/unknown-enums]\n    - Fix Button capabilities logging\n    - Improve lifecycle management and version retrieving for RAI\n    - Fix NPE for responses if SDLVersion is passed as null", "committedDate": "2020-04-30T12:36:08Z", "type": "commit"}, {"oid": "67cc2e489372b315c6143131570d1c97a1167738", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/67cc2e489372b315c6143131570d1c97a1167738", "message": "[poc/video-streaming]\n    - Hardcoded display size to 2k", "committedDate": "2020-04-30T12:45:24Z", "type": "commit"}, {"oid": "4f48cd995d7f9711ff3eae8760f9bd7562f5afd0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/4f48cd995d7f9711ff3eae8760f9bd7562f5afd0", "message": "[poc/video-streaming]\n    - Add video config fields\n    - Fix bug with default bad scale", "committedDate": "2020-04-30T14:05:33Z", "type": "commit"}, {"oid": "dc7ca23a5c749df8dba9a728c9a3ab7543251621", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/dc7ca23a5c749df8dba9a728c9a3ab7543251621", "message": "[poc/video-streaming]\n    - Add video config fields\n    - Fix bug with default bad scale", "committedDate": "2020-04-30T14:06:48Z", "type": "commit"}, {"oid": "e15cc6514667ff453aad63547a6678c5ad9944c3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e15cc6514667ff453aad63547a6678c5ad9944c3", "message": "[poc/video-streaming]\n    - Add service restart", "committedDate": "2020-05-05T17:46:53Z", "type": "commit"}, {"oid": "4e79b976f3969789d05a00db36962f919e3cd196", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/4e79b976f3969789d05a00db36962f919e3cd196", "message": "[poc/video-streaming]\n    - Implement video streaming POC for android", "committedDate": "2020-05-19T11:17:16Z", "type": "commit"}, {"oid": "ac26007d0dfbc51649d7c1c20cc7cf9d94dd9f79", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ac26007d0dfbc51649d7c1c20cc7cf9d94dd9f79", "message": "[poc/video-streaming]\n    - Update onServiceEnded with proper handling", "committedDate": "2020-05-27T14:10:24Z", "type": "commit"}, {"oid": "f1a11c2093b373b024bb1eb3b3e1db70cb2d61e5", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f1a11c2093b373b024bb1eb3b3e1db70cb2d61e5", "message": "Merge branch 'develop' into poc/video_streaming_with_capabilities_update\n\n# Conflicts:\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "committedDate": "2020-05-27T14:19:10Z", "type": "commit"}, {"oid": "e1d401d17b9bce5f1ce1efc105598420578f971b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e1d401d17b9bce5f1ce1efc105598420578f971b", "message": "[poc/video-streaming]\n    - Remove unused logs", "committedDate": "2020-05-31T13:22:53Z", "type": "commit"}, {"oid": "36a69c7fe85000fbb008c585ed160bad90db10e7", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/36a69c7fe85000fbb008c585ed160bad90db10e7", "message": "[poc/video-streaming]\n    - Remove dependency on start/stopVideoService\n    - Move logic to VideoStreamManager", "committedDate": "2020-06-08T09:21:35Z", "type": "commit"}, {"oid": "c6744a342991119f28aa31440fce625ec8d9bb25", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c6744a342991119f28aa31440fce625ec8d9bb25", "message": "[poc/video-streaming]\n    - Extend with callback to give third-party devs control on view resize process", "committedDate": "2020-06-08T09:33:31Z", "type": "commit"}, {"oid": "dbd4861246a1a12d20cbab0a2f1229190cdeb985", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/dbd4861246a1a12d20cbab0a2f1229190cdeb985", "message": "[poc/video-streaming]\n    - Implement new \"Paused\" state for state machine", "committedDate": "2020-06-08T10:00:58Z", "type": "commit"}, {"oid": "b1a1748ab25e7ea065653dc2c45a46a3d6880200", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/b1a1748ab25e7ea065653dc2c45a46a3d6880200", "message": "[poc/video-streaming]\n    - Implement new \"Paused\" state for state machine\n    - Implement developer-provided info about resolution", "committedDate": "2020-06-11T12:55:14Z", "type": "commit"}, {"oid": "6d3ed1cc09c21cde42c592351888611d767dd512", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/6d3ed1cc09c21cde42c592351888611d767dd512", "message": "[poc/video-streaming]\n    - Updated according to latest specification", "committedDate": "2020-06-12T13:34:12Z", "type": "commit"}, {"oid": "483c0d86203739d61c15bd565fe3786bb757285d", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/483c0d86203739d61c15bd565fe3786bb757285d", "message": "[0296]\n    - Update according to new proposal revision", "committedDate": "2020-06-30T08:35:21Z", "type": "commit"}, {"oid": "631938cf2a3cb4bcfd67677d753346c52733c6d6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/631938cf2a3cb4bcfd67677d753346c52733c6d6", "message": "[VideoStreaming]\n    - Add new notification\n    - Fix compilation error\n    - Move mocks to make easier pending implementation", "committedDate": "2020-07-10T14:42:35Z", "type": "commit"}, {"oid": "b856cef0c3f2eda3059d4a8dc2f08494d8eeb0b9", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/b856cef0c3f2eda3059d4a8dc2f08494d8eeb0b9", "message": "[VideoStreaming]\n    - Fix logic error with unused ranges provided by developer\n    - Provide builder for SupportedStreamingRange\n    - Add share prefs for saving ip on edit\n    - Add button to kill app and all it's components", "committedDate": "2020-07-15T11:19:50Z", "type": "commit"}, {"oid": "9a8292176d0d83678b2f128d5c84ad3e45999d6c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9a8292176d0d83678b2f128d5c84ad3e45999d6c", "message": "Merge branch 'develop' into poc/fork/video_streaming_with_capabilities_update\n\n# Conflicts:\n#\tandroid/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/SdlManager.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/streaming/video/SdlRemoteDisplay.java\n#\tbase/src/main/java/com/smartdevicelink/proxy/SystemCapabilityManager.java", "committedDate": "2020-07-21T12:58:15Z", "type": "commit"}, {"oid": "43434a8f1be4cac4798b4a80254acc8a6dda132e", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/43434a8f1be4cac4798b4a80254acc8a6dda132e", "message": "[VideoStreaming]\n    - Fix bugs after develop merge\n    - Fix tests", "committedDate": "2020-07-21T20:27:16Z", "type": "commit"}, {"oid": "ad5ef1a8cd5477f986a8d486a8abd62ffc154ac2", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ad5ef1a8cd5477f986a8d486a8abd62ffc154ac2", "message": "[VideoStreaming]\n    - Fix Version\n    - Rename according to proposal", "committedDate": "2020-07-27T14:05:18Z", "type": "commit"}, {"oid": "7843cf303811ada8d0fbfaedc171e0204e3e0f44", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/7843cf303811ada8d0fbfaedc171e0204e3e0f44", "message": "[VideoStreaming]\n    - Fix wrong diagonal crash", "committedDate": "2020-07-28T07:42:03Z", "type": "commit"}, {"oid": "ca86259f26896a4f939df854befd2faf1613198d", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ca86259f26896a4f939df854befd2faf1613198d", "message": "[VideoStreaming]\n    - Add validation for inconsistent capabilities\n    - Fix filtration algorithm", "committedDate": "2020-07-29T09:24:56Z", "type": "commit"}, {"oid": "315cb858f438c214b822943b7c04a7ba6a4afffb", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/315cb858f438c214b822943b7c04a7ba6a4afffb", "message": "[VideoStreaming]\n    - Fix edge case when notification contains only scale parameter\n    - Align resolutions according to QA needs", "committedDate": "2020-07-30T08:08:23Z", "type": "commit"}, {"oid": "770b69f32a0109194ee903d576a961a33dcb6001", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/770b69f32a0109194ee903d576a961a33dcb6001", "message": "[VideoStreaming]\n    - Fix notifications flow\n    - Fix \"only scale in notification\" wrong processing\n    - Add caching of previous parameters", "committedDate": "2020-08-03T07:41:05Z", "type": "commit"}, {"oid": "a6c1159d2c5b7994addc24e0b60e916db647f0e6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a6c1159d2c5b7994addc24e0b60e916db647f0e6", "message": "[VideoStreaming]\n    - Refactor filtering to methods", "committedDate": "2020-08-05T22:09:26Z", "type": "commit"}, {"oid": "8d9e233f1fe3ec41271056a9234a0265fed5c86f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8d9e233f1fe3ec41271056a9234a0265fed5c86f", "message": "[VideoStreaming]\n    - Use methods to simplify code and decrease complexity", "committedDate": "2020-08-05T22:23:00Z", "type": "commit"}, {"oid": "7e50ea7693886972939bf28aaefabd002d2b8892", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/7e50ea7693886972939bf28aaefabd002d2b8892", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/proxy/SdlProxyBase.java", "committedDate": "2020-08-06T16:43:11Z", "type": "commit"}, {"oid": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "message": "[VideoStreaming]\n     - Fix compilation errors on merge", "committedDate": "2020-08-06T16:58:02Z", "type": "commit"}, {"oid": "be4e36dfb5dc8db77fa9120bc0fad7b6be74f1aa", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/be4e36dfb5dc8db77fa9120bc0fad7b6be74f1aa", "message": "Merge branch 'develop' into Feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/hello_sdl_android/build.gradle\n#\tandroid/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/streaming/video/SdlRemoteDisplayTest.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/proxy/SdlProxyBase.java", "committedDate": "2020-08-18T13:03:39Z", "type": "commit"}, {"oid": "d57ad9b4990c051ac60e981884b46248fc96b970", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/d57ad9b4990c051ac60e981884b46248fc96b970", "message": "[0296]\n    - Fix compilation errors", "committedDate": "2020-08-18T13:57:32Z", "type": "commit"}, {"oid": "dece45c76f65ec2657f5a5feacf23f96bdb3262c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/dece45c76f65ec2657f5a5feacf23f96bdb3262c", "message": "Merge remote-tracking branch 'origin/feature/0296_possibility_to_update_video_streaming_capabilities' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/proxy/SdlProxyBase.java", "committedDate": "2020-08-18T14:41:12Z", "type": "commit"}, {"oid": "16e430a7de2ac66bd9a5612f0b1059ac0fbac24f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/16e430a7de2ac66bd9a5612f0b1059ac0fbac24f", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tbase/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java", "committedDate": "2020-08-18T14:45:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0NTMyMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471645321", "bodyText": "Per the proposal, getSupportedCapabilities should be defined as:\n\"...\nprivate List<VideoStreamingCapability> getSupportedCapabilities( Resolution minResolution, Resolution maxResolution, Double minAspectRatio, Double maxAspectRatio, Double minScreenDiagonal )\n...\"\nDo you need to change your method definition to match with the proposal?", "author": "santhanamk", "createdAt": "2020-08-17T17:27:14Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -603,6 +744,120 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n \t\treturn motionEventList;\n \t}\n \n+\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n+\t\treturn parameters;\n+\t}\n+\n+\tpublic boolean getLastCachedIsEncrypted() {\n+\t\treturn isEncrypted;\n+\t}\n+\n+\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n+\t\t\tResolution minResolution,\n+\t\t\tResolution maxResolution,", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzNzA2Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473337062", "bodyText": "Per the proposal, getSupportedCapabilities should be defined as:\n\"...\nprivate List<VideoStreamingCapability> getSupportedCapabilities( Resolution minResolution, Resolution maxResolution, Double minAspectRatio, Double maxAspectRatio, Double minScreenDiagonal )\n...\"\nDo you need to change your method definition to match with the proposal?\n\n@kostyaBoss Does your method definition need to match with the proposal?", "author": "santhanamk", "createdAt": "2020-08-19T21:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0NTMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 5461d9d4d..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -65,898 +65,968 @@ import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.TouchCoord;\n import com.smartdevicelink.proxy.rpc.TouchEvent;\n import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.TouchType;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n import com.smartdevicelink.proxy.rpc.enums.VideoStreamingState;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.session.SdlSession;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.IVideoStreamListener;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n import com.smartdevicelink.transport.utl.TransportRecord;\n import com.smartdevicelink.util.DebugTool;\n import com.smartdevicelink.util.Version;\n \n+import java.io.IOException;\n import java.lang.ref.WeakReference;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.FutureTask;\n \n @TargetApi(19)\n public class VideoStreamManager extends BaseVideoStreamManager {\n-\tprivate static String TAG = \"VideoStreamManager\";\n-\n-\tprivate WeakReference<Context> context;\n-\tprivate volatile VirtualDisplayEncoder virtualDisplayEncoder;\n-\tprivate Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n-\tprivate SdlRemoteDisplay sdlRemoteDisplay;\n-\tprivate float[] touchScalar = {1.0f,1.0f}; //x, y\n-\tprivate HapticInterfaceManager hapticManager;\n-\tprivate SdlMotionEvent sdlMotionEvent = null;\n-\tprivate OnHMIStatus currentOnHMIStatus;\n-\tprivate StreamingStateMachine stateMachine;\n-\tprivate VideoStreamingParameters parameters;\n-\tprivate VideoStreamingCapability originalCapability;\n-\tprivate IVideoStreamListener streamListener;\n-\tprivate boolean isTransportAvailable = false;\n-\tprivate Integer majorProtocolVersion;\n-\tprivate VideoStreamingRange streamingRange;\n-\tprivate boolean hasStarted;\n-\tprivate String vehicleMake = null;\n-\tprivate boolean isEncrypted = false;\n-\tprivate boolean withPendingRestart = false;\n-\n-\t// INTERNAL INTERFACES\n-\n-\tprivate final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif (session != null && session.getAcceptedVideoParams() != null) {\n-\t\t\t\t\tparameters = session.getAcceptedVideoParams();\n-\t\t\t\t\tVideoStreamManager.this.streamListener = session.startVideoStream();\n-\t\t\t\t}\n-\n-\t\t\t\tif (VideoStreamManager.this.streamListener == null) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error starting video stream\");\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\tif(capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())){\n-\t\t\t\t\thapticManager = new HapticInterfaceManager(internalInterface);\n-\t\t\t\t}\n-\t\t\t\tcheckState();\n-\t\t\t\tstartEncoder();\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\t\thasStarted = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SdlSession session, SessionType type) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif(sdlRemoteDisplay !=null){\n-\t\t\t\t    // TODO set withPendingRestart to default in proper place\n-\t\t\t\t\tstopStreaming(withPendingRestart);\n-\t\t\t\t}\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\t\t\ttransitionToState(SETTING_UP);\n-\n-\t\t\t\tif (withPendingRestart){\n-\t\t\t\t\tVideoStreamManager manager = VideoStreamManager.this;\n-\t\t\t\t\tmanager.internalInterface.startVideoService(\n-\t\t\t\t\t\t\tmanager.getLastCachedStreamingParameters(),\n-\t\t\t\t\t\t\tmanager.isEncrypted\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceError(SdlSession session, SessionType type, String reason) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null){\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tOnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n-\t\t\t\tcurrentOnHMIStatus = onHMIStatus;\n-\n-\t\t\t\tif (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n-\t\t\t\t\tinternalInterface.stopVideoService();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null && sdlRemoteDisplay != null){\n-\t\t\t\tList<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent)notification);\n-\t\t\t\tif (motionEventList != null && !motionEventList.isEmpty()) {\n-\t\t\t\t\tfor (MotionEvent motionEvent : motionEventList) {\n-\t\t\t\t\t\tsdlRemoteDisplay.handleMotionEvent(motionEvent);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t@Override\n-\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\n-\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\n-\t\t\t// means only scale received\n-\t\t\tif (castedCapability.getPreferredResolution() == null &&\n-\t\t\t\t\tcastedCapability.getScale() != null &&\n-\t\t\t\t\tcastedCapability.getScale() != 0 &&\n-\t\t\t\t\tVideoStreamManager.this.parameters != null\n-\t\t\t\t\t&& VideoStreamManager.this.parameters.getResolution() != null) {\n-\t\t\t\t// set cached resolution\n-\t\t\t\tcastedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n-\t\t\t}\n-\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\tVideoStreamManager.this.withPendingRestart = true;\n-\n-\t\t\tvirtualDisplayEncoder.setStreamingParams(params);\n-\t\t\tstopStreaming(true);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onError(String info) {\n-\t\t\tLog.d(\"MyTagLogInfo\", info);\n-\t\t}\n-\t};\n-\n-\t// MANAGER APIs\n-\tpublic VideoStreamManager(ISdl internalInterface){\n-\t\tsuper(internalInterface);\n-\n-\t\tif(internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n-\t\t\t\tinternalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n-\t\t\tvehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n-\t\t}\n-\t\tvirtualDisplayEncoder = new VirtualDisplayEncoder();\n-\n-\t\t// Listen for video service events\n-\t\tinternalInterface.addServiceListener(SessionType.NAV, serviceListener);\n-\t\t// Take care of the touch events\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t// Listen for HMILevel changes\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t// Listen for SystemCapabilityType VIDEO_STREAMING\n-\t\tinternalInterface.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n-\t\tstateMachine = new StreamingStateMachine();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\tisTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n-\t\tcheckState();\n-\t\tsuper.start(listener);\n-\t}\n-\n-\tprivate synchronized void checkState(){\n-\t\tif(this.getState() == SETTING_UP\n-\t\t\t\t&& isTransportAvailable\n-\t\t\t\t&& isHMIStateVideoStreamCapable(currentOnHMIStatus)\n-\t\t\t\t&& parameters != null){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.READY);\n-\t\t\ttransitionToState(READY);\n-\t\t}\n-\t}\n-\n-\tboolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n-\t\tHMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n-\t\tVideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n-\t\treturn (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n-\t}\n-\n-\tprivate void getVideoStreamingParams(){\n-\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5) {\n-\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\tcheckState();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\ttransitionToState(ERROR);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\t//We just use default video streaming params\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\tif(dispCap !=null){\n-\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t}\n-\n-\t\t\tthis.parameters = params;\n-\t\t\tcheckState();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param streamingRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tthis.streamingRange = streamingRange;\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n-\t\tif(parameters == null){\n-\t\t\tif(majorProtocolVersion >= 5) {\n-\t\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\n-\t\t\t\t\t\t// Mocks data here\n-\t\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\t\t\t\tif (streamingRange != null) {\n-\t\t\t\t\t\t\t// filtering\n-\t\t\t\t\t\t\tcastedCapability.setAdditionalVideoStreamingCapabilities(\n-\t\t\t\t\t\t\t\t\tgetSupportedCapabilities(\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxScreenDiagonal(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getAspectRatio(),\n-\t\t\t\t\t\t\t\t\t\t\tcastedCapability.getAdditionalVideoStreamingCapabilities()\n-\t\t\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// TODO handle??\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tOnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n-\t\t\t\t\t\tinternalInterface.sendRPC(onAppCapabilityUpdated);\n-\t\t\t\t\t\tstartStreaming(params, isEncrypted);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}else{\n-\t\t\t\t//We just use default video streaming params\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\tif(dispCap !=null){\n-\t\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t}\n-\t\t\t\tstartStreaming(params, encrypted);\n-\t\t\t}\n-\t\t}else{\n-\t\t\tstartStreaming(parameters, encrypted);\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n-\t * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n-\t *                    VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n-\t * @param encrypted Specify true if packets on this service have to be encrypted\n-\t */\n-\tprotected void startStreaming(VideoStreamingParameters parameters, boolean encrypted){\n-\t\tthis.parameters = parameters;\n-\t\tif (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n-\t\t\tDebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n-\t\t\treturn;\n-\t\t}\n-\t\t//Start the video service\n-\t\tthis.internalInterface.startVideoService(parameters, encrypted);\n-\t}\n-\n-\t/**\n-\t * Initializes and starts the virtual display encoder and creates the remote display\n-\t */\n-\tprivate void startEncoder(){\n-\t\ttry {\n-\t\t\tif (sdlRemoteDisplay != null) {\n-\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t}\n-\n-\t\t\tvirtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n-\t\t\t//We are all set so we can start streaming at at this point\n-\t\t\tvirtualDisplayEncoder.start();\n-\t\t\t//Encoder should be up and running\n-\t\t\tDisplay display = virtualDisplayEncoder.getDisplay();\n-\t\t\tcreateRemoteDisplay(display);\n-\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\thasStarted = true;\n-\t\t} catch (Exception e) {\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming from the remote display. To restart, call\n-\t * @see #resumeStreaming()\n-\t */\n-\tpublic void stopStreaming(boolean withPendingRestart){\n-\t\tif(sdlRemoteDisplay!=null && !withPendingRestart){\n-\t\t\tsdlRemoteDisplay.stop();\n-\t\t\tthis.withPendingRestart = false;\n-\t\t}\n-\t\tif (this.isStreaming()) {\n-\t\t\tif(virtualDisplayEncoder!=null){\n-\t\t\t\tvirtualDisplayEncoder.shutDown(withPendingRestart);\n-\t\t\t}\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.PAUSED);\n-\n-\t\t\tthis.internalInterface.stopVideoService();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Resumes streaming after calling\n-\t * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n-\t * followed by a call to\n-\t * @see #stopStreaming(boolean withPendingRestart)\n-\t */\n-\tpublic void resumeStreaming(){\n-\t\tint currentState = stateMachine.getState();\n-\t\tif (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n-\t\t\tstartEncoder();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming, ends video streaming service and removes service listeners.\n-\t */\n-\t@Override\n-\tpublic void dispose(){\n-\t\tstopStreaming(false);\n-\n-\t\thapticManager = null;\n-\t\tsdlRemoteDisplay = null;\n-\t\tparameters = null;\n-\t\tvirtualDisplayEncoder = null;\n-\t\tif (internalInterface != null) {\n-\t\t\tinternalInterface.stopVideoService();\n-\t\t\t// Remove listeners\n-\t\t\tinternalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t}\n-\n-\n-\n-\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\tsuper.dispose();\n-\t}\n-\n-\t// PUBLIC METHODS FOR CHECKING STATE\n-\n-\t/**\n-\t * Check if a video service is currently active\n-\t * @return boolean (true = active, false = inactive)\n-\t */\n-\tpublic boolean isServiceActive(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.READY) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STARTED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.PAUSED);\n-\t}\n-\n-\t/**\n-\t * Check if video is currently streaming and visible\n-\t * @return boolean (true = yes, false = no)\n-\t */\n-\tpublic boolean isStreaming(){\n-\t\tboolean state = (stateMachine.getState() == StreamingStateMachine.STARTED);\n-\t\tboolean capable = isHMIStateVideoStreamCapable(currentOnHMIStatus);\n-\t\treturn state && capable;\n-\t}\n-\n-\t/**\n-\t * Check if video streaming has been paused due to app moving to background or manually stopped\n-\t * @return boolean (true = not paused, false = paused)\n-\t */\n-\tpublic boolean isPaused(){\n-\t\treturn (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n-\t}\n-\n-\t/**\n-\t * Gets the current video streaming state as defined in @StreamingStateMachine\n-\t * @return int representing StreamingStateMachine.StreamingState\n-\t */\n-\tpublic @StreamingStateMachine.StreamingState int currentVideoStreamState(){\n-\t\treturn stateMachine.getState();\n-\t}\n-\n-\t// HELPER METHODS\n-\n-\tprivate void createRemoteDisplay(final Display disp){\n-\t\ttry{\n-\t\t\tif (disp == null){\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Dismiss the current presentation if the display has changed.\n-\t\t\tif (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n-\t\t\t\tsdlRemoteDisplay.dismissPresentation();\n-\t\t\t}\n-\n-\t\t\tFutureTask<Boolean> fTask =  new FutureTask<Boolean>( new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback(){\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCreated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Remote display has been created.\n-\t\t\t\t\t//Now is a good time to do parsing for spatial data\n-\t\t\t\t\tVideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\t//Get touch scalars\n-\t\t\t\t\tImageResolution resolution = null;\n-\t\t\t\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5){ //At this point we should already have the capability\n-\t\t\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\t\t\tif(capability != null){\n-\t\t\t\t\t\t\tresolution = capability.getPreferredResolution();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution == null){ //Either the protocol version is too low to access video streaming caps, or they were null\n-\t\t\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities) internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\t\t\tif (dispCap != null) {\n-\t\t\t\t\t\t\tresolution = (dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution != null){\n-\t\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\t\tdisp.getMetrics(displayMetrics);\n-\t\t\t\t\t\tcreateTouchScalar(resolution, displayMetrics);\n+    private static final String TAG = \"VideoStreamManager\";\n+\n+    private WeakReference<Context> context;\n+    private volatile VirtualDisplayEncoder virtualDisplayEncoder;\n+    private Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n+    private SdlRemoteDisplay sdlRemoteDisplay;\n+    private final float[] touchScalar = {1.0f, 1.0f}; //x, y\n+    private HapticInterfaceManager hapticManager;\n+    private SdlMotionEvent sdlMotionEvent = null;\n+    private OnHMIStatus currentOnHMIStatus;\n+    private final StreamingStateMachine stateMachine;\n+    private VideoStreamingParameters parameters;\n+    private VideoStreamingCapability originalCapability;\n+    private IVideoStreamListener streamListener;\n+    private boolean isTransportAvailable = false;\n+    private Integer majorProtocolVersion;\n+    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private boolean hasStarted;\n+    private String vehicleMake = null;\n+    private boolean isEncrypted = false;\n+    private boolean withPendingRestart = false;\n+    private AbstractPacketizer videoPacketizer;\n+\n+    // INTERNAL INTERFACES\n+\n+    private final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n+        @Override\n+        public void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n+            if (SessionType.NAV.equals(type)) {\n+                if (session != null && session.getAcceptedVideoParams() != null) {\n+                    parameters = session.getAcceptedVideoParams();\n+                    VideoStreamManager.this.streamListener = startVideoStream(session.getAcceptedVideoParams(), session);\n+                }\n+\n+                if (VideoStreamManager.this.streamListener == null) {\n+                    DebugTool.logError(TAG, \"Error starting video stream\");\n+                    stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                    return;\n+                }\n+                VideoStreamingCapability capability = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                }\n+                if (capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())) {\n+                    hapticManager = new HapticInterfaceManager(internalInterface);\n+                }\n+                checkState();\n+                startEncoder();\n+                stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+                hasStarted = true;\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceEnded(SdlSession session, SessionType type) {\n+            if (SessionType.NAV.equals(type)) {\n+                //stopVideoStream();\n+                if (sdlRemoteDisplay !=null){\n+                    stopStreaming(withPendingRestart);\n+                }\n+                stateMachine.transitionToState(StreamingStateMachine.NONE);\n+                transitionToState(SETTING_UP);\n+\n+                if (withPendingRestart){\n+                    VideoStreamManager manager = VideoStreamManager.this;\n+                    manager.internalInterface.startVideoService(\n+                            manager.getLastCachedStreamingParameters(),\n+                            manager.isEncrypted,\n+                            withPendingRestart\n+                    );\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceError(SdlSession session, SessionType type, String reason) {\n+            DebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n+            stopVideoStream();\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            transitionToState(BaseSubManager.ERROR);\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                OnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n+                currentOnHMIStatus = onHMIStatus;\n+                if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+                    getVideoStreamingParams();\n+                }\n+                checkState();\n+                if (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n+                    stopVideoStream();\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null && sdlRemoteDisplay != null) {\n+                List<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent) notification);\n+                if (motionEventList != null && !motionEventList.isEmpty()) {\n+                    for (MotionEvent motionEvent : motionEventList) {\n+                        sdlRemoteDisplay.handleMotionEvent(motionEvent);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+\n+            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+            // means only scale received\n+            if (castedCapability.getPreferredResolution() == null &&\n+                    castedCapability.getScale() != null &&\n+                    castedCapability.getScale() != 0 &&\n+                    VideoStreamManager.this.parameters != null\n+                    && VideoStreamManager.this.parameters.getResolution() != null) {\n+                // set cached resolution\n+                castedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+            }\n+            params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+            VideoStreamManager.this.parameters = params;\n+\n+            VideoStreamManager.this.withPendingRestart = true;\n+\n+            virtualDisplayEncoder.setStreamingParams(params);\n+            stopStreaming(true);\n+        }\n+\n+        @Override\n+        public void onError(String info) { }\n+    };\n+\n+    // MANAGER APIs\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public VideoStreamManager(ISdl internalInterface) {\n+        super(internalInterface);\n+\n+        if (internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n+                internalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n+            vehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n+        }\n+        virtualDisplayEncoder = new VirtualDisplayEncoder();\n+\n+        // Listen for video service events\n+        internalInterface.addServiceListener(SessionType.NAV, serviceListener);\n+        // Take care of the touch events\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+        // Listen for HMILevel changes\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        // Listen for SystemCapabilityType VIDEO_STREAMING\n+        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n+        stateMachine = new StreamingStateMachine();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        isTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n+        checkState();\n+        super.start(listener);\n+    }\n+\n+    private synchronized void checkState() {\n+        if (this.getState() == SETTING_UP\n+                && isTransportAvailable\n+                && isHMIStateVideoStreamCapable(currentOnHMIStatus)\n+                && parameters != null) {\n+            stateMachine.transitionToState(StreamingStateMachine.READY);\n+            transitionToState(READY);\n+        }\n+    }\n+\n+    boolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n+        HMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n+        VideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n+        return (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n+    }\n+\n+    private void getVideoStreamingParams() {\n+        if (internalInterface.getProtocolVersion().getMajor() >= 5) {\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                    @Override\n+                    public void onCapabilityRetrieved(Object capability) {\n+                        VideoStreamingParameters params = new VideoStreamingParameters();\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+                        params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+                        // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                        checkState();\n+                        }\n+\n+                    @Override\n+                    public void onError(String info) {\n+                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                        transitionToState(ERROR);\n+                    }\n+                }, false);\n+            }\n+        } else {\n+            //We just use default video streaming params\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+            DisplayCapabilities dispCap = null;\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+            }\n+            if (dispCap != null) {\n+                params.setResolution(dispCap.getScreenParams().getImageResolution());\n+            }\n+\n+            this.parameters = params;\n+            checkState();\n+        }\n+    }\n+\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {\n+            if (majorProtocolVersion >= 5) {\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                        @Override\n+                        public void onCapabilityRetrieved(Object capability) {\n+                            VideoStreamingParameters params = new VideoStreamingParameters();\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                            VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                            // Mocks data here\n+                            // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                            params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+                            if (listOfStreamingRanges != null) {\n+                                // filtering\n+                                castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                                );\n+                            } else { }\n+                            OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n+                            internalInterface.sendRPC(onAppCapabilityUpdated);\n+                            startStreaming(params, isEncrypted);\n+                        }\n+\n+                        @Override\n+                        public void onError(String info) {\n+                            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                            DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        }\n+                    }, false);\n+                }\n+            } else {\n+                //We just use default video streaming params\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                DisplayCapabilities dispCap = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                }\n+                if (dispCap != null) {\n+                    params.setResolution(dispCap.getScreenParams().getImageResolution());\n+                }\n+                startStreaming(params, encrypted);\n+            }\n+        } else {\n+            startStreaming(parameters, encrypted);\n+        }\n+    }\n+\n+\n+    /**\n+     * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n+     *\n+     * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n+     *                   VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n+     * @param encrypted  Specify true if packets on this service have to be encrypted\n+     */\n+    protected void startStreaming(VideoStreamingParameters parameters, boolean encrypted) {\n+        this.parameters = parameters;\n+        if (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n+            DebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n+            return;\n+        }\n+        //Start the video service\n+        this.internalInterface.startVideoService(parameters, encrypted, false);\n+    }\n+\n+    /**\n+     * Initializes and starts the virtual display encoder and creates the remote display\n+     */\n+    private void startEncoder() {\n+        try {\n+            if (sdlRemoteDisplay != null) {\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+            }\n+\n+            virtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n+            //We are all set so we can start streaming at at this point\n+            virtualDisplayEncoder.start();\n+            //Encoder should be up and running\n+            createRemoteDisplay(virtualDisplayEncoder.getDisplay());\n+\n+            stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+            hasStarted = true;\n+        } catch (Exception e) {\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    public void stopStreaming(boolean withPendingRestart) {\n+        if (sdlRemoteDisplay!= null && !withPendingRestart) {\n+            sdlRemoteDisplay.stop();\n+                this.withPendingRestart = false;\n+        }\n+        if (this.isStreaming()) {\n+            if (virtualDisplayEncoder!=null){\n+                virtualDisplayEncoder.shutDown(withPendingRestart);\n+            }\n+            stateMachine.transitionToState(StreamingStateMachine.PAUSED);\n+            stopVideoStream();\n+        }\n+    }\n+\n+    /**\n+     * Resumes streaming after calling\n+     *\n+     * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n+     * followed by a call to\n+     * @see #stopStreaming(boolean withPendingRestart)\n+     */\n+    public void resumeStreaming() {\n+        int currentState = stateMachine.getState();\n+        if (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n+            startEncoder();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming, ends video streaming service and removes service listeners.\n+     */\n+    @Override\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void dispose() {\n+        stopStreaming(false);\n+\n+        hapticManager = null;\n+        sdlRemoteDisplay = null;\n+        parameters = null;\n+        virtualDisplayEncoder = null;\n+        if (internalInterface != null) {\n+            // Remove listeners\n+            internalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        }\n+\n+        stopVideoStream();\n+\n+\n+        stateMachine.transitionToState(StreamingStateMachine.NONE);\n+        super.dispose();\n+    }\n+\n+    // PUBLIC METHODS FOR CHECKING STATE\n+\n+    /**\n+     * Check if a video service is currently active\n+     *\n+     * @return boolean (true = active, false = inactive)\n+     */\n+    public boolean isServiceActive() {\n+        return (stateMachine.getState() == StreamingStateMachine.READY) ||\n+                (stateMachine.getState() == StreamingStateMachine.STARTED) ||\n+                (stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n+                (stateMachine.getState() == StreamingStateMachine.PAUSED);\n+        }\n+\n+    /**\n+     * Check if video is currently streaming and visible\n+     *\n+     * @return boolean (true = yes, false = no)\n+     */\n+    public boolean isStreaming() {\n+        return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Check if video streaming has been paused due to app moving to background or manually stopped\n+     *\n+     * @return boolean (true = not paused, false = paused)\n+     */\n+    public boolean isPaused() {\n+        return (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Gets the current video streaming state as defined in @StreamingStateMachine\n+     *\n+     * @return int representing StreamingStateMachine.StreamingState\n+     */\n+    public @StreamingStateMachine.StreamingState\n+    int currentVideoStreamState() {\n+        return stateMachine.getState();\n+    }\n+\n+    // HELPER METHODS\n+\n+    private void createRemoteDisplay(final Display disp) {\n+        try {\n+            if (disp == null) {\n+                return;\n+            }\n+\n+            // Dismiss the current presentation if the display has changed.\n+            if (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n+                sdlRemoteDisplay.dismissPresentation();\n+            }\n+\n+            FutureTask<Boolean> fTask = new FutureTask<>(new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback() {\n+                @Override\n+                public void onCreated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Remote display has been created.\n+                    //Now is a good time to do parsing for spatial data\n+                    VideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                    //Get touch scalars\n+                    ImageResolution resolution = null;\n+                    if (internalInterface.getProtocolVersion().getMajor() >= 5) { //At this point we should already have the capability\n+                        VideoStreamingCapability capability = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                        }\n+                        if (capability != null) {\n+                            resolution = capability.getPreferredResolution();\n+                        }\n+                    }\n+\n+                    if (resolution == null) { //Either the protocol version is too low to access video streaming caps, or they were null\n+                        DisplayCapabilities dispCap = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                        }\n+                        if (dispCap != null) {\n+                            resolution = (dispCap.getScreenParams().getImageResolution());\n+                        }\n+                    }\n+\n+                    if (resolution != null) {\n+                        DisplayMetrics displayMetrics = new DisplayMetrics();\n+                        disp.getMetrics(displayMetrics);\n+                        createTouchScalar(resolution, displayMetrics);\n                     }\n \n-\t\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Our view has been invalidated\n-\t\t\t\t\t//A good time to refresh spatial data\n-\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\tsdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n-\t\t\t\t\tdisplayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n-\t\t\t\t\tdisplayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n-\t\t\t\t\tcreateTouchScalar(parameters.getResolution(), displayMetrics);\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ));\n-\t\t\tThread showPresentation = new Thread(fTask);\n-\t\t\tshowPresentation.setName(\"RmtDispThread\");\n-\n-\t\t\tshowPresentation.start();\n-\t\t} catch (Exception ex) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n-\t\t\tif(DebugTool.isDebugEnabled()){\n-\t\t\t\tex.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail){\n-\n-\t\tisTransportAvailable = videoStreamTransportAvail;\n-\n-\t\tif(internalInterface.getProtocolVersion().isNewerThan(new Version(5,1,0)) >= 0){\n-\t\t\tif(videoStreamTransportAvail){\n-\t\t\t\tcheckState();\n-\t\t\t}\n-\t\t}else{\n-\t\t\t//The protocol version doesn't support simultaneous transports.\n-\t\t\tif(!videoStreamTransportAvail){\n-\t\t\t\t//If video streaming isn't available on primary transport then it is not possible to\n-\t\t\t\t//use the video streaming manager until a complete register on a transport that\n-\t\t\t\t//supports video\n-\t\t\t\ttransitionToState(ERROR);\n-\t\t\t}\n-\t\t}\n-\t}\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+                }\n+\n+                @Override\n+                public void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Our view has been invalidated\n+                    //A good time to refresh spatial data\n+                    DisplayMetrics displayMetrics = new DisplayMetrics();\n+                    sdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n+                    displayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n+                    displayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n+                    createTouchScalar(parameters.getResolution(), displayMetrics);\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                }\n+            }));\n+            Thread showPresentation = new Thread(fTask);\n+            showPresentation.setName(\"RmtDispThread\");\n+\n+            showPresentation.start();\n+        } catch (Exception ex) {\n+            DebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n+            if (DebugTool.isDebugEnabled()) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail) {\n+\n+        isTransportAvailable = videoStreamTransportAvail;\n+\n+        if (internalInterface.getProtocolVersion().isNewerThan(new Version(5, 1, 0)) >= 0) {\n+            if (videoStreamTransportAvail) {\n+                checkState();\n+            }\n+        } else {\n+            //The protocol version doesn't support simultaneous transports.\n+            if (!videoStreamTransportAvail) {\n+                //If video streaming isn't available on primary transport then it is not possible to\n+                //use the video streaming manager until a complete register on a transport that\n+                //supports video\n+                transitionToState(ERROR);\n+            }\n+        }\n+    }\n \n     void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics) {\n-        touchScalar[0] = ((float)displayMetrics.widthPixels) / resolution.getResolutionWidth();\n-        touchScalar[1] = ((float)displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+        touchScalar[0] = ((float) displayMetrics.widthPixels) / resolution.getResolutionWidth();\n+        touchScalar[1] = ((float) displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+    }\n+\n+    List<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent) {\n+        List<MotionEvent> motionEventList = new ArrayList<>();\n+\n+        List<TouchEvent> touchEventList = onTouchEvent.getEvent();\n+        if (touchEventList == null || touchEventList.size() == 0) return null;\n+\n+        TouchType touchType = onTouchEvent.getType();\n+        if (touchType == null) {\n+            return null;\n+        }\n+\n+        if (sdlMotionEvent == null) {\n+            if (touchType == TouchType.BEGIN) {\n+                sdlMotionEvent = new SdlMotionEvent();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        SdlMotionEvent.Pointer pointer;\n+        MotionEvent motionEvent;\n+\n+        for (TouchEvent touchEvent : touchEventList) {\n+            if (touchEvent == null || touchEvent.getId() == null) {\n+                continue;\n+            }\n+\n+            List<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n+            if (touchCoordList == null || touchCoordList.size() == 0) {\n+                continue;\n+            }\n+\n+            TouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n+            if (touchCoord == null) {\n+                continue;\n+            }\n+\n+            int motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n+            long downTime = sdlMotionEvent.downTime;\n+            long eventTime = sdlMotionEvent.eventTime;\n+            pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n+            if (pointer != null) {\n+                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n+            }\n+\n+            MotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n+            MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n+\n+            for (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n+                pointerProperties[i] = new MotionEvent.PointerProperties();\n+                pointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n+                pointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n+\n+                pointerCoords[i] = new MotionEvent.PointerCoords();\n+                pointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n+                pointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n+                pointerCoords[i].orientation = 0;\n+                pointerCoords[i].pressure = 1.0f;\n+                pointerCoords[i].size = 1;\n+            }\n+\n+            motionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n+                    sdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n+                    1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n+            motionEventList.add(motionEvent);\n+\n+            if (motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL) {\n+                //If the motion event should be finished we should clear our reference\n+                sdlMotionEvent.pointers.clear();\n+                sdlMotionEvent = null;\n+                break;\n+            } else if ((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP) {\n+                sdlMotionEvent.removePointerById(touchEvent.getId());\n+            }\n+        }\n+\n+        return motionEventList;\n+    }\n+\n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n     }\n \n-\tList<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent){\n-\t\tList<MotionEvent> motionEventList = new ArrayList<MotionEvent>();\n-\n-\t\tList<TouchEvent> touchEventList = onTouchEvent.getEvent();\n-\t\tif (touchEventList == null || touchEventList.size() == 0) return null;\n-\n-\t\tTouchType touchType = onTouchEvent.getType();\n-\t\tif (touchType == null) { return null; }\n-\n-\t\tif(sdlMotionEvent == null) {\n-\t\t\tif (touchType == TouchType.BEGIN) {\n-\t\t\t\tsdlMotionEvent = new SdlMotionEvent();\n-\t\t\t} else{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tSdlMotionEvent.Pointer pointer;\n-\t\tMotionEvent motionEvent;\n-\n-\t\tfor (TouchEvent touchEvent : touchEventList) {\n-\t\t\tif (touchEvent == null || touchEvent.getId() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tList<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n-\t\t\tif (touchCoordList == null || touchCoordList.size() == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tTouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n-\t\t\tif (touchCoord == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tint motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n-\t\t\tlong downTime = sdlMotionEvent.downTime;\n-\t\t\tlong eventTime = sdlMotionEvent.eventTime;\n-\t\t\tpointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n-\t\t\tif (pointer != null) {\n-\t\t\t\tpointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n-\t\t\t}\n-\n-\t\t\tMotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n-\t\t\tMotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n-\n-\t\t\tfor (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n-\t\t\t\tpointerProperties[i] = new MotionEvent.PointerProperties();\n-\t\t\t\tpointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n-\t\t\t\tpointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n-\n-\t\t\t\tpointerCoords[i] = new MotionEvent.PointerCoords();\n-\t\t\t\tpointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n-\t\t\t\tpointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n-\t\t\t\tpointerCoords[i].orientation = 0;\n-\t\t\t\tpointerCoords[i].pressure = 1.0f;\n-\t\t\t\tpointerCoords[i].size = 1;\n-\t\t\t}\n-\n-\t\t\tmotionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n-\t\t\t\t\tsdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n-\t\t\t\t\t1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n-\t\t\tmotionEventList.add(motionEvent);\n-\n-\t\t\tif(motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL){\n-\t\t\t\t//If the motion event should be finished we should clear our reference\n-\t\t\t\tsdlMotionEvent.pointers.clear();\n-\t\t\t\tsdlMotionEvent = null;\n-\t\t\t\tbreak;\n-\t\t\t} else if((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP){\n-\t\t\t\tsdlMotionEvent.removePointerById(touchEvent.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn motionEventList;\n-\t}\n-\n-\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n-\t\treturn parameters;\n-\t}\n-\n-\tpublic boolean getLastCachedIsEncrypted() {\n-\t\treturn isEncrypted;\n-\t}\n-\n-\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n-\t\t\tResolution minResolution,\n-\t\t\tResolution maxResolution,\n-\t\t\tDouble constraintDiagonalMax,\n-\t\t\tAspectRatio ratioRange,\n-\t\t\tList<VideoStreamingCapability> originalAdditionalCapabilities\n-\t){\n-\t\tInteger constraintHeightMax = maxResolution.getResolutionHeight();\n-\t\tInteger constraintHeightMin = minResolution.getResolutionHeight();\n-\t\tInteger constraintWidthMax = maxResolution.getResolutionWidth();\n-\t\tInteger constraintWidthMin = minResolution.getResolutionWidth();\n-\t\tDouble aspectRationMin = ratioRange.getMinAspectRatio();\n-\t\tDouble aspectRationMax = ratioRange.getMaxAspectRatio();\n-\n-\t\tList<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n-\n-\t\tVideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n-\t\tpreferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n-\t\tpreferredCapability.setPreferredResolution(new ImageResolution(\n-\t\t\t\tparameters.getResolution().getResolutionWidth(),\n-\t\t\t\tparameters.getResolution().getResolutionHeight())\n-\t\t);\n-\n-\t\t// get the first one - the Desired resolution to guarantee streaming will start\n-\t\tvalidCapabilities.add(preferredCapability);\n-\n-\t\tfor (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n-\t\t\tdouble diagonal;\n-\t\t\tint resolutionHeight;\n-\t\t\tint resolutionWidth;\n-\t\t\t// TODO refactor\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionHeight() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionHeight = capability.getPreferredResolution().getResolutionHeight();\n-\t\t\t}\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionWidth() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionWidth = capability.getPreferredResolution().getResolutionWidth();\n-\t\t\t}\n-\t\t\tif (capability.getDiagonalScreenSize() == null ) {\n-\t\t\t\tdiagonal = parameters.getPreferredDiagonal();\n-\t\t\t} else {\n-\t\t\t\tdiagonal = capability.getDiagonalScreenSize();\n-\t\t\t}\n-\n-\t\t\tif (constraintDiagonalMax < diagonal) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!isAspectRatioInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tif (constraintHeightMax == null && constraintHeightMin == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!isImageResolutionInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tvalidCapabilities.add(capability);\n-\t\t}\n-\n-\t\treturn validCapabilities;\n-\t}\n-\n-\tpublic Boolean isImageResolutionInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\n-\t\tInteger constraintHeightMax = range.getMaxSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintHeightMin = range.getMinSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintWidthMax = range.getMaxSupportedResolution().getResolutionWidth();\n-\t\tInteger constraintWidthMin = range.getMinSupportedResolution().getResolutionWidth();\n-\t\tInteger resolutionHeight = currentResolution.getResolutionHeight();\n-\t\tInteger resolutionWidth = currentResolution.getResolutionWidth();\n-\t\tif (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null)\n-\t\t{\n-\t\t\tif (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tif (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// TODO check what if dev provided invalid constraints\n-\t\treturn true;\n-\t}\n-\n-\tpublic Boolean isAspectRatioInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\t\tDouble aspectRatioMin = range.getAspectRatio().getMinAspectRatio();\n-\t\tDouble aspectRatioMax = range.getAspectRatio().getMaxAspectRatio();\n-\n-\t\tDouble currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n-\n-\t\tif (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n-\t\t\tif ((currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\t// TODO check what if dev provided invalid constraints\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * Keeps track of the current motion event for VPM\n-\t */\n-\tprivate static class SdlMotionEvent {\n-\t\tclass Pointer {\n-\t\t\tint id;\n-\t\t\tfloat x;\n-\t\t\tfloat y;\n-\t\t\tPointer (int id) {\n-\t\t\t\tthis.id = id;\n-\t\t\t\tthis.x = 0.0f;\n-\t\t\t\tthis.y = 0.0f;\n-\t\t\t}\n-\t\t\tvoid setCoords(float x, float y) {\n-\t\t\t\tthis.x = x;\n-\t\t\t\tthis.y = y;\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n-\t\tprivate long downTime;\n-\t\tprivate long downTimeOnHMI;\n-\t\tprivate long eventTime;\n-\n-\t\tSdlMotionEvent(){\n-\t\t\tdownTimeOnHMI = 0;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n-\t\t * Android MotionEvent according to this events status\n-\t\t * @param touchType The SDL TouchType that was received from the module\n-\t\t * @param touchEvent The SDL TouchEvent that was received from the module\n-\t\t * @return the correct native Android MotionEvent action to dispatch\n-\t\t */\n-\t\tsynchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent){\n-\t\t\teventTime = 0;\n-\t\t\tint motionEventAction = -1;\n-\t\t\tswitch (touchType){\n-\t\t\t\tcase BEGIN:\n-\t\t\t\t\tif(pointers.size() == 0){\n-\t\t\t\t\t\t//The motion event has just begun\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_DOWN;\n-\t\t\t\t\t\tdownTime = SystemClock.uptimeMillis();\n-\t\t\t\t\t\tdownTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n-\t\t\t\t\t\teventTime = downTime;\n-\t\t\t\t\t} else{\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\t}\n-\t\t\t\t\tpointers.add(new Pointer(touchEvent.getId()));\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase MOVE:\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_MOVE;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase END:\n-\t\t\t\t\tif(pointers.size() <= 1){\n-\t\t\t\t\t\t//The motion event has just ended\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tint pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n-\t\t\t\t\t\tif (pointerIndex != -1) {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase CANCEL:\n-\t\t\t\t\t//Assuming this cancels the entire event\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_CANCEL;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\treturn motionEventAction;\n-\t\t}\n-\n-\t\tPointer getPointerById(int id){\n-\t\t\tif (pointers != null && !pointers.isEmpty()){\n-\t\t\t\tfor (Pointer pointer : pointers){\n-\t\t\t\t\tif (pointer.id == id){\n-\t\t\t\t\t\treturn pointer;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tPointer getPointerByIndex(int index){\n-\t\t\treturn pointers.get(index);\n-\t\t}\n-\n-\t\tvoid removePointerById(int id){\n-\t\t\tpointers.remove(getPointerById(id));\n-\t\t}\n-\t}\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n+        Double aspectRatioMin = aspectRatio.getMinAspectRatio();\n+        Double aspectRatioMax = aspectRatio.getMaxAspectRatio();\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n+            if (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Keeps track of the current motion event for VPM\n+     */\n+    private static class SdlMotionEvent {\n+        class Pointer {\n+            final int id;\n+            float x;\n+            float y;\n+\n+            Pointer(int id) {\n+                this.id = id;\n+                this.x = 0.0f;\n+                this.y = 0.0f;\n+            }\n+\n+            void setCoords(float x, float y) {\n+                this.x = x;\n+                this.y = y;\n+            }\n+        }\n+\n+        private final CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n+        private long downTime;\n+        private long downTimeOnHMI;\n+        private long eventTime;\n+\n+        SdlMotionEvent() {\n+            downTimeOnHMI = 0;\n+        }\n+\n+        /**\n+         * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n+         * Android MotionEvent according to this events status\n+         *\n+         * @param touchType  The SDL TouchType that was received from the module\n+         * @param touchEvent The SDL TouchEvent that was received from the module\n+         * @return the correct native Android MotionEvent action to dispatch\n+         */\n+        synchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent) {\n+            eventTime = 0;\n+            int motionEventAction = -1;\n+            switch (touchType) {\n+                case BEGIN:\n+                    if (pointers.size() == 0) {\n+                        //The motion event has just begun\n+                        motionEventAction = MotionEvent.ACTION_DOWN;\n+                        downTime = SystemClock.uptimeMillis();\n+                        downTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n+                        eventTime = downTime;\n+                    } else {\n+                        motionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    }\n+                    pointers.add(new Pointer(touchEvent.getId()));\n+                    break;\n+                case MOVE:\n+                    motionEventAction = MotionEvent.ACTION_MOVE;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case END:\n+                    if (pointers.size() <= 1) {\n+                        //The motion event has just ended\n+                        motionEventAction = MotionEvent.ACTION_UP;\n+                    } else {\n+                        int pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n+                        if (pointerIndex != -1) {\n+                            motionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        } else {\n+                            motionEventAction = MotionEvent.ACTION_UP;\n+                        }\n+                    }\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case CANCEL:\n+                    //Assuming this cancels the entire event\n+                    motionEventAction = MotionEvent.ACTION_CANCEL;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return motionEventAction;\n+        }\n+\n+        Pointer getPointerById(int id) {\n+            if (pointers != null && !pointers.isEmpty()) {\n+                for (Pointer pointer : pointers) {\n+                    if (pointer.id == id) {\n+                        return pointer;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        Pointer getPointerByIndex(int index) {\n+            return pointers.get(index);\n+        }\n+\n+        void removePointerById(int id) {\n+            pointers.remove(getPointerById(id));\n+        }\n+    }\n+\n+    private VideoStreamingProtocol getAcceptedProtocol(VideoStreamingParameters params) {\n+        if (params != null) {\n+            VideoStreamingFormat format = params.getFormat();\n+            if (format != null && format.getProtocol() != null) {\n+                return format.getProtocol();\n+            }\n+        }\n+        //Returns default protocol if none are found\n+        return new VideoStreamingParameters().getFormat().getProtocol();\n+\n+    }\n+\n+    protected IVideoStreamListener startVideoStream(VideoStreamingParameters params, final SdlSession session) {\n+        VideoStreamingProtocol protocol = getAcceptedProtocol(params);\n+\n+        IStreamListener iStreamListener = new IStreamListener() {\n+            @Override\n+            public void sendStreamPacket(ProtocolMessage pm) {\n+                session.sendMessage(pm);\n+            }\n+        };\n+\n+        try {\n+            switch (protocol) {\n+                case RAW: {\n+                    videoPacketizer = new StreamPacketizer(iStreamListener, null, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                case RTP: {\n+                    //FIXME why is this not an extension of StreamPacketizer?\n+                    videoPacketizer = new RTPH264Packetizer(iStreamListener, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                default:\n+                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\n+                    return null;\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    protected boolean stopVideoStream() {\n+        if (videoPacketizer != null) {\n+            videoPacketizer.stop();\n+            return true;\n+        }\n+        return false;\n+    }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgyMDM0OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471820349", "bodyText": "On line 166, you can use the TAG variable instead of \"MyTagLog\"", "author": "santhanamk", "createdAt": "2020-08-17T23:01:53Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -138,13 +150,20 @@ public void update(VideoStreamingParameters params){\n      */\n     public void update(VideoStreamingCapability capability, String vehicleMake){\n         if(capability.getMaxBitrate()!=null){ this.bitrate = capability.getMaxBitrate() * 1000; } // NOTE: the unit of maxBitrate in getSystemCapability is kbps.\n-        double scale = DEFAULT_SCALE;\n         if(capability.getScale() != null) { scale = capability.getScale(); }\n+        if (capability.getDiagonalScreenSize() != null) { preferredDiagonal = capability.getDiagonalScreenSize(); }\n         ImageResolution resolution = capability.getPreferredResolution();\n+        if (capability.getAdditionalVideoStreamingCapabilities() != null &&\n+                !capability.getAdditionalVideoStreamingCapabilities().isEmpty()) {\n+            this.additionalCapabilities = capability.getAdditionalVideoStreamingCapabilities();\n+        }\n         if(resolution!=null){\n \n             if (vehicleMake != null) {\n-                if ((vehicleMake.contains(\"Ford\") || vehicleMake.contains(\"Lincoln\")) && ((resolution.getResolutionHeight() != null && resolution.getResolutionHeight() > 800) || (resolution.getResolutionWidth() != null && resolution.getResolutionWidth() > 800))) {\n+                if ((vehicleMake.contains(\"Ford\") || vehicleMake.contains(\"Lincoln\")) &&\n+                        ((resolution.getResolutionHeight() != null && resolution.getResolutionHeight() > 800) ||\n+                                (resolution.getResolutionWidth() != null && resolution.getResolutionWidth() > 800))) {\n+                    Log.d(\"MyTagLog\", \"specific case\");", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex cf4ac22b0..5ab5ca931 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -139,45 +140,52 @@ public class VideoStreamingParameters {\n         }\n     }\n \n-\n     /**\n      * Update the values contained in the capability that should have been returned through the SystemCapabilityManager.\n      * This update will use the most preferred streaming format from the module.\n-     * @param capability the video streaming capability returned from the SystemCapabilityManager\n+     *\n+     * @param capability  the video streaming capability returned from the SystemCapabilityManager\n      * @param vehicleMake the vehicle make from the RegisterAppInterfaceResponse\n-     * @see com.smartdevicelink.proxy.SystemCapabilityManager\n+     * @see com.smartdevicelink.managers.lifecycle.SystemCapabilityManager\n      * @see VideoStreamingCapability\n      */\n-    public void update(VideoStreamingCapability capability, String vehicleMake){\n-        if(capability.getMaxBitrate()!=null){ this.bitrate = capability.getMaxBitrate() * 1000; } // NOTE: the unit of maxBitrate in getSystemCapability is kbps.\n-        if(capability.getScale() != null) { scale = capability.getScale(); }\n+    public void update(VideoStreamingCapability capability, String vehicleMake) {\n+        if (capability.getMaxBitrate() != null) {\n+            this.bitrate = capability.getMaxBitrate() * 1000;\n+        } // NOTE: the unit of maxBitrate in getSystemCapability is kbps.\n+        if (capability.getScale() != null) {\n+            scale = capability.getScale();\n+        }\n         if (capability.getDiagonalScreenSize() != null) { preferredDiagonal = capability.getDiagonalScreenSize(); }\n         ImageResolution resolution = capability.getPreferredResolution();\n         if (capability.getAdditionalVideoStreamingCapabilities() != null &&\n                 !capability.getAdditionalVideoStreamingCapabilities().isEmpty()) {\n             this.additionalCapabilities = capability.getAdditionalVideoStreamingCapabilities();\n         }\n-        if(resolution!=null){\n+        if (resolution != null) {\n \n             if (vehicleMake != null) {\n                 if ((vehicleMake.contains(\"Ford\") || vehicleMake.contains(\"Lincoln\")) &&\n                         ((resolution.getResolutionHeight() != null && resolution.getResolutionHeight() > 800) ||\n                                 (resolution.getResolutionWidth() != null && resolution.getResolutionWidth() > 800))) {\n-                    Log.d(\"MyTagLog\", \"specific case\");\n                     scale = 1.0 / 0.75;\n                 }\n             }\n \n-            if(resolution.getResolutionHeight()!=null && resolution.getResolutionHeight() > 0){ this.resolution.setResolutionHeight((int)(resolution.getResolutionHeight() / scale)); }\n-            if(resolution.getResolutionWidth()!=null && resolution.getResolutionWidth() > 0){ this.resolution.setResolutionWidth((int)(resolution.getResolutionWidth() / scale)); }\n+            if (resolution.getResolutionHeight() != null && resolution.getResolutionHeight() > 0) {\n+                this.resolution.setResolutionHeight((int) (resolution.getResolutionHeight() / scale));\n+            }\n+            if (resolution.getResolutionWidth() != null && resolution.getResolutionWidth() > 0) {\n+                this.resolution.setResolutionWidth((int) (resolution.getResolutionWidth() / scale));\n+            }\n         }\n \n         // This should be the last call as it will return out once a suitable format is found\n         final List<VideoStreamingFormat> formats = capability.getSupportedFormats();\n         if(formats != null && formats.size()>0){\n             for(VideoStreamingFormat format : formats){\n-                for(int i = 0; i < CURRENTLY_SUPPORTED_FORMATS.length; i ++){\n-                    if(CURRENTLY_SUPPORTED_FORMATS[i].equals(format) ){\n+                for(int i = 0; i < currentlySupportedFormats.length; i ++){\n+                    if(currentlySupportedFormats[i].equals(format) ){\n                         this.format = format;\n                         return;\n                     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgyMDU0Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471820542", "bodyText": "You may not need this function public List<VideoStreamingCapability> getAdditionalCapabilities() { return additionalCapabilities; };.\nIt is not being used.", "author": "santhanamk", "createdAt": "2020-08-17T23:02:31Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -259,6 +279,13 @@ public ImageResolution getResolution() {\n \t\treturn resolution;\n \t}\n \n+    public double getScale() { return scale; }\n+\n+    public double getPreferredDiagonal() { return preferredDiagonal; }\n+\n+    public List<VideoStreamingCapability> getAdditionalCapabilities() { return additionalCapabilities; };", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex cf4ac22b0..5ab5ca931 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -263,29 +270,26 @@ public class VideoStreamingParameters {\n         return interval;\n     }\n \n-    public void setFormat(VideoStreamingFormat format){\n-\t    this.format = format;\n+    public void setFormat(VideoStreamingFormat format) {\n+        this.format = format;\n     }\n \n-    public VideoStreamingFormat getFormat(){\n-\t    return format;\n+    public VideoStreamingFormat getFormat() {\n+        return format;\n     }\n \n-    public void setResolution(ImageResolution resolution){\n-\t    this.resolution = resolution;\n+    public void setResolution(ImageResolution resolution) {\n+        this.resolution = resolution;\n     }\n \n-\tpublic ImageResolution getResolution() {\n-\t\treturn resolution;\n-\t}\n+    public ImageResolution getResolution() {\n+        return resolution;\n+    }\n \n     public double getScale() { return scale; }\n \n     public double getPreferredDiagonal() { return preferredDiagonal; }\n \n-    public List<VideoStreamingCapability> getAdditionalCapabilities() { return additionalCapabilities; };\n-\n-    // TODO extend with @additionalCapabilities if confirmed\n     @Override\n     public String toString() {\n         StringBuilder builder = new StringBuilder();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgyNjAwNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471826006", "bodyText": "AppCapabilityType.java needs a valueForString() method.\nYou could define like below:\n`\"    ;\n/**\n * Convert String to AppCapabilityType\n * @param value String\n * @return AppCapabilityType\n */\npublic static AppCapabilityType valueForString(String value) {\n    try{\n        return valueOf(value);\n    }catch(Exception e){\n        return null;\n    }\n}\"`", "author": "santhanamk", "createdAt": "2020-08-17T23:19:13Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.smartdevicelink.proxy.rpc.enums;\n+\n+/**\n+ * Since SmartDeviceLink 6.0\n+ * Enumerations of all available app capability types\n+ */\n+public enum AppCapabilityType {\n+    VIDEO_STREAMING,", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\nindex a86119c12..7285edae6 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n\n@@ -1,9 +1,23 @@\n package com.smartdevicelink.proxy.rpc.enums;\n \n /**\n- * Since SmartDeviceLink 6.0\n+ * @since SmartDeviceLink 7.0\n  * Enumerations of all available app capability types\n  */\n public enum AppCapabilityType {\n     VIDEO_STREAMING,\n+    ;\n+\n+    /**\n+     * Convert String to AppCapabilityType\n+     * @param value String\n+     * @return AppCapabilityType\n+     */\n+    public static AppCapabilityType valueForString(String value) {\n+        try{\n+            return valueOf(value);\n+        }catch(Exception e){\n+            return null;\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgyNzE0MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471827141", "bodyText": "Unit tests for this enum are needed.  They should be in a file called AppCapabilityTypeTests.java under the .../test/rpc/enums folder.", "author": "santhanamk", "createdAt": "2020-08-17T23:22:49Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.smartdevicelink.proxy.rpc.enums;\n+\n+/**\n+ * Since SmartDeviceLink 6.0", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\nindex a86119c12..7285edae6 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n\n@@ -1,9 +1,23 @@\n package com.smartdevicelink.proxy.rpc.enums;\n \n /**\n- * Since SmartDeviceLink 6.0\n+ * @since SmartDeviceLink 7.0\n  * Enumerations of all available app capability types\n  */\n public enum AppCapabilityType {\n     VIDEO_STREAMING,\n+    ;\n+\n+    /**\n+     * Convert String to AppCapabilityType\n+     * @param value String\n+     * @return AppCapabilityType\n+     */\n+    public static AppCapabilityType valueForString(String value) {\n+        try{\n+            return valueOf(value);\n+        }catch(Exception e){\n+            return null;\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkzNDAxOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471934019", "bodyText": "VideoStreamingCapability capability is not mandatory, so you do not need to initialize it in this constructor.", "author": "santhanamk", "createdAt": "2020-08-18T06:04:05Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.smartdevicelink.proxy.rpc;\n+\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.proxy.RPCStruct;\n+import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n+\n+import java.util.Hashtable;\n+\n+public class AppCapability extends RPCStruct {\n+    public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n+    public static final String KEY_VIDEO_STREAMING_CAPABILITY = \"videoStreamingCapability\";\n+\n+    public AppCapability() {\n+    }\n+\n+    /**\n+     * Constructs a new AppCapability object indicated by the Hashtable\n+     * parameter\n+     *\n+     * @param hash hashtable filled with params to create an instance of this RPC\n+     *             The hash table to use\n+     */\n+    public AppCapability(Hashtable<String, Object> hash) {\n+        super(hash);\n+    }\n+\n+    public AppCapability(@NonNull VideoStreamingCapability capability, AppCapabilityType appCapabilityType) {\n+        this();", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3NjE1NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473376155", "bodyText": "VideoStreamingCapability capability is not mandatory, so you do not need to initialize it in this constructor.\n\n@kostyaBoss I still see VideoStreamingCapability capability being passed into the constructor on line 29.  You don't need it, since it is not a mandatory field.", "author": "santhanamk", "createdAt": "2020-08-19T22:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkzNDAxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\nindex e4b78bed5..31f33125d 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n\n@@ -1,12 +1,16 @@\n package com.smartdevicelink.proxy.rpc;\n \n-import android.support.annotation.NonNull;\n+\n+import androidx.annotation.NonNull;\n \n import com.smartdevicelink.proxy.RPCStruct;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n \n import java.util.Hashtable;\n \n+/**\n+ * @since SmartDeviceLink 7.0\n+ */\n public class AppCapability extends RPCStruct {\n     public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n     public static final String KEY_VIDEO_STREAMING_CAPABILITY = \"videoStreamingCapability\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkzNDYxMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471934613", "bodyText": "On line 43, this should be \"...getObject(AppCapabilityType.class...)\"  instead of \"...getObject(VideoStreamingCapability.class...\"", "author": "santhanamk", "createdAt": "2020-08-18T06:05:54Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.smartdevicelink.proxy.rpc;\n+\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.proxy.RPCStruct;\n+import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n+\n+import java.util.Hashtable;\n+\n+public class AppCapability extends RPCStruct {\n+    public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n+    public static final String KEY_VIDEO_STREAMING_CAPABILITY = \"videoStreamingCapability\";\n+\n+    public AppCapability() {\n+    }\n+\n+    /**\n+     * Constructs a new AppCapability object indicated by the Hashtable\n+     * parameter\n+     *\n+     * @param hash hashtable filled with params to create an instance of this RPC\n+     *             The hash table to use\n+     */\n+    public AppCapability(Hashtable<String, Object> hash) {\n+        super(hash);\n+    }\n+\n+    public AppCapability(@NonNull VideoStreamingCapability capability, AppCapabilityType appCapabilityType) {\n+        this();\n+        setVideoStreamingCapability(capability);\n+        setAppCapabilityType(appCapabilityType);\n+    }\n+\n+    public VideoStreamingCapability getVideoStreamingCapability() {\n+        return (VideoStreamingCapability) getObject(VideoStreamingCapability.class, KEY_VIDEO_STREAMING_CAPABILITY);\n+    }\n+\n+    public void setVideoStreamingCapability(@NonNull VideoStreamingCapability capabilityType) {\n+        setValue(KEY_VIDEO_STREAMING_CAPABILITY, capabilityType);\n+    }\n+\n+    public AppCapabilityType getAppCapabilityType() {\n+        return (AppCapabilityType) getObject(VideoStreamingCapability.class, KEY_APP_CAPABILITY_TYPE);", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\nindex e4b78bed5..31f33125d 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n\n@@ -1,12 +1,16 @@\n package com.smartdevicelink.proxy.rpc;\n \n-import android.support.annotation.NonNull;\n+\n+import androidx.annotation.NonNull;\n \n import com.smartdevicelink.proxy.RPCStruct;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n \n import java.util.Hashtable;\n \n+/**\n+ * @since SmartDeviceLink 7.0\n+ */\n public class AppCapability extends RPCStruct {\n     public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n     public static final String KEY_VIDEO_STREAMING_CAPABILITY = \"videoStreamingCapability\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkzNTY2Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471935662", "bodyText": "Unit tests are needed for this class, and should be defined in AppCapabilityTests.java", "author": "santhanamk", "createdAt": "2020-08-18T06:09:15Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.smartdevicelink.proxy.rpc;\n+\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.proxy.RPCStruct;\n+import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n+\n+import java.util.Hashtable;\n+\n+public class AppCapability extends RPCStruct {", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\nindex e4b78bed5..31f33125d 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n\n@@ -1,12 +1,16 @@\n package com.smartdevicelink.proxy.rpc;\n \n-import android.support.annotation.NonNull;\n+\n+import androidx.annotation.NonNull;\n \n import com.smartdevicelink.proxy.RPCStruct;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n \n import java.util.Hashtable;\n \n+/**\n+ * @since SmartDeviceLink 7.0\n+ */\n public class AppCapability extends RPCStruct {\n     public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n     public static final String KEY_VIDEO_STREAMING_CAPABILITY = \"videoStreamingCapability\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkzODQ0MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471938441", "bodyText": "This class is missing unit tests.  Unit tests should be defined in the file OnAppCapabilityUpdatedTests.java", "author": "santhanamk", "createdAt": "2020-08-18T06:17:37Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.smartdevicelink.proxy.rpc;\n+\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCNotification;\n+\n+import java.util.Hashtable;\n+\n+/**\n+ * since Smart Device Link 6.0\n+ * A notification to inform SDL Core that a specific app capability has changed.\n+ */\n+\n+public class OnAppCapabilityUpdated extends RPCNotification {", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\nindex 18e8a6e2c..92f82c1b2 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\n\n@@ -6,7 +6,8 @@ import com.smartdevicelink.proxy.RPCNotification;\n import java.util.Hashtable;\n \n /**\n- * since Smart Device Link 6.0\n+ *\n+ * @since Smart Device Link 7.0\n  * A notification to inform SDL Core that a specific app capability has changed.\n  */\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0MDE3Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471940176", "bodyText": "This looks good,but the unit tests in VideoStreamingCapabilityTests.java need to be updated to include the new parameter additionalVideoStreamingCapabilities.", "author": "santhanamk", "createdAt": "2020-08-18T06:22:05Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -49,6 +50,7 @@\n \tpublic static final String KEY_DIAGONAL_SCREEN_SIZE = \"diagonalScreenSize\";\n \tpublic static final String KEY_PIXEL_PER_INCH = \"pixelPerInch\";\n \tpublic static final String KEY_SCALE = \"scale\";\n+\tpublic static final String KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES = \"additionalVideoStreamingCapabilities\";", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3NjU2NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473376564", "bodyText": "This looks good,but the unit tests in VideoStreamingCapabilityTests.java need to be updated to include the new parameter additionalVideoStreamingCapabilities.\n\n@kostyaBoss I still see this issue.  In VideoStreamingCapabilityTests.java you need to update the unit tests to include the new parameter additionalVideoStreamingCapabilities.", "author": "santhanamk", "createdAt": "2020-08-19T22:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0MDE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3NjgxNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473376814", "bodyText": "Based on the mobile_API.xml, the new parameter on line 53 needs the /** @since 7.0 */ annotation.\n\n@kostyaBoss I still see this issue.  The parameter KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES should have the /** @since 7.0 */ annotation.", "author": "santhanamk", "createdAt": "2020-08-19T22:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0MDE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk5Nzg2Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474997866", "bodyText": "This looks good,but the unit tests in VideoStreamingCapabilityTests.java need to be updated to include the new parameter additionalVideoStreamingCapabilities.\n\n@kostyaBoss I still see this issue. In VideoStreamingCapabilityTests.java you need to update the unit tests to include the new parameter additionalVideoStreamingCapabilities.\n\n@kostyaBoss I still see this issue.  In VideoStreamingCapabilityTests.java you need to update the unit tests to include the new parameter additionalVideoStreamingCapabilities.", "author": "santhanamk", "createdAt": "2020-08-21T22:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0MDE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUxODA3Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r477518072", "bodyText": "This looks good,but the unit tests in VideoStreamingCapabilityTests.java need to be updated to include the new parameter additionalVideoStreamingCapabilities.\n\n@kostyaBoss I still see this issue. In VideoStreamingCapabilityTests.java you need to update the unit tests to include the new parameter additionalVideoStreamingCapabilities.\n\n@kostyaBoss I still see this issue. In VideoStreamingCapabilityTests.java you need to update the unit tests to include the new parameter additionalVideoStreamingCapabilities.\n\n@kostyaBoss I still see this issue.  Can you update the unit tests in VideoStreamingCapabilityTests.java to include the new parameter additionalVideoStreamingCapabilities?", "author": "santhanamk", "createdAt": "2020-08-26T18:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0MDE3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex 2bd87369a..a0e5a3760 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -43,114 +42,156 @@ import java.util.List;\n  */\n \n public class VideoStreamingCapability extends RPCStruct {\n-\tpublic static final String KEY_PREFERRED_RESOLUTION = \"preferredResolution\";\n-\tpublic static final String KEY_MAX_BITRATE = \"maxBitrate\";\n-\tpublic static final String KEY_SUPPORTED_FORMATS = \"supportedFormats\";\n-\tpublic static final String KEY_HAPTIC_SPATIAL_DATA_SUPPORTED = \"hapticSpatialDataSupported\";\n-\tpublic static final String KEY_DIAGONAL_SCREEN_SIZE = \"diagonalScreenSize\";\n-\tpublic static final String KEY_PIXEL_PER_INCH = \"pixelPerInch\";\n-\tpublic static final String KEY_SCALE = \"scale\";\n-\tpublic static final String KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES = \"additionalVideoStreamingCapabilities\";\n-\n-\tpublic VideoStreamingCapability(){}\n-\tpublic VideoStreamingCapability(Hashtable<String, Object> hash){super(hash);}\n-\n-\tpublic void setPreferredResolution(ImageResolution res){\n-\t\tsetValue(KEY_PREFERRED_RESOLUTION, res);\n-\t}\n-\n-\tpublic ImageResolution getPreferredResolution(){\n-\t\treturn (ImageResolution) getObject(ImageResolution.class, KEY_PREFERRED_RESOLUTION);\n-\t}\n-\n-\t/**\n-\t * Set the max bitrate supported by this module.\n-\t *\n-\t * <b>NOTE: </b> Unit is in kbps.\n-\t * @param maxBitrate in kbps\n-\t */\n-\tpublic void setMaxBitrate(Integer maxBitrate){\n-\t\tsetValue(KEY_MAX_BITRATE, maxBitrate);\n-\t}\n-\n-\t/**\n-\t * Retrieves the max bitrate supported by this module.\n-\t *\n-\t * <b>NOTE: </b> Unit is in kbps.\n-\t * @return max bitrate in kbps\n-\t */\n-\tpublic Integer getMaxBitrate(){\n-\t\treturn getInteger(KEY_MAX_BITRATE);\n-\t}\n-\n-\tpublic void setSupportedFormats(List<VideoStreamingFormat> formats){\n-\t\tsetValue(KEY_SUPPORTED_FORMATS, formats);\n-\t}\n-\n-\tpublic List<VideoStreamingFormat> getSupportedFormats(){\n-\t\treturn (List<VideoStreamingFormat>) getObject(VideoStreamingFormat.class, KEY_SUPPORTED_FORMATS);\n-\t}\n-\n-\tpublic Boolean getIsHapticSpatialDataSupported() {\n-\t\treturn getBoolean(KEY_HAPTIC_SPATIAL_DATA_SUPPORTED);\n-\t}\n-\n-\tpublic void setIsHapticSpatialDataSupported(Boolean hapticSpatialDataSupported) {\n-\t\tsetValue(KEY_HAPTIC_SPATIAL_DATA_SUPPORTED, hapticSpatialDataSupported);\n-\t}\n-\n-\t/**\n-\t * @return the diagonal screen size in inches.\n-\t */\n-\tpublic Double getDiagonalScreenSize() {\n-\t    Object object = getValue(KEY_DIAGONAL_SCREEN_SIZE);\n-\t\treturn SdlDataTypeConverter.objectToDouble(object);\n-\t}\n-\n-\t/**\n-\t * @param diagonalScreenSize the diagonal screen size in inches.\n-\t */\n-\tpublic void setDiagonalScreenSize(Double diagonalScreenSize) {\n-\t\tsetValue(KEY_DIAGONAL_SCREEN_SIZE, diagonalScreenSize);\n-\t}\n-\n-\t/**\n-\t * @return the diagonal resolution in pixels divided by the diagonal screen size in inches.\n-\t */\n-\tpublic Double getPixelPerInch() {\n-\t    Object object = getValue(KEY_PIXEL_PER_INCH);\n-\t    return SdlDataTypeConverter.objectToDouble(object);\n-\t}\n-\n-\t/**\n-\t * @param pixelPerInch the diagonal resolution in pixels divided by the diagonal screen size in inches.\n-\t */\n-\tpublic void setPixelPerInch(Double pixelPerInch) {\n-\t\tsetValue(KEY_PIXEL_PER_INCH, pixelPerInch);\n-\t}\n-\n-\t/**\n-\t * @return the scaling factor the app should use to change the size of the projecting view.\n-\t */\n-\tpublic Double getScale() {\n-\t    Object object = getValue(KEY_SCALE);\n-\t    return SdlDataTypeConverter.objectToDouble(object);\n-\t}\n-\n-\t/**\n-\t * @param scale the scaling factor the app should use to change the size of the projecting view.\n-\t */\n-\tpublic void setScale(Double scale) {\n-\t\tsetValue(KEY_SCALE, scale);\n-\t}\n-\n-\t// TODO replace with real data\n-\t@SuppressWarnings(\"unchecked\")\n-\tpublic List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n-\t\treturn (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n-\t}\n-\n-\tpublic void setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> capabilities) {\n-\t\tsetValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, capabilities);\n-\t}\n+    public static final String KEY_PREFERRED_RESOLUTION = \"preferredResolution\";\n+    public static final String KEY_MAX_BITRATE = \"maxBitrate\";\n+    public static final String KEY_SUPPORTED_FORMATS = \"supportedFormats\";\n+    public static final String KEY_HAPTIC_SPATIAL_DATA_SUPPORTED = \"hapticSpatialDataSupported\";\n+    public static final String KEY_DIAGONAL_SCREEN_SIZE = \"diagonalScreenSize\";\n+    public static final String KEY_PIXEL_PER_INCH = \"pixelPerInch\";\n+    public static final String KEY_SCALE = \"scale\";\n+    /**\n+     * @since SmartDeviceLink 7.0\n+     */\n+    public static final String KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES = \"additionalVideoStreamingCapabilities\";\n+\n+    public VideoStreamingCapability() {\n+    }\n+\n+    public VideoStreamingCapability(Hashtable<String, Object> hash) {\n+        super(hash);\n+    }\n+\n+    public VideoStreamingCapability setPreferredResolution(ImageResolution res) {\n+        setValue(KEY_PREFERRED_RESOLUTION, res);\n+        return this;\n+    }\n+\n+    public ImageResolution getPreferredResolution() {\n+        return (ImageResolution) getObject(ImageResolution.class, KEY_PREFERRED_RESOLUTION);\n+    }\n+\n+    /**\n+     * Set the max bitrate supported by this module.\n+     *\n+     * <b>NOTE: </b> Unit is in kbps.\n+     *\n+     * @param maxBitrate in kbps\n+     */\n+    public VideoStreamingCapability setMaxBitrate(Integer maxBitrate) {\n+        setValue(KEY_MAX_BITRATE, maxBitrate);\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieves the max bitrate supported by this module.\n+     *\n+     * <b>NOTE: </b> Unit is in kbps.\n+     *\n+     * @return max bitrate in kbps\n+     */\n+    public Integer getMaxBitrate() {\n+        return getInteger(KEY_MAX_BITRATE);\n+    }\n+\n+    public VideoStreamingCapability setSupportedFormats(List<VideoStreamingFormat> formats) {\n+        setValue(KEY_SUPPORTED_FORMATS, formats);\n+        return this;\n+    }\n+\n+    public List<VideoStreamingFormat> getSupportedFormats() {\n+        return (List<VideoStreamingFormat>) getObject(VideoStreamingFormat.class, KEY_SUPPORTED_FORMATS);\n+    }\n+\n+    /**\n+     * @deprecated use {@link #isHapticSpatialDataSupported()} instead.\n+     */\n+    @Deprecated\n+    public Boolean getIsHapticSpatialDataSupported() {\n+        return isHapticSpatialDataSupported();\n+    }\n+\n+    /**\n+     * @deprecated use {@link #setHapticSpatialDataSupported(Boolean hapticSpatialDataSupported)} instead.\n+     */\n+    @Deprecated\n+    public VideoStreamingCapability setIsHapticSpatialDataSupported(Boolean hapticSpatialDataSupported) {\n+        return setHapticSpatialDataSupported(hapticSpatialDataSupported);\n+    }\n+\n+    /**\n+     * Gets whether the dead unit supports HapticSpatialData\n+     *\n+     * @return True if the system can utilize the haptic spatial data from the source being streamed. If not included, it can be assumed the module doesn't support haptic spatial data.\n+     */\n+    public Boolean isHapticSpatialDataSupported() {\n+        return getBoolean(KEY_HAPTIC_SPATIAL_DATA_SUPPORTED);\n+    }\n+\n+    /**\n+     * Sets whether the dead unit supports HapticSpatialData\n+     *\n+     * @param hapticSpatialDataSupported True if the system can utilize the haptic spatial data from the source being streamed. If not included, it can be assumed the module doesn't support haptic spatial data.\n+     */\n+    public VideoStreamingCapability setHapticSpatialDataSupported(Boolean hapticSpatialDataSupported) {\n+        setValue(KEY_HAPTIC_SPATIAL_DATA_SUPPORTED, hapticSpatialDataSupported);\n+        return this;\n+    }\n+\n+    /**\n+     * @return the diagonal screen size in inches.\n+     */\n+    public Double getDiagonalScreenSize() {\n+        Object object = getValue(KEY_DIAGONAL_SCREEN_SIZE);\n+        return SdlDataTypeConverter.objectToDouble(object);\n+    }\n+\n+    /**\n+     * @param diagonalScreenSize the diagonal screen size in inches.\n+     */\n+    public VideoStreamingCapability setDiagonalScreenSize(Double diagonalScreenSize) {\n+        setValue(KEY_DIAGONAL_SCREEN_SIZE, diagonalScreenSize);\n+        return this;\n+    }\n+\n+    /**\n+     * @return the diagonal resolution in pixels divided by the diagonal screen size in inches.\n+     */\n+    public Double getPixelPerInch() {\n+        Object object = getValue(KEY_PIXEL_PER_INCH);\n+        return SdlDataTypeConverter.objectToDouble(object);\n+    }\n+\n+    /**\n+     * @param pixelPerInch the diagonal resolution in pixels divided by the diagonal screen size in inches.\n+     */\n+    public VideoStreamingCapability setPixelPerInch(Double pixelPerInch) {\n+        setValue(KEY_PIXEL_PER_INCH, pixelPerInch);\n+        return this;\n+    }\n+\n+    /**\n+     * @return the scaling factor the app should use to change the size of the projecting view.\n+     */\n+    public Double getScale() {\n+        Object object = getValue(KEY_SCALE);\n+        return SdlDataTypeConverter.objectToDouble(object);\n+    }\n+\n+    /**\n+     * @param scale the scaling factor the app should use to change the size of the projecting view.\n+     */\n+    public VideoStreamingCapability setScale(Double scale) {\n+        setValue(KEY_SCALE, scale);\n+        return this;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public List<VideoStreamingCapability> getAdditionalVideoStreamingCapabilities(){\n+        return (List<VideoStreamingCapability>) getObject(VideoStreamingCapability.class, KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES);\n+    }\n+\n+    public VideoStreamingCapability setAdditionalVideoStreamingCapabilities(List<VideoStreamingCapability> capabilities) {\n+        setValue(KEY_ADDITIONAL_VIDEO_STREAMING_CAPABILITIES, capabilities);\n+        return this;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0NTQ2OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471945469", "bodyText": "Does VideoStreamingParametersTest.java need to be updated to include tests for the new parameter List<VideoStreamingCapability> additionalCapabilities?", "author": "santhanamk", "createdAt": "2020-08-18T06:35:14Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -61,8 +64,11 @@\n \tprivate int frameRate;\n \tprivate int bitrate;\n \tprivate int interval;\n+\tprivate double preferredDiagonal;\n+\tprivate double scale = DEFAULT_SCALE;\n \tprivate ImageResolution resolution;\n \tprivate VideoStreamingFormat format;\n+\tprivate List<VideoStreamingCapability> additionalCapabilities = new ArrayList<>(1);", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3NzUyMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473377522", "bodyText": "Does VideoStreamingParametersTest.java need to be updated to include tests for the new parameter List<VideoStreamingCapability> additionalCapabilities?\n\n@kostyaBoss I still see this issue.  Does VideoStreamingParametersTest.java need to be updated to include tests for the new parameter List<VideoStreamingCapability> additionalCapabilities?", "author": "santhanamk", "createdAt": "2020-08-19T22:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0NTQ2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex cf4ac22b0..5ab5ca931 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -45,69 +45,71 @@ import java.util.ArrayList;\n import java.util.List;\n \n @SuppressWarnings(\"FieldCanBeLocal\")\n+@RestrictTo(RestrictTo.Scope.LIBRARY)\n public class VideoStreamingParameters {\n     private static final String TAG = \"VideoStreamingParameters\";\n-\tprivate final VideoStreamingProtocol DEFAULT_PROTOCOL = VideoStreamingProtocol.RAW;\n-\tprivate final VideoStreamingCodec DEFAULT_CODEC = VideoStreamingCodec.H264;\n-\tprivate final VideoStreamingFormat[] CURRENTLY_SUPPORTED_FORMATS = { new VideoStreamingFormat(VideoStreamingProtocol.RTP, VideoStreamingCodec.H264),\n-                                                                         new VideoStreamingFormat(VideoStreamingProtocol.RAW, VideoStreamingCodec.H264) };\n-\tprivate final int DEFAULT_WIDTH = 1024;\n-\tprivate final int DEFAULT_HEIGHT = 576;\n-\tprivate final int DEFAULT_DENSITY = 240;\n-\tprivate final int DEFAULT_FRAMERATE = 30;\n-\tprivate final int DEFAULT_BITRATE = 512000;\n-\tprivate final int DEFAULT_INTERVAL = 5;\n-\tprivate final static double DEFAULT_SCALE = 1.0;\n-\n-\n-\tprivate int displayDensity;\n-\tprivate int frameRate;\n-\tprivate int bitrate;\n-\tprivate int interval;\n-\tprivate double preferredDiagonal;\n-\tprivate double scale = DEFAULT_SCALE;\n-\tprivate ImageResolution resolution;\n-\tprivate VideoStreamingFormat format;\n-\tprivate List<VideoStreamingCapability> additionalCapabilities = new ArrayList<>(1);\n-\n-    public VideoStreamingParameters(){\n-\t    displayDensity = DEFAULT_DENSITY;\n-\t    frameRate = DEFAULT_FRAMERATE;\n-\t    bitrate = DEFAULT_BITRATE;\n-\t    interval = DEFAULT_INTERVAL;\n-\t    resolution = new ImageResolution();\n-\t    resolution.setResolutionWidth(DEFAULT_WIDTH);\n-\t    resolution.setResolutionHeight(DEFAULT_HEIGHT);\n-\t    format = new VideoStreamingFormat();\n-\t    format.setProtocol(DEFAULT_PROTOCOL);\n-\t    format.setCodec(DEFAULT_CODEC);\n+    private final VideoStreamingProtocol DEFAULT_PROTOCOL = VideoStreamingProtocol.RAW;\n+    private final VideoStreamingCodec DEFAULT_CODEC = VideoStreamingCodec.H264;\n+    private final VideoStreamingFormat[] currentlySupportedFormats = {new VideoStreamingFormat(VideoStreamingProtocol.RTP, VideoStreamingCodec.H264),\n+            new VideoStreamingFormat(VideoStreamingProtocol.RAW, VideoStreamingCodec.H264)};\n+    private final int DEFAULT_WIDTH = 1024;\n+    private final int DEFAULT_HEIGHT = 576;\n+    private final int DEFAULT_DENSITY = 240;\n+    private final int DEFAULT_FRAMERATE = 30;\n+    private final int DEFAULT_BITRATE = 512000;\n+    private final int DEFAULT_INTERVAL = 5;\n+    private final static double DEFAULT_SCALE = 1.0;\n+\n+\n+    private int displayDensity;\n+    private int frameRate;\n+    private int bitrate;\n+    private int interval;\n+    private double preferredDiagonal;\n+    private double scale = DEFAULT_SCALE;\n+    private ImageResolution resolution;\n+    private VideoStreamingFormat format;\n+    private List<VideoStreamingCapability> additionalCapabilities = new ArrayList<>(1);\n+\n+    public VideoStreamingParameters() {\n+        displayDensity = DEFAULT_DENSITY;\n+        frameRate = DEFAULT_FRAMERATE;\n+        bitrate = DEFAULT_BITRATE;\n+        interval = DEFAULT_INTERVAL;\n+        resolution = new ImageResolution();\n+        resolution.setResolutionWidth(DEFAULT_WIDTH);\n+        resolution.setResolutionHeight(DEFAULT_HEIGHT);\n+        format = new VideoStreamingFormat();\n+        format.setProtocol(DEFAULT_PROTOCOL);\n+        format.setCodec(DEFAULT_CODEC);\n     }\n \n     public VideoStreamingParameters(int displayDensity, int frameRate, int bitrate, int interval,\n-                                    ImageResolution resolution, VideoStreamingFormat format){\n-\t    this.displayDensity = displayDensity;\n-\t    this.frameRate = frameRate;\n-\t    this.bitrate = bitrate;\n-\t    this.interval = interval;\n-\t    this.resolution = resolution;\n-\t    this.format = format;\n+                                    ImageResolution resolution, VideoStreamingFormat format) {\n+        this.displayDensity = displayDensity;\n+        this.frameRate = frameRate;\n+        this.bitrate = bitrate;\n+        this.interval = interval;\n+        this.resolution = resolution;\n+        this.format = format;\n     }\n \n     /**\n      * Will only copy values that are not null or are greater than 0\n+     *\n      * @param params VideoStreamingParameters that should be copied into this new instants\n      */\n-    @SuppressWarnings(\"unused\")\n-    public VideoStreamingParameters(VideoStreamingParameters params){\n+    public VideoStreamingParameters(VideoStreamingParameters params) {\n         update(params);\n     }\n \n     /**\n      * Will only copy values that are not null or are greater than 0\n+     *\n      * @param params VideoStreamingParameters that should be copied into this new instants\n      */\n-    public void update(VideoStreamingParameters params){\n-        if(params!=null) {\n+    public void update(VideoStreamingParameters params) {\n+        if (params != null) {\n             if (params.displayDensity > 0) {\n                 this.displayDensity = params.displayDensity;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Nzc2Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471977762", "bodyText": "The variables on lines 25-27 are not being used, and can be removed.", "author": "santhanamk", "createdAt": "2020-08-18T07:39:15Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java", "diffHunk": "@@ -1,25 +1,142 @@\n package com.sdl.hellosdlandroid;\n \n import android.content.Intent;\n+import android.content.SharedPreferences;\n import android.os.Bundle;\n+import android.preference.PreferenceManager;\n import android.support.v7.app.AppCompatActivity;\n+import android.text.Editable;\n+import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.EditText;\n+import android.widget.Toast;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n \n public class MainActivity extends AppCompatActivity {\n \tprivate static final String TAG = \"MainActivity\";\n-\t\n+\n+\tpublic static final String IP = \"ip\";\n+\tpublic static final String PORT = \"port\";\n+\tpublic static final String COMMAND = \"command\";", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0NTI1NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472945254", "bodyText": "@santhanamk Ip and port are used to pass intent, thought, still this change is related more to demonstrate proposal implementation, rather than to a functional one. If it is required, I can separate this code, but, I believe, this should not go to the final release version and should be deleted. Though, it remains here right now in order to help everybody to acknowledge. Should I remove it now?", "author": "kboskin", "createdAt": "2020-08-19T11:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Nzc2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\nindex b624e984f..43ad79ac7 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n\n@@ -1,164 +1,43 @@\n package com.sdl.hellosdlandroid;\n \n import android.content.Intent;\n-import android.content.SharedPreferences;\n import android.os.Bundle;\n-import android.preference.PreferenceManager;\n-import android.support.v7.app.AppCompatActivity;\n-import android.text.Editable;\n-import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.EditText;\n-import android.widget.Toast;\n \n-import java.util.Timer;\n-import java.util.TimerTask;\n+import androidx.appcompat.app.AppCompatActivity;\n \n public class MainActivity extends AppCompatActivity {\n-\tprivate static final String TAG = \"MainActivity\";\n \n-\tpublic static final String IP = \"ip\";\n-\tpublic static final String PORT = \"port\";\n-\tpublic static final String COMMAND = \"command\";\n-\tpublic static final String COMMAND_START_PROXY = \"c_start_proxy\";\n-\tpublic static final String COMMAND_START_STREAM = \"c_start_stream\";\n-\n-\tpublic static final String PREDEFINED_WIDTH = \"pre_def_w\";\n-\tpublic static final String PREDEFINED_HEIGHT = \"pre_def_h\";\n-\tpublic static final String IP_ADDRESS = \"ip_address\";\n-\tSharedPreferences preferences;\n-\n-\t@Override\n-\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\tsuper.onCreate(savedInstanceState);\n-\t\tsetContentView(R.layout.activity_main);\n-\n-\t\tpreferences = PreferenceManager.getDefaultSharedPreferences(this);\n-\n-\n-\t\tButton startStreaming = findViewById(R.id.start_streaming);\n-\t\tButton startStreamingUI = findViewById(R.id.start_streaming_ui);\n-\t\tButton startProxy = findViewById(R.id.start_proxy);\n-\t\tButton stopApp = findViewById(R.id.exit_application);\n-\n-\t\tfinal EditText ip = findViewById(R.id.machine_ip);\n-\t\tfinal EditText port = findViewById(R.id.machine_port);\n-\n-\t\tfinal EditText preConfWidth = findViewById(R.id.pre_conf_width);\n-\t\tfinal EditText preConfHeight = findViewById(R.id.pre_conf_height);\n-\n-\t\tip.setText(preferences.getString(IP_ADDRESS, \"192.168.0.101\"));\n-\n-\t\tip.addTextChangedListener(new TextWatcher() {\n-\t\t\t@Override\n-\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void afterTextChanged(Editable s) {\n-\t\t\t\tif (s!=null) {\n-\t\t\t\t\tpreferences.edit().putString(IP_ADDRESS, s.toString()).commit();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartProxy.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\t//If we are connected to a module we want to start our SdlService\n-\t\t\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\t\tSdlReceiver.queryForConnectedService(MainActivity.this);\n-\t\t\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\t\tIntent proxyIntent = new Intent(MainActivity.this, SdlService.class);\n-\n-\t\t\t\t\tString ipString = ip.getText().toString();\n-\t\t\t\t\tString portString = port.getText().toString();\n-\t\t\t\t\tif (!ipString.isEmpty() && !portString.isEmpty()) {\n-\t\t\t\t\t\tproxyIntent.putExtra(IP, ip.getText().toString());\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tproxyIntent.putExtra(PORT, Integer.parseInt(port.getText().toString()));\n-\t\t\t\t\t\t} catch (NumberFormatException e){\n-\t\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Port should be number\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tstartService(proxyIntent);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Fill ip and port\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreaming.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreamingUI.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING_UI);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstopApp.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View v) {\n-\t\t\t\tstopService(new Intent(MainActivity.this, SdlService.class));\n-\n-\t\t\t\tnew Timer().schedule(new TimerTask() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\tandroid.os.Process.killProcess(android.os.Process.myPid());\n-\t\t\t\t\t}\n-\t\t\t\t}, 50);\n-\n-\t\t\t\tfinish();\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Override\n-\tpublic boolean onCreateOptionsMenu(Menu menu) {\n-\t\t// Inflate the menu; this adds items to the action bar if it is present.\n-\t\tgetMenuInflater().inflate(R.menu.main, menu);\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic boolean onOptionsItemSelected(MenuItem item) {\n-\t\t// Handle action bar item clicks here. The action bar will\n-\t\t// automatically handle clicks on the Home/Up button, so long\n-\t\t// as you specify a parent activity in AndroidManifest.xml.\n-\t\tint id = item.getItemId();\n-\t\tif (id == R.id.action_settings) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn super.onOptionsItemSelected(item);\n-\t}\n-\n-\tpublic static enum STREAM_ENUM{\n-\t\tSTART_STREAMING, START_STREAMING_UI\n-\t}\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setContentView(R.layout.activity_main);\n+        //If we are connected to a module we want to start our SdlService\n+        if (BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+            SdlReceiver.queryForConnectedService(this);\n+        } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+            Intent proxyIntent = new Intent(this, SdlService.class);\n+            startService(proxyIntent);\n+        }\n+    }\n+\n+    @Override\n+    public boolean onCreateOptionsMenu(Menu menu) {\n+        // Inflate the menu; this adds items to the action bar if it is present.\n+        getMenuInflater().inflate(R.menu.main, menu);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        // Handle action bar item clicks here. The action bar will\n+        // automatically handle clicks on the Home/Up button, so long\n+        // as you specify a parent activity in AndroidManifest.xml.\n+        int id = item.getItemId();\n+        if (id == R.id.action_settings) {\n+            return true;\n+        }\n+        return super.onOptionsItemSelected(item);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3OTEwNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471979104", "bodyText": "To be consistent in the naming of the UI variables, I would do the following:\n\nline 45: rename stopApp to exitApplication\nline 47: rename ip to machineIp\nline 48: rename port to machinePort", "author": "santhanamk", "createdAt": "2020-08-18T07:41:32Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java", "diffHunk": "@@ -1,25 +1,142 @@\n package com.sdl.hellosdlandroid;\n \n import android.content.Intent;\n+import android.content.SharedPreferences;\n import android.os.Bundle;\n+import android.preference.PreferenceManager;\n import android.support.v7.app.AppCompatActivity;\n+import android.text.Editable;\n+import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.EditText;\n+import android.widget.Toast;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n \n public class MainActivity extends AppCompatActivity {\n \tprivate static final String TAG = \"MainActivity\";\n-\t\n+\n+\tpublic static final String IP = \"ip\";\n+\tpublic static final String PORT = \"port\";\n+\tpublic static final String COMMAND = \"command\";\n+\tpublic static final String COMMAND_START_PROXY = \"c_start_proxy\";\n+\tpublic static final String COMMAND_START_STREAM = \"c_start_stream\";\n+\n+\tpublic static final String PREDEFINED_WIDTH = \"pre_def_w\";\n+\tpublic static final String PREDEFINED_HEIGHT = \"pre_def_h\";\n+\tpublic static final String IP_ADDRESS = \"ip_address\";\n+\tSharedPreferences preferences;\n+\n \t@Override\n \tprotected void onCreate(Bundle savedInstanceState) {\n \t\tsuper.onCreate(savedInstanceState);\n \t\tsetContentView(R.layout.activity_main);\n-\t\t//If we are connected to a module we want to start our SdlService\n-\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\tSdlReceiver.queryForConnectedService(this);\n-\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\tIntent proxyIntent = new Intent(this, SdlService.class);\n-\t\t\tstartService(proxyIntent);\n-\t\t}\n+\n+\t\tpreferences = PreferenceManager.getDefaultSharedPreferences(this);\n+\n+\n+\t\tButton startStreaming = findViewById(R.id.start_streaming);\n+\t\tButton startStreamingUI = findViewById(R.id.start_streaming_ui);\n+\t\tButton startProxy = findViewById(R.id.start_proxy);\n+\t\tButton stopApp = findViewById(R.id.exit_application);", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\nindex b624e984f..43ad79ac7 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n\n@@ -1,164 +1,43 @@\n package com.sdl.hellosdlandroid;\n \n import android.content.Intent;\n-import android.content.SharedPreferences;\n import android.os.Bundle;\n-import android.preference.PreferenceManager;\n-import android.support.v7.app.AppCompatActivity;\n-import android.text.Editable;\n-import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.EditText;\n-import android.widget.Toast;\n \n-import java.util.Timer;\n-import java.util.TimerTask;\n+import androidx.appcompat.app.AppCompatActivity;\n \n public class MainActivity extends AppCompatActivity {\n-\tprivate static final String TAG = \"MainActivity\";\n \n-\tpublic static final String IP = \"ip\";\n-\tpublic static final String PORT = \"port\";\n-\tpublic static final String COMMAND = \"command\";\n-\tpublic static final String COMMAND_START_PROXY = \"c_start_proxy\";\n-\tpublic static final String COMMAND_START_STREAM = \"c_start_stream\";\n-\n-\tpublic static final String PREDEFINED_WIDTH = \"pre_def_w\";\n-\tpublic static final String PREDEFINED_HEIGHT = \"pre_def_h\";\n-\tpublic static final String IP_ADDRESS = \"ip_address\";\n-\tSharedPreferences preferences;\n-\n-\t@Override\n-\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\tsuper.onCreate(savedInstanceState);\n-\t\tsetContentView(R.layout.activity_main);\n-\n-\t\tpreferences = PreferenceManager.getDefaultSharedPreferences(this);\n-\n-\n-\t\tButton startStreaming = findViewById(R.id.start_streaming);\n-\t\tButton startStreamingUI = findViewById(R.id.start_streaming_ui);\n-\t\tButton startProxy = findViewById(R.id.start_proxy);\n-\t\tButton stopApp = findViewById(R.id.exit_application);\n-\n-\t\tfinal EditText ip = findViewById(R.id.machine_ip);\n-\t\tfinal EditText port = findViewById(R.id.machine_port);\n-\n-\t\tfinal EditText preConfWidth = findViewById(R.id.pre_conf_width);\n-\t\tfinal EditText preConfHeight = findViewById(R.id.pre_conf_height);\n-\n-\t\tip.setText(preferences.getString(IP_ADDRESS, \"192.168.0.101\"));\n-\n-\t\tip.addTextChangedListener(new TextWatcher() {\n-\t\t\t@Override\n-\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void afterTextChanged(Editable s) {\n-\t\t\t\tif (s!=null) {\n-\t\t\t\t\tpreferences.edit().putString(IP_ADDRESS, s.toString()).commit();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartProxy.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\t//If we are connected to a module we want to start our SdlService\n-\t\t\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\t\tSdlReceiver.queryForConnectedService(MainActivity.this);\n-\t\t\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\t\tIntent proxyIntent = new Intent(MainActivity.this, SdlService.class);\n-\n-\t\t\t\t\tString ipString = ip.getText().toString();\n-\t\t\t\t\tString portString = port.getText().toString();\n-\t\t\t\t\tif (!ipString.isEmpty() && !portString.isEmpty()) {\n-\t\t\t\t\t\tproxyIntent.putExtra(IP, ip.getText().toString());\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tproxyIntent.putExtra(PORT, Integer.parseInt(port.getText().toString()));\n-\t\t\t\t\t\t} catch (NumberFormatException e){\n-\t\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Port should be number\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tstartService(proxyIntent);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Fill ip and port\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreaming.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreamingUI.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING_UI);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstopApp.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View v) {\n-\t\t\t\tstopService(new Intent(MainActivity.this, SdlService.class));\n-\n-\t\t\t\tnew Timer().schedule(new TimerTask() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\tandroid.os.Process.killProcess(android.os.Process.myPid());\n-\t\t\t\t\t}\n-\t\t\t\t}, 50);\n-\n-\t\t\t\tfinish();\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Override\n-\tpublic boolean onCreateOptionsMenu(Menu menu) {\n-\t\t// Inflate the menu; this adds items to the action bar if it is present.\n-\t\tgetMenuInflater().inflate(R.menu.main, menu);\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic boolean onOptionsItemSelected(MenuItem item) {\n-\t\t// Handle action bar item clicks here. The action bar will\n-\t\t// automatically handle clicks on the Home/Up button, so long\n-\t\t// as you specify a parent activity in AndroidManifest.xml.\n-\t\tint id = item.getItemId();\n-\t\tif (id == R.id.action_settings) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn super.onOptionsItemSelected(item);\n-\t}\n-\n-\tpublic static enum STREAM_ENUM{\n-\t\tSTART_STREAMING, START_STREAMING_UI\n-\t}\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setContentView(R.layout.activity_main);\n+        //If we are connected to a module we want to start our SdlService\n+        if (BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+            SdlReceiver.queryForConnectedService(this);\n+        } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+            Intent proxyIntent = new Intent(this, SdlService.class);\n+            startService(proxyIntent);\n+        }\n+    }\n+\n+    @Override\n+    public boolean onCreateOptionsMenu(Menu menu) {\n+        // Inflate the menu; this adds items to the action bar if it is present.\n+        getMenuInflater().inflate(R.menu.main, menu);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        // Handle action bar item clicks here. The action bar will\n+        // automatically handle clicks on the Home/Up button, so long\n+        // as you specify a parent activity in AndroidManifest.xml.\n+        int id = item.getItemId();\n+        if (id == R.id.action_settings) {\n+            return true;\n+        }\n+        return super.onOptionsItemSelected(item);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3OTU1NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471979555", "bodyText": "On line 92, you could change the Toast message to \"IP and Port are empty.\"", "author": "santhanamk", "createdAt": "2020-08-18T07:42:18Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java", "diffHunk": "@@ -1,25 +1,142 @@\n package com.sdl.hellosdlandroid;\n \n import android.content.Intent;\n+import android.content.SharedPreferences;\n import android.os.Bundle;\n+import android.preference.PreferenceManager;\n import android.support.v7.app.AppCompatActivity;\n+import android.text.Editable;\n+import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.EditText;\n+import android.widget.Toast;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n \n public class MainActivity extends AppCompatActivity {\n \tprivate static final String TAG = \"MainActivity\";\n-\t\n+\n+\tpublic static final String IP = \"ip\";\n+\tpublic static final String PORT = \"port\";\n+\tpublic static final String COMMAND = \"command\";\n+\tpublic static final String COMMAND_START_PROXY = \"c_start_proxy\";\n+\tpublic static final String COMMAND_START_STREAM = \"c_start_stream\";\n+\n+\tpublic static final String PREDEFINED_WIDTH = \"pre_def_w\";\n+\tpublic static final String PREDEFINED_HEIGHT = \"pre_def_h\";\n+\tpublic static final String IP_ADDRESS = \"ip_address\";\n+\tSharedPreferences preferences;\n+\n \t@Override\n \tprotected void onCreate(Bundle savedInstanceState) {\n \t\tsuper.onCreate(savedInstanceState);\n \t\tsetContentView(R.layout.activity_main);\n-\t\t//If we are connected to a module we want to start our SdlService\n-\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\tSdlReceiver.queryForConnectedService(this);\n-\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\tIntent proxyIntent = new Intent(this, SdlService.class);\n-\t\t\tstartService(proxyIntent);\n-\t\t}\n+\n+\t\tpreferences = PreferenceManager.getDefaultSharedPreferences(this);\n+\n+\n+\t\tButton startStreaming = findViewById(R.id.start_streaming);\n+\t\tButton startStreamingUI = findViewById(R.id.start_streaming_ui);\n+\t\tButton startProxy = findViewById(R.id.start_proxy);\n+\t\tButton stopApp = findViewById(R.id.exit_application);\n+\n+\t\tfinal EditText ip = findViewById(R.id.machine_ip);\n+\t\tfinal EditText port = findViewById(R.id.machine_port);\n+\n+\t\tfinal EditText preConfWidth = findViewById(R.id.pre_conf_width);\n+\t\tfinal EditText preConfHeight = findViewById(R.id.pre_conf_height);\n+\n+\t\tip.setText(preferences.getString(IP_ADDRESS, \"192.168.0.101\"));\n+\n+\t\tip.addTextChangedListener(new TextWatcher() {\n+\t\t\t@Override\n+\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) { }\n+\n+\t\t\t@Override\n+\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) { }\n+\n+\t\t\t@Override\n+\t\t\tpublic void afterTextChanged(Editable s) {\n+\t\t\t\tif (s!=null) {\n+\t\t\t\t\tpreferences.edit().putString(IP_ADDRESS, s.toString()).commit();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\n+\t\tstartProxy.setOnClickListener(new View.OnClickListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onClick(View view) {\n+\t\t\t\t//If we are connected to a module we want to start our SdlService\n+\t\t\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+\t\t\t\t\tSdlReceiver.queryForConnectedService(MainActivity.this);\n+\t\t\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+\t\t\t\t\tIntent proxyIntent = new Intent(MainActivity.this, SdlService.class);\n+\n+\t\t\t\t\tString ipString = ip.getText().toString();\n+\t\t\t\t\tString portString = port.getText().toString();\n+\t\t\t\t\tif (!ipString.isEmpty() && !portString.isEmpty()) {\n+\t\t\t\t\t\tproxyIntent.putExtra(IP, ip.getText().toString());\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tproxyIntent.putExtra(PORT, Integer.parseInt(port.getText().toString()));\n+\t\t\t\t\t\t} catch (NumberFormatException e){\n+\t\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Port should be number\", Toast.LENGTH_SHORT).show();\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tstartService(proxyIntent);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Fill ip and port\", Toast.LENGTH_SHORT).show();", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\nindex b624e984f..43ad79ac7 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n\n@@ -1,164 +1,43 @@\n package com.sdl.hellosdlandroid;\n \n import android.content.Intent;\n-import android.content.SharedPreferences;\n import android.os.Bundle;\n-import android.preference.PreferenceManager;\n-import android.support.v7.app.AppCompatActivity;\n-import android.text.Editable;\n-import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.EditText;\n-import android.widget.Toast;\n \n-import java.util.Timer;\n-import java.util.TimerTask;\n+import androidx.appcompat.app.AppCompatActivity;\n \n public class MainActivity extends AppCompatActivity {\n-\tprivate static final String TAG = \"MainActivity\";\n \n-\tpublic static final String IP = \"ip\";\n-\tpublic static final String PORT = \"port\";\n-\tpublic static final String COMMAND = \"command\";\n-\tpublic static final String COMMAND_START_PROXY = \"c_start_proxy\";\n-\tpublic static final String COMMAND_START_STREAM = \"c_start_stream\";\n-\n-\tpublic static final String PREDEFINED_WIDTH = \"pre_def_w\";\n-\tpublic static final String PREDEFINED_HEIGHT = \"pre_def_h\";\n-\tpublic static final String IP_ADDRESS = \"ip_address\";\n-\tSharedPreferences preferences;\n-\n-\t@Override\n-\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\tsuper.onCreate(savedInstanceState);\n-\t\tsetContentView(R.layout.activity_main);\n-\n-\t\tpreferences = PreferenceManager.getDefaultSharedPreferences(this);\n-\n-\n-\t\tButton startStreaming = findViewById(R.id.start_streaming);\n-\t\tButton startStreamingUI = findViewById(R.id.start_streaming_ui);\n-\t\tButton startProxy = findViewById(R.id.start_proxy);\n-\t\tButton stopApp = findViewById(R.id.exit_application);\n-\n-\t\tfinal EditText ip = findViewById(R.id.machine_ip);\n-\t\tfinal EditText port = findViewById(R.id.machine_port);\n-\n-\t\tfinal EditText preConfWidth = findViewById(R.id.pre_conf_width);\n-\t\tfinal EditText preConfHeight = findViewById(R.id.pre_conf_height);\n-\n-\t\tip.setText(preferences.getString(IP_ADDRESS, \"192.168.0.101\"));\n-\n-\t\tip.addTextChangedListener(new TextWatcher() {\n-\t\t\t@Override\n-\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void afterTextChanged(Editable s) {\n-\t\t\t\tif (s!=null) {\n-\t\t\t\t\tpreferences.edit().putString(IP_ADDRESS, s.toString()).commit();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartProxy.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\t//If we are connected to a module we want to start our SdlService\n-\t\t\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\t\tSdlReceiver.queryForConnectedService(MainActivity.this);\n-\t\t\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\t\tIntent proxyIntent = new Intent(MainActivity.this, SdlService.class);\n-\n-\t\t\t\t\tString ipString = ip.getText().toString();\n-\t\t\t\t\tString portString = port.getText().toString();\n-\t\t\t\t\tif (!ipString.isEmpty() && !portString.isEmpty()) {\n-\t\t\t\t\t\tproxyIntent.putExtra(IP, ip.getText().toString());\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tproxyIntent.putExtra(PORT, Integer.parseInt(port.getText().toString()));\n-\t\t\t\t\t\t} catch (NumberFormatException e){\n-\t\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Port should be number\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tstartService(proxyIntent);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Fill ip and port\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreaming.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreamingUI.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING_UI);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstopApp.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View v) {\n-\t\t\t\tstopService(new Intent(MainActivity.this, SdlService.class));\n-\n-\t\t\t\tnew Timer().schedule(new TimerTask() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\tandroid.os.Process.killProcess(android.os.Process.myPid());\n-\t\t\t\t\t}\n-\t\t\t\t}, 50);\n-\n-\t\t\t\tfinish();\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Override\n-\tpublic boolean onCreateOptionsMenu(Menu menu) {\n-\t\t// Inflate the menu; this adds items to the action bar if it is present.\n-\t\tgetMenuInflater().inflate(R.menu.main, menu);\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic boolean onOptionsItemSelected(MenuItem item) {\n-\t\t// Handle action bar item clicks here. The action bar will\n-\t\t// automatically handle clicks on the Home/Up button, so long\n-\t\t// as you specify a parent activity in AndroidManifest.xml.\n-\t\tint id = item.getItemId();\n-\t\tif (id == R.id.action_settings) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn super.onOptionsItemSelected(item);\n-\t}\n-\n-\tpublic static enum STREAM_ENUM{\n-\t\tSTART_STREAMING, START_STREAMING_UI\n-\t}\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setContentView(R.layout.activity_main);\n+        //If we are connected to a module we want to start our SdlService\n+        if (BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+            SdlReceiver.queryForConnectedService(this);\n+        } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+            Intent proxyIntent = new Intent(this, SdlService.class);\n+            startService(proxyIntent);\n+        }\n+    }\n+\n+    @Override\n+    public boolean onCreateOptionsMenu(Menu menu) {\n+        // Inflate the menu; this adds items to the action bar if it is present.\n+        getMenuInflater().inflate(R.menu.main, menu);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        // Handle action bar item clicks here. The action bar will\n+        // automatically handle clicks on the Home/Up button, so long\n+        // as you specify a parent activity in AndroidManifest.xml.\n+        int id = item.getItemId();\n+        if (id == R.id.action_settings) {\n+            return true;\n+        }\n+        return super.onOptionsItemSelected(item);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3OTk3Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471979977", "bodyText": "The toast messages on lines 106 and 120 are the same (\"Configure display width and height\").  Are they supposed to be the same?", "author": "santhanamk", "createdAt": "2020-08-18T07:43:03Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java", "diffHunk": "@@ -1,25 +1,142 @@\n package com.sdl.hellosdlandroid;\n \n import android.content.Intent;\n+import android.content.SharedPreferences;\n import android.os.Bundle;\n+import android.preference.PreferenceManager;\n import android.support.v7.app.AppCompatActivity;\n+import android.text.Editable;\n+import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.EditText;\n+import android.widget.Toast;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n \n public class MainActivity extends AppCompatActivity {\n \tprivate static final String TAG = \"MainActivity\";\n-\t\n+\n+\tpublic static final String IP = \"ip\";\n+\tpublic static final String PORT = \"port\";\n+\tpublic static final String COMMAND = \"command\";\n+\tpublic static final String COMMAND_START_PROXY = \"c_start_proxy\";\n+\tpublic static final String COMMAND_START_STREAM = \"c_start_stream\";\n+\n+\tpublic static final String PREDEFINED_WIDTH = \"pre_def_w\";\n+\tpublic static final String PREDEFINED_HEIGHT = \"pre_def_h\";\n+\tpublic static final String IP_ADDRESS = \"ip_address\";\n+\tSharedPreferences preferences;\n+\n \t@Override\n \tprotected void onCreate(Bundle savedInstanceState) {\n \t\tsuper.onCreate(savedInstanceState);\n \t\tsetContentView(R.layout.activity_main);\n-\t\t//If we are connected to a module we want to start our SdlService\n-\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\tSdlReceiver.queryForConnectedService(this);\n-\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\tIntent proxyIntent = new Intent(this, SdlService.class);\n-\t\t\tstartService(proxyIntent);\n-\t\t}\n+\n+\t\tpreferences = PreferenceManager.getDefaultSharedPreferences(this);\n+\n+\n+\t\tButton startStreaming = findViewById(R.id.start_streaming);\n+\t\tButton startStreamingUI = findViewById(R.id.start_streaming_ui);\n+\t\tButton startProxy = findViewById(R.id.start_proxy);\n+\t\tButton stopApp = findViewById(R.id.exit_application);\n+\n+\t\tfinal EditText ip = findViewById(R.id.machine_ip);\n+\t\tfinal EditText port = findViewById(R.id.machine_port);\n+\n+\t\tfinal EditText preConfWidth = findViewById(R.id.pre_conf_width);\n+\t\tfinal EditText preConfHeight = findViewById(R.id.pre_conf_height);\n+\n+\t\tip.setText(preferences.getString(IP_ADDRESS, \"192.168.0.101\"));\n+\n+\t\tip.addTextChangedListener(new TextWatcher() {\n+\t\t\t@Override\n+\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) { }\n+\n+\t\t\t@Override\n+\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) { }\n+\n+\t\t\t@Override\n+\t\t\tpublic void afterTextChanged(Editable s) {\n+\t\t\t\tif (s!=null) {\n+\t\t\t\t\tpreferences.edit().putString(IP_ADDRESS, s.toString()).commit();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\n+\t\tstartProxy.setOnClickListener(new View.OnClickListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onClick(View view) {\n+\t\t\t\t//If we are connected to a module we want to start our SdlService\n+\t\t\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+\t\t\t\t\tSdlReceiver.queryForConnectedService(MainActivity.this);\n+\t\t\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+\t\t\t\t\tIntent proxyIntent = new Intent(MainActivity.this, SdlService.class);\n+\n+\t\t\t\t\tString ipString = ip.getText().toString();\n+\t\t\t\t\tString portString = port.getText().toString();\n+\t\t\t\t\tif (!ipString.isEmpty() && !portString.isEmpty()) {\n+\t\t\t\t\t\tproxyIntent.putExtra(IP, ip.getText().toString());\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tproxyIntent.putExtra(PORT, Integer.parseInt(port.getText().toString()));\n+\t\t\t\t\t\t} catch (NumberFormatException e){\n+\t\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Port should be number\", Toast.LENGTH_SHORT).show();\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tstartService(proxyIntent);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Fill ip and port\", Toast.LENGTH_SHORT).show();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\n+\t\tstartStreaming.setOnClickListener(new View.OnClickListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onClick(View view) {\n+\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n+\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n+\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n+\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING);\n+\t\t\t\t} else {\n+\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\n+\t\tstartStreamingUI.setOnClickListener(new View.OnClickListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onClick(View view) {\n+\n+\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n+\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n+\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n+\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING_UI);\n+\t\t\t\t} else {\n+\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0NjQyNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472946424", "bodyText": "@santhanamk, not really, it's more like general validation. This is not related to the proposal, but this part was important for testing, should I remove this?", "author": "kboskin", "createdAt": "2020-08-19T11:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3OTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE1OTIzMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473159231", "bodyText": "@kostyaBoss If you think it is needed for testing, then you can go ahead and keep the Toasts.", "author": "santhanamk", "createdAt": "2020-08-19T16:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3OTk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\nindex b624e984f..43ad79ac7 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n\n@@ -1,164 +1,43 @@\n package com.sdl.hellosdlandroid;\n \n import android.content.Intent;\n-import android.content.SharedPreferences;\n import android.os.Bundle;\n-import android.preference.PreferenceManager;\n-import android.support.v7.app.AppCompatActivity;\n-import android.text.Editable;\n-import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.EditText;\n-import android.widget.Toast;\n \n-import java.util.Timer;\n-import java.util.TimerTask;\n+import androidx.appcompat.app.AppCompatActivity;\n \n public class MainActivity extends AppCompatActivity {\n-\tprivate static final String TAG = \"MainActivity\";\n \n-\tpublic static final String IP = \"ip\";\n-\tpublic static final String PORT = \"port\";\n-\tpublic static final String COMMAND = \"command\";\n-\tpublic static final String COMMAND_START_PROXY = \"c_start_proxy\";\n-\tpublic static final String COMMAND_START_STREAM = \"c_start_stream\";\n-\n-\tpublic static final String PREDEFINED_WIDTH = \"pre_def_w\";\n-\tpublic static final String PREDEFINED_HEIGHT = \"pre_def_h\";\n-\tpublic static final String IP_ADDRESS = \"ip_address\";\n-\tSharedPreferences preferences;\n-\n-\t@Override\n-\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\tsuper.onCreate(savedInstanceState);\n-\t\tsetContentView(R.layout.activity_main);\n-\n-\t\tpreferences = PreferenceManager.getDefaultSharedPreferences(this);\n-\n-\n-\t\tButton startStreaming = findViewById(R.id.start_streaming);\n-\t\tButton startStreamingUI = findViewById(R.id.start_streaming_ui);\n-\t\tButton startProxy = findViewById(R.id.start_proxy);\n-\t\tButton stopApp = findViewById(R.id.exit_application);\n-\n-\t\tfinal EditText ip = findViewById(R.id.machine_ip);\n-\t\tfinal EditText port = findViewById(R.id.machine_port);\n-\n-\t\tfinal EditText preConfWidth = findViewById(R.id.pre_conf_width);\n-\t\tfinal EditText preConfHeight = findViewById(R.id.pre_conf_height);\n-\n-\t\tip.setText(preferences.getString(IP_ADDRESS, \"192.168.0.101\"));\n-\n-\t\tip.addTextChangedListener(new TextWatcher() {\n-\t\t\t@Override\n-\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void afterTextChanged(Editable s) {\n-\t\t\t\tif (s!=null) {\n-\t\t\t\t\tpreferences.edit().putString(IP_ADDRESS, s.toString()).commit();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartProxy.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\t//If we are connected to a module we want to start our SdlService\n-\t\t\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\t\tSdlReceiver.queryForConnectedService(MainActivity.this);\n-\t\t\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\t\tIntent proxyIntent = new Intent(MainActivity.this, SdlService.class);\n-\n-\t\t\t\t\tString ipString = ip.getText().toString();\n-\t\t\t\t\tString portString = port.getText().toString();\n-\t\t\t\t\tif (!ipString.isEmpty() && !portString.isEmpty()) {\n-\t\t\t\t\t\tproxyIntent.putExtra(IP, ip.getText().toString());\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tproxyIntent.putExtra(PORT, Integer.parseInt(port.getText().toString()));\n-\t\t\t\t\t\t} catch (NumberFormatException e){\n-\t\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Port should be number\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tstartService(proxyIntent);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Fill ip and port\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreaming.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreamingUI.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING_UI);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstopApp.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View v) {\n-\t\t\t\tstopService(new Intent(MainActivity.this, SdlService.class));\n-\n-\t\t\t\tnew Timer().schedule(new TimerTask() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\tandroid.os.Process.killProcess(android.os.Process.myPid());\n-\t\t\t\t\t}\n-\t\t\t\t}, 50);\n-\n-\t\t\t\tfinish();\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Override\n-\tpublic boolean onCreateOptionsMenu(Menu menu) {\n-\t\t// Inflate the menu; this adds items to the action bar if it is present.\n-\t\tgetMenuInflater().inflate(R.menu.main, menu);\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic boolean onOptionsItemSelected(MenuItem item) {\n-\t\t// Handle action bar item clicks here. The action bar will\n-\t\t// automatically handle clicks on the Home/Up button, so long\n-\t\t// as you specify a parent activity in AndroidManifest.xml.\n-\t\tint id = item.getItemId();\n-\t\tif (id == R.id.action_settings) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn super.onOptionsItemSelected(item);\n-\t}\n-\n-\tpublic static enum STREAM_ENUM{\n-\t\tSTART_STREAMING, START_STREAMING_UI\n-\t}\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setContentView(R.layout.activity_main);\n+        //If we are connected to a module we want to start our SdlService\n+        if (BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+            SdlReceiver.queryForConnectedService(this);\n+        } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+            Intent proxyIntent = new Intent(this, SdlService.class);\n+            startService(proxyIntent);\n+        }\n+    }\n+\n+    @Override\n+    public boolean onCreateOptionsMenu(Menu menu) {\n+        // Inflate the menu; this adds items to the action bar if it is present.\n+        getMenuInflater().inflate(R.menu.main, menu);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        // Handle action bar item clicks here. The action bar will\n+        // automatically handle clicks on the Home/Up button, so long\n+        // as you specify a parent activity in AndroidManifest.xml.\n+        int id = item.getItemId();\n+        if (id == R.id.action_settings) {\n+            return true;\n+        }\n+        return super.onOptionsItemSelected(item);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4OTU2Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471989562", "bodyText": "This looks good.  You can remove the unused imports on lines 42-43.", "author": "santhanamk", "createdAt": "2020-08-18T07:59:14Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/streaming/video/SdlRemoteDisplay.java", "diffHunk": "@@ -39,9 +39,12 @@\n import android.os.Bundle;\n import android.os.Handler;\n import android.os.Looper;\n+import android.support.annotation.NonNull;", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/streaming/video/SdlRemoteDisplay.java b/android/sdl_android/src/main/java/com/smartdevicelink/streaming/video/SdlRemoteDisplay.java\nindex e0cbd26ce..66888cbbe 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/streaming/video/SdlRemoteDisplay.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/streaming/video/SdlRemoteDisplay.java\n\n@@ -39,8 +39,6 @@ import android.os.Build;\n import android.os.Bundle;\n import android.os.Handler;\n import android.os.Looper;\n-import android.support.annotation.NonNull;\n-import android.util.Log;\n import android.view.Display;\n import android.view.MotionEvent;\n import android.view.View;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MjM1Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471992352", "bodyText": "Can you add code to unit test the newly added resizeView(...) function in SdlRemoteDisplay.java?", "author": "santhanamk", "createdAt": "2020-08-18T08:04:07Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/streaming/video/SdlRemoteDisplayTest.java", "diffHunk": "@@ -37,7 +37,7 @@ public void testCreator(){\n         assertNotNull(encoder);\n ", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MDgwNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473370805", "bodyText": "Can you add code to unit test the newly added resizeView(...) function in SdlRemoteDisplay.java?\n\n@kostyaBoss .  Are you able to add code to unit test the newly added resizeView(...) function?", "author": "santhanamk", "createdAt": "2020-08-19T22:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MjM1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/streaming/video/SdlRemoteDisplayTest.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/streaming/video/SdlRemoteDisplayTest.java\nindex 106cc0d05..3b1e6aa67 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/streaming/video/SdlRemoteDisplayTest.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/streaming/video/SdlRemoteDisplayTest.java\n\n@@ -27,17 +28,17 @@ public class SdlRemoteDisplayTest extends TestCase {\n     @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n-        if(Looper.myLooper() == null){\n+        if (Looper.myLooper() == null) {\n             Looper.prepare();\n         }\n     }\n \n-    public void testCreator(){\n+    public void testCreator() {\n         VirtualDisplayEncoder encoder = createVDE();\n         assertNotNull(encoder);\n \n \n-        SdlRemoteDisplay.Creator creator = new SdlRemoteDisplay.Creator(InstrumentationRegistry.getContext(), encoder.getDisplay(), null, MockRemoteDisplay.class, rdCallback);\n+        SdlRemoteDisplay.Creator creator = new SdlRemoteDisplay.Creator(InstrumentationRegistry.getInstrumentation().getContext(), encoder.getDisplay(), null, MockRemoteDisplay.class, rdCallback);\n         assertNotNull(creator);\n         FutureTask<Boolean> fTask = new FutureTask<Boolean>(creator);\n         Thread showPresentation = new Thread(fTask);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTc3NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471999774", "bodyText": "You can remove the unused imports on lines 35 and 46.", "author": "santhanamk", "createdAt": "2020-08-18T08:16:52Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -32,14 +32,18 @@\n \n package com.smartdevicelink.encoder;\n \n+import android.annotation.SuppressLint;", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 30fbbff5c..664e1a605 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -32,25 +32,21 @@\n \n package com.smartdevicelink.encoder;\n \n-import android.annotation.SuppressLint;\n import android.annotation.TargetApi;\n import android.content.Context;\n-import android.content.SharedPreferences;\n import android.hardware.display.DisplayManager;\n import android.hardware.display.VirtualDisplay;\n import android.media.MediaCodec;\n import android.media.MediaCodecInfo;\n import android.media.MediaFormat;\n import android.os.Build;\n-import android.preference.PreferenceManager;\n-import android.util.Log;\n import android.view.Display;\n import android.view.Surface;\n \n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n import com.smartdevicelink.proxy.rpc.ImageResolution;\n import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n import com.smartdevicelink.proxy.rpc.enums.VideoStreamingCodec;\n+import com.smartdevicelink.streaming.video.IVideoStreamListener;\n import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n import com.smartdevicelink.util.DebugTool;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTk3Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r471999973", "bodyText": "You can rename this to preferences", "author": "santhanamk", "createdAt": "2020-08-18T08:17:15Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -98,6 +105,11 @@ public void init(Context context, IVideoStreamListener outputListener, VideoStre\n \n         mOutputListener = outputListener;\n \n+        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(context);", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0MjY2OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472942668", "bodyText": "@santhanamk this change is related more to demonstrate proposal implementation, rather than to a functional one. If it is required, I can separate this code, but, I believe, this should not go to the final release version and should be deleted. Though, it remains here right now in order to help everybody to acknowledge. Should I remove it now?", "author": "kboskin", "createdAt": "2020-08-19T10:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MTUzNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473371535", "bodyText": "@kostyaBoss I still see this.  On line 106, can you rename the variable p to preferences?", "author": "santhanamk", "createdAt": "2020-08-19T22:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5OTk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex 30fbbff5c..664e1a605 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -105,25 +101,17 @@ public class VirtualDisplayEncoder {\n \n         mOutputListener = outputListener;\n \n-        SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(context);\n-\n-        predefined_width = p.getInt(\"pre_def_w\", predefined_width);\n-        predefined_height = p.getInt(\"pre_def_h\", predefined_height);\n-\n         initPassed = true;\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    public VideoStreamingParameters getStreamingParams(){\n+    public VideoStreamingParameters getStreamingParams() {\n         return this.streamingParams;\n     }\n \n-    @SuppressWarnings(\"unused\")\n     public void setStreamingParams(int displayDensity, ImageResolution resolution, int frameRate, int bitrate, int interval, VideoStreamingFormat format) {\n         this.streamingParams = new VideoStreamingParameters(displayDensity, frameRate, bitrate, interval, resolution, format);\n     }\n \n-    @SuppressWarnings(\"unused\")\n     public void setStreamingParams(VideoStreamingParameters streamingParams) {\n         this.streamingParams = streamingParams;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNTIyOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472005229", "bodyText": "What does the paused state represent?  I don't see it mentioned in the proposal.", "author": "santhanamk", "createdAt": "2020-08-18T08:25:50Z", "path": "base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java", "diffHunk": "@@ -37,10 +37,10 @@\n import java.lang.annotation.RetentionPolicy;\n \n public class StreamingStateMachine {\n-\t@IntDef({NONE, READY, STARTED, STOPPED, ERROR})\n+\t@IntDef({NONE, READY, STARTED, STOPPED, ERROR, PAUSED})", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyNTUyNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472925525", "bodyText": "@santhanamk, it was request by @joeljfischer during the proposal implementation", "author": "kboskin", "createdAt": "2020-08-19T10:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNTIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java b/base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java\nindex 21f1b15b7..6eb6fe3e3 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java\n\n@@ -31,78 +31,83 @@\n  */\n package com.smartdevicelink.managers;\n \n-import android.support.annotation.IntDef;\n+import androidx.annotation.IntDef;\n \n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n \n public class StreamingStateMachine {\n-\t@IntDef({NONE, READY, STARTED, STOPPED, ERROR, PAUSED})\n-\t@Retention(RetentionPolicy.SOURCE)\n-\tpublic @interface StreamingState {}\n-\tpublic static final int NONE = 0x00, READY = 0x30, STARTED = 0x60, STOPPED = 0x90, ERROR = 0xC0, PAUSED = 0xF0;\n+    @IntDef({NONE, READY, STARTED, STOPPED, ERROR, PAUSED})\n+    @Retention(RetentionPolicy.SOURCE)\n+    public @interface StreamingState {\n+    }\n \n-\tprivate @StreamingState int state = NONE;\n-\tprivate final Object STATE_LOCK = new Object();\n+    public static final int NONE = 0x00, READY = 0x30, STARTED = 0x60, STOPPED = 0x90, ERROR = 0xC0, PAUSED = 0xF0;\n \n-\tpublic StreamingStateMachine(){}\n+    private @StreamingState\n+    int state = NONE;\n+    private final Object STATE_LOCK = new Object();\n \n-\tpublic void transitionToState(int state) {\n-\t\tif(state != NONE && state != READY && state != STARTED\n-\t\t\t\t&& state != PAUSED && state != STOPPED && state != ERROR) {\n-\t\t\treturn;\n-\t\t}\n-\t\tsynchronized (STATE_LOCK) {\n-\t\t\tif(isValidTransition(this.state, state)){\n-\t\t\t\tthis.state = state;\n-\t\t\t}\n-\t\t}\n-\t}\n+    public StreamingStateMachine() {\n+    }\n \n-\tpublic @StreamingState int getState() {\n-\t\tsynchronized (STATE_LOCK) {\n-\t\t\treturn state;\n-\t\t}\n-\t}\n+    public void transitionToState(int state) {\n+        if (state != NONE && state != READY && state != STARTED\n+                && state != PAUSED && state != STOPPED && state != ERROR) {\n+            return;\n+        }\n+        synchronized (STATE_LOCK) {\n+            if (isValidTransition(this.state, state)) {\n+                this.state = state;\n+            }\n+        }\n+    }\n \n-\tprivate boolean isValidTransition(int prev_state, int next_state){\n-\t\tif(prev_state == next_state){\n-\t\t\treturn false;\n-\t\t}\n-\t\tswitch (prev_state){\n-\t\t\tcase NONE:\n-\t\t\t\tif((next_state == READY) || (next_state == ERROR)){\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase READY:\n-\t\t\t\tif((next_state == STARTED) || (next_state == ERROR)){\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase STARTED:\n-\t\t\t\tif((next_state == STOPPED) || (next_state == ERROR) || (next_state == PAUSED)){\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase PAUSED:\n-\t\t\t\tif((next_state == STARTED) || (next_state == STOPPED) || (next_state == ERROR)){\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase STOPPED:\n-\t\t\t\tif((next_state == STARTED) || (next_state == NONE)){\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase ERROR:\n-\t\t\t\tif(next_state == NONE){\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tbreak;\n-\t\t}\n-\t\treturn false;\n-\t}\n+    public @StreamingState\n+    int getState() {\n+        synchronized (STATE_LOCK) {\n+            return state;\n+        }\n+    }\n+\n+    private boolean isValidTransition(int prev_state, int next_state) {\n+        if (prev_state == next_state) {\n+            return false;\n+        }\n+        switch (prev_state) {\n+            case NONE:\n+                if ((next_state == READY) || (next_state == ERROR)) {\n+                    return true;\n+                }\n+                break;\n+            case READY:\n+                if ((next_state == STARTED) || (next_state == ERROR)) {\n+                    return true;\n+                }\n+                break;\n+            case STARTED:\n+                if ((next_state == STOPPED) || (next_state == ERROR) || (next_state == PAUSED)){\n+                    return true;\n+                }\n+                break;\n+            case PAUSED:\n+                if((next_state == STARTED) || (next_state == STOPPED) || (next_state == ERROR)) {\n+                    return true;\n+                }\n+                break;\n+            case STOPPED:\n+                if ((next_state == STARTED) || (next_state == NONE)) {\n+                    return true;\n+                }\n+                break;\n+            case ERROR:\n+                if (next_state == NONE) {\n+                    return true;\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+        return false;\n+    }\n }\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAyOTcyMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472029722", "bodyText": "In the setup function around line 105, does a call need to be made to videoStreamingCapability.setAdditionalVideoStreamingCapabilities(...)?", "author": "santhanamk", "createdAt": "2020-08-18T09:04:40Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java", "diffHunk": "@@ -365,9 +365,9 @@ public void testGetCapabilityHmiNone() {\n \t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n \t\tVideoStreamingCapability retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2ODA1Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473368052", "bodyText": "In the setup function around line 105, does a call need to be made to videoStreamingCapability.setAdditionalVideoStreamingCapabilities(...)?\n\n@kostyaBoss I still see this issue.  In the setup function around line 106, does a call need to be made to videoStreamingCapability.setAdditionalVideoStreamingCapabilities(...)?", "author": "santhanamk", "createdAt": "2020-08-19T22:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAyOTcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java\nindex 9b5d233d6..5d87795ca 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java\n\n@@ -89,1012 +85,981 @@ import static org.mockito.Mockito.when;\n \n @RunWith(AndroidJUnit4.class)\n public class SystemCapabilityManagerTests {\n-\tpublic static final String TAG = \"SystemCapabilityManagerTests\";\n-\tpublic static SystemCapabilityManager systemCapabilityManager;\n-\tprivate SystemCapability systemCapability;\n-\tprivate VideoStreamingCapability videoStreamingCapability;\n-\n-\t@Before\n-\tpublic void setUp() throws Exception{\n-\n-\t\tsystemCapability = new SystemCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\tvideoStreamingCapability = new VideoStreamingCapability();\n-\t\tvideoStreamingCapability.setMaxBitrate(TestValues.GENERAL_INT);\n-\t\tvideoStreamingCapability.setPreferredResolution(TestValues.GENERAL_IMAGERESOLUTION);\n-\t\tvideoStreamingCapability.setSupportedFormats(TestValues.GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\t}\n-\n-\tpublic SystemCapabilityManager createSampleManager(){\n-\t\treturn createSampleManager(new InternalSDLInterface());\n-\t}\n-\n-\tpublic SystemCapabilityManager createSampleManager(InternalSDLInterface iSdl){\n-\t\tSystemCapabilityManager systemCapabilityManager = new SystemCapabilityManager(iSdl);\n-\n-\t\tRegisterAppInterfaceResponse raiResponse = new RegisterAppInterfaceResponse();\n-\n-\t\traiResponse.setHmiCapabilities(TestValues.GENERAL_HMICAPABILITIES);\n-\t\traiResponse.setDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES);\n-\t\traiResponse.setAudioPassThruCapabilities(TestValues.GENERAL_AUDIOPASSTHRUCAPABILITIES_LIST);\n-\t\traiResponse.setButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\traiResponse.setHmiZoneCapabilities(TestValues.GENERAL_HMIZONECAPABILITIES_LIST);\n-\t\traiResponse.setPresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES);\n-\t\traiResponse.setSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n-\t\traiResponse.setSpeechCapabilities(TestValues.GENERAL_SPEECHCAPABILITIES_LIST);\n-\t\traiResponse.setPrerecordedSpeech(TestValues.GENERAL_PRERECORDEDSPEECH_LIST);\n-\t\traiResponse.setSuccess(true);\n-\n-\t\tsystemCapabilityManager.parseRAIResponse(raiResponse);\n-\t\treturn systemCapabilityManager;\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n-\t\tWindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n-\n-\t\tDisplayCapability displayCapability = new DisplayCapability();\n-\t\tdisplayCapability.setDisplayName(display != null ? display.getDisplayName() : null);\n-\t\tdisplayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n-\n-\t\tWindowCapability defaultWindowCapability = new WindowCapability();\n-\t\tdefaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t\tdefaultWindowCapability.setButtonCapabilities(button);\n-\t\tdefaultWindowCapability.setSoftButtonCapabilities(softButton);\n-\n-\t\tif (display == null) {\n-\t\t\tdefaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n-\t\t\tdefaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n-\t\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\t\treturn Collections.singletonList(displayCapability);\n-\t\t}\n-\n-\t\tdefaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n-\t\tdefaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n-\t\tdefaultWindowCapability.setTextFields(display.getTextFields());\n-\t\tdefaultWindowCapability.setImageFields(display.getImageFields());\n-\t\tArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n-\t\timageTypeSupported.add(ImageType.STATIC);\n-\t\tif (display.getGraphicSupported()) {\n-\t\t\timageTypeSupported.add(ImageType.DYNAMIC);\n-\t\t}\n-\t\tdefaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n-\n-\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\treturn Collections.singletonList(displayCapability);\n-\t}\n-\n-\tprivate DisplayCapabilities createDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n-\t\tDisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n-\t\tconvertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n-\t\tconvertedCapabilities.setDisplayName(displayName);\n-\t\tconvertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n-\t\tconvertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n-\t\tconvertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n-\t\tconvertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n-\t\tconvertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but can be empty\n-\t\tconvertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported().contains(ImageType.DYNAMIC));\n-\n-\t\treturn convertedCapabilities;\n-\t}\n-\n-\t@Test\n-\tpublic void testParseRAI() {\n-\t\tsystemCapabilityManager = createSampleManager();\n-\n-\t\tList<DisplayCapability> displayCapabilityList = createDisplayCapabilityList(TestValues.GENERAL_DISPLAYCAPABILITIES, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateDisplayCapabilityList(displayCapabilityList, (List<DisplayCapability>) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateHMICapabilities(TestValues.GENERAL_HMICAPABILITIES, (HMICapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.HMI)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES, (DisplayCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateAudioPassThruCapabilities(TestValues.GENERAL_AUDIOPASSTHRUCAPABILITIES_LIST, (List<AudioPassThruCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.AUDIO_PASSTHROUGH)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST, (List<ButtonCapabilities> )systemCapabilityManager.getCapability(SystemCapabilityType.BUTTON)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateHMIZoneCapabilities(TestValues.GENERAL_HMIZONECAPABILITIES_LIST, (List<HmiZoneCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.HMI_ZONE)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validatePresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES, (PresetBankCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.PRESET_BANK)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST, (List<SoftButtonCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.SOFTBUTTON)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateSpeechCapabilities(TestValues.GENERAL_SPEECHCAPABILITIES_LIST, (List<SpeechCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.SPEECH)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validatePreRecordedSpeechCapabilities(TestValues.GENERAL_PRERECORDEDSPEECH_LIST, (List<PrerecordedSpeech>) systemCapabilityManager.getCapability(SystemCapabilityType.PRERECORDED_SPEECH)));\n-\n-\t}\n-\n-\t@Test\n-\tpublic void testNullDisplayCapabilitiesEnablesAllTextAndImageFields() {\n-\t\tList<DisplayCapability> displayCapabilityList = createDisplayCapabilityList(null, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n-\t\tassertEquals(displayCapabilityList.get(0).getWindowCapabilities().get(0).getTextFields().size(), 29);\n-\t\tassertEquals(displayCapabilityList.get(0).getWindowCapabilities().get(0).getImageFields().size(), 14);\n-\t}\n-\n-\t@Test\n-\tpublic void testGetVSCapability(){\n-\t\tVideoStreamingCapability vsCapability = new VideoStreamingCapability();\n-\t\tvsCapability.setMaxBitrate(TestValues.GENERAL_INT);\n-\t\tvsCapability.setPreferredResolution(TestValues.GENERAL_IMAGERESOLUTION);\n-\t\tvsCapability.setSupportedFormats(TestValues.GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\n-\t\tSystemCapability cap = new SystemCapability();\n-\t\tcap.setSystemCapabilityType(SystemCapabilityType.VIDEO_STREAMING);\n-\t\tcap.setCapabilityForType(SystemCapabilityType.VIDEO_STREAMING, vsCapability);\n-\n-\t\tfinal SystemCapability referenceCapability = cap;\n-\n-\t\tsystemCapabilityManager = new SystemCapabilityManager(new InternalSDLInterface() {\n-\t\t\t@Override\n-\t\t\tpublic void sendRPC(RPCMessage message) {\n-\t\t\t\tGetSystemCapabilityResponse response = new GetSystemCapabilityResponse();\n-\t\t\t\tresponse.setSystemCapability(referenceCapability);\n-\t\t\t\tresponse.setSuccess(true);\n-\t\t\t\tif (message instanceof RPCRequest) {\n-\t\t\t\t\tRPCRequest request = (RPCRequest) message;\n-\t\t\t\t\trequest.getOnRPCResponseListener().onResponse(CorrelationIdGenerator.generateId(), response);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void addOnRPCListener(FunctionID messageId, OnRPCListener listener) {\n-\t\t\t\tlistener.onReceived(new OnHMIStatus(HMILevel.HMI_FULL, AudioStreamingState.NOT_AUDIBLE, SystemContext.SYSCTXT_MAIN));\n-\t\t\t}\n-\t\t});\n-\n-\t\tsystemCapabilityManager.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\t\t\tValidator.validateVideoStreamingCapability(\n-\t\t\t\t\t\t\t\t(VideoStreamingCapability) referenceCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING),\n-\t\t\t\t\t\t\t\t(VideoStreamingCapability) capability));\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tassertTrue(false);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tprivate Answer<Void> createOnHMIStatusAnswer(final HMILevel hmiLevel){\n-\t\tAnswer<Void> onHMIStatusAnswer = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tOnRPCListener onHMIStatusListener = (OnRPCListener) args[1];\n-\t\t\t\tOnHMIStatus onHMIStatusFakeNotification = new OnHMIStatus();\n-\t\t\t\tonHMIStatusFakeNotification.setHmiLevel(hmiLevel);\n-\t\t\t\tonHMIStatusListener.onReceived(onHMIStatusFakeNotification);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\t\treturn onHMIStatusAnswer;\n-\t}\n-\n-\tprivate Answer<Void> createOnSendGetSystemCapabilityAnswer (final boolean success, final Boolean subscribe) {\n-\t\tAnswer<Void> onSendGetSystemCapabilityAnswer = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tGetSystemCapability getSystemCapability = (GetSystemCapability) args[0];\n-\t\t\t\tif (subscribe != null) {\n-\t\t\t\t\tassertEquals(subscribe, getSystemCapability.getSubscribe());\n-\t\t\t\t}\n-\t\t\t\tGetSystemCapabilityResponse response;\n-\t\t\t\tif (success) {\n-\t\t\t\t\tresponse = new GetSystemCapabilityResponse(Result.SUCCESS, true);\n-\t\t\t\t} else {\n-\t\t\t\t\tresponse = new GetSystemCapabilityResponse(Result.REJECTED, false);\n-\t\t\t\t}\n-\t\t\t\tresponse.setSystemCapability(systemCapability);\n-\t\t\t\tgetSystemCapability.getOnRPCResponseListener().onResponse(CorrelationIdGenerator.generateId(), response);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\t\treturn onSendGetSystemCapabilityAnswer;\n-\t}\n-\n-\t@Test\n-\tpublic void testGetCapability() {\n-\t\tISdl internalInterface;\n-\t\tSystemCapabilityManager scm;\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener;\n-\t\tVideoStreamingCapability retrievedCapability;\n-\n-\n-\t\t// Test case 1 (capability not cached, listener not null, forceUpdate false)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n-\t\tretrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n-\t\tassertNull(retrievedCapability);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Test case 2 (capability cached, listener not null, forceUpdate true)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\t\tretrievedCapability =  (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, true);\n-\t\tassertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Test case 3 (capability cached, listener null, forceUpdate true)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = null;\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\t\tretrievedCapability =  (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, true);\n-\t\tassertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\n-\n-\t\t// Test case 4 (capability cached, listener null, forceUpdate false)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = null;\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\t\tretrievedCapability =  (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n-\t\tassertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testGetCapabilityHmiNone() {\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_NONE)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n-\t\tVideoStreamingCapability retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n-\t\tassertNull(retrievedCapability);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener, times(0)).onError(any(String.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerWithSubscriptionsSupportedAndCapabilityCached() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(6, 0); // This version supports capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\n-\n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should go out with subscribe=true\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\n-\n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\n-\n-\t\t// Remove listener3\n-\t\t// When the last listener is removed, GetSystemCapability request should go out with subscribe=false\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerWithSubscriptionsSupportedAndCapabilityNotCached() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(6, 0); // This version supports capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n-\n-\n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should go out with subscribe=true\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\n-\n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+    public static final String TAG = \"SystemCapabilityManagerTests\";\n+    public static SystemCapabilityManager systemCapabilityManager;\n+    private SystemCapability systemCapability;\n+    private VideoStreamingCapability videoStreamingCapability;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+\n+        systemCapability = new SystemCapability(SystemCapabilityType.VIDEO_STREAMING);\n+        videoStreamingCapability = new VideoStreamingCapability();\n+        videoStreamingCapability.setMaxBitrate(TestValues.GENERAL_INT);\n+        videoStreamingCapability.setPreferredResolution(TestValues.GENERAL_IMAGERESOLUTION);\n+        videoStreamingCapability.setSupportedFormats(TestValues.GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        videoStreamingCapability.setAdditionalVideoStreamingCapabilities(TestValues.GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+    }\n+\n+    public SystemCapabilityManager createSampleManager() {\n+        return createSampleManager(new InternalSDLInterface());\n+    }\n+\n+    public SystemCapabilityManager createSampleManager(InternalSDLInterface iSdl) {\n+        SystemCapabilityManager systemCapabilityManager = new SystemCapabilityManager(iSdl);\n+\n+        RegisterAppInterfaceResponse raiResponse = new RegisterAppInterfaceResponse();\n+\n+        raiResponse.setHmiCapabilities(TestValues.GENERAL_HMICAPABILITIES);\n+        raiResponse.setDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES);\n+        raiResponse.setAudioPassThruCapabilities(TestValues.GENERAL_AUDIOPASSTHRUCAPABILITIES_LIST);\n+        raiResponse.setButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST);\n+        raiResponse.setHmiZoneCapabilities(TestValues.GENERAL_HMIZONECAPABILITIES_LIST);\n+        raiResponse.setPresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES);\n+        raiResponse.setSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+        raiResponse.setSpeechCapabilities(TestValues.GENERAL_SPEECHCAPABILITIES_LIST);\n+        raiResponse.setPrerecordedSpeech(TestValues.GENERAL_PRERECORDEDSPEECH_LIST);\n+        raiResponse.setSuccess(true);\n+\n+        systemCapabilityManager.parseRAIResponse(raiResponse);\n+        return systemCapabilityManager;\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n+        WindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n+\n+        DisplayCapability displayCapability = new DisplayCapability();\n+        displayCapability.setDisplayName(display != null ? display.getDisplayName() : null);\n+        displayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n+\n+        WindowCapability defaultWindowCapability = new WindowCapability();\n+        defaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+        defaultWindowCapability.setButtonCapabilities(button);\n+        defaultWindowCapability.setSoftButtonCapabilities(softButton);\n+\n+        if (display == null) {\n+            defaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n+            defaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n+            displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+            return Collections.singletonList(displayCapability);\n+        }\n+\n+        defaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n+        defaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n+        defaultWindowCapability.setTextFields(display.getTextFields());\n+        defaultWindowCapability.setImageFields(display.getImageFields());\n+        ArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n+        imageTypeSupported.add(ImageType.STATIC);\n+        if (display.getGraphicSupported()) {\n+            imageTypeSupported.add(ImageType.DYNAMIC);\n+        }\n+        defaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n+\n+        displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+        return Collections.singletonList(displayCapability);\n+    }\n+\n+    private DisplayCapabilities createDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n+        DisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n+        convertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n+        convertedCapabilities.setDisplayName(displayName);\n+        convertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n+        convertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n+        convertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n+        convertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n+        convertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but can be empty\n+        convertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported().contains(ImageType.DYNAMIC));\n+\n+        return convertedCapabilities;\n+    }\n+\n+    @Test\n+    public void testParseRAI() {\n+        systemCapabilityManager = createSampleManager();\n+\n+        List<DisplayCapability> displayCapabilityList = createDisplayCapabilityList(TestValues.GENERAL_DISPLAYCAPABILITIES, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateDisplayCapabilityList(displayCapabilityList, (List<DisplayCapability>) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateHMICapabilities(TestValues.GENERAL_HMICAPABILITIES, (HMICapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.HMI, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES, (DisplayCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateAudioPassThruCapabilities(TestValues.GENERAL_AUDIOPASSTHRUCAPABILITIES_LIST, (List<AudioPassThruCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST, (List<ButtonCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.BUTTON, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateHMIZoneCapabilities(TestValues.GENERAL_HMIZONECAPABILITIES_LIST, (List<HmiZoneCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.HMI_ZONE, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validatePresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES, (PresetBankCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.PRESET_BANK, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST, (List<SoftButtonCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.SOFTBUTTON, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateSpeechCapabilities(TestValues.GENERAL_SPEECHCAPABILITIES_LIST, (List<SpeechCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.SPEECH, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validatePreRecordedSpeechCapabilities(TestValues.GENERAL_PRERECORDEDSPEECH_LIST, (List<PrerecordedSpeech>) systemCapabilityManager.getCapability(SystemCapabilityType.PRERECORDED_SPEECH, null, false)));\n+\n+    }\n+\n+    @Test\n+    public void testNullDisplayCapabilitiesEnablesAllTextAndImageFields() {\n+        List<DisplayCapability> displayCapabilityList = createDisplayCapabilityList(null, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+        assertEquals(displayCapabilityList.get(0).getWindowCapabilities().get(0).getTextFields().size(), 32);\n+        assertEquals(displayCapabilityList.get(0).getWindowCapabilities().get(0).getImageFields().size(), 16);\n+    }\n+\n+    @Test\n+    public void testGetVSCapability() {\n+        VideoStreamingCapability vsCapability = new VideoStreamingCapability();\n+        vsCapability.setMaxBitrate(TestValues.GENERAL_INT);\n+        vsCapability.setPreferredResolution(TestValues.GENERAL_IMAGERESOLUTION);\n+        vsCapability.setAdditionalVideoStreamingCapabilities(TestValues.GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+        vsCapability.setSupportedFormats(TestValues.GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+\n+        SystemCapability cap = new SystemCapability();\n+        cap.setSystemCapabilityType(SystemCapabilityType.VIDEO_STREAMING);\n+        cap.setCapabilityForType(SystemCapabilityType.VIDEO_STREAMING, vsCapability);\n+\n+        final SystemCapability referenceCapability = cap;\n+\n+        systemCapabilityManager = new SystemCapabilityManager(new InternalSDLInterface() {\n+            @Override\n+            public void sendRPC(RPCMessage message) {\n+                GetSystemCapabilityResponse response = new GetSystemCapabilityResponse();\n+                response.setSystemCapability(referenceCapability);\n+                response.setSuccess(true);\n+                if (message instanceof RPCRequest) {\n+                    RPCRequest request = (RPCRequest) message;\n+                    request.getOnRPCResponseListener().onResponse(CorrelationIdGenerator.generateId(), response);\n+                }\n+            }\n+\n+            @Override\n+            public void addOnRPCListener(FunctionID messageId, OnRPCListener listener) {\n+                listener.onReceived(new OnHMIStatus(HMILevel.HMI_FULL, AudioStreamingState.NOT_AUDIBLE, SystemContext.SYSCTXT_MAIN));\n+            }\n+        });\n+\n+        systemCapabilityManager.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+            @Override\n+            public void onCapabilityRetrieved(Object capability) {\n+                assertTrue(TestValues.TRUE,\n+                        Validator.validateVideoStreamingCapability(\n+                                (VideoStreamingCapability) referenceCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING),\n+                                (VideoStreamingCapability) capability));\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                assertTrue(false);\n+            }\n+        }, false);\n+    }\n+\n+    private Answer<Void> createOnHMIStatusAnswer(final HMILevel hmiLevel) {\n+        Answer<Void> onHMIStatusAnswer = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnRPCListener onHMIStatusListener = (OnRPCListener) args[1];\n+                OnHMIStatus onHMIStatusFakeNotification = new OnHMIStatus();\n+                onHMIStatusFakeNotification.setHmiLevel(hmiLevel);\n+                onHMIStatusListener.onReceived(onHMIStatusFakeNotification);\n+                return null;\n+            }\n+        };\n+        return onHMIStatusAnswer;\n+    }\n+\n+    private Answer<Void> createOnSendGetSystemCapabilityAnswer(final boolean success, final Boolean subscribe) {\n+        Answer<Void> onSendGetSystemCapabilityAnswer = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                GetSystemCapability getSystemCapability = (GetSystemCapability) args[0];\n+                if (subscribe != null) {\n+                    assertEquals(subscribe, getSystemCapability.getSubscribe());\n+                }\n+                GetSystemCapabilityResponse response;\n+                if (success) {\n+                    response = new GetSystemCapabilityResponse(Result.SUCCESS, true);\n+                } else {\n+                    response = new GetSystemCapabilityResponse(Result.REJECTED, false);\n+                }\n+                response.setSystemCapability(systemCapability);\n+                getSystemCapability.getOnRPCResponseListener().onResponse(CorrelationIdGenerator.generateId(), response);\n+                return null;\n+            }\n+        };\n+        return onSendGetSystemCapabilityAnswer;\n+    }\n+\n+    @Test\n+    public void testGetCapability() {\n+        ISdl internalInterface;\n+        SystemCapabilityManager scm;\n+        OnSystemCapabilityListener onSystemCapabilityListener;\n+        VideoStreamingCapability retrievedCapability;\n+\n+\n+        // Test case 1 (capability not cached, listener not null, forceUpdate false)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n+        retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n+        assertNull(retrievedCapability);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Test case 2 (capability cached, listener not null, forceUpdate true)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+        retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, true);\n+        assertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Test case 3 (capability cached, listener null, forceUpdate true)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = null;\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+        retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, true);\n+        assertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+\n+\n+        // Test case 4 (capability cached, listener null, forceUpdate false)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = null;\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+        retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n+        assertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+    }\n+\n+    @Test\n+    public void testGetCapabilityHmiNone() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_NONE)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        OnSystemCapabilityListener onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n+        VideoStreamingCapability retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n+        assertNull(retrievedCapability);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener, times(0)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener, times(1)).onError(any(String.class));\n+    }\n+\n+    @Test\n+    public void testAddOnSystemCapabilityListenerWithSubscriptionsSupportedAndCapabilityCached() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(6, 0); // This version supports capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+\n+\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should go out with subscribe=true\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+\n+\n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+\n+\n+        // Remove listener3\n+        // When the last listener is removed, GetSystemCapability request should go out with subscribe=false\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+    }\n+\n+    @Test\n+    public void testAddOnSystemCapabilityListenerWithSubscriptionsSupportedAndCapabilityNotCached() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(6, 0); // This version supports capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n+\n+\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should go out with subscribe=true\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener3\n-\t\t// When the last listener is removed, GetSystemCapability request should go out with subscribe=false\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n-\t}\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerWithSubscriptionsNotSupportedAndCapabilityCached() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n \n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n \n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should not go out because subscription is not supported and the capability is cached\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n \n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener3\n+        // When the last listener is removed, GetSystemCapability request should go out with subscribe=false\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n+    }\n \n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+    @Test\n+    public void testAddOnSystemCapabilityListenerWithSubscriptionsNotSupportedAndCapabilityCached() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n \n \n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should not go out because subscription is not supported and the capability is cached\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener3\n-\t\t// When the last listener is removed, GetSystemCapability request should not go out because subscription is not supported\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t}\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerWithSubscriptionsNotSupportedAndCapabilityNotCached() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n \n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n \n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should out because because capability is not cached\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n \n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener3\n+        // When the last listener is removed, GetSystemCapability request should not go out because subscription is not supported\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+    }\n \n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+    @Test\n+    public void testAddOnSystemCapabilityListenerWithSubscriptionsNotSupportedAndCapabilityNotCached() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n \n \n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should out because because capability is not cached\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener3\n-\t\t// When the last listener is removed, GetSystemCapability request should not go out because subscription is not supported\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t}\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerThenGetCapabilityWhenSubscriptionsAreNotSupported() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n \n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n \n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should go out with subscribe=false\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n \n-\t\t// Get Capability (should notify listener1 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(2)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener3\n+        // When the last listener is removed, GetSystemCapability request should not go out because subscription is not supported\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n+    }\n \n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+    @Test\n+    public void testAddOnSystemCapabilityListenerThenGetCapabilityWhenSubscriptionsAreNotSupported() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n \n \n-\t\t// Get Capability (should notify listener1 & listener2 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(3)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(2)).onCapabilityRetrieved(any(Object.class));\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should go out with subscribe=false\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+        // Get Capability (should notify listener1 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Get Capability (should notify listener1 & listener2 & listener3 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(3)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(3)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener3, times(2)).onCapabilityRetrieved(any(Object.class));\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        // Get Capability (should notify listener1 & listener2 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Get Capability (should notify listener2 & listener3 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(4)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener3, times(3)).onCapabilityRetrieved(any(Object.class));\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        // Get Capability (should notify listener1 & listener2 & listener3 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Get Capability (should notify listener3 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(5)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener3, times(4)).onCapabilityRetrieved(any(Object.class));\n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n \n \n-\t\t// Remove listener3\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(5)).sendRPC(any(GetSystemCapability.class));\n+        // Get Capability (should notify listener2 & listener3 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Get Capability (should not notify any listener again because they are all removed)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(6)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener3, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t}\n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n \n-\t@Test\n-\tpublic void testGetAndAddListenerForDisplaysCapability() {\n-\t\tISdl internalInterface;\n-\t\tSystemCapabilityManager scm;\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener;\n-\t\tDisplayCapabilities retrievedCapability;\n-\n-\n-\t\t// Test case 1 (capability cached, listener not null, forceUpdate true)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.DISPLAYS, new DisplayCapabilities());\n-\t\tretrievedCapability = (DisplayCapabilities) scm.getCapability(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener, true);\n-\t\tassertNotNull(retrievedCapability);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener, times(0)).onError(any(String.class));\n \n-\n-\t\t// Test case 2 (Add listener)\n-\t\t// When the first DISPLAYS listener is added, GetSystemCapability request should not go out\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        // Get Capability (should notify listener3 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Test case 3 (Remove listener)\n-\t\t// When the last DISPLAYS listener is removed, GetSystemCapability request should not go out\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testListConversion(){\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager();\n-\t\tObject capability = systemCapabilityManager.getCapability(SystemCapabilityType.SOFTBUTTON);\n-\t\tassertNotNull(capability);\n-\t\tList<SoftButtonCapabilities> list = SystemCapabilityManager.convertToList(capability, SoftButtonCapabilities.class);\n-\t\tassertNotNull(list);\n-\t}\n-\n-\t@Test\n-\tpublic void testFalsePositive(){\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager();\n-\t\tsystemCapabilityManager.setCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, null);\n-\t\tassertFalse(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.AUDIO_PASSTHROUGH));\n-\t}\n-\n-\t@Test\n-\tpublic void testOnSystemCapabilityUpdateWithNoExistingCap(){\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tOnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n-\t\tassertNotNull(scmRpcListener);\n-\n-\t\tassertNull(systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES));\n+        // Remove listener3\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH THE SCM */\n-\t\tAppServiceCapability addServiceID = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"test\", \"3453\", true, null);\n-\t\tAppServicesCapabilities serviceIdASC = new AppServicesCapabilities();\n-\t\tserviceIdASC.setAppServices(Collections.singletonList(addServiceID));\n \n-\t\tSystemCapability systemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, serviceIdASC);\n-\n-\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        // Get Capability (should not notify any listener again because they are all removed)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+    }\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+    @Test\n+    public void testGetAndAddListenerForDisplaysCapability() {\n+        ISdl internalInterface;\n+        SystemCapabilityManager scm;\n+        OnSystemCapabilityListener onSystemCapabilityListener;\n+        DisplayCapabilities retrievedCapability;\n+\n+\n+        // Test case 1 (capability cached, listener not null, forceUpdate true)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.DISPLAYS, new DisplayCapabilities());\n+        retrievedCapability = (DisplayCapabilities) scm.getCapability(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener, true);\n+        assertNotNull(retrievedCapability);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener, times(0)).onError(any(String.class));\n \n-\t\tassertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES));\n-\t}\n-\n-\t@Test\n-\tpublic void testOnSystemCapabilityUpdatedForDISPLAYS() {\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tOnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n-\t\tassertNotNull(scmRpcListener);\n \n-\t\tassertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS));\n-\t\tassertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY));\n-\n-\t\tList<DisplayCapability> newCaps = createDisplayCapabilityList(TestValues.GENERAL_DISPLAYCAPABILITIES, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);;\n-\n-\t\tSystemCapability systemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.DISPLAYS);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.DISPLAYS, newCaps);\n-\n-\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n-\n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        // Test case 2 (Add listener)\n+        // When the first DISPLAYS listener is added, GetSystemCapability request should not go out\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n \n-\t\tList<DisplayCapability> appliedCaps = (List<DisplayCapability>)systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS);\n-\t\tassertNotNull(appliedCaps);\n-\t\tassertTrue(Validator.validateDisplayCapabilityList(newCaps, appliedCaps));\n-\n-\t\tDisplayCapabilities appliedConvertedCaps = (DisplayCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY);\n-\t\tassertNotNull(appliedConvertedCaps);\n-\t\tDisplayCapabilities testConvertedCaps = createDisplayCapabilities(newCaps.get(0).getDisplayName(), newCaps.get(0).getWindowCapabilities().get(0));\n-\t\tassertTrue(Validator.validateDisplayCapabilities(appliedConvertedCaps, testConvertedCaps));\n-\t}\n-\n-\t@Test\n-\tpublic void testOnSystemCapabilityUpdated(){\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tString baseName = \"NavTest\", baseID = \"37F98053AE\";\n-\t\tAppServiceCapability capability1 = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, baseName, null, true, null);\n+        // Test case 3 (Remove listener)\n+        // When the last DISPLAYS listener is removed, GetSystemCapability request should not go out\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+    }\n+\n+    @Test\n+    public void testListConversion() {\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager();\n+        Object capability = systemCapabilityManager.getCapability(SystemCapabilityType.SOFTBUTTON, null, false);\n+        assertNotNull(capability);\n+        List<SoftButtonCapabilities> list = SystemCapabilityManager.convertToList(capability, SoftButtonCapabilities.class);\n+        assertNotNull(list);\n+    }\n+\n+    @Test\n+    public void testFalsePositive() {\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager();\n+        systemCapabilityManager.setCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, null);\n+        assertFalse(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.AUDIO_PASSTHROUGH));\n+    }\n+\n+    @Test\n+    public void testOnSystemCapabilityUpdateWithNoExistingCap() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        OnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n+        assertNotNull(scmRpcListener);\n+\n+        assertNull(systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false));\n \n-\t\tAppServicesCapabilities appServicesCapabilities = new AppServicesCapabilities();\n-\t\tappServicesCapabilities.setAppServices(Collections.singletonList(capability1));\n+        /* PERFORM A NOTIFICATION SEND THROUGH THE SCM */\n+        AppServiceCapability addServiceID = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"test\", \"3453\", true, null);\n+        AppServicesCapabilities serviceIdASC = new AppServicesCapabilities();\n+        serviceIdASC.setAppServices(Collections.singletonList(addServiceID));\n \n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tassertNotNull(iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()));\n-\t\tOnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n-\t\tassertNotNull(scmRpcListener);\n+        SystemCapability systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, serviceIdASC);\n+\n+        OnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\t/* CONFIRM THE CAP DOESN'T EXIST IN SCM */\n-\t\tAppServicesCapabilities cachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNull(cachedCap);\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\t/* ADD THE CAP IN SCM */\n-\t\tsystemCapabilityManager.setCapability(SystemCapabilityType.APP_SERVICES, appServicesCapabilities);\n-\t\t/* CONFIRM THE CAP DOES EXIST IN SCM */\n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n-\t\t/* CONFIRM THE CAP IN SCM EQUALS ORIGINAL*/\n-\t\tassertEquals(cachedCap, appServicesCapabilities);\n-\t\tassertNull(cachedCap.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID());\n+        assertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false));\n+    }\n+\n+    @Test\n+    public void testOnSystemCapabilityUpdatedForDISPLAYS() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        OnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n+        assertNotNull(scmRpcListener);\n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH THE SCM */\n-\t\tAppServiceCapability addServiceID = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, baseName, baseID, true, null);\n-\t\tAppServicesCapabilities serviceIdASC = new AppServicesCapabilities();\n-\t\tserviceIdASC.setAppServices(Collections.singletonList(addServiceID));\n+        assertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS, null, false));\n+        assertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY, null, false));\n+\n+        List<DisplayCapability> newCaps = createDisplayCapabilityList(TestValues.GENERAL_DISPLAYCAPABILITIES, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+\n+        SystemCapability systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.DISPLAYS);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.DISPLAYS, newCaps);\n+\n+        OnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tSystemCapability systemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, serviceIdASC);\n+        List<DisplayCapability> appliedCaps = (List<DisplayCapability>) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS, null, false);\n+        assertNotNull(appliedCaps);\n+        assertTrue(Validator.validateDisplayCapabilityList(newCaps, appliedCaps));\n+\n+        DisplayCapabilities appliedConvertedCaps = (DisplayCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY, null, false);\n+        assertNotNull(appliedConvertedCaps);\n+        DisplayCapabilities testConvertedCaps = createDisplayCapabilities(newCaps.get(0).getDisplayName(), newCaps.get(0).getWindowCapabilities().get(0));\n+        assertTrue(Validator.validateDisplayCapabilities(appliedConvertedCaps, testConvertedCaps));\n+    }\n+\n+    @Test\n+    public void testOnSystemCapabilityUpdated() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        String baseName = \"NavTest\", baseID = \"37F98053AE\";\n+        AppServiceCapability capability1 = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, baseName, null, true, null);\n \n-\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        AppServicesCapabilities appServicesCapabilities = new AppServicesCapabilities();\n+        appServicesCapabilities.setAppServices(Collections.singletonList(capability1));\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        assertNotNull(iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()));\n+        OnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n+        assertNotNull(scmRpcListener);\n \n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n+        /* CONFIRM THE CAP DOESN'T EXIST IN SCM */\n+        AppServicesCapabilities cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNull(cachedCap);\n \n-\t\tassertTrue(cachedCap.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID().equals(baseID));\n+        /* ADD THE CAP IN SCM */\n+        systemCapabilityManager.setCapability(SystemCapabilityType.APP_SERVICES, appServicesCapabilities);\n+        /* CONFIRM THE CAP DOES EXIST IN SCM */\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n+        /* CONFIRM THE CAP IN SCM EQUALS ORIGINAL*/\n+        assertEquals(cachedCap, appServicesCapabilities);\n+        assertNull(cachedCap.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID());\n \n-\t\tappServicesCapabilities.updateAppServices(Collections.singletonList(addServiceID));\n-\t\tassertTrue(serviceIdASC.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID().equalsIgnoreCase(appServicesCapabilities.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID()));\n+        /* PERFORM A NOTIFICATION SEND THROUGH THE SCM */\n+        AppServiceCapability addServiceID = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, baseName, baseID, true, null);\n+        AppServicesCapabilities serviceIdASC = new AppServicesCapabilities();\n+        serviceIdASC.setAppServices(Collections.singletonList(addServiceID));\n \n-\t\tassertEquals(cachedCap, appServicesCapabilities);\n+        SystemCapability systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, serviceIdASC);\n \n+        OnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH AN UPDATED SERVICE NAME */\n-\t\tAppServiceCapability newServiceName = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"TestNav\", baseID, true, null);\n-\t\tAppServicesCapabilities newServiceNameASC = new AppServicesCapabilities();\n-\t\tnewServiceNameASC.setAppServices(Collections.singletonList(newServiceName));\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tsystemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, newServiceNameASC);\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n \n-\t\tonSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        assertTrue(cachedCap.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID().equals(baseID));\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        appServicesCapabilities.updateAppServices(Collections.singletonList(addServiceID));\n+        assertTrue(serviceIdASC.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID().equalsIgnoreCase(appServicesCapabilities.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID()));\n \n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n-\t\tassertEquals(cachedCap.getAppServices().size(), 1);\n+        assertEquals(cachedCap, appServicesCapabilities);\n \n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH THE SCM WITH DIFFERENT SERVICE */\n-\t\tAppServiceCapability newService = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"NewNav\", \"eeeeeeeee\", false, null);\n-\t\tAppServicesCapabilities newServiceASC = new AppServicesCapabilities();\n-\t\tnewServiceASC.setAppServices(Collections.singletonList(newService));\n+        /* PERFORM A NOTIFICATION SEND THROUGH AN UPDATED SERVICE NAME */\n+        AppServiceCapability newServiceName = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"TestNav\", baseID, true, null);\n+        AppServicesCapabilities newServiceNameASC = new AppServicesCapabilities();\n+        newServiceNameASC.setAppServices(Collections.singletonList(newServiceName));\n \n-\t\tsystemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, newServiceASC);\n+        systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, newServiceNameASC);\n \n-\t\tonSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n-\t\tassertEquals(cachedCap.getAppServices().size(), 2);\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n+        assertEquals(cachedCap.getAppServices().size(), 1);\n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH THE SCM WITH A REMOVED SERVICE */\n-\t\tAppServiceCapability removedService = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"NewNav\", \"eeeeeeeee\", false, null);\n-\t\tremovedService.setUpdateReason(ServiceUpdateReason.REMOVED);\n-\t\tAppServicesCapabilities removedServiceASC = new AppServicesCapabilities();\n-\t\tremovedServiceASC.setAppServices(Collections.singletonList(removedService));\n \n-\t\tsystemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, removedServiceASC);\n+        /* PERFORM A NOTIFICATION SEND THROUGH THE SCM WITH DIFFERENT SERVICE */\n+        AppServiceCapability newService = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"NewNav\", \"eeeeeeeee\", false, null);\n+        AppServicesCapabilities newServiceASC = new AppServicesCapabilities();\n+        newServiceASC.setAppServices(Collections.singletonList(newService));\n \n-\t\tonSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, newServiceASC);\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n-\t\tassertEquals(cachedCap.getAppServices().size(), 1);\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t}\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n+        assertEquals(cachedCap.getAppServices().size(), 2);\n \n+        /* PERFORM A NOTIFICATION SEND THROUGH THE SCM WITH A REMOVED SERVICE */\n+        AppServiceCapability removedService = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"NewNav\", \"eeeeeeeee\", false, null);\n+        removedService.setUpdateReason(ServiceUpdateReason.REMOVED);\n+        AppServicesCapabilities removedServiceASC = new AppServicesCapabilities();\n+        removedServiceASC.setAppServices(Collections.singletonList(removedService));\n+\n+        systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, removedServiceASC);\n \n-\t@Test\n-\tpublic void testOnSystemCapabilityUpdatedOverwrite(){\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tOnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n-\t\tassertNotNull(scmRpcListener);\n-\t\tsystemCapabilityManager.setCapability(SystemCapabilityType.PHONE_CALL, TestValues.GENERAL_PHONECAPABILITY);\n+        onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\tPhoneCapability phoneCapability = (PhoneCapability)systemCapabilityManager.getCapability(SystemCapabilityType.PHONE_CALL);\n-\t\tassertNotNull(phoneCapability);\n-\t\tassertEquals(phoneCapability, TestValues.GENERAL_PHONECAPABILITY);\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tphoneCapability.setDialNumberEnabled(!TestValues.GENERAL_PHONECAPABILITY.getDialNumberEnabled()); //Flip it\n-\t\tSystemCapability systemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.PHONE_CALL);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.PHONE_CALL, phoneCapability);\n-\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n+        assertEquals(cachedCap.getAppServices().size(), 1);\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+    }\n \n-\t\tPhoneCapability phoneCapabilityUpdated = (PhoneCapability)systemCapabilityManager.getCapability(SystemCapabilityType.PHONE_CALL);\n-\t\tassertNotNull(phoneCapabilityUpdated);\n-\t\tassertFalse(phoneCapabilityUpdated.getDialNumberEnabled());\n-\t\tassertEquals(phoneCapability, phoneCapabilityUpdated);\n-\t}\n \n-\t@Test\n-\tpublic void testOnSetDisplayLayout() {\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tOnRPCListener dlRpcListener = iSDL.rpcListeners.get(FunctionID.SET_DISPLAY_LAYOUT.getId()).get(0);\n-\t\tassertNotNull(dlRpcListener);\n+    @Test\n+    public void testOnSystemCapabilityUpdatedOverwrite() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        OnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n+        assertNotNull(scmRpcListener);\n+        systemCapabilityManager.setCapability(SystemCapabilityType.PHONE_CALL, TestValues.GENERAL_PHONECAPABILITY);\n \n-\t\tSetDisplayLayoutResponse newLayout = new SetDisplayLayoutResponse();\n-\t\tnewLayout.setDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES);\n-\t\tnewLayout.setButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tnewLayout.setSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n-\t\tnewLayout.setPresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES);\n-\t\tnewLayout.setSuccess(true);\n-\t\tnewLayout.setResultCode(Result.SUCCESS);\n+        PhoneCapability phoneCapability = (PhoneCapability) systemCapabilityManager.getCapability(SystemCapabilityType.PHONE_CALL, null, false);\n+        assertNotNull(phoneCapability);\n+        assertEquals(phoneCapability, TestValues.GENERAL_PHONECAPABILITY);\n \n-\t\tdlRpcListener.onReceived(newLayout);\n+        phoneCapability.setDialNumberEnabled(!TestValues.GENERAL_PHONECAPABILITY.getDialNumberEnabled()); //Flip it\n+        SystemCapability systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.PHONE_CALL);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.PHONE_CALL, phoneCapability);\n+        OnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tDisplayCapabilities appliedCaps = (DisplayCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY);\n-\t\tassertNotNull(appliedCaps);\n-\t\tassertTrue(Validator.validateDisplayCapabilities(newLayout.getDisplayCapabilities(), appliedCaps));\n+        PhoneCapability phoneCapabilityUpdated = (PhoneCapability) systemCapabilityManager.getCapability(SystemCapabilityType.PHONE_CALL, null, false);\n+        assertNotNull(phoneCapabilityUpdated);\n+        assertFalse(phoneCapabilityUpdated.getDialNumberEnabled());\n+        assertEquals(phoneCapability, phoneCapabilityUpdated);\n+    }\n \n-\t\tList<DisplayCapability> convertedCaps = (List<DisplayCapability>)systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS);\n-\t\tassertNotNull(convertedCaps);\n-\t\tList<DisplayCapability> testCaps = createDisplayCapabilityList(newLayout.getDisplayCapabilities(), newLayout.getButtonCapabilities(), newLayout.getSoftButtonCapabilities());\n-\t\tassertTrue(Validator.validateDisplayCapabilityList(convertedCaps, testCaps));\n+    @Test\n+    public void testOnSetDisplayLayout() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        OnRPCListener dlRpcListener = iSDL.rpcListeners.get(FunctionID.SET_DISPLAY_LAYOUT.getId()).get(0);\n+        assertNotNull(dlRpcListener);\n \n-\t\tWindowCapability matchWindowCapability = testCaps.get(0).getWindowCapabilities().get(0);\n-\t\tWindowCapability testWindowCapability = systemCapabilityManager.getDefaultMainWindowCapability();\n-\t\tassertTrue(Validator.validateWindowCapability(matchWindowCapability, testWindowCapability));\n-\t\tassertNull(systemCapabilityManager.getWindowCapability(42));\n-\t}\n-\n-\t@Test\n-\tpublic void testManagerBeforeDisplayUpdate() {\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = new SystemCapabilityManager(iSDL);\n-\t\tassertNull(systemCapabilityManager.getDefaultMainWindowCapability());\n-\t\tassertNull(systemCapabilityManager.getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue()));\n-\t\tassertNull(systemCapabilityManager.getWindowCapability(PredefinedWindows.PRIMARY_WIDGET.getValue()));\n-\t}\n-\n-\tprivate class InternalSDLInterface implements ISdl{\n-\t\tprivate final Object RPC_LISTENER_LOCK = new Object();\n-\t\tSparseArray<CopyOnWriteArrayList<OnRPCListener>> rpcListeners = new SparseArray<>();\n-\n-\t\t@Override\n-\t\tpublic void start(){}\n-\n-\t\t@Override\n-\t\tpublic void stop() {}\n-\n-\t\t@Override\n-\t\tpublic boolean isConnected() {return false;\t}\n-\n-\t\t@Override\n-\t\tpublic void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener) {}\n-\n-\t\t@Override\n-\t\tpublic void removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener) {}\n-\n-\t\t@Override\n-\t\tpublic void startVideoService(VideoStreamingParameters parameters, boolean encrypted) {\t}\n-\n-\t\t@Override\n-\t\tpublic void stopVideoService() {}\n-\n-\t\t@Override\n-\t\tpublic void stopAudioService() {}\n-\n-\t\t@Override\n-\t\tpublic void sendRPCRequest(RPCRequest message) {}\n-\n-\t\t@Override\n-\t\tpublic void sendRPC(RPCMessage message) {}\n-\n-\t\t@Override\n-\t\tpublic void sendRequests(List<? extends RPCRequest> rpcs, OnMultipleRequestListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, OnMultipleRequestListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void sendSequentialRPCs(List<? extends RPCMessage> rpcs, OnMultipleRequestListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener) {return false;}\n-\n-\t\t@Override\n-\t\tpublic void addOnRPCRequestListener(FunctionID functionID, OnRPCRequestListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean removeOnRPCRequestListener(FunctionID functionID, OnRPCRequestListener listener) {\n-\t\t\treturn false;\n-\t\t}\n-\t\t@Override\n-\t\tpublic void addOnRPCListener(FunctionID messageId, OnRPCListener listener){\n-\t\t\tsynchronized(RPC_LISTENER_LOCK){\n-\t\t\t\tif(messageId != null && listener != null){\n-\t\t\t\t\tif(rpcListeners.indexOfKey(messageId.getId()) < 0 ){\n-\t\t\t\t\t\trpcListeners.put(messageId.getId(),new CopyOnWriteArrayList<OnRPCListener>());\n-\t\t\t\t\t}\n-\t\t\t\t\trpcListeners.get(messageId.getId()).add(listener);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic boolean removeOnRPCListener(FunctionID messageId, OnRPCListener listener){\n-\t\t\tsynchronized(RPC_LISTENER_LOCK){\n-\t\t\t\tif(rpcListeners!= null\n-\t\t\t\t\t\t&& messageId != null\n-\t\t\t\t\t\t&& listener != null\n-\t\t\t\t\t\t&& rpcListeners.indexOfKey(messageId.getId()) >= 0){\n-\t\t\t\t\treturn rpcListeners.get(messageId.getId()).remove(listener);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Object getCapability(SystemCapabilityType systemCapabilityType){return null;}\n-\n-\t\t@Override\n-\t\tpublic void getCapability(SystemCapabilityType systemCapabilityType, OnSystemCapabilityListener scListener) {\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse() {\n-\t\t\treturn null;\n-\t\t}\n+        SetDisplayLayoutResponse newLayout = new SetDisplayLayoutResponse();\n+        newLayout.setDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES);\n+        newLayout.setButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST);\n+        newLayout.setSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+        newLayout.setPresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES);\n+        newLayout.setSuccess(true);\n+        newLayout.setResultCode(Result.SUCCESS);\n+\n+        dlRpcListener.onReceived(newLayout);\n \n-\t\t@Override\n-\t\tpublic Object getCapability(SystemCapabilityType systemCapabilityType, OnSystemCapabilityListener scListener, boolean forceUpdate) {\n-\t\t\treturn null;\n-\t\t}\n \n-\t\t@Override\n-\t\tpublic SdlMsgVersion getSdlMsgVersion() {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Version getProtocolVersion() {\n-\t\t\treturn new Version(1,0,0);\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic boolean isCapabilitySupported(SystemCapabilityType systemCapabilityType){\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void addOnSystemCapabilityListener(SystemCapabilityType systemCapabilityType, OnSystemCapabilityListener listener) { }\n-\n-\t\t@Override\n-\t\tpublic boolean removeOnSystemCapabilityListener(SystemCapabilityType systemCapabilityType, OnSystemCapabilityListener listener) { return false; }\n-\n-\t\t@Override\n-\t\tpublic boolean isTransportForServiceAvailable(SessionType serviceType) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void startAudioService(boolean isEncrypted, AudioStreamingCodec codec,\n-\t\t\t\t\t\t\t\t\t  AudioStreamingParams params) {}\n-\n-\t\t@Override\n-\t\tpublic IVideoStreamListener startVideoStream(boolean isEncrypted, VideoStreamingParameters parameters){\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic IAudioStreamListener startAudioStream(boolean isEncrypted, AudioStreamingCodec codec,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t AudioStreamingParams params) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void startAudioService(boolean encrypted){}\n-\n-\t\t@Override\n-\t\tpublic void startRPCEncryption() {}\n-\n-\t\t@Override\n-\t\tpublic Taskmaster getTaskmaster() {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n+        DisplayCapabilities appliedCaps = (DisplayCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY, null, false);\n+        assertNotNull(appliedCaps);\n+        assertTrue(Validator.validateDisplayCapabilities(newLayout.getDisplayCapabilities(), appliedCaps));\n+\n+        List<DisplayCapability> convertedCaps = (List<DisplayCapability>) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS, null, false);\n+        assertNotNull(convertedCaps);\n+        List<DisplayCapability> testCaps = createDisplayCapabilityList(newLayout.getDisplayCapabilities(), newLayout.getButtonCapabilities(), newLayout.getSoftButtonCapabilities());\n+        assertTrue(Validator.validateDisplayCapabilityList(convertedCaps, testCaps));\n+\n+        WindowCapability matchWindowCapability = testCaps.get(0).getWindowCapabilities().get(0);\n+        WindowCapability testWindowCapability = systemCapabilityManager.getDefaultMainWindowCapability();\n+        assertTrue(Validator.validateWindowCapability(matchWindowCapability, testWindowCapability));\n+        assertNull(systemCapabilityManager.getWindowCapability(42));\n+    }\n+\n+    @Test\n+    public void testManagerBeforeDisplayUpdate() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = new SystemCapabilityManager(iSDL);\n+        assertNull(systemCapabilityManager.getDefaultMainWindowCapability());\n+        assertNull(systemCapabilityManager.getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue()));\n+        assertNull(systemCapabilityManager.getWindowCapability(PredefinedWindows.PRIMARY_WIDGET.getValue()));\n+    }\n+\n+    private class InternalSDLInterface implements ISdl {\n+        private final Object RPC_LISTENER_LOCK = new Object();\n+        SparseArray<CopyOnWriteArrayList<OnRPCListener>> rpcListeners = new SparseArray<>();\n+\n+        @Override\n+        public void start() {\n+        }\n+\n+        @Override\n+        public void stop() {\n+        }\n+\n+        @Override\n+        public boolean isConnected() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener) {\n+        }\n+\n+        @Override\n+        public void removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener) {\n+        }\n+\n+        @Override\n+        public void startVideoService(VideoStreamingParameters parameters, boolean encrypted, boolean withPendingRestart) {\n+        }\n+\n+        @Override\n+        public void sendRPC(RPCMessage message) {\n+        }\n+\n+        @Override\n+        public void sendRPCs(List<? extends RPCMessage> rpcs, OnMultipleRequestListener listener) {\n+\n+        }\n+\n+        @Override\n+        public void sendSequentialRPCs(List<? extends RPCMessage> rpcs, OnMultipleRequestListener listener) {\n+\n+        }\n+\n+        @Override\n+        public void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener) {\n+\n+        }\n+\n+        @Override\n+        public boolean removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener) {\n+            return false;\n+        }\n+\n+        @Override\n+        public void addOnRPCRequestListener(FunctionID functionID, OnRPCRequestListener listener) {\n+\n+        }\n+\n+        @Override\n+        public boolean removeOnRPCRequestListener(FunctionID functionID, OnRPCRequestListener listener) {\n+            return false;\n+        }\n+\n+        @Override\n+        public void addOnRPCListener(FunctionID messageId, OnRPCListener listener) {\n+            synchronized (RPC_LISTENER_LOCK) {\n+                if (messageId != null && listener != null) {\n+                    if (rpcListeners.indexOfKey(messageId.getId()) < 0) {\n+                        rpcListeners.put(messageId.getId(), new CopyOnWriteArrayList<OnRPCListener>());\n+                    }\n+                    rpcListeners.get(messageId.getId()).add(listener);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public boolean removeOnRPCListener(FunctionID messageId, OnRPCListener listener) {\n+            synchronized (RPC_LISTENER_LOCK) {\n+                if (rpcListeners != null\n+                        && messageId != null\n+                        && listener != null\n+                        && rpcListeners.indexOfKey(messageId.getId()) >= 0) {\n+                    return rpcListeners.get(messageId.getId()).remove(listener);\n+                }\n+            }\n+            return false;\n+        }\n+\n+\n+        @Override\n+        public RegisterAppInterfaceResponse getRegisterAppInterfaceResponse() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SdlMsgVersion getSdlMsgVersion() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Version getProtocolVersion() {\n+            return new Version(1, 0, 0);\n+        }\n+\n+        @Override\n+        public boolean isTransportForServiceAvailable(SessionType serviceType) {\n+            return false;\n+        }\n+\n+        @Override\n+        public void startAudioService(boolean encrypted) {\n+        }\n+\n+        @Override\n+        public void startRPCEncryption() {\n+        }\n+\n+        @Override\n+        public Taskmaster getTaskmaster() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SystemCapabilityManager getSystemCapabilityManager() {\n+            return null;\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAzMDY1MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472030650", "bodyText": "In the testGetVSCapability function around line 221, does a call need to be made to vsCapability.setAdditionalVideoStreamingCapabilities(...)?", "author": "santhanamk", "createdAt": "2020-08-18T09:06:07Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java", "diffHunk": "@@ -365,9 +365,9 @@ public void testGetCapabilityHmiNone() {\n \t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n \t\tVideoStreamingCapability retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n \t\tassertNull(retrievedCapability);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));", "originalCommit": "2c1422192d1b4ef1dca0ab74f30a714f69a4d9ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2ODQ0NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473368444", "bodyText": "In the testGetVSCapability function around line 221, does a call need to be made to vsCapability.setAdditionalVideoStreamingCapabilities(...)?\n\n@kostyaBoss I still see this issue.  In the testGetVSCapability function around line 221, does a call need to be made to vsCapability.setAdditionalVideoStreamingCapabilities(...)?", "author": "santhanamk", "createdAt": "2020-08-19T22:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAzMDY1MA=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java\nindex 9b5d233d6..5d87795ca 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java\n\n@@ -89,1012 +85,981 @@ import static org.mockito.Mockito.when;\n \n @RunWith(AndroidJUnit4.class)\n public class SystemCapabilityManagerTests {\n-\tpublic static final String TAG = \"SystemCapabilityManagerTests\";\n-\tpublic static SystemCapabilityManager systemCapabilityManager;\n-\tprivate SystemCapability systemCapability;\n-\tprivate VideoStreamingCapability videoStreamingCapability;\n-\n-\t@Before\n-\tpublic void setUp() throws Exception{\n-\n-\t\tsystemCapability = new SystemCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\tvideoStreamingCapability = new VideoStreamingCapability();\n-\t\tvideoStreamingCapability.setMaxBitrate(TestValues.GENERAL_INT);\n-\t\tvideoStreamingCapability.setPreferredResolution(TestValues.GENERAL_IMAGERESOLUTION);\n-\t\tvideoStreamingCapability.setSupportedFormats(TestValues.GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\t}\n-\n-\tpublic SystemCapabilityManager createSampleManager(){\n-\t\treturn createSampleManager(new InternalSDLInterface());\n-\t}\n-\n-\tpublic SystemCapabilityManager createSampleManager(InternalSDLInterface iSdl){\n-\t\tSystemCapabilityManager systemCapabilityManager = new SystemCapabilityManager(iSdl);\n-\n-\t\tRegisterAppInterfaceResponse raiResponse = new RegisterAppInterfaceResponse();\n-\n-\t\traiResponse.setHmiCapabilities(TestValues.GENERAL_HMICAPABILITIES);\n-\t\traiResponse.setDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES);\n-\t\traiResponse.setAudioPassThruCapabilities(TestValues.GENERAL_AUDIOPASSTHRUCAPABILITIES_LIST);\n-\t\traiResponse.setButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\traiResponse.setHmiZoneCapabilities(TestValues.GENERAL_HMIZONECAPABILITIES_LIST);\n-\t\traiResponse.setPresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES);\n-\t\traiResponse.setSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n-\t\traiResponse.setSpeechCapabilities(TestValues.GENERAL_SPEECHCAPABILITIES_LIST);\n-\t\traiResponse.setPrerecordedSpeech(TestValues.GENERAL_PRERECORDEDSPEECH_LIST);\n-\t\traiResponse.setSuccess(true);\n-\n-\t\tsystemCapabilityManager.parseRAIResponse(raiResponse);\n-\t\treturn systemCapabilityManager;\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n-\t\tWindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n-\n-\t\tDisplayCapability displayCapability = new DisplayCapability();\n-\t\tdisplayCapability.setDisplayName(display != null ? display.getDisplayName() : null);\n-\t\tdisplayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n-\n-\t\tWindowCapability defaultWindowCapability = new WindowCapability();\n-\t\tdefaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t\tdefaultWindowCapability.setButtonCapabilities(button);\n-\t\tdefaultWindowCapability.setSoftButtonCapabilities(softButton);\n-\n-\t\tif (display == null) {\n-\t\t\tdefaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n-\t\t\tdefaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n-\t\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\t\treturn Collections.singletonList(displayCapability);\n-\t\t}\n-\n-\t\tdefaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n-\t\tdefaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n-\t\tdefaultWindowCapability.setTextFields(display.getTextFields());\n-\t\tdefaultWindowCapability.setImageFields(display.getImageFields());\n-\t\tArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n-\t\timageTypeSupported.add(ImageType.STATIC);\n-\t\tif (display.getGraphicSupported()) {\n-\t\t\timageTypeSupported.add(ImageType.DYNAMIC);\n-\t\t}\n-\t\tdefaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n-\n-\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\treturn Collections.singletonList(displayCapability);\n-\t}\n-\n-\tprivate DisplayCapabilities createDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n-\t\tDisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n-\t\tconvertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n-\t\tconvertedCapabilities.setDisplayName(displayName);\n-\t\tconvertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n-\t\tconvertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n-\t\tconvertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n-\t\tconvertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n-\t\tconvertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but can be empty\n-\t\tconvertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported().contains(ImageType.DYNAMIC));\n-\n-\t\treturn convertedCapabilities;\n-\t}\n-\n-\t@Test\n-\tpublic void testParseRAI() {\n-\t\tsystemCapabilityManager = createSampleManager();\n-\n-\t\tList<DisplayCapability> displayCapabilityList = createDisplayCapabilityList(TestValues.GENERAL_DISPLAYCAPABILITIES, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateDisplayCapabilityList(displayCapabilityList, (List<DisplayCapability>) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateHMICapabilities(TestValues.GENERAL_HMICAPABILITIES, (HMICapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.HMI)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES, (DisplayCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateAudioPassThruCapabilities(TestValues.GENERAL_AUDIOPASSTHRUCAPABILITIES_LIST, (List<AudioPassThruCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.AUDIO_PASSTHROUGH)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST, (List<ButtonCapabilities> )systemCapabilityManager.getCapability(SystemCapabilityType.BUTTON)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateHMIZoneCapabilities(TestValues.GENERAL_HMIZONECAPABILITIES_LIST, (List<HmiZoneCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.HMI_ZONE)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validatePresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES, (PresetBankCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.PRESET_BANK)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST, (List<SoftButtonCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.SOFTBUTTON)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validateSpeechCapabilities(TestValues.GENERAL_SPEECHCAPABILITIES_LIST, (List<SpeechCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.SPEECH)));\n-\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\tValidator.validatePreRecordedSpeechCapabilities(TestValues.GENERAL_PRERECORDEDSPEECH_LIST, (List<PrerecordedSpeech>) systemCapabilityManager.getCapability(SystemCapabilityType.PRERECORDED_SPEECH)));\n-\n-\t}\n-\n-\t@Test\n-\tpublic void testNullDisplayCapabilitiesEnablesAllTextAndImageFields() {\n-\t\tList<DisplayCapability> displayCapabilityList = createDisplayCapabilityList(null, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n-\t\tassertEquals(displayCapabilityList.get(0).getWindowCapabilities().get(0).getTextFields().size(), 29);\n-\t\tassertEquals(displayCapabilityList.get(0).getWindowCapabilities().get(0).getImageFields().size(), 14);\n-\t}\n-\n-\t@Test\n-\tpublic void testGetVSCapability(){\n-\t\tVideoStreamingCapability vsCapability = new VideoStreamingCapability();\n-\t\tvsCapability.setMaxBitrate(TestValues.GENERAL_INT);\n-\t\tvsCapability.setPreferredResolution(TestValues.GENERAL_IMAGERESOLUTION);\n-\t\tvsCapability.setSupportedFormats(TestValues.GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\n-\t\tSystemCapability cap = new SystemCapability();\n-\t\tcap.setSystemCapabilityType(SystemCapabilityType.VIDEO_STREAMING);\n-\t\tcap.setCapabilityForType(SystemCapabilityType.VIDEO_STREAMING, vsCapability);\n-\n-\t\tfinal SystemCapability referenceCapability = cap;\n-\n-\t\tsystemCapabilityManager = new SystemCapabilityManager(new InternalSDLInterface() {\n-\t\t\t@Override\n-\t\t\tpublic void sendRPC(RPCMessage message) {\n-\t\t\t\tGetSystemCapabilityResponse response = new GetSystemCapabilityResponse();\n-\t\t\t\tresponse.setSystemCapability(referenceCapability);\n-\t\t\t\tresponse.setSuccess(true);\n-\t\t\t\tif (message instanceof RPCRequest) {\n-\t\t\t\t\tRPCRequest request = (RPCRequest) message;\n-\t\t\t\t\trequest.getOnRPCResponseListener().onResponse(CorrelationIdGenerator.generateId(), response);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void addOnRPCListener(FunctionID messageId, OnRPCListener listener) {\n-\t\t\t\tlistener.onReceived(new OnHMIStatus(HMILevel.HMI_FULL, AudioStreamingState.NOT_AUDIBLE, SystemContext.SYSCTXT_MAIN));\n-\t\t\t}\n-\t\t});\n-\n-\t\tsystemCapabilityManager.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\tassertTrue(TestValues.TRUE,\n-\t\t\t\t\t\tValidator.validateVideoStreamingCapability(\n-\t\t\t\t\t\t\t\t(VideoStreamingCapability) referenceCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING),\n-\t\t\t\t\t\t\t\t(VideoStreamingCapability) capability));\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tassertTrue(false);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\tprivate Answer<Void> createOnHMIStatusAnswer(final HMILevel hmiLevel){\n-\t\tAnswer<Void> onHMIStatusAnswer = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tOnRPCListener onHMIStatusListener = (OnRPCListener) args[1];\n-\t\t\t\tOnHMIStatus onHMIStatusFakeNotification = new OnHMIStatus();\n-\t\t\t\tonHMIStatusFakeNotification.setHmiLevel(hmiLevel);\n-\t\t\t\tonHMIStatusListener.onReceived(onHMIStatusFakeNotification);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\t\treturn onHMIStatusAnswer;\n-\t}\n-\n-\tprivate Answer<Void> createOnSendGetSystemCapabilityAnswer (final boolean success, final Boolean subscribe) {\n-\t\tAnswer<Void> onSendGetSystemCapabilityAnswer = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tGetSystemCapability getSystemCapability = (GetSystemCapability) args[0];\n-\t\t\t\tif (subscribe != null) {\n-\t\t\t\t\tassertEquals(subscribe, getSystemCapability.getSubscribe());\n-\t\t\t\t}\n-\t\t\t\tGetSystemCapabilityResponse response;\n-\t\t\t\tif (success) {\n-\t\t\t\t\tresponse = new GetSystemCapabilityResponse(Result.SUCCESS, true);\n-\t\t\t\t} else {\n-\t\t\t\t\tresponse = new GetSystemCapabilityResponse(Result.REJECTED, false);\n-\t\t\t\t}\n-\t\t\t\tresponse.setSystemCapability(systemCapability);\n-\t\t\t\tgetSystemCapability.getOnRPCResponseListener().onResponse(CorrelationIdGenerator.generateId(), response);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\t\treturn onSendGetSystemCapabilityAnswer;\n-\t}\n-\n-\t@Test\n-\tpublic void testGetCapability() {\n-\t\tISdl internalInterface;\n-\t\tSystemCapabilityManager scm;\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener;\n-\t\tVideoStreamingCapability retrievedCapability;\n-\n-\n-\t\t// Test case 1 (capability not cached, listener not null, forceUpdate false)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n-\t\tretrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n-\t\tassertNull(retrievedCapability);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Test case 2 (capability cached, listener not null, forceUpdate true)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\t\tretrievedCapability =  (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, true);\n-\t\tassertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Test case 3 (capability cached, listener null, forceUpdate true)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = null;\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\t\tretrievedCapability =  (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, true);\n-\t\tassertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\n-\n-\t\t// Test case 4 (capability cached, listener null, forceUpdate false)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = null;\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\t\tretrievedCapability =  (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n-\t\tassertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testGetCapabilityHmiNone() {\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_NONE)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n-\t\tVideoStreamingCapability retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n-\t\tassertNull(retrievedCapability);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener, times(0)).onError(any(String.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerWithSubscriptionsSupportedAndCapabilityCached() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(6, 0); // This version supports capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n-\n-\n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should go out with subscribe=true\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\n-\n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\n-\n-\t\t// Remove listener3\n-\t\t// When the last listener is removed, GetSystemCapability request should go out with subscribe=false\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerWithSubscriptionsSupportedAndCapabilityNotCached() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(6, 0); // This version supports capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n-\n-\n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should go out with subscribe=true\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n-\n-\n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\n-\n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+    public static final String TAG = \"SystemCapabilityManagerTests\";\n+    public static SystemCapabilityManager systemCapabilityManager;\n+    private SystemCapability systemCapability;\n+    private VideoStreamingCapability videoStreamingCapability;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+\n+        systemCapability = new SystemCapability(SystemCapabilityType.VIDEO_STREAMING);\n+        videoStreamingCapability = new VideoStreamingCapability();\n+        videoStreamingCapability.setMaxBitrate(TestValues.GENERAL_INT);\n+        videoStreamingCapability.setPreferredResolution(TestValues.GENERAL_IMAGERESOLUTION);\n+        videoStreamingCapability.setSupportedFormats(TestValues.GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        videoStreamingCapability.setAdditionalVideoStreamingCapabilities(TestValues.GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+    }\n+\n+    public SystemCapabilityManager createSampleManager() {\n+        return createSampleManager(new InternalSDLInterface());\n+    }\n+\n+    public SystemCapabilityManager createSampleManager(InternalSDLInterface iSdl) {\n+        SystemCapabilityManager systemCapabilityManager = new SystemCapabilityManager(iSdl);\n+\n+        RegisterAppInterfaceResponse raiResponse = new RegisterAppInterfaceResponse();\n+\n+        raiResponse.setHmiCapabilities(TestValues.GENERAL_HMICAPABILITIES);\n+        raiResponse.setDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES);\n+        raiResponse.setAudioPassThruCapabilities(TestValues.GENERAL_AUDIOPASSTHRUCAPABILITIES_LIST);\n+        raiResponse.setButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST);\n+        raiResponse.setHmiZoneCapabilities(TestValues.GENERAL_HMIZONECAPABILITIES_LIST);\n+        raiResponse.setPresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES);\n+        raiResponse.setSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+        raiResponse.setSpeechCapabilities(TestValues.GENERAL_SPEECHCAPABILITIES_LIST);\n+        raiResponse.setPrerecordedSpeech(TestValues.GENERAL_PRERECORDEDSPEECH_LIST);\n+        raiResponse.setSuccess(true);\n+\n+        systemCapabilityManager.parseRAIResponse(raiResponse);\n+        return systemCapabilityManager;\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n+        WindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n+\n+        DisplayCapability displayCapability = new DisplayCapability();\n+        displayCapability.setDisplayName(display != null ? display.getDisplayName() : null);\n+        displayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n+\n+        WindowCapability defaultWindowCapability = new WindowCapability();\n+        defaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+        defaultWindowCapability.setButtonCapabilities(button);\n+        defaultWindowCapability.setSoftButtonCapabilities(softButton);\n+\n+        if (display == null) {\n+            defaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n+            defaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n+            displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+            return Collections.singletonList(displayCapability);\n+        }\n+\n+        defaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n+        defaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n+        defaultWindowCapability.setTextFields(display.getTextFields());\n+        defaultWindowCapability.setImageFields(display.getImageFields());\n+        ArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n+        imageTypeSupported.add(ImageType.STATIC);\n+        if (display.getGraphicSupported()) {\n+            imageTypeSupported.add(ImageType.DYNAMIC);\n+        }\n+        defaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n+\n+        displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+        return Collections.singletonList(displayCapability);\n+    }\n+\n+    private DisplayCapabilities createDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n+        DisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n+        convertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n+        convertedCapabilities.setDisplayName(displayName);\n+        convertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n+        convertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n+        convertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n+        convertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n+        convertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but can be empty\n+        convertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported().contains(ImageType.DYNAMIC));\n+\n+        return convertedCapabilities;\n+    }\n+\n+    @Test\n+    public void testParseRAI() {\n+        systemCapabilityManager = createSampleManager();\n+\n+        List<DisplayCapability> displayCapabilityList = createDisplayCapabilityList(TestValues.GENERAL_DISPLAYCAPABILITIES, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateDisplayCapabilityList(displayCapabilityList, (List<DisplayCapability>) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateHMICapabilities(TestValues.GENERAL_HMICAPABILITIES, (HMICapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.HMI, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES, (DisplayCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateAudioPassThruCapabilities(TestValues.GENERAL_AUDIOPASSTHRUCAPABILITIES_LIST, (List<AudioPassThruCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST, (List<ButtonCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.BUTTON, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateHMIZoneCapabilities(TestValues.GENERAL_HMIZONECAPABILITIES_LIST, (List<HmiZoneCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.HMI_ZONE, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validatePresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES, (PresetBankCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.PRESET_BANK, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST, (List<SoftButtonCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.SOFTBUTTON, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validateSpeechCapabilities(TestValues.GENERAL_SPEECHCAPABILITIES_LIST, (List<SpeechCapabilities>) systemCapabilityManager.getCapability(SystemCapabilityType.SPEECH, null, false)));\n+        assertTrue(TestValues.TRUE,\n+                Validator.validatePreRecordedSpeechCapabilities(TestValues.GENERAL_PRERECORDEDSPEECH_LIST, (List<PrerecordedSpeech>) systemCapabilityManager.getCapability(SystemCapabilityType.PRERECORDED_SPEECH, null, false)));\n+\n+    }\n+\n+    @Test\n+    public void testNullDisplayCapabilitiesEnablesAllTextAndImageFields() {\n+        List<DisplayCapability> displayCapabilityList = createDisplayCapabilityList(null, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+        assertEquals(displayCapabilityList.get(0).getWindowCapabilities().get(0).getTextFields().size(), 32);\n+        assertEquals(displayCapabilityList.get(0).getWindowCapabilities().get(0).getImageFields().size(), 16);\n+    }\n+\n+    @Test\n+    public void testGetVSCapability() {\n+        VideoStreamingCapability vsCapability = new VideoStreamingCapability();\n+        vsCapability.setMaxBitrate(TestValues.GENERAL_INT);\n+        vsCapability.setPreferredResolution(TestValues.GENERAL_IMAGERESOLUTION);\n+        vsCapability.setAdditionalVideoStreamingCapabilities(TestValues.GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+        vsCapability.setSupportedFormats(TestValues.GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+\n+        SystemCapability cap = new SystemCapability();\n+        cap.setSystemCapabilityType(SystemCapabilityType.VIDEO_STREAMING);\n+        cap.setCapabilityForType(SystemCapabilityType.VIDEO_STREAMING, vsCapability);\n+\n+        final SystemCapability referenceCapability = cap;\n+\n+        systemCapabilityManager = new SystemCapabilityManager(new InternalSDLInterface() {\n+            @Override\n+            public void sendRPC(RPCMessage message) {\n+                GetSystemCapabilityResponse response = new GetSystemCapabilityResponse();\n+                response.setSystemCapability(referenceCapability);\n+                response.setSuccess(true);\n+                if (message instanceof RPCRequest) {\n+                    RPCRequest request = (RPCRequest) message;\n+                    request.getOnRPCResponseListener().onResponse(CorrelationIdGenerator.generateId(), response);\n+                }\n+            }\n+\n+            @Override\n+            public void addOnRPCListener(FunctionID messageId, OnRPCListener listener) {\n+                listener.onReceived(new OnHMIStatus(HMILevel.HMI_FULL, AudioStreamingState.NOT_AUDIBLE, SystemContext.SYSCTXT_MAIN));\n+            }\n+        });\n+\n+        systemCapabilityManager.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+            @Override\n+            public void onCapabilityRetrieved(Object capability) {\n+                assertTrue(TestValues.TRUE,\n+                        Validator.validateVideoStreamingCapability(\n+                                (VideoStreamingCapability) referenceCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING),\n+                                (VideoStreamingCapability) capability));\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                assertTrue(false);\n+            }\n+        }, false);\n+    }\n+\n+    private Answer<Void> createOnHMIStatusAnswer(final HMILevel hmiLevel) {\n+        Answer<Void> onHMIStatusAnswer = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnRPCListener onHMIStatusListener = (OnRPCListener) args[1];\n+                OnHMIStatus onHMIStatusFakeNotification = new OnHMIStatus();\n+                onHMIStatusFakeNotification.setHmiLevel(hmiLevel);\n+                onHMIStatusListener.onReceived(onHMIStatusFakeNotification);\n+                return null;\n+            }\n+        };\n+        return onHMIStatusAnswer;\n+    }\n+\n+    private Answer<Void> createOnSendGetSystemCapabilityAnswer(final boolean success, final Boolean subscribe) {\n+        Answer<Void> onSendGetSystemCapabilityAnswer = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                GetSystemCapability getSystemCapability = (GetSystemCapability) args[0];\n+                if (subscribe != null) {\n+                    assertEquals(subscribe, getSystemCapability.getSubscribe());\n+                }\n+                GetSystemCapabilityResponse response;\n+                if (success) {\n+                    response = new GetSystemCapabilityResponse(Result.SUCCESS, true);\n+                } else {\n+                    response = new GetSystemCapabilityResponse(Result.REJECTED, false);\n+                }\n+                response.setSystemCapability(systemCapability);\n+                getSystemCapability.getOnRPCResponseListener().onResponse(CorrelationIdGenerator.generateId(), response);\n+                return null;\n+            }\n+        };\n+        return onSendGetSystemCapabilityAnswer;\n+    }\n+\n+    @Test\n+    public void testGetCapability() {\n+        ISdl internalInterface;\n+        SystemCapabilityManager scm;\n+        OnSystemCapabilityListener onSystemCapabilityListener;\n+        VideoStreamingCapability retrievedCapability;\n+\n+\n+        // Test case 1 (capability not cached, listener not null, forceUpdate false)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n+        retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n+        assertNull(retrievedCapability);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Test case 2 (capability cached, listener not null, forceUpdate true)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+        retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, true);\n+        assertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Test case 3 (capability cached, listener null, forceUpdate true)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = null;\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+        retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, true);\n+        assertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+\n+\n+        // Test case 4 (capability cached, listener null, forceUpdate false)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = null;\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+        retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n+        assertTrue(TestValues.TRUE, Validator.validateVideoStreamingCapability((VideoStreamingCapability) systemCapability.getCapabilityForType(SystemCapabilityType.VIDEO_STREAMING), retrievedCapability));\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+    }\n+\n+    @Test\n+    public void testGetCapabilityHmiNone() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_NONE)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        OnSystemCapabilityListener onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n+        VideoStreamingCapability retrievedCapability = (VideoStreamingCapability) scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener, false);\n+        assertNull(retrievedCapability);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener, times(0)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener, times(1)).onError(any(String.class));\n+    }\n+\n+    @Test\n+    public void testAddOnSystemCapabilityListenerWithSubscriptionsSupportedAndCapabilityCached() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(6, 0); // This version supports capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n+\n+\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should go out with subscribe=true\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+\n+\n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+\n+\n+        // Remove listener3\n+        // When the last listener is removed, GetSystemCapability request should go out with subscribe=false\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+    }\n+\n+    @Test\n+    public void testAddOnSystemCapabilityListenerWithSubscriptionsSupportedAndCapabilityNotCached() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(6, 0); // This version supports capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n+\n+\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should go out with subscribe=true\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n+\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener3\n-\t\t// When the last listener is removed, GetSystemCapability request should go out with subscribe=false\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n-\t}\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerWithSubscriptionsNotSupportedAndCapabilityCached() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n \n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n \n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should not go out because subscription is not supported and the capability is cached\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n \n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener3\n+        // When the last listener is removed, GetSystemCapability request should go out with subscribe=false\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n+    }\n \n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+    @Test\n+    public void testAddOnSystemCapabilityListenerWithSubscriptionsNotSupportedAndCapabilityCached() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n \n \n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should not go out because subscription is not supported and the capability is cached\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, true)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener3\n-\t\t// When the last listener is removed, GetSystemCapability request should not go out because subscription is not supported\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t}\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerWithSubscriptionsNotSupportedAndCapabilityNotCached() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n \n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n \n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should out because because capability is not cached\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n \n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener3\n+        // When the last listener is removed, GetSystemCapability request should not go out because subscription is not supported\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+    }\n \n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+    @Test\n+    public void testAddOnSystemCapabilityListenerWithSubscriptionsNotSupportedAndCapabilityNotCached() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, null);\n \n \n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should out because because capability is not cached\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener3\n-\t\t// When the last listener is removed, GetSystemCapability request should not go out because subscription is not supported\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t}\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n-\t@Test\n-\tpublic void testAddOnSystemCapabilityListenerThenGetCapabilityWhenSubscriptionsAreNotSupported() {\n-\t\tSdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n-\t\tsdlMsgVersion.setPatchVersion(0);\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\twhen(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n-\t\tSystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n-\t\tscm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n \n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n \n-\t\t// Add listener1\n-\t\t// When the first listener is added, GetSystemCapability request should go out with subscribe=false\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n \n-\t\t// Get Capability (should notify listener1 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(2)).onCapabilityRetrieved(any(Object.class));\n \n+        // Remove listener3\n+        // When the last listener is removed, GetSystemCapability request should not go out because subscription is not supported\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n+    }\n \n-\t\t// Add listener2\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n-\t\tverify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+    @Test\n+    public void testAddOnSystemCapabilityListenerThenGetCapabilityWhenSubscriptionsAreNotSupported() {\n+        SdlMsgVersion sdlMsgVersion = new SdlMsgVersion(5, 0); // This version doesn't support capability subscriptions\n+        sdlMsgVersion.setPatchVersion(0);\n+        ISdl internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        when(internalInterface.getSdlMsgVersion()).thenReturn(sdlMsgVersion);\n+        SystemCapabilityManager scm = new SystemCapabilityManager(internalInterface);\n+        scm.setCapability(SystemCapabilityType.VIDEO_STREAMING, videoStreamingCapability);\n \n \n-\t\t// Get Capability (should notify listener1 & listener2 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(2)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(3)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(2)).onCapabilityRetrieved(any(Object.class));\n+        // Add listener1\n+        // When the first listener is added, GetSystemCapability request should go out with subscribe=false\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, false)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Add listener3\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+        // Get Capability (should notify listener1 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Get Capability (should notify listener1 & listener2 & listener3 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(3)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(3)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener3, times(2)).onCapabilityRetrieved(any(Object.class));\n+        // Add listener2\n+        OnSystemCapabilityListener onSystemCapabilityListener2 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener1\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n+        // Get Capability (should notify listener1 & listener2 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Get Capability (should notify listener2 & listener3 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(4)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener3, times(3)).onCapabilityRetrieved(any(Object.class));\n+        // Add listener3\n+        OnSystemCapabilityListener onSystemCapabilityListener3 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Remove listener2\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n+        // Get Capability (should notify listener1 & listener2 & listener3 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Get Capability (should notify listener3 again)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(5)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener3, times(4)).onCapabilityRetrieved(any(Object.class));\n+        // Remove listener1\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener1);\n \n \n-\t\t// Remove listener3\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n-\t\tverify(internalInterface, times(5)).sendRPC(any(GetSystemCapability.class));\n+        // Get Capability (should notify listener2 & listener3 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Get Capability (should not notify any listener again because they are all removed)\n-\t\tscm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n-\t\tverify(internalInterface, times(6)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener2, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener3, times(4)).onCapabilityRetrieved(any(Object.class));\n-\t}\n+        // Remove listener2\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener2);\n \n-\t@Test\n-\tpublic void testGetAndAddListenerForDisplaysCapability() {\n-\t\tISdl internalInterface;\n-\t\tSystemCapabilityManager scm;\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener;\n-\t\tDisplayCapabilities retrievedCapability;\n-\n-\n-\t\t// Test case 1 (capability cached, listener not null, forceUpdate true)\n-\t\tinternalInterface = mock(ISdl.class);\n-\t\tdoAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n-\t\tscm = new SystemCapabilityManager(internalInterface);\n-\t\tonSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n-\t\tdoAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n-\t\tscm.setCapability(SystemCapabilityType.DISPLAYS, new DisplayCapabilities());\n-\t\tretrievedCapability = (DisplayCapabilities) scm.getCapability(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener, true);\n-\t\tassertNotNull(retrievedCapability);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n-\t\tverify(onSystemCapabilityListener, times(0)).onError(any(String.class));\n \n-\n-\t\t// Test case 2 (Add listener)\n-\t\t// When the first DISPLAYS listener is added, GetSystemCapability request should not go out\n-\t\tOnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n-\t\tscm.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t\tverify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        // Get Capability (should notify listener3 again)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n \n \n-\t\t// Test case 3 (Remove listener)\n-\t\t// When the last DISPLAYS listener is removed, GetSystemCapability request should not go out\n-\t\tscm.removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener1);\n-\t\tverify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n-\t}\n-\n-\t@Test\n-\tpublic void testListConversion(){\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager();\n-\t\tObject capability = systemCapabilityManager.getCapability(SystemCapabilityType.SOFTBUTTON);\n-\t\tassertNotNull(capability);\n-\t\tList<SoftButtonCapabilities> list = SystemCapabilityManager.convertToList(capability, SoftButtonCapabilities.class);\n-\t\tassertNotNull(list);\n-\t}\n-\n-\t@Test\n-\tpublic void testFalsePositive(){\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager();\n-\t\tsystemCapabilityManager.setCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, null);\n-\t\tassertFalse(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.AUDIO_PASSTHROUGH));\n-\t}\n-\n-\t@Test\n-\tpublic void testOnSystemCapabilityUpdateWithNoExistingCap(){\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tOnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n-\t\tassertNotNull(scmRpcListener);\n-\n-\t\tassertNull(systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES));\n+        // Remove listener3\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, onSystemCapabilityListener3);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH THE SCM */\n-\t\tAppServiceCapability addServiceID = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"test\", \"3453\", true, null);\n-\t\tAppServicesCapabilities serviceIdASC = new AppServicesCapabilities();\n-\t\tserviceIdASC.setAppServices(Collections.singletonList(addServiceID));\n \n-\t\tSystemCapability systemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, serviceIdASC);\n-\n-\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        // Get Capability (should not notify any listener again because they are all removed)\n+        scm.getCapability(SystemCapabilityType.VIDEO_STREAMING, null, true);\n+        verify(internalInterface, times(1)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener2, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener3, times(1)).onCapabilityRetrieved(any(Object.class));\n+    }\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+    @Test\n+    public void testGetAndAddListenerForDisplaysCapability() {\n+        ISdl internalInterface;\n+        SystemCapabilityManager scm;\n+        OnSystemCapabilityListener onSystemCapabilityListener;\n+        DisplayCapabilities retrievedCapability;\n+\n+\n+        // Test case 1 (capability cached, listener not null, forceUpdate true)\n+        internalInterface = mock(ISdl.class);\n+        doAnswer(createOnHMIStatusAnswer(HMILevel.HMI_FULL)).when(internalInterface).addOnRPCListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCListener.class));\n+        scm = new SystemCapabilityManager(internalInterface);\n+        onSystemCapabilityListener = mock(OnSystemCapabilityListener.class);\n+        doAnswer(createOnSendGetSystemCapabilityAnswer(true, null)).when(internalInterface).sendRPC(any(GetSystemCapability.class));\n+        scm.setCapability(SystemCapabilityType.DISPLAYS, new DisplayCapabilities());\n+        retrievedCapability = (DisplayCapabilities) scm.getCapability(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener, true);\n+        assertNotNull(retrievedCapability);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener, times(1)).onCapabilityRetrieved(any(Object.class));\n+        verify(onSystemCapabilityListener, times(0)).onError(any(String.class));\n \n-\t\tassertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES));\n-\t}\n-\n-\t@Test\n-\tpublic void testOnSystemCapabilityUpdatedForDISPLAYS() {\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tOnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n-\t\tassertNotNull(scmRpcListener);\n \n-\t\tassertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS));\n-\t\tassertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY));\n-\n-\t\tList<DisplayCapability> newCaps = createDisplayCapabilityList(TestValues.GENERAL_DISPLAYCAPABILITIES, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);;\n-\n-\t\tSystemCapability systemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.DISPLAYS);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.DISPLAYS, newCaps);\n-\n-\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n-\n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        // Test case 2 (Add listener)\n+        // When the first DISPLAYS listener is added, GetSystemCapability request should not go out\n+        OnSystemCapabilityListener onSystemCapabilityListener1 = mock(OnSystemCapabilityListener.class);\n+        scm.addOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+        verify(onSystemCapabilityListener1, times(1)).onCapabilityRetrieved(any(Object.class));\n+\n \n-\t\tList<DisplayCapability> appliedCaps = (List<DisplayCapability>)systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS);\n-\t\tassertNotNull(appliedCaps);\n-\t\tassertTrue(Validator.validateDisplayCapabilityList(newCaps, appliedCaps));\n-\n-\t\tDisplayCapabilities appliedConvertedCaps = (DisplayCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY);\n-\t\tassertNotNull(appliedConvertedCaps);\n-\t\tDisplayCapabilities testConvertedCaps = createDisplayCapabilities(newCaps.get(0).getDisplayName(), newCaps.get(0).getWindowCapabilities().get(0));\n-\t\tassertTrue(Validator.validateDisplayCapabilities(appliedConvertedCaps, testConvertedCaps));\n-\t}\n-\n-\t@Test\n-\tpublic void testOnSystemCapabilityUpdated(){\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tString baseName = \"NavTest\", baseID = \"37F98053AE\";\n-\t\tAppServiceCapability capability1 = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, baseName, null, true, null);\n+        // Test case 3 (Remove listener)\n+        // When the last DISPLAYS listener is removed, GetSystemCapability request should not go out\n+        scm.removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onSystemCapabilityListener1);\n+        verify(internalInterface, times(0)).sendRPC(any(GetSystemCapability.class));\n+    }\n+\n+    @Test\n+    public void testListConversion() {\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager();\n+        Object capability = systemCapabilityManager.getCapability(SystemCapabilityType.SOFTBUTTON, null, false);\n+        assertNotNull(capability);\n+        List<SoftButtonCapabilities> list = SystemCapabilityManager.convertToList(capability, SoftButtonCapabilities.class);\n+        assertNotNull(list);\n+    }\n+\n+    @Test\n+    public void testFalsePositive() {\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager();\n+        systemCapabilityManager.setCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, null);\n+        assertFalse(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.AUDIO_PASSTHROUGH));\n+    }\n+\n+    @Test\n+    public void testOnSystemCapabilityUpdateWithNoExistingCap() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        OnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n+        assertNotNull(scmRpcListener);\n+\n+        assertNull(systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false));\n \n-\t\tAppServicesCapabilities appServicesCapabilities = new AppServicesCapabilities();\n-\t\tappServicesCapabilities.setAppServices(Collections.singletonList(capability1));\n+        /* PERFORM A NOTIFICATION SEND THROUGH THE SCM */\n+        AppServiceCapability addServiceID = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"test\", \"3453\", true, null);\n+        AppServicesCapabilities serviceIdASC = new AppServicesCapabilities();\n+        serviceIdASC.setAppServices(Collections.singletonList(addServiceID));\n \n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tassertNotNull(iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()));\n-\t\tOnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n-\t\tassertNotNull(scmRpcListener);\n+        SystemCapability systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, serviceIdASC);\n+\n+        OnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\t/* CONFIRM THE CAP DOESN'T EXIST IN SCM */\n-\t\tAppServicesCapabilities cachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNull(cachedCap);\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\t/* ADD THE CAP IN SCM */\n-\t\tsystemCapabilityManager.setCapability(SystemCapabilityType.APP_SERVICES, appServicesCapabilities);\n-\t\t/* CONFIRM THE CAP DOES EXIST IN SCM */\n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n-\t\t/* CONFIRM THE CAP IN SCM EQUALS ORIGINAL*/\n-\t\tassertEquals(cachedCap, appServicesCapabilities);\n-\t\tassertNull(cachedCap.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID());\n+        assertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false));\n+    }\n+\n+    @Test\n+    public void testOnSystemCapabilityUpdatedForDISPLAYS() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        OnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n+        assertNotNull(scmRpcListener);\n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH THE SCM */\n-\t\tAppServiceCapability addServiceID = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, baseName, baseID, true, null);\n-\t\tAppServicesCapabilities serviceIdASC = new AppServicesCapabilities();\n-\t\tserviceIdASC.setAppServices(Collections.singletonList(addServiceID));\n+        assertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS, null, false));\n+        assertNotNull(systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY, null, false));\n+\n+        List<DisplayCapability> newCaps = createDisplayCapabilityList(TestValues.GENERAL_DISPLAYCAPABILITIES, TestValues.GENERAL_BUTTONCAPABILITIES_LIST, TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+\n+        SystemCapability systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.DISPLAYS);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.DISPLAYS, newCaps);\n+\n+        OnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tSystemCapability systemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, serviceIdASC);\n+        List<DisplayCapability> appliedCaps = (List<DisplayCapability>) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS, null, false);\n+        assertNotNull(appliedCaps);\n+        assertTrue(Validator.validateDisplayCapabilityList(newCaps, appliedCaps));\n+\n+        DisplayCapabilities appliedConvertedCaps = (DisplayCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY, null, false);\n+        assertNotNull(appliedConvertedCaps);\n+        DisplayCapabilities testConvertedCaps = createDisplayCapabilities(newCaps.get(0).getDisplayName(), newCaps.get(0).getWindowCapabilities().get(0));\n+        assertTrue(Validator.validateDisplayCapabilities(appliedConvertedCaps, testConvertedCaps));\n+    }\n+\n+    @Test\n+    public void testOnSystemCapabilityUpdated() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        String baseName = \"NavTest\", baseID = \"37F98053AE\";\n+        AppServiceCapability capability1 = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, baseName, null, true, null);\n \n-\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        AppServicesCapabilities appServicesCapabilities = new AppServicesCapabilities();\n+        appServicesCapabilities.setAppServices(Collections.singletonList(capability1));\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        assertNotNull(iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()));\n+        OnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n+        assertNotNull(scmRpcListener);\n \n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n+        /* CONFIRM THE CAP DOESN'T EXIST IN SCM */\n+        AppServicesCapabilities cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNull(cachedCap);\n \n-\t\tassertTrue(cachedCap.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID().equals(baseID));\n+        /* ADD THE CAP IN SCM */\n+        systemCapabilityManager.setCapability(SystemCapabilityType.APP_SERVICES, appServicesCapabilities);\n+        /* CONFIRM THE CAP DOES EXIST IN SCM */\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n+        /* CONFIRM THE CAP IN SCM EQUALS ORIGINAL*/\n+        assertEquals(cachedCap, appServicesCapabilities);\n+        assertNull(cachedCap.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID());\n \n-\t\tappServicesCapabilities.updateAppServices(Collections.singletonList(addServiceID));\n-\t\tassertTrue(serviceIdASC.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID().equalsIgnoreCase(appServicesCapabilities.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID()));\n+        /* PERFORM A NOTIFICATION SEND THROUGH THE SCM */\n+        AppServiceCapability addServiceID = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, baseName, baseID, true, null);\n+        AppServicesCapabilities serviceIdASC = new AppServicesCapabilities();\n+        serviceIdASC.setAppServices(Collections.singletonList(addServiceID));\n \n-\t\tassertEquals(cachedCap, appServicesCapabilities);\n+        SystemCapability systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, serviceIdASC);\n \n+        OnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH AN UPDATED SERVICE NAME */\n-\t\tAppServiceCapability newServiceName = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"TestNav\", baseID, true, null);\n-\t\tAppServicesCapabilities newServiceNameASC = new AppServicesCapabilities();\n-\t\tnewServiceNameASC.setAppServices(Collections.singletonList(newServiceName));\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tsystemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, newServiceNameASC);\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n \n-\t\tonSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        assertTrue(cachedCap.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID().equals(baseID));\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        appServicesCapabilities.updateAppServices(Collections.singletonList(addServiceID));\n+        assertTrue(serviceIdASC.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID().equalsIgnoreCase(appServicesCapabilities.getAppServices().get(0).getUpdatedAppServiceRecord().getServiceID()));\n \n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n-\t\tassertEquals(cachedCap.getAppServices().size(), 1);\n+        assertEquals(cachedCap, appServicesCapabilities);\n \n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH THE SCM WITH DIFFERENT SERVICE */\n-\t\tAppServiceCapability newService = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"NewNav\", \"eeeeeeeee\", false, null);\n-\t\tAppServicesCapabilities newServiceASC = new AppServicesCapabilities();\n-\t\tnewServiceASC.setAppServices(Collections.singletonList(newService));\n+        /* PERFORM A NOTIFICATION SEND THROUGH AN UPDATED SERVICE NAME */\n+        AppServiceCapability newServiceName = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"TestNav\", baseID, true, null);\n+        AppServicesCapabilities newServiceNameASC = new AppServicesCapabilities();\n+        newServiceNameASC.setAppServices(Collections.singletonList(newServiceName));\n \n-\t\tsystemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, newServiceASC);\n+        systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, newServiceNameASC);\n \n-\t\tonSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n-\t\tassertEquals(cachedCap.getAppServices().size(), 2);\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n+        assertEquals(cachedCap.getAppServices().size(), 1);\n \n-\t\t/* PERFORM A NOTIFICATION SEND THROUGH THE SCM WITH A REMOVED SERVICE */\n-\t\tAppServiceCapability removedService = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"NewNav\", \"eeeeeeeee\", false, null);\n-\t\tremovedService.setUpdateReason(ServiceUpdateReason.REMOVED);\n-\t\tAppServicesCapabilities removedServiceASC = new AppServicesCapabilities();\n-\t\tremovedServiceASC.setAppServices(Collections.singletonList(removedService));\n \n-\t\tsystemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, removedServiceASC);\n+        /* PERFORM A NOTIFICATION SEND THROUGH THE SCM WITH DIFFERENT SERVICE */\n+        AppServiceCapability newService = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"NewNav\", \"eeeeeeeee\", false, null);\n+        AppServicesCapabilities newServiceASC = new AppServicesCapabilities();\n+        newServiceASC.setAppServices(Collections.singletonList(newService));\n \n-\t\tonSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, newServiceASC);\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+        onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\tcachedCap = (AppServicesCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES);\n-\t\tassertNotNull(cachedCap);\n-\t\tassertEquals(cachedCap.getAppServices().size(), 1);\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t}\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n+        assertEquals(cachedCap.getAppServices().size(), 2);\n \n+        /* PERFORM A NOTIFICATION SEND THROUGH THE SCM WITH A REMOVED SERVICE */\n+        AppServiceCapability removedService = AppServiceFactory.createAppServiceCapability(AppServiceType.NAVIGATION, \"NewNav\", \"eeeeeeeee\", false, null);\n+        removedService.setUpdateReason(ServiceUpdateReason.REMOVED);\n+        AppServicesCapabilities removedServiceASC = new AppServicesCapabilities();\n+        removedServiceASC.setAppServices(Collections.singletonList(removedService));\n+\n+        systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.APP_SERVICES);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.APP_SERVICES, removedServiceASC);\n \n-\t@Test\n-\tpublic void testOnSystemCapabilityUpdatedOverwrite(){\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tOnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n-\t\tassertNotNull(scmRpcListener);\n-\t\tsystemCapabilityManager.setCapability(SystemCapabilityType.PHONE_CALL, TestValues.GENERAL_PHONECAPABILITY);\n+        onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n-\t\tPhoneCapability phoneCapability = (PhoneCapability)systemCapabilityManager.getCapability(SystemCapabilityType.PHONE_CALL);\n-\t\tassertNotNull(phoneCapability);\n-\t\tassertEquals(phoneCapability, TestValues.GENERAL_PHONECAPABILITY);\n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tphoneCapability.setDialNumberEnabled(!TestValues.GENERAL_PHONECAPABILITY.getDialNumberEnabled()); //Flip it\n-\t\tSystemCapability systemCapability = new SystemCapability();\n-\t\tsystemCapability.setSystemCapabilityType(SystemCapabilityType.PHONE_CALL);\n-\t\tsystemCapability.setCapabilityForType(SystemCapabilityType.PHONE_CALL, phoneCapability);\n-\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n-\t\tonSystemCapabilityUpdated.setSystemCapability(systemCapability);\n+        cachedCap = (AppServicesCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.APP_SERVICES, null, false);\n+        assertNotNull(cachedCap);\n+        assertEquals(cachedCap.getAppServices().size(), 1);\n \n-\t\tscmRpcListener.onReceived(onSystemCapabilityUpdated);\n+    }\n \n-\t\tPhoneCapability phoneCapabilityUpdated = (PhoneCapability)systemCapabilityManager.getCapability(SystemCapabilityType.PHONE_CALL);\n-\t\tassertNotNull(phoneCapabilityUpdated);\n-\t\tassertFalse(phoneCapabilityUpdated.getDialNumberEnabled());\n-\t\tassertEquals(phoneCapability, phoneCapabilityUpdated);\n-\t}\n \n-\t@Test\n-\tpublic void testOnSetDisplayLayout() {\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n-\t\tOnRPCListener dlRpcListener = iSDL.rpcListeners.get(FunctionID.SET_DISPLAY_LAYOUT.getId()).get(0);\n-\t\tassertNotNull(dlRpcListener);\n+    @Test\n+    public void testOnSystemCapabilityUpdatedOverwrite() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        OnRPCListener scmRpcListener = iSDL.rpcListeners.get(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED.getId()).get(0);\n+        assertNotNull(scmRpcListener);\n+        systemCapabilityManager.setCapability(SystemCapabilityType.PHONE_CALL, TestValues.GENERAL_PHONECAPABILITY);\n \n-\t\tSetDisplayLayoutResponse newLayout = new SetDisplayLayoutResponse();\n-\t\tnewLayout.setDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES);\n-\t\tnewLayout.setButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tnewLayout.setSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n-\t\tnewLayout.setPresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES);\n-\t\tnewLayout.setSuccess(true);\n-\t\tnewLayout.setResultCode(Result.SUCCESS);\n+        PhoneCapability phoneCapability = (PhoneCapability) systemCapabilityManager.getCapability(SystemCapabilityType.PHONE_CALL, null, false);\n+        assertNotNull(phoneCapability);\n+        assertEquals(phoneCapability, TestValues.GENERAL_PHONECAPABILITY);\n \n-\t\tdlRpcListener.onReceived(newLayout);\n+        phoneCapability.setDialNumberEnabled(!TestValues.GENERAL_PHONECAPABILITY.getDialNumberEnabled()); //Flip it\n+        SystemCapability systemCapability = new SystemCapability();\n+        systemCapability.setSystemCapabilityType(SystemCapabilityType.PHONE_CALL);\n+        systemCapability.setCapabilityForType(SystemCapabilityType.PHONE_CALL, phoneCapability);\n+        OnSystemCapabilityUpdated onSystemCapabilityUpdated = new OnSystemCapabilityUpdated();\n+        onSystemCapabilityUpdated.setSystemCapability(systemCapability);\n \n+        scmRpcListener.onReceived(onSystemCapabilityUpdated);\n \n-\t\tDisplayCapabilities appliedCaps = (DisplayCapabilities)systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY);\n-\t\tassertNotNull(appliedCaps);\n-\t\tassertTrue(Validator.validateDisplayCapabilities(newLayout.getDisplayCapabilities(), appliedCaps));\n+        PhoneCapability phoneCapabilityUpdated = (PhoneCapability) systemCapabilityManager.getCapability(SystemCapabilityType.PHONE_CALL, null, false);\n+        assertNotNull(phoneCapabilityUpdated);\n+        assertFalse(phoneCapabilityUpdated.getDialNumberEnabled());\n+        assertEquals(phoneCapability, phoneCapabilityUpdated);\n+    }\n \n-\t\tList<DisplayCapability> convertedCaps = (List<DisplayCapability>)systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS);\n-\t\tassertNotNull(convertedCaps);\n-\t\tList<DisplayCapability> testCaps = createDisplayCapabilityList(newLayout.getDisplayCapabilities(), newLayout.getButtonCapabilities(), newLayout.getSoftButtonCapabilities());\n-\t\tassertTrue(Validator.validateDisplayCapabilityList(convertedCaps, testCaps));\n+    @Test\n+    public void testOnSetDisplayLayout() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = createSampleManager(iSDL);\n+        OnRPCListener dlRpcListener = iSDL.rpcListeners.get(FunctionID.SET_DISPLAY_LAYOUT.getId()).get(0);\n+        assertNotNull(dlRpcListener);\n \n-\t\tWindowCapability matchWindowCapability = testCaps.get(0).getWindowCapabilities().get(0);\n-\t\tWindowCapability testWindowCapability = systemCapabilityManager.getDefaultMainWindowCapability();\n-\t\tassertTrue(Validator.validateWindowCapability(matchWindowCapability, testWindowCapability));\n-\t\tassertNull(systemCapabilityManager.getWindowCapability(42));\n-\t}\n-\n-\t@Test\n-\tpublic void testManagerBeforeDisplayUpdate() {\n-\t\tInternalSDLInterface iSDL = new InternalSDLInterface();\n-\t\tSystemCapabilityManager systemCapabilityManager = new SystemCapabilityManager(iSDL);\n-\t\tassertNull(systemCapabilityManager.getDefaultMainWindowCapability());\n-\t\tassertNull(systemCapabilityManager.getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue()));\n-\t\tassertNull(systemCapabilityManager.getWindowCapability(PredefinedWindows.PRIMARY_WIDGET.getValue()));\n-\t}\n-\n-\tprivate class InternalSDLInterface implements ISdl{\n-\t\tprivate final Object RPC_LISTENER_LOCK = new Object();\n-\t\tSparseArray<CopyOnWriteArrayList<OnRPCListener>> rpcListeners = new SparseArray<>();\n-\n-\t\t@Override\n-\t\tpublic void start(){}\n-\n-\t\t@Override\n-\t\tpublic void stop() {}\n-\n-\t\t@Override\n-\t\tpublic boolean isConnected() {return false;\t}\n-\n-\t\t@Override\n-\t\tpublic void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener) {}\n-\n-\t\t@Override\n-\t\tpublic void removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener) {}\n-\n-\t\t@Override\n-\t\tpublic void startVideoService(VideoStreamingParameters parameters, boolean encrypted) {\t}\n-\n-\t\t@Override\n-\t\tpublic void stopVideoService() {}\n-\n-\t\t@Override\n-\t\tpublic void stopAudioService() {}\n-\n-\t\t@Override\n-\t\tpublic void sendRPCRequest(RPCRequest message) {}\n-\n-\t\t@Override\n-\t\tpublic void sendRPC(RPCMessage message) {}\n-\n-\t\t@Override\n-\t\tpublic void sendRequests(List<? extends RPCRequest> rpcs, OnMultipleRequestListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, OnMultipleRequestListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void sendSequentialRPCs(List<? extends RPCMessage> rpcs, OnMultipleRequestListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener) {return false;}\n-\n-\t\t@Override\n-\t\tpublic void addOnRPCRequestListener(FunctionID functionID, OnRPCRequestListener listener) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean removeOnRPCRequestListener(FunctionID functionID, OnRPCRequestListener listener) {\n-\t\t\treturn false;\n-\t\t}\n-\t\t@Override\n-\t\tpublic void addOnRPCListener(FunctionID messageId, OnRPCListener listener){\n-\t\t\tsynchronized(RPC_LISTENER_LOCK){\n-\t\t\t\tif(messageId != null && listener != null){\n-\t\t\t\t\tif(rpcListeners.indexOfKey(messageId.getId()) < 0 ){\n-\t\t\t\t\t\trpcListeners.put(messageId.getId(),new CopyOnWriteArrayList<OnRPCListener>());\n-\t\t\t\t\t}\n-\t\t\t\t\trpcListeners.get(messageId.getId()).add(listener);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic boolean removeOnRPCListener(FunctionID messageId, OnRPCListener listener){\n-\t\t\tsynchronized(RPC_LISTENER_LOCK){\n-\t\t\t\tif(rpcListeners!= null\n-\t\t\t\t\t\t&& messageId != null\n-\t\t\t\t\t\t&& listener != null\n-\t\t\t\t\t\t&& rpcListeners.indexOfKey(messageId.getId()) >= 0){\n-\t\t\t\t\treturn rpcListeners.get(messageId.getId()).remove(listener);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Object getCapability(SystemCapabilityType systemCapabilityType){return null;}\n-\n-\t\t@Override\n-\t\tpublic void getCapability(SystemCapabilityType systemCapabilityType, OnSystemCapabilityListener scListener) {\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse() {\n-\t\t\treturn null;\n-\t\t}\n+        SetDisplayLayoutResponse newLayout = new SetDisplayLayoutResponse();\n+        newLayout.setDisplayCapabilities(TestValues.GENERAL_DISPLAYCAPABILITIES);\n+        newLayout.setButtonCapabilities(TestValues.GENERAL_BUTTONCAPABILITIES_LIST);\n+        newLayout.setSoftButtonCapabilities(TestValues.GENERAL_SOFTBUTTONCAPABILITIES_LIST);\n+        newLayout.setPresetBankCapabilities(TestValues.GENERAL_PRESETBANKCAPABILITIES);\n+        newLayout.setSuccess(true);\n+        newLayout.setResultCode(Result.SUCCESS);\n+\n+        dlRpcListener.onReceived(newLayout);\n \n-\t\t@Override\n-\t\tpublic Object getCapability(SystemCapabilityType systemCapabilityType, OnSystemCapabilityListener scListener, boolean forceUpdate) {\n-\t\t\treturn null;\n-\t\t}\n \n-\t\t@Override\n-\t\tpublic SdlMsgVersion getSdlMsgVersion() {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic Version getProtocolVersion() {\n-\t\t\treturn new Version(1,0,0);\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic boolean isCapabilitySupported(SystemCapabilityType systemCapabilityType){\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void addOnSystemCapabilityListener(SystemCapabilityType systemCapabilityType, OnSystemCapabilityListener listener) { }\n-\n-\t\t@Override\n-\t\tpublic boolean removeOnSystemCapabilityListener(SystemCapabilityType systemCapabilityType, OnSystemCapabilityListener listener) { return false; }\n-\n-\t\t@Override\n-\t\tpublic boolean isTransportForServiceAvailable(SessionType serviceType) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void startAudioService(boolean isEncrypted, AudioStreamingCodec codec,\n-\t\t\t\t\t\t\t\t\t  AudioStreamingParams params) {}\n-\n-\t\t@Override\n-\t\tpublic IVideoStreamListener startVideoStream(boolean isEncrypted, VideoStreamingParameters parameters){\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic IAudioStreamListener startAudioStream(boolean isEncrypted, AudioStreamingCodec codec,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t AudioStreamingParams params) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void startAudioService(boolean encrypted){}\n-\n-\t\t@Override\n-\t\tpublic void startRPCEncryption() {}\n-\n-\t\t@Override\n-\t\tpublic Taskmaster getTaskmaster() {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n+        DisplayCapabilities appliedCaps = (DisplayCapabilities) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAY, null, false);\n+        assertNotNull(appliedCaps);\n+        assertTrue(Validator.validateDisplayCapabilities(newLayout.getDisplayCapabilities(), appliedCaps));\n+\n+        List<DisplayCapability> convertedCaps = (List<DisplayCapability>) systemCapabilityManager.getCapability(SystemCapabilityType.DISPLAYS, null, false);\n+        assertNotNull(convertedCaps);\n+        List<DisplayCapability> testCaps = createDisplayCapabilityList(newLayout.getDisplayCapabilities(), newLayout.getButtonCapabilities(), newLayout.getSoftButtonCapabilities());\n+        assertTrue(Validator.validateDisplayCapabilityList(convertedCaps, testCaps));\n+\n+        WindowCapability matchWindowCapability = testCaps.get(0).getWindowCapabilities().get(0);\n+        WindowCapability testWindowCapability = systemCapabilityManager.getDefaultMainWindowCapability();\n+        assertTrue(Validator.validateWindowCapability(matchWindowCapability, testWindowCapability));\n+        assertNull(systemCapabilityManager.getWindowCapability(42));\n+    }\n+\n+    @Test\n+    public void testManagerBeforeDisplayUpdate() {\n+        InternalSDLInterface iSDL = new InternalSDLInterface();\n+        SystemCapabilityManager systemCapabilityManager = new SystemCapabilityManager(iSDL);\n+        assertNull(systemCapabilityManager.getDefaultMainWindowCapability());\n+        assertNull(systemCapabilityManager.getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue()));\n+        assertNull(systemCapabilityManager.getWindowCapability(PredefinedWindows.PRIMARY_WIDGET.getValue()));\n+    }\n+\n+    private class InternalSDLInterface implements ISdl {\n+        private final Object RPC_LISTENER_LOCK = new Object();\n+        SparseArray<CopyOnWriteArrayList<OnRPCListener>> rpcListeners = new SparseArray<>();\n+\n+        @Override\n+        public void start() {\n+        }\n+\n+        @Override\n+        public void stop() {\n+        }\n+\n+        @Override\n+        public boolean isConnected() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener) {\n+        }\n+\n+        @Override\n+        public void removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener) {\n+        }\n+\n+        @Override\n+        public void startVideoService(VideoStreamingParameters parameters, boolean encrypted, boolean withPendingRestart) {\n+        }\n+\n+        @Override\n+        public void sendRPC(RPCMessage message) {\n+        }\n+\n+        @Override\n+        public void sendRPCs(List<? extends RPCMessage> rpcs, OnMultipleRequestListener listener) {\n+\n+        }\n+\n+        @Override\n+        public void sendSequentialRPCs(List<? extends RPCMessage> rpcs, OnMultipleRequestListener listener) {\n+\n+        }\n+\n+        @Override\n+        public void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener) {\n+\n+        }\n+\n+        @Override\n+        public boolean removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener) {\n+            return false;\n+        }\n+\n+        @Override\n+        public void addOnRPCRequestListener(FunctionID functionID, OnRPCRequestListener listener) {\n+\n+        }\n+\n+        @Override\n+        public boolean removeOnRPCRequestListener(FunctionID functionID, OnRPCRequestListener listener) {\n+            return false;\n+        }\n+\n+        @Override\n+        public void addOnRPCListener(FunctionID messageId, OnRPCListener listener) {\n+            synchronized (RPC_LISTENER_LOCK) {\n+                if (messageId != null && listener != null) {\n+                    if (rpcListeners.indexOfKey(messageId.getId()) < 0) {\n+                        rpcListeners.put(messageId.getId(), new CopyOnWriteArrayList<OnRPCListener>());\n+                    }\n+                    rpcListeners.get(messageId.getId()).add(listener);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public boolean removeOnRPCListener(FunctionID messageId, OnRPCListener listener) {\n+            synchronized (RPC_LISTENER_LOCK) {\n+                if (rpcListeners != null\n+                        && messageId != null\n+                        && listener != null\n+                        && rpcListeners.indexOfKey(messageId.getId()) >= 0) {\n+                    return rpcListeners.get(messageId.getId()).remove(listener);\n+                }\n+            }\n+            return false;\n+        }\n+\n+\n+        @Override\n+        public RegisterAppInterfaceResponse getRegisterAppInterfaceResponse() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SdlMsgVersion getSdlMsgVersion() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Version getProtocolVersion() {\n+            return new Version(1, 0, 0);\n+        }\n+\n+        @Override\n+        public boolean isTransportForServiceAvailable(SessionType serviceType) {\n+            return false;\n+        }\n+\n+        @Override\n+        public void startAudioService(boolean encrypted) {\n+        }\n+\n+        @Override\n+        public void startRPCEncryption() {\n+        }\n+\n+        @Override\n+        public Taskmaster getTaskmaster() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SystemCapabilityManager getSystemCapabilityManager() {\n+            return null;\n+        }\n+    }\n }\n"}}, {"oid": "23b4799bd98bee6509f6d8b8a021f4f21be1e8c6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/23b4799bd98bee6509f6d8b8a021f4f21be1e8c6", "message": "Merge branch 'feature/0296_possibility_to_update_video_streaming_capabilities' of https://github.com/LuxoftSDL/sdl_java_suite into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/proxy/SdlProxyBase.java", "committedDate": "2020-08-18T17:29:58Z", "type": "commit"}, {"oid": "9b99237b669f09357eac214870d5f351911060ce", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9b99237b669f09357eac214870d5f351911060ce", "message": "Merge branch 'develop' into Feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tbase/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java", "committedDate": "2020-08-18T20:40:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwNDc0MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472504740", "bodyText": "For these three:\nON_SUBTLE_ALERT_PRESSED(32788, \"OnSubtleAlertPressed\"), ON_UPDATE_FILE(32789, \"OnUpdateFile\"), ON_UPDATE_SUB_MENU(32790, \"OnUpdateSubMenu\"),\nI don't see these RPC notifications defined in the proposal.  Can you explain what they are?", "author": "santhanamk", "createdAt": "2020-08-18T21:30:50Z", "path": "base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java", "diffHunk": "@@ -132,6 +132,9 @@\n     ON_RC_STATUS(32785, \"OnRCStatus\"),\r\n     ON_APP_SERVICE_DATA(32786, \"OnAppServiceData\"),\r\n     ON_SYSTEM_CAPABILITY_UPDATED(32787, \"OnSystemCapabilityUpdated\"),\r\n+    ON_SUBTLE_ALERT_PRESSED(32788, \"OnSubtleAlertPressed\"),\r", "originalCommit": "16e430a7de2ac66bd9a5612f0b1059ac0fbac24f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkzOTMyNg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472939326", "bodyText": "@santhanamk this was displayed because of unresolved merge conflicts with dev branch. In the latest version after the update it is not marked as change, the FunctionID.java was aligned according to the latest specification", "author": "kboskin", "createdAt": "2020-08-19T10:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwNDc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java b/base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java\nindex 68daadcb5..e75722d93 100644\n--- a/base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java\n+++ b/base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java\n\n@@ -135,58 +134,45 @@ public enum FunctionID{\n     ON_SUBTLE_ALERT_PRESSED(32788, \"OnSubtleAlertPressed\"),\n     ON_UPDATE_FILE(32789, \"OnUpdateFile\"),\n     ON_UPDATE_SUB_MENU(32790, \"OnUpdateSubMenu\"),\n-    ON_APP_CAPABILITY_UPDATED(32788, \"OnAppCapabilityUpdated\"),\n-\n-    // MOCKED FUNCTIONS (NOT SENT FROM HEAD-UNIT)\n-    @Deprecated\n-    ON_LOCK_SCREEN_STATUS(-1, \"OnLockScreenStatus\"),\n-    @Deprecated\n-    ON_SDL_CHOICE_CHOSEN(-1, \"OnSdlChoiceChosen\"),\n-    @Deprecated\n-    ON_STREAM_RPC(-1, \"OnStreamRPC\"),\n-    @Deprecated\n-    STREAM_RPC(-1, \"StreamRPC\"),\n-\n+    ON_APP_CAPABILITY_UPDATED(32791, \"OnAppCapabilityUpdated\"),\n     ;\n \n-    public static final int                 INVALID_ID = -1;\n+    public static final int INVALID_ID = -1;\n \n     private static HashMap<String, Integer> functionMap;\n \n-    private final int                       ID;\n-    private final String                    JSON_NAME;\n+    private final int ID;\n+    private final String JSON_NAME;\n \n-    private FunctionID(int id, String jsonName){\n+    private FunctionID(int id, String jsonName) {\n         this.ID = id;\n         this.JSON_NAME = jsonName;\n     }\n \n-    public int getId(){\n+    public int getId() {\n         return this.ID;\n     }\n \n     @Override\n-    public String toString(){\n+    public String toString() {\n         return this.JSON_NAME;\n     }\n \n-    private static void initFunctionMap(){\n-        functionMap = new HashMap<String, Integer>(values().length);\n+    private static void initFunctionMap() {\n+        functionMap = new HashMap<>(values().length);\n \n-        for(FunctionID value : EnumSet.allOf(FunctionID.class)){\n+        for (FunctionID value : EnumSet.allOf(FunctionID.class)) {\n             functionMap.put(value.toString(), value.getId());\n         }\n     }\n \n-    public static String getFunctionName(int i){\n-        if(functionMap == null){\n+    public static String getFunctionName(int i) {\n+        if (functionMap == null) {\n             initFunctionMap();\n         }\n \n-        Iterator<Entry<String, Integer>> iterator = functionMap.entrySet().iterator();\n-        while(iterator.hasNext()){\n-            Entry<String, Integer> thisEntry = iterator.next();\n-            if(Integer.valueOf(i).equals(thisEntry.getValue())){\n+        for (Entry<String, Integer> thisEntry : functionMap.entrySet()) {\n+            if (Integer.valueOf(i).equals(thisEntry.getValue())) {\n                 return thisEntry.getKey();\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwNDg4Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472504887", "bodyText": "Unit tests are needed for OnSubtleAlertPressed.", "author": "santhanamk", "createdAt": "2020-08-18T21:31:11Z", "path": "base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java", "diffHunk": "@@ -132,6 +132,9 @@\n     ON_RC_STATUS(32785, \"OnRCStatus\"),\r\n     ON_APP_SERVICE_DATA(32786, \"OnAppServiceData\"),\r\n     ON_SYSTEM_CAPABILITY_UPDATED(32787, \"OnSystemCapabilityUpdated\"),\r\n+    ON_SUBTLE_ALERT_PRESSED(32788, \"OnSubtleAlertPressed\"),\r", "originalCommit": "16e430a7de2ac66bd9a5612f0b1059ac0fbac24f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkzOTQzMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472939431", "bodyText": "@santhanamk this was displayed because of unresolved merge conflicts with dev branch. In the latest version after the update it is not marked as change, the FunctionID.java was aligned according to the latest specification", "author": "kboskin", "createdAt": "2020-08-19T10:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwNDg4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java b/base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java\nindex 68daadcb5..e75722d93 100644\n--- a/base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java\n+++ b/base/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java\n\n@@ -135,58 +134,45 @@ public enum FunctionID{\n     ON_SUBTLE_ALERT_PRESSED(32788, \"OnSubtleAlertPressed\"),\n     ON_UPDATE_FILE(32789, \"OnUpdateFile\"),\n     ON_UPDATE_SUB_MENU(32790, \"OnUpdateSubMenu\"),\n-    ON_APP_CAPABILITY_UPDATED(32788, \"OnAppCapabilityUpdated\"),\n-\n-    // MOCKED FUNCTIONS (NOT SENT FROM HEAD-UNIT)\n-    @Deprecated\n-    ON_LOCK_SCREEN_STATUS(-1, \"OnLockScreenStatus\"),\n-    @Deprecated\n-    ON_SDL_CHOICE_CHOSEN(-1, \"OnSdlChoiceChosen\"),\n-    @Deprecated\n-    ON_STREAM_RPC(-1, \"OnStreamRPC\"),\n-    @Deprecated\n-    STREAM_RPC(-1, \"StreamRPC\"),\n-\n+    ON_APP_CAPABILITY_UPDATED(32791, \"OnAppCapabilityUpdated\"),\n     ;\n \n-    public static final int                 INVALID_ID = -1;\n+    public static final int INVALID_ID = -1;\n \n     private static HashMap<String, Integer> functionMap;\n \n-    private final int                       ID;\n-    private final String                    JSON_NAME;\n+    private final int ID;\n+    private final String JSON_NAME;\n \n-    private FunctionID(int id, String jsonName){\n+    private FunctionID(int id, String jsonName) {\n         this.ID = id;\n         this.JSON_NAME = jsonName;\n     }\n \n-    public int getId(){\n+    public int getId() {\n         return this.ID;\n     }\n \n     @Override\n-    public String toString(){\n+    public String toString() {\n         return this.JSON_NAME;\n     }\n \n-    private static void initFunctionMap(){\n-        functionMap = new HashMap<String, Integer>(values().length);\n+    private static void initFunctionMap() {\n+        functionMap = new HashMap<>(values().length);\n \n-        for(FunctionID value : EnumSet.allOf(FunctionID.class)){\n+        for (FunctionID value : EnumSet.allOf(FunctionID.class)) {\n             functionMap.put(value.toString(), value.getId());\n         }\n     }\n \n-    public static String getFunctionName(int i){\n-        if(functionMap == null){\n+    public static String getFunctionName(int i) {\n+        if (functionMap == null) {\n             initFunctionMap();\n         }\n \n-        Iterator<Entry<String, Integer>> iterator = functionMap.entrySet().iterator();\n-        while(iterator.hasNext()){\n-            Entry<String, Integer> thisEntry = iterator.next();\n-            if(Integer.valueOf(i).equals(thisEntry.getValue())){\n+        for (Entry<String, Integer> thisEntry : functionMap.entrySet()) {\n+            if (Integer.valueOf(i).equals(thisEntry.getValue())) {\n                 return thisEntry.getKey();\n             }\n         }\n"}}, {"oid": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e64d5879fa5d471514ebea3c6d07fb6082562cd9", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities", "committedDate": "2020-08-18T23:18:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0OTA1Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472549057", "bodyText": "I believe this should be 7.0 instead of 6.0.", "author": "santhanamk", "createdAt": "2020-08-18T23:29:54Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.smartdevicelink.proxy.rpc;\n+\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCNotification;\n+\n+import java.util.Hashtable;\n+\n+/**\n+ * since Smart Device Link 6.0", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\nindex 18e8a6e2c..92f82c1b2 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/OnAppCapabilityUpdated.java\n\n@@ -6,7 +6,8 @@ import com.smartdevicelink.proxy.RPCNotification;\n import java.util.Hashtable;\n \n /**\n- * since Smart Device Link 6.0\n+ *\n+ * @since Smart Device Link 7.0\n  * A notification to inform SDL Core that a specific app capability has changed.\n  */\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MTE5MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472551191", "bodyText": "Based on the mobile_API.xml, this file should have the /** @since 7.0 */ annotation.", "author": "santhanamk", "createdAt": "2020-08-18T23:36:18Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package com.smartdevicelink.proxy.rpc;\n+\n+", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3NTI3Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473375277", "bodyText": "Based on the mobile_API.xml, this file should have the /** @since 7.0 */ annotation.\n\n@kostyaBoss I dont see the annotation /** @since 7.0 */ at the top. Can you please add it whenever you get the chance?", "author": "santhanamk", "createdAt": "2020-08-19T22:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MTE5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\nindex 79f8a0fa7..31f33125d 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n\n@@ -8,6 +8,9 @@ import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n \n import java.util.Hashtable;\n \n+/**\n+ * @since SmartDeviceLink 7.0\n+ */\n public class AppCapability extends RPCStruct {\n     public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n     public static final String KEY_VIDEO_STREAMING_CAPABILITY = \"videoStreamingCapability\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MTgxMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472551811", "bodyText": "This should be 7.0 instead of 6.0 on line 4.", "author": "santhanamk", "createdAt": "2020-08-18T23:38:33Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.smartdevicelink.proxy.rpc.enums;\n+\n+/**\n+ * Since SmartDeviceLink 6.0", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\nindex a86119c12..7285edae6 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/enums/AppCapabilityType.java\n\n@@ -1,9 +1,23 @@\n package com.smartdevicelink.proxy.rpc.enums;\n \n /**\n- * Since SmartDeviceLink 6.0\n+ * @since SmartDeviceLink 7.0\n  * Enumerations of all available app capability types\n  */\n public enum AppCapabilityType {\n     VIDEO_STREAMING,\n+    ;\n+\n+    /**\n+     * Convert String to AppCapabilityType\n+     * @param value String\n+     * @return AppCapabilityType\n+     */\n+    public static AppCapabilityType valueForString(String value) {\n+        try{\n+            return valueOf(value);\n+        }catch(Exception e){\n+            return null;\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcxNDI1Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472714252", "bodyText": "Can the STREAM_ENUM enum be defined in a separate class?", "author": "santhanamk", "createdAt": "2020-08-19T05:28:04Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java", "diffHunk": "@@ -40,4 +157,8 @@ public boolean onOptionsItemSelected(MenuItem item) {\n \t\t}\n \t\treturn super.onOptionsItemSelected(item);\n \t}\n+\n+\tpublic static enum STREAM_ENUM{", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyODY0NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472928645", "bodyText": "@santhanamk this change is related more to demonstrate proposal implementation, rather than to a functional one. If it is required, I can separate this code, but, I believe, this should not go to the final release version and should be deleted. Though, it remains here right now in order to help everybody to acknowledge. Should I remove it now?", "author": "kboskin", "createdAt": "2020-08-19T10:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcxNDI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE1Nzc4MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473157781", "bodyText": "@kostyaBoss  if you think it should be deleted, then you can go ahead and delete it.  Thanks.", "author": "santhanamk", "createdAt": "2020-08-19T16:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcxNDI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\nindex 237b44444..43ad79ac7 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n\n@@ -1,164 +1,43 @@\n package com.sdl.hellosdlandroid;\n \n-import android.app.Activity;\n import android.content.Intent;\n-import android.content.SharedPreferences;\n import android.os.Bundle;\n-import android.preference.PreferenceManager;\n-import android.text.Editable;\n-import android.text.TextWatcher;\n import android.view.Menu;\n import android.view.MenuItem;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.EditText;\n-import android.widget.Toast;\n \n-import java.util.Timer;\n-import java.util.TimerTask;\n-\n-public class MainActivity extends Activity {\n-\tprivate static final String TAG = \"MainActivity\";\n-\n-\tpublic static final String IP = \"ip\";\n-\tpublic static final String PORT = \"port\";\n-\tpublic static final String COMMAND = \"command\";\n-\tpublic static final String COMMAND_START_PROXY = \"c_start_proxy\";\n-\tpublic static final String COMMAND_START_STREAM = \"c_start_stream\";\n-\n-\tpublic static final String PREDEFINED_WIDTH = \"pre_def_w\";\n-\tpublic static final String PREDEFINED_HEIGHT = \"pre_def_h\";\n-\tpublic static final String IP_ADDRESS = \"ip_address\";\n-\tSharedPreferences preferences;\n-\n-\t@Override\n-\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\tsuper.onCreate(savedInstanceState);\n-\t\tsetContentView(R.layout.activity_main);\n-\n-\t\tpreferences = PreferenceManager.getDefaultSharedPreferences(this);\n-\n-\n-\t\tButton startStreaming = findViewById(R.id.start_streaming);\n-\t\tButton startStreamingUI = findViewById(R.id.start_streaming_ui);\n-\t\tButton startProxy = findViewById(R.id.start_proxy);\n-\t\tButton stopApp = findViewById(R.id.exit_application);\n-\n-\t\tfinal EditText ip = findViewById(R.id.machine_ip);\n-\t\tfinal EditText port = findViewById(R.id.machine_port);\n-\n-\t\tfinal EditText preConfWidth = findViewById(R.id.pre_conf_width);\n-\t\tfinal EditText preConfHeight = findViewById(R.id.pre_conf_height);\n-\n-\t\tip.setText(preferences.getString(IP_ADDRESS, \"192.168.0.101\"));\n-\n-\t\tip.addTextChangedListener(new TextWatcher() {\n-\t\t\t@Override\n-\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) { }\n-\n-\t\t\t@Override\n-\t\t\tpublic void afterTextChanged(Editable s) {\n-\t\t\t\tif (s!=null) {\n-\t\t\t\t\tpreferences.edit().putString(IP_ADDRESS, s.toString()).commit();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartProxy.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\t//If we are connected to a module we want to start our SdlService\n-\t\t\t\tif(BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\t\tSdlReceiver.queryForConnectedService(MainActivity.this);\n-\t\t\t\t}else if(BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\t\tIntent proxyIntent = new Intent(MainActivity.this, SdlService.class);\n-\n-\t\t\t\t\tString ipString = ip.getText().toString();\n-\t\t\t\t\tString portString = port.getText().toString();\n-\t\t\t\t\tif (!ipString.isEmpty() && !portString.isEmpty()) {\n-\t\t\t\t\t\tproxyIntent.putExtra(IP, ip.getText().toString());\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tproxyIntent.putExtra(PORT, Integer.parseInt(port.getText().toString()));\n-\t\t\t\t\t\t} catch (NumberFormatException e){\n-\t\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Port should be number\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tstartService(proxyIntent);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tToast.makeText(MainActivity.this, \"Fill ip and port\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreaming.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstartStreamingUI.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View view) {\n-\n-\t\t\t\tif (!preConfWidth.getText().toString().isEmpty() && !preConfHeight.getText().toString().isEmpty()) {\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_WIDTH, Integer.parseInt(preConfWidth.getText().toString())).commit();\n-\t\t\t\t\tpreferences.edit().putInt(PREDEFINED_HEIGHT, Integer.parseInt(preConfHeight.getText().toString())).commit();\n-\t\t\t\t\tSdlService.relay.accept(STREAM_ENUM.START_STREAMING_UI);\n-\t\t\t\t} else {\n-\t\t\t\t\tToast.makeText(MainActivity.this, \"Configure display width and height\", Toast.LENGTH_SHORT).show();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tstopApp.setOnClickListener(new View.OnClickListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onClick(View v) {\n-\t\t\t\tstopService(new Intent(MainActivity.this, SdlService.class));\n-\n-\t\t\t\tnew Timer().schedule(new TimerTask() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\tandroid.os.Process.killProcess(android.os.Process.myPid());\n-\t\t\t\t\t}\n-\t\t\t\t}, 50);\n-\n-\t\t\t\tfinish();\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Override\n-\tpublic boolean onCreateOptionsMenu(Menu menu) {\n-\t\t// Inflate the menu; this adds items to the action bar if it is present.\n-\t\tgetMenuInflater().inflate(R.menu.main, menu);\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic boolean onOptionsItemSelected(MenuItem item) {\n-\t\t// Handle action bar item clicks here. The action bar will\n-\t\t// automatically handle clicks on the Home/Up button, so long\n-\t\t// as you specify a parent activity in AndroidManifest.xml.\n-\t\tint id = item.getItemId();\n-\t\tif (id == R.id.action_settings) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn super.onOptionsItemSelected(item);\n-\t}\n-\n-\tpublic static enum STREAM_ENUM{\n-\t\tSTART_STREAMING, START_STREAMING_UI\n-\t}\n+import androidx.appcompat.app.AppCompatActivity;\n+\n+public class MainActivity extends AppCompatActivity {\n+\n+    @Override\n+    protected void onCreate(Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setContentView(R.layout.activity_main);\n+        //If we are connected to a module we want to start our SdlService\n+        if (BuildConfig.TRANSPORT.equals(\"MULTI\") || BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+            SdlReceiver.queryForConnectedService(this);\n+        } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+            Intent proxyIntent = new Intent(this, SdlService.class);\n+            startService(proxyIntent);\n+        }\n+    }\n+\n+    @Override\n+    public boolean onCreateOptionsMenu(Menu menu) {\n+        // Inflate the menu; this adds items to the action bar if it is present.\n+        getMenuInflater().inflate(R.menu.main, menu);\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean onOptionsItemSelected(MenuItem item) {\n+        // Handle action bar item clicks here. The action bar will\n+        // automatically handle clicks on the Home/Up button, so long\n+        // as you specify a parent activity in AndroidManifest.xml.\n+        int id = item.getItemId();\n+        if (id == R.id.action_settings) {\n+            return true;\n+        }\n+        return super.onOptionsItemSelected(item);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcxOTU2MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472719560", "bodyText": "This whole section is commented out including boilerplate calls to setVoiceCommands();``sendMenus(); performWelcomeSpeak();``performWelcomeShow();``preloadChoices();``subscribeToButtons(); .  Do these calls need to be made from anywhere else?", "author": "santhanamk", "createdAt": "2020-08-19T05:36:15Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java", "diffHunk": "@@ -166,31 +221,43 @@ private void startProxy() {\n \n \t\t\t// The app type to be used\n \t\t\tVector<AppHMIType> appType = new Vector<>();\n-\t\t\tappType.add(AppHMIType.DEFAULT);\n+\t\t\tappType.add(AppHMIType.NAVIGATION);\n \n \t\t\t// The manager listener helps you know when certain events that pertain to the SDL Manager happen\n \t\t\t// Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n \t\t\tSdlManagerListener listener = new SdlManagerListener() {\n \t\t\t\t@Override\n \t\t\t\tpublic void onStart() {\n-\t\t\t\t\t// HMI Status Listener\n-\t\t\t\t\tsdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-\t\t\t\t\t\t@Override\n-\t\t\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus)notification;\n-\t\t\t\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n-\t\t\t\t\t\t\t\tsetVoiceCommands();", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk4NDk1OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472984958", "bodyText": "@santhanamk removed", "author": "kboskin", "createdAt": "2020-08-19T12:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcxOTU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1NzI2Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473357267", "bodyText": "@kostyaBoss can you revert this change?  I think you should bring those back and leave it commented like before.", "author": "santhanamk", "createdAt": "2020-08-19T21:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcxOTU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5MTk5Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474791997", "bodyText": "@kostyaBoss Could you also bring back the methods and code for setVoiceCommands();, sendMenus();, performWelcomeSpeak();,  performWelcomeShow();, preloadChoices(); , subscribeToButtons();?  You can leave it commented out, but it can be there for reference.", "author": "santhanamk", "createdAt": "2020-08-21T16:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcxOTU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\nindex fab9cbb2c..0b83e0842 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n\n@@ -62,566 +51,402 @@ import com.smartdevicelink.util.DebugTool;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Vector;\n \n-import io.reactivex.functions.Consumer;\n-\n public class SdlService extends Service {\n \n-\tprivate static final String TAG \t\t\t\t\t= \"SDL Service\";\n-\n-\tprivate static final String APP_NAME \t\t\t\t= \"Hello Sdl\";\n-\tprivate static final String APP_NAME_ES \t\t\t= \"Hola Sdl\";\n-\tprivate static final String APP_NAME_FR \t\t\t= \"Bonjour Sdl\";\n-\tprivate static final String APP_ID \t\t\t\t\t= \"8678309\";\n-\n-\tprivate static final String ICON_FILENAME \t\t\t= \"hello_sdl_icon.png\";\n-\tprivate static final String SDL_IMAGE_FILENAME  \t= \"sdl_full_image.png\";\n-\n-\tprivate static final String WELCOME_SHOW \t\t\t= \"Welcome to HelloSDL\";\n-\tprivate static final String WELCOME_SPEAK \t\t\t= \"Welcome to Hello S D L\";\n-\n-\tprivate static final String TEST_COMMAND_NAME \t\t= \"Test Command\";\n-\n-\tprivate static final int FOREGROUND_SERVICE_ID = 111;\n-\n-\t// TCP/IP transport config\n-\t// The default port is 12345\n-\t// The IP is of the machine that is running SDL Core\n-\tprivate static final int TCP_PORT = 12345;\n-\tprivate static final String DEV_MACHINE_IP_ADDRESS = \"192.168.0.104\";\n-\n-\t// variable to create and call functions of the SyncProxy\n-\tprivate SdlManager sdlManager = null;\n-\tprivate List<ChoiceCell> choiceCellList;\n-\tMap<FunctionID, OnRPCNotificationListener> onRPCNotificationListenerMap = new HashMap<>();\n-\tpublic static final PublishRelay<MainActivity.STREAM_ENUM> relay = PublishRelay.create();\n-\n-\t@Override\n-\tpublic IBinder onBind(Intent intent) {\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic void onCreate() {\n-\t\tLog.d(TAG, \"onCreate\");\n-\t\tsuper.onCreate();\n-\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tenterForeground();\n-\t\t}\n-\t}\n-\n-\t// Helper method to let the service enter foreground mode\n-\t@SuppressLint(\"NewApi\")\n-\tpublic void enterForeground() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tNotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n-\t\t\tNotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n-\t\t\tif (notificationManager != null) {\n-\t\t\t\tnotificationManager.createNotificationChannel(channel);\n-\t\t\t\tNotification serviceNotification = new Notification.Builder(this, channel.getId())\n-\t\t\t\t\t\t.setContentTitle(\"Connected through SDL\")\n-\t\t\t\t\t\t.setSmallIcon(R.drawable.ic_sdl)\n-\t\t\t\t\t\t.build();\n-\t\t\t\tstartForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int onStartCommand(Intent intent, int flags, int startId) {\n-\t\tString ip = intent.getStringExtra(MainActivity.IP);\n-\t\tint port = intent.getIntExtra(MainActivity.PORT, 12345);\n-\t\tstartProxy(port, ip);\n-\n-\t\trelay.doOnNext(new Consumer<MainActivity.STREAM_ENUM>() {\n-\t\t\t@Override\n-\t\t\tpublic void accept(MainActivity.STREAM_ENUM stream_enum) throws Exception {\n-\t\t\t\tstartStreaming(stream_enum);\n-\t\t\t}\n-\t\t}).subscribe();\n-\t\treturn START_STICKY;\n-\t}\n-\n-\t@Override\n-\tpublic void onDestroy() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tstopForeground(true);\n-\t\t}\n-\n-\t\tif (sdlManager != null) {\n-\t\t\tsdlManager.dispose();\n-\t\t}\n-\n-\t\tsuper.onDestroy();\n-\t}\n-\n-\tprivate void startStreaming(final MainActivity.STREAM_ENUM value) {\n-\t\tif (sdlManager.getVideoStreamManager() != null) {\n-\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (success) {\n-\t\t\t\t\t\tClass myClass;\n-\t\t\t\t\t\tif (value.equals(MainActivity.STREAM_ENUM.START_STREAMING)) {\n-\t\t\t\t\t\t\tmyClass = MyDisplay.class;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmyClass = UIStreamingDisplay.class;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tVideoStreamingRange.Builder builder = new VideoStreamingRange.Builder();\n-\t\t\t\t\t\tbuilder\n-\t\t\t\t\t\t\t\t.setMaxSupportedResolution(new Resolution(800, 480))\n-\t\t\t\t\t\t\t\t.setMinSupportedResolution(new Resolution(400, 200))\n-\t\t\t\t\t\t\t\t.setAspectRatio(new AspectRatio(1., 6.))\n-\t\t\t\t\t\t\t\t.setMaxScreenDiagonal(20.);\n-\t\t\t\t\t\tVideoStreamingRange range = builder.build();\n-\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), myClass, null, false, range);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void startProxy(int port, String ip) {\n-\t\t// This logic is to select the correct transport and security levels defined in the selected build flavor\n-\t\t// Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n-\t\t// Typically in your app, you will only set one of these.\n-\t\tif (sdlManager == null) {\n-\t\t\tLog.i(TAG, \"Starting SDL Proxy\");\n-\t\t\t// Enable DebugTool for debug build type\n-\t\t\tif (BuildConfig.DEBUG){\n-\t\t\t\tDebugTool.enableDebugTool();\n-\t\t\t}\n-\t\t\tBaseTransportConfig transport = null;\n-\t\t\tif (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n-\t\t\t\tint securityLevel;\n-\t\t\t\tif (BuildConfig.SECURITY.equals(\"HIGH\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"MED\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n-\t\t\t\t} else {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n-\t\t\t\t}\n-\t\t\t\ttransport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\ttransport = new TCPTransportConfig(port, ip, true);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\tMultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n-\t\t\t\tmtc.setRequiresHighBandwidth(true);\n-\t\t\t\ttransport = mtc;\n-\t\t\t}\n-\n-\t\t\t// The app type to be used\n-\t\t\tVector<AppHMIType> appType = new Vector<>();\n-\t\t\tappType.add(AppHMIType.NAVIGATION);\n-\n-\t\t\t// The manager listener helps you know when certain events that pertain to the SDL Manager happen\n-\t\t\t// Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n-\t\t\tSdlManagerListener listener = new SdlManagerListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onStart() {\n-//\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null) {\n-//\n-//\t\t\t\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-//\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\tpublic void onComplete(boolean success) {\n-//\t\t\t\t\t\t\t\tif (success) {\n-//\t\t\t\t\t\t\t\t\tsdlManager.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING,\n-//\t\t\t\t\t\t\t\t\t\t\tnew OnSystemCapabilityListener() {\n-//\t\t\t\t\t\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\t\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tVideoStreamingCapability capability1 = (VideoStreamingCapability)capability;\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Diagonal: \" +  capability1.getDiagonalScreenSize());\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"PPI: \" +  capability1.getPixelPerInch());\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Scale: \" +  capability1.getScale());\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), MyDisplay.class, null, false);\n-//\t\t\t\t\t\t\t\t\t\t\t\t}\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\t\t\t\t\t\tpublic void onError(String info) {\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\t\t\t\t\t});\n-//\t\t\t\t\t\t\t\t} else {\n-//\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-//\t\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t});\n-//\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onDestroy() {\n-\t\t\t\t\tSdlService.this.stopSelf();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info, Exception e) {\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n-\t\t\t\t\tboolean isNeedUpdate = false;\n-\t\t\t\t\tString appName = APP_NAME;\n-\t\t\t\t\tString ttsName = APP_NAME;\n-\t\t\t\t\tswitch (language) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tswitch (hmiLanguage) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (isNeedUpdate) {\n-\t\t\t\t\t\treturn new LifecycleConfigurationUpdate(appName, null, TTSChunkFactory.createSimpleTTSChunks(ttsName), null);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t\t// Create App Icon, this is set in the SdlManager builder\n-\t\t\tSdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n-\n-\t\t\tonRPCNotificationListenerMap.put(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\t\tOnHMIStatus status = (OnHMIStatus) notification;\n-\t\t\t\t\tif (status != null && status.getHmiLevel() == HMILevel.HMI_NONE) {\n-\t\t\t\t\t\t//Stop the stream\n-\t\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null && sdlManager.getVideoStreamManager().isStreaming()) {\n-\t\t\t\t\t\t\tLog.d(\"OnHmiStatus\", \"stop streaming\");\n-\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().stopStreaming(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\t// The manager builder sets options for your session\n-\t\t\tSdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n-\t\t\tbuilder.setAppTypes(appType);\n-\t\t\tbuilder.setTransportType(transport);\n-\t\t\tbuilder.setAppIcon(appIcon);\n-\t\t\tbuilder.setRPCNotificationListeners(onRPCNotificationListenerMap);\n-\t\t\tsdlManager = builder.build();\n-\t\t\tsdlManager.start();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Send some voice commands\n-\t */\n-\tprivate void setVoiceCommands(){\n-\n-\t\tList<String> list1 = Collections.singletonList(\"Command One\");\n-\t\tList<String> list2 = Collections.singletonList(\"Command two\");\n-\n-\t\tVoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 1 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tVoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 2 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tsdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1,voiceCommand2));\n-\t}\n-\n-\t/**\n-\t *  Add menus for the app on SDL.\n-\t */\n-\tprivate void sendMenus(){\n-\n-\t\t// some arts\n-\t\tSdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n-\n-\t\t// some voice commands\n-\t\tList<String> voice2 = Collections.singletonList(\"Cell two\");\n-\n-\t\tMenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t\tshowTest();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// SUB MENU\n-\n-\t\tMenuCell subCell1 = new MenuCell(\"SubCell 1\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell subCell2 = new MenuCell(\"SubCell 2\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// sub menu parent cell\n-\t\tMenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", null, Arrays.asList(subCell1,subCell2));\n-\n-\t\tMenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tshowPerformInteraction();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell5 = new MenuCell(\"Clear the menu\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Clearing Menu. Source: \"+ trigger.toString());\n-\t\t\t\t// Clear this thing\n-\t\t\t\tsdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n-\t\t\t\tshowAlert(\"Menu Cleared\");\n-\t\t\t}\n-\t\t});\n-\n-\t\t// Send the entire menu off to be created\n-\t\tsdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n-\t}\n-\n-\t/**\n-\t * Will speak a sample welcome message\n-\t */\n-\tprivate void performWelcomeSpeak(){\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(WELCOME_SPEAK)));\n-\t}\n-\n-\t/**\n-\t * Use the Screen Manager to set the initial screen text and set the image.\n-\t * Because we are setting multiple items, we will call beginTransaction() first,\n-\t * and finish with commit() when we are done.\n-\t */\n-\tprivate void performWelcomeShow() {\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(APP_NAME);\n-\t\tsdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n-\t\tsdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n-\t\tsdlManager.getScreenManager().commit(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tif (success){\n-\t\t\t\t\tLog.i(TAG, \"welcome show successful\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * Attempts to Subscribe to all preset buttons\n-\t */\n-\tprivate void subscribeToButtons() {\n-\t\tButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n-\t\t\t\tButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n-\t\t\t\tButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n-\n-\t\tOnButtonListener onButtonListener = new OnButtonListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n-\t\t\t\tsdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n-\t\t\t\tsdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tLog.i(TAG, \"onError: \" + info);\n-\t\t\t}\n-\t\t};\n-\n-\t\tfor (ButtonName buttonName : buttonNames) {\n-\t\t\tsdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Will show a sample test message on screen as well as speak a sample test message\n-\t */\n-\tprivate void showTest(){\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n-\t\tsdlManager.getScreenManager().setTextField2(\"\");\n-\t\tsdlManager.getScreenManager().commit(null);\n-\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(TEST_COMMAND_NAME)));\n-\t}\n-\n-\tprivate void showAlert(String text){\n-\t\tAlert alert = new Alert();\n-\t\talert.setAlertText1(text);\n-\t\talert.setDuration(5000);\n-\t\tsdlManager.sendRPC(alert);\n-\t}\n-\n-\t// Choice Set\n-\n-\tprivate void preloadChoices(){\n-\t\tChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n-\t\tChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n-\t\tChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n-\t\tchoiceCellList = new ArrayList<>(Arrays.asList(cell1,cell2,cell3));\n-\t\tsdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n-\t}\n-\n-\tprivate void showPerformInteraction(){\n-\t\tif (choiceCellList != null) {\n-\t\t\tChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n-\t\t\t\t\tshowAlert(choiceCell.getText() + \" was selected\");\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String error) {\n-\t\t\t\t\tLog.e(TAG, \"There was an error showing the perform interaction: \"+ error);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tsdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n-\t\t}\n-\t}\n-\n-\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n-\t\tint clickCounter1 = 0;\n-\t\tint clickCounter2 = 0;\n-\t\tpublic UIStreamingDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.ui_streaming_layout);\n-\n-\n-\t\t\tfinal Button button1 = findViewById(R.id.button1);\n-\t\t\tfinal Button button2 = findViewById(R.id.button2);\n-\t\t\tfinal TextView counter1 = findViewById(R.id.button_one_counter);\n-\t\t\tfinal TextView counter2 = findViewById(R.id.button_two_counter);\n-            button1.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter1.setText(\"Click!!! \" + ++clickCounter1);\n-\t\t\t\t\tLog.d(\"MyTagClickCounter\", String.valueOf(clickCounter1));\n-\t\t\t\t\tint location [] = new int[2];\n-                    button1.getLocationInWindow(location);\n-                    //counter1.append(\"\\nButton size: \" + button1.getWidth() + \"x\" + button1.getHeight());\n-\t\t\t\t\t//textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\n-            button2.setOnTouchListener(new View.OnTouchListener() {\n+    private static final String TAG = \"SDL Service\";\n+\n+    private static final String APP_NAME = \"Hello Sdl\";\n+    private static final String APP_NAME_ES = \"Hola Sdl\";\n+    private static final String APP_NAME_FR = \"Bonjour Sdl\";\n+    private static final String APP_ID = \"8678309\";\n+\n+    private static final String ICON_FILENAME = \"hello_sdl_icon.png\";\n+    private static final String SDL_IMAGE_FILENAME = \"sdl_full_image.png\";\n+\n+    private static final String WELCOME_SHOW = \"Welcome to HelloSDL\";\n+    private static final String WELCOME_SPEAK = \"Welcome to Hello S D L\";\n+\n+    private static final String TEST_COMMAND_NAME = \"Test Command\";\n+\n+    private static final int FOREGROUND_SERVICE_ID = 111;\n+\n+    // TCP/IP transport config\n+    // The default port is 12345\n+    // The IP is of the machine that is running SDL Core\n+    private static final int TCP_PORT = 12247;\n+    private static final String DEV_MACHINE_IP_ADDRESS = \"m.sdl.tools\";\n+\n+    // variable to create and call functions of the SyncProxy\n+    private SdlManager sdlManager = null;\n+    private List<ChoiceCell> choiceCellList;\n+\n+    @Override\n+    public IBinder onBind(Intent intent) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void onCreate() {\n+        Log.d(TAG, \"onCreate\");\n+        super.onCreate();\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            enterForeground();\n+        }\n+    }\n+\n+    // Helper method to let the service enter foreground mode\n+    @SuppressLint(\"NewApi\")\n+    public void enterForeground() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            NotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n+            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n+            if (notificationManager != null) {\n+                notificationManager.createNotificationChannel(channel);\n+                Notification serviceNotification = new Notification.Builder(this, channel.getId())\n+                        .setContentTitle(\"Connected through SDL\")\n+                        .setSmallIcon(R.drawable.ic_sdl)\n+                        .build();\n+                startForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int onStartCommand(Intent intent, int flags, int startId) {\n+        startProxy();\n+        return START_STICKY;\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            stopForeground(true);\n+        }\n+\n+        if (sdlManager != null) {\n+            sdlManager.dispose();\n+        }\n+\n+        super.onDestroy();\n+    }\n+\n+    private void startProxy() {\n+        // This logic is to select the correct transport and security levels defined in the selected build flavor\n+        // Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n+        // Typically in your app, you will only set one of these.\n+        if (sdlManager == null) {\n+            Log.i(TAG, \"Starting SDL Proxy\");\n+            // Enable DebugTool for debug build type\n+            if (BuildConfig.DEBUG) {\n+                DebugTool.enableDebugTool();\n+            }\n+            BaseTransportConfig transport = null;\n+            if (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n+                int securityLevel;\n+                if (BuildConfig.SECURITY.equals(\"HIGH\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n+                } else if (BuildConfig.SECURITY.equals(\"MED\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n+                } else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n+                } else {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n+                }\n+                transport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n+            } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+                transport = new TCPTransportConfig(TCP_PORT, DEV_MACHINE_IP_ADDRESS, true);\n+            } else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+                MultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n+                mtc.setRequiresHighBandwidth(true);\n+                transport = mtc;\n+            }\n+\n+            // The app type to be used\n+            Vector<AppHMIType> appType = new Vector<>();\n+            appType.add(AppHMIType.DEFAULT);\n+\n+            // The manager listener helps you know when certain events that pertain to the SDL Manager happen\n+            // Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n+            SdlManagerListener listener = new SdlManagerListener() {\n+                @Override\n+                public void onStart() {\n+                    // HMI Status Listener\n+                    sdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n+                        @Override\n+                        public void onNotified(RPCNotification notification) {\n+                            OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                            if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                                return;\n+                            }\n+                            if (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n+                                setVoiceCommands();\n+                                sendMenus();\n+                                performWelcomeSpeak();\n+                                performWelcomeShow();\n+                                preloadChoices();\n+                                subscribeToButtons();\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onDestroy() {\n+                    SdlService.this.stopSelf();\n+                }\n+\n+                @Override\n+                public void onError(String info, Exception e) {\n+                }\n+\n+                @Override\n+                public LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n+                    boolean isNeedUpdate = false;\n+                    String appName = APP_NAME;\n+                    String ttsName = APP_NAME;\n+                    switch (language) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    switch (hmiLanguage) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    if (isNeedUpdate) {\n+                        Vector<TTSChunk> chunks = new Vector<>(Collections.singletonList(new TTSChunk(ttsName, SpeechCapabilities.TEXT)));\n+                        return new LifecycleConfigurationUpdate(appName, null, chunks, null);\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+            };\n+\n+            // Create App Icon, this is set in the SdlManager builder\n+            SdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n+\n+            // The manager builder sets options for your session\n+            SdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n+            builder.setAppTypes(appType);\n+            builder.setTransportType(transport);\n+            builder.setAppIcon(appIcon);\n+            sdlManager = builder.build();\n+            sdlManager.start();\n+        }\n+    }\n+\n+    /**\n+     * Send some voice commands\n+     */\n+    private void setVoiceCommands() {\n+\n+        List<String> list1 = Collections.singletonList(\"Command One\");\n+        List<String> list2 = Collections.singletonList(\"Command two\");\n+\n+        VoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 1 triggered\");\n+            }\n+        });\n+\n+        VoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 2 triggered\");\n+            }\n+        });\n+\n+        sdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1, voiceCommand2));\n+    }\n+\n+    /**\n+     * Add menus for the app on SDL.\n+     */\n+    private void sendMenus() {\n+\n+        // some arts\n+        SdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n+\n+        // some voice commands\n+        List<String> voice2 = Collections.singletonList(\"Cell two\");\n+\n+        MenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 1 triggered. Source: \" + trigger.toString());\n+                showTest();\n+            }\n+        });\n+\n+        MenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // SUB MENU\n+\n+        MenuCell subCell1 = new MenuCell(\"SubCell 1\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 1 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        MenuCell subCell2 = new MenuCell(\"SubCell 2\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // sub menu parent cell\n+        MenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", MenuLayout.LIST, null, Arrays.asList(subCell1, subCell2));\n+\n+        MenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                showPerformInteraction();\n+            }\n+        });\n+\n+        MenuCell mainCell5 = new MenuCell(\"Clear the menu\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Clearing Menu. Source: \" + trigger.toString());\n+                // Clear this thing\n+                sdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n+                showAlert(\"Menu Cleared\");\n+            }\n+        });\n+\n+        // Send the entire menu off to be created\n+        sdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n+    }\n+\n+    /**\n+     * Will speak a sample welcome message\n+     */\n+    private void performWelcomeSpeak() {\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(WELCOME_SPEAK, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    /**\n+     * Use the Screen Manager to set the initial screen text and set the image.\n+     * Because we are setting multiple items, we will call beginTransaction() first,\n+     * and finish with commit() when we are done.\n+     */\n+    private void performWelcomeShow() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(APP_NAME);\n+        sdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n+        sdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n+        sdlManager.getScreenManager().commit(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                if (success) {\n+                    Log.i(TAG, \"welcome show successful\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Attempts to Subscribe to all preset buttons\n+     */\n+    private void subscribeToButtons() {\n+        ButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n+                ButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n+                ButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n+\n+        OnButtonListener onButtonListener = new OnButtonListener() {\n+            @Override\n+            public void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n+                sdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n+            }\n+\n+            @Override\n+            public void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n+                sdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                Log.i(TAG, \"onError: \" + info);\n+            }\n+        };\n+\n+        for (ButtonName buttonName : buttonNames) {\n+            sdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n+        }\n+    }\n+\n+    /**\n+     * Will show a sample test message on screen as well as speak a sample test message\n+     */\n+    private void showTest() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n+        sdlManager.getScreenManager().setTextField2(\"\");\n+        sdlManager.getScreenManager().commit(null);\n+\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(TEST_COMMAND_NAME, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    private void showAlert(String text) {\n+        Alert alert = new Alert();\n+        alert.setAlertText1(text);\n+        alert.setDuration(5000);\n+        sdlManager.sendRPC(alert);\n+    }\n+\n+    // Choice Set\n+\n+    private void preloadChoices() {\n+        ChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n+        ChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n+        ChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n+        choiceCellList = new ArrayList<>(Arrays.asList(cell1, cell2, cell3));\n+        sdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n+    }\n+\n+    private void showPerformInteraction() {\n+        if (choiceCellList != null) {\n+            ChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n+                @Override\n+                public void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n+                    showAlert(choiceCell.getText() + \" was selected\");\n+                }\n+\n                 @Override\n-                public boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter2.setText(\"Click!!! \" + ++clickCounter2);\n-                    Log.d(\"MyTagClickCounter\", String.valueOf(clickCounter2));\n-                    int location [] = new int[2];\n-                    button2.getLocationInWindow(location);\n-                    //counter2.append(\"\\nButton size: \" + button.getWidth() + \"x\" + button.getHeight());\n-                    //textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-                    return false;\n+                public void onError(String error) {\n+                    Log.e(TAG, \"There was an error showing the perform interaction: \" + error);\n                 }\n             });\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n-\t}\n-\n-\tpublic static class MyDisplay extends SdlRemoteDisplay {\n-\t\tpublic MyDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.streaming_layout);\n-\n-\n-\t\t\tString videoUri = \"android.resource://\" + getContext().getPackageName() + \"/\" + R.raw.sdl;\n-\t\t\tfinal VideoView videoView = findViewById(R.id.videoView);\n-\t\t\tvideoView.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\t\t\t\t\tint[] location = new int[2];\n-\t\t\t\t\tvideoView.getLocationInWindow(location);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"View size \" + videoView.getWidth() + \"x\" + videoView.getHeight());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Location \" + location[0] + \" \" + location[1]);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Count: \" + motionEvent.getPointerCount());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Click(\" + motionEvent.getX() + \" \" + motionEvent.getY() + \" Raw \" + motionEvent.getRawX() + \" \" + motionEvent.getRawY());\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tvideoView.setVideoURI(Uri.parse(videoUri));\n-\t\t\tvideoView.start();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n+            sdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMTMyOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472721329", "bodyText": "Can the UIStreamingDisplay class be put into a separate file?", "author": "santhanamk", "createdAt": "2020-08-19T05:39:18Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java", "diffHunk": "@@ -450,4 +531,97 @@ public void onError(String error) {\n \t\t\tsdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n \t\t}\n \t}\n+\n+\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyODcyNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472928724", "bodyText": "@santhanamk this change is related more to demonstrate proposal implementation, rather than to a functional one. If it is required, I can separate this code, but, I believe, this should not go to the final release version and should be deleted. Though, it remains here right now in order to help everybody to acknowledge. Should I remove it now?", "author": "kboskin", "createdAt": "2020-08-19T10:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMTMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1Nzk4Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473357982", "bodyText": "@kostyaBoss If you think the code should be deleted, then you can go ahead and delete it.", "author": "santhanamk", "createdAt": "2020-08-19T21:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMTMyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\nindex fab9cbb2c..0b83e0842 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n\n@@ -62,566 +51,402 @@ import com.smartdevicelink.util.DebugTool;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Vector;\n \n-import io.reactivex.functions.Consumer;\n-\n public class SdlService extends Service {\n \n-\tprivate static final String TAG \t\t\t\t\t= \"SDL Service\";\n-\n-\tprivate static final String APP_NAME \t\t\t\t= \"Hello Sdl\";\n-\tprivate static final String APP_NAME_ES \t\t\t= \"Hola Sdl\";\n-\tprivate static final String APP_NAME_FR \t\t\t= \"Bonjour Sdl\";\n-\tprivate static final String APP_ID \t\t\t\t\t= \"8678309\";\n-\n-\tprivate static final String ICON_FILENAME \t\t\t= \"hello_sdl_icon.png\";\n-\tprivate static final String SDL_IMAGE_FILENAME  \t= \"sdl_full_image.png\";\n-\n-\tprivate static final String WELCOME_SHOW \t\t\t= \"Welcome to HelloSDL\";\n-\tprivate static final String WELCOME_SPEAK \t\t\t= \"Welcome to Hello S D L\";\n-\n-\tprivate static final String TEST_COMMAND_NAME \t\t= \"Test Command\";\n-\n-\tprivate static final int FOREGROUND_SERVICE_ID = 111;\n-\n-\t// TCP/IP transport config\n-\t// The default port is 12345\n-\t// The IP is of the machine that is running SDL Core\n-\tprivate static final int TCP_PORT = 12345;\n-\tprivate static final String DEV_MACHINE_IP_ADDRESS = \"192.168.0.104\";\n-\n-\t// variable to create and call functions of the SyncProxy\n-\tprivate SdlManager sdlManager = null;\n-\tprivate List<ChoiceCell> choiceCellList;\n-\tMap<FunctionID, OnRPCNotificationListener> onRPCNotificationListenerMap = new HashMap<>();\n-\tpublic static final PublishRelay<MainActivity.STREAM_ENUM> relay = PublishRelay.create();\n-\n-\t@Override\n-\tpublic IBinder onBind(Intent intent) {\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic void onCreate() {\n-\t\tLog.d(TAG, \"onCreate\");\n-\t\tsuper.onCreate();\n-\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tenterForeground();\n-\t\t}\n-\t}\n-\n-\t// Helper method to let the service enter foreground mode\n-\t@SuppressLint(\"NewApi\")\n-\tpublic void enterForeground() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tNotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n-\t\t\tNotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n-\t\t\tif (notificationManager != null) {\n-\t\t\t\tnotificationManager.createNotificationChannel(channel);\n-\t\t\t\tNotification serviceNotification = new Notification.Builder(this, channel.getId())\n-\t\t\t\t\t\t.setContentTitle(\"Connected through SDL\")\n-\t\t\t\t\t\t.setSmallIcon(R.drawable.ic_sdl)\n-\t\t\t\t\t\t.build();\n-\t\t\t\tstartForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int onStartCommand(Intent intent, int flags, int startId) {\n-\t\tString ip = intent.getStringExtra(MainActivity.IP);\n-\t\tint port = intent.getIntExtra(MainActivity.PORT, 12345);\n-\t\tstartProxy(port, ip);\n-\n-\t\trelay.doOnNext(new Consumer<MainActivity.STREAM_ENUM>() {\n-\t\t\t@Override\n-\t\t\tpublic void accept(MainActivity.STREAM_ENUM stream_enum) throws Exception {\n-\t\t\t\tstartStreaming(stream_enum);\n-\t\t\t}\n-\t\t}).subscribe();\n-\t\treturn START_STICKY;\n-\t}\n-\n-\t@Override\n-\tpublic void onDestroy() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tstopForeground(true);\n-\t\t}\n-\n-\t\tif (sdlManager != null) {\n-\t\t\tsdlManager.dispose();\n-\t\t}\n-\n-\t\tsuper.onDestroy();\n-\t}\n-\n-\tprivate void startStreaming(final MainActivity.STREAM_ENUM value) {\n-\t\tif (sdlManager.getVideoStreamManager() != null) {\n-\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (success) {\n-\t\t\t\t\t\tClass myClass;\n-\t\t\t\t\t\tif (value.equals(MainActivity.STREAM_ENUM.START_STREAMING)) {\n-\t\t\t\t\t\t\tmyClass = MyDisplay.class;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmyClass = UIStreamingDisplay.class;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tVideoStreamingRange.Builder builder = new VideoStreamingRange.Builder();\n-\t\t\t\t\t\tbuilder\n-\t\t\t\t\t\t\t\t.setMaxSupportedResolution(new Resolution(800, 480))\n-\t\t\t\t\t\t\t\t.setMinSupportedResolution(new Resolution(400, 200))\n-\t\t\t\t\t\t\t\t.setAspectRatio(new AspectRatio(1., 6.))\n-\t\t\t\t\t\t\t\t.setMaxScreenDiagonal(20.);\n-\t\t\t\t\t\tVideoStreamingRange range = builder.build();\n-\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), myClass, null, false, range);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void startProxy(int port, String ip) {\n-\t\t// This logic is to select the correct transport and security levels defined in the selected build flavor\n-\t\t// Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n-\t\t// Typically in your app, you will only set one of these.\n-\t\tif (sdlManager == null) {\n-\t\t\tLog.i(TAG, \"Starting SDL Proxy\");\n-\t\t\t// Enable DebugTool for debug build type\n-\t\t\tif (BuildConfig.DEBUG){\n-\t\t\t\tDebugTool.enableDebugTool();\n-\t\t\t}\n-\t\t\tBaseTransportConfig transport = null;\n-\t\t\tif (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n-\t\t\t\tint securityLevel;\n-\t\t\t\tif (BuildConfig.SECURITY.equals(\"HIGH\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"MED\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n-\t\t\t\t} else {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n-\t\t\t\t}\n-\t\t\t\ttransport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\ttransport = new TCPTransportConfig(port, ip, true);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\tMultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n-\t\t\t\tmtc.setRequiresHighBandwidth(true);\n-\t\t\t\ttransport = mtc;\n-\t\t\t}\n-\n-\t\t\t// The app type to be used\n-\t\t\tVector<AppHMIType> appType = new Vector<>();\n-\t\t\tappType.add(AppHMIType.NAVIGATION);\n-\n-\t\t\t// The manager listener helps you know when certain events that pertain to the SDL Manager happen\n-\t\t\t// Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n-\t\t\tSdlManagerListener listener = new SdlManagerListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onStart() {\n-//\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null) {\n-//\n-//\t\t\t\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-//\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\tpublic void onComplete(boolean success) {\n-//\t\t\t\t\t\t\t\tif (success) {\n-//\t\t\t\t\t\t\t\t\tsdlManager.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING,\n-//\t\t\t\t\t\t\t\t\t\t\tnew OnSystemCapabilityListener() {\n-//\t\t\t\t\t\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\t\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tVideoStreamingCapability capability1 = (VideoStreamingCapability)capability;\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Diagonal: \" +  capability1.getDiagonalScreenSize());\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"PPI: \" +  capability1.getPixelPerInch());\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Scale: \" +  capability1.getScale());\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), MyDisplay.class, null, false);\n-//\t\t\t\t\t\t\t\t\t\t\t\t}\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\t\t\t\t\t\tpublic void onError(String info) {\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\t\t\t\t\t});\n-//\t\t\t\t\t\t\t\t} else {\n-//\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-//\t\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t});\n-//\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onDestroy() {\n-\t\t\t\t\tSdlService.this.stopSelf();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info, Exception e) {\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n-\t\t\t\t\tboolean isNeedUpdate = false;\n-\t\t\t\t\tString appName = APP_NAME;\n-\t\t\t\t\tString ttsName = APP_NAME;\n-\t\t\t\t\tswitch (language) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tswitch (hmiLanguage) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (isNeedUpdate) {\n-\t\t\t\t\t\treturn new LifecycleConfigurationUpdate(appName, null, TTSChunkFactory.createSimpleTTSChunks(ttsName), null);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t\t// Create App Icon, this is set in the SdlManager builder\n-\t\t\tSdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n-\n-\t\t\tonRPCNotificationListenerMap.put(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\t\tOnHMIStatus status = (OnHMIStatus) notification;\n-\t\t\t\t\tif (status != null && status.getHmiLevel() == HMILevel.HMI_NONE) {\n-\t\t\t\t\t\t//Stop the stream\n-\t\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null && sdlManager.getVideoStreamManager().isStreaming()) {\n-\t\t\t\t\t\t\tLog.d(\"OnHmiStatus\", \"stop streaming\");\n-\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().stopStreaming(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\t// The manager builder sets options for your session\n-\t\t\tSdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n-\t\t\tbuilder.setAppTypes(appType);\n-\t\t\tbuilder.setTransportType(transport);\n-\t\t\tbuilder.setAppIcon(appIcon);\n-\t\t\tbuilder.setRPCNotificationListeners(onRPCNotificationListenerMap);\n-\t\t\tsdlManager = builder.build();\n-\t\t\tsdlManager.start();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Send some voice commands\n-\t */\n-\tprivate void setVoiceCommands(){\n-\n-\t\tList<String> list1 = Collections.singletonList(\"Command One\");\n-\t\tList<String> list2 = Collections.singletonList(\"Command two\");\n-\n-\t\tVoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 1 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tVoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 2 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tsdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1,voiceCommand2));\n-\t}\n-\n-\t/**\n-\t *  Add menus for the app on SDL.\n-\t */\n-\tprivate void sendMenus(){\n-\n-\t\t// some arts\n-\t\tSdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n-\n-\t\t// some voice commands\n-\t\tList<String> voice2 = Collections.singletonList(\"Cell two\");\n-\n-\t\tMenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t\tshowTest();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// SUB MENU\n-\n-\t\tMenuCell subCell1 = new MenuCell(\"SubCell 1\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell subCell2 = new MenuCell(\"SubCell 2\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// sub menu parent cell\n-\t\tMenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", null, Arrays.asList(subCell1,subCell2));\n-\n-\t\tMenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tshowPerformInteraction();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell5 = new MenuCell(\"Clear the menu\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Clearing Menu. Source: \"+ trigger.toString());\n-\t\t\t\t// Clear this thing\n-\t\t\t\tsdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n-\t\t\t\tshowAlert(\"Menu Cleared\");\n-\t\t\t}\n-\t\t});\n-\n-\t\t// Send the entire menu off to be created\n-\t\tsdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n-\t}\n-\n-\t/**\n-\t * Will speak a sample welcome message\n-\t */\n-\tprivate void performWelcomeSpeak(){\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(WELCOME_SPEAK)));\n-\t}\n-\n-\t/**\n-\t * Use the Screen Manager to set the initial screen text and set the image.\n-\t * Because we are setting multiple items, we will call beginTransaction() first,\n-\t * and finish with commit() when we are done.\n-\t */\n-\tprivate void performWelcomeShow() {\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(APP_NAME);\n-\t\tsdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n-\t\tsdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n-\t\tsdlManager.getScreenManager().commit(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tif (success){\n-\t\t\t\t\tLog.i(TAG, \"welcome show successful\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * Attempts to Subscribe to all preset buttons\n-\t */\n-\tprivate void subscribeToButtons() {\n-\t\tButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n-\t\t\t\tButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n-\t\t\t\tButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n-\n-\t\tOnButtonListener onButtonListener = new OnButtonListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n-\t\t\t\tsdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n-\t\t\t\tsdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tLog.i(TAG, \"onError: \" + info);\n-\t\t\t}\n-\t\t};\n-\n-\t\tfor (ButtonName buttonName : buttonNames) {\n-\t\t\tsdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Will show a sample test message on screen as well as speak a sample test message\n-\t */\n-\tprivate void showTest(){\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n-\t\tsdlManager.getScreenManager().setTextField2(\"\");\n-\t\tsdlManager.getScreenManager().commit(null);\n-\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(TEST_COMMAND_NAME)));\n-\t}\n-\n-\tprivate void showAlert(String text){\n-\t\tAlert alert = new Alert();\n-\t\talert.setAlertText1(text);\n-\t\talert.setDuration(5000);\n-\t\tsdlManager.sendRPC(alert);\n-\t}\n-\n-\t// Choice Set\n-\n-\tprivate void preloadChoices(){\n-\t\tChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n-\t\tChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n-\t\tChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n-\t\tchoiceCellList = new ArrayList<>(Arrays.asList(cell1,cell2,cell3));\n-\t\tsdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n-\t}\n-\n-\tprivate void showPerformInteraction(){\n-\t\tif (choiceCellList != null) {\n-\t\t\tChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n-\t\t\t\t\tshowAlert(choiceCell.getText() + \" was selected\");\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String error) {\n-\t\t\t\t\tLog.e(TAG, \"There was an error showing the perform interaction: \"+ error);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tsdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n-\t\t}\n-\t}\n-\n-\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n-\t\tint clickCounter1 = 0;\n-\t\tint clickCounter2 = 0;\n-\t\tpublic UIStreamingDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.ui_streaming_layout);\n-\n-\n-\t\t\tfinal Button button1 = findViewById(R.id.button1);\n-\t\t\tfinal Button button2 = findViewById(R.id.button2);\n-\t\t\tfinal TextView counter1 = findViewById(R.id.button_one_counter);\n-\t\t\tfinal TextView counter2 = findViewById(R.id.button_two_counter);\n-            button1.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter1.setText(\"Click!!! \" + ++clickCounter1);\n-\t\t\t\t\tLog.d(\"MyTagClickCounter\", String.valueOf(clickCounter1));\n-\t\t\t\t\tint location [] = new int[2];\n-                    button1.getLocationInWindow(location);\n-                    //counter1.append(\"\\nButton size: \" + button1.getWidth() + \"x\" + button1.getHeight());\n-\t\t\t\t\t//textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\n-            button2.setOnTouchListener(new View.OnTouchListener() {\n+    private static final String TAG = \"SDL Service\";\n+\n+    private static final String APP_NAME = \"Hello Sdl\";\n+    private static final String APP_NAME_ES = \"Hola Sdl\";\n+    private static final String APP_NAME_FR = \"Bonjour Sdl\";\n+    private static final String APP_ID = \"8678309\";\n+\n+    private static final String ICON_FILENAME = \"hello_sdl_icon.png\";\n+    private static final String SDL_IMAGE_FILENAME = \"sdl_full_image.png\";\n+\n+    private static final String WELCOME_SHOW = \"Welcome to HelloSDL\";\n+    private static final String WELCOME_SPEAK = \"Welcome to Hello S D L\";\n+\n+    private static final String TEST_COMMAND_NAME = \"Test Command\";\n+\n+    private static final int FOREGROUND_SERVICE_ID = 111;\n+\n+    // TCP/IP transport config\n+    // The default port is 12345\n+    // The IP is of the machine that is running SDL Core\n+    private static final int TCP_PORT = 12247;\n+    private static final String DEV_MACHINE_IP_ADDRESS = \"m.sdl.tools\";\n+\n+    // variable to create and call functions of the SyncProxy\n+    private SdlManager sdlManager = null;\n+    private List<ChoiceCell> choiceCellList;\n+\n+    @Override\n+    public IBinder onBind(Intent intent) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void onCreate() {\n+        Log.d(TAG, \"onCreate\");\n+        super.onCreate();\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            enterForeground();\n+        }\n+    }\n+\n+    // Helper method to let the service enter foreground mode\n+    @SuppressLint(\"NewApi\")\n+    public void enterForeground() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            NotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n+            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n+            if (notificationManager != null) {\n+                notificationManager.createNotificationChannel(channel);\n+                Notification serviceNotification = new Notification.Builder(this, channel.getId())\n+                        .setContentTitle(\"Connected through SDL\")\n+                        .setSmallIcon(R.drawable.ic_sdl)\n+                        .build();\n+                startForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int onStartCommand(Intent intent, int flags, int startId) {\n+        startProxy();\n+        return START_STICKY;\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            stopForeground(true);\n+        }\n+\n+        if (sdlManager != null) {\n+            sdlManager.dispose();\n+        }\n+\n+        super.onDestroy();\n+    }\n+\n+    private void startProxy() {\n+        // This logic is to select the correct transport and security levels defined in the selected build flavor\n+        // Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n+        // Typically in your app, you will only set one of these.\n+        if (sdlManager == null) {\n+            Log.i(TAG, \"Starting SDL Proxy\");\n+            // Enable DebugTool for debug build type\n+            if (BuildConfig.DEBUG) {\n+                DebugTool.enableDebugTool();\n+            }\n+            BaseTransportConfig transport = null;\n+            if (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n+                int securityLevel;\n+                if (BuildConfig.SECURITY.equals(\"HIGH\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n+                } else if (BuildConfig.SECURITY.equals(\"MED\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n+                } else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n+                } else {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n+                }\n+                transport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n+            } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+                transport = new TCPTransportConfig(TCP_PORT, DEV_MACHINE_IP_ADDRESS, true);\n+            } else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+                MultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n+                mtc.setRequiresHighBandwidth(true);\n+                transport = mtc;\n+            }\n+\n+            // The app type to be used\n+            Vector<AppHMIType> appType = new Vector<>();\n+            appType.add(AppHMIType.DEFAULT);\n+\n+            // The manager listener helps you know when certain events that pertain to the SDL Manager happen\n+            // Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n+            SdlManagerListener listener = new SdlManagerListener() {\n+                @Override\n+                public void onStart() {\n+                    // HMI Status Listener\n+                    sdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n+                        @Override\n+                        public void onNotified(RPCNotification notification) {\n+                            OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                            if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                                return;\n+                            }\n+                            if (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n+                                setVoiceCommands();\n+                                sendMenus();\n+                                performWelcomeSpeak();\n+                                performWelcomeShow();\n+                                preloadChoices();\n+                                subscribeToButtons();\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onDestroy() {\n+                    SdlService.this.stopSelf();\n+                }\n+\n+                @Override\n+                public void onError(String info, Exception e) {\n+                }\n+\n+                @Override\n+                public LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n+                    boolean isNeedUpdate = false;\n+                    String appName = APP_NAME;\n+                    String ttsName = APP_NAME;\n+                    switch (language) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    switch (hmiLanguage) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    if (isNeedUpdate) {\n+                        Vector<TTSChunk> chunks = new Vector<>(Collections.singletonList(new TTSChunk(ttsName, SpeechCapabilities.TEXT)));\n+                        return new LifecycleConfigurationUpdate(appName, null, chunks, null);\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+            };\n+\n+            // Create App Icon, this is set in the SdlManager builder\n+            SdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n+\n+            // The manager builder sets options for your session\n+            SdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n+            builder.setAppTypes(appType);\n+            builder.setTransportType(transport);\n+            builder.setAppIcon(appIcon);\n+            sdlManager = builder.build();\n+            sdlManager.start();\n+        }\n+    }\n+\n+    /**\n+     * Send some voice commands\n+     */\n+    private void setVoiceCommands() {\n+\n+        List<String> list1 = Collections.singletonList(\"Command One\");\n+        List<String> list2 = Collections.singletonList(\"Command two\");\n+\n+        VoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 1 triggered\");\n+            }\n+        });\n+\n+        VoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 2 triggered\");\n+            }\n+        });\n+\n+        sdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1, voiceCommand2));\n+    }\n+\n+    /**\n+     * Add menus for the app on SDL.\n+     */\n+    private void sendMenus() {\n+\n+        // some arts\n+        SdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n+\n+        // some voice commands\n+        List<String> voice2 = Collections.singletonList(\"Cell two\");\n+\n+        MenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 1 triggered. Source: \" + trigger.toString());\n+                showTest();\n+            }\n+        });\n+\n+        MenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // SUB MENU\n+\n+        MenuCell subCell1 = new MenuCell(\"SubCell 1\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 1 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        MenuCell subCell2 = new MenuCell(\"SubCell 2\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // sub menu parent cell\n+        MenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", MenuLayout.LIST, null, Arrays.asList(subCell1, subCell2));\n+\n+        MenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                showPerformInteraction();\n+            }\n+        });\n+\n+        MenuCell mainCell5 = new MenuCell(\"Clear the menu\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Clearing Menu. Source: \" + trigger.toString());\n+                // Clear this thing\n+                sdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n+                showAlert(\"Menu Cleared\");\n+            }\n+        });\n+\n+        // Send the entire menu off to be created\n+        sdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n+    }\n+\n+    /**\n+     * Will speak a sample welcome message\n+     */\n+    private void performWelcomeSpeak() {\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(WELCOME_SPEAK, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    /**\n+     * Use the Screen Manager to set the initial screen text and set the image.\n+     * Because we are setting multiple items, we will call beginTransaction() first,\n+     * and finish with commit() when we are done.\n+     */\n+    private void performWelcomeShow() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(APP_NAME);\n+        sdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n+        sdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n+        sdlManager.getScreenManager().commit(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                if (success) {\n+                    Log.i(TAG, \"welcome show successful\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Attempts to Subscribe to all preset buttons\n+     */\n+    private void subscribeToButtons() {\n+        ButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n+                ButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n+                ButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n+\n+        OnButtonListener onButtonListener = new OnButtonListener() {\n+            @Override\n+            public void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n+                sdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n+            }\n+\n+            @Override\n+            public void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n+                sdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                Log.i(TAG, \"onError: \" + info);\n+            }\n+        };\n+\n+        for (ButtonName buttonName : buttonNames) {\n+            sdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n+        }\n+    }\n+\n+    /**\n+     * Will show a sample test message on screen as well as speak a sample test message\n+     */\n+    private void showTest() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n+        sdlManager.getScreenManager().setTextField2(\"\");\n+        sdlManager.getScreenManager().commit(null);\n+\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(TEST_COMMAND_NAME, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    private void showAlert(String text) {\n+        Alert alert = new Alert();\n+        alert.setAlertText1(text);\n+        alert.setDuration(5000);\n+        sdlManager.sendRPC(alert);\n+    }\n+\n+    // Choice Set\n+\n+    private void preloadChoices() {\n+        ChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n+        ChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n+        ChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n+        choiceCellList = new ArrayList<>(Arrays.asList(cell1, cell2, cell3));\n+        sdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n+    }\n+\n+    private void showPerformInteraction() {\n+        if (choiceCellList != null) {\n+            ChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n+                @Override\n+                public void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n+                    showAlert(choiceCell.getText() + \" was selected\");\n+                }\n+\n                 @Override\n-                public boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter2.setText(\"Click!!! \" + ++clickCounter2);\n-                    Log.d(\"MyTagClickCounter\", String.valueOf(clickCounter2));\n-                    int location [] = new int[2];\n-                    button2.getLocationInWindow(location);\n-                    //counter2.append(\"\\nButton size: \" + button.getWidth() + \"x\" + button.getHeight());\n-                    //textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-                    return false;\n+                public void onError(String error) {\n+                    Log.e(TAG, \"There was an error showing the perform interaction: \" + error);\n                 }\n             });\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n-\t}\n-\n-\tpublic static class MyDisplay extends SdlRemoteDisplay {\n-\t\tpublic MyDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.streaming_layout);\n-\n-\n-\t\t\tString videoUri = \"android.resource://\" + getContext().getPackageName() + \"/\" + R.raw.sdl;\n-\t\t\tfinal VideoView videoView = findViewById(R.id.videoView);\n-\t\t\tvideoView.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\t\t\t\t\tint[] location = new int[2];\n-\t\t\t\t\tvideoView.getLocationInWindow(location);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"View size \" + videoView.getWidth() + \"x\" + videoView.getHeight());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Location \" + location[0] + \" \" + location[1]);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Count: \" + motionEvent.getPointerCount());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Click(\" + motionEvent.getX() + \" \" + motionEvent.getY() + \" Raw \" + motionEvent.getRawX() + \" \" + motionEvent.getRawY());\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tvideoView.setVideoURI(Uri.parse(videoUri));\n-\t\t\tvideoView.start();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n+            sdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMjI3OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472722279", "bodyText": "Instead of button1, button2, clickCounter1, clickCounter2 , counter1, and counter2 can more descriptive names be given to the variables in the source code and in the layout xml?", "author": "santhanamk", "createdAt": "2020-08-19T05:40:44Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java", "diffHunk": "@@ -450,4 +531,97 @@ public void onError(String error) {\n \t\t\tsdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n \t\t}\n \t}\n+\n+\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n+\t\tint clickCounter1 = 0;\n+\t\tint clickCounter2 = 0;\n+\t\tpublic UIStreamingDisplay(Context context, Display display) {\n+\t\t\tsuper(context, display);\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void onCreate(Bundle savedInstanceState) {\n+\t\t\tsuper.onCreate(savedInstanceState);\n+\t\t\tsetContentView(R.layout.ui_streaming_layout);\n+\n+\n+\t\t\tfinal Button button1 = findViewById(R.id.button1);", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1ODg3Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473358877", "bodyText": "Instead of button1, button2, clickCounter1, clickCounter2 , counter1, and counter2 can more descriptive names be given to the variables in the source code and in the layout xml?\n\n@kostyaBoss I still see the old variable names.  Can you change these to more descriptive names?", "author": "santhanamk", "createdAt": "2020-08-19T21:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMjI3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\nindex fab9cbb2c..0b83e0842 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n\n@@ -62,566 +51,402 @@ import com.smartdevicelink.util.DebugTool;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Vector;\n \n-import io.reactivex.functions.Consumer;\n-\n public class SdlService extends Service {\n \n-\tprivate static final String TAG \t\t\t\t\t= \"SDL Service\";\n-\n-\tprivate static final String APP_NAME \t\t\t\t= \"Hello Sdl\";\n-\tprivate static final String APP_NAME_ES \t\t\t= \"Hola Sdl\";\n-\tprivate static final String APP_NAME_FR \t\t\t= \"Bonjour Sdl\";\n-\tprivate static final String APP_ID \t\t\t\t\t= \"8678309\";\n-\n-\tprivate static final String ICON_FILENAME \t\t\t= \"hello_sdl_icon.png\";\n-\tprivate static final String SDL_IMAGE_FILENAME  \t= \"sdl_full_image.png\";\n-\n-\tprivate static final String WELCOME_SHOW \t\t\t= \"Welcome to HelloSDL\";\n-\tprivate static final String WELCOME_SPEAK \t\t\t= \"Welcome to Hello S D L\";\n-\n-\tprivate static final String TEST_COMMAND_NAME \t\t= \"Test Command\";\n-\n-\tprivate static final int FOREGROUND_SERVICE_ID = 111;\n-\n-\t// TCP/IP transport config\n-\t// The default port is 12345\n-\t// The IP is of the machine that is running SDL Core\n-\tprivate static final int TCP_PORT = 12345;\n-\tprivate static final String DEV_MACHINE_IP_ADDRESS = \"192.168.0.104\";\n-\n-\t// variable to create and call functions of the SyncProxy\n-\tprivate SdlManager sdlManager = null;\n-\tprivate List<ChoiceCell> choiceCellList;\n-\tMap<FunctionID, OnRPCNotificationListener> onRPCNotificationListenerMap = new HashMap<>();\n-\tpublic static final PublishRelay<MainActivity.STREAM_ENUM> relay = PublishRelay.create();\n-\n-\t@Override\n-\tpublic IBinder onBind(Intent intent) {\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic void onCreate() {\n-\t\tLog.d(TAG, \"onCreate\");\n-\t\tsuper.onCreate();\n-\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tenterForeground();\n-\t\t}\n-\t}\n-\n-\t// Helper method to let the service enter foreground mode\n-\t@SuppressLint(\"NewApi\")\n-\tpublic void enterForeground() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tNotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n-\t\t\tNotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n-\t\t\tif (notificationManager != null) {\n-\t\t\t\tnotificationManager.createNotificationChannel(channel);\n-\t\t\t\tNotification serviceNotification = new Notification.Builder(this, channel.getId())\n-\t\t\t\t\t\t.setContentTitle(\"Connected through SDL\")\n-\t\t\t\t\t\t.setSmallIcon(R.drawable.ic_sdl)\n-\t\t\t\t\t\t.build();\n-\t\t\t\tstartForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int onStartCommand(Intent intent, int flags, int startId) {\n-\t\tString ip = intent.getStringExtra(MainActivity.IP);\n-\t\tint port = intent.getIntExtra(MainActivity.PORT, 12345);\n-\t\tstartProxy(port, ip);\n-\n-\t\trelay.doOnNext(new Consumer<MainActivity.STREAM_ENUM>() {\n-\t\t\t@Override\n-\t\t\tpublic void accept(MainActivity.STREAM_ENUM stream_enum) throws Exception {\n-\t\t\t\tstartStreaming(stream_enum);\n-\t\t\t}\n-\t\t}).subscribe();\n-\t\treturn START_STICKY;\n-\t}\n-\n-\t@Override\n-\tpublic void onDestroy() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tstopForeground(true);\n-\t\t}\n-\n-\t\tif (sdlManager != null) {\n-\t\t\tsdlManager.dispose();\n-\t\t}\n-\n-\t\tsuper.onDestroy();\n-\t}\n-\n-\tprivate void startStreaming(final MainActivity.STREAM_ENUM value) {\n-\t\tif (sdlManager.getVideoStreamManager() != null) {\n-\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (success) {\n-\t\t\t\t\t\tClass myClass;\n-\t\t\t\t\t\tif (value.equals(MainActivity.STREAM_ENUM.START_STREAMING)) {\n-\t\t\t\t\t\t\tmyClass = MyDisplay.class;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmyClass = UIStreamingDisplay.class;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tVideoStreamingRange.Builder builder = new VideoStreamingRange.Builder();\n-\t\t\t\t\t\tbuilder\n-\t\t\t\t\t\t\t\t.setMaxSupportedResolution(new Resolution(800, 480))\n-\t\t\t\t\t\t\t\t.setMinSupportedResolution(new Resolution(400, 200))\n-\t\t\t\t\t\t\t\t.setAspectRatio(new AspectRatio(1., 6.))\n-\t\t\t\t\t\t\t\t.setMaxScreenDiagonal(20.);\n-\t\t\t\t\t\tVideoStreamingRange range = builder.build();\n-\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), myClass, null, false, range);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void startProxy(int port, String ip) {\n-\t\t// This logic is to select the correct transport and security levels defined in the selected build flavor\n-\t\t// Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n-\t\t// Typically in your app, you will only set one of these.\n-\t\tif (sdlManager == null) {\n-\t\t\tLog.i(TAG, \"Starting SDL Proxy\");\n-\t\t\t// Enable DebugTool for debug build type\n-\t\t\tif (BuildConfig.DEBUG){\n-\t\t\t\tDebugTool.enableDebugTool();\n-\t\t\t}\n-\t\t\tBaseTransportConfig transport = null;\n-\t\t\tif (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n-\t\t\t\tint securityLevel;\n-\t\t\t\tif (BuildConfig.SECURITY.equals(\"HIGH\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"MED\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n-\t\t\t\t} else {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n-\t\t\t\t}\n-\t\t\t\ttransport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\ttransport = new TCPTransportConfig(port, ip, true);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\tMultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n-\t\t\t\tmtc.setRequiresHighBandwidth(true);\n-\t\t\t\ttransport = mtc;\n-\t\t\t}\n-\n-\t\t\t// The app type to be used\n-\t\t\tVector<AppHMIType> appType = new Vector<>();\n-\t\t\tappType.add(AppHMIType.NAVIGATION);\n-\n-\t\t\t// The manager listener helps you know when certain events that pertain to the SDL Manager happen\n-\t\t\t// Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n-\t\t\tSdlManagerListener listener = new SdlManagerListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onStart() {\n-//\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null) {\n-//\n-//\t\t\t\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-//\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\tpublic void onComplete(boolean success) {\n-//\t\t\t\t\t\t\t\tif (success) {\n-//\t\t\t\t\t\t\t\t\tsdlManager.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING,\n-//\t\t\t\t\t\t\t\t\t\t\tnew OnSystemCapabilityListener() {\n-//\t\t\t\t\t\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\t\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tVideoStreamingCapability capability1 = (VideoStreamingCapability)capability;\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Diagonal: \" +  capability1.getDiagonalScreenSize());\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"PPI: \" +  capability1.getPixelPerInch());\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Scale: \" +  capability1.getScale());\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), MyDisplay.class, null, false);\n-//\t\t\t\t\t\t\t\t\t\t\t\t}\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\t\t\t\t\t\tpublic void onError(String info) {\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\t\t\t\t\t});\n-//\t\t\t\t\t\t\t\t} else {\n-//\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-//\t\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t});\n-//\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onDestroy() {\n-\t\t\t\t\tSdlService.this.stopSelf();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info, Exception e) {\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n-\t\t\t\t\tboolean isNeedUpdate = false;\n-\t\t\t\t\tString appName = APP_NAME;\n-\t\t\t\t\tString ttsName = APP_NAME;\n-\t\t\t\t\tswitch (language) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tswitch (hmiLanguage) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (isNeedUpdate) {\n-\t\t\t\t\t\treturn new LifecycleConfigurationUpdate(appName, null, TTSChunkFactory.createSimpleTTSChunks(ttsName), null);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t\t// Create App Icon, this is set in the SdlManager builder\n-\t\t\tSdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n-\n-\t\t\tonRPCNotificationListenerMap.put(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\t\tOnHMIStatus status = (OnHMIStatus) notification;\n-\t\t\t\t\tif (status != null && status.getHmiLevel() == HMILevel.HMI_NONE) {\n-\t\t\t\t\t\t//Stop the stream\n-\t\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null && sdlManager.getVideoStreamManager().isStreaming()) {\n-\t\t\t\t\t\t\tLog.d(\"OnHmiStatus\", \"stop streaming\");\n-\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().stopStreaming(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\t// The manager builder sets options for your session\n-\t\t\tSdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n-\t\t\tbuilder.setAppTypes(appType);\n-\t\t\tbuilder.setTransportType(transport);\n-\t\t\tbuilder.setAppIcon(appIcon);\n-\t\t\tbuilder.setRPCNotificationListeners(onRPCNotificationListenerMap);\n-\t\t\tsdlManager = builder.build();\n-\t\t\tsdlManager.start();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Send some voice commands\n-\t */\n-\tprivate void setVoiceCommands(){\n-\n-\t\tList<String> list1 = Collections.singletonList(\"Command One\");\n-\t\tList<String> list2 = Collections.singletonList(\"Command two\");\n-\n-\t\tVoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 1 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tVoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 2 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tsdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1,voiceCommand2));\n-\t}\n-\n-\t/**\n-\t *  Add menus for the app on SDL.\n-\t */\n-\tprivate void sendMenus(){\n-\n-\t\t// some arts\n-\t\tSdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n-\n-\t\t// some voice commands\n-\t\tList<String> voice2 = Collections.singletonList(\"Cell two\");\n-\n-\t\tMenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t\tshowTest();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// SUB MENU\n-\n-\t\tMenuCell subCell1 = new MenuCell(\"SubCell 1\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell subCell2 = new MenuCell(\"SubCell 2\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// sub menu parent cell\n-\t\tMenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", null, Arrays.asList(subCell1,subCell2));\n-\n-\t\tMenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tshowPerformInteraction();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell5 = new MenuCell(\"Clear the menu\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Clearing Menu. Source: \"+ trigger.toString());\n-\t\t\t\t// Clear this thing\n-\t\t\t\tsdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n-\t\t\t\tshowAlert(\"Menu Cleared\");\n-\t\t\t}\n-\t\t});\n-\n-\t\t// Send the entire menu off to be created\n-\t\tsdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n-\t}\n-\n-\t/**\n-\t * Will speak a sample welcome message\n-\t */\n-\tprivate void performWelcomeSpeak(){\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(WELCOME_SPEAK)));\n-\t}\n-\n-\t/**\n-\t * Use the Screen Manager to set the initial screen text and set the image.\n-\t * Because we are setting multiple items, we will call beginTransaction() first,\n-\t * and finish with commit() when we are done.\n-\t */\n-\tprivate void performWelcomeShow() {\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(APP_NAME);\n-\t\tsdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n-\t\tsdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n-\t\tsdlManager.getScreenManager().commit(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tif (success){\n-\t\t\t\t\tLog.i(TAG, \"welcome show successful\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * Attempts to Subscribe to all preset buttons\n-\t */\n-\tprivate void subscribeToButtons() {\n-\t\tButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n-\t\t\t\tButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n-\t\t\t\tButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n-\n-\t\tOnButtonListener onButtonListener = new OnButtonListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n-\t\t\t\tsdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n-\t\t\t\tsdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tLog.i(TAG, \"onError: \" + info);\n-\t\t\t}\n-\t\t};\n-\n-\t\tfor (ButtonName buttonName : buttonNames) {\n-\t\t\tsdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Will show a sample test message on screen as well as speak a sample test message\n-\t */\n-\tprivate void showTest(){\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n-\t\tsdlManager.getScreenManager().setTextField2(\"\");\n-\t\tsdlManager.getScreenManager().commit(null);\n-\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(TEST_COMMAND_NAME)));\n-\t}\n-\n-\tprivate void showAlert(String text){\n-\t\tAlert alert = new Alert();\n-\t\talert.setAlertText1(text);\n-\t\talert.setDuration(5000);\n-\t\tsdlManager.sendRPC(alert);\n-\t}\n-\n-\t// Choice Set\n-\n-\tprivate void preloadChoices(){\n-\t\tChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n-\t\tChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n-\t\tChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n-\t\tchoiceCellList = new ArrayList<>(Arrays.asList(cell1,cell2,cell3));\n-\t\tsdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n-\t}\n-\n-\tprivate void showPerformInteraction(){\n-\t\tif (choiceCellList != null) {\n-\t\t\tChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n-\t\t\t\t\tshowAlert(choiceCell.getText() + \" was selected\");\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String error) {\n-\t\t\t\t\tLog.e(TAG, \"There was an error showing the perform interaction: \"+ error);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tsdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n-\t\t}\n-\t}\n-\n-\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n-\t\tint clickCounter1 = 0;\n-\t\tint clickCounter2 = 0;\n-\t\tpublic UIStreamingDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.ui_streaming_layout);\n-\n-\n-\t\t\tfinal Button button1 = findViewById(R.id.button1);\n-\t\t\tfinal Button button2 = findViewById(R.id.button2);\n-\t\t\tfinal TextView counter1 = findViewById(R.id.button_one_counter);\n-\t\t\tfinal TextView counter2 = findViewById(R.id.button_two_counter);\n-            button1.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter1.setText(\"Click!!! \" + ++clickCounter1);\n-\t\t\t\t\tLog.d(\"MyTagClickCounter\", String.valueOf(clickCounter1));\n-\t\t\t\t\tint location [] = new int[2];\n-                    button1.getLocationInWindow(location);\n-                    //counter1.append(\"\\nButton size: \" + button1.getWidth() + \"x\" + button1.getHeight());\n-\t\t\t\t\t//textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\n-            button2.setOnTouchListener(new View.OnTouchListener() {\n+    private static final String TAG = \"SDL Service\";\n+\n+    private static final String APP_NAME = \"Hello Sdl\";\n+    private static final String APP_NAME_ES = \"Hola Sdl\";\n+    private static final String APP_NAME_FR = \"Bonjour Sdl\";\n+    private static final String APP_ID = \"8678309\";\n+\n+    private static final String ICON_FILENAME = \"hello_sdl_icon.png\";\n+    private static final String SDL_IMAGE_FILENAME = \"sdl_full_image.png\";\n+\n+    private static final String WELCOME_SHOW = \"Welcome to HelloSDL\";\n+    private static final String WELCOME_SPEAK = \"Welcome to Hello S D L\";\n+\n+    private static final String TEST_COMMAND_NAME = \"Test Command\";\n+\n+    private static final int FOREGROUND_SERVICE_ID = 111;\n+\n+    // TCP/IP transport config\n+    // The default port is 12345\n+    // The IP is of the machine that is running SDL Core\n+    private static final int TCP_PORT = 12247;\n+    private static final String DEV_MACHINE_IP_ADDRESS = \"m.sdl.tools\";\n+\n+    // variable to create and call functions of the SyncProxy\n+    private SdlManager sdlManager = null;\n+    private List<ChoiceCell> choiceCellList;\n+\n+    @Override\n+    public IBinder onBind(Intent intent) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void onCreate() {\n+        Log.d(TAG, \"onCreate\");\n+        super.onCreate();\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            enterForeground();\n+        }\n+    }\n+\n+    // Helper method to let the service enter foreground mode\n+    @SuppressLint(\"NewApi\")\n+    public void enterForeground() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            NotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n+            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n+            if (notificationManager != null) {\n+                notificationManager.createNotificationChannel(channel);\n+                Notification serviceNotification = new Notification.Builder(this, channel.getId())\n+                        .setContentTitle(\"Connected through SDL\")\n+                        .setSmallIcon(R.drawable.ic_sdl)\n+                        .build();\n+                startForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int onStartCommand(Intent intent, int flags, int startId) {\n+        startProxy();\n+        return START_STICKY;\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            stopForeground(true);\n+        }\n+\n+        if (sdlManager != null) {\n+            sdlManager.dispose();\n+        }\n+\n+        super.onDestroy();\n+    }\n+\n+    private void startProxy() {\n+        // This logic is to select the correct transport and security levels defined in the selected build flavor\n+        // Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n+        // Typically in your app, you will only set one of these.\n+        if (sdlManager == null) {\n+            Log.i(TAG, \"Starting SDL Proxy\");\n+            // Enable DebugTool for debug build type\n+            if (BuildConfig.DEBUG) {\n+                DebugTool.enableDebugTool();\n+            }\n+            BaseTransportConfig transport = null;\n+            if (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n+                int securityLevel;\n+                if (BuildConfig.SECURITY.equals(\"HIGH\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n+                } else if (BuildConfig.SECURITY.equals(\"MED\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n+                } else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n+                } else {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n+                }\n+                transport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n+            } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+                transport = new TCPTransportConfig(TCP_PORT, DEV_MACHINE_IP_ADDRESS, true);\n+            } else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+                MultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n+                mtc.setRequiresHighBandwidth(true);\n+                transport = mtc;\n+            }\n+\n+            // The app type to be used\n+            Vector<AppHMIType> appType = new Vector<>();\n+            appType.add(AppHMIType.DEFAULT);\n+\n+            // The manager listener helps you know when certain events that pertain to the SDL Manager happen\n+            // Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n+            SdlManagerListener listener = new SdlManagerListener() {\n+                @Override\n+                public void onStart() {\n+                    // HMI Status Listener\n+                    sdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n+                        @Override\n+                        public void onNotified(RPCNotification notification) {\n+                            OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                            if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                                return;\n+                            }\n+                            if (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n+                                setVoiceCommands();\n+                                sendMenus();\n+                                performWelcomeSpeak();\n+                                performWelcomeShow();\n+                                preloadChoices();\n+                                subscribeToButtons();\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onDestroy() {\n+                    SdlService.this.stopSelf();\n+                }\n+\n+                @Override\n+                public void onError(String info, Exception e) {\n+                }\n+\n+                @Override\n+                public LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n+                    boolean isNeedUpdate = false;\n+                    String appName = APP_NAME;\n+                    String ttsName = APP_NAME;\n+                    switch (language) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    switch (hmiLanguage) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    if (isNeedUpdate) {\n+                        Vector<TTSChunk> chunks = new Vector<>(Collections.singletonList(new TTSChunk(ttsName, SpeechCapabilities.TEXT)));\n+                        return new LifecycleConfigurationUpdate(appName, null, chunks, null);\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+            };\n+\n+            // Create App Icon, this is set in the SdlManager builder\n+            SdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n+\n+            // The manager builder sets options for your session\n+            SdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n+            builder.setAppTypes(appType);\n+            builder.setTransportType(transport);\n+            builder.setAppIcon(appIcon);\n+            sdlManager = builder.build();\n+            sdlManager.start();\n+        }\n+    }\n+\n+    /**\n+     * Send some voice commands\n+     */\n+    private void setVoiceCommands() {\n+\n+        List<String> list1 = Collections.singletonList(\"Command One\");\n+        List<String> list2 = Collections.singletonList(\"Command two\");\n+\n+        VoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 1 triggered\");\n+            }\n+        });\n+\n+        VoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 2 triggered\");\n+            }\n+        });\n+\n+        sdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1, voiceCommand2));\n+    }\n+\n+    /**\n+     * Add menus for the app on SDL.\n+     */\n+    private void sendMenus() {\n+\n+        // some arts\n+        SdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n+\n+        // some voice commands\n+        List<String> voice2 = Collections.singletonList(\"Cell two\");\n+\n+        MenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 1 triggered. Source: \" + trigger.toString());\n+                showTest();\n+            }\n+        });\n+\n+        MenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // SUB MENU\n+\n+        MenuCell subCell1 = new MenuCell(\"SubCell 1\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 1 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        MenuCell subCell2 = new MenuCell(\"SubCell 2\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // sub menu parent cell\n+        MenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", MenuLayout.LIST, null, Arrays.asList(subCell1, subCell2));\n+\n+        MenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                showPerformInteraction();\n+            }\n+        });\n+\n+        MenuCell mainCell5 = new MenuCell(\"Clear the menu\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Clearing Menu. Source: \" + trigger.toString());\n+                // Clear this thing\n+                sdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n+                showAlert(\"Menu Cleared\");\n+            }\n+        });\n+\n+        // Send the entire menu off to be created\n+        sdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n+    }\n+\n+    /**\n+     * Will speak a sample welcome message\n+     */\n+    private void performWelcomeSpeak() {\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(WELCOME_SPEAK, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    /**\n+     * Use the Screen Manager to set the initial screen text and set the image.\n+     * Because we are setting multiple items, we will call beginTransaction() first,\n+     * and finish with commit() when we are done.\n+     */\n+    private void performWelcomeShow() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(APP_NAME);\n+        sdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n+        sdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n+        sdlManager.getScreenManager().commit(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                if (success) {\n+                    Log.i(TAG, \"welcome show successful\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Attempts to Subscribe to all preset buttons\n+     */\n+    private void subscribeToButtons() {\n+        ButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n+                ButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n+                ButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n+\n+        OnButtonListener onButtonListener = new OnButtonListener() {\n+            @Override\n+            public void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n+                sdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n+            }\n+\n+            @Override\n+            public void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n+                sdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                Log.i(TAG, \"onError: \" + info);\n+            }\n+        };\n+\n+        for (ButtonName buttonName : buttonNames) {\n+            sdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n+        }\n+    }\n+\n+    /**\n+     * Will show a sample test message on screen as well as speak a sample test message\n+     */\n+    private void showTest() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n+        sdlManager.getScreenManager().setTextField2(\"\");\n+        sdlManager.getScreenManager().commit(null);\n+\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(TEST_COMMAND_NAME, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    private void showAlert(String text) {\n+        Alert alert = new Alert();\n+        alert.setAlertText1(text);\n+        alert.setDuration(5000);\n+        sdlManager.sendRPC(alert);\n+    }\n+\n+    // Choice Set\n+\n+    private void preloadChoices() {\n+        ChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n+        ChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n+        ChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n+        choiceCellList = new ArrayList<>(Arrays.asList(cell1, cell2, cell3));\n+        sdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n+    }\n+\n+    private void showPerformInteraction() {\n+        if (choiceCellList != null) {\n+            ChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n+                @Override\n+                public void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n+                    showAlert(choiceCell.getText() + \" was selected\");\n+                }\n+\n                 @Override\n-                public boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter2.setText(\"Click!!! \" + ++clickCounter2);\n-                    Log.d(\"MyTagClickCounter\", String.valueOf(clickCounter2));\n-                    int location [] = new int[2];\n-                    button2.getLocationInWindow(location);\n-                    //counter2.append(\"\\nButton size: \" + button.getWidth() + \"x\" + button.getHeight());\n-                    //textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-                    return false;\n+                public void onError(String error) {\n+                    Log.e(TAG, \"There was an error showing the perform interaction: \" + error);\n                 }\n             });\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n-\t}\n-\n-\tpublic static class MyDisplay extends SdlRemoteDisplay {\n-\t\tpublic MyDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.streaming_layout);\n-\n-\n-\t\t\tString videoUri = \"android.resource://\" + getContext().getPackageName() + \"/\" + R.raw.sdl;\n-\t\t\tfinal VideoView videoView = findViewById(R.id.videoView);\n-\t\t\tvideoView.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\t\t\t\t\tint[] location = new int[2];\n-\t\t\t\t\tvideoView.getLocationInWindow(location);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"View size \" + videoView.getWidth() + \"x\" + videoView.getHeight());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Location \" + location[0] + \" \" + location[1]);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Count: \" + motionEvent.getPointerCount());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Click(\" + motionEvent.getX() + \" \" + motionEvent.getY() + \" Raw \" + motionEvent.getRawX() + \" \" + motionEvent.getRawY());\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tvideoView.setVideoURI(Uri.parse(videoUri));\n-\t\t\tvideoView.start();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n+            sdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzg2OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472723869", "bodyText": "Can the MyDisplay class be put into its own separate file?", "author": "santhanamk", "createdAt": "2020-08-19T05:43:05Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java", "diffHunk": "@@ -450,4 +531,97 @@ public void onError(String error) {\n \t\t\tsdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n \t\t}\n \t}\n+\n+\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n+\t\tint clickCounter1 = 0;\n+\t\tint clickCounter2 = 0;\n+\t\tpublic UIStreamingDisplay(Context context, Display display) {\n+\t\t\tsuper(context, display);\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void onCreate(Bundle savedInstanceState) {\n+\t\t\tsuper.onCreate(savedInstanceState);\n+\t\t\tsetContentView(R.layout.ui_streaming_layout);\n+\n+\n+\t\t\tfinal Button button1 = findViewById(R.id.button1);\n+\t\t\tfinal Button button2 = findViewById(R.id.button2);\n+\t\t\tfinal TextView counter1 = findViewById(R.id.button_one_counter);\n+\t\t\tfinal TextView counter2 = findViewById(R.id.button_two_counter);\n+            button1.setOnTouchListener(new View.OnTouchListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n+\n+                    counter1.setText(\"Click!!! \" + ++clickCounter1);\n+\t\t\t\t\tLog.d(\"MyTagClickCounter\", String.valueOf(clickCounter1));\n+\t\t\t\t\tint location [] = new int[2];\n+                    button1.getLocationInWindow(location);\n+                    //counter1.append(\"\\nButton size: \" + button1.getWidth() + \"x\" + button1.getHeight());\n+\t\t\t\t\t//textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t});\n+\n+            button2.setOnTouchListener(new View.OnTouchListener() {\n+                @Override\n+                public boolean onTouch(View view, MotionEvent motionEvent) {\n+\n+                    counter2.setText(\"Click!!! \" + ++clickCounter2);\n+                    Log.d(\"MyTagClickCounter\", String.valueOf(clickCounter2));\n+                    int location [] = new int[2];\n+                    button2.getLocationInWindow(location);\n+                    //counter2.append(\"\\nButton size: \" + button.getWidth() + \"x\" + button.getHeight());\n+                    //textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n+                    return false;\n+                }\n+            });\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onViewResized(int width, int height) {\n+\t\t\tToast.makeText(getContext(),\n+\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n+\t\t\t\t\tToast.LENGTH_SHORT\n+\t\t\t).show();\n+\t\t}\n+\t}\n+\n+\tpublic static class MyDisplay extends SdlRemoteDisplay {", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyODkwNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472928907", "bodyText": "@santhanamk this change is related more to demonstrate proposal implementation, rather than to a functional one. If it is required, I can separate this code, but, I believe, this should not go to the final release version and should be deleted. Though, it remains here right now in order to help everybody to acknowledge. Should I remove it now?", "author": "kboskin", "createdAt": "2020-08-19T10:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1OTIzOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473359238", "bodyText": "@kostyaBoss If you think the class can be deleted, then you can go ahead and delete it.", "author": "santhanamk", "createdAt": "2020-08-19T21:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMzg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\nindex fab9cbb2c..0b83e0842 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n\n@@ -62,566 +51,402 @@ import com.smartdevicelink.util.DebugTool;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Vector;\n \n-import io.reactivex.functions.Consumer;\n-\n public class SdlService extends Service {\n \n-\tprivate static final String TAG \t\t\t\t\t= \"SDL Service\";\n-\n-\tprivate static final String APP_NAME \t\t\t\t= \"Hello Sdl\";\n-\tprivate static final String APP_NAME_ES \t\t\t= \"Hola Sdl\";\n-\tprivate static final String APP_NAME_FR \t\t\t= \"Bonjour Sdl\";\n-\tprivate static final String APP_ID \t\t\t\t\t= \"8678309\";\n-\n-\tprivate static final String ICON_FILENAME \t\t\t= \"hello_sdl_icon.png\";\n-\tprivate static final String SDL_IMAGE_FILENAME  \t= \"sdl_full_image.png\";\n-\n-\tprivate static final String WELCOME_SHOW \t\t\t= \"Welcome to HelloSDL\";\n-\tprivate static final String WELCOME_SPEAK \t\t\t= \"Welcome to Hello S D L\";\n-\n-\tprivate static final String TEST_COMMAND_NAME \t\t= \"Test Command\";\n-\n-\tprivate static final int FOREGROUND_SERVICE_ID = 111;\n-\n-\t// TCP/IP transport config\n-\t// The default port is 12345\n-\t// The IP is of the machine that is running SDL Core\n-\tprivate static final int TCP_PORT = 12345;\n-\tprivate static final String DEV_MACHINE_IP_ADDRESS = \"192.168.0.104\";\n-\n-\t// variable to create and call functions of the SyncProxy\n-\tprivate SdlManager sdlManager = null;\n-\tprivate List<ChoiceCell> choiceCellList;\n-\tMap<FunctionID, OnRPCNotificationListener> onRPCNotificationListenerMap = new HashMap<>();\n-\tpublic static final PublishRelay<MainActivity.STREAM_ENUM> relay = PublishRelay.create();\n-\n-\t@Override\n-\tpublic IBinder onBind(Intent intent) {\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic void onCreate() {\n-\t\tLog.d(TAG, \"onCreate\");\n-\t\tsuper.onCreate();\n-\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tenterForeground();\n-\t\t}\n-\t}\n-\n-\t// Helper method to let the service enter foreground mode\n-\t@SuppressLint(\"NewApi\")\n-\tpublic void enterForeground() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tNotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n-\t\t\tNotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n-\t\t\tif (notificationManager != null) {\n-\t\t\t\tnotificationManager.createNotificationChannel(channel);\n-\t\t\t\tNotification serviceNotification = new Notification.Builder(this, channel.getId())\n-\t\t\t\t\t\t.setContentTitle(\"Connected through SDL\")\n-\t\t\t\t\t\t.setSmallIcon(R.drawable.ic_sdl)\n-\t\t\t\t\t\t.build();\n-\t\t\t\tstartForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int onStartCommand(Intent intent, int flags, int startId) {\n-\t\tString ip = intent.getStringExtra(MainActivity.IP);\n-\t\tint port = intent.getIntExtra(MainActivity.PORT, 12345);\n-\t\tstartProxy(port, ip);\n-\n-\t\trelay.doOnNext(new Consumer<MainActivity.STREAM_ENUM>() {\n-\t\t\t@Override\n-\t\t\tpublic void accept(MainActivity.STREAM_ENUM stream_enum) throws Exception {\n-\t\t\t\tstartStreaming(stream_enum);\n-\t\t\t}\n-\t\t}).subscribe();\n-\t\treturn START_STICKY;\n-\t}\n-\n-\t@Override\n-\tpublic void onDestroy() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tstopForeground(true);\n-\t\t}\n-\n-\t\tif (sdlManager != null) {\n-\t\t\tsdlManager.dispose();\n-\t\t}\n-\n-\t\tsuper.onDestroy();\n-\t}\n-\n-\tprivate void startStreaming(final MainActivity.STREAM_ENUM value) {\n-\t\tif (sdlManager.getVideoStreamManager() != null) {\n-\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (success) {\n-\t\t\t\t\t\tClass myClass;\n-\t\t\t\t\t\tif (value.equals(MainActivity.STREAM_ENUM.START_STREAMING)) {\n-\t\t\t\t\t\t\tmyClass = MyDisplay.class;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmyClass = UIStreamingDisplay.class;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tVideoStreamingRange.Builder builder = new VideoStreamingRange.Builder();\n-\t\t\t\t\t\tbuilder\n-\t\t\t\t\t\t\t\t.setMaxSupportedResolution(new Resolution(800, 480))\n-\t\t\t\t\t\t\t\t.setMinSupportedResolution(new Resolution(400, 200))\n-\t\t\t\t\t\t\t\t.setAspectRatio(new AspectRatio(1., 6.))\n-\t\t\t\t\t\t\t\t.setMaxScreenDiagonal(20.);\n-\t\t\t\t\t\tVideoStreamingRange range = builder.build();\n-\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), myClass, null, false, range);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void startProxy(int port, String ip) {\n-\t\t// This logic is to select the correct transport and security levels defined in the selected build flavor\n-\t\t// Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n-\t\t// Typically in your app, you will only set one of these.\n-\t\tif (sdlManager == null) {\n-\t\t\tLog.i(TAG, \"Starting SDL Proxy\");\n-\t\t\t// Enable DebugTool for debug build type\n-\t\t\tif (BuildConfig.DEBUG){\n-\t\t\t\tDebugTool.enableDebugTool();\n-\t\t\t}\n-\t\t\tBaseTransportConfig transport = null;\n-\t\t\tif (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n-\t\t\t\tint securityLevel;\n-\t\t\t\tif (BuildConfig.SECURITY.equals(\"HIGH\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"MED\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n-\t\t\t\t} else {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n-\t\t\t\t}\n-\t\t\t\ttransport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\ttransport = new TCPTransportConfig(port, ip, true);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\tMultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n-\t\t\t\tmtc.setRequiresHighBandwidth(true);\n-\t\t\t\ttransport = mtc;\n-\t\t\t}\n-\n-\t\t\t// The app type to be used\n-\t\t\tVector<AppHMIType> appType = new Vector<>();\n-\t\t\tappType.add(AppHMIType.NAVIGATION);\n-\n-\t\t\t// The manager listener helps you know when certain events that pertain to the SDL Manager happen\n-\t\t\t// Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n-\t\t\tSdlManagerListener listener = new SdlManagerListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onStart() {\n-//\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null) {\n-//\n-//\t\t\t\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-//\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\tpublic void onComplete(boolean success) {\n-//\t\t\t\t\t\t\t\tif (success) {\n-//\t\t\t\t\t\t\t\t\tsdlManager.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING,\n-//\t\t\t\t\t\t\t\t\t\t\tnew OnSystemCapabilityListener() {\n-//\t\t\t\t\t\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\t\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tVideoStreamingCapability capability1 = (VideoStreamingCapability)capability;\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Diagonal: \" +  capability1.getDiagonalScreenSize());\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"PPI: \" +  capability1.getPixelPerInch());\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Scale: \" +  capability1.getScale());\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), MyDisplay.class, null, false);\n-//\t\t\t\t\t\t\t\t\t\t\t\t}\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\t\t\t\t\t\t\tpublic void onError(String info) {\n-//\n-//\t\t\t\t\t\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\t\t\t\t\t});\n-//\t\t\t\t\t\t\t\t} else {\n-//\t\t\t\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-//\t\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t});\n-//\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onDestroy() {\n-\t\t\t\t\tSdlService.this.stopSelf();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info, Exception e) {\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n-\t\t\t\t\tboolean isNeedUpdate = false;\n-\t\t\t\t\tString appName = APP_NAME;\n-\t\t\t\t\tString ttsName = APP_NAME;\n-\t\t\t\t\tswitch (language) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tswitch (hmiLanguage) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (isNeedUpdate) {\n-\t\t\t\t\t\treturn new LifecycleConfigurationUpdate(appName, null, TTSChunkFactory.createSimpleTTSChunks(ttsName), null);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t\t// Create App Icon, this is set in the SdlManager builder\n-\t\t\tSdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n-\n-\t\t\tonRPCNotificationListenerMap.put(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\t\tOnHMIStatus status = (OnHMIStatus) notification;\n-\t\t\t\t\tif (status != null && status.getHmiLevel() == HMILevel.HMI_NONE) {\n-\t\t\t\t\t\t//Stop the stream\n-\t\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null && sdlManager.getVideoStreamManager().isStreaming()) {\n-\t\t\t\t\t\t\tLog.d(\"OnHmiStatus\", \"stop streaming\");\n-\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().stopStreaming(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\t// The manager builder sets options for your session\n-\t\t\tSdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n-\t\t\tbuilder.setAppTypes(appType);\n-\t\t\tbuilder.setTransportType(transport);\n-\t\t\tbuilder.setAppIcon(appIcon);\n-\t\t\tbuilder.setRPCNotificationListeners(onRPCNotificationListenerMap);\n-\t\t\tsdlManager = builder.build();\n-\t\t\tsdlManager.start();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Send some voice commands\n-\t */\n-\tprivate void setVoiceCommands(){\n-\n-\t\tList<String> list1 = Collections.singletonList(\"Command One\");\n-\t\tList<String> list2 = Collections.singletonList(\"Command two\");\n-\n-\t\tVoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 1 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tVoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 2 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tsdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1,voiceCommand2));\n-\t}\n-\n-\t/**\n-\t *  Add menus for the app on SDL.\n-\t */\n-\tprivate void sendMenus(){\n-\n-\t\t// some arts\n-\t\tSdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n-\n-\t\t// some voice commands\n-\t\tList<String> voice2 = Collections.singletonList(\"Cell two\");\n-\n-\t\tMenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t\tshowTest();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// SUB MENU\n-\n-\t\tMenuCell subCell1 = new MenuCell(\"SubCell 1\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell subCell2 = new MenuCell(\"SubCell 2\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// sub menu parent cell\n-\t\tMenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", null, Arrays.asList(subCell1,subCell2));\n-\n-\t\tMenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tshowPerformInteraction();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell5 = new MenuCell(\"Clear the menu\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Clearing Menu. Source: \"+ trigger.toString());\n-\t\t\t\t// Clear this thing\n-\t\t\t\tsdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n-\t\t\t\tshowAlert(\"Menu Cleared\");\n-\t\t\t}\n-\t\t});\n-\n-\t\t// Send the entire menu off to be created\n-\t\tsdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n-\t}\n-\n-\t/**\n-\t * Will speak a sample welcome message\n-\t */\n-\tprivate void performWelcomeSpeak(){\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(WELCOME_SPEAK)));\n-\t}\n-\n-\t/**\n-\t * Use the Screen Manager to set the initial screen text and set the image.\n-\t * Because we are setting multiple items, we will call beginTransaction() first,\n-\t * and finish with commit() when we are done.\n-\t */\n-\tprivate void performWelcomeShow() {\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(APP_NAME);\n-\t\tsdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n-\t\tsdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n-\t\tsdlManager.getScreenManager().commit(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tif (success){\n-\t\t\t\t\tLog.i(TAG, \"welcome show successful\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * Attempts to Subscribe to all preset buttons\n-\t */\n-\tprivate void subscribeToButtons() {\n-\t\tButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n-\t\t\t\tButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n-\t\t\t\tButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n-\n-\t\tOnButtonListener onButtonListener = new OnButtonListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n-\t\t\t\tsdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n-\t\t\t\tsdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(String info) {\n-\t\t\t\tLog.i(TAG, \"onError: \" + info);\n-\t\t\t}\n-\t\t};\n-\n-\t\tfor (ButtonName buttonName : buttonNames) {\n-\t\t\tsdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Will show a sample test message on screen as well as speak a sample test message\n-\t */\n-\tprivate void showTest(){\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n-\t\tsdlManager.getScreenManager().setTextField2(\"\");\n-\t\tsdlManager.getScreenManager().commit(null);\n-\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(TEST_COMMAND_NAME)));\n-\t}\n-\n-\tprivate void showAlert(String text){\n-\t\tAlert alert = new Alert();\n-\t\talert.setAlertText1(text);\n-\t\talert.setDuration(5000);\n-\t\tsdlManager.sendRPC(alert);\n-\t}\n-\n-\t// Choice Set\n-\n-\tprivate void preloadChoices(){\n-\t\tChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n-\t\tChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n-\t\tChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n-\t\tchoiceCellList = new ArrayList<>(Arrays.asList(cell1,cell2,cell3));\n-\t\tsdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n-\t}\n-\n-\tprivate void showPerformInteraction(){\n-\t\tif (choiceCellList != null) {\n-\t\t\tChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n-\t\t\t\t\tshowAlert(choiceCell.getText() + \" was selected\");\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String error) {\n-\t\t\t\t\tLog.e(TAG, \"There was an error showing the perform interaction: \"+ error);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tsdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n-\t\t}\n-\t}\n-\n-\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n-\t\tint clickCounter1 = 0;\n-\t\tint clickCounter2 = 0;\n-\t\tpublic UIStreamingDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.ui_streaming_layout);\n-\n-\n-\t\t\tfinal Button button1 = findViewById(R.id.button1);\n-\t\t\tfinal Button button2 = findViewById(R.id.button2);\n-\t\t\tfinal TextView counter1 = findViewById(R.id.button_one_counter);\n-\t\t\tfinal TextView counter2 = findViewById(R.id.button_two_counter);\n-            button1.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter1.setText(\"Click!!! \" + ++clickCounter1);\n-\t\t\t\t\tLog.d(\"MyTagClickCounter\", String.valueOf(clickCounter1));\n-\t\t\t\t\tint location [] = new int[2];\n-                    button1.getLocationInWindow(location);\n-                    //counter1.append(\"\\nButton size: \" + button1.getWidth() + \"x\" + button1.getHeight());\n-\t\t\t\t\t//textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\n-            button2.setOnTouchListener(new View.OnTouchListener() {\n+    private static final String TAG = \"SDL Service\";\n+\n+    private static final String APP_NAME = \"Hello Sdl\";\n+    private static final String APP_NAME_ES = \"Hola Sdl\";\n+    private static final String APP_NAME_FR = \"Bonjour Sdl\";\n+    private static final String APP_ID = \"8678309\";\n+\n+    private static final String ICON_FILENAME = \"hello_sdl_icon.png\";\n+    private static final String SDL_IMAGE_FILENAME = \"sdl_full_image.png\";\n+\n+    private static final String WELCOME_SHOW = \"Welcome to HelloSDL\";\n+    private static final String WELCOME_SPEAK = \"Welcome to Hello S D L\";\n+\n+    private static final String TEST_COMMAND_NAME = \"Test Command\";\n+\n+    private static final int FOREGROUND_SERVICE_ID = 111;\n+\n+    // TCP/IP transport config\n+    // The default port is 12345\n+    // The IP is of the machine that is running SDL Core\n+    private static final int TCP_PORT = 12247;\n+    private static final String DEV_MACHINE_IP_ADDRESS = \"m.sdl.tools\";\n+\n+    // variable to create and call functions of the SyncProxy\n+    private SdlManager sdlManager = null;\n+    private List<ChoiceCell> choiceCellList;\n+\n+    @Override\n+    public IBinder onBind(Intent intent) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void onCreate() {\n+        Log.d(TAG, \"onCreate\");\n+        super.onCreate();\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            enterForeground();\n+        }\n+    }\n+\n+    // Helper method to let the service enter foreground mode\n+    @SuppressLint(\"NewApi\")\n+    public void enterForeground() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            NotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n+            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n+            if (notificationManager != null) {\n+                notificationManager.createNotificationChannel(channel);\n+                Notification serviceNotification = new Notification.Builder(this, channel.getId())\n+                        .setContentTitle(\"Connected through SDL\")\n+                        .setSmallIcon(R.drawable.ic_sdl)\n+                        .build();\n+                startForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int onStartCommand(Intent intent, int flags, int startId) {\n+        startProxy();\n+        return START_STICKY;\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            stopForeground(true);\n+        }\n+\n+        if (sdlManager != null) {\n+            sdlManager.dispose();\n+        }\n+\n+        super.onDestroy();\n+    }\n+\n+    private void startProxy() {\n+        // This logic is to select the correct transport and security levels defined in the selected build flavor\n+        // Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n+        // Typically in your app, you will only set one of these.\n+        if (sdlManager == null) {\n+            Log.i(TAG, \"Starting SDL Proxy\");\n+            // Enable DebugTool for debug build type\n+            if (BuildConfig.DEBUG) {\n+                DebugTool.enableDebugTool();\n+            }\n+            BaseTransportConfig transport = null;\n+            if (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n+                int securityLevel;\n+                if (BuildConfig.SECURITY.equals(\"HIGH\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n+                } else if (BuildConfig.SECURITY.equals(\"MED\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n+                } else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n+                } else {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n+                }\n+                transport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n+            } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+                transport = new TCPTransportConfig(TCP_PORT, DEV_MACHINE_IP_ADDRESS, true);\n+            } else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+                MultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n+                mtc.setRequiresHighBandwidth(true);\n+                transport = mtc;\n+            }\n+\n+            // The app type to be used\n+            Vector<AppHMIType> appType = new Vector<>();\n+            appType.add(AppHMIType.DEFAULT);\n+\n+            // The manager listener helps you know when certain events that pertain to the SDL Manager happen\n+            // Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n+            SdlManagerListener listener = new SdlManagerListener() {\n+                @Override\n+                public void onStart() {\n+                    // HMI Status Listener\n+                    sdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n+                        @Override\n+                        public void onNotified(RPCNotification notification) {\n+                            OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                            if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                                return;\n+                            }\n+                            if (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n+                                setVoiceCommands();\n+                                sendMenus();\n+                                performWelcomeSpeak();\n+                                performWelcomeShow();\n+                                preloadChoices();\n+                                subscribeToButtons();\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onDestroy() {\n+                    SdlService.this.stopSelf();\n+                }\n+\n+                @Override\n+                public void onError(String info, Exception e) {\n+                }\n+\n+                @Override\n+                public LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n+                    boolean isNeedUpdate = false;\n+                    String appName = APP_NAME;\n+                    String ttsName = APP_NAME;\n+                    switch (language) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    switch (hmiLanguage) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    if (isNeedUpdate) {\n+                        Vector<TTSChunk> chunks = new Vector<>(Collections.singletonList(new TTSChunk(ttsName, SpeechCapabilities.TEXT)));\n+                        return new LifecycleConfigurationUpdate(appName, null, chunks, null);\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+            };\n+\n+            // Create App Icon, this is set in the SdlManager builder\n+            SdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n+\n+            // The manager builder sets options for your session\n+            SdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n+            builder.setAppTypes(appType);\n+            builder.setTransportType(transport);\n+            builder.setAppIcon(appIcon);\n+            sdlManager = builder.build();\n+            sdlManager.start();\n+        }\n+    }\n+\n+    /**\n+     * Send some voice commands\n+     */\n+    private void setVoiceCommands() {\n+\n+        List<String> list1 = Collections.singletonList(\"Command One\");\n+        List<String> list2 = Collections.singletonList(\"Command two\");\n+\n+        VoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 1 triggered\");\n+            }\n+        });\n+\n+        VoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 2 triggered\");\n+            }\n+        });\n+\n+        sdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1, voiceCommand2));\n+    }\n+\n+    /**\n+     * Add menus for the app on SDL.\n+     */\n+    private void sendMenus() {\n+\n+        // some arts\n+        SdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n+\n+        // some voice commands\n+        List<String> voice2 = Collections.singletonList(\"Cell two\");\n+\n+        MenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 1 triggered. Source: \" + trigger.toString());\n+                showTest();\n+            }\n+        });\n+\n+        MenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // SUB MENU\n+\n+        MenuCell subCell1 = new MenuCell(\"SubCell 1\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 1 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        MenuCell subCell2 = new MenuCell(\"SubCell 2\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // sub menu parent cell\n+        MenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", MenuLayout.LIST, null, Arrays.asList(subCell1, subCell2));\n+\n+        MenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                showPerformInteraction();\n+            }\n+        });\n+\n+        MenuCell mainCell5 = new MenuCell(\"Clear the menu\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Clearing Menu. Source: \" + trigger.toString());\n+                // Clear this thing\n+                sdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n+                showAlert(\"Menu Cleared\");\n+            }\n+        });\n+\n+        // Send the entire menu off to be created\n+        sdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n+    }\n+\n+    /**\n+     * Will speak a sample welcome message\n+     */\n+    private void performWelcomeSpeak() {\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(WELCOME_SPEAK, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    /**\n+     * Use the Screen Manager to set the initial screen text and set the image.\n+     * Because we are setting multiple items, we will call beginTransaction() first,\n+     * and finish with commit() when we are done.\n+     */\n+    private void performWelcomeShow() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(APP_NAME);\n+        sdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n+        sdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n+        sdlManager.getScreenManager().commit(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                if (success) {\n+                    Log.i(TAG, \"welcome show successful\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Attempts to Subscribe to all preset buttons\n+     */\n+    private void subscribeToButtons() {\n+        ButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n+                ButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n+                ButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n+\n+        OnButtonListener onButtonListener = new OnButtonListener() {\n+            @Override\n+            public void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n+                sdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n+            }\n+\n+            @Override\n+            public void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n+                sdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                Log.i(TAG, \"onError: \" + info);\n+            }\n+        };\n+\n+        for (ButtonName buttonName : buttonNames) {\n+            sdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n+        }\n+    }\n+\n+    /**\n+     * Will show a sample test message on screen as well as speak a sample test message\n+     */\n+    private void showTest() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n+        sdlManager.getScreenManager().setTextField2(\"\");\n+        sdlManager.getScreenManager().commit(null);\n+\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(TEST_COMMAND_NAME, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    private void showAlert(String text) {\n+        Alert alert = new Alert();\n+        alert.setAlertText1(text);\n+        alert.setDuration(5000);\n+        sdlManager.sendRPC(alert);\n+    }\n+\n+    // Choice Set\n+\n+    private void preloadChoices() {\n+        ChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n+        ChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n+        ChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n+        choiceCellList = new ArrayList<>(Arrays.asList(cell1, cell2, cell3));\n+        sdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n+    }\n+\n+    private void showPerformInteraction() {\n+        if (choiceCellList != null) {\n+            ChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n+                @Override\n+                public void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n+                    showAlert(choiceCell.getText() + \" was selected\");\n+                }\n+\n                 @Override\n-                public boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter2.setText(\"Click!!! \" + ++clickCounter2);\n-                    Log.d(\"MyTagClickCounter\", String.valueOf(clickCounter2));\n-                    int location [] = new int[2];\n-                    button2.getLocationInWindow(location);\n-                    //counter2.append(\"\\nButton size: \" + button.getWidth() + \"x\" + button.getHeight());\n-                    //textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-                    return false;\n+                public void onError(String error) {\n+                    Log.e(TAG, \"There was an error showing the perform interaction: \" + error);\n                 }\n             });\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n-\t}\n-\n-\tpublic static class MyDisplay extends SdlRemoteDisplay {\n-\t\tpublic MyDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.streaming_layout);\n-\n-\n-\t\t\tString videoUri = \"android.resource://\" + getContext().getPackageName() + \"/\" + R.raw.sdl;\n-\t\t\tfinal VideoView videoView = findViewById(R.id.videoView);\n-\t\t\tvideoView.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\t\t\t\t\tint[] location = new int[2];\n-\t\t\t\t\tvideoView.getLocationInWindow(location);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"View size \" + videoView.getWidth() + \"x\" + videoView.getHeight());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Location \" + location[0] + \" \" + location[1]);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Count: \" + motionEvent.getPointerCount());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Click(\" + motionEvent.getX() + \" \" + motionEvent.getY() + \" Raw \" + motionEvent.getRawX() + \" \" + motionEvent.getRawY());\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tvideoView.setVideoURI(Uri.parse(videoUri));\n-\t\t\tvideoView.start();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n+            sdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyODA1OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472728058", "bodyText": "You could use DebugTool.logError(...) here instead of Log.d(...)", "author": "santhanamk", "createdAt": "2020-08-19T05:49:20Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -165,17 +184,48 @@ public void onNotified(RPCNotification notification) {\n \tprivate final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n \t\t@Override\n \t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null && remoteDisplay != null){\n+\t\t\tif(notification != null && sdlRemoteDisplay != null){\n \t\t\t\tList<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent)notification);\n \t\t\t\tif (motionEventList != null && !motionEventList.isEmpty()) {\n \t\t\t\t\tfor (MotionEvent motionEvent : motionEventList) {\n-\t\t\t\t\t\tremoteDisplay.handleMotionEvent(motionEvent);\n+\t\t\t\t\t\tsdlRemoteDisplay.handleMotionEvent(motionEvent);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t};\n \n+\tprivate final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+\t\t@Override\n+\t\tpublic void onCapabilityRetrieved(Object capability) {\n+\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n+\n+\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+\t\t\t// means only scale received\n+\t\t\tif (castedCapability.getPreferredResolution() == null &&\n+\t\t\t\t\tcastedCapability.getScale() != null &&\n+\t\t\t\t\tcastedCapability.getScale() != 0 &&\n+\t\t\t\t\tVideoStreamManager.this.parameters != null\n+\t\t\t\t\t&& VideoStreamManager.this.parameters.getResolution() != null) {\n+\t\t\t\t// set cached resolution\n+\t\t\t\tcastedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+\t\t\t}\n+\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n+\t\t\tVideoStreamManager.this.parameters = params;\n+\n+\t\t\tVideoStreamManager.this.withPendingRestart = true;\n+\n+\t\t\tvirtualDisplayEncoder.setStreamingParams(params);\n+\t\t\tstopStreaming(true);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onError(String info) {\n+\t\t\tLog.d(\"MyTagLogInfo\", info);", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 5461d9d4d..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -65,898 +65,968 @@ import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.TouchCoord;\n import com.smartdevicelink.proxy.rpc.TouchEvent;\n import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.TouchType;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n import com.smartdevicelink.proxy.rpc.enums.VideoStreamingState;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.session.SdlSession;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.IVideoStreamListener;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n import com.smartdevicelink.transport.utl.TransportRecord;\n import com.smartdevicelink.util.DebugTool;\n import com.smartdevicelink.util.Version;\n \n+import java.io.IOException;\n import java.lang.ref.WeakReference;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.FutureTask;\n \n @TargetApi(19)\n public class VideoStreamManager extends BaseVideoStreamManager {\n-\tprivate static String TAG = \"VideoStreamManager\";\n-\n-\tprivate WeakReference<Context> context;\n-\tprivate volatile VirtualDisplayEncoder virtualDisplayEncoder;\n-\tprivate Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n-\tprivate SdlRemoteDisplay sdlRemoteDisplay;\n-\tprivate float[] touchScalar = {1.0f,1.0f}; //x, y\n-\tprivate HapticInterfaceManager hapticManager;\n-\tprivate SdlMotionEvent sdlMotionEvent = null;\n-\tprivate OnHMIStatus currentOnHMIStatus;\n-\tprivate StreamingStateMachine stateMachine;\n-\tprivate VideoStreamingParameters parameters;\n-\tprivate VideoStreamingCapability originalCapability;\n-\tprivate IVideoStreamListener streamListener;\n-\tprivate boolean isTransportAvailable = false;\n-\tprivate Integer majorProtocolVersion;\n-\tprivate VideoStreamingRange streamingRange;\n-\tprivate boolean hasStarted;\n-\tprivate String vehicleMake = null;\n-\tprivate boolean isEncrypted = false;\n-\tprivate boolean withPendingRestart = false;\n-\n-\t// INTERNAL INTERFACES\n-\n-\tprivate final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif (session != null && session.getAcceptedVideoParams() != null) {\n-\t\t\t\t\tparameters = session.getAcceptedVideoParams();\n-\t\t\t\t\tVideoStreamManager.this.streamListener = session.startVideoStream();\n-\t\t\t\t}\n-\n-\t\t\t\tif (VideoStreamManager.this.streamListener == null) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error starting video stream\");\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\tif(capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())){\n-\t\t\t\t\thapticManager = new HapticInterfaceManager(internalInterface);\n-\t\t\t\t}\n-\t\t\t\tcheckState();\n-\t\t\t\tstartEncoder();\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\t\thasStarted = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SdlSession session, SessionType type) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif(sdlRemoteDisplay !=null){\n-\t\t\t\t    // TODO set withPendingRestart to default in proper place\n-\t\t\t\t\tstopStreaming(withPendingRestart);\n-\t\t\t\t}\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\t\t\ttransitionToState(SETTING_UP);\n-\n-\t\t\t\tif (withPendingRestart){\n-\t\t\t\t\tVideoStreamManager manager = VideoStreamManager.this;\n-\t\t\t\t\tmanager.internalInterface.startVideoService(\n-\t\t\t\t\t\t\tmanager.getLastCachedStreamingParameters(),\n-\t\t\t\t\t\t\tmanager.isEncrypted\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceError(SdlSession session, SessionType type, String reason) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null){\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tOnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n-\t\t\t\tcurrentOnHMIStatus = onHMIStatus;\n-\n-\t\t\t\tif (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n-\t\t\t\t\tinternalInterface.stopVideoService();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null && sdlRemoteDisplay != null){\n-\t\t\t\tList<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent)notification);\n-\t\t\t\tif (motionEventList != null && !motionEventList.isEmpty()) {\n-\t\t\t\t\tfor (MotionEvent motionEvent : motionEventList) {\n-\t\t\t\t\t\tsdlRemoteDisplay.handleMotionEvent(motionEvent);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t@Override\n-\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\n-\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\n-\t\t\t// means only scale received\n-\t\t\tif (castedCapability.getPreferredResolution() == null &&\n-\t\t\t\t\tcastedCapability.getScale() != null &&\n-\t\t\t\t\tcastedCapability.getScale() != 0 &&\n-\t\t\t\t\tVideoStreamManager.this.parameters != null\n-\t\t\t\t\t&& VideoStreamManager.this.parameters.getResolution() != null) {\n-\t\t\t\t// set cached resolution\n-\t\t\t\tcastedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n-\t\t\t}\n-\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\tVideoStreamManager.this.withPendingRestart = true;\n-\n-\t\t\tvirtualDisplayEncoder.setStreamingParams(params);\n-\t\t\tstopStreaming(true);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onError(String info) {\n-\t\t\tLog.d(\"MyTagLogInfo\", info);\n-\t\t}\n-\t};\n-\n-\t// MANAGER APIs\n-\tpublic VideoStreamManager(ISdl internalInterface){\n-\t\tsuper(internalInterface);\n-\n-\t\tif(internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n-\t\t\t\tinternalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n-\t\t\tvehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n-\t\t}\n-\t\tvirtualDisplayEncoder = new VirtualDisplayEncoder();\n-\n-\t\t// Listen for video service events\n-\t\tinternalInterface.addServiceListener(SessionType.NAV, serviceListener);\n-\t\t// Take care of the touch events\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t// Listen for HMILevel changes\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t// Listen for SystemCapabilityType VIDEO_STREAMING\n-\t\tinternalInterface.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n-\t\tstateMachine = new StreamingStateMachine();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\tisTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n-\t\tcheckState();\n-\t\tsuper.start(listener);\n-\t}\n-\n-\tprivate synchronized void checkState(){\n-\t\tif(this.getState() == SETTING_UP\n-\t\t\t\t&& isTransportAvailable\n-\t\t\t\t&& isHMIStateVideoStreamCapable(currentOnHMIStatus)\n-\t\t\t\t&& parameters != null){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.READY);\n-\t\t\ttransitionToState(READY);\n-\t\t}\n-\t}\n-\n-\tboolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n-\t\tHMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n-\t\tVideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n-\t\treturn (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n-\t}\n-\n-\tprivate void getVideoStreamingParams(){\n-\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5) {\n-\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\tcheckState();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\ttransitionToState(ERROR);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\t//We just use default video streaming params\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\tif(dispCap !=null){\n-\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t}\n-\n-\t\t\tthis.parameters = params;\n-\t\t\tcheckState();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param streamingRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tthis.streamingRange = streamingRange;\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n-\t\tif(parameters == null){\n-\t\t\tif(majorProtocolVersion >= 5) {\n-\t\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\n-\t\t\t\t\t\t// Mocks data here\n-\t\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\t\t\t\tif (streamingRange != null) {\n-\t\t\t\t\t\t\t// filtering\n-\t\t\t\t\t\t\tcastedCapability.setAdditionalVideoStreamingCapabilities(\n-\t\t\t\t\t\t\t\t\tgetSupportedCapabilities(\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxScreenDiagonal(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getAspectRatio(),\n-\t\t\t\t\t\t\t\t\t\t\tcastedCapability.getAdditionalVideoStreamingCapabilities()\n-\t\t\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// TODO handle??\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tOnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n-\t\t\t\t\t\tinternalInterface.sendRPC(onAppCapabilityUpdated);\n-\t\t\t\t\t\tstartStreaming(params, isEncrypted);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}else{\n-\t\t\t\t//We just use default video streaming params\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\tif(dispCap !=null){\n-\t\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t}\n-\t\t\t\tstartStreaming(params, encrypted);\n-\t\t\t}\n-\t\t}else{\n-\t\t\tstartStreaming(parameters, encrypted);\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n-\t * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n-\t *                    VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n-\t * @param encrypted Specify true if packets on this service have to be encrypted\n-\t */\n-\tprotected void startStreaming(VideoStreamingParameters parameters, boolean encrypted){\n-\t\tthis.parameters = parameters;\n-\t\tif (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n-\t\t\tDebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n-\t\t\treturn;\n-\t\t}\n-\t\t//Start the video service\n-\t\tthis.internalInterface.startVideoService(parameters, encrypted);\n-\t}\n-\n-\t/**\n-\t * Initializes and starts the virtual display encoder and creates the remote display\n-\t */\n-\tprivate void startEncoder(){\n-\t\ttry {\n-\t\t\tif (sdlRemoteDisplay != null) {\n-\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t}\n-\n-\t\t\tvirtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n-\t\t\t//We are all set so we can start streaming at at this point\n-\t\t\tvirtualDisplayEncoder.start();\n-\t\t\t//Encoder should be up and running\n-\t\t\tDisplay display = virtualDisplayEncoder.getDisplay();\n-\t\t\tcreateRemoteDisplay(display);\n-\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\thasStarted = true;\n-\t\t} catch (Exception e) {\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming from the remote display. To restart, call\n-\t * @see #resumeStreaming()\n-\t */\n-\tpublic void stopStreaming(boolean withPendingRestart){\n-\t\tif(sdlRemoteDisplay!=null && !withPendingRestart){\n-\t\t\tsdlRemoteDisplay.stop();\n-\t\t\tthis.withPendingRestart = false;\n-\t\t}\n-\t\tif (this.isStreaming()) {\n-\t\t\tif(virtualDisplayEncoder!=null){\n-\t\t\t\tvirtualDisplayEncoder.shutDown(withPendingRestart);\n-\t\t\t}\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.PAUSED);\n-\n-\t\t\tthis.internalInterface.stopVideoService();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Resumes streaming after calling\n-\t * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n-\t * followed by a call to\n-\t * @see #stopStreaming(boolean withPendingRestart)\n-\t */\n-\tpublic void resumeStreaming(){\n-\t\tint currentState = stateMachine.getState();\n-\t\tif (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n-\t\t\tstartEncoder();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming, ends video streaming service and removes service listeners.\n-\t */\n-\t@Override\n-\tpublic void dispose(){\n-\t\tstopStreaming(false);\n-\n-\t\thapticManager = null;\n-\t\tsdlRemoteDisplay = null;\n-\t\tparameters = null;\n-\t\tvirtualDisplayEncoder = null;\n-\t\tif (internalInterface != null) {\n-\t\t\tinternalInterface.stopVideoService();\n-\t\t\t// Remove listeners\n-\t\t\tinternalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t}\n-\n-\n-\n-\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\tsuper.dispose();\n-\t}\n-\n-\t// PUBLIC METHODS FOR CHECKING STATE\n-\n-\t/**\n-\t * Check if a video service is currently active\n-\t * @return boolean (true = active, false = inactive)\n-\t */\n-\tpublic boolean isServiceActive(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.READY) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STARTED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.PAUSED);\n-\t}\n-\n-\t/**\n-\t * Check if video is currently streaming and visible\n-\t * @return boolean (true = yes, false = no)\n-\t */\n-\tpublic boolean isStreaming(){\n-\t\tboolean state = (stateMachine.getState() == StreamingStateMachine.STARTED);\n-\t\tboolean capable = isHMIStateVideoStreamCapable(currentOnHMIStatus);\n-\t\treturn state && capable;\n-\t}\n-\n-\t/**\n-\t * Check if video streaming has been paused due to app moving to background or manually stopped\n-\t * @return boolean (true = not paused, false = paused)\n-\t */\n-\tpublic boolean isPaused(){\n-\t\treturn (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n-\t}\n-\n-\t/**\n-\t * Gets the current video streaming state as defined in @StreamingStateMachine\n-\t * @return int representing StreamingStateMachine.StreamingState\n-\t */\n-\tpublic @StreamingStateMachine.StreamingState int currentVideoStreamState(){\n-\t\treturn stateMachine.getState();\n-\t}\n-\n-\t// HELPER METHODS\n-\n-\tprivate void createRemoteDisplay(final Display disp){\n-\t\ttry{\n-\t\t\tif (disp == null){\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Dismiss the current presentation if the display has changed.\n-\t\t\tif (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n-\t\t\t\tsdlRemoteDisplay.dismissPresentation();\n-\t\t\t}\n-\n-\t\t\tFutureTask<Boolean> fTask =  new FutureTask<Boolean>( new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback(){\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCreated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Remote display has been created.\n-\t\t\t\t\t//Now is a good time to do parsing for spatial data\n-\t\t\t\t\tVideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\t//Get touch scalars\n-\t\t\t\t\tImageResolution resolution = null;\n-\t\t\t\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5){ //At this point we should already have the capability\n-\t\t\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\t\t\tif(capability != null){\n-\t\t\t\t\t\t\tresolution = capability.getPreferredResolution();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution == null){ //Either the protocol version is too low to access video streaming caps, or they were null\n-\t\t\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities) internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\t\t\tif (dispCap != null) {\n-\t\t\t\t\t\t\tresolution = (dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution != null){\n-\t\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\t\tdisp.getMetrics(displayMetrics);\n-\t\t\t\t\t\tcreateTouchScalar(resolution, displayMetrics);\n+    private static final String TAG = \"VideoStreamManager\";\n+\n+    private WeakReference<Context> context;\n+    private volatile VirtualDisplayEncoder virtualDisplayEncoder;\n+    private Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n+    private SdlRemoteDisplay sdlRemoteDisplay;\n+    private final float[] touchScalar = {1.0f, 1.0f}; //x, y\n+    private HapticInterfaceManager hapticManager;\n+    private SdlMotionEvent sdlMotionEvent = null;\n+    private OnHMIStatus currentOnHMIStatus;\n+    private final StreamingStateMachine stateMachine;\n+    private VideoStreamingParameters parameters;\n+    private VideoStreamingCapability originalCapability;\n+    private IVideoStreamListener streamListener;\n+    private boolean isTransportAvailable = false;\n+    private Integer majorProtocolVersion;\n+    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private boolean hasStarted;\n+    private String vehicleMake = null;\n+    private boolean isEncrypted = false;\n+    private boolean withPendingRestart = false;\n+    private AbstractPacketizer videoPacketizer;\n+\n+    // INTERNAL INTERFACES\n+\n+    private final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n+        @Override\n+        public void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n+            if (SessionType.NAV.equals(type)) {\n+                if (session != null && session.getAcceptedVideoParams() != null) {\n+                    parameters = session.getAcceptedVideoParams();\n+                    VideoStreamManager.this.streamListener = startVideoStream(session.getAcceptedVideoParams(), session);\n+                }\n+\n+                if (VideoStreamManager.this.streamListener == null) {\n+                    DebugTool.logError(TAG, \"Error starting video stream\");\n+                    stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                    return;\n+                }\n+                VideoStreamingCapability capability = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                }\n+                if (capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())) {\n+                    hapticManager = new HapticInterfaceManager(internalInterface);\n+                }\n+                checkState();\n+                startEncoder();\n+                stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+                hasStarted = true;\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceEnded(SdlSession session, SessionType type) {\n+            if (SessionType.NAV.equals(type)) {\n+                //stopVideoStream();\n+                if (sdlRemoteDisplay !=null){\n+                    stopStreaming(withPendingRestart);\n+                }\n+                stateMachine.transitionToState(StreamingStateMachine.NONE);\n+                transitionToState(SETTING_UP);\n+\n+                if (withPendingRestart){\n+                    VideoStreamManager manager = VideoStreamManager.this;\n+                    manager.internalInterface.startVideoService(\n+                            manager.getLastCachedStreamingParameters(),\n+                            manager.isEncrypted,\n+                            withPendingRestart\n+                    );\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceError(SdlSession session, SessionType type, String reason) {\n+            DebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n+            stopVideoStream();\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            transitionToState(BaseSubManager.ERROR);\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                OnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n+                currentOnHMIStatus = onHMIStatus;\n+                if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+                    getVideoStreamingParams();\n+                }\n+                checkState();\n+                if (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n+                    stopVideoStream();\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null && sdlRemoteDisplay != null) {\n+                List<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent) notification);\n+                if (motionEventList != null && !motionEventList.isEmpty()) {\n+                    for (MotionEvent motionEvent : motionEventList) {\n+                        sdlRemoteDisplay.handleMotionEvent(motionEvent);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+\n+            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+            // means only scale received\n+            if (castedCapability.getPreferredResolution() == null &&\n+                    castedCapability.getScale() != null &&\n+                    castedCapability.getScale() != 0 &&\n+                    VideoStreamManager.this.parameters != null\n+                    && VideoStreamManager.this.parameters.getResolution() != null) {\n+                // set cached resolution\n+                castedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+            }\n+            params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+            VideoStreamManager.this.parameters = params;\n+\n+            VideoStreamManager.this.withPendingRestart = true;\n+\n+            virtualDisplayEncoder.setStreamingParams(params);\n+            stopStreaming(true);\n+        }\n+\n+        @Override\n+        public void onError(String info) { }\n+    };\n+\n+    // MANAGER APIs\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public VideoStreamManager(ISdl internalInterface) {\n+        super(internalInterface);\n+\n+        if (internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n+                internalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n+            vehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n+        }\n+        virtualDisplayEncoder = new VirtualDisplayEncoder();\n+\n+        // Listen for video service events\n+        internalInterface.addServiceListener(SessionType.NAV, serviceListener);\n+        // Take care of the touch events\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+        // Listen for HMILevel changes\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        // Listen for SystemCapabilityType VIDEO_STREAMING\n+        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n+        stateMachine = new StreamingStateMachine();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        isTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n+        checkState();\n+        super.start(listener);\n+    }\n+\n+    private synchronized void checkState() {\n+        if (this.getState() == SETTING_UP\n+                && isTransportAvailable\n+                && isHMIStateVideoStreamCapable(currentOnHMIStatus)\n+                && parameters != null) {\n+            stateMachine.transitionToState(StreamingStateMachine.READY);\n+            transitionToState(READY);\n+        }\n+    }\n+\n+    boolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n+        HMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n+        VideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n+        return (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n+    }\n+\n+    private void getVideoStreamingParams() {\n+        if (internalInterface.getProtocolVersion().getMajor() >= 5) {\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                    @Override\n+                    public void onCapabilityRetrieved(Object capability) {\n+                        VideoStreamingParameters params = new VideoStreamingParameters();\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+                        params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+                        // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                        checkState();\n+                        }\n+\n+                    @Override\n+                    public void onError(String info) {\n+                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                        transitionToState(ERROR);\n+                    }\n+                }, false);\n+            }\n+        } else {\n+            //We just use default video streaming params\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+            DisplayCapabilities dispCap = null;\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+            }\n+            if (dispCap != null) {\n+                params.setResolution(dispCap.getScreenParams().getImageResolution());\n+            }\n+\n+            this.parameters = params;\n+            checkState();\n+        }\n+    }\n+\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {\n+            if (majorProtocolVersion >= 5) {\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                        @Override\n+                        public void onCapabilityRetrieved(Object capability) {\n+                            VideoStreamingParameters params = new VideoStreamingParameters();\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                            VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                            // Mocks data here\n+                            // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                            params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+                            if (listOfStreamingRanges != null) {\n+                                // filtering\n+                                castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                                );\n+                            } else { }\n+                            OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n+                            internalInterface.sendRPC(onAppCapabilityUpdated);\n+                            startStreaming(params, isEncrypted);\n+                        }\n+\n+                        @Override\n+                        public void onError(String info) {\n+                            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                            DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        }\n+                    }, false);\n+                }\n+            } else {\n+                //We just use default video streaming params\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                DisplayCapabilities dispCap = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                }\n+                if (dispCap != null) {\n+                    params.setResolution(dispCap.getScreenParams().getImageResolution());\n+                }\n+                startStreaming(params, encrypted);\n+            }\n+        } else {\n+            startStreaming(parameters, encrypted);\n+        }\n+    }\n+\n+\n+    /**\n+     * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n+     *\n+     * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n+     *                   VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n+     * @param encrypted  Specify true if packets on this service have to be encrypted\n+     */\n+    protected void startStreaming(VideoStreamingParameters parameters, boolean encrypted) {\n+        this.parameters = parameters;\n+        if (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n+            DebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n+            return;\n+        }\n+        //Start the video service\n+        this.internalInterface.startVideoService(parameters, encrypted, false);\n+    }\n+\n+    /**\n+     * Initializes and starts the virtual display encoder and creates the remote display\n+     */\n+    private void startEncoder() {\n+        try {\n+            if (sdlRemoteDisplay != null) {\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+            }\n+\n+            virtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n+            //We are all set so we can start streaming at at this point\n+            virtualDisplayEncoder.start();\n+            //Encoder should be up and running\n+            createRemoteDisplay(virtualDisplayEncoder.getDisplay());\n+\n+            stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+            hasStarted = true;\n+        } catch (Exception e) {\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    public void stopStreaming(boolean withPendingRestart) {\n+        if (sdlRemoteDisplay!= null && !withPendingRestart) {\n+            sdlRemoteDisplay.stop();\n+                this.withPendingRestart = false;\n+        }\n+        if (this.isStreaming()) {\n+            if (virtualDisplayEncoder!=null){\n+                virtualDisplayEncoder.shutDown(withPendingRestart);\n+            }\n+            stateMachine.transitionToState(StreamingStateMachine.PAUSED);\n+            stopVideoStream();\n+        }\n+    }\n+\n+    /**\n+     * Resumes streaming after calling\n+     *\n+     * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n+     * followed by a call to\n+     * @see #stopStreaming(boolean withPendingRestart)\n+     */\n+    public void resumeStreaming() {\n+        int currentState = stateMachine.getState();\n+        if (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n+            startEncoder();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming, ends video streaming service and removes service listeners.\n+     */\n+    @Override\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void dispose() {\n+        stopStreaming(false);\n+\n+        hapticManager = null;\n+        sdlRemoteDisplay = null;\n+        parameters = null;\n+        virtualDisplayEncoder = null;\n+        if (internalInterface != null) {\n+            // Remove listeners\n+            internalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        }\n+\n+        stopVideoStream();\n+\n+\n+        stateMachine.transitionToState(StreamingStateMachine.NONE);\n+        super.dispose();\n+    }\n+\n+    // PUBLIC METHODS FOR CHECKING STATE\n+\n+    /**\n+     * Check if a video service is currently active\n+     *\n+     * @return boolean (true = active, false = inactive)\n+     */\n+    public boolean isServiceActive() {\n+        return (stateMachine.getState() == StreamingStateMachine.READY) ||\n+                (stateMachine.getState() == StreamingStateMachine.STARTED) ||\n+                (stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n+                (stateMachine.getState() == StreamingStateMachine.PAUSED);\n+        }\n+\n+    /**\n+     * Check if video is currently streaming and visible\n+     *\n+     * @return boolean (true = yes, false = no)\n+     */\n+    public boolean isStreaming() {\n+        return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Check if video streaming has been paused due to app moving to background or manually stopped\n+     *\n+     * @return boolean (true = not paused, false = paused)\n+     */\n+    public boolean isPaused() {\n+        return (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Gets the current video streaming state as defined in @StreamingStateMachine\n+     *\n+     * @return int representing StreamingStateMachine.StreamingState\n+     */\n+    public @StreamingStateMachine.StreamingState\n+    int currentVideoStreamState() {\n+        return stateMachine.getState();\n+    }\n+\n+    // HELPER METHODS\n+\n+    private void createRemoteDisplay(final Display disp) {\n+        try {\n+            if (disp == null) {\n+                return;\n+            }\n+\n+            // Dismiss the current presentation if the display has changed.\n+            if (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n+                sdlRemoteDisplay.dismissPresentation();\n+            }\n+\n+            FutureTask<Boolean> fTask = new FutureTask<>(new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback() {\n+                @Override\n+                public void onCreated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Remote display has been created.\n+                    //Now is a good time to do parsing for spatial data\n+                    VideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                    //Get touch scalars\n+                    ImageResolution resolution = null;\n+                    if (internalInterface.getProtocolVersion().getMajor() >= 5) { //At this point we should already have the capability\n+                        VideoStreamingCapability capability = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                        }\n+                        if (capability != null) {\n+                            resolution = capability.getPreferredResolution();\n+                        }\n+                    }\n+\n+                    if (resolution == null) { //Either the protocol version is too low to access video streaming caps, or they were null\n+                        DisplayCapabilities dispCap = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                        }\n+                        if (dispCap != null) {\n+                            resolution = (dispCap.getScreenParams().getImageResolution());\n+                        }\n+                    }\n+\n+                    if (resolution != null) {\n+                        DisplayMetrics displayMetrics = new DisplayMetrics();\n+                        disp.getMetrics(displayMetrics);\n+                        createTouchScalar(resolution, displayMetrics);\n                     }\n \n-\t\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Our view has been invalidated\n-\t\t\t\t\t//A good time to refresh spatial data\n-\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\tsdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n-\t\t\t\t\tdisplayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n-\t\t\t\t\tdisplayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n-\t\t\t\t\tcreateTouchScalar(parameters.getResolution(), displayMetrics);\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ));\n-\t\t\tThread showPresentation = new Thread(fTask);\n-\t\t\tshowPresentation.setName(\"RmtDispThread\");\n-\n-\t\t\tshowPresentation.start();\n-\t\t} catch (Exception ex) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n-\t\t\tif(DebugTool.isDebugEnabled()){\n-\t\t\t\tex.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail){\n-\n-\t\tisTransportAvailable = videoStreamTransportAvail;\n-\n-\t\tif(internalInterface.getProtocolVersion().isNewerThan(new Version(5,1,0)) >= 0){\n-\t\t\tif(videoStreamTransportAvail){\n-\t\t\t\tcheckState();\n-\t\t\t}\n-\t\t}else{\n-\t\t\t//The protocol version doesn't support simultaneous transports.\n-\t\t\tif(!videoStreamTransportAvail){\n-\t\t\t\t//If video streaming isn't available on primary transport then it is not possible to\n-\t\t\t\t//use the video streaming manager until a complete register on a transport that\n-\t\t\t\t//supports video\n-\t\t\t\ttransitionToState(ERROR);\n-\t\t\t}\n-\t\t}\n-\t}\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+                }\n+\n+                @Override\n+                public void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Our view has been invalidated\n+                    //A good time to refresh spatial data\n+                    DisplayMetrics displayMetrics = new DisplayMetrics();\n+                    sdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n+                    displayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n+                    displayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n+                    createTouchScalar(parameters.getResolution(), displayMetrics);\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                }\n+            }));\n+            Thread showPresentation = new Thread(fTask);\n+            showPresentation.setName(\"RmtDispThread\");\n+\n+            showPresentation.start();\n+        } catch (Exception ex) {\n+            DebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n+            if (DebugTool.isDebugEnabled()) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail) {\n+\n+        isTransportAvailable = videoStreamTransportAvail;\n+\n+        if (internalInterface.getProtocolVersion().isNewerThan(new Version(5, 1, 0)) >= 0) {\n+            if (videoStreamTransportAvail) {\n+                checkState();\n+            }\n+        } else {\n+            //The protocol version doesn't support simultaneous transports.\n+            if (!videoStreamTransportAvail) {\n+                //If video streaming isn't available on primary transport then it is not possible to\n+                //use the video streaming manager until a complete register on a transport that\n+                //supports video\n+                transitionToState(ERROR);\n+            }\n+        }\n+    }\n \n     void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics) {\n-        touchScalar[0] = ((float)displayMetrics.widthPixels) / resolution.getResolutionWidth();\n-        touchScalar[1] = ((float)displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+        touchScalar[0] = ((float) displayMetrics.widthPixels) / resolution.getResolutionWidth();\n+        touchScalar[1] = ((float) displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+    }\n+\n+    List<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent) {\n+        List<MotionEvent> motionEventList = new ArrayList<>();\n+\n+        List<TouchEvent> touchEventList = onTouchEvent.getEvent();\n+        if (touchEventList == null || touchEventList.size() == 0) return null;\n+\n+        TouchType touchType = onTouchEvent.getType();\n+        if (touchType == null) {\n+            return null;\n+        }\n+\n+        if (sdlMotionEvent == null) {\n+            if (touchType == TouchType.BEGIN) {\n+                sdlMotionEvent = new SdlMotionEvent();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        SdlMotionEvent.Pointer pointer;\n+        MotionEvent motionEvent;\n+\n+        for (TouchEvent touchEvent : touchEventList) {\n+            if (touchEvent == null || touchEvent.getId() == null) {\n+                continue;\n+            }\n+\n+            List<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n+            if (touchCoordList == null || touchCoordList.size() == 0) {\n+                continue;\n+            }\n+\n+            TouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n+            if (touchCoord == null) {\n+                continue;\n+            }\n+\n+            int motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n+            long downTime = sdlMotionEvent.downTime;\n+            long eventTime = sdlMotionEvent.eventTime;\n+            pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n+            if (pointer != null) {\n+                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n+            }\n+\n+            MotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n+            MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n+\n+            for (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n+                pointerProperties[i] = new MotionEvent.PointerProperties();\n+                pointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n+                pointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n+\n+                pointerCoords[i] = new MotionEvent.PointerCoords();\n+                pointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n+                pointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n+                pointerCoords[i].orientation = 0;\n+                pointerCoords[i].pressure = 1.0f;\n+                pointerCoords[i].size = 1;\n+            }\n+\n+            motionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n+                    sdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n+                    1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n+            motionEventList.add(motionEvent);\n+\n+            if (motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL) {\n+                //If the motion event should be finished we should clear our reference\n+                sdlMotionEvent.pointers.clear();\n+                sdlMotionEvent = null;\n+                break;\n+            } else if ((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP) {\n+                sdlMotionEvent.removePointerById(touchEvent.getId());\n+            }\n+        }\n+\n+        return motionEventList;\n+    }\n+\n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n     }\n \n-\tList<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent){\n-\t\tList<MotionEvent> motionEventList = new ArrayList<MotionEvent>();\n-\n-\t\tList<TouchEvent> touchEventList = onTouchEvent.getEvent();\n-\t\tif (touchEventList == null || touchEventList.size() == 0) return null;\n-\n-\t\tTouchType touchType = onTouchEvent.getType();\n-\t\tif (touchType == null) { return null; }\n-\n-\t\tif(sdlMotionEvent == null) {\n-\t\t\tif (touchType == TouchType.BEGIN) {\n-\t\t\t\tsdlMotionEvent = new SdlMotionEvent();\n-\t\t\t} else{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tSdlMotionEvent.Pointer pointer;\n-\t\tMotionEvent motionEvent;\n-\n-\t\tfor (TouchEvent touchEvent : touchEventList) {\n-\t\t\tif (touchEvent == null || touchEvent.getId() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tList<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n-\t\t\tif (touchCoordList == null || touchCoordList.size() == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tTouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n-\t\t\tif (touchCoord == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tint motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n-\t\t\tlong downTime = sdlMotionEvent.downTime;\n-\t\t\tlong eventTime = sdlMotionEvent.eventTime;\n-\t\t\tpointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n-\t\t\tif (pointer != null) {\n-\t\t\t\tpointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n-\t\t\t}\n-\n-\t\t\tMotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n-\t\t\tMotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n-\n-\t\t\tfor (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n-\t\t\t\tpointerProperties[i] = new MotionEvent.PointerProperties();\n-\t\t\t\tpointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n-\t\t\t\tpointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n-\n-\t\t\t\tpointerCoords[i] = new MotionEvent.PointerCoords();\n-\t\t\t\tpointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n-\t\t\t\tpointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n-\t\t\t\tpointerCoords[i].orientation = 0;\n-\t\t\t\tpointerCoords[i].pressure = 1.0f;\n-\t\t\t\tpointerCoords[i].size = 1;\n-\t\t\t}\n-\n-\t\t\tmotionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n-\t\t\t\t\tsdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n-\t\t\t\t\t1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n-\t\t\tmotionEventList.add(motionEvent);\n-\n-\t\t\tif(motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL){\n-\t\t\t\t//If the motion event should be finished we should clear our reference\n-\t\t\t\tsdlMotionEvent.pointers.clear();\n-\t\t\t\tsdlMotionEvent = null;\n-\t\t\t\tbreak;\n-\t\t\t} else if((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP){\n-\t\t\t\tsdlMotionEvent.removePointerById(touchEvent.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn motionEventList;\n-\t}\n-\n-\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n-\t\treturn parameters;\n-\t}\n-\n-\tpublic boolean getLastCachedIsEncrypted() {\n-\t\treturn isEncrypted;\n-\t}\n-\n-\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n-\t\t\tResolution minResolution,\n-\t\t\tResolution maxResolution,\n-\t\t\tDouble constraintDiagonalMax,\n-\t\t\tAspectRatio ratioRange,\n-\t\t\tList<VideoStreamingCapability> originalAdditionalCapabilities\n-\t){\n-\t\tInteger constraintHeightMax = maxResolution.getResolutionHeight();\n-\t\tInteger constraintHeightMin = minResolution.getResolutionHeight();\n-\t\tInteger constraintWidthMax = maxResolution.getResolutionWidth();\n-\t\tInteger constraintWidthMin = minResolution.getResolutionWidth();\n-\t\tDouble aspectRationMin = ratioRange.getMinAspectRatio();\n-\t\tDouble aspectRationMax = ratioRange.getMaxAspectRatio();\n-\n-\t\tList<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n-\n-\t\tVideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n-\t\tpreferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n-\t\tpreferredCapability.setPreferredResolution(new ImageResolution(\n-\t\t\t\tparameters.getResolution().getResolutionWidth(),\n-\t\t\t\tparameters.getResolution().getResolutionHeight())\n-\t\t);\n-\n-\t\t// get the first one - the Desired resolution to guarantee streaming will start\n-\t\tvalidCapabilities.add(preferredCapability);\n-\n-\t\tfor (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n-\t\t\tdouble diagonal;\n-\t\t\tint resolutionHeight;\n-\t\t\tint resolutionWidth;\n-\t\t\t// TODO refactor\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionHeight() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionHeight = capability.getPreferredResolution().getResolutionHeight();\n-\t\t\t}\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionWidth() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionWidth = capability.getPreferredResolution().getResolutionWidth();\n-\t\t\t}\n-\t\t\tif (capability.getDiagonalScreenSize() == null ) {\n-\t\t\t\tdiagonal = parameters.getPreferredDiagonal();\n-\t\t\t} else {\n-\t\t\t\tdiagonal = capability.getDiagonalScreenSize();\n-\t\t\t}\n-\n-\t\t\tif (constraintDiagonalMax < diagonal) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!isAspectRatioInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tif (constraintHeightMax == null && constraintHeightMin == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!isImageResolutionInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tvalidCapabilities.add(capability);\n-\t\t}\n-\n-\t\treturn validCapabilities;\n-\t}\n-\n-\tpublic Boolean isImageResolutionInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\n-\t\tInteger constraintHeightMax = range.getMaxSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintHeightMin = range.getMinSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintWidthMax = range.getMaxSupportedResolution().getResolutionWidth();\n-\t\tInteger constraintWidthMin = range.getMinSupportedResolution().getResolutionWidth();\n-\t\tInteger resolutionHeight = currentResolution.getResolutionHeight();\n-\t\tInteger resolutionWidth = currentResolution.getResolutionWidth();\n-\t\tif (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null)\n-\t\t{\n-\t\t\tif (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tif (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// TODO check what if dev provided invalid constraints\n-\t\treturn true;\n-\t}\n-\n-\tpublic Boolean isAspectRatioInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\t\tDouble aspectRatioMin = range.getAspectRatio().getMinAspectRatio();\n-\t\tDouble aspectRatioMax = range.getAspectRatio().getMaxAspectRatio();\n-\n-\t\tDouble currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n-\n-\t\tif (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n-\t\t\tif ((currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\t// TODO check what if dev provided invalid constraints\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * Keeps track of the current motion event for VPM\n-\t */\n-\tprivate static class SdlMotionEvent {\n-\t\tclass Pointer {\n-\t\t\tint id;\n-\t\t\tfloat x;\n-\t\t\tfloat y;\n-\t\t\tPointer (int id) {\n-\t\t\t\tthis.id = id;\n-\t\t\t\tthis.x = 0.0f;\n-\t\t\t\tthis.y = 0.0f;\n-\t\t\t}\n-\t\t\tvoid setCoords(float x, float y) {\n-\t\t\t\tthis.x = x;\n-\t\t\t\tthis.y = y;\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n-\t\tprivate long downTime;\n-\t\tprivate long downTimeOnHMI;\n-\t\tprivate long eventTime;\n-\n-\t\tSdlMotionEvent(){\n-\t\t\tdownTimeOnHMI = 0;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n-\t\t * Android MotionEvent according to this events status\n-\t\t * @param touchType The SDL TouchType that was received from the module\n-\t\t * @param touchEvent The SDL TouchEvent that was received from the module\n-\t\t * @return the correct native Android MotionEvent action to dispatch\n-\t\t */\n-\t\tsynchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent){\n-\t\t\teventTime = 0;\n-\t\t\tint motionEventAction = -1;\n-\t\t\tswitch (touchType){\n-\t\t\t\tcase BEGIN:\n-\t\t\t\t\tif(pointers.size() == 0){\n-\t\t\t\t\t\t//The motion event has just begun\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_DOWN;\n-\t\t\t\t\t\tdownTime = SystemClock.uptimeMillis();\n-\t\t\t\t\t\tdownTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n-\t\t\t\t\t\teventTime = downTime;\n-\t\t\t\t\t} else{\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\t}\n-\t\t\t\t\tpointers.add(new Pointer(touchEvent.getId()));\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase MOVE:\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_MOVE;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase END:\n-\t\t\t\t\tif(pointers.size() <= 1){\n-\t\t\t\t\t\t//The motion event has just ended\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tint pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n-\t\t\t\t\t\tif (pointerIndex != -1) {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase CANCEL:\n-\t\t\t\t\t//Assuming this cancels the entire event\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_CANCEL;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\treturn motionEventAction;\n-\t\t}\n-\n-\t\tPointer getPointerById(int id){\n-\t\t\tif (pointers != null && !pointers.isEmpty()){\n-\t\t\t\tfor (Pointer pointer : pointers){\n-\t\t\t\t\tif (pointer.id == id){\n-\t\t\t\t\t\treturn pointer;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tPointer getPointerByIndex(int index){\n-\t\t\treturn pointers.get(index);\n-\t\t}\n-\n-\t\tvoid removePointerById(int id){\n-\t\t\tpointers.remove(getPointerById(id));\n-\t\t}\n-\t}\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n+        Double aspectRatioMin = aspectRatio.getMinAspectRatio();\n+        Double aspectRatioMax = aspectRatio.getMaxAspectRatio();\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n+            if (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Keeps track of the current motion event for VPM\n+     */\n+    private static class SdlMotionEvent {\n+        class Pointer {\n+            final int id;\n+            float x;\n+            float y;\n+\n+            Pointer(int id) {\n+                this.id = id;\n+                this.x = 0.0f;\n+                this.y = 0.0f;\n+            }\n+\n+            void setCoords(float x, float y) {\n+                this.x = x;\n+                this.y = y;\n+            }\n+        }\n+\n+        private final CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n+        private long downTime;\n+        private long downTimeOnHMI;\n+        private long eventTime;\n+\n+        SdlMotionEvent() {\n+            downTimeOnHMI = 0;\n+        }\n+\n+        /**\n+         * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n+         * Android MotionEvent according to this events status\n+         *\n+         * @param touchType  The SDL TouchType that was received from the module\n+         * @param touchEvent The SDL TouchEvent that was received from the module\n+         * @return the correct native Android MotionEvent action to dispatch\n+         */\n+        synchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent) {\n+            eventTime = 0;\n+            int motionEventAction = -1;\n+            switch (touchType) {\n+                case BEGIN:\n+                    if (pointers.size() == 0) {\n+                        //The motion event has just begun\n+                        motionEventAction = MotionEvent.ACTION_DOWN;\n+                        downTime = SystemClock.uptimeMillis();\n+                        downTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n+                        eventTime = downTime;\n+                    } else {\n+                        motionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    }\n+                    pointers.add(new Pointer(touchEvent.getId()));\n+                    break;\n+                case MOVE:\n+                    motionEventAction = MotionEvent.ACTION_MOVE;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case END:\n+                    if (pointers.size() <= 1) {\n+                        //The motion event has just ended\n+                        motionEventAction = MotionEvent.ACTION_UP;\n+                    } else {\n+                        int pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n+                        if (pointerIndex != -1) {\n+                            motionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        } else {\n+                            motionEventAction = MotionEvent.ACTION_UP;\n+                        }\n+                    }\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case CANCEL:\n+                    //Assuming this cancels the entire event\n+                    motionEventAction = MotionEvent.ACTION_CANCEL;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return motionEventAction;\n+        }\n+\n+        Pointer getPointerById(int id) {\n+            if (pointers != null && !pointers.isEmpty()) {\n+                for (Pointer pointer : pointers) {\n+                    if (pointer.id == id) {\n+                        return pointer;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        Pointer getPointerByIndex(int index) {\n+            return pointers.get(index);\n+        }\n+\n+        void removePointerById(int id) {\n+            pointers.remove(getPointerById(id));\n+        }\n+    }\n+\n+    private VideoStreamingProtocol getAcceptedProtocol(VideoStreamingParameters params) {\n+        if (params != null) {\n+            VideoStreamingFormat format = params.getFormat();\n+            if (format != null && format.getProtocol() != null) {\n+                return format.getProtocol();\n+            }\n+        }\n+        //Returns default protocol if none are found\n+        return new VideoStreamingParameters().getFormat().getProtocol();\n+\n+    }\n+\n+    protected IVideoStreamListener startVideoStream(VideoStreamingParameters params, final SdlSession session) {\n+        VideoStreamingProtocol protocol = getAcceptedProtocol(params);\n+\n+        IStreamListener iStreamListener = new IStreamListener() {\n+            @Override\n+            public void sendStreamPacket(ProtocolMessage pm) {\n+                session.sendMessage(pm);\n+            }\n+        };\n+\n+        try {\n+            switch (protocol) {\n+                case RAW: {\n+                    videoPacketizer = new StreamPacketizer(iStreamListener, null, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                case RTP: {\n+                    //FIXME why is this not an extension of StreamPacketizer?\n+                    videoPacketizer = new RTPH264Packetizer(iStreamListener, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                default:\n+                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\n+                    return null;\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    protected boolean stopVideoStream() {\n+        if (videoPacketizer != null) {\n+            videoPacketizer.stop();\n+            return true;\n+        }\n+        return false;\n+    }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjczMzMxMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472733313", "bodyText": "Can you delete the overloaded configureGlobalParameters method (the one with 3 parameters), and just use this one and set this.streamingRange = streamingRange; if streamingRange is not null?", "author": "santhanamk", "createdAt": "2020-08-19T05:56:54Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -262,23 +337,69 @@ public void onError(String info) {\n \t *\n \t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n \t */\n+\t@Deprecated\n \tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tint majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted);\n \t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n \t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n \t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n \t\t\treturn;\n \t\t}\n+\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+\t\t\tgetVideoStreamingParams();\n+\t\t}\n+\t\tcheckState();\n+\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n+\t}\n+\n+\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted) {\n+\t\tthis.context = new WeakReference<>(context);\n+\t\tthis.remoteDisplayClass = remoteDisplayClass;\n+\t\tthis.isEncrypted = encrypted;\n+\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+\t}\n+\n+\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange streamingRange) {", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzMjcwMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473332701", "bodyText": "Can you delete the overloaded configureGlobalParameters method (the one with 3 parameters), and just use this one and set this.streamingRange = streamingRange; if streamingRange is not null?\n\n@kostyaBoss I still see this issue.  Are you able to make this change?", "author": "santhanamk", "createdAt": "2020-08-19T21:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjczMzMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 5461d9d4d..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -65,898 +65,968 @@ import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.TouchCoord;\n import com.smartdevicelink.proxy.rpc.TouchEvent;\n import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.TouchType;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n import com.smartdevicelink.proxy.rpc.enums.VideoStreamingState;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.session.SdlSession;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.IVideoStreamListener;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n import com.smartdevicelink.transport.utl.TransportRecord;\n import com.smartdevicelink.util.DebugTool;\n import com.smartdevicelink.util.Version;\n \n+import java.io.IOException;\n import java.lang.ref.WeakReference;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.FutureTask;\n \n @TargetApi(19)\n public class VideoStreamManager extends BaseVideoStreamManager {\n-\tprivate static String TAG = \"VideoStreamManager\";\n-\n-\tprivate WeakReference<Context> context;\n-\tprivate volatile VirtualDisplayEncoder virtualDisplayEncoder;\n-\tprivate Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n-\tprivate SdlRemoteDisplay sdlRemoteDisplay;\n-\tprivate float[] touchScalar = {1.0f,1.0f}; //x, y\n-\tprivate HapticInterfaceManager hapticManager;\n-\tprivate SdlMotionEvent sdlMotionEvent = null;\n-\tprivate OnHMIStatus currentOnHMIStatus;\n-\tprivate StreamingStateMachine stateMachine;\n-\tprivate VideoStreamingParameters parameters;\n-\tprivate VideoStreamingCapability originalCapability;\n-\tprivate IVideoStreamListener streamListener;\n-\tprivate boolean isTransportAvailable = false;\n-\tprivate Integer majorProtocolVersion;\n-\tprivate VideoStreamingRange streamingRange;\n-\tprivate boolean hasStarted;\n-\tprivate String vehicleMake = null;\n-\tprivate boolean isEncrypted = false;\n-\tprivate boolean withPendingRestart = false;\n-\n-\t// INTERNAL INTERFACES\n-\n-\tprivate final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif (session != null && session.getAcceptedVideoParams() != null) {\n-\t\t\t\t\tparameters = session.getAcceptedVideoParams();\n-\t\t\t\t\tVideoStreamManager.this.streamListener = session.startVideoStream();\n-\t\t\t\t}\n-\n-\t\t\t\tif (VideoStreamManager.this.streamListener == null) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error starting video stream\");\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\tif(capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())){\n-\t\t\t\t\thapticManager = new HapticInterfaceManager(internalInterface);\n-\t\t\t\t}\n-\t\t\t\tcheckState();\n-\t\t\t\tstartEncoder();\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\t\thasStarted = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SdlSession session, SessionType type) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif(sdlRemoteDisplay !=null){\n-\t\t\t\t    // TODO set withPendingRestart to default in proper place\n-\t\t\t\t\tstopStreaming(withPendingRestart);\n-\t\t\t\t}\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\t\t\ttransitionToState(SETTING_UP);\n-\n-\t\t\t\tif (withPendingRestart){\n-\t\t\t\t\tVideoStreamManager manager = VideoStreamManager.this;\n-\t\t\t\t\tmanager.internalInterface.startVideoService(\n-\t\t\t\t\t\t\tmanager.getLastCachedStreamingParameters(),\n-\t\t\t\t\t\t\tmanager.isEncrypted\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceError(SdlSession session, SessionType type, String reason) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null){\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tOnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n-\t\t\t\tcurrentOnHMIStatus = onHMIStatus;\n-\n-\t\t\t\tif (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n-\t\t\t\t\tinternalInterface.stopVideoService();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null && sdlRemoteDisplay != null){\n-\t\t\t\tList<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent)notification);\n-\t\t\t\tif (motionEventList != null && !motionEventList.isEmpty()) {\n-\t\t\t\t\tfor (MotionEvent motionEvent : motionEventList) {\n-\t\t\t\t\t\tsdlRemoteDisplay.handleMotionEvent(motionEvent);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t@Override\n-\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\n-\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\n-\t\t\t// means only scale received\n-\t\t\tif (castedCapability.getPreferredResolution() == null &&\n-\t\t\t\t\tcastedCapability.getScale() != null &&\n-\t\t\t\t\tcastedCapability.getScale() != 0 &&\n-\t\t\t\t\tVideoStreamManager.this.parameters != null\n-\t\t\t\t\t&& VideoStreamManager.this.parameters.getResolution() != null) {\n-\t\t\t\t// set cached resolution\n-\t\t\t\tcastedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n-\t\t\t}\n-\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\tVideoStreamManager.this.withPendingRestart = true;\n-\n-\t\t\tvirtualDisplayEncoder.setStreamingParams(params);\n-\t\t\tstopStreaming(true);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onError(String info) {\n-\t\t\tLog.d(\"MyTagLogInfo\", info);\n-\t\t}\n-\t};\n-\n-\t// MANAGER APIs\n-\tpublic VideoStreamManager(ISdl internalInterface){\n-\t\tsuper(internalInterface);\n-\n-\t\tif(internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n-\t\t\t\tinternalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n-\t\t\tvehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n-\t\t}\n-\t\tvirtualDisplayEncoder = new VirtualDisplayEncoder();\n-\n-\t\t// Listen for video service events\n-\t\tinternalInterface.addServiceListener(SessionType.NAV, serviceListener);\n-\t\t// Take care of the touch events\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t// Listen for HMILevel changes\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t// Listen for SystemCapabilityType VIDEO_STREAMING\n-\t\tinternalInterface.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n-\t\tstateMachine = new StreamingStateMachine();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\tisTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n-\t\tcheckState();\n-\t\tsuper.start(listener);\n-\t}\n-\n-\tprivate synchronized void checkState(){\n-\t\tif(this.getState() == SETTING_UP\n-\t\t\t\t&& isTransportAvailable\n-\t\t\t\t&& isHMIStateVideoStreamCapable(currentOnHMIStatus)\n-\t\t\t\t&& parameters != null){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.READY);\n-\t\t\ttransitionToState(READY);\n-\t\t}\n-\t}\n-\n-\tboolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n-\t\tHMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n-\t\tVideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n-\t\treturn (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n-\t}\n-\n-\tprivate void getVideoStreamingParams(){\n-\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5) {\n-\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\tcheckState();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\ttransitionToState(ERROR);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\t//We just use default video streaming params\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\tif(dispCap !=null){\n-\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t}\n-\n-\t\t\tthis.parameters = params;\n-\t\t\tcheckState();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param streamingRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tthis.streamingRange = streamingRange;\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n-\t\tif(parameters == null){\n-\t\t\tif(majorProtocolVersion >= 5) {\n-\t\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\n-\t\t\t\t\t\t// Mocks data here\n-\t\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\t\t\t\tif (streamingRange != null) {\n-\t\t\t\t\t\t\t// filtering\n-\t\t\t\t\t\t\tcastedCapability.setAdditionalVideoStreamingCapabilities(\n-\t\t\t\t\t\t\t\t\tgetSupportedCapabilities(\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxScreenDiagonal(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getAspectRatio(),\n-\t\t\t\t\t\t\t\t\t\t\tcastedCapability.getAdditionalVideoStreamingCapabilities()\n-\t\t\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// TODO handle??\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tOnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n-\t\t\t\t\t\tinternalInterface.sendRPC(onAppCapabilityUpdated);\n-\t\t\t\t\t\tstartStreaming(params, isEncrypted);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}else{\n-\t\t\t\t//We just use default video streaming params\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\tif(dispCap !=null){\n-\t\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t}\n-\t\t\t\tstartStreaming(params, encrypted);\n-\t\t\t}\n-\t\t}else{\n-\t\t\tstartStreaming(parameters, encrypted);\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n-\t * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n-\t *                    VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n-\t * @param encrypted Specify true if packets on this service have to be encrypted\n-\t */\n-\tprotected void startStreaming(VideoStreamingParameters parameters, boolean encrypted){\n-\t\tthis.parameters = parameters;\n-\t\tif (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n-\t\t\tDebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n-\t\t\treturn;\n-\t\t}\n-\t\t//Start the video service\n-\t\tthis.internalInterface.startVideoService(parameters, encrypted);\n-\t}\n-\n-\t/**\n-\t * Initializes and starts the virtual display encoder and creates the remote display\n-\t */\n-\tprivate void startEncoder(){\n-\t\ttry {\n-\t\t\tif (sdlRemoteDisplay != null) {\n-\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t}\n-\n-\t\t\tvirtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n-\t\t\t//We are all set so we can start streaming at at this point\n-\t\t\tvirtualDisplayEncoder.start();\n-\t\t\t//Encoder should be up and running\n-\t\t\tDisplay display = virtualDisplayEncoder.getDisplay();\n-\t\t\tcreateRemoteDisplay(display);\n-\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\thasStarted = true;\n-\t\t} catch (Exception e) {\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming from the remote display. To restart, call\n-\t * @see #resumeStreaming()\n-\t */\n-\tpublic void stopStreaming(boolean withPendingRestart){\n-\t\tif(sdlRemoteDisplay!=null && !withPendingRestart){\n-\t\t\tsdlRemoteDisplay.stop();\n-\t\t\tthis.withPendingRestart = false;\n-\t\t}\n-\t\tif (this.isStreaming()) {\n-\t\t\tif(virtualDisplayEncoder!=null){\n-\t\t\t\tvirtualDisplayEncoder.shutDown(withPendingRestart);\n-\t\t\t}\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.PAUSED);\n-\n-\t\t\tthis.internalInterface.stopVideoService();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Resumes streaming after calling\n-\t * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n-\t * followed by a call to\n-\t * @see #stopStreaming(boolean withPendingRestart)\n-\t */\n-\tpublic void resumeStreaming(){\n-\t\tint currentState = stateMachine.getState();\n-\t\tif (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n-\t\t\tstartEncoder();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming, ends video streaming service and removes service listeners.\n-\t */\n-\t@Override\n-\tpublic void dispose(){\n-\t\tstopStreaming(false);\n-\n-\t\thapticManager = null;\n-\t\tsdlRemoteDisplay = null;\n-\t\tparameters = null;\n-\t\tvirtualDisplayEncoder = null;\n-\t\tif (internalInterface != null) {\n-\t\t\tinternalInterface.stopVideoService();\n-\t\t\t// Remove listeners\n-\t\t\tinternalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t}\n-\n-\n-\n-\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\tsuper.dispose();\n-\t}\n-\n-\t// PUBLIC METHODS FOR CHECKING STATE\n-\n-\t/**\n-\t * Check if a video service is currently active\n-\t * @return boolean (true = active, false = inactive)\n-\t */\n-\tpublic boolean isServiceActive(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.READY) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STARTED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.PAUSED);\n-\t}\n-\n-\t/**\n-\t * Check if video is currently streaming and visible\n-\t * @return boolean (true = yes, false = no)\n-\t */\n-\tpublic boolean isStreaming(){\n-\t\tboolean state = (stateMachine.getState() == StreamingStateMachine.STARTED);\n-\t\tboolean capable = isHMIStateVideoStreamCapable(currentOnHMIStatus);\n-\t\treturn state && capable;\n-\t}\n-\n-\t/**\n-\t * Check if video streaming has been paused due to app moving to background or manually stopped\n-\t * @return boolean (true = not paused, false = paused)\n-\t */\n-\tpublic boolean isPaused(){\n-\t\treturn (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n-\t}\n-\n-\t/**\n-\t * Gets the current video streaming state as defined in @StreamingStateMachine\n-\t * @return int representing StreamingStateMachine.StreamingState\n-\t */\n-\tpublic @StreamingStateMachine.StreamingState int currentVideoStreamState(){\n-\t\treturn stateMachine.getState();\n-\t}\n-\n-\t// HELPER METHODS\n-\n-\tprivate void createRemoteDisplay(final Display disp){\n-\t\ttry{\n-\t\t\tif (disp == null){\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Dismiss the current presentation if the display has changed.\n-\t\t\tif (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n-\t\t\t\tsdlRemoteDisplay.dismissPresentation();\n-\t\t\t}\n-\n-\t\t\tFutureTask<Boolean> fTask =  new FutureTask<Boolean>( new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback(){\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCreated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Remote display has been created.\n-\t\t\t\t\t//Now is a good time to do parsing for spatial data\n-\t\t\t\t\tVideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\t//Get touch scalars\n-\t\t\t\t\tImageResolution resolution = null;\n-\t\t\t\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5){ //At this point we should already have the capability\n-\t\t\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\t\t\tif(capability != null){\n-\t\t\t\t\t\t\tresolution = capability.getPreferredResolution();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution == null){ //Either the protocol version is too low to access video streaming caps, or they were null\n-\t\t\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities) internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\t\t\tif (dispCap != null) {\n-\t\t\t\t\t\t\tresolution = (dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution != null){\n-\t\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\t\tdisp.getMetrics(displayMetrics);\n-\t\t\t\t\t\tcreateTouchScalar(resolution, displayMetrics);\n+    private static final String TAG = \"VideoStreamManager\";\n+\n+    private WeakReference<Context> context;\n+    private volatile VirtualDisplayEncoder virtualDisplayEncoder;\n+    private Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n+    private SdlRemoteDisplay sdlRemoteDisplay;\n+    private final float[] touchScalar = {1.0f, 1.0f}; //x, y\n+    private HapticInterfaceManager hapticManager;\n+    private SdlMotionEvent sdlMotionEvent = null;\n+    private OnHMIStatus currentOnHMIStatus;\n+    private final StreamingStateMachine stateMachine;\n+    private VideoStreamingParameters parameters;\n+    private VideoStreamingCapability originalCapability;\n+    private IVideoStreamListener streamListener;\n+    private boolean isTransportAvailable = false;\n+    private Integer majorProtocolVersion;\n+    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private boolean hasStarted;\n+    private String vehicleMake = null;\n+    private boolean isEncrypted = false;\n+    private boolean withPendingRestart = false;\n+    private AbstractPacketizer videoPacketizer;\n+\n+    // INTERNAL INTERFACES\n+\n+    private final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n+        @Override\n+        public void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n+            if (SessionType.NAV.equals(type)) {\n+                if (session != null && session.getAcceptedVideoParams() != null) {\n+                    parameters = session.getAcceptedVideoParams();\n+                    VideoStreamManager.this.streamListener = startVideoStream(session.getAcceptedVideoParams(), session);\n+                }\n+\n+                if (VideoStreamManager.this.streamListener == null) {\n+                    DebugTool.logError(TAG, \"Error starting video stream\");\n+                    stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                    return;\n+                }\n+                VideoStreamingCapability capability = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                }\n+                if (capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())) {\n+                    hapticManager = new HapticInterfaceManager(internalInterface);\n+                }\n+                checkState();\n+                startEncoder();\n+                stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+                hasStarted = true;\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceEnded(SdlSession session, SessionType type) {\n+            if (SessionType.NAV.equals(type)) {\n+                //stopVideoStream();\n+                if (sdlRemoteDisplay !=null){\n+                    stopStreaming(withPendingRestart);\n+                }\n+                stateMachine.transitionToState(StreamingStateMachine.NONE);\n+                transitionToState(SETTING_UP);\n+\n+                if (withPendingRestart){\n+                    VideoStreamManager manager = VideoStreamManager.this;\n+                    manager.internalInterface.startVideoService(\n+                            manager.getLastCachedStreamingParameters(),\n+                            manager.isEncrypted,\n+                            withPendingRestart\n+                    );\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceError(SdlSession session, SessionType type, String reason) {\n+            DebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n+            stopVideoStream();\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            transitionToState(BaseSubManager.ERROR);\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                OnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n+                currentOnHMIStatus = onHMIStatus;\n+                if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+                    getVideoStreamingParams();\n+                }\n+                checkState();\n+                if (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n+                    stopVideoStream();\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null && sdlRemoteDisplay != null) {\n+                List<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent) notification);\n+                if (motionEventList != null && !motionEventList.isEmpty()) {\n+                    for (MotionEvent motionEvent : motionEventList) {\n+                        sdlRemoteDisplay.handleMotionEvent(motionEvent);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+\n+            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+            // means only scale received\n+            if (castedCapability.getPreferredResolution() == null &&\n+                    castedCapability.getScale() != null &&\n+                    castedCapability.getScale() != 0 &&\n+                    VideoStreamManager.this.parameters != null\n+                    && VideoStreamManager.this.parameters.getResolution() != null) {\n+                // set cached resolution\n+                castedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+            }\n+            params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+            VideoStreamManager.this.parameters = params;\n+\n+            VideoStreamManager.this.withPendingRestart = true;\n+\n+            virtualDisplayEncoder.setStreamingParams(params);\n+            stopStreaming(true);\n+        }\n+\n+        @Override\n+        public void onError(String info) { }\n+    };\n+\n+    // MANAGER APIs\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public VideoStreamManager(ISdl internalInterface) {\n+        super(internalInterface);\n+\n+        if (internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n+                internalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n+            vehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n+        }\n+        virtualDisplayEncoder = new VirtualDisplayEncoder();\n+\n+        // Listen for video service events\n+        internalInterface.addServiceListener(SessionType.NAV, serviceListener);\n+        // Take care of the touch events\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+        // Listen for HMILevel changes\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        // Listen for SystemCapabilityType VIDEO_STREAMING\n+        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n+        stateMachine = new StreamingStateMachine();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        isTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n+        checkState();\n+        super.start(listener);\n+    }\n+\n+    private synchronized void checkState() {\n+        if (this.getState() == SETTING_UP\n+                && isTransportAvailable\n+                && isHMIStateVideoStreamCapable(currentOnHMIStatus)\n+                && parameters != null) {\n+            stateMachine.transitionToState(StreamingStateMachine.READY);\n+            transitionToState(READY);\n+        }\n+    }\n+\n+    boolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n+        HMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n+        VideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n+        return (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n+    }\n+\n+    private void getVideoStreamingParams() {\n+        if (internalInterface.getProtocolVersion().getMajor() >= 5) {\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                    @Override\n+                    public void onCapabilityRetrieved(Object capability) {\n+                        VideoStreamingParameters params = new VideoStreamingParameters();\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+                        params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+                        // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                        checkState();\n+                        }\n+\n+                    @Override\n+                    public void onError(String info) {\n+                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                        transitionToState(ERROR);\n+                    }\n+                }, false);\n+            }\n+        } else {\n+            //We just use default video streaming params\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+            DisplayCapabilities dispCap = null;\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+            }\n+            if (dispCap != null) {\n+                params.setResolution(dispCap.getScreenParams().getImageResolution());\n+            }\n+\n+            this.parameters = params;\n+            checkState();\n+        }\n+    }\n+\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {\n+            if (majorProtocolVersion >= 5) {\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                        @Override\n+                        public void onCapabilityRetrieved(Object capability) {\n+                            VideoStreamingParameters params = new VideoStreamingParameters();\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                            VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                            // Mocks data here\n+                            // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                            params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+                            if (listOfStreamingRanges != null) {\n+                                // filtering\n+                                castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                                );\n+                            } else { }\n+                            OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n+                            internalInterface.sendRPC(onAppCapabilityUpdated);\n+                            startStreaming(params, isEncrypted);\n+                        }\n+\n+                        @Override\n+                        public void onError(String info) {\n+                            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                            DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        }\n+                    }, false);\n+                }\n+            } else {\n+                //We just use default video streaming params\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                DisplayCapabilities dispCap = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                }\n+                if (dispCap != null) {\n+                    params.setResolution(dispCap.getScreenParams().getImageResolution());\n+                }\n+                startStreaming(params, encrypted);\n+            }\n+        } else {\n+            startStreaming(parameters, encrypted);\n+        }\n+    }\n+\n+\n+    /**\n+     * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n+     *\n+     * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n+     *                   VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n+     * @param encrypted  Specify true if packets on this service have to be encrypted\n+     */\n+    protected void startStreaming(VideoStreamingParameters parameters, boolean encrypted) {\n+        this.parameters = parameters;\n+        if (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n+            DebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n+            return;\n+        }\n+        //Start the video service\n+        this.internalInterface.startVideoService(parameters, encrypted, false);\n+    }\n+\n+    /**\n+     * Initializes and starts the virtual display encoder and creates the remote display\n+     */\n+    private void startEncoder() {\n+        try {\n+            if (sdlRemoteDisplay != null) {\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+            }\n+\n+            virtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n+            //We are all set so we can start streaming at at this point\n+            virtualDisplayEncoder.start();\n+            //Encoder should be up and running\n+            createRemoteDisplay(virtualDisplayEncoder.getDisplay());\n+\n+            stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+            hasStarted = true;\n+        } catch (Exception e) {\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    public void stopStreaming(boolean withPendingRestart) {\n+        if (sdlRemoteDisplay!= null && !withPendingRestart) {\n+            sdlRemoteDisplay.stop();\n+                this.withPendingRestart = false;\n+        }\n+        if (this.isStreaming()) {\n+            if (virtualDisplayEncoder!=null){\n+                virtualDisplayEncoder.shutDown(withPendingRestart);\n+            }\n+            stateMachine.transitionToState(StreamingStateMachine.PAUSED);\n+            stopVideoStream();\n+        }\n+    }\n+\n+    /**\n+     * Resumes streaming after calling\n+     *\n+     * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n+     * followed by a call to\n+     * @see #stopStreaming(boolean withPendingRestart)\n+     */\n+    public void resumeStreaming() {\n+        int currentState = stateMachine.getState();\n+        if (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n+            startEncoder();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming, ends video streaming service and removes service listeners.\n+     */\n+    @Override\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void dispose() {\n+        stopStreaming(false);\n+\n+        hapticManager = null;\n+        sdlRemoteDisplay = null;\n+        parameters = null;\n+        virtualDisplayEncoder = null;\n+        if (internalInterface != null) {\n+            // Remove listeners\n+            internalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        }\n+\n+        stopVideoStream();\n+\n+\n+        stateMachine.transitionToState(StreamingStateMachine.NONE);\n+        super.dispose();\n+    }\n+\n+    // PUBLIC METHODS FOR CHECKING STATE\n+\n+    /**\n+     * Check if a video service is currently active\n+     *\n+     * @return boolean (true = active, false = inactive)\n+     */\n+    public boolean isServiceActive() {\n+        return (stateMachine.getState() == StreamingStateMachine.READY) ||\n+                (stateMachine.getState() == StreamingStateMachine.STARTED) ||\n+                (stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n+                (stateMachine.getState() == StreamingStateMachine.PAUSED);\n+        }\n+\n+    /**\n+     * Check if video is currently streaming and visible\n+     *\n+     * @return boolean (true = yes, false = no)\n+     */\n+    public boolean isStreaming() {\n+        return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Check if video streaming has been paused due to app moving to background or manually stopped\n+     *\n+     * @return boolean (true = not paused, false = paused)\n+     */\n+    public boolean isPaused() {\n+        return (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Gets the current video streaming state as defined in @StreamingStateMachine\n+     *\n+     * @return int representing StreamingStateMachine.StreamingState\n+     */\n+    public @StreamingStateMachine.StreamingState\n+    int currentVideoStreamState() {\n+        return stateMachine.getState();\n+    }\n+\n+    // HELPER METHODS\n+\n+    private void createRemoteDisplay(final Display disp) {\n+        try {\n+            if (disp == null) {\n+                return;\n+            }\n+\n+            // Dismiss the current presentation if the display has changed.\n+            if (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n+                sdlRemoteDisplay.dismissPresentation();\n+            }\n+\n+            FutureTask<Boolean> fTask = new FutureTask<>(new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback() {\n+                @Override\n+                public void onCreated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Remote display has been created.\n+                    //Now is a good time to do parsing for spatial data\n+                    VideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                    //Get touch scalars\n+                    ImageResolution resolution = null;\n+                    if (internalInterface.getProtocolVersion().getMajor() >= 5) { //At this point we should already have the capability\n+                        VideoStreamingCapability capability = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                        }\n+                        if (capability != null) {\n+                            resolution = capability.getPreferredResolution();\n+                        }\n+                    }\n+\n+                    if (resolution == null) { //Either the protocol version is too low to access video streaming caps, or they were null\n+                        DisplayCapabilities dispCap = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                        }\n+                        if (dispCap != null) {\n+                            resolution = (dispCap.getScreenParams().getImageResolution());\n+                        }\n+                    }\n+\n+                    if (resolution != null) {\n+                        DisplayMetrics displayMetrics = new DisplayMetrics();\n+                        disp.getMetrics(displayMetrics);\n+                        createTouchScalar(resolution, displayMetrics);\n                     }\n \n-\t\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Our view has been invalidated\n-\t\t\t\t\t//A good time to refresh spatial data\n-\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\tsdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n-\t\t\t\t\tdisplayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n-\t\t\t\t\tdisplayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n-\t\t\t\t\tcreateTouchScalar(parameters.getResolution(), displayMetrics);\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ));\n-\t\t\tThread showPresentation = new Thread(fTask);\n-\t\t\tshowPresentation.setName(\"RmtDispThread\");\n-\n-\t\t\tshowPresentation.start();\n-\t\t} catch (Exception ex) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n-\t\t\tif(DebugTool.isDebugEnabled()){\n-\t\t\t\tex.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail){\n-\n-\t\tisTransportAvailable = videoStreamTransportAvail;\n-\n-\t\tif(internalInterface.getProtocolVersion().isNewerThan(new Version(5,1,0)) >= 0){\n-\t\t\tif(videoStreamTransportAvail){\n-\t\t\t\tcheckState();\n-\t\t\t}\n-\t\t}else{\n-\t\t\t//The protocol version doesn't support simultaneous transports.\n-\t\t\tif(!videoStreamTransportAvail){\n-\t\t\t\t//If video streaming isn't available on primary transport then it is not possible to\n-\t\t\t\t//use the video streaming manager until a complete register on a transport that\n-\t\t\t\t//supports video\n-\t\t\t\ttransitionToState(ERROR);\n-\t\t\t}\n-\t\t}\n-\t}\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+                }\n+\n+                @Override\n+                public void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Our view has been invalidated\n+                    //A good time to refresh spatial data\n+                    DisplayMetrics displayMetrics = new DisplayMetrics();\n+                    sdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n+                    displayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n+                    displayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n+                    createTouchScalar(parameters.getResolution(), displayMetrics);\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                }\n+            }));\n+            Thread showPresentation = new Thread(fTask);\n+            showPresentation.setName(\"RmtDispThread\");\n+\n+            showPresentation.start();\n+        } catch (Exception ex) {\n+            DebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n+            if (DebugTool.isDebugEnabled()) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail) {\n+\n+        isTransportAvailable = videoStreamTransportAvail;\n+\n+        if (internalInterface.getProtocolVersion().isNewerThan(new Version(5, 1, 0)) >= 0) {\n+            if (videoStreamTransportAvail) {\n+                checkState();\n+            }\n+        } else {\n+            //The protocol version doesn't support simultaneous transports.\n+            if (!videoStreamTransportAvail) {\n+                //If video streaming isn't available on primary transport then it is not possible to\n+                //use the video streaming manager until a complete register on a transport that\n+                //supports video\n+                transitionToState(ERROR);\n+            }\n+        }\n+    }\n \n     void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics) {\n-        touchScalar[0] = ((float)displayMetrics.widthPixels) / resolution.getResolutionWidth();\n-        touchScalar[1] = ((float)displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+        touchScalar[0] = ((float) displayMetrics.widthPixels) / resolution.getResolutionWidth();\n+        touchScalar[1] = ((float) displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+    }\n+\n+    List<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent) {\n+        List<MotionEvent> motionEventList = new ArrayList<>();\n+\n+        List<TouchEvent> touchEventList = onTouchEvent.getEvent();\n+        if (touchEventList == null || touchEventList.size() == 0) return null;\n+\n+        TouchType touchType = onTouchEvent.getType();\n+        if (touchType == null) {\n+            return null;\n+        }\n+\n+        if (sdlMotionEvent == null) {\n+            if (touchType == TouchType.BEGIN) {\n+                sdlMotionEvent = new SdlMotionEvent();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        SdlMotionEvent.Pointer pointer;\n+        MotionEvent motionEvent;\n+\n+        for (TouchEvent touchEvent : touchEventList) {\n+            if (touchEvent == null || touchEvent.getId() == null) {\n+                continue;\n+            }\n+\n+            List<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n+            if (touchCoordList == null || touchCoordList.size() == 0) {\n+                continue;\n+            }\n+\n+            TouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n+            if (touchCoord == null) {\n+                continue;\n+            }\n+\n+            int motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n+            long downTime = sdlMotionEvent.downTime;\n+            long eventTime = sdlMotionEvent.eventTime;\n+            pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n+            if (pointer != null) {\n+                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n+            }\n+\n+            MotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n+            MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n+\n+            for (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n+                pointerProperties[i] = new MotionEvent.PointerProperties();\n+                pointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n+                pointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n+\n+                pointerCoords[i] = new MotionEvent.PointerCoords();\n+                pointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n+                pointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n+                pointerCoords[i].orientation = 0;\n+                pointerCoords[i].pressure = 1.0f;\n+                pointerCoords[i].size = 1;\n+            }\n+\n+            motionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n+                    sdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n+                    1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n+            motionEventList.add(motionEvent);\n+\n+            if (motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL) {\n+                //If the motion event should be finished we should clear our reference\n+                sdlMotionEvent.pointers.clear();\n+                sdlMotionEvent = null;\n+                break;\n+            } else if ((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP) {\n+                sdlMotionEvent.removePointerById(touchEvent.getId());\n+            }\n+        }\n+\n+        return motionEventList;\n+    }\n+\n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n     }\n \n-\tList<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent){\n-\t\tList<MotionEvent> motionEventList = new ArrayList<MotionEvent>();\n-\n-\t\tList<TouchEvent> touchEventList = onTouchEvent.getEvent();\n-\t\tif (touchEventList == null || touchEventList.size() == 0) return null;\n-\n-\t\tTouchType touchType = onTouchEvent.getType();\n-\t\tif (touchType == null) { return null; }\n-\n-\t\tif(sdlMotionEvent == null) {\n-\t\t\tif (touchType == TouchType.BEGIN) {\n-\t\t\t\tsdlMotionEvent = new SdlMotionEvent();\n-\t\t\t} else{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tSdlMotionEvent.Pointer pointer;\n-\t\tMotionEvent motionEvent;\n-\n-\t\tfor (TouchEvent touchEvent : touchEventList) {\n-\t\t\tif (touchEvent == null || touchEvent.getId() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tList<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n-\t\t\tif (touchCoordList == null || touchCoordList.size() == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tTouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n-\t\t\tif (touchCoord == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tint motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n-\t\t\tlong downTime = sdlMotionEvent.downTime;\n-\t\t\tlong eventTime = sdlMotionEvent.eventTime;\n-\t\t\tpointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n-\t\t\tif (pointer != null) {\n-\t\t\t\tpointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n-\t\t\t}\n-\n-\t\t\tMotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n-\t\t\tMotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n-\n-\t\t\tfor (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n-\t\t\t\tpointerProperties[i] = new MotionEvent.PointerProperties();\n-\t\t\t\tpointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n-\t\t\t\tpointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n-\n-\t\t\t\tpointerCoords[i] = new MotionEvent.PointerCoords();\n-\t\t\t\tpointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n-\t\t\t\tpointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n-\t\t\t\tpointerCoords[i].orientation = 0;\n-\t\t\t\tpointerCoords[i].pressure = 1.0f;\n-\t\t\t\tpointerCoords[i].size = 1;\n-\t\t\t}\n-\n-\t\t\tmotionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n-\t\t\t\t\tsdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n-\t\t\t\t\t1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n-\t\t\tmotionEventList.add(motionEvent);\n-\n-\t\t\tif(motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL){\n-\t\t\t\t//If the motion event should be finished we should clear our reference\n-\t\t\t\tsdlMotionEvent.pointers.clear();\n-\t\t\t\tsdlMotionEvent = null;\n-\t\t\t\tbreak;\n-\t\t\t} else if((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP){\n-\t\t\t\tsdlMotionEvent.removePointerById(touchEvent.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn motionEventList;\n-\t}\n-\n-\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n-\t\treturn parameters;\n-\t}\n-\n-\tpublic boolean getLastCachedIsEncrypted() {\n-\t\treturn isEncrypted;\n-\t}\n-\n-\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n-\t\t\tResolution minResolution,\n-\t\t\tResolution maxResolution,\n-\t\t\tDouble constraintDiagonalMax,\n-\t\t\tAspectRatio ratioRange,\n-\t\t\tList<VideoStreamingCapability> originalAdditionalCapabilities\n-\t){\n-\t\tInteger constraintHeightMax = maxResolution.getResolutionHeight();\n-\t\tInteger constraintHeightMin = minResolution.getResolutionHeight();\n-\t\tInteger constraintWidthMax = maxResolution.getResolutionWidth();\n-\t\tInteger constraintWidthMin = minResolution.getResolutionWidth();\n-\t\tDouble aspectRationMin = ratioRange.getMinAspectRatio();\n-\t\tDouble aspectRationMax = ratioRange.getMaxAspectRatio();\n-\n-\t\tList<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n-\n-\t\tVideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n-\t\tpreferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n-\t\tpreferredCapability.setPreferredResolution(new ImageResolution(\n-\t\t\t\tparameters.getResolution().getResolutionWidth(),\n-\t\t\t\tparameters.getResolution().getResolutionHeight())\n-\t\t);\n-\n-\t\t// get the first one - the Desired resolution to guarantee streaming will start\n-\t\tvalidCapabilities.add(preferredCapability);\n-\n-\t\tfor (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n-\t\t\tdouble diagonal;\n-\t\t\tint resolutionHeight;\n-\t\t\tint resolutionWidth;\n-\t\t\t// TODO refactor\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionHeight() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionHeight = capability.getPreferredResolution().getResolutionHeight();\n-\t\t\t}\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionWidth() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionWidth = capability.getPreferredResolution().getResolutionWidth();\n-\t\t\t}\n-\t\t\tif (capability.getDiagonalScreenSize() == null ) {\n-\t\t\t\tdiagonal = parameters.getPreferredDiagonal();\n-\t\t\t} else {\n-\t\t\t\tdiagonal = capability.getDiagonalScreenSize();\n-\t\t\t}\n-\n-\t\t\tif (constraintDiagonalMax < diagonal) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!isAspectRatioInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tif (constraintHeightMax == null && constraintHeightMin == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!isImageResolutionInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tvalidCapabilities.add(capability);\n-\t\t}\n-\n-\t\treturn validCapabilities;\n-\t}\n-\n-\tpublic Boolean isImageResolutionInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\n-\t\tInteger constraintHeightMax = range.getMaxSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintHeightMin = range.getMinSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintWidthMax = range.getMaxSupportedResolution().getResolutionWidth();\n-\t\tInteger constraintWidthMin = range.getMinSupportedResolution().getResolutionWidth();\n-\t\tInteger resolutionHeight = currentResolution.getResolutionHeight();\n-\t\tInteger resolutionWidth = currentResolution.getResolutionWidth();\n-\t\tif (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null)\n-\t\t{\n-\t\t\tif (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tif (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// TODO check what if dev provided invalid constraints\n-\t\treturn true;\n-\t}\n-\n-\tpublic Boolean isAspectRatioInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\t\tDouble aspectRatioMin = range.getAspectRatio().getMinAspectRatio();\n-\t\tDouble aspectRatioMax = range.getAspectRatio().getMaxAspectRatio();\n-\n-\t\tDouble currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n-\n-\t\tif (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n-\t\t\tif ((currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\t// TODO check what if dev provided invalid constraints\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * Keeps track of the current motion event for VPM\n-\t */\n-\tprivate static class SdlMotionEvent {\n-\t\tclass Pointer {\n-\t\t\tint id;\n-\t\t\tfloat x;\n-\t\t\tfloat y;\n-\t\t\tPointer (int id) {\n-\t\t\t\tthis.id = id;\n-\t\t\t\tthis.x = 0.0f;\n-\t\t\t\tthis.y = 0.0f;\n-\t\t\t}\n-\t\t\tvoid setCoords(float x, float y) {\n-\t\t\t\tthis.x = x;\n-\t\t\t\tthis.y = y;\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n-\t\tprivate long downTime;\n-\t\tprivate long downTimeOnHMI;\n-\t\tprivate long eventTime;\n-\n-\t\tSdlMotionEvent(){\n-\t\t\tdownTimeOnHMI = 0;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n-\t\t * Android MotionEvent according to this events status\n-\t\t * @param touchType The SDL TouchType that was received from the module\n-\t\t * @param touchEvent The SDL TouchEvent that was received from the module\n-\t\t * @return the correct native Android MotionEvent action to dispatch\n-\t\t */\n-\t\tsynchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent){\n-\t\t\teventTime = 0;\n-\t\t\tint motionEventAction = -1;\n-\t\t\tswitch (touchType){\n-\t\t\t\tcase BEGIN:\n-\t\t\t\t\tif(pointers.size() == 0){\n-\t\t\t\t\t\t//The motion event has just begun\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_DOWN;\n-\t\t\t\t\t\tdownTime = SystemClock.uptimeMillis();\n-\t\t\t\t\t\tdownTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n-\t\t\t\t\t\teventTime = downTime;\n-\t\t\t\t\t} else{\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\t}\n-\t\t\t\t\tpointers.add(new Pointer(touchEvent.getId()));\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase MOVE:\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_MOVE;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase END:\n-\t\t\t\t\tif(pointers.size() <= 1){\n-\t\t\t\t\t\t//The motion event has just ended\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tint pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n-\t\t\t\t\t\tif (pointerIndex != -1) {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase CANCEL:\n-\t\t\t\t\t//Assuming this cancels the entire event\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_CANCEL;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\treturn motionEventAction;\n-\t\t}\n-\n-\t\tPointer getPointerById(int id){\n-\t\t\tif (pointers != null && !pointers.isEmpty()){\n-\t\t\t\tfor (Pointer pointer : pointers){\n-\t\t\t\t\tif (pointer.id == id){\n-\t\t\t\t\t\treturn pointer;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tPointer getPointerByIndex(int index){\n-\t\t\treturn pointers.get(index);\n-\t\t}\n-\n-\t\tvoid removePointerById(int id){\n-\t\t\tpointers.remove(getPointerById(id));\n-\t\t}\n-\t}\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n+        Double aspectRatioMin = aspectRatio.getMinAspectRatio();\n+        Double aspectRatioMax = aspectRatio.getMaxAspectRatio();\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n+            if (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Keeps track of the current motion event for VPM\n+     */\n+    private static class SdlMotionEvent {\n+        class Pointer {\n+            final int id;\n+            float x;\n+            float y;\n+\n+            Pointer(int id) {\n+                this.id = id;\n+                this.x = 0.0f;\n+                this.y = 0.0f;\n+            }\n+\n+            void setCoords(float x, float y) {\n+                this.x = x;\n+                this.y = y;\n+            }\n+        }\n+\n+        private final CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n+        private long downTime;\n+        private long downTimeOnHMI;\n+        private long eventTime;\n+\n+        SdlMotionEvent() {\n+            downTimeOnHMI = 0;\n+        }\n+\n+        /**\n+         * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n+         * Android MotionEvent according to this events status\n+         *\n+         * @param touchType  The SDL TouchType that was received from the module\n+         * @param touchEvent The SDL TouchEvent that was received from the module\n+         * @return the correct native Android MotionEvent action to dispatch\n+         */\n+        synchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent) {\n+            eventTime = 0;\n+            int motionEventAction = -1;\n+            switch (touchType) {\n+                case BEGIN:\n+                    if (pointers.size() == 0) {\n+                        //The motion event has just begun\n+                        motionEventAction = MotionEvent.ACTION_DOWN;\n+                        downTime = SystemClock.uptimeMillis();\n+                        downTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n+                        eventTime = downTime;\n+                    } else {\n+                        motionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    }\n+                    pointers.add(new Pointer(touchEvent.getId()));\n+                    break;\n+                case MOVE:\n+                    motionEventAction = MotionEvent.ACTION_MOVE;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case END:\n+                    if (pointers.size() <= 1) {\n+                        //The motion event has just ended\n+                        motionEventAction = MotionEvent.ACTION_UP;\n+                    } else {\n+                        int pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n+                        if (pointerIndex != -1) {\n+                            motionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        } else {\n+                            motionEventAction = MotionEvent.ACTION_UP;\n+                        }\n+                    }\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case CANCEL:\n+                    //Assuming this cancels the entire event\n+                    motionEventAction = MotionEvent.ACTION_CANCEL;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return motionEventAction;\n+        }\n+\n+        Pointer getPointerById(int id) {\n+            if (pointers != null && !pointers.isEmpty()) {\n+                for (Pointer pointer : pointers) {\n+                    if (pointer.id == id) {\n+                        return pointer;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        Pointer getPointerByIndex(int index) {\n+            return pointers.get(index);\n+        }\n+\n+        void removePointerById(int id) {\n+            pointers.remove(getPointerById(id));\n+        }\n+    }\n+\n+    private VideoStreamingProtocol getAcceptedProtocol(VideoStreamingParameters params) {\n+        if (params != null) {\n+            VideoStreamingFormat format = params.getFormat();\n+            if (format != null && format.getProtocol() != null) {\n+                return format.getProtocol();\n+            }\n+        }\n+        //Returns default protocol if none are found\n+        return new VideoStreamingParameters().getFormat().getProtocol();\n+\n+    }\n+\n+    protected IVideoStreamListener startVideoStream(VideoStreamingParameters params, final SdlSession session) {\n+        VideoStreamingProtocol protocol = getAcceptedProtocol(params);\n+\n+        IStreamListener iStreamListener = new IStreamListener() {\n+            @Override\n+            public void sendStreamPacket(ProtocolMessage pm) {\n+                session.sendMessage(pm);\n+            }\n+        };\n+\n+        try {\n+            switch (protocol) {\n+                case RAW: {\n+                    videoPacketizer = new StreamPacketizer(iStreamListener, null, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                case RTP: {\n+                    //FIXME why is this not an extension of StreamPacketizer?\n+                    videoPacketizer = new RTPH264Packetizer(iStreamListener, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                default:\n+                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\n+                    return null;\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    protected boolean stopVideoStream() {\n+        if (videoPacketizer != null) {\n+            videoPacketizer.stop();\n+            return true;\n+        }\n+        return false;\n+    }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MDk0Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472740943", "bodyText": "Can you delete lines 455 and 456 and instead just do createRemoteDisplay(virtualDisplayEncoder.getDisplay());?", "author": "santhanamk", "createdAt": "2020-08-19T06:08:07Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -323,11 +444,17 @@ protected void startStreaming(VideoStreamingParameters parameters, boolean encry\n \t */\n \tprivate void startEncoder(){\n \t\ttry {\n+\t\t\tif (sdlRemoteDisplay != null) {\n+\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+\t\t\t}\n+\n \t\t\tvirtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n \t\t\t//We are all set so we can start streaming at at this point\n \t\t\tvirtualDisplayEncoder.start();\n \t\t\t//Encoder should be up and running\n-\t\t\tcreateRemoteDisplay(virtualDisplayEncoder.getVirtualDisplay());\n+\t\t\tDisplay display = virtualDisplayEncoder.getDisplay();", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzMzgyNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473333824", "bodyText": "Can you delete lines 455 and 456 and instead just do createRemoteDisplay(virtualDisplayEncoder.getDisplay());?\n\n@kostyaBoss I still see this issue.  Are you able to make this change?", "author": "santhanamk", "createdAt": "2020-08-19T21:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MDk0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 5461d9d4d..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -65,898 +65,968 @@ import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.TouchCoord;\n import com.smartdevicelink.proxy.rpc.TouchEvent;\n import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.TouchType;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n import com.smartdevicelink.proxy.rpc.enums.VideoStreamingState;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.session.SdlSession;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.IVideoStreamListener;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n import com.smartdevicelink.transport.utl.TransportRecord;\n import com.smartdevicelink.util.DebugTool;\n import com.smartdevicelink.util.Version;\n \n+import java.io.IOException;\n import java.lang.ref.WeakReference;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.FutureTask;\n \n @TargetApi(19)\n public class VideoStreamManager extends BaseVideoStreamManager {\n-\tprivate static String TAG = \"VideoStreamManager\";\n-\n-\tprivate WeakReference<Context> context;\n-\tprivate volatile VirtualDisplayEncoder virtualDisplayEncoder;\n-\tprivate Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n-\tprivate SdlRemoteDisplay sdlRemoteDisplay;\n-\tprivate float[] touchScalar = {1.0f,1.0f}; //x, y\n-\tprivate HapticInterfaceManager hapticManager;\n-\tprivate SdlMotionEvent sdlMotionEvent = null;\n-\tprivate OnHMIStatus currentOnHMIStatus;\n-\tprivate StreamingStateMachine stateMachine;\n-\tprivate VideoStreamingParameters parameters;\n-\tprivate VideoStreamingCapability originalCapability;\n-\tprivate IVideoStreamListener streamListener;\n-\tprivate boolean isTransportAvailable = false;\n-\tprivate Integer majorProtocolVersion;\n-\tprivate VideoStreamingRange streamingRange;\n-\tprivate boolean hasStarted;\n-\tprivate String vehicleMake = null;\n-\tprivate boolean isEncrypted = false;\n-\tprivate boolean withPendingRestart = false;\n-\n-\t// INTERNAL INTERFACES\n-\n-\tprivate final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif (session != null && session.getAcceptedVideoParams() != null) {\n-\t\t\t\t\tparameters = session.getAcceptedVideoParams();\n-\t\t\t\t\tVideoStreamManager.this.streamListener = session.startVideoStream();\n-\t\t\t\t}\n-\n-\t\t\t\tif (VideoStreamManager.this.streamListener == null) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error starting video stream\");\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\tif(capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())){\n-\t\t\t\t\thapticManager = new HapticInterfaceManager(internalInterface);\n-\t\t\t\t}\n-\t\t\t\tcheckState();\n-\t\t\t\tstartEncoder();\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\t\thasStarted = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SdlSession session, SessionType type) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif(sdlRemoteDisplay !=null){\n-\t\t\t\t    // TODO set withPendingRestart to default in proper place\n-\t\t\t\t\tstopStreaming(withPendingRestart);\n-\t\t\t\t}\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\t\t\ttransitionToState(SETTING_UP);\n-\n-\t\t\t\tif (withPendingRestart){\n-\t\t\t\t\tVideoStreamManager manager = VideoStreamManager.this;\n-\t\t\t\t\tmanager.internalInterface.startVideoService(\n-\t\t\t\t\t\t\tmanager.getLastCachedStreamingParameters(),\n-\t\t\t\t\t\t\tmanager.isEncrypted\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceError(SdlSession session, SessionType type, String reason) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null){\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tOnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n-\t\t\t\tcurrentOnHMIStatus = onHMIStatus;\n-\n-\t\t\t\tif (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n-\t\t\t\t\tinternalInterface.stopVideoService();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null && sdlRemoteDisplay != null){\n-\t\t\t\tList<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent)notification);\n-\t\t\t\tif (motionEventList != null && !motionEventList.isEmpty()) {\n-\t\t\t\t\tfor (MotionEvent motionEvent : motionEventList) {\n-\t\t\t\t\t\tsdlRemoteDisplay.handleMotionEvent(motionEvent);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t@Override\n-\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\n-\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\n-\t\t\t// means only scale received\n-\t\t\tif (castedCapability.getPreferredResolution() == null &&\n-\t\t\t\t\tcastedCapability.getScale() != null &&\n-\t\t\t\t\tcastedCapability.getScale() != 0 &&\n-\t\t\t\t\tVideoStreamManager.this.parameters != null\n-\t\t\t\t\t&& VideoStreamManager.this.parameters.getResolution() != null) {\n-\t\t\t\t// set cached resolution\n-\t\t\t\tcastedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n-\t\t\t}\n-\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\tVideoStreamManager.this.withPendingRestart = true;\n-\n-\t\t\tvirtualDisplayEncoder.setStreamingParams(params);\n-\t\t\tstopStreaming(true);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onError(String info) {\n-\t\t\tLog.d(\"MyTagLogInfo\", info);\n-\t\t}\n-\t};\n-\n-\t// MANAGER APIs\n-\tpublic VideoStreamManager(ISdl internalInterface){\n-\t\tsuper(internalInterface);\n-\n-\t\tif(internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n-\t\t\t\tinternalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n-\t\t\tvehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n-\t\t}\n-\t\tvirtualDisplayEncoder = new VirtualDisplayEncoder();\n-\n-\t\t// Listen for video service events\n-\t\tinternalInterface.addServiceListener(SessionType.NAV, serviceListener);\n-\t\t// Take care of the touch events\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t// Listen for HMILevel changes\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t// Listen for SystemCapabilityType VIDEO_STREAMING\n-\t\tinternalInterface.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n-\t\tstateMachine = new StreamingStateMachine();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\tisTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n-\t\tcheckState();\n-\t\tsuper.start(listener);\n-\t}\n-\n-\tprivate synchronized void checkState(){\n-\t\tif(this.getState() == SETTING_UP\n-\t\t\t\t&& isTransportAvailable\n-\t\t\t\t&& isHMIStateVideoStreamCapable(currentOnHMIStatus)\n-\t\t\t\t&& parameters != null){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.READY);\n-\t\t\ttransitionToState(READY);\n-\t\t}\n-\t}\n-\n-\tboolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n-\t\tHMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n-\t\tVideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n-\t\treturn (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n-\t}\n-\n-\tprivate void getVideoStreamingParams(){\n-\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5) {\n-\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\tcheckState();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\ttransitionToState(ERROR);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\t//We just use default video streaming params\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\tif(dispCap !=null){\n-\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t}\n-\n-\t\t\tthis.parameters = params;\n-\t\t\tcheckState();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param streamingRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tthis.streamingRange = streamingRange;\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n-\t\tif(parameters == null){\n-\t\t\tif(majorProtocolVersion >= 5) {\n-\t\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\n-\t\t\t\t\t\t// Mocks data here\n-\t\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\t\t\t\tif (streamingRange != null) {\n-\t\t\t\t\t\t\t// filtering\n-\t\t\t\t\t\t\tcastedCapability.setAdditionalVideoStreamingCapabilities(\n-\t\t\t\t\t\t\t\t\tgetSupportedCapabilities(\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxScreenDiagonal(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getAspectRatio(),\n-\t\t\t\t\t\t\t\t\t\t\tcastedCapability.getAdditionalVideoStreamingCapabilities()\n-\t\t\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// TODO handle??\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tOnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n-\t\t\t\t\t\tinternalInterface.sendRPC(onAppCapabilityUpdated);\n-\t\t\t\t\t\tstartStreaming(params, isEncrypted);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}else{\n-\t\t\t\t//We just use default video streaming params\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\tif(dispCap !=null){\n-\t\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t}\n-\t\t\t\tstartStreaming(params, encrypted);\n-\t\t\t}\n-\t\t}else{\n-\t\t\tstartStreaming(parameters, encrypted);\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n-\t * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n-\t *                    VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n-\t * @param encrypted Specify true if packets on this service have to be encrypted\n-\t */\n-\tprotected void startStreaming(VideoStreamingParameters parameters, boolean encrypted){\n-\t\tthis.parameters = parameters;\n-\t\tif (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n-\t\t\tDebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n-\t\t\treturn;\n-\t\t}\n-\t\t//Start the video service\n-\t\tthis.internalInterface.startVideoService(parameters, encrypted);\n-\t}\n-\n-\t/**\n-\t * Initializes and starts the virtual display encoder and creates the remote display\n-\t */\n-\tprivate void startEncoder(){\n-\t\ttry {\n-\t\t\tif (sdlRemoteDisplay != null) {\n-\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t}\n-\n-\t\t\tvirtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n-\t\t\t//We are all set so we can start streaming at at this point\n-\t\t\tvirtualDisplayEncoder.start();\n-\t\t\t//Encoder should be up and running\n-\t\t\tDisplay display = virtualDisplayEncoder.getDisplay();\n-\t\t\tcreateRemoteDisplay(display);\n-\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\thasStarted = true;\n-\t\t} catch (Exception e) {\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming from the remote display. To restart, call\n-\t * @see #resumeStreaming()\n-\t */\n-\tpublic void stopStreaming(boolean withPendingRestart){\n-\t\tif(sdlRemoteDisplay!=null && !withPendingRestart){\n-\t\t\tsdlRemoteDisplay.stop();\n-\t\t\tthis.withPendingRestart = false;\n-\t\t}\n-\t\tif (this.isStreaming()) {\n-\t\t\tif(virtualDisplayEncoder!=null){\n-\t\t\t\tvirtualDisplayEncoder.shutDown(withPendingRestart);\n-\t\t\t}\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.PAUSED);\n-\n-\t\t\tthis.internalInterface.stopVideoService();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Resumes streaming after calling\n-\t * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n-\t * followed by a call to\n-\t * @see #stopStreaming(boolean withPendingRestart)\n-\t */\n-\tpublic void resumeStreaming(){\n-\t\tint currentState = stateMachine.getState();\n-\t\tif (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n-\t\t\tstartEncoder();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming, ends video streaming service and removes service listeners.\n-\t */\n-\t@Override\n-\tpublic void dispose(){\n-\t\tstopStreaming(false);\n-\n-\t\thapticManager = null;\n-\t\tsdlRemoteDisplay = null;\n-\t\tparameters = null;\n-\t\tvirtualDisplayEncoder = null;\n-\t\tif (internalInterface != null) {\n-\t\t\tinternalInterface.stopVideoService();\n-\t\t\t// Remove listeners\n-\t\t\tinternalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t}\n-\n-\n-\n-\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\tsuper.dispose();\n-\t}\n-\n-\t// PUBLIC METHODS FOR CHECKING STATE\n-\n-\t/**\n-\t * Check if a video service is currently active\n-\t * @return boolean (true = active, false = inactive)\n-\t */\n-\tpublic boolean isServiceActive(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.READY) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STARTED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.PAUSED);\n-\t}\n-\n-\t/**\n-\t * Check if video is currently streaming and visible\n-\t * @return boolean (true = yes, false = no)\n-\t */\n-\tpublic boolean isStreaming(){\n-\t\tboolean state = (stateMachine.getState() == StreamingStateMachine.STARTED);\n-\t\tboolean capable = isHMIStateVideoStreamCapable(currentOnHMIStatus);\n-\t\treturn state && capable;\n-\t}\n-\n-\t/**\n-\t * Check if video streaming has been paused due to app moving to background or manually stopped\n-\t * @return boolean (true = not paused, false = paused)\n-\t */\n-\tpublic boolean isPaused(){\n-\t\treturn (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n-\t}\n-\n-\t/**\n-\t * Gets the current video streaming state as defined in @StreamingStateMachine\n-\t * @return int representing StreamingStateMachine.StreamingState\n-\t */\n-\tpublic @StreamingStateMachine.StreamingState int currentVideoStreamState(){\n-\t\treturn stateMachine.getState();\n-\t}\n-\n-\t// HELPER METHODS\n-\n-\tprivate void createRemoteDisplay(final Display disp){\n-\t\ttry{\n-\t\t\tif (disp == null){\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Dismiss the current presentation if the display has changed.\n-\t\t\tif (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n-\t\t\t\tsdlRemoteDisplay.dismissPresentation();\n-\t\t\t}\n-\n-\t\t\tFutureTask<Boolean> fTask =  new FutureTask<Boolean>( new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback(){\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCreated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Remote display has been created.\n-\t\t\t\t\t//Now is a good time to do parsing for spatial data\n-\t\t\t\t\tVideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\t//Get touch scalars\n-\t\t\t\t\tImageResolution resolution = null;\n-\t\t\t\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5){ //At this point we should already have the capability\n-\t\t\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\t\t\tif(capability != null){\n-\t\t\t\t\t\t\tresolution = capability.getPreferredResolution();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution == null){ //Either the protocol version is too low to access video streaming caps, or they were null\n-\t\t\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities) internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\t\t\tif (dispCap != null) {\n-\t\t\t\t\t\t\tresolution = (dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution != null){\n-\t\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\t\tdisp.getMetrics(displayMetrics);\n-\t\t\t\t\t\tcreateTouchScalar(resolution, displayMetrics);\n+    private static final String TAG = \"VideoStreamManager\";\n+\n+    private WeakReference<Context> context;\n+    private volatile VirtualDisplayEncoder virtualDisplayEncoder;\n+    private Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n+    private SdlRemoteDisplay sdlRemoteDisplay;\n+    private final float[] touchScalar = {1.0f, 1.0f}; //x, y\n+    private HapticInterfaceManager hapticManager;\n+    private SdlMotionEvent sdlMotionEvent = null;\n+    private OnHMIStatus currentOnHMIStatus;\n+    private final StreamingStateMachine stateMachine;\n+    private VideoStreamingParameters parameters;\n+    private VideoStreamingCapability originalCapability;\n+    private IVideoStreamListener streamListener;\n+    private boolean isTransportAvailable = false;\n+    private Integer majorProtocolVersion;\n+    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private boolean hasStarted;\n+    private String vehicleMake = null;\n+    private boolean isEncrypted = false;\n+    private boolean withPendingRestart = false;\n+    private AbstractPacketizer videoPacketizer;\n+\n+    // INTERNAL INTERFACES\n+\n+    private final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n+        @Override\n+        public void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n+            if (SessionType.NAV.equals(type)) {\n+                if (session != null && session.getAcceptedVideoParams() != null) {\n+                    parameters = session.getAcceptedVideoParams();\n+                    VideoStreamManager.this.streamListener = startVideoStream(session.getAcceptedVideoParams(), session);\n+                }\n+\n+                if (VideoStreamManager.this.streamListener == null) {\n+                    DebugTool.logError(TAG, \"Error starting video stream\");\n+                    stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                    return;\n+                }\n+                VideoStreamingCapability capability = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                }\n+                if (capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())) {\n+                    hapticManager = new HapticInterfaceManager(internalInterface);\n+                }\n+                checkState();\n+                startEncoder();\n+                stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+                hasStarted = true;\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceEnded(SdlSession session, SessionType type) {\n+            if (SessionType.NAV.equals(type)) {\n+                //stopVideoStream();\n+                if (sdlRemoteDisplay !=null){\n+                    stopStreaming(withPendingRestart);\n+                }\n+                stateMachine.transitionToState(StreamingStateMachine.NONE);\n+                transitionToState(SETTING_UP);\n+\n+                if (withPendingRestart){\n+                    VideoStreamManager manager = VideoStreamManager.this;\n+                    manager.internalInterface.startVideoService(\n+                            manager.getLastCachedStreamingParameters(),\n+                            manager.isEncrypted,\n+                            withPendingRestart\n+                    );\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceError(SdlSession session, SessionType type, String reason) {\n+            DebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n+            stopVideoStream();\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            transitionToState(BaseSubManager.ERROR);\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                OnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n+                currentOnHMIStatus = onHMIStatus;\n+                if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+                    getVideoStreamingParams();\n+                }\n+                checkState();\n+                if (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n+                    stopVideoStream();\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null && sdlRemoteDisplay != null) {\n+                List<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent) notification);\n+                if (motionEventList != null && !motionEventList.isEmpty()) {\n+                    for (MotionEvent motionEvent : motionEventList) {\n+                        sdlRemoteDisplay.handleMotionEvent(motionEvent);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+\n+            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+            // means only scale received\n+            if (castedCapability.getPreferredResolution() == null &&\n+                    castedCapability.getScale() != null &&\n+                    castedCapability.getScale() != 0 &&\n+                    VideoStreamManager.this.parameters != null\n+                    && VideoStreamManager.this.parameters.getResolution() != null) {\n+                // set cached resolution\n+                castedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+            }\n+            params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+            VideoStreamManager.this.parameters = params;\n+\n+            VideoStreamManager.this.withPendingRestart = true;\n+\n+            virtualDisplayEncoder.setStreamingParams(params);\n+            stopStreaming(true);\n+        }\n+\n+        @Override\n+        public void onError(String info) { }\n+    };\n+\n+    // MANAGER APIs\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public VideoStreamManager(ISdl internalInterface) {\n+        super(internalInterface);\n+\n+        if (internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n+                internalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n+            vehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n+        }\n+        virtualDisplayEncoder = new VirtualDisplayEncoder();\n+\n+        // Listen for video service events\n+        internalInterface.addServiceListener(SessionType.NAV, serviceListener);\n+        // Take care of the touch events\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+        // Listen for HMILevel changes\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        // Listen for SystemCapabilityType VIDEO_STREAMING\n+        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n+        stateMachine = new StreamingStateMachine();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        isTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n+        checkState();\n+        super.start(listener);\n+    }\n+\n+    private synchronized void checkState() {\n+        if (this.getState() == SETTING_UP\n+                && isTransportAvailable\n+                && isHMIStateVideoStreamCapable(currentOnHMIStatus)\n+                && parameters != null) {\n+            stateMachine.transitionToState(StreamingStateMachine.READY);\n+            transitionToState(READY);\n+        }\n+    }\n+\n+    boolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n+        HMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n+        VideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n+        return (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n+    }\n+\n+    private void getVideoStreamingParams() {\n+        if (internalInterface.getProtocolVersion().getMajor() >= 5) {\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                    @Override\n+                    public void onCapabilityRetrieved(Object capability) {\n+                        VideoStreamingParameters params = new VideoStreamingParameters();\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+                        params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+                        // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                        checkState();\n+                        }\n+\n+                    @Override\n+                    public void onError(String info) {\n+                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                        transitionToState(ERROR);\n+                    }\n+                }, false);\n+            }\n+        } else {\n+            //We just use default video streaming params\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+            DisplayCapabilities dispCap = null;\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+            }\n+            if (dispCap != null) {\n+                params.setResolution(dispCap.getScreenParams().getImageResolution());\n+            }\n+\n+            this.parameters = params;\n+            checkState();\n+        }\n+    }\n+\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {\n+            if (majorProtocolVersion >= 5) {\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                        @Override\n+                        public void onCapabilityRetrieved(Object capability) {\n+                            VideoStreamingParameters params = new VideoStreamingParameters();\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                            VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                            // Mocks data here\n+                            // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                            params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+                            if (listOfStreamingRanges != null) {\n+                                // filtering\n+                                castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                                );\n+                            } else { }\n+                            OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n+                            internalInterface.sendRPC(onAppCapabilityUpdated);\n+                            startStreaming(params, isEncrypted);\n+                        }\n+\n+                        @Override\n+                        public void onError(String info) {\n+                            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                            DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        }\n+                    }, false);\n+                }\n+            } else {\n+                //We just use default video streaming params\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                DisplayCapabilities dispCap = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                }\n+                if (dispCap != null) {\n+                    params.setResolution(dispCap.getScreenParams().getImageResolution());\n+                }\n+                startStreaming(params, encrypted);\n+            }\n+        } else {\n+            startStreaming(parameters, encrypted);\n+        }\n+    }\n+\n+\n+    /**\n+     * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n+     *\n+     * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n+     *                   VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n+     * @param encrypted  Specify true if packets on this service have to be encrypted\n+     */\n+    protected void startStreaming(VideoStreamingParameters parameters, boolean encrypted) {\n+        this.parameters = parameters;\n+        if (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n+            DebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n+            return;\n+        }\n+        //Start the video service\n+        this.internalInterface.startVideoService(parameters, encrypted, false);\n+    }\n+\n+    /**\n+     * Initializes and starts the virtual display encoder and creates the remote display\n+     */\n+    private void startEncoder() {\n+        try {\n+            if (sdlRemoteDisplay != null) {\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+            }\n+\n+            virtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n+            //We are all set so we can start streaming at at this point\n+            virtualDisplayEncoder.start();\n+            //Encoder should be up and running\n+            createRemoteDisplay(virtualDisplayEncoder.getDisplay());\n+\n+            stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+            hasStarted = true;\n+        } catch (Exception e) {\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    public void stopStreaming(boolean withPendingRestart) {\n+        if (sdlRemoteDisplay!= null && !withPendingRestart) {\n+            sdlRemoteDisplay.stop();\n+                this.withPendingRestart = false;\n+        }\n+        if (this.isStreaming()) {\n+            if (virtualDisplayEncoder!=null){\n+                virtualDisplayEncoder.shutDown(withPendingRestart);\n+            }\n+            stateMachine.transitionToState(StreamingStateMachine.PAUSED);\n+            stopVideoStream();\n+        }\n+    }\n+\n+    /**\n+     * Resumes streaming after calling\n+     *\n+     * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n+     * followed by a call to\n+     * @see #stopStreaming(boolean withPendingRestart)\n+     */\n+    public void resumeStreaming() {\n+        int currentState = stateMachine.getState();\n+        if (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n+            startEncoder();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming, ends video streaming service and removes service listeners.\n+     */\n+    @Override\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void dispose() {\n+        stopStreaming(false);\n+\n+        hapticManager = null;\n+        sdlRemoteDisplay = null;\n+        parameters = null;\n+        virtualDisplayEncoder = null;\n+        if (internalInterface != null) {\n+            // Remove listeners\n+            internalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        }\n+\n+        stopVideoStream();\n+\n+\n+        stateMachine.transitionToState(StreamingStateMachine.NONE);\n+        super.dispose();\n+    }\n+\n+    // PUBLIC METHODS FOR CHECKING STATE\n+\n+    /**\n+     * Check if a video service is currently active\n+     *\n+     * @return boolean (true = active, false = inactive)\n+     */\n+    public boolean isServiceActive() {\n+        return (stateMachine.getState() == StreamingStateMachine.READY) ||\n+                (stateMachine.getState() == StreamingStateMachine.STARTED) ||\n+                (stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n+                (stateMachine.getState() == StreamingStateMachine.PAUSED);\n+        }\n+\n+    /**\n+     * Check if video is currently streaming and visible\n+     *\n+     * @return boolean (true = yes, false = no)\n+     */\n+    public boolean isStreaming() {\n+        return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Check if video streaming has been paused due to app moving to background or manually stopped\n+     *\n+     * @return boolean (true = not paused, false = paused)\n+     */\n+    public boolean isPaused() {\n+        return (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Gets the current video streaming state as defined in @StreamingStateMachine\n+     *\n+     * @return int representing StreamingStateMachine.StreamingState\n+     */\n+    public @StreamingStateMachine.StreamingState\n+    int currentVideoStreamState() {\n+        return stateMachine.getState();\n+    }\n+\n+    // HELPER METHODS\n+\n+    private void createRemoteDisplay(final Display disp) {\n+        try {\n+            if (disp == null) {\n+                return;\n+            }\n+\n+            // Dismiss the current presentation if the display has changed.\n+            if (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n+                sdlRemoteDisplay.dismissPresentation();\n+            }\n+\n+            FutureTask<Boolean> fTask = new FutureTask<>(new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback() {\n+                @Override\n+                public void onCreated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Remote display has been created.\n+                    //Now is a good time to do parsing for spatial data\n+                    VideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                    //Get touch scalars\n+                    ImageResolution resolution = null;\n+                    if (internalInterface.getProtocolVersion().getMajor() >= 5) { //At this point we should already have the capability\n+                        VideoStreamingCapability capability = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                        }\n+                        if (capability != null) {\n+                            resolution = capability.getPreferredResolution();\n+                        }\n+                    }\n+\n+                    if (resolution == null) { //Either the protocol version is too low to access video streaming caps, or they were null\n+                        DisplayCapabilities dispCap = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                        }\n+                        if (dispCap != null) {\n+                            resolution = (dispCap.getScreenParams().getImageResolution());\n+                        }\n+                    }\n+\n+                    if (resolution != null) {\n+                        DisplayMetrics displayMetrics = new DisplayMetrics();\n+                        disp.getMetrics(displayMetrics);\n+                        createTouchScalar(resolution, displayMetrics);\n                     }\n \n-\t\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Our view has been invalidated\n-\t\t\t\t\t//A good time to refresh spatial data\n-\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\tsdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n-\t\t\t\t\tdisplayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n-\t\t\t\t\tdisplayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n-\t\t\t\t\tcreateTouchScalar(parameters.getResolution(), displayMetrics);\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ));\n-\t\t\tThread showPresentation = new Thread(fTask);\n-\t\t\tshowPresentation.setName(\"RmtDispThread\");\n-\n-\t\t\tshowPresentation.start();\n-\t\t} catch (Exception ex) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n-\t\t\tif(DebugTool.isDebugEnabled()){\n-\t\t\t\tex.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail){\n-\n-\t\tisTransportAvailable = videoStreamTransportAvail;\n-\n-\t\tif(internalInterface.getProtocolVersion().isNewerThan(new Version(5,1,0)) >= 0){\n-\t\t\tif(videoStreamTransportAvail){\n-\t\t\t\tcheckState();\n-\t\t\t}\n-\t\t}else{\n-\t\t\t//The protocol version doesn't support simultaneous transports.\n-\t\t\tif(!videoStreamTransportAvail){\n-\t\t\t\t//If video streaming isn't available on primary transport then it is not possible to\n-\t\t\t\t//use the video streaming manager until a complete register on a transport that\n-\t\t\t\t//supports video\n-\t\t\t\ttransitionToState(ERROR);\n-\t\t\t}\n-\t\t}\n-\t}\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+                }\n+\n+                @Override\n+                public void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Our view has been invalidated\n+                    //A good time to refresh spatial data\n+                    DisplayMetrics displayMetrics = new DisplayMetrics();\n+                    sdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n+                    displayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n+                    displayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n+                    createTouchScalar(parameters.getResolution(), displayMetrics);\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                }\n+            }));\n+            Thread showPresentation = new Thread(fTask);\n+            showPresentation.setName(\"RmtDispThread\");\n+\n+            showPresentation.start();\n+        } catch (Exception ex) {\n+            DebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n+            if (DebugTool.isDebugEnabled()) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail) {\n+\n+        isTransportAvailable = videoStreamTransportAvail;\n+\n+        if (internalInterface.getProtocolVersion().isNewerThan(new Version(5, 1, 0)) >= 0) {\n+            if (videoStreamTransportAvail) {\n+                checkState();\n+            }\n+        } else {\n+            //The protocol version doesn't support simultaneous transports.\n+            if (!videoStreamTransportAvail) {\n+                //If video streaming isn't available on primary transport then it is not possible to\n+                //use the video streaming manager until a complete register on a transport that\n+                //supports video\n+                transitionToState(ERROR);\n+            }\n+        }\n+    }\n \n     void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics) {\n-        touchScalar[0] = ((float)displayMetrics.widthPixels) / resolution.getResolutionWidth();\n-        touchScalar[1] = ((float)displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+        touchScalar[0] = ((float) displayMetrics.widthPixels) / resolution.getResolutionWidth();\n+        touchScalar[1] = ((float) displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+    }\n+\n+    List<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent) {\n+        List<MotionEvent> motionEventList = new ArrayList<>();\n+\n+        List<TouchEvent> touchEventList = onTouchEvent.getEvent();\n+        if (touchEventList == null || touchEventList.size() == 0) return null;\n+\n+        TouchType touchType = onTouchEvent.getType();\n+        if (touchType == null) {\n+            return null;\n+        }\n+\n+        if (sdlMotionEvent == null) {\n+            if (touchType == TouchType.BEGIN) {\n+                sdlMotionEvent = new SdlMotionEvent();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        SdlMotionEvent.Pointer pointer;\n+        MotionEvent motionEvent;\n+\n+        for (TouchEvent touchEvent : touchEventList) {\n+            if (touchEvent == null || touchEvent.getId() == null) {\n+                continue;\n+            }\n+\n+            List<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n+            if (touchCoordList == null || touchCoordList.size() == 0) {\n+                continue;\n+            }\n+\n+            TouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n+            if (touchCoord == null) {\n+                continue;\n+            }\n+\n+            int motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n+            long downTime = sdlMotionEvent.downTime;\n+            long eventTime = sdlMotionEvent.eventTime;\n+            pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n+            if (pointer != null) {\n+                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n+            }\n+\n+            MotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n+            MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n+\n+            for (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n+                pointerProperties[i] = new MotionEvent.PointerProperties();\n+                pointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n+                pointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n+\n+                pointerCoords[i] = new MotionEvent.PointerCoords();\n+                pointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n+                pointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n+                pointerCoords[i].orientation = 0;\n+                pointerCoords[i].pressure = 1.0f;\n+                pointerCoords[i].size = 1;\n+            }\n+\n+            motionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n+                    sdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n+                    1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n+            motionEventList.add(motionEvent);\n+\n+            if (motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL) {\n+                //If the motion event should be finished we should clear our reference\n+                sdlMotionEvent.pointers.clear();\n+                sdlMotionEvent = null;\n+                break;\n+            } else if ((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP) {\n+                sdlMotionEvent.removePointerById(touchEvent.getId());\n+            }\n+        }\n+\n+        return motionEventList;\n+    }\n+\n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n     }\n \n-\tList<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent){\n-\t\tList<MotionEvent> motionEventList = new ArrayList<MotionEvent>();\n-\n-\t\tList<TouchEvent> touchEventList = onTouchEvent.getEvent();\n-\t\tif (touchEventList == null || touchEventList.size() == 0) return null;\n-\n-\t\tTouchType touchType = onTouchEvent.getType();\n-\t\tif (touchType == null) { return null; }\n-\n-\t\tif(sdlMotionEvent == null) {\n-\t\t\tif (touchType == TouchType.BEGIN) {\n-\t\t\t\tsdlMotionEvent = new SdlMotionEvent();\n-\t\t\t} else{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tSdlMotionEvent.Pointer pointer;\n-\t\tMotionEvent motionEvent;\n-\n-\t\tfor (TouchEvent touchEvent : touchEventList) {\n-\t\t\tif (touchEvent == null || touchEvent.getId() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tList<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n-\t\t\tif (touchCoordList == null || touchCoordList.size() == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tTouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n-\t\t\tif (touchCoord == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tint motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n-\t\t\tlong downTime = sdlMotionEvent.downTime;\n-\t\t\tlong eventTime = sdlMotionEvent.eventTime;\n-\t\t\tpointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n-\t\t\tif (pointer != null) {\n-\t\t\t\tpointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n-\t\t\t}\n-\n-\t\t\tMotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n-\t\t\tMotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n-\n-\t\t\tfor (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n-\t\t\t\tpointerProperties[i] = new MotionEvent.PointerProperties();\n-\t\t\t\tpointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n-\t\t\t\tpointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n-\n-\t\t\t\tpointerCoords[i] = new MotionEvent.PointerCoords();\n-\t\t\t\tpointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n-\t\t\t\tpointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n-\t\t\t\tpointerCoords[i].orientation = 0;\n-\t\t\t\tpointerCoords[i].pressure = 1.0f;\n-\t\t\t\tpointerCoords[i].size = 1;\n-\t\t\t}\n-\n-\t\t\tmotionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n-\t\t\t\t\tsdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n-\t\t\t\t\t1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n-\t\t\tmotionEventList.add(motionEvent);\n-\n-\t\t\tif(motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL){\n-\t\t\t\t//If the motion event should be finished we should clear our reference\n-\t\t\t\tsdlMotionEvent.pointers.clear();\n-\t\t\t\tsdlMotionEvent = null;\n-\t\t\t\tbreak;\n-\t\t\t} else if((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP){\n-\t\t\t\tsdlMotionEvent.removePointerById(touchEvent.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn motionEventList;\n-\t}\n-\n-\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n-\t\treturn parameters;\n-\t}\n-\n-\tpublic boolean getLastCachedIsEncrypted() {\n-\t\treturn isEncrypted;\n-\t}\n-\n-\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n-\t\t\tResolution minResolution,\n-\t\t\tResolution maxResolution,\n-\t\t\tDouble constraintDiagonalMax,\n-\t\t\tAspectRatio ratioRange,\n-\t\t\tList<VideoStreamingCapability> originalAdditionalCapabilities\n-\t){\n-\t\tInteger constraintHeightMax = maxResolution.getResolutionHeight();\n-\t\tInteger constraintHeightMin = minResolution.getResolutionHeight();\n-\t\tInteger constraintWidthMax = maxResolution.getResolutionWidth();\n-\t\tInteger constraintWidthMin = minResolution.getResolutionWidth();\n-\t\tDouble aspectRationMin = ratioRange.getMinAspectRatio();\n-\t\tDouble aspectRationMax = ratioRange.getMaxAspectRatio();\n-\n-\t\tList<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n-\n-\t\tVideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n-\t\tpreferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n-\t\tpreferredCapability.setPreferredResolution(new ImageResolution(\n-\t\t\t\tparameters.getResolution().getResolutionWidth(),\n-\t\t\t\tparameters.getResolution().getResolutionHeight())\n-\t\t);\n-\n-\t\t// get the first one - the Desired resolution to guarantee streaming will start\n-\t\tvalidCapabilities.add(preferredCapability);\n-\n-\t\tfor (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n-\t\t\tdouble diagonal;\n-\t\t\tint resolutionHeight;\n-\t\t\tint resolutionWidth;\n-\t\t\t// TODO refactor\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionHeight() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionHeight = capability.getPreferredResolution().getResolutionHeight();\n-\t\t\t}\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionWidth() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionWidth = capability.getPreferredResolution().getResolutionWidth();\n-\t\t\t}\n-\t\t\tif (capability.getDiagonalScreenSize() == null ) {\n-\t\t\t\tdiagonal = parameters.getPreferredDiagonal();\n-\t\t\t} else {\n-\t\t\t\tdiagonal = capability.getDiagonalScreenSize();\n-\t\t\t}\n-\n-\t\t\tif (constraintDiagonalMax < diagonal) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!isAspectRatioInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tif (constraintHeightMax == null && constraintHeightMin == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!isImageResolutionInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tvalidCapabilities.add(capability);\n-\t\t}\n-\n-\t\treturn validCapabilities;\n-\t}\n-\n-\tpublic Boolean isImageResolutionInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\n-\t\tInteger constraintHeightMax = range.getMaxSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintHeightMin = range.getMinSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintWidthMax = range.getMaxSupportedResolution().getResolutionWidth();\n-\t\tInteger constraintWidthMin = range.getMinSupportedResolution().getResolutionWidth();\n-\t\tInteger resolutionHeight = currentResolution.getResolutionHeight();\n-\t\tInteger resolutionWidth = currentResolution.getResolutionWidth();\n-\t\tif (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null)\n-\t\t{\n-\t\t\tif (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tif (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// TODO check what if dev provided invalid constraints\n-\t\treturn true;\n-\t}\n-\n-\tpublic Boolean isAspectRatioInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\t\tDouble aspectRatioMin = range.getAspectRatio().getMinAspectRatio();\n-\t\tDouble aspectRatioMax = range.getAspectRatio().getMaxAspectRatio();\n-\n-\t\tDouble currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n-\n-\t\tif (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n-\t\t\tif ((currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\t// TODO check what if dev provided invalid constraints\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * Keeps track of the current motion event for VPM\n-\t */\n-\tprivate static class SdlMotionEvent {\n-\t\tclass Pointer {\n-\t\t\tint id;\n-\t\t\tfloat x;\n-\t\t\tfloat y;\n-\t\t\tPointer (int id) {\n-\t\t\t\tthis.id = id;\n-\t\t\t\tthis.x = 0.0f;\n-\t\t\t\tthis.y = 0.0f;\n-\t\t\t}\n-\t\t\tvoid setCoords(float x, float y) {\n-\t\t\t\tthis.x = x;\n-\t\t\t\tthis.y = y;\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n-\t\tprivate long downTime;\n-\t\tprivate long downTimeOnHMI;\n-\t\tprivate long eventTime;\n-\n-\t\tSdlMotionEvent(){\n-\t\t\tdownTimeOnHMI = 0;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n-\t\t * Android MotionEvent according to this events status\n-\t\t * @param touchType The SDL TouchType that was received from the module\n-\t\t * @param touchEvent The SDL TouchEvent that was received from the module\n-\t\t * @return the correct native Android MotionEvent action to dispatch\n-\t\t */\n-\t\tsynchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent){\n-\t\t\teventTime = 0;\n-\t\t\tint motionEventAction = -1;\n-\t\t\tswitch (touchType){\n-\t\t\t\tcase BEGIN:\n-\t\t\t\t\tif(pointers.size() == 0){\n-\t\t\t\t\t\t//The motion event has just begun\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_DOWN;\n-\t\t\t\t\t\tdownTime = SystemClock.uptimeMillis();\n-\t\t\t\t\t\tdownTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n-\t\t\t\t\t\teventTime = downTime;\n-\t\t\t\t\t} else{\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\t}\n-\t\t\t\t\tpointers.add(new Pointer(touchEvent.getId()));\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase MOVE:\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_MOVE;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase END:\n-\t\t\t\t\tif(pointers.size() <= 1){\n-\t\t\t\t\t\t//The motion event has just ended\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tint pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n-\t\t\t\t\t\tif (pointerIndex != -1) {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase CANCEL:\n-\t\t\t\t\t//Assuming this cancels the entire event\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_CANCEL;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\treturn motionEventAction;\n-\t\t}\n-\n-\t\tPointer getPointerById(int id){\n-\t\t\tif (pointers != null && !pointers.isEmpty()){\n-\t\t\t\tfor (Pointer pointer : pointers){\n-\t\t\t\t\tif (pointer.id == id){\n-\t\t\t\t\t\treturn pointer;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tPointer getPointerByIndex(int index){\n-\t\t\treturn pointers.get(index);\n-\t\t}\n-\n-\t\tvoid removePointerById(int id){\n-\t\t\tpointers.remove(getPointerById(id));\n-\t\t}\n-\t}\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n+        Double aspectRatioMin = aspectRatio.getMinAspectRatio();\n+        Double aspectRatioMax = aspectRatio.getMaxAspectRatio();\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n+            if (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Keeps track of the current motion event for VPM\n+     */\n+    private static class SdlMotionEvent {\n+        class Pointer {\n+            final int id;\n+            float x;\n+            float y;\n+\n+            Pointer(int id) {\n+                this.id = id;\n+                this.x = 0.0f;\n+                this.y = 0.0f;\n+            }\n+\n+            void setCoords(float x, float y) {\n+                this.x = x;\n+                this.y = y;\n+            }\n+        }\n+\n+        private final CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n+        private long downTime;\n+        private long downTimeOnHMI;\n+        private long eventTime;\n+\n+        SdlMotionEvent() {\n+            downTimeOnHMI = 0;\n+        }\n+\n+        /**\n+         * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n+         * Android MotionEvent according to this events status\n+         *\n+         * @param touchType  The SDL TouchType that was received from the module\n+         * @param touchEvent The SDL TouchEvent that was received from the module\n+         * @return the correct native Android MotionEvent action to dispatch\n+         */\n+        synchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent) {\n+            eventTime = 0;\n+            int motionEventAction = -1;\n+            switch (touchType) {\n+                case BEGIN:\n+                    if (pointers.size() == 0) {\n+                        //The motion event has just begun\n+                        motionEventAction = MotionEvent.ACTION_DOWN;\n+                        downTime = SystemClock.uptimeMillis();\n+                        downTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n+                        eventTime = downTime;\n+                    } else {\n+                        motionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    }\n+                    pointers.add(new Pointer(touchEvent.getId()));\n+                    break;\n+                case MOVE:\n+                    motionEventAction = MotionEvent.ACTION_MOVE;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case END:\n+                    if (pointers.size() <= 1) {\n+                        //The motion event has just ended\n+                        motionEventAction = MotionEvent.ACTION_UP;\n+                    } else {\n+                        int pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n+                        if (pointerIndex != -1) {\n+                            motionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        } else {\n+                            motionEventAction = MotionEvent.ACTION_UP;\n+                        }\n+                    }\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case CANCEL:\n+                    //Assuming this cancels the entire event\n+                    motionEventAction = MotionEvent.ACTION_CANCEL;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return motionEventAction;\n+        }\n+\n+        Pointer getPointerById(int id) {\n+            if (pointers != null && !pointers.isEmpty()) {\n+                for (Pointer pointer : pointers) {\n+                    if (pointer.id == id) {\n+                        return pointer;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        Pointer getPointerByIndex(int index) {\n+            return pointers.get(index);\n+        }\n+\n+        void removePointerById(int id) {\n+            pointers.remove(getPointerById(id));\n+        }\n+    }\n+\n+    private VideoStreamingProtocol getAcceptedProtocol(VideoStreamingParameters params) {\n+        if (params != null) {\n+            VideoStreamingFormat format = params.getFormat();\n+            if (format != null && format.getProtocol() != null) {\n+                return format.getProtocol();\n+            }\n+        }\n+        //Returns default protocol if none are found\n+        return new VideoStreamingParameters().getFormat().getProtocol();\n+\n+    }\n+\n+    protected IVideoStreamListener startVideoStream(VideoStreamingParameters params, final SdlSession session) {\n+        VideoStreamingProtocol protocol = getAcceptedProtocol(params);\n+\n+        IStreamListener iStreamListener = new IStreamListener() {\n+            @Override\n+            public void sendStreamPacket(ProtocolMessage pm) {\n+                session.sendMessage(pm);\n+            }\n+        };\n+\n+        try {\n+            switch (protocol) {\n+                case RAW: {\n+                    videoPacketizer = new StreamPacketizer(iStreamListener, null, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                case RTP: {\n+                    //FIXME why is this not an extension of StreamPacketizer?\n+                    videoPacketizer = new RTPH264Packetizer(iStreamListener, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                default:\n+                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\n+                    return null;\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    protected boolean stopVideoStream() {\n+        if (videoPacketizer != null) {\n+            videoPacketizer.stop();\n+            return true;\n+        }\n+        return false;\n+    }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzM3Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472743372", "bodyText": "Can you replace lines 541-543 with return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));?  This was the previous code, and is equivalent to the new code.", "author": "santhanamk", "createdAt": "2020-08-19T06:11:28Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -397,15 +529,18 @@ public void dispose(){\n \tpublic boolean isServiceActive(){\n \t\treturn (stateMachine.getState() == StreamingStateMachine.READY) ||\n \t\t\t\t(stateMachine.getState() == StreamingStateMachine.STARTED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED);\n+\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n+\t\t\t\t(stateMachine.getState() == StreamingStateMachine.PAUSED);\n \t}\n \n \t/**\n \t * Check if video is currently streaming and visible\n \t * @return boolean (true = yes, false = no)\n \t */\n \tpublic boolean isStreaming(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzNTU0Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473335543", "bodyText": "Can you replace lines 541-543 with return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));? This was the previous code, and is equivalent to the new code.\n\n@kostyaBoss I still see this issue.  Are you able to make this change?", "author": "santhanamk", "createdAt": "2020-08-19T21:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MzM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 5461d9d4d..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -65,898 +65,968 @@ import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.TouchCoord;\n import com.smartdevicelink.proxy.rpc.TouchEvent;\n import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.TouchType;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n import com.smartdevicelink.proxy.rpc.enums.VideoStreamingState;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.session.SdlSession;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.IVideoStreamListener;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n import com.smartdevicelink.transport.utl.TransportRecord;\n import com.smartdevicelink.util.DebugTool;\n import com.smartdevicelink.util.Version;\n \n+import java.io.IOException;\n import java.lang.ref.WeakReference;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.FutureTask;\n \n @TargetApi(19)\n public class VideoStreamManager extends BaseVideoStreamManager {\n-\tprivate static String TAG = \"VideoStreamManager\";\n-\n-\tprivate WeakReference<Context> context;\n-\tprivate volatile VirtualDisplayEncoder virtualDisplayEncoder;\n-\tprivate Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n-\tprivate SdlRemoteDisplay sdlRemoteDisplay;\n-\tprivate float[] touchScalar = {1.0f,1.0f}; //x, y\n-\tprivate HapticInterfaceManager hapticManager;\n-\tprivate SdlMotionEvent sdlMotionEvent = null;\n-\tprivate OnHMIStatus currentOnHMIStatus;\n-\tprivate StreamingStateMachine stateMachine;\n-\tprivate VideoStreamingParameters parameters;\n-\tprivate VideoStreamingCapability originalCapability;\n-\tprivate IVideoStreamListener streamListener;\n-\tprivate boolean isTransportAvailable = false;\n-\tprivate Integer majorProtocolVersion;\n-\tprivate VideoStreamingRange streamingRange;\n-\tprivate boolean hasStarted;\n-\tprivate String vehicleMake = null;\n-\tprivate boolean isEncrypted = false;\n-\tprivate boolean withPendingRestart = false;\n-\n-\t// INTERNAL INTERFACES\n-\n-\tprivate final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif (session != null && session.getAcceptedVideoParams() != null) {\n-\t\t\t\t\tparameters = session.getAcceptedVideoParams();\n-\t\t\t\t\tVideoStreamManager.this.streamListener = session.startVideoStream();\n-\t\t\t\t}\n-\n-\t\t\t\tif (VideoStreamManager.this.streamListener == null) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error starting video stream\");\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\tif(capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())){\n-\t\t\t\t\thapticManager = new HapticInterfaceManager(internalInterface);\n-\t\t\t\t}\n-\t\t\t\tcheckState();\n-\t\t\t\tstartEncoder();\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\t\thasStarted = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SdlSession session, SessionType type) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif(sdlRemoteDisplay !=null){\n-\t\t\t\t    // TODO set withPendingRestart to default in proper place\n-\t\t\t\t\tstopStreaming(withPendingRestart);\n-\t\t\t\t}\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\t\t\ttransitionToState(SETTING_UP);\n-\n-\t\t\t\tif (withPendingRestart){\n-\t\t\t\t\tVideoStreamManager manager = VideoStreamManager.this;\n-\t\t\t\t\tmanager.internalInterface.startVideoService(\n-\t\t\t\t\t\t\tmanager.getLastCachedStreamingParameters(),\n-\t\t\t\t\t\t\tmanager.isEncrypted\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceError(SdlSession session, SessionType type, String reason) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null){\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tOnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n-\t\t\t\tcurrentOnHMIStatus = onHMIStatus;\n-\n-\t\t\t\tif (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n-\t\t\t\t\tinternalInterface.stopVideoService();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null && sdlRemoteDisplay != null){\n-\t\t\t\tList<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent)notification);\n-\t\t\t\tif (motionEventList != null && !motionEventList.isEmpty()) {\n-\t\t\t\t\tfor (MotionEvent motionEvent : motionEventList) {\n-\t\t\t\t\t\tsdlRemoteDisplay.handleMotionEvent(motionEvent);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t@Override\n-\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\n-\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\n-\t\t\t// means only scale received\n-\t\t\tif (castedCapability.getPreferredResolution() == null &&\n-\t\t\t\t\tcastedCapability.getScale() != null &&\n-\t\t\t\t\tcastedCapability.getScale() != 0 &&\n-\t\t\t\t\tVideoStreamManager.this.parameters != null\n-\t\t\t\t\t&& VideoStreamManager.this.parameters.getResolution() != null) {\n-\t\t\t\t// set cached resolution\n-\t\t\t\tcastedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n-\t\t\t}\n-\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\tVideoStreamManager.this.withPendingRestart = true;\n-\n-\t\t\tvirtualDisplayEncoder.setStreamingParams(params);\n-\t\t\tstopStreaming(true);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onError(String info) {\n-\t\t\tLog.d(\"MyTagLogInfo\", info);\n-\t\t}\n-\t};\n-\n-\t// MANAGER APIs\n-\tpublic VideoStreamManager(ISdl internalInterface){\n-\t\tsuper(internalInterface);\n-\n-\t\tif(internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n-\t\t\t\tinternalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n-\t\t\tvehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n-\t\t}\n-\t\tvirtualDisplayEncoder = new VirtualDisplayEncoder();\n-\n-\t\t// Listen for video service events\n-\t\tinternalInterface.addServiceListener(SessionType.NAV, serviceListener);\n-\t\t// Take care of the touch events\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t// Listen for HMILevel changes\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t// Listen for SystemCapabilityType VIDEO_STREAMING\n-\t\tinternalInterface.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n-\t\tstateMachine = new StreamingStateMachine();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\tisTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n-\t\tcheckState();\n-\t\tsuper.start(listener);\n-\t}\n-\n-\tprivate synchronized void checkState(){\n-\t\tif(this.getState() == SETTING_UP\n-\t\t\t\t&& isTransportAvailable\n-\t\t\t\t&& isHMIStateVideoStreamCapable(currentOnHMIStatus)\n-\t\t\t\t&& parameters != null){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.READY);\n-\t\t\ttransitionToState(READY);\n-\t\t}\n-\t}\n-\n-\tboolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n-\t\tHMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n-\t\tVideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n-\t\treturn (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n-\t}\n-\n-\tprivate void getVideoStreamingParams(){\n-\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5) {\n-\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\tcheckState();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\ttransitionToState(ERROR);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\t//We just use default video streaming params\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\tif(dispCap !=null){\n-\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t}\n-\n-\t\t\tthis.parameters = params;\n-\t\t\tcheckState();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param streamingRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tthis.streamingRange = streamingRange;\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n-\t\tif(parameters == null){\n-\t\t\tif(majorProtocolVersion >= 5) {\n-\t\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\n-\t\t\t\t\t\t// Mocks data here\n-\t\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\t\t\t\tif (streamingRange != null) {\n-\t\t\t\t\t\t\t// filtering\n-\t\t\t\t\t\t\tcastedCapability.setAdditionalVideoStreamingCapabilities(\n-\t\t\t\t\t\t\t\t\tgetSupportedCapabilities(\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxScreenDiagonal(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getAspectRatio(),\n-\t\t\t\t\t\t\t\t\t\t\tcastedCapability.getAdditionalVideoStreamingCapabilities()\n-\t\t\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// TODO handle??\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tOnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n-\t\t\t\t\t\tinternalInterface.sendRPC(onAppCapabilityUpdated);\n-\t\t\t\t\t\tstartStreaming(params, isEncrypted);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}else{\n-\t\t\t\t//We just use default video streaming params\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\tif(dispCap !=null){\n-\t\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t}\n-\t\t\t\tstartStreaming(params, encrypted);\n-\t\t\t}\n-\t\t}else{\n-\t\t\tstartStreaming(parameters, encrypted);\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n-\t * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n-\t *                    VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n-\t * @param encrypted Specify true if packets on this service have to be encrypted\n-\t */\n-\tprotected void startStreaming(VideoStreamingParameters parameters, boolean encrypted){\n-\t\tthis.parameters = parameters;\n-\t\tif (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n-\t\t\tDebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n-\t\t\treturn;\n-\t\t}\n-\t\t//Start the video service\n-\t\tthis.internalInterface.startVideoService(parameters, encrypted);\n-\t}\n-\n-\t/**\n-\t * Initializes and starts the virtual display encoder and creates the remote display\n-\t */\n-\tprivate void startEncoder(){\n-\t\ttry {\n-\t\t\tif (sdlRemoteDisplay != null) {\n-\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t}\n-\n-\t\t\tvirtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n-\t\t\t//We are all set so we can start streaming at at this point\n-\t\t\tvirtualDisplayEncoder.start();\n-\t\t\t//Encoder should be up and running\n-\t\t\tDisplay display = virtualDisplayEncoder.getDisplay();\n-\t\t\tcreateRemoteDisplay(display);\n-\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\thasStarted = true;\n-\t\t} catch (Exception e) {\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming from the remote display. To restart, call\n-\t * @see #resumeStreaming()\n-\t */\n-\tpublic void stopStreaming(boolean withPendingRestart){\n-\t\tif(sdlRemoteDisplay!=null && !withPendingRestart){\n-\t\t\tsdlRemoteDisplay.stop();\n-\t\t\tthis.withPendingRestart = false;\n-\t\t}\n-\t\tif (this.isStreaming()) {\n-\t\t\tif(virtualDisplayEncoder!=null){\n-\t\t\t\tvirtualDisplayEncoder.shutDown(withPendingRestart);\n-\t\t\t}\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.PAUSED);\n-\n-\t\t\tthis.internalInterface.stopVideoService();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Resumes streaming after calling\n-\t * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n-\t * followed by a call to\n-\t * @see #stopStreaming(boolean withPendingRestart)\n-\t */\n-\tpublic void resumeStreaming(){\n-\t\tint currentState = stateMachine.getState();\n-\t\tif (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n-\t\t\tstartEncoder();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming, ends video streaming service and removes service listeners.\n-\t */\n-\t@Override\n-\tpublic void dispose(){\n-\t\tstopStreaming(false);\n-\n-\t\thapticManager = null;\n-\t\tsdlRemoteDisplay = null;\n-\t\tparameters = null;\n-\t\tvirtualDisplayEncoder = null;\n-\t\tif (internalInterface != null) {\n-\t\t\tinternalInterface.stopVideoService();\n-\t\t\t// Remove listeners\n-\t\t\tinternalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t}\n-\n-\n-\n-\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\tsuper.dispose();\n-\t}\n-\n-\t// PUBLIC METHODS FOR CHECKING STATE\n-\n-\t/**\n-\t * Check if a video service is currently active\n-\t * @return boolean (true = active, false = inactive)\n-\t */\n-\tpublic boolean isServiceActive(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.READY) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STARTED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.PAUSED);\n-\t}\n-\n-\t/**\n-\t * Check if video is currently streaming and visible\n-\t * @return boolean (true = yes, false = no)\n-\t */\n-\tpublic boolean isStreaming(){\n-\t\tboolean state = (stateMachine.getState() == StreamingStateMachine.STARTED);\n-\t\tboolean capable = isHMIStateVideoStreamCapable(currentOnHMIStatus);\n-\t\treturn state && capable;\n-\t}\n-\n-\t/**\n-\t * Check if video streaming has been paused due to app moving to background or manually stopped\n-\t * @return boolean (true = not paused, false = paused)\n-\t */\n-\tpublic boolean isPaused(){\n-\t\treturn (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n-\t}\n-\n-\t/**\n-\t * Gets the current video streaming state as defined in @StreamingStateMachine\n-\t * @return int representing StreamingStateMachine.StreamingState\n-\t */\n-\tpublic @StreamingStateMachine.StreamingState int currentVideoStreamState(){\n-\t\treturn stateMachine.getState();\n-\t}\n-\n-\t// HELPER METHODS\n-\n-\tprivate void createRemoteDisplay(final Display disp){\n-\t\ttry{\n-\t\t\tif (disp == null){\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Dismiss the current presentation if the display has changed.\n-\t\t\tif (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n-\t\t\t\tsdlRemoteDisplay.dismissPresentation();\n-\t\t\t}\n-\n-\t\t\tFutureTask<Boolean> fTask =  new FutureTask<Boolean>( new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback(){\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCreated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Remote display has been created.\n-\t\t\t\t\t//Now is a good time to do parsing for spatial data\n-\t\t\t\t\tVideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\t//Get touch scalars\n-\t\t\t\t\tImageResolution resolution = null;\n-\t\t\t\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5){ //At this point we should already have the capability\n-\t\t\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\t\t\tif(capability != null){\n-\t\t\t\t\t\t\tresolution = capability.getPreferredResolution();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution == null){ //Either the protocol version is too low to access video streaming caps, or they were null\n-\t\t\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities) internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\t\t\tif (dispCap != null) {\n-\t\t\t\t\t\t\tresolution = (dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution != null){\n-\t\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\t\tdisp.getMetrics(displayMetrics);\n-\t\t\t\t\t\tcreateTouchScalar(resolution, displayMetrics);\n+    private static final String TAG = \"VideoStreamManager\";\n+\n+    private WeakReference<Context> context;\n+    private volatile VirtualDisplayEncoder virtualDisplayEncoder;\n+    private Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n+    private SdlRemoteDisplay sdlRemoteDisplay;\n+    private final float[] touchScalar = {1.0f, 1.0f}; //x, y\n+    private HapticInterfaceManager hapticManager;\n+    private SdlMotionEvent sdlMotionEvent = null;\n+    private OnHMIStatus currentOnHMIStatus;\n+    private final StreamingStateMachine stateMachine;\n+    private VideoStreamingParameters parameters;\n+    private VideoStreamingCapability originalCapability;\n+    private IVideoStreamListener streamListener;\n+    private boolean isTransportAvailable = false;\n+    private Integer majorProtocolVersion;\n+    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private boolean hasStarted;\n+    private String vehicleMake = null;\n+    private boolean isEncrypted = false;\n+    private boolean withPendingRestart = false;\n+    private AbstractPacketizer videoPacketizer;\n+\n+    // INTERNAL INTERFACES\n+\n+    private final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n+        @Override\n+        public void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n+            if (SessionType.NAV.equals(type)) {\n+                if (session != null && session.getAcceptedVideoParams() != null) {\n+                    parameters = session.getAcceptedVideoParams();\n+                    VideoStreamManager.this.streamListener = startVideoStream(session.getAcceptedVideoParams(), session);\n+                }\n+\n+                if (VideoStreamManager.this.streamListener == null) {\n+                    DebugTool.logError(TAG, \"Error starting video stream\");\n+                    stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                    return;\n+                }\n+                VideoStreamingCapability capability = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                }\n+                if (capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())) {\n+                    hapticManager = new HapticInterfaceManager(internalInterface);\n+                }\n+                checkState();\n+                startEncoder();\n+                stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+                hasStarted = true;\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceEnded(SdlSession session, SessionType type) {\n+            if (SessionType.NAV.equals(type)) {\n+                //stopVideoStream();\n+                if (sdlRemoteDisplay !=null){\n+                    stopStreaming(withPendingRestart);\n+                }\n+                stateMachine.transitionToState(StreamingStateMachine.NONE);\n+                transitionToState(SETTING_UP);\n+\n+                if (withPendingRestart){\n+                    VideoStreamManager manager = VideoStreamManager.this;\n+                    manager.internalInterface.startVideoService(\n+                            manager.getLastCachedStreamingParameters(),\n+                            manager.isEncrypted,\n+                            withPendingRestart\n+                    );\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceError(SdlSession session, SessionType type, String reason) {\n+            DebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n+            stopVideoStream();\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            transitionToState(BaseSubManager.ERROR);\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                OnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n+                currentOnHMIStatus = onHMIStatus;\n+                if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+                    getVideoStreamingParams();\n+                }\n+                checkState();\n+                if (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n+                    stopVideoStream();\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null && sdlRemoteDisplay != null) {\n+                List<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent) notification);\n+                if (motionEventList != null && !motionEventList.isEmpty()) {\n+                    for (MotionEvent motionEvent : motionEventList) {\n+                        sdlRemoteDisplay.handleMotionEvent(motionEvent);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+\n+            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+            // means only scale received\n+            if (castedCapability.getPreferredResolution() == null &&\n+                    castedCapability.getScale() != null &&\n+                    castedCapability.getScale() != 0 &&\n+                    VideoStreamManager.this.parameters != null\n+                    && VideoStreamManager.this.parameters.getResolution() != null) {\n+                // set cached resolution\n+                castedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+            }\n+            params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+            VideoStreamManager.this.parameters = params;\n+\n+            VideoStreamManager.this.withPendingRestart = true;\n+\n+            virtualDisplayEncoder.setStreamingParams(params);\n+            stopStreaming(true);\n+        }\n+\n+        @Override\n+        public void onError(String info) { }\n+    };\n+\n+    // MANAGER APIs\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public VideoStreamManager(ISdl internalInterface) {\n+        super(internalInterface);\n+\n+        if (internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n+                internalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n+            vehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n+        }\n+        virtualDisplayEncoder = new VirtualDisplayEncoder();\n+\n+        // Listen for video service events\n+        internalInterface.addServiceListener(SessionType.NAV, serviceListener);\n+        // Take care of the touch events\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+        // Listen for HMILevel changes\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        // Listen for SystemCapabilityType VIDEO_STREAMING\n+        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n+        stateMachine = new StreamingStateMachine();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        isTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n+        checkState();\n+        super.start(listener);\n+    }\n+\n+    private synchronized void checkState() {\n+        if (this.getState() == SETTING_UP\n+                && isTransportAvailable\n+                && isHMIStateVideoStreamCapable(currentOnHMIStatus)\n+                && parameters != null) {\n+            stateMachine.transitionToState(StreamingStateMachine.READY);\n+            transitionToState(READY);\n+        }\n+    }\n+\n+    boolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n+        HMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n+        VideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n+        return (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n+    }\n+\n+    private void getVideoStreamingParams() {\n+        if (internalInterface.getProtocolVersion().getMajor() >= 5) {\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                    @Override\n+                    public void onCapabilityRetrieved(Object capability) {\n+                        VideoStreamingParameters params = new VideoStreamingParameters();\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+                        params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+                        // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                        checkState();\n+                        }\n+\n+                    @Override\n+                    public void onError(String info) {\n+                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                        transitionToState(ERROR);\n+                    }\n+                }, false);\n+            }\n+        } else {\n+            //We just use default video streaming params\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+            DisplayCapabilities dispCap = null;\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+            }\n+            if (dispCap != null) {\n+                params.setResolution(dispCap.getScreenParams().getImageResolution());\n+            }\n+\n+            this.parameters = params;\n+            checkState();\n+        }\n+    }\n+\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {\n+            if (majorProtocolVersion >= 5) {\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                        @Override\n+                        public void onCapabilityRetrieved(Object capability) {\n+                            VideoStreamingParameters params = new VideoStreamingParameters();\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                            VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                            // Mocks data here\n+                            // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                            params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+                            if (listOfStreamingRanges != null) {\n+                                // filtering\n+                                castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                                );\n+                            } else { }\n+                            OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n+                            internalInterface.sendRPC(onAppCapabilityUpdated);\n+                            startStreaming(params, isEncrypted);\n+                        }\n+\n+                        @Override\n+                        public void onError(String info) {\n+                            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                            DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        }\n+                    }, false);\n+                }\n+            } else {\n+                //We just use default video streaming params\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                DisplayCapabilities dispCap = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                }\n+                if (dispCap != null) {\n+                    params.setResolution(dispCap.getScreenParams().getImageResolution());\n+                }\n+                startStreaming(params, encrypted);\n+            }\n+        } else {\n+            startStreaming(parameters, encrypted);\n+        }\n+    }\n+\n+\n+    /**\n+     * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n+     *\n+     * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n+     *                   VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n+     * @param encrypted  Specify true if packets on this service have to be encrypted\n+     */\n+    protected void startStreaming(VideoStreamingParameters parameters, boolean encrypted) {\n+        this.parameters = parameters;\n+        if (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n+            DebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n+            return;\n+        }\n+        //Start the video service\n+        this.internalInterface.startVideoService(parameters, encrypted, false);\n+    }\n+\n+    /**\n+     * Initializes and starts the virtual display encoder and creates the remote display\n+     */\n+    private void startEncoder() {\n+        try {\n+            if (sdlRemoteDisplay != null) {\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+            }\n+\n+            virtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n+            //We are all set so we can start streaming at at this point\n+            virtualDisplayEncoder.start();\n+            //Encoder should be up and running\n+            createRemoteDisplay(virtualDisplayEncoder.getDisplay());\n+\n+            stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+            hasStarted = true;\n+        } catch (Exception e) {\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    public void stopStreaming(boolean withPendingRestart) {\n+        if (sdlRemoteDisplay!= null && !withPendingRestart) {\n+            sdlRemoteDisplay.stop();\n+                this.withPendingRestart = false;\n+        }\n+        if (this.isStreaming()) {\n+            if (virtualDisplayEncoder!=null){\n+                virtualDisplayEncoder.shutDown(withPendingRestart);\n+            }\n+            stateMachine.transitionToState(StreamingStateMachine.PAUSED);\n+            stopVideoStream();\n+        }\n+    }\n+\n+    /**\n+     * Resumes streaming after calling\n+     *\n+     * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n+     * followed by a call to\n+     * @see #stopStreaming(boolean withPendingRestart)\n+     */\n+    public void resumeStreaming() {\n+        int currentState = stateMachine.getState();\n+        if (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n+            startEncoder();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming, ends video streaming service and removes service listeners.\n+     */\n+    @Override\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void dispose() {\n+        stopStreaming(false);\n+\n+        hapticManager = null;\n+        sdlRemoteDisplay = null;\n+        parameters = null;\n+        virtualDisplayEncoder = null;\n+        if (internalInterface != null) {\n+            // Remove listeners\n+            internalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        }\n+\n+        stopVideoStream();\n+\n+\n+        stateMachine.transitionToState(StreamingStateMachine.NONE);\n+        super.dispose();\n+    }\n+\n+    // PUBLIC METHODS FOR CHECKING STATE\n+\n+    /**\n+     * Check if a video service is currently active\n+     *\n+     * @return boolean (true = active, false = inactive)\n+     */\n+    public boolean isServiceActive() {\n+        return (stateMachine.getState() == StreamingStateMachine.READY) ||\n+                (stateMachine.getState() == StreamingStateMachine.STARTED) ||\n+                (stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n+                (stateMachine.getState() == StreamingStateMachine.PAUSED);\n+        }\n+\n+    /**\n+     * Check if video is currently streaming and visible\n+     *\n+     * @return boolean (true = yes, false = no)\n+     */\n+    public boolean isStreaming() {\n+        return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Check if video streaming has been paused due to app moving to background or manually stopped\n+     *\n+     * @return boolean (true = not paused, false = paused)\n+     */\n+    public boolean isPaused() {\n+        return (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Gets the current video streaming state as defined in @StreamingStateMachine\n+     *\n+     * @return int representing StreamingStateMachine.StreamingState\n+     */\n+    public @StreamingStateMachine.StreamingState\n+    int currentVideoStreamState() {\n+        return stateMachine.getState();\n+    }\n+\n+    // HELPER METHODS\n+\n+    private void createRemoteDisplay(final Display disp) {\n+        try {\n+            if (disp == null) {\n+                return;\n+            }\n+\n+            // Dismiss the current presentation if the display has changed.\n+            if (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n+                sdlRemoteDisplay.dismissPresentation();\n+            }\n+\n+            FutureTask<Boolean> fTask = new FutureTask<>(new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback() {\n+                @Override\n+                public void onCreated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Remote display has been created.\n+                    //Now is a good time to do parsing for spatial data\n+                    VideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                    //Get touch scalars\n+                    ImageResolution resolution = null;\n+                    if (internalInterface.getProtocolVersion().getMajor() >= 5) { //At this point we should already have the capability\n+                        VideoStreamingCapability capability = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                        }\n+                        if (capability != null) {\n+                            resolution = capability.getPreferredResolution();\n+                        }\n+                    }\n+\n+                    if (resolution == null) { //Either the protocol version is too low to access video streaming caps, or they were null\n+                        DisplayCapabilities dispCap = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                        }\n+                        if (dispCap != null) {\n+                            resolution = (dispCap.getScreenParams().getImageResolution());\n+                        }\n+                    }\n+\n+                    if (resolution != null) {\n+                        DisplayMetrics displayMetrics = new DisplayMetrics();\n+                        disp.getMetrics(displayMetrics);\n+                        createTouchScalar(resolution, displayMetrics);\n                     }\n \n-\t\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Our view has been invalidated\n-\t\t\t\t\t//A good time to refresh spatial data\n-\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\tsdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n-\t\t\t\t\tdisplayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n-\t\t\t\t\tdisplayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n-\t\t\t\t\tcreateTouchScalar(parameters.getResolution(), displayMetrics);\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ));\n-\t\t\tThread showPresentation = new Thread(fTask);\n-\t\t\tshowPresentation.setName(\"RmtDispThread\");\n-\n-\t\t\tshowPresentation.start();\n-\t\t} catch (Exception ex) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n-\t\t\tif(DebugTool.isDebugEnabled()){\n-\t\t\t\tex.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail){\n-\n-\t\tisTransportAvailable = videoStreamTransportAvail;\n-\n-\t\tif(internalInterface.getProtocolVersion().isNewerThan(new Version(5,1,0)) >= 0){\n-\t\t\tif(videoStreamTransportAvail){\n-\t\t\t\tcheckState();\n-\t\t\t}\n-\t\t}else{\n-\t\t\t//The protocol version doesn't support simultaneous transports.\n-\t\t\tif(!videoStreamTransportAvail){\n-\t\t\t\t//If video streaming isn't available on primary transport then it is not possible to\n-\t\t\t\t//use the video streaming manager until a complete register on a transport that\n-\t\t\t\t//supports video\n-\t\t\t\ttransitionToState(ERROR);\n-\t\t\t}\n-\t\t}\n-\t}\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+                }\n+\n+                @Override\n+                public void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Our view has been invalidated\n+                    //A good time to refresh spatial data\n+                    DisplayMetrics displayMetrics = new DisplayMetrics();\n+                    sdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n+                    displayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n+                    displayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n+                    createTouchScalar(parameters.getResolution(), displayMetrics);\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                }\n+            }));\n+            Thread showPresentation = new Thread(fTask);\n+            showPresentation.setName(\"RmtDispThread\");\n+\n+            showPresentation.start();\n+        } catch (Exception ex) {\n+            DebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n+            if (DebugTool.isDebugEnabled()) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail) {\n+\n+        isTransportAvailable = videoStreamTransportAvail;\n+\n+        if (internalInterface.getProtocolVersion().isNewerThan(new Version(5, 1, 0)) >= 0) {\n+            if (videoStreamTransportAvail) {\n+                checkState();\n+            }\n+        } else {\n+            //The protocol version doesn't support simultaneous transports.\n+            if (!videoStreamTransportAvail) {\n+                //If video streaming isn't available on primary transport then it is not possible to\n+                //use the video streaming manager until a complete register on a transport that\n+                //supports video\n+                transitionToState(ERROR);\n+            }\n+        }\n+    }\n \n     void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics) {\n-        touchScalar[0] = ((float)displayMetrics.widthPixels) / resolution.getResolutionWidth();\n-        touchScalar[1] = ((float)displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+        touchScalar[0] = ((float) displayMetrics.widthPixels) / resolution.getResolutionWidth();\n+        touchScalar[1] = ((float) displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+    }\n+\n+    List<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent) {\n+        List<MotionEvent> motionEventList = new ArrayList<>();\n+\n+        List<TouchEvent> touchEventList = onTouchEvent.getEvent();\n+        if (touchEventList == null || touchEventList.size() == 0) return null;\n+\n+        TouchType touchType = onTouchEvent.getType();\n+        if (touchType == null) {\n+            return null;\n+        }\n+\n+        if (sdlMotionEvent == null) {\n+            if (touchType == TouchType.BEGIN) {\n+                sdlMotionEvent = new SdlMotionEvent();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        SdlMotionEvent.Pointer pointer;\n+        MotionEvent motionEvent;\n+\n+        for (TouchEvent touchEvent : touchEventList) {\n+            if (touchEvent == null || touchEvent.getId() == null) {\n+                continue;\n+            }\n+\n+            List<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n+            if (touchCoordList == null || touchCoordList.size() == 0) {\n+                continue;\n+            }\n+\n+            TouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n+            if (touchCoord == null) {\n+                continue;\n+            }\n+\n+            int motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n+            long downTime = sdlMotionEvent.downTime;\n+            long eventTime = sdlMotionEvent.eventTime;\n+            pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n+            if (pointer != null) {\n+                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n+            }\n+\n+            MotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n+            MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n+\n+            for (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n+                pointerProperties[i] = new MotionEvent.PointerProperties();\n+                pointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n+                pointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n+\n+                pointerCoords[i] = new MotionEvent.PointerCoords();\n+                pointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n+                pointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n+                pointerCoords[i].orientation = 0;\n+                pointerCoords[i].pressure = 1.0f;\n+                pointerCoords[i].size = 1;\n+            }\n+\n+            motionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n+                    sdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n+                    1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n+            motionEventList.add(motionEvent);\n+\n+            if (motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL) {\n+                //If the motion event should be finished we should clear our reference\n+                sdlMotionEvent.pointers.clear();\n+                sdlMotionEvent = null;\n+                break;\n+            } else if ((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP) {\n+                sdlMotionEvent.removePointerById(touchEvent.getId());\n+            }\n+        }\n+\n+        return motionEventList;\n+    }\n+\n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n     }\n \n-\tList<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent){\n-\t\tList<MotionEvent> motionEventList = new ArrayList<MotionEvent>();\n-\n-\t\tList<TouchEvent> touchEventList = onTouchEvent.getEvent();\n-\t\tif (touchEventList == null || touchEventList.size() == 0) return null;\n-\n-\t\tTouchType touchType = onTouchEvent.getType();\n-\t\tif (touchType == null) { return null; }\n-\n-\t\tif(sdlMotionEvent == null) {\n-\t\t\tif (touchType == TouchType.BEGIN) {\n-\t\t\t\tsdlMotionEvent = new SdlMotionEvent();\n-\t\t\t} else{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tSdlMotionEvent.Pointer pointer;\n-\t\tMotionEvent motionEvent;\n-\n-\t\tfor (TouchEvent touchEvent : touchEventList) {\n-\t\t\tif (touchEvent == null || touchEvent.getId() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tList<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n-\t\t\tif (touchCoordList == null || touchCoordList.size() == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tTouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n-\t\t\tif (touchCoord == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tint motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n-\t\t\tlong downTime = sdlMotionEvent.downTime;\n-\t\t\tlong eventTime = sdlMotionEvent.eventTime;\n-\t\t\tpointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n-\t\t\tif (pointer != null) {\n-\t\t\t\tpointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n-\t\t\t}\n-\n-\t\t\tMotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n-\t\t\tMotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n-\n-\t\t\tfor (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n-\t\t\t\tpointerProperties[i] = new MotionEvent.PointerProperties();\n-\t\t\t\tpointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n-\t\t\t\tpointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n-\n-\t\t\t\tpointerCoords[i] = new MotionEvent.PointerCoords();\n-\t\t\t\tpointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n-\t\t\t\tpointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n-\t\t\t\tpointerCoords[i].orientation = 0;\n-\t\t\t\tpointerCoords[i].pressure = 1.0f;\n-\t\t\t\tpointerCoords[i].size = 1;\n-\t\t\t}\n-\n-\t\t\tmotionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n-\t\t\t\t\tsdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n-\t\t\t\t\t1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n-\t\t\tmotionEventList.add(motionEvent);\n-\n-\t\t\tif(motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL){\n-\t\t\t\t//If the motion event should be finished we should clear our reference\n-\t\t\t\tsdlMotionEvent.pointers.clear();\n-\t\t\t\tsdlMotionEvent = null;\n-\t\t\t\tbreak;\n-\t\t\t} else if((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP){\n-\t\t\t\tsdlMotionEvent.removePointerById(touchEvent.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn motionEventList;\n-\t}\n-\n-\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n-\t\treturn parameters;\n-\t}\n-\n-\tpublic boolean getLastCachedIsEncrypted() {\n-\t\treturn isEncrypted;\n-\t}\n-\n-\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n-\t\t\tResolution minResolution,\n-\t\t\tResolution maxResolution,\n-\t\t\tDouble constraintDiagonalMax,\n-\t\t\tAspectRatio ratioRange,\n-\t\t\tList<VideoStreamingCapability> originalAdditionalCapabilities\n-\t){\n-\t\tInteger constraintHeightMax = maxResolution.getResolutionHeight();\n-\t\tInteger constraintHeightMin = minResolution.getResolutionHeight();\n-\t\tInteger constraintWidthMax = maxResolution.getResolutionWidth();\n-\t\tInteger constraintWidthMin = minResolution.getResolutionWidth();\n-\t\tDouble aspectRationMin = ratioRange.getMinAspectRatio();\n-\t\tDouble aspectRationMax = ratioRange.getMaxAspectRatio();\n-\n-\t\tList<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n-\n-\t\tVideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n-\t\tpreferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n-\t\tpreferredCapability.setPreferredResolution(new ImageResolution(\n-\t\t\t\tparameters.getResolution().getResolutionWidth(),\n-\t\t\t\tparameters.getResolution().getResolutionHeight())\n-\t\t);\n-\n-\t\t// get the first one - the Desired resolution to guarantee streaming will start\n-\t\tvalidCapabilities.add(preferredCapability);\n-\n-\t\tfor (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n-\t\t\tdouble diagonal;\n-\t\t\tint resolutionHeight;\n-\t\t\tint resolutionWidth;\n-\t\t\t// TODO refactor\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionHeight() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionHeight = capability.getPreferredResolution().getResolutionHeight();\n-\t\t\t}\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionWidth() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionWidth = capability.getPreferredResolution().getResolutionWidth();\n-\t\t\t}\n-\t\t\tif (capability.getDiagonalScreenSize() == null ) {\n-\t\t\t\tdiagonal = parameters.getPreferredDiagonal();\n-\t\t\t} else {\n-\t\t\t\tdiagonal = capability.getDiagonalScreenSize();\n-\t\t\t}\n-\n-\t\t\tif (constraintDiagonalMax < diagonal) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!isAspectRatioInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tif (constraintHeightMax == null && constraintHeightMin == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!isImageResolutionInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tvalidCapabilities.add(capability);\n-\t\t}\n-\n-\t\treturn validCapabilities;\n-\t}\n-\n-\tpublic Boolean isImageResolutionInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\n-\t\tInteger constraintHeightMax = range.getMaxSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintHeightMin = range.getMinSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintWidthMax = range.getMaxSupportedResolution().getResolutionWidth();\n-\t\tInteger constraintWidthMin = range.getMinSupportedResolution().getResolutionWidth();\n-\t\tInteger resolutionHeight = currentResolution.getResolutionHeight();\n-\t\tInteger resolutionWidth = currentResolution.getResolutionWidth();\n-\t\tif (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null)\n-\t\t{\n-\t\t\tif (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tif (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// TODO check what if dev provided invalid constraints\n-\t\treturn true;\n-\t}\n-\n-\tpublic Boolean isAspectRatioInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\t\tDouble aspectRatioMin = range.getAspectRatio().getMinAspectRatio();\n-\t\tDouble aspectRatioMax = range.getAspectRatio().getMaxAspectRatio();\n-\n-\t\tDouble currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n-\n-\t\tif (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n-\t\t\tif ((currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\t// TODO check what if dev provided invalid constraints\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * Keeps track of the current motion event for VPM\n-\t */\n-\tprivate static class SdlMotionEvent {\n-\t\tclass Pointer {\n-\t\t\tint id;\n-\t\t\tfloat x;\n-\t\t\tfloat y;\n-\t\t\tPointer (int id) {\n-\t\t\t\tthis.id = id;\n-\t\t\t\tthis.x = 0.0f;\n-\t\t\t\tthis.y = 0.0f;\n-\t\t\t}\n-\t\t\tvoid setCoords(float x, float y) {\n-\t\t\t\tthis.x = x;\n-\t\t\t\tthis.y = y;\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n-\t\tprivate long downTime;\n-\t\tprivate long downTimeOnHMI;\n-\t\tprivate long eventTime;\n-\n-\t\tSdlMotionEvent(){\n-\t\t\tdownTimeOnHMI = 0;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n-\t\t * Android MotionEvent according to this events status\n-\t\t * @param touchType The SDL TouchType that was received from the module\n-\t\t * @param touchEvent The SDL TouchEvent that was received from the module\n-\t\t * @return the correct native Android MotionEvent action to dispatch\n-\t\t */\n-\t\tsynchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent){\n-\t\t\teventTime = 0;\n-\t\t\tint motionEventAction = -1;\n-\t\t\tswitch (touchType){\n-\t\t\t\tcase BEGIN:\n-\t\t\t\t\tif(pointers.size() == 0){\n-\t\t\t\t\t\t//The motion event has just begun\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_DOWN;\n-\t\t\t\t\t\tdownTime = SystemClock.uptimeMillis();\n-\t\t\t\t\t\tdownTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n-\t\t\t\t\t\teventTime = downTime;\n-\t\t\t\t\t} else{\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\t}\n-\t\t\t\t\tpointers.add(new Pointer(touchEvent.getId()));\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase MOVE:\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_MOVE;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase END:\n-\t\t\t\t\tif(pointers.size() <= 1){\n-\t\t\t\t\t\t//The motion event has just ended\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tint pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n-\t\t\t\t\t\tif (pointerIndex != -1) {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase CANCEL:\n-\t\t\t\t\t//Assuming this cancels the entire event\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_CANCEL;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\treturn motionEventAction;\n-\t\t}\n-\n-\t\tPointer getPointerById(int id){\n-\t\t\tif (pointers != null && !pointers.isEmpty()){\n-\t\t\t\tfor (Pointer pointer : pointers){\n-\t\t\t\t\tif (pointer.id == id){\n-\t\t\t\t\t\treturn pointer;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tPointer getPointerByIndex(int index){\n-\t\t\treturn pointers.get(index);\n-\t\t}\n-\n-\t\tvoid removePointerById(int id){\n-\t\t\tpointers.remove(getPointerById(id));\n-\t\t}\n-\t}\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n+        Double aspectRatioMin = aspectRatio.getMinAspectRatio();\n+        Double aspectRatioMax = aspectRatio.getMaxAspectRatio();\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n+            if (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Keeps track of the current motion event for VPM\n+     */\n+    private static class SdlMotionEvent {\n+        class Pointer {\n+            final int id;\n+            float x;\n+            float y;\n+\n+            Pointer(int id) {\n+                this.id = id;\n+                this.x = 0.0f;\n+                this.y = 0.0f;\n+            }\n+\n+            void setCoords(float x, float y) {\n+                this.x = x;\n+                this.y = y;\n+            }\n+        }\n+\n+        private final CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n+        private long downTime;\n+        private long downTimeOnHMI;\n+        private long eventTime;\n+\n+        SdlMotionEvent() {\n+            downTimeOnHMI = 0;\n+        }\n+\n+        /**\n+         * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n+         * Android MotionEvent according to this events status\n+         *\n+         * @param touchType  The SDL TouchType that was received from the module\n+         * @param touchEvent The SDL TouchEvent that was received from the module\n+         * @return the correct native Android MotionEvent action to dispatch\n+         */\n+        synchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent) {\n+            eventTime = 0;\n+            int motionEventAction = -1;\n+            switch (touchType) {\n+                case BEGIN:\n+                    if (pointers.size() == 0) {\n+                        //The motion event has just begun\n+                        motionEventAction = MotionEvent.ACTION_DOWN;\n+                        downTime = SystemClock.uptimeMillis();\n+                        downTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n+                        eventTime = downTime;\n+                    } else {\n+                        motionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    }\n+                    pointers.add(new Pointer(touchEvent.getId()));\n+                    break;\n+                case MOVE:\n+                    motionEventAction = MotionEvent.ACTION_MOVE;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case END:\n+                    if (pointers.size() <= 1) {\n+                        //The motion event has just ended\n+                        motionEventAction = MotionEvent.ACTION_UP;\n+                    } else {\n+                        int pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n+                        if (pointerIndex != -1) {\n+                            motionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        } else {\n+                            motionEventAction = MotionEvent.ACTION_UP;\n+                        }\n+                    }\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case CANCEL:\n+                    //Assuming this cancels the entire event\n+                    motionEventAction = MotionEvent.ACTION_CANCEL;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return motionEventAction;\n+        }\n+\n+        Pointer getPointerById(int id) {\n+            if (pointers != null && !pointers.isEmpty()) {\n+                for (Pointer pointer : pointers) {\n+                    if (pointer.id == id) {\n+                        return pointer;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        Pointer getPointerByIndex(int index) {\n+            return pointers.get(index);\n+        }\n+\n+        void removePointerById(int id) {\n+            pointers.remove(getPointerById(id));\n+        }\n+    }\n+\n+    private VideoStreamingProtocol getAcceptedProtocol(VideoStreamingParameters params) {\n+        if (params != null) {\n+            VideoStreamingFormat format = params.getFormat();\n+            if (format != null && format.getProtocol() != null) {\n+                return format.getProtocol();\n+            }\n+        }\n+        //Returns default protocol if none are found\n+        return new VideoStreamingParameters().getFormat().getProtocol();\n+\n+    }\n+\n+    protected IVideoStreamListener startVideoStream(VideoStreamingParameters params, final SdlSession session) {\n+        VideoStreamingProtocol protocol = getAcceptedProtocol(params);\n+\n+        IStreamListener iStreamListener = new IStreamListener() {\n+            @Override\n+            public void sendStreamPacket(ProtocolMessage pm) {\n+                session.sendMessage(pm);\n+            }\n+        };\n+\n+        try {\n+            switch (protocol) {\n+                case RAW: {\n+                    videoPacketizer = new StreamPacketizer(iStreamListener, null, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                case RTP: {\n+                    //FIXME why is this not an extension of StreamPacketizer?\n+                    videoPacketizer = new RTPH264Packetizer(iStreamListener, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                default:\n+                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\n+                    return null;\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    protected boolean stopVideoStream() {\n+        if (videoPacketizer != null) {\n+            videoPacketizer.stop();\n+            return true;\n+        }\n+        return false;\n+    }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc1MDU1MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472750551", "bodyText": "In VideoStreamManager.java there is this line pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]); where the MotionEvent pointer is set using division.  How come in the unit test it has been changed to multiplication?", "author": "santhanamk", "createdAt": "2020-08-19T06:21:35Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java", "diffHunk": "@@ -538,8 +543,8 @@ private void assertMotionEventWithScale(int width, int height, float scale) {\n \n         motionEvent = motionEventList.get(0);\n         assertEquals(1, motionEvent.getPointerCount());\n-        assertEquals(Math.round(e1x / scale), Math.round(motionEvent.getX(0)));\n-        assertEquals(Math.round(e1y / scale), Math.round(motionEvent.getY(0)));\n+        assertEquals(Math.round(e1x * scale), Math.round(motionEvent.getX(0)));", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2OTEzOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473369138", "bodyText": "In VideoStreamManager.java there is this line pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]); where the MotionEvent pointer is set using division. How come in the unit test it has been changed to multiplication?\n\n@kostyaBoss In VideoStreamManager.java there is this line pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]); where the MotionEvent pointer is set using division. How come in the unit test it has been changed to multiplication?", "author": "santhanamk", "createdAt": "2020-08-19T22:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc1MDU1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\nindex 871d8f77f..79c3d6240 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n\n@@ -548,38 +589,41 @@ public class VideoStreamManagerTests {\n     }\n \n     @Test\n-\tpublic void testIsHMIStateVideoStreamCapable() {\n-\t\tVideoStreamManager videoStreamManager = new VideoStreamManager(mock(ISdl.class));\n-\n-\t\t// Case 1 (VideoStreamingState = STREAMABLE)\n-\t\tassertTrue(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_FULL, VideoStreamingState.STREAMABLE)));\n-\t\tassertTrue(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_LIMITED, VideoStreamingState.STREAMABLE)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_BACKGROUND, VideoStreamingState.STREAMABLE)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_NONE, VideoStreamingState.STREAMABLE)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(null, VideoStreamingState.STREAMABLE)));\n-\n-\t\t// Case 2 (VideoStreamingState = NOT_STREAMABLE)\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_FULL, VideoStreamingState.NOT_STREAMABLE)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_LIMITED, VideoStreamingState.NOT_STREAMABLE)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_BACKGROUND, VideoStreamingState.NOT_STREAMABLE)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_NONE, VideoStreamingState.NOT_STREAMABLE)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(null, VideoStreamingState.NOT_STREAMABLE)));\n-\n-\t\t// Case 3 (VideoStreamingState = NULL)\n-\t\tassertTrue(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_FULL, null)));\n-\t\tassertTrue(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_LIMITED, null)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_BACKGROUND, null)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_NONE, null)));\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(null, null)));\n-\n-\t\t// Case 4 (onHMIStatus = NULL)\n-\t\tassertFalse(videoStreamManager.isHMIStateVideoStreamCapable(null));\n-\t}\n-\n-\tprivate OnHMIStatus createOnHMIStatus(HMILevel hmiLevel, VideoStreamingState videoStreamingState) {\n-\t\tOnHMIStatus onHMIStatus = new OnHMIStatus();\n-\t\tonHMIStatus.setHmiLevel(hmiLevel);\n-\t\tonHMIStatus.setVideoStreamingState(videoStreamingState);\n-\t\treturn onHMIStatus;\n-\t}\n+    public void testIsHMIStateVideoStreamCapable() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+\n+        // Case 1 (VideoStreamingState = STREAMABLE)\n+        assertTrue(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_FULL, VideoStreamingState.STREAMABLE)));\n+        assertTrue(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_LIMITED, VideoStreamingState.STREAMABLE)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_BACKGROUND, VideoStreamingState.STREAMABLE)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_NONE, VideoStreamingState.STREAMABLE)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(null, VideoStreamingState.STREAMABLE)));\n+\n+        // Case 2 (VideoStreamingState = NOT_STREAMABLE)\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_FULL, VideoStreamingState.NOT_STREAMABLE)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_LIMITED, VideoStreamingState.NOT_STREAMABLE)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_BACKGROUND, VideoStreamingState.NOT_STREAMABLE)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_NONE, VideoStreamingState.NOT_STREAMABLE)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(null, VideoStreamingState.NOT_STREAMABLE)));\n+\n+        // Case 3 (VideoStreamingState = NULL)\n+        assertTrue(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_FULL, null)));\n+        assertTrue(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_LIMITED, null)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_BACKGROUND, null)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(HMILevel.HMI_NONE, null)));\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(createOnHMIStatus(null, null)));\n+\n+        // Case 4 (onHMIStatus = NULL)\n+        assertFalse(videoStreamManager.isHMIStateVideoStreamCapable(null));\n+    }\n+\n+    private OnHMIStatus createOnHMIStatus(HMILevel hmiLevel, VideoStreamingState videoStreamingState) {\n+        OnHMIStatus onHMIStatus = new OnHMIStatus();\n+        onHMIStatus.setHmiLevel(hmiLevel);\n+        onHMIStatus.setVideoStreamingState(videoStreamingState);\n+        return onHMIStatus;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc1MTIxNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472751217", "bodyText": "Do more unit tests need to be added to test all of the new code that was added in VideoStreamManager.java?", "author": "santhanamk", "createdAt": "2020-08-19T06:22:24Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java", "diffHunk": "@@ -92,6 +92,11 @@ protected void onCreate(Bundle savedInstanceState) {\n \t\t\tsetContentView(simulatedView);\n \t\t}\n \n+\t\t@Override\n+\t\tpublic void onViewResized(int width, int height) {\n+\n+\t\t}\n+\n \t\t@Override", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2ODg1NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473368855", "bodyText": "Do more unit tests need to be added to test all of the new code that was added in VideoStreamManager.java?\n\n@kostyaBoss Do more unit tests need to be added to test all of the new code that was added in VideoStreamManager.java?", "author": "santhanamk", "createdAt": "2020-08-19T22:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc1MTIxNw=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\nindex 871d8f77f..79c3d6240 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n\n@@ -66,434 +68,472 @@ import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentat\n  */\n @RunWith(AndroidJUnit4.class)\n public class VideoStreamManagerTests {\n-\tpublic static final String TAG = \"VideoStreamManagerTests\";\n-\tprivate Context mTestContext;\n-\tprivate static boolean touchEventOccured = false;\n-\n-\t// SETUP / HELPERS\n-\n-\t@Before\n-\tpublic void setUp() throws Exception{\n-\t\tmTestContext = getInstrumentation().getContext();\n-\t}\n-\n-\t// TEST CLASSES\n-\n-\tpublic static class TestPresentation extends SdlRemoteDisplay {\n-\t\tView simulatedView = new View(this.getContext());\n-\n-\t\tpublic TestPresentation(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(simulatedView);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean onTouchEvent(@NonNull MotionEvent event) {\n-\t\t\ttouchEventOccured = true;\n-\t\t\treturn super.onTouchEvent(event);\n-\t\t}\n-\t}\n-\n-\t// TESTS\n-\n-\t@Test\n-\tpublic void testInitialization(){\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn(new Version(5,1,0));\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tAnswer<Void> onAddServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tSessionType sessionType = (SessionType) args[0];\n-\t\t\t\tISdlServiceListener sdlServiceListener = (ISdlServiceListener) args[1];\n-\t\t\t\tassertEquals(sessionType, SessionType.NAV);\n-\t\t\t\tassertNotNull(sdlServiceListener);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddServiceListener).when(internalInterface).addServiceListener(any(SessionType.class), any(ISdlServiceListener.class));\n-\n-\t\tVideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tassertTrue(success);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Test\n-\tpublic void testHMILevelNotFull(){\n-\t\tfinal ISdl internalInterface = mock(ISdl.class);\n-\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn((new Version(5,0,0)));\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\twhen(internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n-\n-\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tboolean encrypted = false;\n-\t\t\t\tvideoStreamManager.startStreaming(params, encrypted);\n-\t\t\t\tverify(internalInterface, times(0)).startVideoService(params, encrypted);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Test\n-\tpublic void testRemoteDisplayStream(){\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tfinal Set<Object> listenerSet = new HashSet<>();\n-\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn(new Version(5,0,0));\n-\t\twhen(internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n-\n-\t\tAnswer<Void> onGetCapability = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tOnSystemCapabilityListener systemCapabilityListener = (OnSystemCapabilityListener) args[1];\n-\t\t\t\tsystemCapabilityListener.onCapabilityRetrieved(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onGetCapability).when(internalInterface).getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class));\n-\n-\t\tAnswer<Void> onAddServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddServiceListener).when(internalInterface).addServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n-\n-\t\tfinal OnRPCNotificationListener[] hmiListener = {null};\n-\n-\t\tAnswer<Void> onAddHMIListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\thmiListener[0] = (OnRPCNotificationListener) args[1];\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onAddTouchListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddTouchListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onRemoveRPCNotificationListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.remove(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n-\t\tdoAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onRemoveServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.remove(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onRemoveServiceListener).when(internalInterface).removeServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n-\n-\t\twhen(internalInterface.startVideoStream(anyBoolean(), any(VideoStreamingParameters.class))).thenReturn(new IVideoStreamListener() {\n-\t\t\t@Override\n-\t\t\tpublic void sendFrame(byte[] data, int offset, int length, long presentationTimeUs) throws ArrayIndexOutOfBoundsException {}\n-\t\t\t@Override\n-\t\t\tpublic void sendFrame(ByteBuffer data, long presentationTimeUs) {}\n-\t\t});\n-\n-\t\twhen(internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\n-\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tassertTrue(success);\n-\t\t\t\tassertTrue(listenerSet.size() == 3);\n-\n-\t\t\t\tOnHMIStatus fullNotification = new OnHMIStatus();\n-\t\t\t\tfullNotification.setHmiLevel(HMILevel.HMI_FULL);\n-\t\t\t\thmiListener[0].onNotified(fullNotification);\n-\n-\t\t\t\tvideoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n-\n-\t\t\t\t//assertTrue(touchEventOccured);\n-\n-\t\t\t\tvideoStreamManager.dispose();\n-\t\t\t\tassertTrue(listenerSet.isEmpty());\n-\t\t\t}\n-\t\t});\n-\n-\t}\n-\n-\t@Test\n-\tpublic void testConvertTouchEvent() {\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tVideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tList<MotionEvent> motionEventList;\n-\t\tlong e1TS = 1558124390L, e2TS = 1558125390L, e3TS = 1558126390L;\n-\t\tint e1x = 50, e1y = 100, e2x = 150, e2y = 200, e3x = 250, e3y = 300;\n-\t\tint e1Id = 100, e2Id = 101, e3Id = 102;\n-\t\tint movingStep = 10;\n-\t\tOnTouchEvent testOnTouchEvent;\n-\t\tMotionEvent motionEvent;\n-\t\tTouchEvent touchEvent1 = new TouchEvent(e1Id, Collections.singletonList(e1TS), Collections.singletonList(new TouchCoord(e1x, e1y)));\n-\t\tTouchEvent touchEvent2 = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x, e2y)));\n-\t\tTouchEvent touchEvent2AfterMovingPointer = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x + movingStep, e2y + movingStep)));\n-\t\tTouchEvent touchEvent3 = new TouchEvent(e3Id, Collections.singletonList(e3TS), Collections.singletonList(new TouchCoord(e3x, e3y)));\n-\n-\n-\n-\t\t/////////////////////////////////////////////////// First OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+    public static final String TAG = \"VideoStreamManagerTests\";\n+    private Context mTestContext;\n+    private static boolean touchEventOccured = false;\n+    private static boolean viewResizedCalled = false;\n \n+    // SETUP / HELPERS\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n-\n+    @Before\n+    public void setUp() throws Exception {\n+        mTestContext = getInstrumentation().getContext();\n+    }\n \n-\t\t// Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(1);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    // TEST CLASSES\n \n+    public static class TestPresentation extends SdlRemoteDisplay {\n+        View simulatedView = new View(this.getContext());\n \n+        public TestPresentation(Context context, Display display) {\n+            super(context, display);\n+        }\n \n-\t\t/////////////////////////////////////////////////// Second OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        @Override\n+        protected void onCreate(Bundle savedInstanceState) {\n+            super.onCreate(savedInstanceState);\n+            setContentView(simulatedView);\n+        }\n \n+        @Override\n+        public void onViewResized(int width, int height) {\n+            viewResizedCalled = true;\n+        }\n \n-\t\t// First MotionEvent should be ACTION_POINTER_DOWN and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        @Override\n+        public boolean onTouchEvent(@NonNull MotionEvent event) {\n+            touchEventOccured = true;\n+            return super.onTouchEvent(event);\n+        }\n+    }\n \n+    // TESTS\n \n+    @Test\n+    public void testInitialization() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getProtocolVersion()).thenReturn(new Version(5, 1, 0));\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        Answer<Void> onAddServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                SessionType sessionType = (SessionType) args[0];\n+                ISdlServiceListener sdlServiceListener = (ISdlServiceListener) args[1];\n+                assertEquals(sessionType, SessionType.NAV);\n+                assertNotNull(sdlServiceListener);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddServiceListener).when(internalInterface).addServiceListener(any(SessionType.class), any(ISdlServiceListener.class));\n \n-\t\t/////////////////////////////////////////////////// Third OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.MOVE, Arrays.asList(touchEvent2AfterMovingPointer));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+            }\n+        });\n+    }\n \n+    @Test\n+    public void testHMILevelNotFull() {\n+        final ISdl internalInterface = mock(ISdl.class);\n+\n+        SystemCapabilityManager systemCapabilityManager = mock(SystemCapabilityManager.class);\n+        doReturn(systemCapabilityManager).when(internalInterface).getSystemCapabilityManager();\n+\n+        when(internalInterface.getProtocolVersion()).thenReturn((new Version(5, 0, 0)));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        when(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                boolean encrypted = false;\n+                videoStreamManager.startStreaming(params, encrypted);\n+                verify(internalInterface, times(0)).startVideoService(params, encrypted, false);\n+            }\n+        });\n+    }\n \n-\t\t// First MotionEvent should be ACTION_MOVE and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_MOVE, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    @Test\n+    public void testRemoteDisplayStream() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        final Set<Object> listenerSet = new HashSet<>();\n+\n+        when(internalInterface.getProtocolVersion()).thenReturn(new Version(5, 0, 0));\n+\n+        SystemCapabilityManager systemCapabilityManager = mock(SystemCapabilityManager.class);\n+        doReturn(systemCapabilityManager).when(internalInterface).getSystemCapabilityManager();\n+        when(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n+\n+        Answer<Void> onGetCapability = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnSystemCapabilityListener systemCapabilityListener = (OnSystemCapabilityListener) args[1];\n+                systemCapabilityListener.onCapabilityRetrieved(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onGetCapability).when(systemCapabilityManager).getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class), anyBoolean());\n+\n+        Answer<Void> onAddServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddServiceListener).when(internalInterface).addServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n+\n+        final OnRPCNotificationListener[] hmiListener = {null};\n+\n+        Answer<Void> onAddHMIListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                hmiListener[0] = (OnRPCNotificationListener) args[1];\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onAddTouchListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddTouchListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onRemoveRPCNotificationListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.remove(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+        doAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onRemoveServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.remove(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onRemoveServiceListener).when(internalInterface).removeServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n+\n+        when(systemCapabilityManager.getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class), anyBoolean())).thenReturn(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+                assertTrue(listenerSet.size() == 3);\n+\n+                OnHMIStatus fullNotification = new OnHMIStatus();\n+                fullNotification.setHmiLevel(HMILevel.HMI_FULL);\n+                hmiListener[0].onNotified(fullNotification);\n+\n+                videoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n+                assertTrue(touchEventOccured);\n+                videoStreamManager.dispose();\n+                assertTrue(listenerSet.isEmpty());\n+            }\n+        });\n \n+    }\n \n+    @Test\n+    public void testOnViewResized() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        final OnRPCNotificationListener[] hmiListener = {null};\n+\n+        Answer<Void> onAddHMIListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                hmiListener[0] = (OnRPCNotificationListener) args[1];\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+                OnHMIStatus fullNotification = new OnHMIStatus();\n+                fullNotification.setHmiLevel(HMILevel.HMI_FULL);\n+                hmiListener[0].onNotified(fullNotification);\n+\n+                videoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n+\n+                Field sdlRemoteDisplayField = null;\n+                try {\n+                    sdlRemoteDisplayField =\n+                            VideoStreamManager.class.getDeclaredField(\"sdlRemoteDisplay\");\n+                } catch (NoSuchFieldException e) { e.printStackTrace(); }\n+                sdlRemoteDisplayField.setAccessible(true);\n+\n+                SdlRemoteDisplay display = null;\n+                try {\n+                    display = (SdlRemoteDisplay) sdlRemoteDisplayField.get(videoStreamManager);\n+                } catch (IllegalAccessException e) { e.printStackTrace(); }\n+                display.onViewResized(100, 100);\n+\n+                assertTrue(viewResizedCalled);\n+            }\n+        });\n+    }\n \n-\t\t/////////////////////////////////////////////////// Fourth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent2AfterMovingPointer));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+    @Test\n+    public void testConvertTouchEvent() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n \n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n \n-\t\t// First MotionEvent should be ACTION_POINTER_UP and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        List<MotionEvent> motionEventList;\n+        long e1TS = 1558124390L, e2TS = 1558125390L, e3TS = 1558126390L;\n+        int e1x = 50, e1y = 100, e2x = 150, e2y = 200, e3x = 250, e3y = 300;\n+        int e1Id = 100, e2Id = 101, e3Id = 102;\n+        int movingStep = 10;\n+        OnTouchEvent testOnTouchEvent;\n+        MotionEvent motionEvent;\n+        TouchEvent touchEvent1 = new TouchEvent(e1Id, Collections.singletonList(e1TS), Collections.singletonList(new TouchCoord(e1x, e1y)));\n+        TouchEvent touchEvent2 = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x, e2y)));\n+        TouchEvent touchEvent2AfterMovingPointer = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x + movingStep, e2y + movingStep)));\n+        TouchEvent touchEvent3 = new TouchEvent(e3Id, Collections.singletonList(e3TS), Collections.singletonList(new TouchCoord(e3x, e3y)));\n \n \n+        /////////////////////////////////////////////////// First OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t/////////////////////////////////////////////////// Fifth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n \n-\t\t// First MotionEvent should be ACTION_POINTER_UP and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        // Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n+        motionEvent = motionEventList.get(1);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t/////////////////////////////////////////////////// Sixth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        /////////////////////////////////////////////////// Second OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t// First MotionEvent should be ACTION_UP and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        // First MotionEvent should be ACTION_POINTER_DOWN and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Third OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.MOVE, Arrays.asList(touchEvent2AfterMovingPointer));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n+        // First MotionEvent should be ACTION_MOVE and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_MOVE, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Fourth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent2AfterMovingPointer));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t/////////////////////////////////////////////////// Seventh OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        // First MotionEvent should be ACTION_POINTER_UP and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Fifth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n \n+        // First MotionEvent should be ACTION_POINTER_UP and have 2 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n-\t\t// Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(1);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        /////////////////////////////////////////////////// Sixth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t/////////////////////////////////////////////////// Eighth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.CANCEL, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        // First MotionEvent should be ACTION_UP and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t// First MotionEvent should be ACTION_CANCEL and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_CANCEL, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        /////////////////////////////////////////////////// Seventh OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+\n+\n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n+\n+\n+        // Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n+        motionEvent = motionEventList.get(1);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Eighth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.CANCEL, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n+        // First MotionEvent should be ACTION_CANCEL and have 2 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_CANCEL, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n-\t\t/////////////////////////////////////////////////// Ninth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        /////////////////////////////////////////////////// Ninth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t/////////////////////////////////////////////////// Tenth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent1));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        /////////////////////////////////////////////////// Tenth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent1));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t// First MotionEvent should be ACTION_UP and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-\t}\n+        // First MotionEvent should be ACTION_UP and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    }\n \n-\t@Test\n+    @Test\n     public void testConvertTouchEvent_Scale_1() {\n         assertMotionEventWithScale(800, 480, 1.0f);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc3OTc3Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472779776", "bodyText": "This method updateCachedVideoStreamingCapabilities(...)  on line 234 is never used.  Can it be deleted?", "author": "santhanamk", "createdAt": "2020-08-19T06:59:24Z", "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java", "diffHunk": "@@ -228,6 +231,9 @@ private void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabi\n \t\tupdateDeprecatedDisplayCapabilities();\n \t}\n \n+\tprivate void updateCachedVideoStreamingCapabilities(VideoStreamingCapability capability) {", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\nindex 1c569e082..c94f7193c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n\n@@ -79,201 +74,198 @@ import java.util.ListIterator;\n import java.util.concurrent.CopyOnWriteArrayList;\n \n abstract class BaseSystemCapabilityManager {\n-\tprivate static final String TAG = \"SystemCapabilityManager\";\n-\tprivate final HashMap<SystemCapabilityType, Object> cachedSystemCapabilities;\n-\tprivate final HashMap<SystemCapabilityType, Boolean> systemCapabilitiesSubscriptionStatus;\n-\tprivate final HashMap<SystemCapabilityType, CopyOnWriteArrayList<OnSystemCapabilityListener>> onSystemCapabilityListeners;\n-\tprivate final Object LISTENER_LOCK;\n-\tprivate final ISdl callback;\n-\tprivate OnRPCListener rpcListener;\n-\tprivate boolean shouldConvertDeprecatedDisplayCapabilities;\n-\tprivate HMILevel currentHMILevel;\n-\n-\tBaseSystemCapabilityManager(ISdl callback) {\n-\t\tthis.callback = callback;\n-\t\tthis.LISTENER_LOCK = new Object();\n-\t\tthis.onSystemCapabilityListeners = new HashMap<>();\n-\t\tthis.cachedSystemCapabilities = new HashMap<>();\n-\t\tthis.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n-\t\tthis.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n-\t\tthis.shouldConvertDeprecatedDisplayCapabilities = true;\n-\t\tthis.currentHMILevel = HMILevel.HMI_NONE;\n-\n-\t\tsetupRpcListeners();\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(RegisterAppInterfaceResponse rpc) {\n-\t\treturn createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(SetDisplayLayoutResponse rpc) {\n-\t\treturn createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n-\t\t// Based on deprecated Display capabilities we don't know if widgets are supported,\n-\t\t// The Default MAIN window is the only window we know is supported\n-\t\tWindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n-\n-\t\tDisplayCapability displayCapability = new DisplayCapability();\n-\t\tif (display != null) {\n-\t\t\tif (display.getDisplayName() != null) {\n-\t\t\t\tdisplayCapability.setDisplayName(display.getDisplayName());\n-\t\t\t} else if (display.getDisplayType() != null) {\n-\t\t\t\tdisplayCapability.setDisplayName(display.getDisplayType().toString());\n-\t\t\t}\n-\t\t}\n-\t\tdisplayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n-\n-\t\t// Create a window capability object for the default MAIN window\n-\t\tWindowCapability defaultWindowCapability = new WindowCapability();\n-\t\tdefaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t\tdefaultWindowCapability.setButtonCapabilities(button);\n-\t\tdefaultWindowCapability.setSoftButtonCapabilities(softButton);\n-\n-\t\t// return if display capabilities don't exist.\n-\t\tif (display == null) {\n-\t\t\tdefaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n-\t\t\tdefaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n-\t\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\t\treturn Collections.singletonList(displayCapability);\n-\t\t}\n-\n-\t\t// copy all available display capabilities\n-\t\tdefaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n-\t\tdefaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n-\t\tdefaultWindowCapability.setTextFields(display.getTextFields());\n-\t\tdefaultWindowCapability.setImageFields(display.getImageFields());\n-\t\tArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n-\t\timageTypeSupported.add(ImageType.STATIC); // static images expected to always work on any head unit\n-\t\tif (display.getGraphicSupported()) {\n-\t\t\timageTypeSupported.add(ImageType.DYNAMIC);\n-\t\t}\n-\t\tdefaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n-\n-\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\treturn Collections.singletonList(displayCapability);\n-\t}\n-\n-\tprivate DisplayCapabilities createDeprecatedDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n-\t\tDisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n-\t\tconvertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n-\t\tconvertedCapabilities.setDisplayName(displayName);\n-\t\tconvertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n-\t\tconvertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n-\t\tconvertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n-\t\tconvertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n-\t\tconvertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but allows empty array\n-\t\t// if there are imageTypes in the response, we must assume graphics are supported\n-\t\tconvertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported() != null && defaultMainWindow.getImageTypeSupported().size() > 0);\n-\n-\t\treturn convertedCapabilities;\n-\t}\n-\n-\tprivate void updateDeprecatedDisplayCapabilities() {\n-\t\tWindowCapability defaultMainWindowCapabilities = getDefaultMainWindowCapability();\n-\t\tList<DisplayCapability> displayCapabilityList = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\n-\t\tif (defaultMainWindowCapabilities == null || displayCapabilityList == null || displayCapabilityList.size() == 0) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// cover the deprecated capabilities for backward compatibility\n-\t\tsetCapability(SystemCapabilityType.DISPLAY, createDeprecatedDisplayCapabilities(displayCapabilityList.get(0).getDisplayName(), defaultMainWindowCapabilities));\n-\t\tsetCapability(SystemCapabilityType.BUTTON, defaultMainWindowCapabilities.getButtonCapabilities());\n-\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, defaultMainWindowCapabilities.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabilities) {\n-\t\tif (newCapabilities == null || newCapabilities.size() == 0) {\n-\t\t\tDebugTool.logWarning(TAG, \"Received invalid display capability list\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tList<DisplayCapability> oldCapabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\n-\t\tif (oldCapabilities == null || oldCapabilities.size() == 0) {\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, newCapabilities);\n-\t\t\tupdateDeprecatedDisplayCapabilities();\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tDisplayCapability oldDefaultDisplayCapabilities = oldCapabilities.get(0);\n-\t\tArrayList<WindowCapability> copyWindowCapabilities = new ArrayList<>(oldDefaultDisplayCapabilities.getWindowCapabilities());\n-\n-\t\tDisplayCapability newDefaultDisplayCapabilities = newCapabilities.get(0);\n-\t\tList<WindowCapability> newWindowCapabilities = newDefaultDisplayCapabilities.getWindowCapabilities();\n-\n-\t\tif (newWindowCapabilities != null && !newWindowCapabilities.isEmpty()) {\n-\t\t\tfor (WindowCapability newWindow : newWindowCapabilities) {\n-\t\t\t\tListIterator<WindowCapability> iterator = copyWindowCapabilities.listIterator();\n-\t\t\t\tboolean oldFound = false;\n-\t\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\t\tWindowCapability oldWindow = iterator.next();\n-\t\t\t\t\tint newWindowID = newWindow.getWindowID() != null ? newWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\tint oldWindowID = oldWindow.getWindowID() != null ? oldWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\tif (newWindowID == oldWindowID) {\n-\t\t\t\t\t\titerator.set(newWindow); // replace the old window caps with new ones\n-\t\t\t\t\t\toldFound = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (!oldFound) {\n-\t\t\t\t\tcopyWindowCapabilities.add(newWindow); // this is a new unknown window\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// replace the window capabilities array with the merged one.\n-\t\tnewDefaultDisplayCapabilities.setWindowCapabilities(copyWindowCapabilities);\n-\t\tsetCapability(SystemCapabilityType.DISPLAYS, Collections.singletonList(newDefaultDisplayCapabilities));\n-\t\tupdateDeprecatedDisplayCapabilities();\n-\t}\n-\n-\tprivate void updateCachedVideoStreamingCapabilities(VideoStreamingCapability capability) {\n-\t\tsetCapability(SystemCapabilityType.VIDEO_STREAMING, capability);\n-\t}\n-\n-\tpublic WindowCapability getWindowCapability(int windowID) {\n-\t\tList<DisplayCapability> capabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tDisplayCapability display = capabilities.get(0);\n-\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t    int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\tif (currentWindowID == windowID) {\n-\t\t\t\treturn windowCapability;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tpublic WindowCapability getDefaultMainWindowCapability() {\n-\t\treturn getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t}\n-\n-\tvoid parseRAIResponse(RegisterAppInterfaceResponse response) {\n-\t\tif (response != null && response.getSuccess()) {\n-\t\t\tthis.shouldConvertDeprecatedDisplayCapabilities = true; // reset the flag\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n-\t\t\tsetCapability(SystemCapabilityType.HMI, response.getHmiCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, response.getAudioPassThruCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PCM_STREAMING, response.getPcmStreamingCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.HMI_ZONE, response.getHmiZoneCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.SPEECH, response.getSpeechCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.VOICE_RECOGNITION, response.getVrCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PRERECORDED_SPEECH, response.getPrerecordedSpeech());\n-\t\t}\n-\t}\n+    private static final String TAG = \"SystemCapabilityManager\";\n+    private final HashMap<SystemCapabilityType, Object> cachedSystemCapabilities;\n+    private final HashMap<SystemCapabilityType, Boolean> systemCapabilitiesSubscriptionStatus;\n+    private final HashMap<SystemCapabilityType, CopyOnWriteArrayList<OnSystemCapabilityListener>> onSystemCapabilityListeners;\n+    private final Object LISTENER_LOCK;\n+    private final ISdl callback;\n+    private boolean shouldConvertDeprecatedDisplayCapabilities;\n+    private HMILevel currentHMILevel;\n+\n+    BaseSystemCapabilityManager(ISdl callback) {\n+        this.callback = callback;\n+        this.LISTENER_LOCK = new Object();\n+        this.onSystemCapabilityListeners = new HashMap<>();\n+        this.cachedSystemCapabilities = new HashMap<>();\n+        this.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.VIDEO_STREAMING, true);\n+        this.shouldConvertDeprecatedDisplayCapabilities = true;\n+        this.currentHMILevel = HMILevel.HMI_NONE;\n+\n+        setupRpcListeners();\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(RegisterAppInterfaceResponse rpc) {\n+        return createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(SetDisplayLayoutResponse rpc) {\n+        return createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n+        // Based on deprecated Display capabilities we don't know if widgets are supported,\n+        // The Default MAIN window is the only window we know is supported\n+        WindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n+\n+        DisplayCapability displayCapability = new DisplayCapability();\n+        if (display != null) {\n+            if (display.getDisplayName() != null) {\n+                displayCapability.setDisplayName(display.getDisplayName());\n+            } else if (display.getDisplayType() != null) {\n+                displayCapability.setDisplayName(display.getDisplayType().toString());\n+            }\n+        }\n+        displayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n+\n+        // Create a window capability object for the default MAIN window\n+        WindowCapability defaultWindowCapability = new WindowCapability();\n+        defaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+        defaultWindowCapability.setButtonCapabilities(button);\n+        defaultWindowCapability.setSoftButtonCapabilities(softButton);\n+\n+        // return if display capabilities don't exist.\n+        if (display == null) {\n+            defaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n+            defaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n+            displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+            return Collections.singletonList(displayCapability);\n+        }\n+\n+        // copy all available display capabilities\n+        defaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n+        defaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n+        defaultWindowCapability.setTextFields(display.getTextFields());\n+        defaultWindowCapability.setImageFields(display.getImageFields());\n+        ArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n+        imageTypeSupported.add(ImageType.STATIC); // static images expected to always work on any head unit\n+        if (display.getGraphicSupported()) {\n+            imageTypeSupported.add(ImageType.DYNAMIC);\n+        }\n+        defaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n+\n+        displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+        return Collections.singletonList(displayCapability);\n+    }\n+\n+    private DisplayCapabilities createDeprecatedDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n+        DisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n+        convertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n+        convertedCapabilities.setDisplayName(displayName);\n+        convertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n+        convertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n+        convertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n+        convertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n+        convertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but allows empty array\n+        // if there are imageTypes in the response, we must assume graphics are supported\n+        convertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported() != null && defaultMainWindow.getImageTypeSupported().size() > 0);\n+\n+        return convertedCapabilities;\n+    }\n+\n+    private void updateDeprecatedDisplayCapabilities() {\n+        WindowCapability defaultMainWindowCapabilities = getDefaultMainWindowCapability();\n+        List<DisplayCapability> displayCapabilityList = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+\n+        if (defaultMainWindowCapabilities == null || displayCapabilityList == null || displayCapabilityList.size() == 0) {\n+            return;\n+        }\n+\n+        // cover the deprecated capabilities for backward compatibility\n+        setCapability(SystemCapabilityType.DISPLAY, createDeprecatedDisplayCapabilities(displayCapabilityList.get(0).getDisplayName(), defaultMainWindowCapabilities));\n+        setCapability(SystemCapabilityType.BUTTON, defaultMainWindowCapabilities.getButtonCapabilities());\n+        setCapability(SystemCapabilityType.SOFTBUTTON, defaultMainWindowCapabilities.getSoftButtonCapabilities());\n+    }\n+\n+    private void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabilities) {\n+        if (newCapabilities == null || newCapabilities.size() == 0) {\n+            DebugTool.logWarning(TAG, \"Received invalid display capability list\");\n+            return;\n+        }\n+\n+        List<DisplayCapability> oldCapabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+\n+        if (oldCapabilities == null || oldCapabilities.size() == 0) {\n+            setCapability(SystemCapabilityType.DISPLAYS, newCapabilities);\n+            updateDeprecatedDisplayCapabilities();\n+            return;\n+        }\n+\n+        DisplayCapability oldDefaultDisplayCapabilities = oldCapabilities.get(0);\n+        ArrayList<WindowCapability> copyWindowCapabilities = new ArrayList<>(oldDefaultDisplayCapabilities.getWindowCapabilities());\n+\n+        DisplayCapability newDefaultDisplayCapabilities = newCapabilities.get(0);\n+        List<WindowCapability> newWindowCapabilities = newDefaultDisplayCapabilities.getWindowCapabilities();\n+\n+        if (newWindowCapabilities != null && !newWindowCapabilities.isEmpty()) {\n+            for (WindowCapability newWindow : newWindowCapabilities) {\n+                ListIterator<WindowCapability> iterator = copyWindowCapabilities.listIterator();\n+                boolean oldFound = false;\n+                while (iterator.hasNext()) {\n+                    WindowCapability oldWindow = iterator.next();\n+                    int newWindowID = newWindow.getWindowID() != null ? newWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                    int oldWindowID = oldWindow.getWindowID() != null ? oldWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                    if (newWindowID == oldWindowID) {\n+                        iterator.set(newWindow); // replace the old window caps with new ones\n+                        oldFound = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!oldFound) {\n+                    copyWindowCapabilities.add(newWindow); // this is a new unknown window\n+                }\n+            }\n+        }\n+\n+        // replace the window capabilities array with the merged one.\n+        newDefaultDisplayCapabilities.setWindowCapabilities(copyWindowCapabilities);\n+        setCapability(SystemCapabilityType.DISPLAYS, Collections.singletonList(newDefaultDisplayCapabilities));\n+        updateDeprecatedDisplayCapabilities();\n+    }\n+\n+\n+    public WindowCapability getWindowCapability(int windowID) {\n+        List<DisplayCapability> capabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+        if (capabilities == null || capabilities.size() == 0) {\n+            return null;\n+        }\n+        DisplayCapability display = capabilities.get(0);\n+        for (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+            int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+            if (currentWindowID == windowID) {\n+                return windowCapability;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public WindowCapability getDefaultMainWindowCapability() {\n+        return getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+    }\n+\n+    void parseRAIResponse(RegisterAppInterfaceResponse response) {\n+        if (response != null && response.getSuccess()) {\n+            this.shouldConvertDeprecatedDisplayCapabilities = true; // reset the flag\n+            setCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n+            setCapability(SystemCapabilityType.HMI, response.getHmiCapabilities());\n+            setCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n+            setCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, response.getAudioPassThruCapabilities());\n+            setCapability(SystemCapabilityType.PCM_STREAMING, response.getPcmStreamingCapabilities());\n+            setCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n+            setCapability(SystemCapabilityType.HMI_ZONE, response.getHmiZoneCapabilities());\n+            setCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n+            setCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n+            setCapability(SystemCapabilityType.SPEECH, response.getSpeechCapabilities());\n+            setCapability(SystemCapabilityType.VOICE_RECOGNITION, response.getVrCapabilities());\n+            setCapability(SystemCapabilityType.PRERECORDED_SPEECH, response.getPrerecordedSpeech());\n+        }\n+    }\n \n     private void setupRpcListeners() {\n-        rpcListener = new OnRPCListener() {\n+        OnRPCListener rpcListener = new OnRPCListener() {\n             @Override\n             public void onReceived(RPCMessage message) {\n                 if (message != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc4NDM4Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472784386", "bodyText": "The alignment of private void setupRpcListeners() was altered .  It (and all of its code) needs to be on the same level as the function above it (parseRAIResponse(...)).", "author": "santhanamk", "createdAt": "2020-08-19T07:05:23Z", "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java", "diffHunk": "@@ -266,81 +272,90 @@ void parseRAIResponse(RegisterAppInterfaceResponse response) {\n \t\t}\n \t}\n \n-\tprivate void setupRpcListeners() {", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3Mzc3OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473373779", "bodyText": "The alignment of private void setupRpcListeners() was altered . It (and all of its code) needs to be on the same level as the function above it (parseRAIResponse(...)).\n\n@kostyaBoss I still see this issue.  The alignment of private void setupRpcListeners() is still a little bit off. It (and all of its code) needs to be on the same level as the function above it (parseRAIResponse(...)).", "author": "santhanamk", "createdAt": "2020-08-19T22:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc4NDM4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\nindex 1c569e082..c94f7193c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n\n@@ -79,201 +74,198 @@ import java.util.ListIterator;\n import java.util.concurrent.CopyOnWriteArrayList;\n \n abstract class BaseSystemCapabilityManager {\n-\tprivate static final String TAG = \"SystemCapabilityManager\";\n-\tprivate final HashMap<SystemCapabilityType, Object> cachedSystemCapabilities;\n-\tprivate final HashMap<SystemCapabilityType, Boolean> systemCapabilitiesSubscriptionStatus;\n-\tprivate final HashMap<SystemCapabilityType, CopyOnWriteArrayList<OnSystemCapabilityListener>> onSystemCapabilityListeners;\n-\tprivate final Object LISTENER_LOCK;\n-\tprivate final ISdl callback;\n-\tprivate OnRPCListener rpcListener;\n-\tprivate boolean shouldConvertDeprecatedDisplayCapabilities;\n-\tprivate HMILevel currentHMILevel;\n-\n-\tBaseSystemCapabilityManager(ISdl callback) {\n-\t\tthis.callback = callback;\n-\t\tthis.LISTENER_LOCK = new Object();\n-\t\tthis.onSystemCapabilityListeners = new HashMap<>();\n-\t\tthis.cachedSystemCapabilities = new HashMap<>();\n-\t\tthis.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n-\t\tthis.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n-\t\tthis.shouldConvertDeprecatedDisplayCapabilities = true;\n-\t\tthis.currentHMILevel = HMILevel.HMI_NONE;\n-\n-\t\tsetupRpcListeners();\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(RegisterAppInterfaceResponse rpc) {\n-\t\treturn createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(SetDisplayLayoutResponse rpc) {\n-\t\treturn createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n-\t\t// Based on deprecated Display capabilities we don't know if widgets are supported,\n-\t\t// The Default MAIN window is the only window we know is supported\n-\t\tWindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n-\n-\t\tDisplayCapability displayCapability = new DisplayCapability();\n-\t\tif (display != null) {\n-\t\t\tif (display.getDisplayName() != null) {\n-\t\t\t\tdisplayCapability.setDisplayName(display.getDisplayName());\n-\t\t\t} else if (display.getDisplayType() != null) {\n-\t\t\t\tdisplayCapability.setDisplayName(display.getDisplayType().toString());\n-\t\t\t}\n-\t\t}\n-\t\tdisplayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n-\n-\t\t// Create a window capability object for the default MAIN window\n-\t\tWindowCapability defaultWindowCapability = new WindowCapability();\n-\t\tdefaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t\tdefaultWindowCapability.setButtonCapabilities(button);\n-\t\tdefaultWindowCapability.setSoftButtonCapabilities(softButton);\n-\n-\t\t// return if display capabilities don't exist.\n-\t\tif (display == null) {\n-\t\t\tdefaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n-\t\t\tdefaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n-\t\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\t\treturn Collections.singletonList(displayCapability);\n-\t\t}\n-\n-\t\t// copy all available display capabilities\n-\t\tdefaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n-\t\tdefaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n-\t\tdefaultWindowCapability.setTextFields(display.getTextFields());\n-\t\tdefaultWindowCapability.setImageFields(display.getImageFields());\n-\t\tArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n-\t\timageTypeSupported.add(ImageType.STATIC); // static images expected to always work on any head unit\n-\t\tif (display.getGraphicSupported()) {\n-\t\t\timageTypeSupported.add(ImageType.DYNAMIC);\n-\t\t}\n-\t\tdefaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n-\n-\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\treturn Collections.singletonList(displayCapability);\n-\t}\n-\n-\tprivate DisplayCapabilities createDeprecatedDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n-\t\tDisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n-\t\tconvertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n-\t\tconvertedCapabilities.setDisplayName(displayName);\n-\t\tconvertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n-\t\tconvertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n-\t\tconvertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n-\t\tconvertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n-\t\tconvertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but allows empty array\n-\t\t// if there are imageTypes in the response, we must assume graphics are supported\n-\t\tconvertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported() != null && defaultMainWindow.getImageTypeSupported().size() > 0);\n-\n-\t\treturn convertedCapabilities;\n-\t}\n-\n-\tprivate void updateDeprecatedDisplayCapabilities() {\n-\t\tWindowCapability defaultMainWindowCapabilities = getDefaultMainWindowCapability();\n-\t\tList<DisplayCapability> displayCapabilityList = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\n-\t\tif (defaultMainWindowCapabilities == null || displayCapabilityList == null || displayCapabilityList.size() == 0) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// cover the deprecated capabilities for backward compatibility\n-\t\tsetCapability(SystemCapabilityType.DISPLAY, createDeprecatedDisplayCapabilities(displayCapabilityList.get(0).getDisplayName(), defaultMainWindowCapabilities));\n-\t\tsetCapability(SystemCapabilityType.BUTTON, defaultMainWindowCapabilities.getButtonCapabilities());\n-\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, defaultMainWindowCapabilities.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabilities) {\n-\t\tif (newCapabilities == null || newCapabilities.size() == 0) {\n-\t\t\tDebugTool.logWarning(TAG, \"Received invalid display capability list\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tList<DisplayCapability> oldCapabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\n-\t\tif (oldCapabilities == null || oldCapabilities.size() == 0) {\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, newCapabilities);\n-\t\t\tupdateDeprecatedDisplayCapabilities();\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tDisplayCapability oldDefaultDisplayCapabilities = oldCapabilities.get(0);\n-\t\tArrayList<WindowCapability> copyWindowCapabilities = new ArrayList<>(oldDefaultDisplayCapabilities.getWindowCapabilities());\n-\n-\t\tDisplayCapability newDefaultDisplayCapabilities = newCapabilities.get(0);\n-\t\tList<WindowCapability> newWindowCapabilities = newDefaultDisplayCapabilities.getWindowCapabilities();\n-\n-\t\tif (newWindowCapabilities != null && !newWindowCapabilities.isEmpty()) {\n-\t\t\tfor (WindowCapability newWindow : newWindowCapabilities) {\n-\t\t\t\tListIterator<WindowCapability> iterator = copyWindowCapabilities.listIterator();\n-\t\t\t\tboolean oldFound = false;\n-\t\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\t\tWindowCapability oldWindow = iterator.next();\n-\t\t\t\t\tint newWindowID = newWindow.getWindowID() != null ? newWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\tint oldWindowID = oldWindow.getWindowID() != null ? oldWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\tif (newWindowID == oldWindowID) {\n-\t\t\t\t\t\titerator.set(newWindow); // replace the old window caps with new ones\n-\t\t\t\t\t\toldFound = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (!oldFound) {\n-\t\t\t\t\tcopyWindowCapabilities.add(newWindow); // this is a new unknown window\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// replace the window capabilities array with the merged one.\n-\t\tnewDefaultDisplayCapabilities.setWindowCapabilities(copyWindowCapabilities);\n-\t\tsetCapability(SystemCapabilityType.DISPLAYS, Collections.singletonList(newDefaultDisplayCapabilities));\n-\t\tupdateDeprecatedDisplayCapabilities();\n-\t}\n-\n-\tprivate void updateCachedVideoStreamingCapabilities(VideoStreamingCapability capability) {\n-\t\tsetCapability(SystemCapabilityType.VIDEO_STREAMING, capability);\n-\t}\n-\n-\tpublic WindowCapability getWindowCapability(int windowID) {\n-\t\tList<DisplayCapability> capabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tDisplayCapability display = capabilities.get(0);\n-\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t    int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\tif (currentWindowID == windowID) {\n-\t\t\t\treturn windowCapability;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tpublic WindowCapability getDefaultMainWindowCapability() {\n-\t\treturn getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t}\n-\n-\tvoid parseRAIResponse(RegisterAppInterfaceResponse response) {\n-\t\tif (response != null && response.getSuccess()) {\n-\t\t\tthis.shouldConvertDeprecatedDisplayCapabilities = true; // reset the flag\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n-\t\t\tsetCapability(SystemCapabilityType.HMI, response.getHmiCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, response.getAudioPassThruCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PCM_STREAMING, response.getPcmStreamingCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.HMI_ZONE, response.getHmiZoneCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.SPEECH, response.getSpeechCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.VOICE_RECOGNITION, response.getVrCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PRERECORDED_SPEECH, response.getPrerecordedSpeech());\n-\t\t}\n-\t}\n+    private static final String TAG = \"SystemCapabilityManager\";\n+    private final HashMap<SystemCapabilityType, Object> cachedSystemCapabilities;\n+    private final HashMap<SystemCapabilityType, Boolean> systemCapabilitiesSubscriptionStatus;\n+    private final HashMap<SystemCapabilityType, CopyOnWriteArrayList<OnSystemCapabilityListener>> onSystemCapabilityListeners;\n+    private final Object LISTENER_LOCK;\n+    private final ISdl callback;\n+    private boolean shouldConvertDeprecatedDisplayCapabilities;\n+    private HMILevel currentHMILevel;\n+\n+    BaseSystemCapabilityManager(ISdl callback) {\n+        this.callback = callback;\n+        this.LISTENER_LOCK = new Object();\n+        this.onSystemCapabilityListeners = new HashMap<>();\n+        this.cachedSystemCapabilities = new HashMap<>();\n+        this.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.VIDEO_STREAMING, true);\n+        this.shouldConvertDeprecatedDisplayCapabilities = true;\n+        this.currentHMILevel = HMILevel.HMI_NONE;\n+\n+        setupRpcListeners();\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(RegisterAppInterfaceResponse rpc) {\n+        return createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(SetDisplayLayoutResponse rpc) {\n+        return createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n+        // Based on deprecated Display capabilities we don't know if widgets are supported,\n+        // The Default MAIN window is the only window we know is supported\n+        WindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n+\n+        DisplayCapability displayCapability = new DisplayCapability();\n+        if (display != null) {\n+            if (display.getDisplayName() != null) {\n+                displayCapability.setDisplayName(display.getDisplayName());\n+            } else if (display.getDisplayType() != null) {\n+                displayCapability.setDisplayName(display.getDisplayType().toString());\n+            }\n+        }\n+        displayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n+\n+        // Create a window capability object for the default MAIN window\n+        WindowCapability defaultWindowCapability = new WindowCapability();\n+        defaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+        defaultWindowCapability.setButtonCapabilities(button);\n+        defaultWindowCapability.setSoftButtonCapabilities(softButton);\n+\n+        // return if display capabilities don't exist.\n+        if (display == null) {\n+            defaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n+            defaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n+            displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+            return Collections.singletonList(displayCapability);\n+        }\n+\n+        // copy all available display capabilities\n+        defaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n+        defaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n+        defaultWindowCapability.setTextFields(display.getTextFields());\n+        defaultWindowCapability.setImageFields(display.getImageFields());\n+        ArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n+        imageTypeSupported.add(ImageType.STATIC); // static images expected to always work on any head unit\n+        if (display.getGraphicSupported()) {\n+            imageTypeSupported.add(ImageType.DYNAMIC);\n+        }\n+        defaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n+\n+        displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+        return Collections.singletonList(displayCapability);\n+    }\n+\n+    private DisplayCapabilities createDeprecatedDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n+        DisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n+        convertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n+        convertedCapabilities.setDisplayName(displayName);\n+        convertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n+        convertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n+        convertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n+        convertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n+        convertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but allows empty array\n+        // if there are imageTypes in the response, we must assume graphics are supported\n+        convertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported() != null && defaultMainWindow.getImageTypeSupported().size() > 0);\n+\n+        return convertedCapabilities;\n+    }\n+\n+    private void updateDeprecatedDisplayCapabilities() {\n+        WindowCapability defaultMainWindowCapabilities = getDefaultMainWindowCapability();\n+        List<DisplayCapability> displayCapabilityList = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+\n+        if (defaultMainWindowCapabilities == null || displayCapabilityList == null || displayCapabilityList.size() == 0) {\n+            return;\n+        }\n+\n+        // cover the deprecated capabilities for backward compatibility\n+        setCapability(SystemCapabilityType.DISPLAY, createDeprecatedDisplayCapabilities(displayCapabilityList.get(0).getDisplayName(), defaultMainWindowCapabilities));\n+        setCapability(SystemCapabilityType.BUTTON, defaultMainWindowCapabilities.getButtonCapabilities());\n+        setCapability(SystemCapabilityType.SOFTBUTTON, defaultMainWindowCapabilities.getSoftButtonCapabilities());\n+    }\n+\n+    private void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabilities) {\n+        if (newCapabilities == null || newCapabilities.size() == 0) {\n+            DebugTool.logWarning(TAG, \"Received invalid display capability list\");\n+            return;\n+        }\n+\n+        List<DisplayCapability> oldCapabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+\n+        if (oldCapabilities == null || oldCapabilities.size() == 0) {\n+            setCapability(SystemCapabilityType.DISPLAYS, newCapabilities);\n+            updateDeprecatedDisplayCapabilities();\n+            return;\n+        }\n+\n+        DisplayCapability oldDefaultDisplayCapabilities = oldCapabilities.get(0);\n+        ArrayList<WindowCapability> copyWindowCapabilities = new ArrayList<>(oldDefaultDisplayCapabilities.getWindowCapabilities());\n+\n+        DisplayCapability newDefaultDisplayCapabilities = newCapabilities.get(0);\n+        List<WindowCapability> newWindowCapabilities = newDefaultDisplayCapabilities.getWindowCapabilities();\n+\n+        if (newWindowCapabilities != null && !newWindowCapabilities.isEmpty()) {\n+            for (WindowCapability newWindow : newWindowCapabilities) {\n+                ListIterator<WindowCapability> iterator = copyWindowCapabilities.listIterator();\n+                boolean oldFound = false;\n+                while (iterator.hasNext()) {\n+                    WindowCapability oldWindow = iterator.next();\n+                    int newWindowID = newWindow.getWindowID() != null ? newWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                    int oldWindowID = oldWindow.getWindowID() != null ? oldWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                    if (newWindowID == oldWindowID) {\n+                        iterator.set(newWindow); // replace the old window caps with new ones\n+                        oldFound = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!oldFound) {\n+                    copyWindowCapabilities.add(newWindow); // this is a new unknown window\n+                }\n+            }\n+        }\n+\n+        // replace the window capabilities array with the merged one.\n+        newDefaultDisplayCapabilities.setWindowCapabilities(copyWindowCapabilities);\n+        setCapability(SystemCapabilityType.DISPLAYS, Collections.singletonList(newDefaultDisplayCapabilities));\n+        updateDeprecatedDisplayCapabilities();\n+    }\n+\n+\n+    public WindowCapability getWindowCapability(int windowID) {\n+        List<DisplayCapability> capabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+        if (capabilities == null || capabilities.size() == 0) {\n+            return null;\n+        }\n+        DisplayCapability display = capabilities.get(0);\n+        for (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+            int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+            if (currentWindowID == windowID) {\n+                return windowCapability;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public WindowCapability getDefaultMainWindowCapability() {\n+        return getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+    }\n+\n+    void parseRAIResponse(RegisterAppInterfaceResponse response) {\n+        if (response != null && response.getSuccess()) {\n+            this.shouldConvertDeprecatedDisplayCapabilities = true; // reset the flag\n+            setCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n+            setCapability(SystemCapabilityType.HMI, response.getHmiCapabilities());\n+            setCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n+            setCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, response.getAudioPassThruCapabilities());\n+            setCapability(SystemCapabilityType.PCM_STREAMING, response.getPcmStreamingCapabilities());\n+            setCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n+            setCapability(SystemCapabilityType.HMI_ZONE, response.getHmiZoneCapabilities());\n+            setCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n+            setCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n+            setCapability(SystemCapabilityType.SPEECH, response.getSpeechCapabilities());\n+            setCapability(SystemCapabilityType.VOICE_RECOGNITION, response.getVrCapabilities());\n+            setCapability(SystemCapabilityType.PRERECORDED_SPEECH, response.getPrerecordedSpeech());\n+        }\n+    }\n \n     private void setupRpcListeners() {\n-        rpcListener = new OnRPCListener() {\n+        OnRPCListener rpcListener = new OnRPCListener() {\n             @Override\n             public void onReceived(RPCMessage message) {\n                 if (message != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc5Mjc0Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472792747", "bodyText": "On line 311, the alignment of case ON_SYSTEM_CAPABILITY_UPDATED was altered . It (and all of its code) needs to be on the same level as the case above it (case ON_HMI_STATUS).", "author": "santhanamk", "createdAt": "2020-08-19T07:15:49Z", "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java", "diffHunk": "@@ -266,81 +272,90 @@ void parseRAIResponse(RegisterAppInterfaceResponse response) {\n \t\t}\n \t}\n \n-\tprivate void setupRpcListeners() {\n-\t\trpcListener = new OnRPCListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onReceived(RPCMessage message) {\n-\t\t\t\tif (message != null) {\n-\t\t\t\t\tif (RPCMessage.KEY_RESPONSE.equals(message.getMessageType())) {\n-\t\t\t\t\t\tswitch (message.getFunctionID()) {\n-\t\t\t\t\t\t\tcase SET_DISPLAY_LAYOUT:\n-\t\t\t\t\t\t\t\tSetDisplayLayoutResponse response = (SetDisplayLayoutResponse) message;\n-\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n-\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n-\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n-\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n-\t\t\t\t\t\t\t\tif (shouldConvertDeprecatedDisplayCapabilities) {\n-\t\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase GET_SYSTEM_CAPABILITY:\n-\t\t\t\t\t\t\t\tGetSystemCapabilityResponse systemCapabilityResponse = (GetSystemCapabilityResponse) message;\n-\t\t\t\t\t\t\t\tSystemCapability systemCapability = systemCapabilityResponse.getSystemCapability();\n-\t\t\t\t\t\t\t\tif (systemCapabilityResponse.getSuccess() && SystemCapabilityType.DISPLAYS.equals(systemCapability.getSystemCapabilityType())) {\n-\t\t\t\t\t\t\t\t\tshouldConvertDeprecatedDisplayCapabilities = false; // Successfully got DISPLAYS data. No conversion needed anymore\n-\t\t\t\t\t\t\t\t\tList<DisplayCapability> newCapabilities = (List<DisplayCapability>) systemCapability.getCapabilityForType(SystemCapabilityType.DISPLAYS);\n-\t\t\t\t\t\t\t\t\tupdateCachedDisplayCapabilityList(newCapabilities);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else if (RPCMessage.KEY_NOTIFICATION.equals(message.getMessageType())) {\n-\t\t\t\t\t\tswitch (message.getFunctionID()) {\n+    private void setupRpcListeners() {\n+        rpcListener = new OnRPCListener() {\n+            @Override\n+            public void onReceived(RPCMessage message) {\n+                if (message != null) {\n+                    if (RPCMessage.KEY_RESPONSE.equals(message.getMessageType())) {\n+                        switch (message.getFunctionID()) {\n+                            case SET_DISPLAY_LAYOUT:\n+                                SetDisplayLayoutResponse response = (SetDisplayLayoutResponse) message;\n+                                setCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n+                                setCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n+                                setCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n+                                setCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n+                                if (shouldConvertDeprecatedDisplayCapabilities) {\n+                                    setCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n+                                }\n+                                break;\n+                            case GET_SYSTEM_CAPABILITY:\n+                                GetSystemCapabilityResponse systemCapabilityResponse = (GetSystemCapabilityResponse) message;\n+                                SystemCapability systemCapability = systemCapabilityResponse.getSystemCapability();\n+                                if (systemCapabilityResponse.getSuccess() && SystemCapabilityType.DISPLAYS.equals(systemCapability.getSystemCapabilityType())) {\n+                                    shouldConvertDeprecatedDisplayCapabilities = false; // Successfully got DISPLAYS data. No conversion needed anymore\n+                                    List<DisplayCapability> newCapabilities = (List<DisplayCapability>) systemCapability.getCapabilityForType(SystemCapabilityType.DISPLAYS);\n+                                    updateCachedDisplayCapabilityList(newCapabilities);\n+                                }\n+                                break;\n+                        }\n+                    } else if (RPCMessage.KEY_NOTIFICATION.equals(message.getMessageType())) {\n+                        switch (message.getFunctionID()) {\n \t\t\t\t\t\t\tcase ON_HMI_STATUS:\n \t\t\t\t\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) message;\n \t\t\t\t\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n \t\t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n \t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase ON_SYSTEM_CAPABILITY_UPDATED:\n-\t\t\t\t\t\t\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = (OnSystemCapabilityUpdated) message;\n-\t\t\t\t\t\t\t\tif (onSystemCapabilityUpdated.getSystemCapability() != null) {\n-\t\t\t\t\t\t\t\t\tSystemCapability systemCapability = onSystemCapabilityUpdated.getSystemCapability();\n-\t\t\t\t\t\t\t\t\tSystemCapabilityType systemCapabilityType = systemCapability.getSystemCapabilityType();\n-\t\t\t\t\t\t\t\t\tObject capability = systemCapability.getCapabilityForType(systemCapabilityType);\n-\t\t\t\t\t\t\t\t\tif (cachedSystemCapabilities.containsKey(systemCapabilityType)) { //The capability already exists\n-\t\t\t\t\t\t\t\t\t\tswitch (systemCapabilityType) {\n-\t\t\t\t\t\t\t\t\t\t\tcase APP_SERVICES:\n-\t\t\t\t\t\t\t\t\t\t\t\t// App services only updates what was changed so we need\n-\t\t\t\t\t\t\t\t\t\t\t\t// to update the capability rather than override it\n-\t\t\t\t\t\t\t\t\t\t\t\tAppServicesCapabilities appServicesCapabilities = (AppServicesCapabilities) capability;\n-\t\t\t\t\t\t\t\t\t\t\t\tif (capability != null) {\n-\t\t\t\t\t\t\t\t\t\t\t\t\tList<AppServiceCapability> appServicesCapabilitiesList = appServicesCapabilities.getAppServices();\n-\t\t\t\t\t\t\t\t\t\t\t\t\tAppServicesCapabilities cachedAppServicesCapabilities = (AppServicesCapabilities) cachedSystemCapabilities.get(systemCapabilityType);\n-\t\t\t\t\t\t\t\t\t\t\t\t\t//Update the cached app services\n-\t\t\t\t\t\t\t\t\t\t\t\t\tif (cachedAppServicesCapabilities != null) {\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tcachedAppServicesCapabilities.updateAppServices(appServicesCapabilitiesList);\n-\t\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\t\t//Set the new capability object to the updated cached capabilities\n-\t\t\t\t\t\t\t\t\t\t\t\t\tcapability = cachedAppServicesCapabilities;\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\t\t\tcase DISPLAYS:\n-\t\t\t\t\t\t\t\t\t\t\t\tshouldConvertDeprecatedDisplayCapabilities = false; // Successfully got DISPLAYS data. No conversion needed anymore\n+                            case ON_SYSTEM_CAPABILITY_UPDATED:", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3NDI5OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473374298", "bodyText": "On line 311, the alignment of case ON_SYSTEM_CAPABILITY_UPDATED was altered . It (and all of its code) needs to be on the same level as the case above it (case ON_HMI_STATUS).\n\n@kostyaBoss I still see the alignment issue with case ON_SYSTEM_CAPABILITY_UPDATED on line 305.  It (and all of its code) needs to be on the same level as the case above it (case ON_HMI_STATUS).", "author": "santhanamk", "createdAt": "2020-08-19T22:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc5Mjc0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\nindex 1c569e082..c94f7193c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n\n@@ -79,201 +74,198 @@ import java.util.ListIterator;\n import java.util.concurrent.CopyOnWriteArrayList;\n \n abstract class BaseSystemCapabilityManager {\n-\tprivate static final String TAG = \"SystemCapabilityManager\";\n-\tprivate final HashMap<SystemCapabilityType, Object> cachedSystemCapabilities;\n-\tprivate final HashMap<SystemCapabilityType, Boolean> systemCapabilitiesSubscriptionStatus;\n-\tprivate final HashMap<SystemCapabilityType, CopyOnWriteArrayList<OnSystemCapabilityListener>> onSystemCapabilityListeners;\n-\tprivate final Object LISTENER_LOCK;\n-\tprivate final ISdl callback;\n-\tprivate OnRPCListener rpcListener;\n-\tprivate boolean shouldConvertDeprecatedDisplayCapabilities;\n-\tprivate HMILevel currentHMILevel;\n-\n-\tBaseSystemCapabilityManager(ISdl callback) {\n-\t\tthis.callback = callback;\n-\t\tthis.LISTENER_LOCK = new Object();\n-\t\tthis.onSystemCapabilityListeners = new HashMap<>();\n-\t\tthis.cachedSystemCapabilities = new HashMap<>();\n-\t\tthis.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n-\t\tthis.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n-\t\tthis.shouldConvertDeprecatedDisplayCapabilities = true;\n-\t\tthis.currentHMILevel = HMILevel.HMI_NONE;\n-\n-\t\tsetupRpcListeners();\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(RegisterAppInterfaceResponse rpc) {\n-\t\treturn createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(SetDisplayLayoutResponse rpc) {\n-\t\treturn createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n-\t\t// Based on deprecated Display capabilities we don't know if widgets are supported,\n-\t\t// The Default MAIN window is the only window we know is supported\n-\t\tWindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n-\n-\t\tDisplayCapability displayCapability = new DisplayCapability();\n-\t\tif (display != null) {\n-\t\t\tif (display.getDisplayName() != null) {\n-\t\t\t\tdisplayCapability.setDisplayName(display.getDisplayName());\n-\t\t\t} else if (display.getDisplayType() != null) {\n-\t\t\t\tdisplayCapability.setDisplayName(display.getDisplayType().toString());\n-\t\t\t}\n-\t\t}\n-\t\tdisplayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n-\n-\t\t// Create a window capability object for the default MAIN window\n-\t\tWindowCapability defaultWindowCapability = new WindowCapability();\n-\t\tdefaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t\tdefaultWindowCapability.setButtonCapabilities(button);\n-\t\tdefaultWindowCapability.setSoftButtonCapabilities(softButton);\n-\n-\t\t// return if display capabilities don't exist.\n-\t\tif (display == null) {\n-\t\t\tdefaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n-\t\t\tdefaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n-\t\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\t\treturn Collections.singletonList(displayCapability);\n-\t\t}\n-\n-\t\t// copy all available display capabilities\n-\t\tdefaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n-\t\tdefaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n-\t\tdefaultWindowCapability.setTextFields(display.getTextFields());\n-\t\tdefaultWindowCapability.setImageFields(display.getImageFields());\n-\t\tArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n-\t\timageTypeSupported.add(ImageType.STATIC); // static images expected to always work on any head unit\n-\t\tif (display.getGraphicSupported()) {\n-\t\t\timageTypeSupported.add(ImageType.DYNAMIC);\n-\t\t}\n-\t\tdefaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n-\n-\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\treturn Collections.singletonList(displayCapability);\n-\t}\n-\n-\tprivate DisplayCapabilities createDeprecatedDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n-\t\tDisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n-\t\tconvertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n-\t\tconvertedCapabilities.setDisplayName(displayName);\n-\t\tconvertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n-\t\tconvertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n-\t\tconvertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n-\t\tconvertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n-\t\tconvertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but allows empty array\n-\t\t// if there are imageTypes in the response, we must assume graphics are supported\n-\t\tconvertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported() != null && defaultMainWindow.getImageTypeSupported().size() > 0);\n-\n-\t\treturn convertedCapabilities;\n-\t}\n-\n-\tprivate void updateDeprecatedDisplayCapabilities() {\n-\t\tWindowCapability defaultMainWindowCapabilities = getDefaultMainWindowCapability();\n-\t\tList<DisplayCapability> displayCapabilityList = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\n-\t\tif (defaultMainWindowCapabilities == null || displayCapabilityList == null || displayCapabilityList.size() == 0) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// cover the deprecated capabilities for backward compatibility\n-\t\tsetCapability(SystemCapabilityType.DISPLAY, createDeprecatedDisplayCapabilities(displayCapabilityList.get(0).getDisplayName(), defaultMainWindowCapabilities));\n-\t\tsetCapability(SystemCapabilityType.BUTTON, defaultMainWindowCapabilities.getButtonCapabilities());\n-\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, defaultMainWindowCapabilities.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabilities) {\n-\t\tif (newCapabilities == null || newCapabilities.size() == 0) {\n-\t\t\tDebugTool.logWarning(TAG, \"Received invalid display capability list\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tList<DisplayCapability> oldCapabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\n-\t\tif (oldCapabilities == null || oldCapabilities.size() == 0) {\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, newCapabilities);\n-\t\t\tupdateDeprecatedDisplayCapabilities();\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tDisplayCapability oldDefaultDisplayCapabilities = oldCapabilities.get(0);\n-\t\tArrayList<WindowCapability> copyWindowCapabilities = new ArrayList<>(oldDefaultDisplayCapabilities.getWindowCapabilities());\n-\n-\t\tDisplayCapability newDefaultDisplayCapabilities = newCapabilities.get(0);\n-\t\tList<WindowCapability> newWindowCapabilities = newDefaultDisplayCapabilities.getWindowCapabilities();\n-\n-\t\tif (newWindowCapabilities != null && !newWindowCapabilities.isEmpty()) {\n-\t\t\tfor (WindowCapability newWindow : newWindowCapabilities) {\n-\t\t\t\tListIterator<WindowCapability> iterator = copyWindowCapabilities.listIterator();\n-\t\t\t\tboolean oldFound = false;\n-\t\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\t\tWindowCapability oldWindow = iterator.next();\n-\t\t\t\t\tint newWindowID = newWindow.getWindowID() != null ? newWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\tint oldWindowID = oldWindow.getWindowID() != null ? oldWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\tif (newWindowID == oldWindowID) {\n-\t\t\t\t\t\titerator.set(newWindow); // replace the old window caps with new ones\n-\t\t\t\t\t\toldFound = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (!oldFound) {\n-\t\t\t\t\tcopyWindowCapabilities.add(newWindow); // this is a new unknown window\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// replace the window capabilities array with the merged one.\n-\t\tnewDefaultDisplayCapabilities.setWindowCapabilities(copyWindowCapabilities);\n-\t\tsetCapability(SystemCapabilityType.DISPLAYS, Collections.singletonList(newDefaultDisplayCapabilities));\n-\t\tupdateDeprecatedDisplayCapabilities();\n-\t}\n-\n-\tprivate void updateCachedVideoStreamingCapabilities(VideoStreamingCapability capability) {\n-\t\tsetCapability(SystemCapabilityType.VIDEO_STREAMING, capability);\n-\t}\n-\n-\tpublic WindowCapability getWindowCapability(int windowID) {\n-\t\tList<DisplayCapability> capabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tDisplayCapability display = capabilities.get(0);\n-\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t    int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\tif (currentWindowID == windowID) {\n-\t\t\t\treturn windowCapability;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tpublic WindowCapability getDefaultMainWindowCapability() {\n-\t\treturn getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t}\n-\n-\tvoid parseRAIResponse(RegisterAppInterfaceResponse response) {\n-\t\tif (response != null && response.getSuccess()) {\n-\t\t\tthis.shouldConvertDeprecatedDisplayCapabilities = true; // reset the flag\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n-\t\t\tsetCapability(SystemCapabilityType.HMI, response.getHmiCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, response.getAudioPassThruCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PCM_STREAMING, response.getPcmStreamingCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.HMI_ZONE, response.getHmiZoneCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.SPEECH, response.getSpeechCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.VOICE_RECOGNITION, response.getVrCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PRERECORDED_SPEECH, response.getPrerecordedSpeech());\n-\t\t}\n-\t}\n+    private static final String TAG = \"SystemCapabilityManager\";\n+    private final HashMap<SystemCapabilityType, Object> cachedSystemCapabilities;\n+    private final HashMap<SystemCapabilityType, Boolean> systemCapabilitiesSubscriptionStatus;\n+    private final HashMap<SystemCapabilityType, CopyOnWriteArrayList<OnSystemCapabilityListener>> onSystemCapabilityListeners;\n+    private final Object LISTENER_LOCK;\n+    private final ISdl callback;\n+    private boolean shouldConvertDeprecatedDisplayCapabilities;\n+    private HMILevel currentHMILevel;\n+\n+    BaseSystemCapabilityManager(ISdl callback) {\n+        this.callback = callback;\n+        this.LISTENER_LOCK = new Object();\n+        this.onSystemCapabilityListeners = new HashMap<>();\n+        this.cachedSystemCapabilities = new HashMap<>();\n+        this.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.VIDEO_STREAMING, true);\n+        this.shouldConvertDeprecatedDisplayCapabilities = true;\n+        this.currentHMILevel = HMILevel.HMI_NONE;\n+\n+        setupRpcListeners();\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(RegisterAppInterfaceResponse rpc) {\n+        return createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(SetDisplayLayoutResponse rpc) {\n+        return createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n+        // Based on deprecated Display capabilities we don't know if widgets are supported,\n+        // The Default MAIN window is the only window we know is supported\n+        WindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n+\n+        DisplayCapability displayCapability = new DisplayCapability();\n+        if (display != null) {\n+            if (display.getDisplayName() != null) {\n+                displayCapability.setDisplayName(display.getDisplayName());\n+            } else if (display.getDisplayType() != null) {\n+                displayCapability.setDisplayName(display.getDisplayType().toString());\n+            }\n+        }\n+        displayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n+\n+        // Create a window capability object for the default MAIN window\n+        WindowCapability defaultWindowCapability = new WindowCapability();\n+        defaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+        defaultWindowCapability.setButtonCapabilities(button);\n+        defaultWindowCapability.setSoftButtonCapabilities(softButton);\n+\n+        // return if display capabilities don't exist.\n+        if (display == null) {\n+            defaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n+            defaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n+            displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+            return Collections.singletonList(displayCapability);\n+        }\n+\n+        // copy all available display capabilities\n+        defaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n+        defaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n+        defaultWindowCapability.setTextFields(display.getTextFields());\n+        defaultWindowCapability.setImageFields(display.getImageFields());\n+        ArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n+        imageTypeSupported.add(ImageType.STATIC); // static images expected to always work on any head unit\n+        if (display.getGraphicSupported()) {\n+            imageTypeSupported.add(ImageType.DYNAMIC);\n+        }\n+        defaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n+\n+        displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+        return Collections.singletonList(displayCapability);\n+    }\n+\n+    private DisplayCapabilities createDeprecatedDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n+        DisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n+        convertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n+        convertedCapabilities.setDisplayName(displayName);\n+        convertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n+        convertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n+        convertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n+        convertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n+        convertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but allows empty array\n+        // if there are imageTypes in the response, we must assume graphics are supported\n+        convertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported() != null && defaultMainWindow.getImageTypeSupported().size() > 0);\n+\n+        return convertedCapabilities;\n+    }\n+\n+    private void updateDeprecatedDisplayCapabilities() {\n+        WindowCapability defaultMainWindowCapabilities = getDefaultMainWindowCapability();\n+        List<DisplayCapability> displayCapabilityList = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+\n+        if (defaultMainWindowCapabilities == null || displayCapabilityList == null || displayCapabilityList.size() == 0) {\n+            return;\n+        }\n+\n+        // cover the deprecated capabilities for backward compatibility\n+        setCapability(SystemCapabilityType.DISPLAY, createDeprecatedDisplayCapabilities(displayCapabilityList.get(0).getDisplayName(), defaultMainWindowCapabilities));\n+        setCapability(SystemCapabilityType.BUTTON, defaultMainWindowCapabilities.getButtonCapabilities());\n+        setCapability(SystemCapabilityType.SOFTBUTTON, defaultMainWindowCapabilities.getSoftButtonCapabilities());\n+    }\n+\n+    private void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabilities) {\n+        if (newCapabilities == null || newCapabilities.size() == 0) {\n+            DebugTool.logWarning(TAG, \"Received invalid display capability list\");\n+            return;\n+        }\n+\n+        List<DisplayCapability> oldCapabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+\n+        if (oldCapabilities == null || oldCapabilities.size() == 0) {\n+            setCapability(SystemCapabilityType.DISPLAYS, newCapabilities);\n+            updateDeprecatedDisplayCapabilities();\n+            return;\n+        }\n+\n+        DisplayCapability oldDefaultDisplayCapabilities = oldCapabilities.get(0);\n+        ArrayList<WindowCapability> copyWindowCapabilities = new ArrayList<>(oldDefaultDisplayCapabilities.getWindowCapabilities());\n+\n+        DisplayCapability newDefaultDisplayCapabilities = newCapabilities.get(0);\n+        List<WindowCapability> newWindowCapabilities = newDefaultDisplayCapabilities.getWindowCapabilities();\n+\n+        if (newWindowCapabilities != null && !newWindowCapabilities.isEmpty()) {\n+            for (WindowCapability newWindow : newWindowCapabilities) {\n+                ListIterator<WindowCapability> iterator = copyWindowCapabilities.listIterator();\n+                boolean oldFound = false;\n+                while (iterator.hasNext()) {\n+                    WindowCapability oldWindow = iterator.next();\n+                    int newWindowID = newWindow.getWindowID() != null ? newWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                    int oldWindowID = oldWindow.getWindowID() != null ? oldWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                    if (newWindowID == oldWindowID) {\n+                        iterator.set(newWindow); // replace the old window caps with new ones\n+                        oldFound = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!oldFound) {\n+                    copyWindowCapabilities.add(newWindow); // this is a new unknown window\n+                }\n+            }\n+        }\n+\n+        // replace the window capabilities array with the merged one.\n+        newDefaultDisplayCapabilities.setWindowCapabilities(copyWindowCapabilities);\n+        setCapability(SystemCapabilityType.DISPLAYS, Collections.singletonList(newDefaultDisplayCapabilities));\n+        updateDeprecatedDisplayCapabilities();\n+    }\n+\n+\n+    public WindowCapability getWindowCapability(int windowID) {\n+        List<DisplayCapability> capabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+        if (capabilities == null || capabilities.size() == 0) {\n+            return null;\n+        }\n+        DisplayCapability display = capabilities.get(0);\n+        for (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+            int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+            if (currentWindowID == windowID) {\n+                return windowCapability;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public WindowCapability getDefaultMainWindowCapability() {\n+        return getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+    }\n+\n+    void parseRAIResponse(RegisterAppInterfaceResponse response) {\n+        if (response != null && response.getSuccess()) {\n+            this.shouldConvertDeprecatedDisplayCapabilities = true; // reset the flag\n+            setCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n+            setCapability(SystemCapabilityType.HMI, response.getHmiCapabilities());\n+            setCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n+            setCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, response.getAudioPassThruCapabilities());\n+            setCapability(SystemCapabilityType.PCM_STREAMING, response.getPcmStreamingCapabilities());\n+            setCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n+            setCapability(SystemCapabilityType.HMI_ZONE, response.getHmiZoneCapabilities());\n+            setCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n+            setCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n+            setCapability(SystemCapabilityType.SPEECH, response.getSpeechCapabilities());\n+            setCapability(SystemCapabilityType.VOICE_RECOGNITION, response.getVrCapabilities());\n+            setCapability(SystemCapabilityType.PRERECORDED_SPEECH, response.getPrerecordedSpeech());\n+        }\n+    }\n \n     private void setupRpcListeners() {\n-        rpcListener = new OnRPCListener() {\n+        OnRPCListener rpcListener = new OnRPCListener() {\n             @Override\n             public void onReceived(RPCMessage message) {\n                 if (message != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc5NTQ0Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472795442", "bodyText": "On line 341, the alignment of case VIDEO_STREAMING needs to be fixed. It (and all of its code) needs to be on the same level as the case above it (case DISPLAYS).", "author": "santhanamk", "createdAt": "2020-08-19T07:18:56Z", "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java", "diffHunk": "@@ -266,81 +272,90 @@ void parseRAIResponse(RegisterAppInterfaceResponse response) {\n \t\t}\n \t}\n \n-\tprivate void setupRpcListeners() {\n-\t\trpcListener = new OnRPCListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onReceived(RPCMessage message) {\n-\t\t\t\tif (message != null) {\n-\t\t\t\t\tif (RPCMessage.KEY_RESPONSE.equals(message.getMessageType())) {\n-\t\t\t\t\t\tswitch (message.getFunctionID()) {\n-\t\t\t\t\t\t\tcase SET_DISPLAY_LAYOUT:\n-\t\t\t\t\t\t\t\tSetDisplayLayoutResponse response = (SetDisplayLayoutResponse) message;\n-\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n-\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n-\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n-\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n-\t\t\t\t\t\t\t\tif (shouldConvertDeprecatedDisplayCapabilities) {\n-\t\t\t\t\t\t\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase GET_SYSTEM_CAPABILITY:\n-\t\t\t\t\t\t\t\tGetSystemCapabilityResponse systemCapabilityResponse = (GetSystemCapabilityResponse) message;\n-\t\t\t\t\t\t\t\tSystemCapability systemCapability = systemCapabilityResponse.getSystemCapability();\n-\t\t\t\t\t\t\t\tif (systemCapabilityResponse.getSuccess() && SystemCapabilityType.DISPLAYS.equals(systemCapability.getSystemCapabilityType())) {\n-\t\t\t\t\t\t\t\t\tshouldConvertDeprecatedDisplayCapabilities = false; // Successfully got DISPLAYS data. No conversion needed anymore\n-\t\t\t\t\t\t\t\t\tList<DisplayCapability> newCapabilities = (List<DisplayCapability>) systemCapability.getCapabilityForType(SystemCapabilityType.DISPLAYS);\n-\t\t\t\t\t\t\t\t\tupdateCachedDisplayCapabilityList(newCapabilities);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else if (RPCMessage.KEY_NOTIFICATION.equals(message.getMessageType())) {\n-\t\t\t\t\t\tswitch (message.getFunctionID()) {\n+    private void setupRpcListeners() {\n+        rpcListener = new OnRPCListener() {\n+            @Override\n+            public void onReceived(RPCMessage message) {\n+                if (message != null) {\n+                    if (RPCMessage.KEY_RESPONSE.equals(message.getMessageType())) {\n+                        switch (message.getFunctionID()) {\n+                            case SET_DISPLAY_LAYOUT:\n+                                SetDisplayLayoutResponse response = (SetDisplayLayoutResponse) message;\n+                                setCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n+                                setCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n+                                setCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n+                                setCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n+                                if (shouldConvertDeprecatedDisplayCapabilities) {\n+                                    setCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n+                                }\n+                                break;\n+                            case GET_SYSTEM_CAPABILITY:\n+                                GetSystemCapabilityResponse systemCapabilityResponse = (GetSystemCapabilityResponse) message;\n+                                SystemCapability systemCapability = systemCapabilityResponse.getSystemCapability();\n+                                if (systemCapabilityResponse.getSuccess() && SystemCapabilityType.DISPLAYS.equals(systemCapability.getSystemCapabilityType())) {\n+                                    shouldConvertDeprecatedDisplayCapabilities = false; // Successfully got DISPLAYS data. No conversion needed anymore\n+                                    List<DisplayCapability> newCapabilities = (List<DisplayCapability>) systemCapability.getCapabilityForType(SystemCapabilityType.DISPLAYS);\n+                                    updateCachedDisplayCapabilityList(newCapabilities);\n+                                }\n+                                break;\n+                        }\n+                    } else if (RPCMessage.KEY_NOTIFICATION.equals(message.getMessageType())) {\n+                        switch (message.getFunctionID()) {\n \t\t\t\t\t\t\tcase ON_HMI_STATUS:\n \t\t\t\t\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) message;\n \t\t\t\t\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n \t\t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tcurrentHMILevel = onHMIStatus.getHmiLevel();\n \t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\tcase ON_SYSTEM_CAPABILITY_UPDATED:\n-\t\t\t\t\t\t\t\tOnSystemCapabilityUpdated onSystemCapabilityUpdated = (OnSystemCapabilityUpdated) message;\n-\t\t\t\t\t\t\t\tif (onSystemCapabilityUpdated.getSystemCapability() != null) {\n-\t\t\t\t\t\t\t\t\tSystemCapability systemCapability = onSystemCapabilityUpdated.getSystemCapability();\n-\t\t\t\t\t\t\t\t\tSystemCapabilityType systemCapabilityType = systemCapability.getSystemCapabilityType();\n-\t\t\t\t\t\t\t\t\tObject capability = systemCapability.getCapabilityForType(systemCapabilityType);\n-\t\t\t\t\t\t\t\t\tif (cachedSystemCapabilities.containsKey(systemCapabilityType)) { //The capability already exists\n-\t\t\t\t\t\t\t\t\t\tswitch (systemCapabilityType) {\n-\t\t\t\t\t\t\t\t\t\t\tcase APP_SERVICES:\n-\t\t\t\t\t\t\t\t\t\t\t\t// App services only updates what was changed so we need\n-\t\t\t\t\t\t\t\t\t\t\t\t// to update the capability rather than override it\n-\t\t\t\t\t\t\t\t\t\t\t\tAppServicesCapabilities appServicesCapabilities = (AppServicesCapabilities) capability;\n-\t\t\t\t\t\t\t\t\t\t\t\tif (capability != null) {\n-\t\t\t\t\t\t\t\t\t\t\t\t\tList<AppServiceCapability> appServicesCapabilitiesList = appServicesCapabilities.getAppServices();\n-\t\t\t\t\t\t\t\t\t\t\t\t\tAppServicesCapabilities cachedAppServicesCapabilities = (AppServicesCapabilities) cachedSystemCapabilities.get(systemCapabilityType);\n-\t\t\t\t\t\t\t\t\t\t\t\t\t//Update the cached app services\n-\t\t\t\t\t\t\t\t\t\t\t\t\tif (cachedAppServicesCapabilities != null) {\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\tcachedAppServicesCapabilities.updateAppServices(appServicesCapabilitiesList);\n-\t\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\t\t//Set the new capability object to the updated cached capabilities\n-\t\t\t\t\t\t\t\t\t\t\t\t\tcapability = cachedAppServicesCapabilities;\n-\t\t\t\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t\t\t\tcase DISPLAYS:\n-\t\t\t\t\t\t\t\t\t\t\t\tshouldConvertDeprecatedDisplayCapabilities = false; // Successfully got DISPLAYS data. No conversion needed anymore\n+                            case ON_SYSTEM_CAPABILITY_UPDATED:\n+                                OnSystemCapabilityUpdated onSystemCapabilityUpdated = (OnSystemCapabilityUpdated) message;\n+                                if (onSystemCapabilityUpdated.getSystemCapability() != null) {\n+                                    SystemCapability systemCapability = onSystemCapabilityUpdated.getSystemCapability();\n+                                    SystemCapabilityType systemCapabilityType = systemCapability.getSystemCapabilityType();\n+                                    Object capability = systemCapability.getCapabilityForType(systemCapabilityType);\n+                                    if (cachedSystemCapabilities.containsKey(systemCapabilityType)) { //The capability already exists\n+                                        switch (systemCapabilityType) {\n+                                            case APP_SERVICES:\n+                                                // App services only updates what was changed so we need\n+                                                // to update the capability rather than override it\n+                                                AppServicesCapabilities appServicesCapabilities = (AppServicesCapabilities) capability;\n+                                                if (capability != null) {\n+                                                    List<AppServiceCapability> appServicesCapabilitiesList = appServicesCapabilities.getAppServices();\n+                                                    AppServicesCapabilities cachedAppServicesCapabilities = (AppServicesCapabilities) cachedSystemCapabilities.get(systemCapabilityType);\n+                                                    //Update the cached app services\n+                                                    if (cachedAppServicesCapabilities != null) {\n+                                                    \tcachedAppServicesCapabilities.updateAppServices(appServicesCapabilitiesList);\n+                                                    }\n+                                                    //Set the new capability object to the updated cached capabilities\n+                                                    capability = cachedAppServicesCapabilities;\n+                                                }\n+                                                break;\n+                                            case DISPLAYS:\n+                                                shouldConvertDeprecatedDisplayCapabilities = false; // Successfully got DISPLAYS data. No conversion needed anymore\n+                                                // this notification can return only affected windows (hence not all windows)\n+                                                List<DisplayCapability> newCapabilities = (List<DisplayCapability>) capability;\n+                                                updateCachedDisplayCapabilityList(newCapabilities);\n+                                                systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n+                                                break;\n+\t\t\t\t\t\t\t\t\t\t\tcase VIDEO_STREAMING:", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3NDU2Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473374567", "bodyText": "On line 341, the alignment of case VIDEO_STREAMING needs to be fixed. It (and all of its code) needs to be on the same level as the case above it (case DISPLAYS).\n\n@kostyaBoss I still see this issue.  On line 335, the alignment of case VIDEO_STREAMING needs to be fixed. It (and all of its code) needs to be on the same level as the case above it (case DISPLAYS).", "author": "santhanamk", "createdAt": "2020-08-19T22:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc5NTQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\nindex 1c569e082..c94f7193c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n\n@@ -79,201 +74,198 @@ import java.util.ListIterator;\n import java.util.concurrent.CopyOnWriteArrayList;\n \n abstract class BaseSystemCapabilityManager {\n-\tprivate static final String TAG = \"SystemCapabilityManager\";\n-\tprivate final HashMap<SystemCapabilityType, Object> cachedSystemCapabilities;\n-\tprivate final HashMap<SystemCapabilityType, Boolean> systemCapabilitiesSubscriptionStatus;\n-\tprivate final HashMap<SystemCapabilityType, CopyOnWriteArrayList<OnSystemCapabilityListener>> onSystemCapabilityListeners;\n-\tprivate final Object LISTENER_LOCK;\n-\tprivate final ISdl callback;\n-\tprivate OnRPCListener rpcListener;\n-\tprivate boolean shouldConvertDeprecatedDisplayCapabilities;\n-\tprivate HMILevel currentHMILevel;\n-\n-\tBaseSystemCapabilityManager(ISdl callback) {\n-\t\tthis.callback = callback;\n-\t\tthis.LISTENER_LOCK = new Object();\n-\t\tthis.onSystemCapabilityListeners = new HashMap<>();\n-\t\tthis.cachedSystemCapabilities = new HashMap<>();\n-\t\tthis.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n-\t\tthis.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n-\t\tthis.shouldConvertDeprecatedDisplayCapabilities = true;\n-\t\tthis.currentHMILevel = HMILevel.HMI_NONE;\n-\n-\t\tsetupRpcListeners();\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(RegisterAppInterfaceResponse rpc) {\n-\t\treturn createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(SetDisplayLayoutResponse rpc) {\n-\t\treturn createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n-\t\t// Based on deprecated Display capabilities we don't know if widgets are supported,\n-\t\t// The Default MAIN window is the only window we know is supported\n-\t\tWindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n-\n-\t\tDisplayCapability displayCapability = new DisplayCapability();\n-\t\tif (display != null) {\n-\t\t\tif (display.getDisplayName() != null) {\n-\t\t\t\tdisplayCapability.setDisplayName(display.getDisplayName());\n-\t\t\t} else if (display.getDisplayType() != null) {\n-\t\t\t\tdisplayCapability.setDisplayName(display.getDisplayType().toString());\n-\t\t\t}\n-\t\t}\n-\t\tdisplayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n-\n-\t\t// Create a window capability object for the default MAIN window\n-\t\tWindowCapability defaultWindowCapability = new WindowCapability();\n-\t\tdefaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t\tdefaultWindowCapability.setButtonCapabilities(button);\n-\t\tdefaultWindowCapability.setSoftButtonCapabilities(softButton);\n-\n-\t\t// return if display capabilities don't exist.\n-\t\tif (display == null) {\n-\t\t\tdefaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n-\t\t\tdefaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n-\t\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\t\treturn Collections.singletonList(displayCapability);\n-\t\t}\n-\n-\t\t// copy all available display capabilities\n-\t\tdefaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n-\t\tdefaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n-\t\tdefaultWindowCapability.setTextFields(display.getTextFields());\n-\t\tdefaultWindowCapability.setImageFields(display.getImageFields());\n-\t\tArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n-\t\timageTypeSupported.add(ImageType.STATIC); // static images expected to always work on any head unit\n-\t\tif (display.getGraphicSupported()) {\n-\t\t\timageTypeSupported.add(ImageType.DYNAMIC);\n-\t\t}\n-\t\tdefaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n-\n-\t\tdisplayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n-\t\treturn Collections.singletonList(displayCapability);\n-\t}\n-\n-\tprivate DisplayCapabilities createDeprecatedDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n-\t\tDisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n-\t\tconvertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n-\t\tconvertedCapabilities.setDisplayName(displayName);\n-\t\tconvertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n-\t\tconvertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n-\t\tconvertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n-\t\tconvertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n-\t\tconvertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but allows empty array\n-\t\t// if there are imageTypes in the response, we must assume graphics are supported\n-\t\tconvertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported() != null && defaultMainWindow.getImageTypeSupported().size() > 0);\n-\n-\t\treturn convertedCapabilities;\n-\t}\n-\n-\tprivate void updateDeprecatedDisplayCapabilities() {\n-\t\tWindowCapability defaultMainWindowCapabilities = getDefaultMainWindowCapability();\n-\t\tList<DisplayCapability> displayCapabilityList = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\n-\t\tif (defaultMainWindowCapabilities == null || displayCapabilityList == null || displayCapabilityList.size() == 0) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// cover the deprecated capabilities for backward compatibility\n-\t\tsetCapability(SystemCapabilityType.DISPLAY, createDeprecatedDisplayCapabilities(displayCapabilityList.get(0).getDisplayName(), defaultMainWindowCapabilities));\n-\t\tsetCapability(SystemCapabilityType.BUTTON, defaultMainWindowCapabilities.getButtonCapabilities());\n-\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, defaultMainWindowCapabilities.getSoftButtonCapabilities());\n-\t}\n-\n-\tprivate void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabilities) {\n-\t\tif (newCapabilities == null || newCapabilities.size() == 0) {\n-\t\t\tDebugTool.logWarning(TAG, \"Received invalid display capability list\");\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tList<DisplayCapability> oldCapabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\n-\t\tif (oldCapabilities == null || oldCapabilities.size() == 0) {\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, newCapabilities);\n-\t\t\tupdateDeprecatedDisplayCapabilities();\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tDisplayCapability oldDefaultDisplayCapabilities = oldCapabilities.get(0);\n-\t\tArrayList<WindowCapability> copyWindowCapabilities = new ArrayList<>(oldDefaultDisplayCapabilities.getWindowCapabilities());\n-\n-\t\tDisplayCapability newDefaultDisplayCapabilities = newCapabilities.get(0);\n-\t\tList<WindowCapability> newWindowCapabilities = newDefaultDisplayCapabilities.getWindowCapabilities();\n-\n-\t\tif (newWindowCapabilities != null && !newWindowCapabilities.isEmpty()) {\n-\t\t\tfor (WindowCapability newWindow : newWindowCapabilities) {\n-\t\t\t\tListIterator<WindowCapability> iterator = copyWindowCapabilities.listIterator();\n-\t\t\t\tboolean oldFound = false;\n-\t\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\t\tWindowCapability oldWindow = iterator.next();\n-\t\t\t\t\tint newWindowID = newWindow.getWindowID() != null ? newWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\tint oldWindowID = oldWindow.getWindowID() != null ? oldWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\t\t\tif (newWindowID == oldWindowID) {\n-\t\t\t\t\t\titerator.set(newWindow); // replace the old window caps with new ones\n-\t\t\t\t\t\toldFound = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (!oldFound) {\n-\t\t\t\t\tcopyWindowCapabilities.add(newWindow); // this is a new unknown window\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// replace the window capabilities array with the merged one.\n-\t\tnewDefaultDisplayCapabilities.setWindowCapabilities(copyWindowCapabilities);\n-\t\tsetCapability(SystemCapabilityType.DISPLAYS, Collections.singletonList(newDefaultDisplayCapabilities));\n-\t\tupdateDeprecatedDisplayCapabilities();\n-\t}\n-\n-\tprivate void updateCachedVideoStreamingCapabilities(VideoStreamingCapability capability) {\n-\t\tsetCapability(SystemCapabilityType.VIDEO_STREAMING, capability);\n-\t}\n-\n-\tpublic WindowCapability getWindowCapability(int windowID) {\n-\t\tList<DisplayCapability> capabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS), DisplayCapability.class);\n-\t\tif (capabilities == null || capabilities.size() == 0) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tDisplayCapability display = capabilities.get(0);\n-\t\tfor (WindowCapability windowCapability : display.getWindowCapabilities()) {\n-\t\t    int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n-\t\t\tif (currentWindowID == windowID) {\n-\t\t\t\treturn windowCapability;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tpublic WindowCapability getDefaultMainWindowCapability() {\n-\t\treturn getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue());\n-\t}\n-\n-\tvoid parseRAIResponse(RegisterAppInterfaceResponse response) {\n-\t\tif (response != null && response.getSuccess()) {\n-\t\t\tthis.shouldConvertDeprecatedDisplayCapabilities = true; // reset the flag\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n-\t\t\tsetCapability(SystemCapabilityType.HMI, response.getHmiCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, response.getAudioPassThruCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PCM_STREAMING, response.getPcmStreamingCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.HMI_ZONE, response.getHmiZoneCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.SPEECH, response.getSpeechCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.VOICE_RECOGNITION, response.getVrCapabilities());\n-\t\t\tsetCapability(SystemCapabilityType.PRERECORDED_SPEECH, response.getPrerecordedSpeech());\n-\t\t}\n-\t}\n+    private static final String TAG = \"SystemCapabilityManager\";\n+    private final HashMap<SystemCapabilityType, Object> cachedSystemCapabilities;\n+    private final HashMap<SystemCapabilityType, Boolean> systemCapabilitiesSubscriptionStatus;\n+    private final HashMap<SystemCapabilityType, CopyOnWriteArrayList<OnSystemCapabilityListener>> onSystemCapabilityListeners;\n+    private final Object LISTENER_LOCK;\n+    private final ISdl callback;\n+    private boolean shouldConvertDeprecatedDisplayCapabilities;\n+    private HMILevel currentHMILevel;\n+\n+    BaseSystemCapabilityManager(ISdl callback) {\n+        this.callback = callback;\n+        this.LISTENER_LOCK = new Object();\n+        this.onSystemCapabilityListeners = new HashMap<>();\n+        this.cachedSystemCapabilities = new HashMap<>();\n+        this.systemCapabilitiesSubscriptionStatus = new HashMap<>();\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.DISPLAYS, true);\n+        this.systemCapabilitiesSubscriptionStatus.put(SystemCapabilityType.VIDEO_STREAMING, true);\n+        this.shouldConvertDeprecatedDisplayCapabilities = true;\n+        this.currentHMILevel = HMILevel.HMI_NONE;\n+\n+        setupRpcListeners();\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(RegisterAppInterfaceResponse rpc) {\n+        return createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(SetDisplayLayoutResponse rpc) {\n+        return createDisplayCapabilityList(rpc.getDisplayCapabilities(), rpc.getButtonCapabilities(), rpc.getSoftButtonCapabilities());\n+    }\n+\n+    private List<DisplayCapability> createDisplayCapabilityList(DisplayCapabilities display, List<ButtonCapabilities> button, List<SoftButtonCapabilities> softButton) {\n+        // Based on deprecated Display capabilities we don't know if widgets are supported,\n+        // The Default MAIN window is the only window we know is supported\n+        WindowTypeCapabilities windowTypeCapabilities = new WindowTypeCapabilities(WindowType.MAIN, 1);\n+\n+        DisplayCapability displayCapability = new DisplayCapability();\n+        if (display != null) {\n+            if (display.getDisplayName() != null) {\n+                displayCapability.setDisplayName(display.getDisplayName());\n+            } else if (display.getDisplayType() != null) {\n+                displayCapability.setDisplayName(display.getDisplayType().toString());\n+            }\n+        }\n+        displayCapability.setWindowTypeSupported(Collections.singletonList(windowTypeCapabilities));\n+\n+        // Create a window capability object for the default MAIN window\n+        WindowCapability defaultWindowCapability = new WindowCapability();\n+        defaultWindowCapability.setWindowID(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+        defaultWindowCapability.setButtonCapabilities(button);\n+        defaultWindowCapability.setSoftButtonCapabilities(softButton);\n+\n+        // return if display capabilities don't exist.\n+        if (display == null) {\n+            defaultWindowCapability.setTextFields(ManagerUtility.WindowCapabilityUtility.getAllTextFields());\n+            defaultWindowCapability.setImageFields(ManagerUtility.WindowCapabilityUtility.getAllImageFields());\n+            displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+            return Collections.singletonList(displayCapability);\n+        }\n+\n+        // copy all available display capabilities\n+        defaultWindowCapability.setTemplatesAvailable(display.getTemplatesAvailable());\n+        defaultWindowCapability.setNumCustomPresetsAvailable(display.getNumCustomPresetsAvailable());\n+        defaultWindowCapability.setTextFields(display.getTextFields());\n+        defaultWindowCapability.setImageFields(display.getImageFields());\n+        ArrayList<ImageType> imageTypeSupported = new ArrayList<>();\n+        imageTypeSupported.add(ImageType.STATIC); // static images expected to always work on any head unit\n+        if (display.getGraphicSupported()) {\n+            imageTypeSupported.add(ImageType.DYNAMIC);\n+        }\n+        defaultWindowCapability.setImageTypeSupported(imageTypeSupported);\n+\n+        displayCapability.setWindowCapabilities(Collections.singletonList(defaultWindowCapability));\n+        return Collections.singletonList(displayCapability);\n+    }\n+\n+    private DisplayCapabilities createDeprecatedDisplayCapabilities(String displayName, WindowCapability defaultMainWindow) {\n+        DisplayCapabilities convertedCapabilities = new DisplayCapabilities();\n+        convertedCapabilities.setDisplayType(DisplayType.SDL_GENERIC); //deprecated but it is mandatory...\n+        convertedCapabilities.setDisplayName(displayName);\n+        convertedCapabilities.setTextFields(defaultMainWindow.getTextFields());\n+        convertedCapabilities.setImageFields(defaultMainWindow.getImageFields());\n+        convertedCapabilities.setTemplatesAvailable(defaultMainWindow.getTemplatesAvailable());\n+        convertedCapabilities.setNumCustomPresetsAvailable(defaultMainWindow.getNumCustomPresetsAvailable());\n+        convertedCapabilities.setMediaClockFormats(new ArrayList<MediaClockFormat>()); // mandatory field but allows empty array\n+        // if there are imageTypes in the response, we must assume graphics are supported\n+        convertedCapabilities.setGraphicSupported(defaultMainWindow.getImageTypeSupported() != null && defaultMainWindow.getImageTypeSupported().size() > 0);\n+\n+        return convertedCapabilities;\n+    }\n+\n+    private void updateDeprecatedDisplayCapabilities() {\n+        WindowCapability defaultMainWindowCapabilities = getDefaultMainWindowCapability();\n+        List<DisplayCapability> displayCapabilityList = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+\n+        if (defaultMainWindowCapabilities == null || displayCapabilityList == null || displayCapabilityList.size() == 0) {\n+            return;\n+        }\n+\n+        // cover the deprecated capabilities for backward compatibility\n+        setCapability(SystemCapabilityType.DISPLAY, createDeprecatedDisplayCapabilities(displayCapabilityList.get(0).getDisplayName(), defaultMainWindowCapabilities));\n+        setCapability(SystemCapabilityType.BUTTON, defaultMainWindowCapabilities.getButtonCapabilities());\n+        setCapability(SystemCapabilityType.SOFTBUTTON, defaultMainWindowCapabilities.getSoftButtonCapabilities());\n+    }\n+\n+    private void updateCachedDisplayCapabilityList(List<DisplayCapability> newCapabilities) {\n+        if (newCapabilities == null || newCapabilities.size() == 0) {\n+            DebugTool.logWarning(TAG, \"Received invalid display capability list\");\n+            return;\n+        }\n+\n+        List<DisplayCapability> oldCapabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+\n+        if (oldCapabilities == null || oldCapabilities.size() == 0) {\n+            setCapability(SystemCapabilityType.DISPLAYS, newCapabilities);\n+            updateDeprecatedDisplayCapabilities();\n+            return;\n+        }\n+\n+        DisplayCapability oldDefaultDisplayCapabilities = oldCapabilities.get(0);\n+        ArrayList<WindowCapability> copyWindowCapabilities = new ArrayList<>(oldDefaultDisplayCapabilities.getWindowCapabilities());\n+\n+        DisplayCapability newDefaultDisplayCapabilities = newCapabilities.get(0);\n+        List<WindowCapability> newWindowCapabilities = newDefaultDisplayCapabilities.getWindowCapabilities();\n+\n+        if (newWindowCapabilities != null && !newWindowCapabilities.isEmpty()) {\n+            for (WindowCapability newWindow : newWindowCapabilities) {\n+                ListIterator<WindowCapability> iterator = copyWindowCapabilities.listIterator();\n+                boolean oldFound = false;\n+                while (iterator.hasNext()) {\n+                    WindowCapability oldWindow = iterator.next();\n+                    int newWindowID = newWindow.getWindowID() != null ? newWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                    int oldWindowID = oldWindow.getWindowID() != null ? oldWindow.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+                    if (newWindowID == oldWindowID) {\n+                        iterator.set(newWindow); // replace the old window caps with new ones\n+                        oldFound = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!oldFound) {\n+                    copyWindowCapabilities.add(newWindow); // this is a new unknown window\n+                }\n+            }\n+        }\n+\n+        // replace the window capabilities array with the merged one.\n+        newDefaultDisplayCapabilities.setWindowCapabilities(copyWindowCapabilities);\n+        setCapability(SystemCapabilityType.DISPLAYS, Collections.singletonList(newDefaultDisplayCapabilities));\n+        updateDeprecatedDisplayCapabilities();\n+    }\n+\n+\n+    public WindowCapability getWindowCapability(int windowID) {\n+        List<DisplayCapability> capabilities = convertToList(getCapability(SystemCapabilityType.DISPLAYS, null, false), DisplayCapability.class);\n+        if (capabilities == null || capabilities.size() == 0) {\n+            return null;\n+        }\n+        DisplayCapability display = capabilities.get(0);\n+        for (WindowCapability windowCapability : display.getWindowCapabilities()) {\n+            int currentWindowID = windowCapability.getWindowID() != null ? windowCapability.getWindowID() : PredefinedWindows.DEFAULT_WINDOW.getValue();\n+            if (currentWindowID == windowID) {\n+                return windowCapability;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public WindowCapability getDefaultMainWindowCapability() {\n+        return getWindowCapability(PredefinedWindows.DEFAULT_WINDOW.getValue());\n+    }\n+\n+    void parseRAIResponse(RegisterAppInterfaceResponse response) {\n+        if (response != null && response.getSuccess()) {\n+            this.shouldConvertDeprecatedDisplayCapabilities = true; // reset the flag\n+            setCapability(SystemCapabilityType.DISPLAYS, createDisplayCapabilityList(response));\n+            setCapability(SystemCapabilityType.HMI, response.getHmiCapabilities());\n+            setCapability(SystemCapabilityType.DISPLAY, response.getDisplayCapabilities());\n+            setCapability(SystemCapabilityType.AUDIO_PASSTHROUGH, response.getAudioPassThruCapabilities());\n+            setCapability(SystemCapabilityType.PCM_STREAMING, response.getPcmStreamingCapabilities());\n+            setCapability(SystemCapabilityType.BUTTON, response.getButtonCapabilities());\n+            setCapability(SystemCapabilityType.HMI_ZONE, response.getHmiZoneCapabilities());\n+            setCapability(SystemCapabilityType.PRESET_BANK, response.getPresetBankCapabilities());\n+            setCapability(SystemCapabilityType.SOFTBUTTON, response.getSoftButtonCapabilities());\n+            setCapability(SystemCapabilityType.SPEECH, response.getSpeechCapabilities());\n+            setCapability(SystemCapabilityType.VOICE_RECOGNITION, response.getVrCapabilities());\n+            setCapability(SystemCapabilityType.PRERECORDED_SPEECH, response.getPrerecordedSpeech());\n+        }\n+    }\n \n     private void setupRpcListeners() {\n-        rpcListener = new OnRPCListener() {\n+        OnRPCListener rpcListener = new OnRPCListener() {\n             @Override\n             public void onReceived(RPCMessage message) {\n                 if (message != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc5NzEyMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r472797123", "bodyText": "On lines 552 and 554, instead of Log.d you could use DebugTool.log...", "author": "santhanamk", "createdAt": "2020-08-19T07:20:56Z", "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java", "diffHunk": "@@ -534,6 +549,11 @@ public void addOnSystemCapabilityListener(final SystemCapabilityType systemCapab\n \t\t\t\tonSystemCapabilityListeners.get(systemCapabilityType).add(listener);\n \t\t\t}\n \t\t}\n+\t\tLog.d(\"MyTagLog\", \"add capabilityListener\");", "originalCommit": "e64d5879fa5d471514ebea3c6d07fb6082562cd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\nindex 1c569e082..c94f7193c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n\n@@ -357,329 +344,311 @@ abstract class BaseSystemCapabilityManager {\n             }\n         };\n \n-\t\tif (callback != null) {\n-\t\t\tcallback.addOnRPCListener(FunctionID.GET_SYSTEM_CAPABILITY, rpcListener);\n-\t\t\tcallback.addOnRPCListener(FunctionID.SET_DISPLAY_LAYOUT, rpcListener);\n-\t\t\tcallback.addOnRPCListener(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED, rpcListener);\n-\t\t\tcallback.addOnRPCListener(FunctionID.ON_HMI_STATUS, rpcListener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Sets a capability in the cached map. This should only be done when an RPC is received and contains updates to the capability\n-\t * that is being cached in the SystemCapabilityManager.\n-\t * @param systemCapabilityType the system capability type that will be set\n-\t * @param capability the value of the capability that will be set\n-\t */\n-\tsynchronized void setCapability(SystemCapabilityType systemCapabilityType, Object capability) {\n-\t\tcachedSystemCapabilities.put(systemCapabilityType, capability);\n-\t\tnotifyListeners(systemCapabilityType, capability);\n-\t}\n-\n-\t/**\n-\t * Notifies listeners in the list about the new retrieved capability\n-\t * @param systemCapabilityType the system capability type that was retrieved\n-\t * @param capability the system capability value that was retrieved\n-\t */\n-\tprivate void notifyListeners(SystemCapabilityType systemCapabilityType, Object capability) {\n-\t\tsynchronized(LISTENER_LOCK) {\n-\t\t\tCopyOnWriteArrayList<OnSystemCapabilityListener> listeners = onSystemCapabilityListeners.get(systemCapabilityType);\n-\t\t\tif (listeners != null && listeners.size() > 0) {\n-\t\t\t\tfor (OnSystemCapabilityListener listener : listeners) {\n-\t\t\t\t\tlistener.onCapabilityRetrieved(capability);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Ability to see if the connected module supports the given capability. Useful to check before\n-\t * attempting to query for capabilities that require asynchronous calls to initialize.\n-\t * @param type the SystemCapabilityType that is to be checked\n-\t * @return if that capability is supported with the current, connected module\n-\t */\n-\tpublic boolean isCapabilitySupported(SystemCapabilityType type) {\n-\t\tif (cachedSystemCapabilities.get(type) != null) {\n-\t\t\t//The capability exists in the map and is not null\n-\t\t\treturn true;\n-\t\t} else if (cachedSystemCapabilities.containsKey(SystemCapabilityType.HMI)) {\n-\t\t\tHMICapabilities hmiCapabilities = ((HMICapabilities) cachedSystemCapabilities.get(SystemCapabilityType.HMI));\n-\t\t\tVersion rpcVersion = null;\n-\t\t\tif (callback != null) {\n-\t\t\t\tSdlMsgVersion version = callback.getSdlMsgVersion();\n-\t\t\t\tif (version != null) {\n-\t\t\t\t\trpcVersion = new Version(version.getMajorVersion(), version.getMinorVersion(), version.getPatchVersion());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (hmiCapabilities != null) {\n-\t\t\t\tswitch (type) {\n-\t\t\t\t\tcase NAVIGATION:\n-\t\t\t\t\t\treturn hmiCapabilities.isNavigationAvailable();\n-\t\t\t\t\tcase PHONE_CALL:\n-\t\t\t\t\t\treturn hmiCapabilities.isPhoneCallAvailable();\n-\t\t\t\t\tcase VIDEO_STREAMING:\n-\t\t\t\t\t\tif (rpcVersion != null) {\n-\t\t\t\t\t\t\tif (rpcVersion.isBetween(new Version(3, 0, 0), new Version(4, 4, 0)) >= 0) {\n-\t\t\t\t\t\t\t\t//This was before the system capability feature was added so check if\n-\t\t\t\t\t\t\t\t// graphics are supported instead\n-\t\t\t\t\t\t\t\tDisplayCapabilities displayCapabilities = (DisplayCapabilities) getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\t\t\t\t\tif (displayCapabilities != null) {\n-\t\t\t\t\t\t\t\t\treturn displayCapabilities.getGraphicSupported() != null && displayCapabilities.getGraphicSupported();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn hmiCapabilities.isVideoStreamingAvailable();\n-\t\t\t\t\tcase REMOTE_CONTROL:\n-\t\t\t\t\t\treturn hmiCapabilities.isRemoteControlAvailable();\n-\t\t\t\t\tcase APP_SERVICES:\n-\t\t\t\t\t\tif (rpcVersion != null) {\n-\t\t\t\t\t\t\tif (rpcVersion.getMajor() == 5 && rpcVersion.getMinor() == 1) {\n-\t\t\t\t\t\t\t\t//This is a corner case that the param was not available in 5.1.0, but\n-\t\t\t\t\t\t\t\t//the app services feature was available.\n-\t\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn hmiCapabilities.isAppServicesAvailable();\n-\t\t\t\t\tcase DISPLAYS:\n-\t\t\t\t\t\treturn hmiCapabilities.isDisplaysCapabilityAvailable();\n-\t\t\t\t\tcase SEAT_LOCATION:\n-\t\t\t\t\t\treturn hmiCapabilities.isSeatLocationAvailable();\n-\t\t\t\t\tcase DRIVER_DISTRACTION:\n-\t\t\t\t\t\treturn hmiCapabilities.isDriverDistractionAvailable();\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Checks is subscriptions are available on the connected head unit.\n-\t * @return True if subscriptions are supported. False if not.\n-\t */\n-\tpublic boolean supportsSubscriptions() {\n-\t\tif (callback != null && callback.getSdlMsgVersion() != null) {\n-\t\t\tVersion onSystemCapabilityNotificationRPCVersion = new Version(5, 1, 0);\n-\t\t\tVersion headUnitRPCVersion = new Version(callback.getSdlMsgVersion());\n-\t\t\treturn headUnitRPCVersion.isNewerThan(onSystemCapabilityNotificationRPCVersion) >= 0;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Checks if the supplied capability type is currently subscribed for or not\n-\t * @param systemCapabilityType type of capability desired\n-\t * @return true if subscribed and false if not\n-\t */\n-\tprivate boolean isSubscribedToSystemCapability(SystemCapabilityType systemCapabilityType) {\n-\t\treturn Boolean.TRUE.equals(systemCapabilitiesSubscriptionStatus.get(systemCapabilityType));\n-\t}\n-\n-\t/** Gets the capability object that corresponds to the supplied capability type by returning the currently cached value immediately (or null) as well as calling the listener immediately with the cached value, if available. If not available, the listener will retrieve a new value and return that when the head unit responds.\n-\t * <strong>If capability is not cached, the method will return null and trigger the supplied listener when the capability becomes available</strong>\n-\t * @param systemCapabilityType type of capability desired\n-\t * @param scListener callback to execute upon retrieving capability\n-\t * @param subscribe flag to subscribe to updates of the supplied capability type. True means subscribe; false means cancel subscription; null means don't change current subscription status.\n-\t * @param forceUpdate flag to force getting a new fresh copy of the capability from the head unit even if it is cached\n-\t * @return desired capability if it is cached in the manager, otherwise returns a null object and works in the background to retrieve the capability for the next call\n-\t */\n-\tprivate Object getCapabilityPrivate(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener scListener, final Boolean subscribe, final boolean forceUpdate) {\n-\t\tObject cachedCapability = cachedSystemCapabilities.get(systemCapabilityType);\n-\n-\t\t// No need to force update if the app is subscribed to that type because updated values will be received via notifications anyway\n-\t\tboolean shouldForceUpdate = forceUpdate && !isSubscribedToSystemCapability(systemCapabilityType);\n-\t\tboolean shouldUpdateSystemCapabilitySubscription = (subscribe != null) && (subscribe != isSubscribedToSystemCapability(systemCapabilityType)) && supportsSubscriptions();\n-\t\tboolean shouldSendGetCapabilityRequest = shouldForceUpdate || (cachedCapability == null) || shouldUpdateSystemCapabilitySubscription;\n-\t\tboolean shouldCallListenerWithCachedValue = (cachedCapability != null) && (scListener != null) && !shouldSendGetCapabilityRequest;\n-\n-\t\tif (shouldCallListenerWithCachedValue) {\n-\t\t\tscListener.onCapabilityRetrieved(cachedCapability);\n-\t\t}\n-\n-\t\tif (shouldSendGetCapabilityRequest) {\n-\t\t\tretrieveCapability(systemCapabilityType, scListener, subscribe);\n-\t\t}\n-\n-\t\treturn cachedCapability;\n-\t}\n-\n-\t/** Gets the capability object that corresponds to the supplied capability type by returning the currently cached value immediately (or null) as well as calling the listener immediately with the cached value, if available. If not available, the listener will retrieve a new value and return that when the head unit responds.\n-\t * <strong>If capability is not cached, the method will return null and trigger the supplied listener when the capability becomes available</strong>\n-\t * @param systemCapabilityType type of capability desired\n-\t * @param scListener callback to execute upon retrieving capability\n-\t * @param forceUpdate flag to force getting a new fresh copy of the capability from the head unit even if it is cached\n-\t * @return desired capability if it is cached in the manager, otherwise returns a null object\n-\t */\n-\tpublic Object getCapability(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener scListener, final boolean forceUpdate) {\n-\t\treturn getCapabilityPrivate(systemCapabilityType, scListener, null, forceUpdate);\n-\t}\n-\n-\t/** Gets the capability object that corresponds to the supplied capability type by calling the listener immediately with the cached value, if available. If not available, the listener will retrieve a new value and return that when the head unit responds.\n-\t * @param systemCapabilityType Type of capability desired\n-\t * @param scListener callback to execute upon retrieving capability\n-\t * @deprecated use {@link #getCapability(SystemCapabilityType, OnSystemCapabilityListener, boolean)} instead.\n-\t */\n-\t@Deprecated\n-\tpublic void getCapability(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener scListener) {\n-\t\tgetCapabilityPrivate(systemCapabilityType, scListener, null, false);\n-\t}\n-\n-\t/** Gets the capability object that corresponds to the supplied capability type by returning the currently cached value immediately if available. Otherwise returns a null object and works in the background to retrieve the capability for the next call\n-\t * @param systemCapabilityType Type of capability desired\n-\t * @return Desired capability if it is cached in the manager, otherwise returns null\n-\t * @deprecated use {@link #getCapability(SystemCapabilityType, OnSystemCapabilityListener, boolean)} instead.\n-\t */\n-\t@Deprecated\n-\tpublic Object getCapability(final SystemCapabilityType systemCapabilityType) {\n-\t\treturn getCapabilityPrivate(systemCapabilityType, null, null, false);\n-\t}\n-\n-\t/**\n-\t * Adds a listener to be called whenever a new capability is retrieved. This method automatically subscribes to the supplied capability type and may call the listener multiple times if there are future updates, unlike getCapability() methods, which only call the listener one time.\n-\t * @param systemCapabilityType Type of capability desired\n-\t * @param listener callback to execute upon retrieving capability\n-\t */\n-\tpublic void addOnSystemCapabilityListener(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener listener) {\n-\t\tsynchronized(LISTENER_LOCK) {\n-\t\t\tif (systemCapabilityType != null && listener != null) {\n-\t\t\t\tif (onSystemCapabilityListeners.get(systemCapabilityType) == null) {\n-\t\t\t\t\tonSystemCapabilityListeners.put(systemCapabilityType, new CopyOnWriteArrayList<OnSystemCapabilityListener>());\n-\t\t\t\t}\n-\t\t\t\tonSystemCapabilityListeners.get(systemCapabilityType).add(listener);\n-\t\t\t}\n-\t\t}\n-\t\tLog.d(\"MyTagLog\", \"add capabilityListener\");\n-\t\tif (systemCapabilityType != null) {\n-\t\t\tLog.d(\"MyTagLog\", systemCapabilityType.name());\n-\t\t}\n-\n-\t\tgetCapabilityPrivate(systemCapabilityType, listener, true, false);\n-\t}\n-\n-\t/**\n-\t * Removes an OnSystemCapabilityListener that was previously added\n-\t * @param systemCapabilityType Type of capability\n-\t * @param listener the listener that should be removed\n-\t * @return boolean that represents whether the removal was successful or not\n-\t */\n-\tpublic boolean removeOnSystemCapabilityListener(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener listener) {\n-\t\tboolean success = false;\n-\t\tsynchronized(LISTENER_LOCK) {\n-\t\t\tif (onSystemCapabilityListeners != null\n-\t\t\t\t\t&& systemCapabilityType != null\n-\t\t\t\t\t&& listener != null\n-\t\t\t\t\t&& onSystemCapabilityListeners.get(systemCapabilityType) != null) {\n-\t\t\t\tsuccess = onSystemCapabilityListeners.get(systemCapabilityType).remove(listener);\n-\t\t\t\t// If the last listener for the supplied capability type is removed, unsubscribe from the capability type\n-\t\t\t\tif (success && onSystemCapabilityListeners.get(systemCapabilityType).isEmpty() && isSubscribedToSystemCapability(systemCapabilityType) && systemCapabilityType != SystemCapabilityType.DISPLAYS) {\n-\t\t\t\t\tretrieveCapability(systemCapabilityType, null, false);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn success;\n-\t}\n-\n-\t/** Sends a GetSystemCapability request for the supplied SystemCapabilityType and call the listener's callback if the systemCapabilityType is queryable\n-\t * @param systemCapabilityType Type of capability desired\n-\t * @param subscribe flag to subscribe to updates of the supplied capability type. True means subscribe; false means cancel subscription; null means don't change current subscription status.\n-\t */\n-\tprivate void retrieveCapability(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener scListener, final Boolean subscribe) {\n-\t\tif (currentHMILevel != null && currentHMILevel.equals(HMILevel.HMI_NONE) && systemCapabilityType != SystemCapabilityType.VIDEO_STREAMING) {\n-\t\t\tString message = String.format(\"Attempted to update type: %s in HMI level NONE, which is not allowed. \" +\n-\t\t\t\t\t\"Please wait until you are in HMI BACKGROUND, LIMITED, or FULL before attempting to update any SystemCapabilityType\", systemCapabilityType);\n-\t\t\tDebugTool.logError(TAG, message);\n-\t\t\tif (scListener != null) {\n-\t\t\t\tscListener.onError(message);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!systemCapabilityType.isQueryable() || systemCapabilityType == SystemCapabilityType.DISPLAYS) {\n-\t\t\tString message = \"This systemCapabilityType cannot be queried for\";\n-\t\t\tDebugTool.logError(TAG, message);\n-\t\t\tif (scListener != null) {\n-\t\t\t\tscListener.onError(message);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tfinal GetSystemCapability request = new GetSystemCapability();\n-\t\trequest.setSystemCapabilityType(systemCapabilityType);\n+        if (callback != null) {\n+            callback.addOnRPCListener(FunctionID.GET_SYSTEM_CAPABILITY, rpcListener);\n+            callback.addOnRPCListener(FunctionID.SET_DISPLAY_LAYOUT, rpcListener);\n+            callback.addOnRPCListener(FunctionID.ON_SYSTEM_CAPABILITY_UPDATED, rpcListener);\n+            callback.addOnRPCListener(FunctionID.ON_HMI_STATUS, rpcListener);\n+        }\n+    }\n+\n+    /**\n+     * Sets a capability in the cached map. This should only be done when an RPC is received and contains updates to the capability\n+     * that is being cached in the SystemCapabilityManager.\n+     *\n+     * @param systemCapabilityType the system capability type that will be set\n+     * @param capability           the value of the capability that will be set\n+     */\n+    synchronized void setCapability(SystemCapabilityType systemCapabilityType, Object capability) {\n+        cachedSystemCapabilities.put(systemCapabilityType, capability);\n+        notifyListeners(systemCapabilityType, capability);\n+    }\n+\n+    /**\n+     * Notifies listeners in the list about the new retrieved capability\n+     *\n+     * @param systemCapabilityType the system capability type that was retrieved\n+     * @param capability           the system capability value that was retrieved\n+     */\n+    private void notifyListeners(SystemCapabilityType systemCapabilityType, Object capability) {\n+        synchronized (LISTENER_LOCK) {\n+            CopyOnWriteArrayList<OnSystemCapabilityListener> listeners = onSystemCapabilityListeners.get(systemCapabilityType);\n+            if (listeners != null && listeners.size() > 0) {\n+                for (OnSystemCapabilityListener listener : listeners) {\n+                    listener.onCapabilityRetrieved(capability);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Ability to see if the connected module supports the given capability. Useful to check before\n+     * attempting to query for capabilities that require asynchronous calls to initialize.\n+     *\n+     * @param type the SystemCapabilityType that is to be checked\n+     * @return if that capability is supported with the current, connected module\n+     */\n+    public boolean isCapabilitySupported(SystemCapabilityType type) {\n+        if (cachedSystemCapabilities.get(type) != null) {\n+            //The capability exists in the map and is not null\n+            return true;\n+        } else if (cachedSystemCapabilities.containsKey(SystemCapabilityType.HMI)) {\n+            HMICapabilities hmiCapabilities = ((HMICapabilities) cachedSystemCapabilities.get(SystemCapabilityType.HMI));\n+            Version rpcVersion = null;\n+            if (callback != null) {\n+                SdlMsgVersion version = callback.getSdlMsgVersion();\n+                if (version != null) {\n+                    rpcVersion = new Version(version.getMajorVersion(), version.getMinorVersion(), version.getPatchVersion());\n+                }\n+            }\n+            if (hmiCapabilities != null) {\n+                switch (type) {\n+                    case NAVIGATION:\n+                        return hmiCapabilities.isNavigationAvailable();\n+                    case PHONE_CALL:\n+                        return hmiCapabilities.isPhoneCallAvailable();\n+                    case VIDEO_STREAMING:\n+                        if (rpcVersion != null) {\n+                            if (rpcVersion.isBetween(new Version(3, 0, 0), new Version(4, 4, 0)) >= 0) {\n+                                //This was before the system capability feature was added so check if\n+                                // graphics are supported instead\n+                                DisplayCapabilities displayCapabilities = (DisplayCapabilities) getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                                if (displayCapabilities != null) {\n+                                    return displayCapabilities.getGraphicSupported() != null && displayCapabilities.getGraphicSupported();\n+                                }\n+                            }\n+                        }\n+                        return hmiCapabilities.isVideoStreamingAvailable();\n+                    case REMOTE_CONTROL:\n+                        return hmiCapabilities.isRemoteControlAvailable();\n+                    case APP_SERVICES:\n+                        if (rpcVersion != null) {\n+                            if (rpcVersion.getMajor() == 5 && rpcVersion.getMinor() == 1) {\n+                                //This is a corner case that the param was not available in 5.1.0, but\n+                                //the app services feature was available.\n+                                return true;\n+                            }\n+                        }\n+                        return hmiCapabilities.isAppServicesAvailable();\n+                    case DISPLAYS:\n+                        return hmiCapabilities.isDisplaysCapabilityAvailable();\n+                    case SEAT_LOCATION:\n+                        return hmiCapabilities.isSeatLocationAvailable();\n+                    case DRIVER_DISTRACTION:\n+                        return hmiCapabilities.isDriverDistractionAvailable();\n+                    default:\n+                        return false;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks is subscriptions are available on the connected head unit.\n+     *\n+     * @return True if subscriptions are supported. False if not.\n+     */\n+    public boolean supportsSubscriptions() {\n+        if (callback != null && callback.getSdlMsgVersion() != null) {\n+            Version onSystemCapabilityNotificationRPCVersion = new Version(5, 1, 0);\n+            Version headUnitRPCVersion = new Version(callback.getSdlMsgVersion());\n+            return headUnitRPCVersion.isNewerThan(onSystemCapabilityNotificationRPCVersion) >= 0;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the supplied capability type is currently subscribed for or not\n+     *\n+     * @param systemCapabilityType type of capability desired\n+     * @return true if subscribed and false if not\n+     */\n+    private boolean isSubscribedToSystemCapability(SystemCapabilityType systemCapabilityType) {\n+        return Boolean.TRUE.equals(systemCapabilitiesSubscriptionStatus.get(systemCapabilityType));\n+    }\n+\n+    /**\n+     * Gets the capability object that corresponds to the supplied capability type by returning the currently cached value immediately (or null) as well as calling the listener immediately with the cached value, if available. If not available, the listener will retrieve a new value and return that when the head unit responds.\n+     * <strong>If capability is not cached, the method will return null and trigger the supplied listener when the capability becomes available</strong>\n+     *\n+     * @param systemCapabilityType type of capability desired\n+     * @param scListener           callback to execute upon retrieving capability\n+     * @param subscribe            flag to subscribe to updates of the supplied capability type. True means subscribe; false means cancel subscription; null means don't change current subscription status.\n+     * @param forceUpdate          flag to force getting a new fresh copy of the capability from the head unit even if it is cached\n+     * @return desired capability if it is cached in the manager, otherwise returns a null object and works in the background to retrieve the capability for the next call\n+     */\n+    private Object getCapabilityPrivate(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener scListener, final Boolean subscribe, final boolean forceUpdate) {\n+        Object cachedCapability = cachedSystemCapabilities.get(systemCapabilityType);\n+\n+        // No need to force update if the app is subscribed to that type because updated values will be received via notifications anyway\n+        boolean shouldForceUpdate = forceUpdate && !isSubscribedToSystemCapability(systemCapabilityType);\n+        boolean shouldUpdateSystemCapabilitySubscription = (subscribe != null) && (subscribe != isSubscribedToSystemCapability(systemCapabilityType)) && supportsSubscriptions();\n+        boolean shouldSendGetCapabilityRequest = shouldForceUpdate || (cachedCapability == null) || shouldUpdateSystemCapabilitySubscription;\n+        boolean shouldCallListenerWithCachedValue = (cachedCapability != null) && (scListener != null) && !shouldSendGetCapabilityRequest;\n+\n+        if (shouldCallListenerWithCachedValue) {\n+            scListener.onCapabilityRetrieved(cachedCapability);\n+        }\n+\n+        if (shouldSendGetCapabilityRequest) {\n+            retrieveCapability(systemCapabilityType, scListener, subscribe);\n+        }\n+\n+        return cachedCapability;\n+    }\n+\n+    /**\n+     * Gets the capability object that corresponds to the supplied capability type by returning the currently cached value immediately (or null) as well as calling the listener immediately with the cached value, if available. If not available, the listener will retrieve a new value and return that when the head unit responds.\n+     * <strong>If capability is not cached, the method will return null and trigger the supplied listener when the capability becomes available</strong>\n+     *\n+     * @param systemCapabilityType type of capability desired\n+     * @param scListener           callback to execute upon retrieving capability\n+     * @param forceUpdate          flag to force getting a new fresh copy of the capability from the head unit even if it is cached\n+     * @return desired capability if it is cached in the manager, otherwise returns a null object\n+     */\n+    public Object getCapability(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener scListener, final boolean forceUpdate) {\n+        return getCapabilityPrivate(systemCapabilityType, scListener, null, forceUpdate);\n+    }\n+\n+    /**\n+     * Adds a listener to be called whenever a new capability is retrieved. This method automatically subscribes to the supplied capability type and may call the listener multiple times if there are future updates, unlike getCapability() methods, which only call the listener one time.\n+     *\n+     * @param systemCapabilityType Type of capability desired\n+     * @param listener             callback to execute upon retrieving capability\n+     */\n+    public void addOnSystemCapabilityListener(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener listener) {\n+        synchronized (LISTENER_LOCK) {\n+            if (systemCapabilityType != null && listener != null) {\n+                if (onSystemCapabilityListeners.get(systemCapabilityType) == null) {\n+                    onSystemCapabilityListeners.put(systemCapabilityType, new CopyOnWriteArrayList<OnSystemCapabilityListener>());\n+                }\n+                onSystemCapabilityListeners.get(systemCapabilityType).add(listener);\n+            }\n+        }\n+        getCapabilityPrivate(systemCapabilityType, listener, true, false);\n+    }\n+\n+    /**\n+     * Removes an OnSystemCapabilityListener that was previously added\n+     *\n+     * @param systemCapabilityType Type of capability\n+     * @param listener             the listener that should be removed\n+     * @return boolean that represents whether the removal was successful or not\n+     */\n+    public boolean removeOnSystemCapabilityListener(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener listener) {\n+        boolean success = false;\n+        synchronized (LISTENER_LOCK) {\n+            if (onSystemCapabilityListeners != null\n+                    && systemCapabilityType != null\n+                    && listener != null\n+                    && onSystemCapabilityListeners.get(systemCapabilityType) != null) {\n+                success = onSystemCapabilityListeners.get(systemCapabilityType).remove(listener);\n+                // If the last listener for the supplied capability type is removed, unsubscribe from the capability type\n+                if (success && onSystemCapabilityListeners.get(systemCapabilityType).isEmpty() && isSubscribedToSystemCapability(systemCapabilityType) && systemCapabilityType != SystemCapabilityType.DISPLAYS) {\n+                    retrieveCapability(systemCapabilityType, null, false);\n+                }\n+            }\n+        }\n+        return success;\n+    }\n+\n+    /**\n+     * Sends a GetSystemCapability request for the supplied SystemCapabilityType and call the listener's callback if the systemCapabilityType is queryable\n+     *\n+     * @param systemCapabilityType Type of capability desired\n+     * @param subscribe            flag to subscribe to updates of the supplied capability type. True means subscribe; false means cancel subscription; null means don't change current subscription status.\n+     */\n+    private void retrieveCapability(final SystemCapabilityType systemCapabilityType, final OnSystemCapabilityListener scListener, final Boolean subscribe) {\n+        if (currentHMILevel != null && currentHMILevel.equals(HMILevel.HMI_NONE)) {\n+            String message = String.format(\"Attempted to update type: %s in HMI level NONE, which is not allowed. \" +\n+                    \"Please wait until you are in HMI BACKGROUND, LIMITED, or FULL before attempting to update any SystemCapabilityType\", systemCapabilityType);\n+            DebugTool.logError(TAG, message);\n+            if (scListener != null) {\n+                scListener.onError(message);\n+            }\n+            return;\n+        }\n+        if (!systemCapabilityType.isQueryable() || systemCapabilityType == SystemCapabilityType.DISPLAYS) {\n+            String message = \"This systemCapabilityType cannot be queried for\";\n+            DebugTool.logError(TAG, message);\n+            if (scListener != null) {\n+                scListener.onError(message);\n+            }\n+            return;\n+        }\n+        final GetSystemCapability request = new GetSystemCapability();\n+        request.setSystemCapabilityType(systemCapabilityType);\n \n \t\t/*\n \t\tThe subscription flag in the request should be set based on multiple variables:\n-\t\t- if subscribe is null (no change), shouldSubscribe = current subscription status, or false if the HU does not support subscriptions\n-\t\t- if subscribe is false, then shouldSubscribe = false\n-\t\t- if subscribe is true and the HU supports subscriptions, then shouldSubscribe = true\n+\t\t- if subscribe is null (no change), willSubscribe = current subscription status, or false if the HU does not support subscriptions\n+\t\t- if subscribe is false, then willSubscribe = false\n+\t\t- if subscribe is true and the HU supports subscriptions, then willSubscribe = true\n \t\t*/\n-\t\tboolean shouldSubscribe = (subscribe != null) ? subscribe : isSubscribedToSystemCapability(systemCapabilityType);\n-\t\tfinal boolean willSubscribe = shouldSubscribe && supportsSubscriptions();\n-\t\trequest.setSubscribe(willSubscribe);\n-\t\trequest.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\tif (response.getSuccess()) {\n-\t\t\t\t\tObject retrievedCapability = ((GetSystemCapabilityResponse) response).getSystemCapability().getCapabilityForType(systemCapabilityType);\n-\t\t\t\t\tsetCapability(systemCapabilityType, retrievedCapability);\n-\t\t\t\t\t// If the listener is not included in the onSystemCapabilityListeners map, then notify it\n-\t\t\t\t\t// This will be triggered if we are just getting capability without adding a listener to the map\n-\t\t\t\t\tif (scListener != null) {\n-\t\t\t\t\t\tsynchronized (LISTENER_LOCK) {\n-\t\t\t\t\t\t\tCopyOnWriteArrayList<OnSystemCapabilityListener> notifiedListeners = onSystemCapabilityListeners.get(systemCapabilityType);\n-\t\t\t\t\t\t\tboolean listenerAlreadyNotified = (notifiedListeners != null) && notifiedListeners.contains(scListener);\n-\t\t\t\t\t\t\tif (!listenerAlreadyNotified) {\n-\t\t\t\t\t\t\t\tscListener.onCapabilityRetrieved(retrievedCapability);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (supportsSubscriptions()) {\n-\t\t\t\t\t\tsystemCapabilitiesSubscriptionStatus.put(systemCapabilityType, willSubscribe);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tif (scListener != null) {\n-\t\t\t\t\t\tscListener.onError(response.getInfo());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\tif (scListener != null) {\n-\t\t\t\t\tscListener.onError(info);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\t\trequest.setCorrelationID(CorrelationIdGenerator.generateId());\n-\n-\t\tif (callback != null) {\n-\t\t\tcallback.sendRPC(request);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Converts a capability object into a list.\n-\t * @param object the capability that needs to be converted\n-\t * @param classType The class type of that should be contained in the list\n-\t * @return a List of capabilities if object is instance of List, otherwise it will return null.\n-\t */\n-\t@SuppressWarnings({\"unchecked\"})\n-\tpublic static <T> List<T> convertToList(Object object, Class<T> classType) {\n-\t\tif (classType != null && object != null && object instanceof List) {\n-\t\t\tList list = (List) object;\n-\t\t\tif (!list.isEmpty()) {\n-\t\t\t\tif (classType.isInstance(list.get(0))) {\n-\t\t\t\t\treturn (List<T>) object;\n-\t\t\t\t} else {\n-\t\t\t\t\t//The list is not of the correct list type\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t//We return a new list of type T instead of null because while we don't know if\n-\t\t\t\t//the original list was of type T we want to ensure that we don't throw a cast class exception\n-\t\t\t\t//but still\n-\t\t\t\treturn new ArrayList<T>();\n-\t\t\t}\n-\t\t} else {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n+        boolean shouldSubscribe = (subscribe != null) ? subscribe : isSubscribedToSystemCapability(systemCapabilityType);\n+        final boolean willSubscribe = shouldSubscribe && supportsSubscriptions();\n+        request.setSubscribe(willSubscribe);\n+        request.setOnRPCResponseListener(new OnRPCResponseListener() {\n+            @Override\n+            public void onResponse(int correlationId, RPCResponse response) {\n+                if (response.getSuccess()) {\n+                    Object retrievedCapability = ((GetSystemCapabilityResponse) response).getSystemCapability().getCapabilityForType(systemCapabilityType);\n+                    setCapability(systemCapabilityType, retrievedCapability);\n+                    // If the listener is not included in the onSystemCapabilityListeners map, then notify it\n+                    // This will be triggered if we are just getting capability without adding a listener to the map\n+                    if (scListener != null) {\n+                        synchronized (LISTENER_LOCK) {\n+                            CopyOnWriteArrayList<OnSystemCapabilityListener> notifiedListeners = onSystemCapabilityListeners.get(systemCapabilityType);\n+                            boolean listenerAlreadyNotified = (notifiedListeners != null) && notifiedListeners.contains(scListener);\n+                            if (!listenerAlreadyNotified) {\n+                                scListener.onCapabilityRetrieved(retrievedCapability);\n+                            }\n+                        }\n+                    }\n+                    if (supportsSubscriptions()) {\n+                        systemCapabilitiesSubscriptionStatus.put(systemCapabilityType, willSubscribe);\n+                    }\n+                } else {\n+                    if (scListener != null) {\n+                        scListener.onError(response.getInfo());\n+                    }\n+                }\n+            }\n+        });\n+        request.setCorrelationID(CorrelationIdGenerator.generateId());\n+\n+        if (callback != null) {\n+            callback.sendRPC(request);\n+        }\n+    }\n+\n+    /**\n+     * Converts a capability object into a list.\n+     *\n+     * @param object    the capability that needs to be converted\n+     * @param classType The class type of that should be contained in the list\n+     * @return a List of capabilities if object is instance of List, otherwise it will return null.\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    public static <T> List<T> convertToList(Object object, Class<T> classType) {\n+        if (classType != null && object != null && object instanceof List) {\n+            List list = (List) object;\n+            if (!list.isEmpty()) {\n+                if (classType.isInstance(list.get(0))) {\n+                    return (List<T>) object;\n+                } else {\n+                    //The list is not of the correct list type\n+                    return null;\n+                }\n+            } else {\n+                //We return a new list of type T instead of null because while we don't know if\n+                //the original list was of type T we want to ensure that we don't throw a cast class exception\n+                //but still\n+                return new ArrayList<>();\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n }\n"}}, {"oid": "992ae762be81fe57c51d72d2d3fccdf7c47555c9", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/992ae762be81fe57c51d72d2d3fccdf7c47555c9", "message": "[VideoStreaming]\n     - Fix tests", "committedDate": "2020-08-19T10:12:24Z", "type": "commit"}, {"oid": "036bb2cfc4699b01ac7481ddd355ca23fedb55f8", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/036bb2cfc4699b01ac7481ddd355ca23fedb55f8", "message": "Fix merge", "committedDate": "2020-08-19T10:21:12Z", "type": "commit"}, {"oid": "a65b8944e8b0bae1d79859965c15fb11565179c3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a65b8944e8b0bae1d79859965c15fb11565179c3", "message": "Merge branch 'feature/0296_possibility_to_update_video_streaming_capabilities' of https://github.com/LuxoftSDL/sdl_java_suite into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tbase/src/main/java/com/smartdevicelink/protocol/enums/FunctionID.java", "committedDate": "2020-08-19T10:23:22Z", "type": "commit"}, {"oid": "7a95ce91f0d4e37bee70768f0c997773cd0d26ec", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/7a95ce91f0d4e37bee70768f0c997773cd0d26ec", "message": "[VideoStreaming]\n    - Remove boilerplate from SdlService\n    - Remote logs from BaseSystemCapabilityManager.java", "committedDate": "2020-08-19T10:35:15Z", "type": "commit"}, {"oid": "3aaf4bdd2416b05b748f2cb83f56692b7c6fe2c5", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3aaf4bdd2416b05b748f2cb83f56692b7c6fe2c5", "message": "[VideoStreaming]\n    - Remove logs from VideoStreamManager.java", "committedDate": "2020-08-19T10:36:13Z", "type": "commit"}, {"oid": "e2bf1b3b04ee5adbd5257d0cd4d6311dc65cca8e", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e2bf1b3b04ee5adbd5257d0cd4d6311dc65cca8e", "message": "[VideoStreaming]\n    - Remove logs from VirtualDisplayEncoder", "committedDate": "2020-08-19T10:44:45Z", "type": "commit"}, {"oid": "fe17e5a24f309d0c472cea7c05c7b9f2f505ffbe", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/fe17e5a24f309d0c472cea7c05c7b9f2f505ffbe", "message": "[VideoStreaming]\n    - Add valueForString for AppCapabilityType.java", "committedDate": "2020-08-19T10:46:08Z", "type": "commit"}, {"oid": "1747be61f0299e92810d3b62f33cb9d54326e4b5", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/1747be61f0299e92810d3b62f33cb9d54326e4b5", "message": "[VideoStreaming]\n    - CleanUp VideoStreamingParameters", "committedDate": "2020-08-19T10:47:56Z", "type": "commit"}, {"oid": "72d1e91979b0075afb02f02a0710c8680c697a71", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/72d1e91979b0075afb02f02a0710c8680c697a71", "message": "[VideoStreaming]\n    - CleanUp AppCapabilityType.java\n    - CleanUp VideoStreamingCapability.java", "committedDate": "2020-08-19T10:57:16Z", "type": "commit"}, {"oid": "6f6ac80b3337f798cc02b42f8f842f6b2f50cb38", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/6f6ac80b3337f798cc02b42f8f842f6b2f50cb38", "message": "[VideoStreaming]\n    - CleanUp AppCapability", "committedDate": "2020-08-19T10:59:37Z", "type": "commit"}, {"oid": "cec21bb8699e83d49a8f95181544c81c430a37e0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/cec21bb8699e83d49a8f95181544c81c430a37e0", "message": "[VideoStreaming]\n    - CleanUp AppCapability", "committedDate": "2020-08-19T11:00:20Z", "type": "commit"}, {"oid": "530e9c0b363760a9993ca2d605f9b44048fc86cd", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/530e9c0b363760a9993ca2d605f9b44048fc86cd", "message": "[VideoStreaming]\n    - CleanUp MainActivity", "committedDate": "2020-08-19T11:06:11Z", "type": "commit"}, {"oid": "4bc2fcd0f588609986fb04f4deb3d7278ee21765", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/4bc2fcd0f588609986fb04f4deb3d7278ee21765", "message": "[VideoStreaming]\n    - Add AppCapabilityTypeTests.java", "committedDate": "2020-08-19T12:15:53Z", "type": "commit"}, {"oid": "f3f81e5920d0cf3fce0efd991ae75cd7739c3ae8", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f3f81e5920d0cf3fce0efd991ae75cd7739c3ae8", "message": "[VideoStreaming]\n    - Cleanup updateCachedVideoStreamingCapabilities", "committedDate": "2020-08-19T12:21:22Z", "type": "commit"}, {"oid": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/6994540523a3b5cda4c60e35fe5e779875f6caa3", "message": "[VideoStreaming]\n    - Add tests", "committedDate": "2020-08-19T14:08:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MDgzNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473180835", "bodyText": "Per the proposal, VideoStreamingRange should be defined as:\n\"...\npublic class VideoStreamingRange { private Resolution minResolution; private Resolution maxResolution; private Double minAspectRatio; private Double maxAspectRatio; private Double minScreenDiagonal; }\n...\"\nDo you need to change your variable definitions to match with the proposal?", "author": "santhanamk", "createdAt": "2020-08-19T16:56:03Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class VideoStreamingRange {", "originalCommit": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex c69f493b8..6f5f06c31 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -1,60 +1,63 @@\n package com.smartdevicelink.managers.video.resolution;\n \n public class VideoStreamingRange {\n-    private Resolution minSupportedResolution;\n-    private Resolution maxSupportedResolution;\n-    private Double maxScreenDiagonal;\n+    private Resolution minResolution;\n+    private Resolution maxResolution;\n+    private Double minScreenDiagonal;\n     private AspectRatio aspectRatio;\n \n-    public VideoStreamingRange(Resolution minSupportedResolution, Resolution maxSupportedResolution, Double maxScreenDiagonal, AspectRatio aspectRatio) {\n-        this.minSupportedResolution = minSupportedResolution;\n-        this.maxSupportedResolution = maxSupportedResolution;\n-        this.maxScreenDiagonal = maxScreenDiagonal;\n+    public VideoStreamingRange(\n+            Resolution minResolution,\n+            Resolution maxResolution,\n+            Double minScreenDiagonal,\n+            AspectRatio aspectRatio\n+    ) {\n+        this.minResolution = minResolution;\n+        this.maxResolution = maxResolution;\n+        this.minScreenDiagonal = minScreenDiagonal;\n         this.aspectRatio = aspectRatio;\n     }\n \n-    private VideoStreamingRange(){}\n+    private VideoStreamingRange() { }\n \n-    public Resolution getMinSupportedResolution() {\n-        return minSupportedResolution;\n+    public Resolution getMinResolution() {\n+        return minResolution;\n     }\n \n-    public Resolution getMaxSupportedResolution() {\n-        return maxSupportedResolution;\n+    public Resolution getMaxResolution() {\n+        return maxResolution;\n     }\n \n-    public Double getMaxScreenDiagonal() {\n-        return maxScreenDiagonal;\n+    public Double getMinScreenDiagonal() {\n+        return minScreenDiagonal;\n     }\n \n-    public AspectRatio getAspectRatio() {\n-        return aspectRatio;\n-    }\n+    public AspectRatio getAspectRatio(){ return aspectRatio; }\n \n     public static class Builder {\n         private VideoStreamingRange range = new VideoStreamingRange();\n \n         public Builder setMinSupportedResolution(Resolution minSupportedResolution) {\n-            range.minSupportedResolution = minSupportedResolution;\n+            range.minResolution = minSupportedResolution;\n             return this;\n         }\n \n         public Builder setMaxSupportedResolution(Resolution maxSupportedResolution) {\n-            range.maxSupportedResolution = maxSupportedResolution;\n+            range.maxResolution = maxSupportedResolution;\n             return this;\n         }\n \n-        public Builder setMaxScreenDiagonal(Double maxScreenDiagonal) {\n-            range.maxScreenDiagonal = maxScreenDiagonal;\n+        public Builder setMinScreenDiagonal(Double minScreenDiagonal) {\n+            range.minScreenDiagonal = minScreenDiagonal;\n             return this;\n         }\n \n-        public Builder setAspectRatio(AspectRatio aspectRatio){\n+        public Builder setAspectRatio(AspectRatio aspectRatio) {\n             range.aspectRatio = aspectRatio;\n             return this;\n         }\n \n-        public VideoStreamingRange build(){\n+        public VideoStreamingRange build() {\n             return range;\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIxNDg2OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473214868", "bodyText": "@kostyaBoss the unused import on line 35 import android util.Log' can be removed.", "author": "santhanamk", "createdAt": "2020-08-19T17:47:52Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -32,13 +32,16 @@\n \n package com.smartdevicelink.streaming.video;\n \n+import android.util.Log;", "originalCommit": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex a3e8dad97..5ab5ca931 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -32,7 +32,7 @@\n \n package com.smartdevicelink.streaming.video;\n \n-import android.util.Log;\n+import androidx.annotation.RestrictTo;\n \n import com.smartdevicelink.proxy.rpc.ImageResolution;\n import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzODYwMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473338602", "bodyText": "@kostyaBoss Do the other setters need to be added here like\npreferredCapability.setPixelPerInch(...);\npreferredCapability.setAdditionalVideoStreamingCapabilities();?", "author": "santhanamk", "createdAt": "2020-08-19T21:27:25Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -603,6 +742,120 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n \t\treturn motionEventList;\n \t}\n \n+\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n+\t\treturn parameters;\n+\t}\n+\n+\tpublic boolean getLastCachedIsEncrypted() {\n+\t\treturn isEncrypted;\n+\t}\n+\n+\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n+\t\t\tResolution minResolution,\n+\t\t\tResolution maxResolution,\n+\t\t\tDouble constraintDiagonalMax,\n+\t\t\tAspectRatio ratioRange,\n+\t\t\tList<VideoStreamingCapability> originalAdditionalCapabilities\n+\t){\n+\t\tInteger constraintHeightMax = maxResolution.getResolutionHeight();\n+\t\tInteger constraintHeightMin = minResolution.getResolutionHeight();\n+\t\tInteger constraintWidthMax = maxResolution.getResolutionWidth();\n+\t\tInteger constraintWidthMin = minResolution.getResolutionWidth();\n+\t\tDouble aspectRationMin = ratioRange.getMinAspectRatio();\n+\t\tDouble aspectRationMax = ratioRange.getMaxAspectRatio();\n+\n+\t\tList<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+\t\tVideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+\t\tpreferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+\t\tpreferredCapability.setPreferredResolution(new ImageResolution(\n+\t\t\t\tparameters.getResolution().getResolutionWidth(),\n+\t\t\t\tparameters.getResolution().getResolutionHeight())\n+\t\t);\n+", "originalCommit": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI5MjY2OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474292669", "bodyText": "Not really, we are using this particular object to send the required data to the HMI. The PPI is not needed, regarding additional capabilities - they are actually what this method returns (line 386), but additional capabilities have the same type - VideoStreamingCapability. Does it make sense?", "author": "kboskin", "createdAt": "2020-08-20T21:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzODYwMg=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 8bae68234..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -65,896 +65,968 @@ import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.TouchCoord;\n import com.smartdevicelink.proxy.rpc.TouchEvent;\n import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.TouchType;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n import com.smartdevicelink.proxy.rpc.enums.VideoStreamingState;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.session.SdlSession;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.IVideoStreamListener;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n import com.smartdevicelink.transport.utl.TransportRecord;\n import com.smartdevicelink.util.DebugTool;\n import com.smartdevicelink.util.Version;\n \n+import java.io.IOException;\n import java.lang.ref.WeakReference;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.FutureTask;\n \n @TargetApi(19)\n public class VideoStreamManager extends BaseVideoStreamManager {\n-\tprivate static String TAG = \"VideoStreamManager\";\n-\n-\tprivate WeakReference<Context> context;\n-\tprivate volatile VirtualDisplayEncoder virtualDisplayEncoder;\n-\tprivate Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n-\tprivate SdlRemoteDisplay sdlRemoteDisplay;\n-\tprivate float[] touchScalar = {1.0f,1.0f}; //x, y\n-\tprivate HapticInterfaceManager hapticManager;\n-\tprivate SdlMotionEvent sdlMotionEvent = null;\n-\tprivate OnHMIStatus currentOnHMIStatus;\n-\tprivate StreamingStateMachine stateMachine;\n-\tprivate VideoStreamingParameters parameters;\n-\tprivate VideoStreamingCapability originalCapability;\n-\tprivate IVideoStreamListener streamListener;\n-\tprivate boolean isTransportAvailable = false;\n-\tprivate Integer majorProtocolVersion;\n-\tprivate VideoStreamingRange streamingRange;\n-\tprivate boolean hasStarted;\n-\tprivate String vehicleMake = null;\n-\tprivate boolean isEncrypted = false;\n-\tprivate boolean withPendingRestart = false;\n-\n-\t// INTERNAL INTERFACES\n-\n-\tprivate final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif (session != null && session.getAcceptedVideoParams() != null) {\n-\t\t\t\t\tparameters = session.getAcceptedVideoParams();\n-\t\t\t\t\tVideoStreamManager.this.streamListener = session.startVideoStream();\n-\t\t\t\t}\n-\n-\t\t\t\tif (VideoStreamManager.this.streamListener == null) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error starting video stream\");\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\tif(capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())){\n-\t\t\t\t\thapticManager = new HapticInterfaceManager(internalInterface);\n-\t\t\t\t}\n-\t\t\t\tcheckState();\n-\t\t\t\tstartEncoder();\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\t\thasStarted = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SdlSession session, SessionType type) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif(sdlRemoteDisplay !=null){\n-\t\t\t\t    // TODO set withPendingRestart to default in proper place\n-\t\t\t\t\tstopStreaming(withPendingRestart);\n-\t\t\t\t}\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\t\t\ttransitionToState(SETTING_UP);\n-\n-\t\t\t\tif (withPendingRestart){\n-\t\t\t\t\tVideoStreamManager manager = VideoStreamManager.this;\n-\t\t\t\t\tmanager.internalInterface.startVideoService(\n-\t\t\t\t\t\t\tmanager.getLastCachedStreamingParameters(),\n-\t\t\t\t\t\t\tmanager.isEncrypted\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceError(SdlSession session, SessionType type, String reason) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null){\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tOnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n-\t\t\t\tcurrentOnHMIStatus = onHMIStatus;\n-\n-\t\t\t\tif (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n-\t\t\t\t\tinternalInterface.stopVideoService();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null && sdlRemoteDisplay != null){\n-\t\t\t\tList<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent)notification);\n-\t\t\t\tif (motionEventList != null && !motionEventList.isEmpty()) {\n-\t\t\t\t\tfor (MotionEvent motionEvent : motionEventList) {\n-\t\t\t\t\t\tsdlRemoteDisplay.handleMotionEvent(motionEvent);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t@Override\n-\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\n-\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\n-\t\t\t// means only scale received\n-\t\t\tif (castedCapability.getPreferredResolution() == null &&\n-\t\t\t\t\tcastedCapability.getScale() != null &&\n-\t\t\t\t\tcastedCapability.getScale() != 0 &&\n-\t\t\t\t\tVideoStreamManager.this.parameters != null\n-\t\t\t\t\t&& VideoStreamManager.this.parameters.getResolution() != null) {\n-\t\t\t\t// set cached resolution\n-\t\t\t\tcastedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n-\t\t\t}\n-\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\tVideoStreamManager.this.withPendingRestart = true;\n-\n-\t\t\tvirtualDisplayEncoder.setStreamingParams(params);\n-\t\t\tstopStreaming(true);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onError(String info) { }\n-\t};\n-\n-\t// MANAGER APIs\n-\tpublic VideoStreamManager(ISdl internalInterface){\n-\t\tsuper(internalInterface);\n-\n-\t\tif(internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n-\t\t\t\tinternalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n-\t\t\tvehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n-\t\t}\n-\t\tvirtualDisplayEncoder = new VirtualDisplayEncoder();\n-\n-\t\t// Listen for video service events\n-\t\tinternalInterface.addServiceListener(SessionType.NAV, serviceListener);\n-\t\t// Take care of the touch events\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t// Listen for HMILevel changes\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t// Listen for SystemCapabilityType VIDEO_STREAMING\n-\t\tinternalInterface.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n-\t\tstateMachine = new StreamingStateMachine();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\tisTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n-\t\tcheckState();\n-\t\tsuper.start(listener);\n-\t}\n-\n-\tprivate synchronized void checkState(){\n-\t\tif(this.getState() == SETTING_UP\n-\t\t\t\t&& isTransportAvailable\n-\t\t\t\t&& isHMIStateVideoStreamCapable(currentOnHMIStatus)\n-\t\t\t\t&& parameters != null){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.READY);\n-\t\t\ttransitionToState(READY);\n-\t\t}\n-\t}\n-\n-\tboolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n-\t\tHMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n-\t\tVideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n-\t\treturn (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n-\t}\n-\n-\tprivate void getVideoStreamingParams(){\n-\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5) {\n-\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\tcheckState();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\ttransitionToState(ERROR);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\t//We just use default video streaming params\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\tif(dispCap !=null){\n-\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t}\n-\n-\t\t\tthis.parameters = params;\n-\t\t\tcheckState();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param streamingRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tthis.streamingRange = streamingRange;\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n-\t\tif(parameters == null){\n-\t\t\tif(majorProtocolVersion >= 5) {\n-\t\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\n-\t\t\t\t\t\t// Mocks data here\n-\t\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\t\t\t\tif (streamingRange != null) {\n-\t\t\t\t\t\t\t// filtering\n-\t\t\t\t\t\t\tcastedCapability.setAdditionalVideoStreamingCapabilities(\n-\t\t\t\t\t\t\t\t\tgetSupportedCapabilities(\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxSupportedResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxScreenDiagonal(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getAspectRatio(),\n-\t\t\t\t\t\t\t\t\t\t\tcastedCapability.getAdditionalVideoStreamingCapabilities()\n-\t\t\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// TODO handle??\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tOnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n-\t\t\t\t\t\tinternalInterface.sendRPC(onAppCapabilityUpdated);\n-\t\t\t\t\t\tstartStreaming(params, isEncrypted);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}else{\n-\t\t\t\t//We just use default video streaming params\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\tif(dispCap !=null){\n-\t\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t}\n-\t\t\t\tstartStreaming(params, encrypted);\n-\t\t\t}\n-\t\t}else{\n-\t\t\tstartStreaming(parameters, encrypted);\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n-\t * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n-\t *                    VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n-\t * @param encrypted Specify true if packets on this service have to be encrypted\n-\t */\n-\tprotected void startStreaming(VideoStreamingParameters parameters, boolean encrypted){\n-\t\tthis.parameters = parameters;\n-\t\tif (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n-\t\t\tDebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n-\t\t\treturn;\n-\t\t}\n-\t\t//Start the video service\n-\t\tthis.internalInterface.startVideoService(parameters, encrypted);\n-\t}\n-\n-\t/**\n-\t * Initializes and starts the virtual display encoder and creates the remote display\n-\t */\n-\tprivate void startEncoder(){\n-\t\ttry {\n-\t\t\tif (sdlRemoteDisplay != null) {\n-\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t}\n-\n-\t\t\tvirtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n-\t\t\t//We are all set so we can start streaming at at this point\n-\t\t\tvirtualDisplayEncoder.start();\n-\t\t\t//Encoder should be up and running\n-\t\t\tDisplay display = virtualDisplayEncoder.getDisplay();\n-\t\t\tcreateRemoteDisplay(display);\n-\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\thasStarted = true;\n-\t\t} catch (Exception e) {\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming from the remote display. To restart, call\n-\t * @see #resumeStreaming()\n-\t */\n-\tpublic void stopStreaming(boolean withPendingRestart){\n-\t\tif(sdlRemoteDisplay!=null && !withPendingRestart){\n-\t\t\tsdlRemoteDisplay.stop();\n-\t\t\tthis.withPendingRestart = false;\n-\t\t}\n-\t\tif (this.isStreaming()) {\n-\t\t\tif(virtualDisplayEncoder!=null){\n-\t\t\t\tvirtualDisplayEncoder.shutDown(withPendingRestart);\n-\t\t\t}\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.PAUSED);\n-\n-\t\t\tthis.internalInterface.stopVideoService();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Resumes streaming after calling\n-\t * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n-\t * followed by a call to\n-\t * @see #stopStreaming(boolean withPendingRestart)\n-\t */\n-\tpublic void resumeStreaming(){\n-\t\tint currentState = stateMachine.getState();\n-\t\tif (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n-\t\t\tstartEncoder();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming, ends video streaming service and removes service listeners.\n-\t */\n-\t@Override\n-\tpublic void dispose(){\n-\t\tstopStreaming(false);\n-\n-\t\thapticManager = null;\n-\t\tsdlRemoteDisplay = null;\n-\t\tparameters = null;\n-\t\tvirtualDisplayEncoder = null;\n-\t\tif (internalInterface != null) {\n-\t\t\tinternalInterface.stopVideoService();\n-\t\t\t// Remove listeners\n-\t\t\tinternalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t}\n-\n-\n-\n-\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\tsuper.dispose();\n-\t}\n-\n-\t// PUBLIC METHODS FOR CHECKING STATE\n-\n-\t/**\n-\t * Check if a video service is currently active\n-\t * @return boolean (true = active, false = inactive)\n-\t */\n-\tpublic boolean isServiceActive(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.READY) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STARTED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.PAUSED);\n-\t}\n-\n-\t/**\n-\t * Check if video is currently streaming and visible\n-\t * @return boolean (true = yes, false = no)\n-\t */\n-\tpublic boolean isStreaming(){\n-\t\tboolean state = (stateMachine.getState() == StreamingStateMachine.STARTED);\n-\t\tboolean capable = isHMIStateVideoStreamCapable(currentOnHMIStatus);\n-\t\treturn state && capable;\n-\t}\n-\n-\t/**\n-\t * Check if video streaming has been paused due to app moving to background or manually stopped\n-\t * @return boolean (true = not paused, false = paused)\n-\t */\n-\tpublic boolean isPaused(){\n-\t\treturn (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n-\t}\n-\n-\t/**\n-\t * Gets the current video streaming state as defined in @StreamingStateMachine\n-\t * @return int representing StreamingStateMachine.StreamingState\n-\t */\n-\tpublic @StreamingStateMachine.StreamingState int currentVideoStreamState(){\n-\t\treturn stateMachine.getState();\n-\t}\n-\n-\t// HELPER METHODS\n-\n-\tprivate void createRemoteDisplay(final Display disp){\n-\t\ttry{\n-\t\t\tif (disp == null){\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Dismiss the current presentation if the display has changed.\n-\t\t\tif (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n-\t\t\t\tsdlRemoteDisplay.dismissPresentation();\n-\t\t\t}\n-\n-\t\t\tFutureTask<Boolean> fTask =  new FutureTask<Boolean>( new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback(){\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCreated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Remote display has been created.\n-\t\t\t\t\t//Now is a good time to do parsing for spatial data\n-\t\t\t\t\tVideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\t//Get touch scalars\n-\t\t\t\t\tImageResolution resolution = null;\n-\t\t\t\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5){ //At this point we should already have the capability\n-\t\t\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\t\t\tif(capability != null){\n-\t\t\t\t\t\t\tresolution = capability.getPreferredResolution();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution == null){ //Either the protocol version is too low to access video streaming caps, or they were null\n-\t\t\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities) internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\t\t\tif (dispCap != null) {\n-\t\t\t\t\t\t\tresolution = (dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution != null){\n-\t\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\t\tdisp.getMetrics(displayMetrics);\n-\t\t\t\t\t\tcreateTouchScalar(resolution, displayMetrics);\n+    private static final String TAG = \"VideoStreamManager\";\n+\n+    private WeakReference<Context> context;\n+    private volatile VirtualDisplayEncoder virtualDisplayEncoder;\n+    private Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n+    private SdlRemoteDisplay sdlRemoteDisplay;\n+    private final float[] touchScalar = {1.0f, 1.0f}; //x, y\n+    private HapticInterfaceManager hapticManager;\n+    private SdlMotionEvent sdlMotionEvent = null;\n+    private OnHMIStatus currentOnHMIStatus;\n+    private final StreamingStateMachine stateMachine;\n+    private VideoStreamingParameters parameters;\n+    private VideoStreamingCapability originalCapability;\n+    private IVideoStreamListener streamListener;\n+    private boolean isTransportAvailable = false;\n+    private Integer majorProtocolVersion;\n+    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private boolean hasStarted;\n+    private String vehicleMake = null;\n+    private boolean isEncrypted = false;\n+    private boolean withPendingRestart = false;\n+    private AbstractPacketizer videoPacketizer;\n+\n+    // INTERNAL INTERFACES\n+\n+    private final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n+        @Override\n+        public void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n+            if (SessionType.NAV.equals(type)) {\n+                if (session != null && session.getAcceptedVideoParams() != null) {\n+                    parameters = session.getAcceptedVideoParams();\n+                    VideoStreamManager.this.streamListener = startVideoStream(session.getAcceptedVideoParams(), session);\n+                }\n+\n+                if (VideoStreamManager.this.streamListener == null) {\n+                    DebugTool.logError(TAG, \"Error starting video stream\");\n+                    stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                    return;\n+                }\n+                VideoStreamingCapability capability = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                }\n+                if (capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())) {\n+                    hapticManager = new HapticInterfaceManager(internalInterface);\n+                }\n+                checkState();\n+                startEncoder();\n+                stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+                hasStarted = true;\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceEnded(SdlSession session, SessionType type) {\n+            if (SessionType.NAV.equals(type)) {\n+                //stopVideoStream();\n+                if (sdlRemoteDisplay !=null){\n+                    stopStreaming(withPendingRestart);\n+                }\n+                stateMachine.transitionToState(StreamingStateMachine.NONE);\n+                transitionToState(SETTING_UP);\n+\n+                if (withPendingRestart){\n+                    VideoStreamManager manager = VideoStreamManager.this;\n+                    manager.internalInterface.startVideoService(\n+                            manager.getLastCachedStreamingParameters(),\n+                            manager.isEncrypted,\n+                            withPendingRestart\n+                    );\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceError(SdlSession session, SessionType type, String reason) {\n+            DebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n+            stopVideoStream();\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            transitionToState(BaseSubManager.ERROR);\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                OnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n+                currentOnHMIStatus = onHMIStatus;\n+                if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+                    getVideoStreamingParams();\n+                }\n+                checkState();\n+                if (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n+                    stopVideoStream();\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null && sdlRemoteDisplay != null) {\n+                List<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent) notification);\n+                if (motionEventList != null && !motionEventList.isEmpty()) {\n+                    for (MotionEvent motionEvent : motionEventList) {\n+                        sdlRemoteDisplay.handleMotionEvent(motionEvent);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+\n+            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+            // means only scale received\n+            if (castedCapability.getPreferredResolution() == null &&\n+                    castedCapability.getScale() != null &&\n+                    castedCapability.getScale() != 0 &&\n+                    VideoStreamManager.this.parameters != null\n+                    && VideoStreamManager.this.parameters.getResolution() != null) {\n+                // set cached resolution\n+                castedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+            }\n+            params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+            VideoStreamManager.this.parameters = params;\n+\n+            VideoStreamManager.this.withPendingRestart = true;\n+\n+            virtualDisplayEncoder.setStreamingParams(params);\n+            stopStreaming(true);\n+        }\n+\n+        @Override\n+        public void onError(String info) { }\n+    };\n+\n+    // MANAGER APIs\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public VideoStreamManager(ISdl internalInterface) {\n+        super(internalInterface);\n+\n+        if (internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n+                internalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n+            vehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n+        }\n+        virtualDisplayEncoder = new VirtualDisplayEncoder();\n+\n+        // Listen for video service events\n+        internalInterface.addServiceListener(SessionType.NAV, serviceListener);\n+        // Take care of the touch events\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+        // Listen for HMILevel changes\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        // Listen for SystemCapabilityType VIDEO_STREAMING\n+        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n+        stateMachine = new StreamingStateMachine();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        isTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n+        checkState();\n+        super.start(listener);\n+    }\n+\n+    private synchronized void checkState() {\n+        if (this.getState() == SETTING_UP\n+                && isTransportAvailable\n+                && isHMIStateVideoStreamCapable(currentOnHMIStatus)\n+                && parameters != null) {\n+            stateMachine.transitionToState(StreamingStateMachine.READY);\n+            transitionToState(READY);\n+        }\n+    }\n+\n+    boolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n+        HMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n+        VideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n+        return (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n+    }\n+\n+    private void getVideoStreamingParams() {\n+        if (internalInterface.getProtocolVersion().getMajor() >= 5) {\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                    @Override\n+                    public void onCapabilityRetrieved(Object capability) {\n+                        VideoStreamingParameters params = new VideoStreamingParameters();\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+                        params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+                        // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                        checkState();\n+                        }\n+\n+                    @Override\n+                    public void onError(String info) {\n+                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                        transitionToState(ERROR);\n+                    }\n+                }, false);\n+            }\n+        } else {\n+            //We just use default video streaming params\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+            DisplayCapabilities dispCap = null;\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+            }\n+            if (dispCap != null) {\n+                params.setResolution(dispCap.getScreenParams().getImageResolution());\n+            }\n+\n+            this.parameters = params;\n+            checkState();\n+        }\n+    }\n+\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {\n+            if (majorProtocolVersion >= 5) {\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                        @Override\n+                        public void onCapabilityRetrieved(Object capability) {\n+                            VideoStreamingParameters params = new VideoStreamingParameters();\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                            VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                            // Mocks data here\n+                            // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                            params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+                            if (listOfStreamingRanges != null) {\n+                                // filtering\n+                                castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                                );\n+                            } else { }\n+                            OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n+                            internalInterface.sendRPC(onAppCapabilityUpdated);\n+                            startStreaming(params, isEncrypted);\n+                        }\n+\n+                        @Override\n+                        public void onError(String info) {\n+                            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                            DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        }\n+                    }, false);\n+                }\n+            } else {\n+                //We just use default video streaming params\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                DisplayCapabilities dispCap = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                }\n+                if (dispCap != null) {\n+                    params.setResolution(dispCap.getScreenParams().getImageResolution());\n+                }\n+                startStreaming(params, encrypted);\n+            }\n+        } else {\n+            startStreaming(parameters, encrypted);\n+        }\n+    }\n+\n+\n+    /**\n+     * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n+     *\n+     * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n+     *                   VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n+     * @param encrypted  Specify true if packets on this service have to be encrypted\n+     */\n+    protected void startStreaming(VideoStreamingParameters parameters, boolean encrypted) {\n+        this.parameters = parameters;\n+        if (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n+            DebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n+            return;\n+        }\n+        //Start the video service\n+        this.internalInterface.startVideoService(parameters, encrypted, false);\n+    }\n+\n+    /**\n+     * Initializes and starts the virtual display encoder and creates the remote display\n+     */\n+    private void startEncoder() {\n+        try {\n+            if (sdlRemoteDisplay != null) {\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+            }\n+\n+            virtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n+            //We are all set so we can start streaming at at this point\n+            virtualDisplayEncoder.start();\n+            //Encoder should be up and running\n+            createRemoteDisplay(virtualDisplayEncoder.getDisplay());\n+\n+            stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+            hasStarted = true;\n+        } catch (Exception e) {\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    public void stopStreaming(boolean withPendingRestart) {\n+        if (sdlRemoteDisplay!= null && !withPendingRestart) {\n+            sdlRemoteDisplay.stop();\n+                this.withPendingRestart = false;\n+        }\n+        if (this.isStreaming()) {\n+            if (virtualDisplayEncoder!=null){\n+                virtualDisplayEncoder.shutDown(withPendingRestart);\n+            }\n+            stateMachine.transitionToState(StreamingStateMachine.PAUSED);\n+            stopVideoStream();\n+        }\n+    }\n+\n+    /**\n+     * Resumes streaming after calling\n+     *\n+     * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n+     * followed by a call to\n+     * @see #stopStreaming(boolean withPendingRestart)\n+     */\n+    public void resumeStreaming() {\n+        int currentState = stateMachine.getState();\n+        if (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n+            startEncoder();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming, ends video streaming service and removes service listeners.\n+     */\n+    @Override\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void dispose() {\n+        stopStreaming(false);\n+\n+        hapticManager = null;\n+        sdlRemoteDisplay = null;\n+        parameters = null;\n+        virtualDisplayEncoder = null;\n+        if (internalInterface != null) {\n+            // Remove listeners\n+            internalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        }\n+\n+        stopVideoStream();\n+\n+\n+        stateMachine.transitionToState(StreamingStateMachine.NONE);\n+        super.dispose();\n+    }\n+\n+    // PUBLIC METHODS FOR CHECKING STATE\n+\n+    /**\n+     * Check if a video service is currently active\n+     *\n+     * @return boolean (true = active, false = inactive)\n+     */\n+    public boolean isServiceActive() {\n+        return (stateMachine.getState() == StreamingStateMachine.READY) ||\n+                (stateMachine.getState() == StreamingStateMachine.STARTED) ||\n+                (stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n+                (stateMachine.getState() == StreamingStateMachine.PAUSED);\n+        }\n+\n+    /**\n+     * Check if video is currently streaming and visible\n+     *\n+     * @return boolean (true = yes, false = no)\n+     */\n+    public boolean isStreaming() {\n+        return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Check if video streaming has been paused due to app moving to background or manually stopped\n+     *\n+     * @return boolean (true = not paused, false = paused)\n+     */\n+    public boolean isPaused() {\n+        return (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Gets the current video streaming state as defined in @StreamingStateMachine\n+     *\n+     * @return int representing StreamingStateMachine.StreamingState\n+     */\n+    public @StreamingStateMachine.StreamingState\n+    int currentVideoStreamState() {\n+        return stateMachine.getState();\n+    }\n+\n+    // HELPER METHODS\n+\n+    private void createRemoteDisplay(final Display disp) {\n+        try {\n+            if (disp == null) {\n+                return;\n+            }\n+\n+            // Dismiss the current presentation if the display has changed.\n+            if (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n+                sdlRemoteDisplay.dismissPresentation();\n+            }\n+\n+            FutureTask<Boolean> fTask = new FutureTask<>(new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback() {\n+                @Override\n+                public void onCreated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Remote display has been created.\n+                    //Now is a good time to do parsing for spatial data\n+                    VideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                    //Get touch scalars\n+                    ImageResolution resolution = null;\n+                    if (internalInterface.getProtocolVersion().getMajor() >= 5) { //At this point we should already have the capability\n+                        VideoStreamingCapability capability = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                        }\n+                        if (capability != null) {\n+                            resolution = capability.getPreferredResolution();\n+                        }\n+                    }\n+\n+                    if (resolution == null) { //Either the protocol version is too low to access video streaming caps, or they were null\n+                        DisplayCapabilities dispCap = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                        }\n+                        if (dispCap != null) {\n+                            resolution = (dispCap.getScreenParams().getImageResolution());\n+                        }\n+                    }\n+\n+                    if (resolution != null) {\n+                        DisplayMetrics displayMetrics = new DisplayMetrics();\n+                        disp.getMetrics(displayMetrics);\n+                        createTouchScalar(resolution, displayMetrics);\n                     }\n \n-\t\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Our view has been invalidated\n-\t\t\t\t\t//A good time to refresh spatial data\n-\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\tsdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n-\t\t\t\t\tdisplayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n-\t\t\t\t\tdisplayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n-\t\t\t\t\tcreateTouchScalar(parameters.getResolution(), displayMetrics);\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ));\n-\t\t\tThread showPresentation = new Thread(fTask);\n-\t\t\tshowPresentation.setName(\"RmtDispThread\");\n-\n-\t\t\tshowPresentation.start();\n-\t\t} catch (Exception ex) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n-\t\t\tif(DebugTool.isDebugEnabled()){\n-\t\t\t\tex.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail){\n-\n-\t\tisTransportAvailable = videoStreamTransportAvail;\n-\n-\t\tif(internalInterface.getProtocolVersion().isNewerThan(new Version(5,1,0)) >= 0){\n-\t\t\tif(videoStreamTransportAvail){\n-\t\t\t\tcheckState();\n-\t\t\t}\n-\t\t}else{\n-\t\t\t//The protocol version doesn't support simultaneous transports.\n-\t\t\tif(!videoStreamTransportAvail){\n-\t\t\t\t//If video streaming isn't available on primary transport then it is not possible to\n-\t\t\t\t//use the video streaming manager until a complete register on a transport that\n-\t\t\t\t//supports video\n-\t\t\t\ttransitionToState(ERROR);\n-\t\t\t}\n-\t\t}\n-\t}\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+                }\n+\n+                @Override\n+                public void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Our view has been invalidated\n+                    //A good time to refresh spatial data\n+                    DisplayMetrics displayMetrics = new DisplayMetrics();\n+                    sdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n+                    displayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n+                    displayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n+                    createTouchScalar(parameters.getResolution(), displayMetrics);\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                }\n+            }));\n+            Thread showPresentation = new Thread(fTask);\n+            showPresentation.setName(\"RmtDispThread\");\n+\n+            showPresentation.start();\n+        } catch (Exception ex) {\n+            DebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n+            if (DebugTool.isDebugEnabled()) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail) {\n+\n+        isTransportAvailable = videoStreamTransportAvail;\n+\n+        if (internalInterface.getProtocolVersion().isNewerThan(new Version(5, 1, 0)) >= 0) {\n+            if (videoStreamTransportAvail) {\n+                checkState();\n+            }\n+        } else {\n+            //The protocol version doesn't support simultaneous transports.\n+            if (!videoStreamTransportAvail) {\n+                //If video streaming isn't available on primary transport then it is not possible to\n+                //use the video streaming manager until a complete register on a transport that\n+                //supports video\n+                transitionToState(ERROR);\n+            }\n+        }\n+    }\n \n     void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics) {\n-        touchScalar[0] = ((float)displayMetrics.widthPixels) / resolution.getResolutionWidth();\n-        touchScalar[1] = ((float)displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+        touchScalar[0] = ((float) displayMetrics.widthPixels) / resolution.getResolutionWidth();\n+        touchScalar[1] = ((float) displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+    }\n+\n+    List<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent) {\n+        List<MotionEvent> motionEventList = new ArrayList<>();\n+\n+        List<TouchEvent> touchEventList = onTouchEvent.getEvent();\n+        if (touchEventList == null || touchEventList.size() == 0) return null;\n+\n+        TouchType touchType = onTouchEvent.getType();\n+        if (touchType == null) {\n+            return null;\n+        }\n+\n+        if (sdlMotionEvent == null) {\n+            if (touchType == TouchType.BEGIN) {\n+                sdlMotionEvent = new SdlMotionEvent();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        SdlMotionEvent.Pointer pointer;\n+        MotionEvent motionEvent;\n+\n+        for (TouchEvent touchEvent : touchEventList) {\n+            if (touchEvent == null || touchEvent.getId() == null) {\n+                continue;\n+            }\n+\n+            List<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n+            if (touchCoordList == null || touchCoordList.size() == 0) {\n+                continue;\n+            }\n+\n+            TouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n+            if (touchCoord == null) {\n+                continue;\n+            }\n+\n+            int motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n+            long downTime = sdlMotionEvent.downTime;\n+            long eventTime = sdlMotionEvent.eventTime;\n+            pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n+            if (pointer != null) {\n+                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n+            }\n+\n+            MotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n+            MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n+\n+            for (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n+                pointerProperties[i] = new MotionEvent.PointerProperties();\n+                pointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n+                pointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n+\n+                pointerCoords[i] = new MotionEvent.PointerCoords();\n+                pointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n+                pointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n+                pointerCoords[i].orientation = 0;\n+                pointerCoords[i].pressure = 1.0f;\n+                pointerCoords[i].size = 1;\n+            }\n+\n+            motionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n+                    sdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n+                    1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n+            motionEventList.add(motionEvent);\n+\n+            if (motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL) {\n+                //If the motion event should be finished we should clear our reference\n+                sdlMotionEvent.pointers.clear();\n+                sdlMotionEvent = null;\n+                break;\n+            } else if ((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP) {\n+                sdlMotionEvent.removePointerById(touchEvent.getId());\n+            }\n+        }\n+\n+        return motionEventList;\n+    }\n+\n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n     }\n \n-\tList<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent){\n-\t\tList<MotionEvent> motionEventList = new ArrayList<MotionEvent>();\n-\n-\t\tList<TouchEvent> touchEventList = onTouchEvent.getEvent();\n-\t\tif (touchEventList == null || touchEventList.size() == 0) return null;\n-\n-\t\tTouchType touchType = onTouchEvent.getType();\n-\t\tif (touchType == null) { return null; }\n-\n-\t\tif(sdlMotionEvent == null) {\n-\t\t\tif (touchType == TouchType.BEGIN) {\n-\t\t\t\tsdlMotionEvent = new SdlMotionEvent();\n-\t\t\t} else{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tSdlMotionEvent.Pointer pointer;\n-\t\tMotionEvent motionEvent;\n-\n-\t\tfor (TouchEvent touchEvent : touchEventList) {\n-\t\t\tif (touchEvent == null || touchEvent.getId() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tList<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n-\t\t\tif (touchCoordList == null || touchCoordList.size() == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tTouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n-\t\t\tif (touchCoord == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tint motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n-\t\t\tlong downTime = sdlMotionEvent.downTime;\n-\t\t\tlong eventTime = sdlMotionEvent.eventTime;\n-\t\t\tpointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n-\t\t\tif (pointer != null) {\n-\t\t\t\tpointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n-\t\t\t}\n-\n-\t\t\tMotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n-\t\t\tMotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n-\n-\t\t\tfor (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n-\t\t\t\tpointerProperties[i] = new MotionEvent.PointerProperties();\n-\t\t\t\tpointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n-\t\t\t\tpointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n-\n-\t\t\t\tpointerCoords[i] = new MotionEvent.PointerCoords();\n-\t\t\t\tpointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n-\t\t\t\tpointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n-\t\t\t\tpointerCoords[i].orientation = 0;\n-\t\t\t\tpointerCoords[i].pressure = 1.0f;\n-\t\t\t\tpointerCoords[i].size = 1;\n-\t\t\t}\n-\n-\t\t\tmotionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n-\t\t\t\t\tsdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n-\t\t\t\t\t1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n-\t\t\tmotionEventList.add(motionEvent);\n-\n-\t\t\tif(motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL){\n-\t\t\t\t//If the motion event should be finished we should clear our reference\n-\t\t\t\tsdlMotionEvent.pointers.clear();\n-\t\t\t\tsdlMotionEvent = null;\n-\t\t\t\tbreak;\n-\t\t\t} else if((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP){\n-\t\t\t\tsdlMotionEvent.removePointerById(touchEvent.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn motionEventList;\n-\t}\n-\n-\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n-\t\treturn parameters;\n-\t}\n-\n-\tpublic boolean getLastCachedIsEncrypted() {\n-\t\treturn isEncrypted;\n-\t}\n-\n-\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n-\t\t\tResolution minResolution,\n-\t\t\tResolution maxResolution,\n-\t\t\tDouble constraintDiagonalMax,\n-\t\t\tAspectRatio ratioRange,\n-\t\t\tList<VideoStreamingCapability> originalAdditionalCapabilities\n-\t){\n-\t\tInteger constraintHeightMax = maxResolution.getResolutionHeight();\n-\t\tInteger constraintHeightMin = minResolution.getResolutionHeight();\n-\t\tInteger constraintWidthMax = maxResolution.getResolutionWidth();\n-\t\tInteger constraintWidthMin = minResolution.getResolutionWidth();\n-\t\tDouble aspectRationMin = ratioRange.getMinAspectRatio();\n-\t\tDouble aspectRationMax = ratioRange.getMaxAspectRatio();\n-\n-\t\tList<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n-\n-\t\tVideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n-\t\tpreferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n-\t\tpreferredCapability.setPreferredResolution(new ImageResolution(\n-\t\t\t\tparameters.getResolution().getResolutionWidth(),\n-\t\t\t\tparameters.getResolution().getResolutionHeight())\n-\t\t);\n-\n-\t\t// get the first one - the Desired resolution to guarantee streaming will start\n-\t\tvalidCapabilities.add(preferredCapability);\n-\n-\t\tfor (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n-\t\t\tdouble diagonal;\n-\t\t\tint resolutionHeight;\n-\t\t\tint resolutionWidth;\n-\t\t\t// TODO refactor\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionHeight() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionHeight = capability.getPreferredResolution().getResolutionHeight();\n-\t\t\t}\n-\t\t\tif (capability.getPreferredResolution() == null || capability.getPreferredResolution().getResolutionWidth() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t} else {\n-\t\t\t\tresolutionWidth = capability.getPreferredResolution().getResolutionWidth();\n-\t\t\t}\n-\t\t\tif (capability.getDiagonalScreenSize() == null ) {\n-\t\t\t\tdiagonal = parameters.getPreferredDiagonal();\n-\t\t\t} else {\n-\t\t\t\tdiagonal = capability.getDiagonalScreenSize();\n-\t\t\t}\n-\n-\t\t\tif (constraintDiagonalMax < diagonal) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!isAspectRatioInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tif (constraintHeightMax == null && constraintHeightMin == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!isImageResolutionInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tvalidCapabilities.add(capability);\n-\t\t}\n-\n-\t\treturn validCapabilities;\n-\t}\n-\n-\tpublic Boolean isImageResolutionInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\n-\t\tInteger constraintHeightMax = range.getMaxSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintHeightMin = range.getMinSupportedResolution().getResolutionHeight();\n-\t\tInteger constraintWidthMax = range.getMaxSupportedResolution().getResolutionWidth();\n-\t\tInteger constraintWidthMin = range.getMinSupportedResolution().getResolutionWidth();\n-\t\tInteger resolutionHeight = currentResolution.getResolutionHeight();\n-\t\tInteger resolutionWidth = currentResolution.getResolutionWidth();\n-\t\tif (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null)\n-\t\t{\n-\t\t\tif (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tif (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// TODO check what if dev provided invalid constraints\n-\t\treturn true;\n-\t}\n-\n-\tpublic Boolean isAspectRatioInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\t\tDouble aspectRatioMin = range.getAspectRatio().getMinAspectRatio();\n-\t\tDouble aspectRatioMax = range.getAspectRatio().getMaxAspectRatio();\n-\n-\t\tDouble currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n-\n-\t\tif (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n-\t\t\tif ((currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\t// TODO check what if dev provided invalid constraints\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * Keeps track of the current motion event for VPM\n-\t */\n-\tprivate static class SdlMotionEvent {\n-\t\tclass Pointer {\n-\t\t\tint id;\n-\t\t\tfloat x;\n-\t\t\tfloat y;\n-\t\t\tPointer (int id) {\n-\t\t\t\tthis.id = id;\n-\t\t\t\tthis.x = 0.0f;\n-\t\t\t\tthis.y = 0.0f;\n-\t\t\t}\n-\t\t\tvoid setCoords(float x, float y) {\n-\t\t\t\tthis.x = x;\n-\t\t\t\tthis.y = y;\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n-\t\tprivate long downTime;\n-\t\tprivate long downTimeOnHMI;\n-\t\tprivate long eventTime;\n-\n-\t\tSdlMotionEvent(){\n-\t\t\tdownTimeOnHMI = 0;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n-\t\t * Android MotionEvent according to this events status\n-\t\t * @param touchType The SDL TouchType that was received from the module\n-\t\t * @param touchEvent The SDL TouchEvent that was received from the module\n-\t\t * @return the correct native Android MotionEvent action to dispatch\n-\t\t */\n-\t\tsynchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent){\n-\t\t\teventTime = 0;\n-\t\t\tint motionEventAction = -1;\n-\t\t\tswitch (touchType){\n-\t\t\t\tcase BEGIN:\n-\t\t\t\t\tif(pointers.size() == 0){\n-\t\t\t\t\t\t//The motion event has just begun\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_DOWN;\n-\t\t\t\t\t\tdownTime = SystemClock.uptimeMillis();\n-\t\t\t\t\t\tdownTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n-\t\t\t\t\t\teventTime = downTime;\n-\t\t\t\t\t} else{\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\t}\n-\t\t\t\t\tpointers.add(new Pointer(touchEvent.getId()));\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase MOVE:\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_MOVE;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase END:\n-\t\t\t\t\tif(pointers.size() <= 1){\n-\t\t\t\t\t\t//The motion event has just ended\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tint pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n-\t\t\t\t\t\tif (pointerIndex != -1) {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase CANCEL:\n-\t\t\t\t\t//Assuming this cancels the entire event\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_CANCEL;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\treturn motionEventAction;\n-\t\t}\n-\n-\t\tPointer getPointerById(int id){\n-\t\t\tif (pointers != null && !pointers.isEmpty()){\n-\t\t\t\tfor (Pointer pointer : pointers){\n-\t\t\t\t\tif (pointer.id == id){\n-\t\t\t\t\t\treturn pointer;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tPointer getPointerByIndex(int index){\n-\t\t\treturn pointers.get(index);\n-\t\t}\n-\n-\t\tvoid removePointerById(int id){\n-\t\t\tpointers.remove(getPointerById(id));\n-\t\t}\n-\t}\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n+        Double aspectRatioMin = aspectRatio.getMinAspectRatio();\n+        Double aspectRatioMax = aspectRatio.getMaxAspectRatio();\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n+            if (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Keeps track of the current motion event for VPM\n+     */\n+    private static class SdlMotionEvent {\n+        class Pointer {\n+            final int id;\n+            float x;\n+            float y;\n+\n+            Pointer(int id) {\n+                this.id = id;\n+                this.x = 0.0f;\n+                this.y = 0.0f;\n+            }\n+\n+            void setCoords(float x, float y) {\n+                this.x = x;\n+                this.y = y;\n+            }\n+        }\n+\n+        private final CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n+        private long downTime;\n+        private long downTimeOnHMI;\n+        private long eventTime;\n+\n+        SdlMotionEvent() {\n+            downTimeOnHMI = 0;\n+        }\n+\n+        /**\n+         * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n+         * Android MotionEvent according to this events status\n+         *\n+         * @param touchType  The SDL TouchType that was received from the module\n+         * @param touchEvent The SDL TouchEvent that was received from the module\n+         * @return the correct native Android MotionEvent action to dispatch\n+         */\n+        synchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent) {\n+            eventTime = 0;\n+            int motionEventAction = -1;\n+            switch (touchType) {\n+                case BEGIN:\n+                    if (pointers.size() == 0) {\n+                        //The motion event has just begun\n+                        motionEventAction = MotionEvent.ACTION_DOWN;\n+                        downTime = SystemClock.uptimeMillis();\n+                        downTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n+                        eventTime = downTime;\n+                    } else {\n+                        motionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    }\n+                    pointers.add(new Pointer(touchEvent.getId()));\n+                    break;\n+                case MOVE:\n+                    motionEventAction = MotionEvent.ACTION_MOVE;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case END:\n+                    if (pointers.size() <= 1) {\n+                        //The motion event has just ended\n+                        motionEventAction = MotionEvent.ACTION_UP;\n+                    } else {\n+                        int pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n+                        if (pointerIndex != -1) {\n+                            motionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        } else {\n+                            motionEventAction = MotionEvent.ACTION_UP;\n+                        }\n+                    }\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case CANCEL:\n+                    //Assuming this cancels the entire event\n+                    motionEventAction = MotionEvent.ACTION_CANCEL;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return motionEventAction;\n+        }\n+\n+        Pointer getPointerById(int id) {\n+            if (pointers != null && !pointers.isEmpty()) {\n+                for (Pointer pointer : pointers) {\n+                    if (pointer.id == id) {\n+                        return pointer;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        Pointer getPointerByIndex(int index) {\n+            return pointers.get(index);\n+        }\n+\n+        void removePointerById(int id) {\n+            pointers.remove(getPointerById(id));\n+        }\n+    }\n+\n+    private VideoStreamingProtocol getAcceptedProtocol(VideoStreamingParameters params) {\n+        if (params != null) {\n+            VideoStreamingFormat format = params.getFormat();\n+            if (format != null && format.getProtocol() != null) {\n+                return format.getProtocol();\n+            }\n+        }\n+        //Returns default protocol if none are found\n+        return new VideoStreamingParameters().getFormat().getProtocol();\n+\n+    }\n+\n+    protected IVideoStreamListener startVideoStream(VideoStreamingParameters params, final SdlSession session) {\n+        VideoStreamingProtocol protocol = getAcceptedProtocol(params);\n+\n+        IStreamListener iStreamListener = new IStreamListener() {\n+            @Override\n+            public void sendStreamPacket(ProtocolMessage pm) {\n+                session.sendMessage(pm);\n+            }\n+        };\n+\n+        try {\n+            switch (protocol) {\n+                case RAW: {\n+                    videoPacketizer = new StreamPacketizer(iStreamListener, null, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                case RTP: {\n+                    //FIXME why is this not an extension of StreamPacketizer?\n+                    videoPacketizer = new RTPH264Packetizer(iStreamListener, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                default:\n+                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\n+                    return null;\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    protected boolean stopVideoStream() {\n+        if (videoPacketizer != null) {\n+            videoPacketizer.stop();\n+            return true;\n+        }\n+        return false;\n+    }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2NTMyOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473365328", "bodyText": "@kostyaBoss Unused import on line 29 can be removed.", "author": "santhanamk", "createdAt": "2020-08-19T21:59:22Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java", "diffHunk": "@@ -7,23 +7,36 @@\n import android.app.Service;\n import android.content.Context;\n import android.content.Intent;\n+import android.net.Uri;\n import android.os.Build;\n+import android.os.Bundle;\n import android.os.IBinder;\n import android.util.Log;\n-\n+import android.view.Display;\n+import android.view.MotionEvent;\n+import android.view.View;\n+import android.widget.Button;\n+import android.widget.TextView;\n+import android.widget.Toast;\n+import android.widget.VideoView;\n+\n+import com.jakewharton.rxrelay2.PublishRelay;\n import com.smartdevicelink.managers.CompletionListener;\n-import com.smartdevicelink.managers.screen.OnButtonListener;\n import com.smartdevicelink.managers.SdlManager;\n import com.smartdevicelink.managers.SdlManagerListener;\n import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n import com.smartdevicelink.managers.lifecycle.LifecycleConfigurationUpdate;\n+import com.smartdevicelink.managers.screen.OnButtonListener;", "originalCommit": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\nindex 5959b44c2..0b83e0842 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n\n@@ -7,20 +7,10 @@ import android.app.NotificationManager;\n import android.app.Service;\n import android.content.Context;\n import android.content.Intent;\n-import android.net.Uri;\n import android.os.Build;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.util.Log;\n-import android.view.Display;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.TextView;\n-import android.widget.Toast;\n-import android.widget.VideoView;\n-\n-import com.jakewharton.rxrelay2.PublishRelay;\n+\n import com.smartdevicelink.managers.CompletionListener;\n import com.smartdevicelink.managers.SdlManager;\n import com.smartdevicelink.managers.SdlManagerListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2OTc1MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473369751", "bodyText": "@kostyaBoss On line 908, I think you need to add these lines:\nGENERAL_VIDEOSTREAMINGCAPABILITY.setAdditionalVideoStreamingCapabilities(...);\nGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(...);\nGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(...);\nGENERAL_VIDEOSTREAMINGCAPABILITY.setScale(...);", "author": "santhanamk", "createdAt": "2020-08-19T22:05:04Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -1133,6 +1137,9 @@ public void onVoiceCommandSelected() {\n \t\tGENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);", "originalCommit": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex a733cb30f..7b3f5dc70 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -888,498 +905,516 @@ public class TestValues {\n         GENERAL_PERMISSIONITEM.setRequireEncryption(GENERAL_BOOLEAN);\n         GENERAL_PERMISSIONITEM_LIST.add(GENERAL_PERMISSIONITEM);\n \n-\t\tGENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n-\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n-\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n-\n-\t\tGENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n-\n-\t\tGENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n-\t\tGENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n-\t\tGENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n-\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n-\n-\t\tGENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n-\n-\t\tList<MetadataType> exampleList = new ArrayList<>();\n-\t\texampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n-\t\texampleList.add(1, MetadataType.MEDIA_ALBUM);\n-\t\texampleList.add(2, MetadataType.MEDIA_ARTIST);\n-\n-\t\tGENERAL_METADATASTRUCT.setMainField1(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField2(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField3(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField4(exampleList);\n-\n-\t\tGENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n-\n-\t\tGENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n-\t\tGENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n-\n-\t\tGENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n-\n-\t\tGENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n-\t\tGENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n-\t\tGENERAL_LOCKSCREENCONFIG.setEnabled(true);\n-\t\tGENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n-\t\tGENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n-\t\tGENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n-\n-\t\tGENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n-\t\tGENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n-\n-\t\tGENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n-\n-\t\tGENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n-\n-\t\tGENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n-\t\tGENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n-\n-\t\tGENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n-\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n-\t\tGENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n-\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n-\t\tGENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n-\t\tGENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n-\n-\t\tGENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\tGENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n-\n-\t\ttry {\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n-\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n-\n-\t\t\tJSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n-\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_FULL);\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n-\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n-\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n-\t\t\tJSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n-\n-\t\t\tJSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n-\t\t\tJSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n-\t\t\tJSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED , GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n-\n-\t\t\tJSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n-\t\t\tJSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_TURNS.put(JSON_TURN);\n-\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n-\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n-\t    \tJSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n-\n-\t    \tJSONObject jsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\t    \tjsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n-\n-\t\t\tJSON_CHOICES.put(JSON_CHOICE);\n-\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n-\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n-\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n-\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n-\t\t\tJSON_DIDRESULTS.put(JSON_DIDRESULT);\n-\n-\t\t\tJSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSONObject jsonButton = new JSONObject();\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n-\t\t\tJSON_BUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSONObject jsonRadioControlCapabilities = new JSONObject();\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n-\n-\t\t\tJSONObject jsonClimateControlCapabilities = new JSONObject();\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n-\t\t\tJSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\t\t\tJSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n-\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n-\t\t\tJSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n-\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n-\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.STATIC);\n-\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n-\n-\t\t\tJSONObject jsonTEC = new JSONObject();\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n-\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n-\t\t\tJSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n-\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n-\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n-\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n-\t\t\tJSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n-\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n-\n-\t\t\tJSON_SEAT_LOCATIONS.put(JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n-\n-\n-\t\t} catch (JSONException e) {\n-\t\t\tLog.e(\"Test\", \"Static Json Construction Failed.\", e);\n-\t\t}\n-\t}\n+        GENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n+\n+        GENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n+        GENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n+        GENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n+\n+        GENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n+\n+        GENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n+\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n+\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n+        GENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n+\n+        GENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n+\n+        GENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n+        GENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n+        GENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n+        GENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n+\n+        GENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n+\n+        GENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n+\n+        List<MetadataType> exampleList = new ArrayList<>();\n+        exampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n+        exampleList.add(1, MetadataType.MEDIA_ALBUM);\n+        exampleList.add(2, MetadataType.MEDIA_ARTIST);\n+\n+        GENERAL_METADATASTRUCT.setMainField1(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField2(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField3(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField4(exampleList);\n+\n+        GENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n+\n+        GENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n+        GENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n+\n+        GENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n+\n+        GENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n+        GENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n+        GENERAL_LOCKSCREENCONFIG.setDisplayMode(LockScreenConfig.DISPLAY_MODE_ALWAYS);\n+        GENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n+        GENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n+        GENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n+        GENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n+        GENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n+        GENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n+        GENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n+        GENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n+        GENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n+\n+        GENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n+\n+        GENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n+        GENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n+\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n+\n+        GENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n+\n+        GENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n+\n+        GENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n+        GENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n+\n+        GENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n+        GENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n+        GENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n+\n+        GENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n+        GENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n+        GENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n+\n+        GENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n+        GENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n+        GENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n+\n+        GENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n+        GENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n+        GENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n+        GENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n+        GENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n+        GENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n+        GENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n+\n+        GENERAL_GEAR_STATUS.setActualGear(GENERAL_ACTUAL_GEAR);\n+        GENERAL_GEAR_STATUS.setTransmissionType(GENERAL_TRANSMISSION_TYPE);\n+        GENERAL_GEAR_STATUS.setUserSelectedGear(GENERAL_USER_SELECTED_GEAR);\n+\n+        GENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n+        GENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n+        GENERAL_STABILITY_CONTROL_STATUS.setEscSystem(GENERAL_ESC_SYSTEM);\n+        GENERAL_STABILITY_CONTROL_STATUS.setTrailerSwayControl(GENERAL_S_WAY_CONTROL);\n+\n+        GENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n+        GENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n+\n+        try {\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n+\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n+\n+            JSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n+            JSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n+\n+            JSON_HMILEVELS.put(HMILevel.HMI_FULL);\n+            JSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n+\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n+\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n+            JSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n+\n+            JSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n+            JSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n+            JSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n+\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n+\n+            JSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n+            JSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_TURNS.put(JSON_TURN);\n+\n+            JSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n+\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n+            JSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n+\n+            JSONObject jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+            jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n+            JSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n+            JSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n+\n+            JSON_CHOICES.put(JSON_CHOICE);\n+\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n+\n+            JSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n+\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n+\n+            JSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n+            JSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n+            JSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n+            JSON_DIDRESULTS.put(JSON_DIDRESULT);\n+\n+            JSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSONObject jsonButton = new JSONObject();\n+            jsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n+            jsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n+            JSON_BUTTONCAPABILITIES.put(jsonButton);\n+\n+            JSONObject jsonRadioControlCapabilities = new JSONObject();\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n+\n+            JSONObject jsonClimateControlCapabilities = new JSONObject();\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n+            JSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+            JSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n+\n+            JSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n+            JSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n+            JSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n+            JSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n+            JSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n+\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n+            JSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n+            JSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n+\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n+            JSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n+\n+            JSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPES.put(ImageType.STATIC);\n+\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n+\n+            JSONObject jsonTEC = new JSONObject();\n+            jsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n+\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n+            JSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n+\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n+\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n+            JSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n+\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n+            JSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n+\n+            JSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n+\n+            JSON_SEAT_LOCATIONS.put(JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n+\n+\n+        } catch (JSONException e) {\n+            Log.e(\"Test\", \"Static Json Construction Failed.\", e);\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MDI5NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473370295", "bodyText": "@kostyaBoss In this comment on line 52, you can change this from AmbientLightStatus to AppCapabilityType.", "author": "santhanamk", "createdAt": "2020-08-19T22:05:50Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/enums/AppCapabilityTypeTests.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.smartdevicelink.test.rpc.enums;\n+\n+import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class AppCapabilityTypeTests extends TestCase {\n+\n+    /**\n+     * Verifies that the enum values are not null upon valid assignment.\n+     */\n+    public void testValidEnums () {\n+        String example = \"VIDEO_STREAMING\";\n+        AppCapabilityType enumVideoStreaming = AppCapabilityType.valueForString(example);\n+\n+        assertNotNull(\"VIDEO_STREAMING returned null\", enumVideoStreaming);\n+    }\n+\n+    /**\n+     * Verifies that an invalid assignment is null.\n+     */\n+    public void testInvalidEnum () {\n+        String example = \"VidEOs_Treamin\";\n+        try {\n+            AppCapabilityType temp = AppCapabilityType.valueForString(example);\n+            assertNull(\"Result of valueForString should be null.\", temp);\n+        }\n+        catch (IllegalArgumentException exception) {\n+            fail(\"Invalid enum throws IllegalArgumentException.\");\n+        }\n+    }\n+\n+    /**\n+     * Verifies that a null assignment is invalid.\n+     */\n+    public void testNullEnum () {\n+        String example = null;\n+        try {\n+            AppCapabilityType temp = AppCapabilityType.valueForString(example);\n+            assertNull(\"Result of valueForString should be null.\", temp);\n+        }\n+        catch (NullPointerException exception) {\n+            fail(\"Null string throws NullPointerException.\");\n+        }\n+    }\n+\n+    /**\n+     * Verifies the possible enum values of AmbientLightStatus.", "originalCommit": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/enums/AppCapabilityTypeTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/enums/AppCapabilityTypeTests.java\nindex fa808869a..dd1f08080 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/enums/AppCapabilityTypeTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/enums/AppCapabilityTypeTests.java\n\n@@ -49,7 +49,7 @@ public class AppCapabilityTypeTests extends TestCase {\n     }\n \n     /**\n-     * Verifies the possible enum values of AmbientLightStatus.\n+     * Verifies the possible enum values of AppCapabilityType.\n      */\n     public void testListEnum() {\n         List<AppCapabilityType> enumValueList = Arrays.asList(AppCapabilityType.values());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MjAzOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473372039", "bodyText": "@kostyaBoss You can remove the unused import import android.util.Log; on line 39.", "author": "santhanamk", "createdAt": "2020-08-19T22:08:00Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -36,6 +36,7 @@\n import android.content.Context;\n import android.os.SystemClock;\n import android.util.DisplayMetrics;\n+import android.util.Log;", "originalCommit": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 8bae68234..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -36,26 +36,26 @@ import android.annotation.TargetApi;\n import android.content.Context;\n import android.os.SystemClock;\n import android.util.DisplayMetrics;\n-import android.util.Log;\n import android.view.Display;\n import android.view.InputDevice;\n import android.view.MotionEvent;\n \n-import com.smartdevicelink.SdlConnection.SdlSession;\n+import androidx.annotation.RestrictTo;\n+\n import com.smartdevicelink.encoder.VirtualDisplayEncoder;\n import com.smartdevicelink.managers.BaseSubManager;\n import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n import com.smartdevicelink.managers.StreamingStateMachine;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.protocol.ISdlServiceListener;\n import com.smartdevicelink.managers.video.resolution.AspectRatio;\n import com.smartdevicelink.managers.video.resolution.Resolution;\n import com.smartdevicelink.managers.video.resolution.VideoStreamingRange;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n import com.smartdevicelink.protocol.enums.FunctionID;\n import com.smartdevicelink.protocol.enums.SessionType;\n import com.smartdevicelink.proxy.RPCNotification;\n-import com.smartdevicelink.proxy.interfaces.ISdl;\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n-import com.smartdevicelink.proxy.interfaces.OnSystemCapabilityListener;\n import com.smartdevicelink.proxy.rpc.AppCapability;\n import com.smartdevicelink.proxy.rpc.DisplayCapabilities;\n import com.smartdevicelink.proxy.rpc.ImageResolution;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MzQwMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r473373402", "bodyText": "@kostyaBoss The unused import on line 55 can be removed.", "author": "santhanamk", "createdAt": "2020-08-19T22:09:32Z", "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java", "diffHunk": "@@ -52,6 +52,7 @@\n import com.smartdevicelink.proxy.rpc.SetDisplayLayoutResponse;\n import com.smartdevicelink.proxy.rpc.SoftButtonCapabilities;\n import com.smartdevicelink.proxy.rpc.SystemCapability;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;", "originalCommit": "6994540523a3b5cda4c60e35fe5e779875f6caa3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\nindex f3c67f671..c94f7193c 100644\n--- a/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n+++ b/base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n\n@@ -52,7 +51,6 @@ import com.smartdevicelink.proxy.rpc.SdlMsgVersion;\n import com.smartdevicelink.proxy.rpc.SetDisplayLayoutResponse;\n import com.smartdevicelink.proxy.rpc.SoftButtonCapabilities;\n import com.smartdevicelink.proxy.rpc.SystemCapability;\n-import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n import com.smartdevicelink.proxy.rpc.WindowCapability;\n import com.smartdevicelink.proxy.rpc.WindowTypeCapabilities;\n import com.smartdevicelink.proxy.rpc.enums.DisplayType;\n"}}, {"oid": "e2814610b5026f05f639ff18f34df499908a5db6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e2814610b5026f05f639ff18f34df499908a5db6", "message": "Merge remote-tracking branch 'origin/feature/0296_possibility_to_update_video_streaming_capabilities' into feature/0296_possibility_to_update_video_streaming_capabilities", "committedDate": "2020-08-20T10:17:13Z", "type": "commit"}, {"oid": "79e44f2840619e41d9bf97f8142eddd369a2a419", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/79e44f2840619e41d9bf97f8142eddd369a2a419", "message": "[0296]\n     - Remove unused import", "committedDate": "2020-08-20T21:37:15Z", "type": "commit"}, {"oid": "332f8e66c741bb5ab0430febb40d8c706050dec0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/332f8e66c741bb5ab0430febb40d8c706050dec0", "message": "[VideoStreaming]\n     - Fix multiple review comments, refactor code", "committedDate": "2020-08-20T21:54:07Z", "type": "commit"}, {"oid": "e100f13cdfc8b54cc57e31398dda2204e380c4e0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e100f13cdfc8b54cc57e31398dda2204e380c4e0", "message": "[VideoStreaming]\n     - Fix multiple review comments, refactor code", "committedDate": "2020-08-20T22:07:13Z", "type": "commit"}, {"oid": "0e5b627c96376d480771ebfd6952ed77bed9c6c4", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/0e5b627c96376d480771ebfd6952ed77bed9c6c4", "message": "[VideoStreaming]\n     - Fix multiple review comments, refactor code", "committedDate": "2020-08-20T22:19:42Z", "type": "commit"}, {"oid": "66cc5e9da7fc040c0c67ee9cbac46dd1c68ad488", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/66cc5e9da7fc040c0c67ee9cbac46dd1c68ad488", "message": "[VideoStreaming]\n     - Simplify Logic", "committedDate": "2020-08-20T22:22:10Z", "type": "commit"}, {"oid": "81bc8ee7231d44b1bdba740005706e8c280d8bf6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/81bc8ee7231d44b1bdba740005706e8c280d8bf6", "message": "[VideoStreaming]\n     - Add tests", "committedDate": "2020-08-20T23:04:32Z", "type": "commit"}, {"oid": "2df898e309f66e6889d25e112cbc073dbad9b4a3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/2df898e309f66e6889d25e112cbc073dbad9b4a3", "message": "[VideoStreaming]\n     - Align VideoStreamManager.java according to the proposal's flow", "committedDate": "2020-08-21T08:52:29Z", "type": "commit"}, {"oid": "09efe463a0068e98e98580c794c2710313dcfa46", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/09efe463a0068e98e98580c794c2710313dcfa46", "message": "[VideoStreaming]\n     - Add test for AdditionalCapability", "committedDate": "2020-08-21T09:02:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNTI3NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474815274", "bodyText": "@kostyaBoss On line 314, can you rename privateStringField to sdlRemoteDisplayField?", "author": "santhanamk", "createdAt": "2020-08-21T16:54:49Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java", "diffHunk": "@@ -268,16 +275,60 @@ public void onComplete(boolean success) {\n \t\t\t\thmiListener[0].onNotified(fullNotification);\n \n \t\t\t\tvideoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n-\n \t\t\t\t//assertTrue(touchEventOccured);\n \n-\t\t\t\tvideoStreamManager.dispose();\n \t\t\t\tassertTrue(listenerSet.isEmpty());\n \t\t\t}\n \t\t});\n \n \t}\n \n+\t@Test\n+\tpublic void testOnViewResized() {\n+\t\tISdl internalInterface = mock(ISdl.class);\n+\n+\t\tfinal OnRPCNotificationListener[] hmiListener = {null};\n+\n+\t\tAnswer<Void> onAddHMIListener = new Answer<Void>() {\n+\t\t\t@Override\n+\t\t\tpublic Void answer(InvocationOnMock invocation) {\n+\t\t\t\tObject[] args = invocation.getArguments();\n+\t\t\t\thmiListener[0] = (OnRPCNotificationListener) args[1];\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\n+\t\tdoAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+\n+\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+\t\tvideoStreamManager.start(new CompletionListener() {\n+\t\t\t@Override\n+\t\t\tpublic void onComplete(boolean success) {\n+\t\t\t\tassertTrue(success);\n+\t\t\t\tOnHMIStatus fullNotification = new OnHMIStatus();\n+\t\t\t\tfullNotification.setHmiLevel(HMILevel.HMI_FULL);\n+\t\t\t\thmiListener[0].onNotified(fullNotification);\n+\n+\t\t\t\tvideoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n+\n+\t\t\t\tField privateStringField = null;", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\nindex abd07cbb2..79c3d6240 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n\n@@ -67,479 +68,472 @@ import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentat\n  */\n @RunWith(AndroidJUnit4.class)\n public class VideoStreamManagerTests {\n-\tpublic static final String TAG = \"VideoStreamManagerTests\";\n-\tprivate Context mTestContext;\n-\tprivate static boolean touchEventOccured = false;\n-\tprivate static boolean viewResizedCalled = false;\n-\n-\t// SETUP / HELPERS\n-\n-\t@Before\n-\tpublic void setUp() throws Exception{\n-\t\tmTestContext = getInstrumentation().getContext();\n-\t}\n-\n-\t// TEST CLASSES\n-\n-\tpublic static class TestPresentation extends SdlRemoteDisplay {\n-\t\tView simulatedView = new View(this.getContext());\n-\n-\t\tpublic TestPresentation(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(simulatedView);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tviewResizedCalled = true;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean onTouchEvent(@NonNull MotionEvent event) {\n-\t\t\ttouchEventOccured = true;\n-\t\t\treturn super.onTouchEvent(event);\n-\t\t}\n-\t}\n-\n-\t// TESTS\n-\n-\t@Test\n-\tpublic void testInitialization(){\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn(new Version(5,1,0));\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tAnswer<Void> onAddServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tSessionType sessionType = (SessionType) args[0];\n-\t\t\t\tISdlServiceListener sdlServiceListener = (ISdlServiceListener) args[1];\n-\t\t\t\tassertEquals(sessionType, SessionType.NAV);\n-\t\t\t\tassertNotNull(sdlServiceListener);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddServiceListener).when(internalInterface).addServiceListener(any(SessionType.class), any(ISdlServiceListener.class));\n-\n-\t\tVideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tassertTrue(success);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Test\n-\tpublic void testHMILevelNotFull(){\n-\t\tfinal ISdl internalInterface = mock(ISdl.class);\n-\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn((new Version(5,0,0)));\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\twhen(internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n-\n-\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tboolean encrypted = false;\n-\t\t\t\tvideoStreamManager.startStreaming(params, encrypted);\n-\t\t\t\tverify(internalInterface, times(0)).startVideoService(params, encrypted);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Test\n-\tpublic void testRemoteDisplayStream(){\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tfinal Set<Object> listenerSet = new HashSet<>();\n-\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn(new Version(5,0,0));\n-\t\twhen(internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n-\n-\t\tAnswer<Void> onGetCapability = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tOnSystemCapabilityListener systemCapabilityListener = (OnSystemCapabilityListener) args[1];\n-\t\t\t\tsystemCapabilityListener.onCapabilityRetrieved(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onGetCapability).when(internalInterface).getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class));\n-\n-\t\tAnswer<Void> onAddServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddServiceListener).when(internalInterface).addServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n-\n-\t\tfinal OnRPCNotificationListener[] hmiListener = {null};\n-\n-\t\tAnswer<Void> onAddHMIListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\thmiListener[0] = (OnRPCNotificationListener) args[1];\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onAddTouchListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddTouchListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onRemoveRPCNotificationListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.remove(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n-\t\tdoAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onRemoveServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.remove(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onRemoveServiceListener).when(internalInterface).removeServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n-\n-\t\twhen(internalInterface.startVideoStream(anyBoolean(), any(VideoStreamingParameters.class))).thenReturn(new IVideoStreamListener() {\n-\t\t\t@Override\n-\t\t\tpublic void sendFrame(byte[] data, int offset, int length, long presentationTimeUs) throws ArrayIndexOutOfBoundsException {}\n-\t\t\t@Override\n-\t\t\tpublic void sendFrame(ByteBuffer data, long presentationTimeUs) {}\n-\t\t});\n-\n-\t\twhen(internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\n-\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tassertTrue(success);\n-\t\t\t\tassertTrue(listenerSet.size() == 3);\n-\n-\t\t\t\tOnHMIStatus fullNotification = new OnHMIStatus();\n-\t\t\t\tfullNotification.setHmiLevel(HMILevel.HMI_FULL);\n-\t\t\t\thmiListener[0].onNotified(fullNotification);\n-\n-\t\t\t\tvideoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n-\t\t\t\t//assertTrue(touchEventOccured);\n-\n-\t\t\t\tassertTrue(listenerSet.isEmpty());\n-\t\t\t}\n-\t\t});\n-\n-\t}\n-\n-\t@Test\n-\tpublic void testOnViewResized() {\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\n-\t\tfinal OnRPCNotificationListener[] hmiListener = {null};\n-\n-\t\tAnswer<Void> onAddHMIListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\thmiListener[0] = (OnRPCNotificationListener) args[1];\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n-\n-\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tassertTrue(success);\n-\t\t\t\tOnHMIStatus fullNotification = new OnHMIStatus();\n-\t\t\t\tfullNotification.setHmiLevel(HMILevel.HMI_FULL);\n-\t\t\t\thmiListener[0].onNotified(fullNotification);\n-\n-\t\t\t\tvideoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n-\n-\t\t\t\tField privateStringField = null;\n-\t\t\t\ttry {\n-\t\t\t\t\tprivateStringField = VideoStreamManager.class.\n-\t\t\t\t\t\t\tgetDeclaredField(\"sdlRemoteDisplay\");\n-\t\t\t\t} catch (NoSuchFieldException e) { e.printStackTrace(); }\n-\t\t\t\tprivateStringField.setAccessible(true);\n-\n-\t\t\t\tSdlRemoteDisplay display = null;\n-\t\t\t\ttry {\n-\t\t\t\t\tdisplay = (SdlRemoteDisplay) privateStringField.get(videoStreamManager);\n-\t\t\t\t} catch (IllegalAccessException e) { e.printStackTrace(); }\n-\t\t\t\tdisplay.onViewResized(100, 100);\n-\n-\t\t\t\tassertTrue(viewResizedCalled);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Test\n-\tpublic void testConvertTouchEvent() {\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tVideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tList<MotionEvent> motionEventList;\n-\t\tlong e1TS = 1558124390L, e2TS = 1558125390L, e3TS = 1558126390L;\n-\t\tint e1x = 50, e1y = 100, e2x = 150, e2y = 200, e3x = 250, e3y = 300;\n-\t\tint e1Id = 100, e2Id = 101, e3Id = 102;\n-\t\tint movingStep = 10;\n-\t\tOnTouchEvent testOnTouchEvent;\n-\t\tMotionEvent motionEvent;\n-\t\tTouchEvent touchEvent1 = new TouchEvent(e1Id, Collections.singletonList(e1TS), Collections.singletonList(new TouchCoord(e1x, e1y)));\n-\t\tTouchEvent touchEvent2 = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x, e2y)));\n-\t\tTouchEvent touchEvent2AfterMovingPointer = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x + movingStep, e2y + movingStep)));\n-\t\tTouchEvent touchEvent3 = new TouchEvent(e3Id, Collections.singletonList(e3TS), Collections.singletonList(new TouchCoord(e3x, e3y)));\n-\n-\n-\n-\t\t/////////////////////////////////////////////////// First OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+    public static final String TAG = \"VideoStreamManagerTests\";\n+    private Context mTestContext;\n+    private static boolean touchEventOccured = false;\n+    private static boolean viewResizedCalled = false;\n \n+    // SETUP / HELPERS\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n-\n+    @Before\n+    public void setUp() throws Exception {\n+        mTestContext = getInstrumentation().getContext();\n+    }\n \n-\t\t// Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(1);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    // TEST CLASSES\n \n+    public static class TestPresentation extends SdlRemoteDisplay {\n+        View simulatedView = new View(this.getContext());\n \n+        public TestPresentation(Context context, Display display) {\n+            super(context, display);\n+        }\n \n-\t\t/////////////////////////////////////////////////// Second OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        @Override\n+        protected void onCreate(Bundle savedInstanceState) {\n+            super.onCreate(savedInstanceState);\n+            setContentView(simulatedView);\n+        }\n \n+        @Override\n+        public void onViewResized(int width, int height) {\n+            viewResizedCalled = true;\n+        }\n \n-\t\t// First MotionEvent should be ACTION_POINTER_DOWN and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        @Override\n+        public boolean onTouchEvent(@NonNull MotionEvent event) {\n+            touchEventOccured = true;\n+            return super.onTouchEvent(event);\n+        }\n+    }\n \n+    // TESTS\n \n+    @Test\n+    public void testInitialization() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getProtocolVersion()).thenReturn(new Version(5, 1, 0));\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        Answer<Void> onAddServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                SessionType sessionType = (SessionType) args[0];\n+                ISdlServiceListener sdlServiceListener = (ISdlServiceListener) args[1];\n+                assertEquals(sessionType, SessionType.NAV);\n+                assertNotNull(sdlServiceListener);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddServiceListener).when(internalInterface).addServiceListener(any(SessionType.class), any(ISdlServiceListener.class));\n \n-\t\t/////////////////////////////////////////////////// Third OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.MOVE, Arrays.asList(touchEvent2AfterMovingPointer));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+            }\n+        });\n+    }\n \n+    @Test\n+    public void testHMILevelNotFull() {\n+        final ISdl internalInterface = mock(ISdl.class);\n+\n+        SystemCapabilityManager systemCapabilityManager = mock(SystemCapabilityManager.class);\n+        doReturn(systemCapabilityManager).when(internalInterface).getSystemCapabilityManager();\n+\n+        when(internalInterface.getProtocolVersion()).thenReturn((new Version(5, 0, 0)));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        when(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                boolean encrypted = false;\n+                videoStreamManager.startStreaming(params, encrypted);\n+                verify(internalInterface, times(0)).startVideoService(params, encrypted, false);\n+            }\n+        });\n+    }\n \n-\t\t// First MotionEvent should be ACTION_MOVE and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_MOVE, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    @Test\n+    public void testRemoteDisplayStream() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        final Set<Object> listenerSet = new HashSet<>();\n+\n+        when(internalInterface.getProtocolVersion()).thenReturn(new Version(5, 0, 0));\n+\n+        SystemCapabilityManager systemCapabilityManager = mock(SystemCapabilityManager.class);\n+        doReturn(systemCapabilityManager).when(internalInterface).getSystemCapabilityManager();\n+        when(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n+\n+        Answer<Void> onGetCapability = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnSystemCapabilityListener systemCapabilityListener = (OnSystemCapabilityListener) args[1];\n+                systemCapabilityListener.onCapabilityRetrieved(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onGetCapability).when(systemCapabilityManager).getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class), anyBoolean());\n+\n+        Answer<Void> onAddServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddServiceListener).when(internalInterface).addServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n+\n+        final OnRPCNotificationListener[] hmiListener = {null};\n+\n+        Answer<Void> onAddHMIListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                hmiListener[0] = (OnRPCNotificationListener) args[1];\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onAddTouchListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddTouchListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onRemoveRPCNotificationListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.remove(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+        doAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onRemoveServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.remove(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onRemoveServiceListener).when(internalInterface).removeServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n+\n+        when(systemCapabilityManager.getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class), anyBoolean())).thenReturn(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+                assertTrue(listenerSet.size() == 3);\n+\n+                OnHMIStatus fullNotification = new OnHMIStatus();\n+                fullNotification.setHmiLevel(HMILevel.HMI_FULL);\n+                hmiListener[0].onNotified(fullNotification);\n+\n+                videoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n+                assertTrue(touchEventOccured);\n+                videoStreamManager.dispose();\n+                assertTrue(listenerSet.isEmpty());\n+            }\n+        });\n \n+    }\n \n+    @Test\n+    public void testOnViewResized() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        final OnRPCNotificationListener[] hmiListener = {null};\n+\n+        Answer<Void> onAddHMIListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                hmiListener[0] = (OnRPCNotificationListener) args[1];\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+                OnHMIStatus fullNotification = new OnHMIStatus();\n+                fullNotification.setHmiLevel(HMILevel.HMI_FULL);\n+                hmiListener[0].onNotified(fullNotification);\n+\n+                videoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n+\n+                Field sdlRemoteDisplayField = null;\n+                try {\n+                    sdlRemoteDisplayField =\n+                            VideoStreamManager.class.getDeclaredField(\"sdlRemoteDisplay\");\n+                } catch (NoSuchFieldException e) { e.printStackTrace(); }\n+                sdlRemoteDisplayField.setAccessible(true);\n+\n+                SdlRemoteDisplay display = null;\n+                try {\n+                    display = (SdlRemoteDisplay) sdlRemoteDisplayField.get(videoStreamManager);\n+                } catch (IllegalAccessException e) { e.printStackTrace(); }\n+                display.onViewResized(100, 100);\n+\n+                assertTrue(viewResizedCalled);\n+            }\n+        });\n+    }\n \n-\t\t/////////////////////////////////////////////////// Fourth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent2AfterMovingPointer));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+    @Test\n+    public void testConvertTouchEvent() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n \n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n \n-\t\t// First MotionEvent should be ACTION_POINTER_UP and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        List<MotionEvent> motionEventList;\n+        long e1TS = 1558124390L, e2TS = 1558125390L, e3TS = 1558126390L;\n+        int e1x = 50, e1y = 100, e2x = 150, e2y = 200, e3x = 250, e3y = 300;\n+        int e1Id = 100, e2Id = 101, e3Id = 102;\n+        int movingStep = 10;\n+        OnTouchEvent testOnTouchEvent;\n+        MotionEvent motionEvent;\n+        TouchEvent touchEvent1 = new TouchEvent(e1Id, Collections.singletonList(e1TS), Collections.singletonList(new TouchCoord(e1x, e1y)));\n+        TouchEvent touchEvent2 = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x, e2y)));\n+        TouchEvent touchEvent2AfterMovingPointer = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x + movingStep, e2y + movingStep)));\n+        TouchEvent touchEvent3 = new TouchEvent(e3Id, Collections.singletonList(e3TS), Collections.singletonList(new TouchCoord(e3x, e3y)));\n \n \n+        /////////////////////////////////////////////////// First OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t/////////////////////////////////////////////////// Fifth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n \n-\t\t// First MotionEvent should be ACTION_POINTER_UP and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        // Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n+        motionEvent = motionEventList.get(1);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t/////////////////////////////////////////////////// Sixth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        /////////////////////////////////////////////////// Second OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t// First MotionEvent should be ACTION_UP and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        // First MotionEvent should be ACTION_POINTER_DOWN and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Third OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.MOVE, Arrays.asList(touchEvent2AfterMovingPointer));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n+        // First MotionEvent should be ACTION_MOVE and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_MOVE, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Fourth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent2AfterMovingPointer));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t/////////////////////////////////////////////////// Seventh OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        // First MotionEvent should be ACTION_POINTER_UP and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Fifth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n \n+        // First MotionEvent should be ACTION_POINTER_UP and have 2 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n-\t\t// Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(1);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        /////////////////////////////////////////////////// Sixth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t/////////////////////////////////////////////////// Eighth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.CANCEL, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        // First MotionEvent should be ACTION_UP and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t// First MotionEvent should be ACTION_CANCEL and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_CANCEL, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        /////////////////////////////////////////////////// Seventh OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+\n+\n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n+\n+\n+        // Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n+        motionEvent = motionEventList.get(1);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Eighth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.CANCEL, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n+        // First MotionEvent should be ACTION_CANCEL and have 2 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_CANCEL, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n-\t\t/////////////////////////////////////////////////// Ninth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        /////////////////////////////////////////////////// Ninth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t/////////////////////////////////////////////////// Tenth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent1));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        /////////////////////////////////////////////////// Tenth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent1));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t// First MotionEvent should be ACTION_UP and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-\t}\n+        // First MotionEvent should be ACTION_UP and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    }\n \n-\t@Test\n+    @Test\n     public void testConvertTouchEvent_Scale_1() {\n         assertMotionEventWithScale(800, 480, 1.0f);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyMjM0OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474822349", "bodyText": "On line 66, the variable scale is defined at the class level.  However, here on line 201, it is defined again locally.  I assume you want the class level variable.\nI think you don't need to redefine it.  On line 201, you can change double scale = DEFAULT_SCALE; to scale = DEFAULT_SCALE;", "author": "santhanamk", "createdAt": "2020-08-21T17:09:34Z", "path": "base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "diffHunk": "@@ -184,6 +200,7 @@ public void update(VideoStreamingCapability capability){\n         if(capability.getMaxBitrate()!=null){ this.bitrate = capability.getMaxBitrate() * 1000; } // NOTE: the unit of maxBitrate in getSystemCapability is kbps.\n         double scale = DEFAULT_SCALE;", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\nindex 0b3017c96..5ab5ca931 100644\n--- a/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n+++ b/base/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java\n\n@@ -192,13 +203,13 @@ public class VideoStreamingParameters {\n      * Update the values contained in the capability that should have been returned through the SystemCapabilityManager.\n      * This update will use the most preferred streaming format from the module.\n      * @param capability the video streaming capability returned from the SystemCapabilityManager\n-     * @see com.smartdevicelink.proxy.SystemCapabilityManager\n+     * @see com.smartdevicelink.managers.lifecycle.SystemCapabilityManager\n      * @see VideoStreamingCapability\n      */\n     @Deprecated\n     public void update(VideoStreamingCapability capability){\n         if(capability.getMaxBitrate()!=null){ this.bitrate = capability.getMaxBitrate() * 1000; } // NOTE: the unit of maxBitrate in getSystemCapability is kbps.\n-        double scale = DEFAULT_SCALE;\n+        scale = DEFAULT_SCALE;\n         if(capability.getScale() != null) { scale = capability.getScale(); }\n         if (capability.getDiagonalScreenSize() != null) { preferredDiagonal = capability.getDiagonalScreenSize(); }\n         ImageResolution resolution = capability.getPreferredResolution();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyMzQ2Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474823463", "bodyText": "@kostyaBoss On line 37, you can remove the unused import.", "author": "santhanamk", "createdAt": "2020-08-21T17:11:47Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java", "diffHunk": "@@ -34,6 +34,7 @@\n import com.smartdevicelink.proxy.RPCStruct;\n import com.smartdevicelink.util.SdlDataTypeConverter;\n \n+import java.util.ArrayList;", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\nindex cbd72f797..a0e5a3760 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n\n@@ -34,7 +34,6 @@ package com.smartdevicelink.proxy.rpc;\n import com.smartdevicelink.proxy.RPCStruct;\n import com.smartdevicelink.util.SdlDataTypeConverter;\n \n-import java.util.ArrayList;\n import java.util.Hashtable;\n import java.util.List;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyODM3NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474828375", "bodyText": "@kostyaBoss On line 162, I don't see setAspectRatio defined in VideoStreamingRange.java.  Does this call need to be changed to setMinAspectRatio or setMaxAspectRatio?", "author": "santhanamk", "createdAt": "2020-08-21T17:21:50Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java", "diffHunk": "@@ -133,7 +143,35 @@ public void onDestroy() {\n \t\tsuper.onDestroy();\n \t}\n \n-\tprivate void startProxy() {\n+\tprivate void startStreaming(final MainActivity.STREAM_ENUM value) {\n+\t\tif (sdlManager.getVideoStreamManager() != null) {\n+\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void onComplete(boolean success) {\n+\t\t\t\t\tif (success) {\n+\t\t\t\t\t\tClass myClass;\n+\t\t\t\t\t\tif (value.equals(MainActivity.STREAM_ENUM.START_STREAMING)) {\n+\t\t\t\t\t\t\tmyClass = MyDisplay.class;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tmyClass = UIStreamingDisplay.class;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tVideoStreamingRange.Builder builder = new VideoStreamingRange.Builder();\n+\t\t\t\t\t\tbuilder\n+\t\t\t\t\t\t\t\t.setMaxSupportedResolution(new Resolution(800, 480))\n+\t\t\t\t\t\t\t\t.setMinSupportedResolution(new Resolution(400, 200))\n+\t\t\t\t\t\t\t\t.setAspectRatio(new AspectRatio(1., 6.))", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMTg5OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r477111899", "bodyText": "@santhanamk according to your suggestion, I've rolled back this to hadle as a model. Aspect ratio contains the information about min and max aspects", "author": "kboskin", "createdAt": "2020-08-26T08:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyODM3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\nindex 834e8fd38..0b83e0842 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n\n@@ -7,396 +7,446 @@ import android.app.NotificationManager;\n import android.app.Service;\n import android.content.Context;\n import android.content.Intent;\n-import android.net.Uri;\n import android.os.Build;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.util.Log;\n-import android.view.Display;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.TextView;\n-import android.widget.Toast;\n-import android.widget.VideoView;\n-\n-import com.jakewharton.rxrelay2.PublishRelay;\n+\n import com.smartdevicelink.managers.CompletionListener;\n import com.smartdevicelink.managers.SdlManager;\n import com.smartdevicelink.managers.SdlManagerListener;\n import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n import com.smartdevicelink.managers.lifecycle.LifecycleConfigurationUpdate;\n+import com.smartdevicelink.managers.screen.OnButtonListener;\n import com.smartdevicelink.managers.screen.choiceset.ChoiceCell;\n-import com.smartdevicelink.managers.video.resolution.AspectRatio;\n-import com.smartdevicelink.managers.video.resolution.Resolution;\n-import com.smartdevicelink.managers.video.resolution.VideoStreamingRange;\n+import com.smartdevicelink.managers.screen.choiceset.ChoiceSet;\n+import com.smartdevicelink.managers.screen.choiceset.ChoiceSetSelectionListener;\n+import com.smartdevicelink.managers.screen.menu.MenuCell;\n+import com.smartdevicelink.managers.screen.menu.MenuSelectionListener;\n+import com.smartdevicelink.managers.screen.menu.VoiceCommand;\n+import com.smartdevicelink.managers.screen.menu.VoiceCommandSelectionListener;\n import com.smartdevicelink.protocol.enums.FunctionID;\n import com.smartdevicelink.proxy.RPCNotification;\n-import com.smartdevicelink.proxy.TTSChunkFactory;\n+import com.smartdevicelink.proxy.rpc.Alert;\n+import com.smartdevicelink.proxy.rpc.OnButtonEvent;\n+import com.smartdevicelink.proxy.rpc.OnButtonPress;\n import com.smartdevicelink.proxy.rpc.OnHMIStatus;\n+import com.smartdevicelink.proxy.rpc.Speak;\n+import com.smartdevicelink.proxy.rpc.TTSChunk;\n import com.smartdevicelink.proxy.rpc.enums.AppHMIType;\n+import com.smartdevicelink.proxy.rpc.enums.ButtonName;\n import com.smartdevicelink.proxy.rpc.enums.FileType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n+import com.smartdevicelink.proxy.rpc.enums.InteractionMode;\n import com.smartdevicelink.proxy.rpc.enums.Language;\n+import com.smartdevicelink.proxy.rpc.enums.MenuLayout;\n+import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.enums.TriggerSource;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n-import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.transport.BaseTransportConfig;\n import com.smartdevicelink.transport.MultiplexTransportConfig;\n import com.smartdevicelink.transport.TCPTransportConfig;\n import com.smartdevicelink.util.DebugTool;\n \n-import java.util.HashMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n import java.util.Vector;\n \n-import io.reactivex.functions.Consumer;\n-\n public class SdlService extends Service {\n \n-\tprivate static final String TAG \t\t\t\t\t= \"SDL Service\";\n-\n-\tprivate static final String APP_NAME \t\t\t\t= \"Hello Sdl\";\n-\tprivate static final String APP_NAME_ES \t\t\t= \"Hola Sdl\";\n-\tprivate static final String APP_NAME_FR \t\t\t= \"Bonjour Sdl\";\n-\tprivate static final String APP_ID \t\t\t\t\t= \"8678309\";\n-\n-\tprivate static final String ICON_FILENAME \t\t\t= \"hello_sdl_icon.png\";\n-\tprivate static final String SDL_IMAGE_FILENAME  \t= \"sdl_full_image.png\";\n-\n-\tprivate static final String WELCOME_SHOW \t\t\t= \"Welcome to HelloSDL\";\n-\tprivate static final String WELCOME_SPEAK \t\t\t= \"Welcome to Hello S D L\";\n-\n-\tprivate static final String TEST_COMMAND_NAME \t\t= \"Test Command\";\n-\n-\tprivate static final int FOREGROUND_SERVICE_ID = 111;\n-\n-\t// TCP/IP transport config\n-\t// The default port is 12345\n-\t// The IP is of the machine that is running SDL Core\n-\tprivate static final int TCP_PORT = 12345;\n-\tprivate static final String DEV_MACHINE_IP_ADDRESS = \"192.168.0.104\";\n-\n-\t// variable to create and call functions of the SyncProxy\n-\tprivate SdlManager sdlManager = null;\n-\tprivate List<ChoiceCell> choiceCellList;\n-\tMap<FunctionID, OnRPCNotificationListener> onRPCNotificationListenerMap = new HashMap<>();\n-\tpublic static final PublishRelay<MainActivity.STREAM_ENUM> relay = PublishRelay.create();\n-\n-\t@Override\n-\tpublic IBinder onBind(Intent intent) {\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic void onCreate() {\n-\t\tLog.d(TAG, \"onCreate\");\n-\t\tsuper.onCreate();\n-\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tenterForeground();\n-\t\t}\n-\t}\n-\n-\t// Helper method to let the service enter foreground mode\n-\t@SuppressLint(\"NewApi\")\n-\tpublic void enterForeground() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tNotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n-\t\t\tNotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n-\t\t\tif (notificationManager != null) {\n-\t\t\t\tnotificationManager.createNotificationChannel(channel);\n-\t\t\t\tNotification serviceNotification = new Notification.Builder(this, channel.getId())\n-\t\t\t\t\t\t.setContentTitle(\"Connected through SDL\")\n-\t\t\t\t\t\t.setSmallIcon(R.drawable.ic_sdl)\n-\t\t\t\t\t\t.build();\n-\t\t\t\tstartForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int onStartCommand(Intent intent, int flags, int startId) {\n-\t\tString ip = intent.getStringExtra(MainActivity.IP);\n-\t\tint port = intent.getIntExtra(MainActivity.PORT, 12345);\n-\t\tstartProxy(port, ip);\n-\n-\t\trelay.doOnNext(new Consumer<MainActivity.STREAM_ENUM>() {\n-\t\t\t@Override\n-\t\t\tpublic void accept(MainActivity.STREAM_ENUM stream_enum) throws Exception {\n-\t\t\t\tstartStreaming(stream_enum);\n-\t\t\t}\n-\t\t}).subscribe();\n-\t\treturn START_STICKY;\n-\t}\n-\n-\t@Override\n-\tpublic void onDestroy() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tstopForeground(true);\n-\t\t}\n-\n-\t\tif (sdlManager != null) {\n-\t\t\tsdlManager.dispose();\n-\t\t}\n-\n-\t\tsuper.onDestroy();\n-\t}\n-\n-\tprivate void startStreaming(final MainActivity.STREAM_ENUM value) {\n-\t\tif (sdlManager.getVideoStreamManager() != null) {\n-\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (success) {\n-\t\t\t\t\t\tClass myClass;\n-\t\t\t\t\t\tif (value.equals(MainActivity.STREAM_ENUM.START_STREAMING)) {\n-\t\t\t\t\t\t\tmyClass = MyDisplay.class;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmyClass = UIStreamingDisplay.class;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tVideoStreamingRange.Builder builder = new VideoStreamingRange.Builder();\n-\t\t\t\t\t\tbuilder\n-\t\t\t\t\t\t\t\t.setMaxSupportedResolution(new Resolution(800, 480))\n-\t\t\t\t\t\t\t\t.setMinSupportedResolution(new Resolution(400, 200))\n-\t\t\t\t\t\t\t\t.setAspectRatio(new AspectRatio(1., 6.))\n-\t\t\t\t\t\t\t\t.setMaxScreenDiagonal(20.);\n-\t\t\t\t\t\tVideoStreamingRange range = builder.build();\n-\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), myClass, null, false, range);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void startProxy(int port, String ip) {\n-\t\t// This logic is to select the correct transport and security levels defined in the selected build flavor\n-\t\t// Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n-\t\t// Typically in your app, you will only set one of these.\n-\t\tif (sdlManager == null) {\n-\t\t\tLog.i(TAG, \"Starting SDL Proxy\");\n-\t\t\t// Enable DebugTool for debug build type\n-\t\t\tif (BuildConfig.DEBUG){\n-\t\t\t\tDebugTool.enableDebugTool();\n-\t\t\t}\n-\t\t\tBaseTransportConfig transport = null;\n-\t\t\tif (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n-\t\t\t\tint securityLevel;\n-\t\t\t\tif (BuildConfig.SECURITY.equals(\"HIGH\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"MED\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n-\t\t\t\t} else {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n-\t\t\t\t}\n-\t\t\t\ttransport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\ttransport = new TCPTransportConfig(port, ip, true);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\tMultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n-\t\t\t\tmtc.setRequiresHighBandwidth(true);\n-\t\t\t\ttransport = mtc;\n-\t\t\t}\n-\n-\t\t\t// The app type to be used\n-\t\t\tVector<AppHMIType> appType = new Vector<>();\n-\t\t\tappType.add(AppHMIType.NAVIGATION);\n-\n-\t\t\t// The manager listener helps you know when certain events that pertain to the SDL Manager happen\n-\t\t\t// Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n-\t\t\tSdlManagerListener listener = new SdlManagerListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onStart() {\n-\t\t\t\t\t// HMI Status Listener\n-//\t\t\t\t\tsdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-//\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-//\t\t\t\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus)notification;\n-//\t\t\t\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-//\t\t\t\t\t\t\t\treturn;\n-//\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\tif (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n-//\t\t\t\t\t\t\t\tsetVoiceCommands();\n-//\t\t\t\t\t\t\t\tsendMenus();\n-//\t\t\t\t\t\t\t\tperformWelcomeSpeak();\n-//\t\t\t\t\t\t\t\tperformWelcomeShow();\n-//\t\t\t\t\t\t\t\tpreloadChoices();\n-//\t\t\t\t\t\t\t\tsubscribeToButtons();\n-//\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t}\n-//\t\t\t\t\t});\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onDestroy() {\n-\t\t\t\t\tSdlService.this.stopSelf();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info, Exception e) {\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n-\t\t\t\t\tboolean isNeedUpdate = false;\n-\t\t\t\t\tString appName = APP_NAME;\n-\t\t\t\t\tString ttsName = APP_NAME;\n-\t\t\t\t\tswitch (language) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tswitch (hmiLanguage) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (isNeedUpdate) {\n-\t\t\t\t\t\treturn new LifecycleConfigurationUpdate(appName, null, TTSChunkFactory.createSimpleTTSChunks(ttsName), null);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t\t// Create App Icon, this is set in the SdlManager builder\n-\t\t\tSdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n-\n-\t\t\tonRPCNotificationListenerMap.put(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\t\tOnHMIStatus status = (OnHMIStatus) notification;\n-\t\t\t\t\tif (status != null && status.getHmiLevel() == HMILevel.HMI_NONE) {\n-\t\t\t\t\t\t//Stop the stream\n-\t\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null && sdlManager.getVideoStreamManager().isStreaming()) {\n-\t\t\t\t\t\t\tLog.d(\"OnHmiStatus\", \"stop streaming\");\n-\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().stopStreaming(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\t// The manager builder sets options for your session\n-\t\t\tSdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n-\t\t\tbuilder.setAppTypes(appType);\n-\t\t\tbuilder.setTransportType(transport);\n-\t\t\tbuilder.setAppIcon(appIcon);\n-\t\t\tbuilder.setRPCNotificationListeners(onRPCNotificationListenerMap);\n-\t\t\tsdlManager = builder.build();\n-\t\t\tsdlManager.start();\n-\t\t}\n-\t}\n-\n-\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n-\t\tint clickCounter1 = 0;\n-\t\tint clickCounter2 = 0;\n-\t\tpublic UIStreamingDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.ui_streaming_layout);\n-\n-\n-\t\t\tfinal Button button1 = findViewById(R.id.button_top_left);\n-\t\t\tfinal Button button2 = findViewById(R.id.button_bottom_right);\n-\t\t\tfinal TextView counter1 = findViewById(R.id.button_top_left_counter);\n-\t\t\tfinal TextView counter2 = findViewById(R.id.button_bottom_right_counter);\n-            button1.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter1.setText(\"Click!!! \" + ++clickCounter1);\n-\t\t\t\t\tint location [] = new int[2];\n-                    button1.getLocationInWindow(location);\n-                    //counter1.append(\"\\nButton size: \" + button1.getWidth() + \"x\" + button1.getHeight());\n-\t\t\t\t\t//textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\n-            button2.setOnTouchListener(new View.OnTouchListener() {\n+    private static final String TAG = \"SDL Service\";\n+\n+    private static final String APP_NAME = \"Hello Sdl\";\n+    private static final String APP_NAME_ES = \"Hola Sdl\";\n+    private static final String APP_NAME_FR = \"Bonjour Sdl\";\n+    private static final String APP_ID = \"8678309\";\n+\n+    private static final String ICON_FILENAME = \"hello_sdl_icon.png\";\n+    private static final String SDL_IMAGE_FILENAME = \"sdl_full_image.png\";\n+\n+    private static final String WELCOME_SHOW = \"Welcome to HelloSDL\";\n+    private static final String WELCOME_SPEAK = \"Welcome to Hello S D L\";\n+\n+    private static final String TEST_COMMAND_NAME = \"Test Command\";\n+\n+    private static final int FOREGROUND_SERVICE_ID = 111;\n+\n+    // TCP/IP transport config\n+    // The default port is 12345\n+    // The IP is of the machine that is running SDL Core\n+    private static final int TCP_PORT = 12247;\n+    private static final String DEV_MACHINE_IP_ADDRESS = \"m.sdl.tools\";\n+\n+    // variable to create and call functions of the SyncProxy\n+    private SdlManager sdlManager = null;\n+    private List<ChoiceCell> choiceCellList;\n+\n+    @Override\n+    public IBinder onBind(Intent intent) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void onCreate() {\n+        Log.d(TAG, \"onCreate\");\n+        super.onCreate();\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            enterForeground();\n+        }\n+    }\n+\n+    // Helper method to let the service enter foreground mode\n+    @SuppressLint(\"NewApi\")\n+    public void enterForeground() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            NotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n+            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n+            if (notificationManager != null) {\n+                notificationManager.createNotificationChannel(channel);\n+                Notification serviceNotification = new Notification.Builder(this, channel.getId())\n+                        .setContentTitle(\"Connected through SDL\")\n+                        .setSmallIcon(R.drawable.ic_sdl)\n+                        .build();\n+                startForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int onStartCommand(Intent intent, int flags, int startId) {\n+        startProxy();\n+        return START_STICKY;\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            stopForeground(true);\n+        }\n+\n+        if (sdlManager != null) {\n+            sdlManager.dispose();\n+        }\n+\n+        super.onDestroy();\n+    }\n+\n+    private void startProxy() {\n+        // This logic is to select the correct transport and security levels defined in the selected build flavor\n+        // Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n+        // Typically in your app, you will only set one of these.\n+        if (sdlManager == null) {\n+            Log.i(TAG, \"Starting SDL Proxy\");\n+            // Enable DebugTool for debug build type\n+            if (BuildConfig.DEBUG) {\n+                DebugTool.enableDebugTool();\n+            }\n+            BaseTransportConfig transport = null;\n+            if (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n+                int securityLevel;\n+                if (BuildConfig.SECURITY.equals(\"HIGH\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n+                } else if (BuildConfig.SECURITY.equals(\"MED\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n+                } else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n+                } else {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n+                }\n+                transport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n+            } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+                transport = new TCPTransportConfig(TCP_PORT, DEV_MACHINE_IP_ADDRESS, true);\n+            } else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+                MultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n+                mtc.setRequiresHighBandwidth(true);\n+                transport = mtc;\n+            }\n+\n+            // The app type to be used\n+            Vector<AppHMIType> appType = new Vector<>();\n+            appType.add(AppHMIType.DEFAULT);\n+\n+            // The manager listener helps you know when certain events that pertain to the SDL Manager happen\n+            // Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n+            SdlManagerListener listener = new SdlManagerListener() {\n+                @Override\n+                public void onStart() {\n+                    // HMI Status Listener\n+                    sdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n+                        @Override\n+                        public void onNotified(RPCNotification notification) {\n+                            OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                            if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                                return;\n+                            }\n+                            if (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n+                                setVoiceCommands();\n+                                sendMenus();\n+                                performWelcomeSpeak();\n+                                performWelcomeShow();\n+                                preloadChoices();\n+                                subscribeToButtons();\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onDestroy() {\n+                    SdlService.this.stopSelf();\n+                }\n+\n+                @Override\n+                public void onError(String info, Exception e) {\n+                }\n+\n+                @Override\n+                public LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n+                    boolean isNeedUpdate = false;\n+                    String appName = APP_NAME;\n+                    String ttsName = APP_NAME;\n+                    switch (language) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    switch (hmiLanguage) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    if (isNeedUpdate) {\n+                        Vector<TTSChunk> chunks = new Vector<>(Collections.singletonList(new TTSChunk(ttsName, SpeechCapabilities.TEXT)));\n+                        return new LifecycleConfigurationUpdate(appName, null, chunks, null);\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+            };\n+\n+            // Create App Icon, this is set in the SdlManager builder\n+            SdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n+\n+            // The manager builder sets options for your session\n+            SdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n+            builder.setAppTypes(appType);\n+            builder.setTransportType(transport);\n+            builder.setAppIcon(appIcon);\n+            sdlManager = builder.build();\n+            sdlManager.start();\n+        }\n+    }\n+\n+    /**\n+     * Send some voice commands\n+     */\n+    private void setVoiceCommands() {\n+\n+        List<String> list1 = Collections.singletonList(\"Command One\");\n+        List<String> list2 = Collections.singletonList(\"Command two\");\n+\n+        VoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 1 triggered\");\n+            }\n+        });\n+\n+        VoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 2 triggered\");\n+            }\n+        });\n+\n+        sdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1, voiceCommand2));\n+    }\n+\n+    /**\n+     * Add menus for the app on SDL.\n+     */\n+    private void sendMenus() {\n+\n+        // some arts\n+        SdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n+\n+        // some voice commands\n+        List<String> voice2 = Collections.singletonList(\"Cell two\");\n+\n+        MenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 1 triggered. Source: \" + trigger.toString());\n+                showTest();\n+            }\n+        });\n+\n+        MenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // SUB MENU\n+\n+        MenuCell subCell1 = new MenuCell(\"SubCell 1\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 1 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        MenuCell subCell2 = new MenuCell(\"SubCell 2\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // sub menu parent cell\n+        MenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", MenuLayout.LIST, null, Arrays.asList(subCell1, subCell2));\n+\n+        MenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                showPerformInteraction();\n+            }\n+        });\n+\n+        MenuCell mainCell5 = new MenuCell(\"Clear the menu\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Clearing Menu. Source: \" + trigger.toString());\n+                // Clear this thing\n+                sdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n+                showAlert(\"Menu Cleared\");\n+            }\n+        });\n+\n+        // Send the entire menu off to be created\n+        sdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n+    }\n+\n+    /**\n+     * Will speak a sample welcome message\n+     */\n+    private void performWelcomeSpeak() {\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(WELCOME_SPEAK, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    /**\n+     * Use the Screen Manager to set the initial screen text and set the image.\n+     * Because we are setting multiple items, we will call beginTransaction() first,\n+     * and finish with commit() when we are done.\n+     */\n+    private void performWelcomeShow() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(APP_NAME);\n+        sdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n+        sdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n+        sdlManager.getScreenManager().commit(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                if (success) {\n+                    Log.i(TAG, \"welcome show successful\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Attempts to Subscribe to all preset buttons\n+     */\n+    private void subscribeToButtons() {\n+        ButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n+                ButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n+                ButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n+\n+        OnButtonListener onButtonListener = new OnButtonListener() {\n+            @Override\n+            public void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n+                sdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n+            }\n+\n+            @Override\n+            public void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n+                sdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                Log.i(TAG, \"onError: \" + info);\n+            }\n+        };\n+\n+        for (ButtonName buttonName : buttonNames) {\n+            sdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n+        }\n+    }\n+\n+    /**\n+     * Will show a sample test message on screen as well as speak a sample test message\n+     */\n+    private void showTest() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n+        sdlManager.getScreenManager().setTextField2(\"\");\n+        sdlManager.getScreenManager().commit(null);\n+\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(TEST_COMMAND_NAME, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    private void showAlert(String text) {\n+        Alert alert = new Alert();\n+        alert.setAlertText1(text);\n+        alert.setDuration(5000);\n+        sdlManager.sendRPC(alert);\n+    }\n+\n+    // Choice Set\n+\n+    private void preloadChoices() {\n+        ChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n+        ChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n+        ChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n+        choiceCellList = new ArrayList<>(Arrays.asList(cell1, cell2, cell3));\n+        sdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n+    }\n+\n+    private void showPerformInteraction() {\n+        if (choiceCellList != null) {\n+            ChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n+                @Override\n+                public void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n+                    showAlert(choiceCell.getText() + \" was selected\");\n+                }\n+\n                 @Override\n-                public boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter2.setText(\"Click!!! \" + ++clickCounter2);\n-                    int location [] = new int[2];\n-                    button2.getLocationInWindow(location);\n-                    //counter2.append(\"\\nButton size: \" + button.getWidth() + \"x\" + button.getHeight());\n-                    //textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-                    return false;\n+                public void onError(String error) {\n+                    Log.e(TAG, \"There was an error showing the perform interaction: \" + error);\n                 }\n             });\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n-\t}\n-\n-\tpublic static class MyDisplay extends SdlRemoteDisplay {\n-\t\tpublic MyDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.streaming_layout);\n-\n-\n-\t\t\tString videoUri = \"android.resource://\" + getContext().getPackageName() + \"/\" + R.raw.sdl;\n-\t\t\tfinal VideoView videoView = findViewById(R.id.videoView);\n-\t\t\tvideoView.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\t\t\t\t\tint[] location = new int[2];\n-\t\t\t\t\tvideoView.getLocationInWindow(location);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"View size \" + videoView.getWidth() + \"x\" + videoView.getHeight());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Location \" + location[0] + \" \" + location[1]);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Count: \" + motionEvent.getPointerCount());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Click(\" + motionEvent.getX() + \" \" + motionEvent.getY() + \" Raw \" + motionEvent.getRawX() + \" \" + motionEvent.getRawY());\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tvideoView.setVideoURI(Uri.parse(videoUri));\n-\t\t\tvideoView.start();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n+            sdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0NDE4MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474844181", "bodyText": "@kostyaBoss On lines 325-328, can you rename the variables to match with your layout file names?\nSo button1 can be renamed to buttonTopLeft, button2 can be renamed to buttonBottomRight, counter1 can be renamed to textViewTopLeftCounter, and counter2 can be renamed to textViewBottomRightCounter.\nIt would look like this:\nfinal Button buttonTopLeft = findViewById(R.id.button_top_left);\nfinal Button buttonBottomRight = findViewById(R.id.button_bottom_right);\nfinal TextView textViewTopLeftCounter = findViewById(R.id.textView_top_left_counter);\nfinal TextView textViewBottomRightCounter = findViewById(R.id.textView_bottom_right_counter);", "author": "santhanamk", "createdAt": "2020-08-21T17:54:48Z", "path": "android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java", "diffHunk": "@@ -247,207 +285,118 @@ public LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language langua\n \t\t\t// Create App Icon, this is set in the SdlManager builder\n \t\t\tSdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n \n+\t\t\tonRPCNotificationListenerMap.put(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void onNotified(RPCNotification notification) {\n+\t\t\t\t\tOnHMIStatus status = (OnHMIStatus) notification;\n+\t\t\t\t\tif (status != null && status.getHmiLevel() == HMILevel.HMI_NONE) {\n+\t\t\t\t\t\t//Stop the stream\n+\t\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null && sdlManager.getVideoStreamManager().isStreaming()) {\n+\t\t\t\t\t\t\tLog.d(\"OnHmiStatus\", \"stop streaming\");\n+\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().stopStreaming(false);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n \t\t\t// The manager builder sets options for your session\n \t\t\tSdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n \t\t\tbuilder.setAppTypes(appType);\n \t\t\tbuilder.setTransportType(transport);\n \t\t\tbuilder.setAppIcon(appIcon);\n+\t\t\tbuilder.setRPCNotificationListeners(onRPCNotificationListenerMap);\n \t\t\tsdlManager = builder.build();\n \t\t\tsdlManager.start();\n \t\t}\n \t}\n \n-\t/**\n-\t * Send some voice commands\n-\t */\n-\tprivate void setVoiceCommands(){\n-\n-\t\tList<String> list1 = Collections.singletonList(\"Command One\");\n-\t\tList<String> list2 = Collections.singletonList(\"Command two\");\n-\n-\t\tVoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 1 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tVoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onVoiceCommandSelected() {\n-\t\t\t\tLog.i(TAG, \"Voice Command 2 triggered\");\n-\t\t\t}\n-\t\t});\n-\n-\t\tsdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1,voiceCommand2));\n-\t}\n-\n-\t/**\n-\t *  Add menus for the app on SDL.\n-\t */\n-\tprivate void sendMenus(){\n-\n-\t\t// some arts\n-\t\tSdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n-\n-\t\t// some voice commands\n-\t\tList<String> voice2 = Collections.singletonList(\"Cell two\");\n-\n-\t\tMenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t\tshowTest();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Test cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// SUB MENU\n-\n-\t\tMenuCell subCell1 = new MenuCell(\"SubCell 1\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 1 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell subCell2 = new MenuCell(\"SubCell 2\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Sub cell 2 triggered. Source: \"+ trigger.toString());\n-\t\t\t}\n-\t\t});\n-\n-\t\t// sub menu parent cell\n-\t\tMenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", MenuLayout.LIST, null, Arrays.asList(subCell1,subCell2));\n-\n-\t\tMenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tshowPerformInteraction();\n-\t\t\t}\n-\t\t});\n-\n-\t\tMenuCell mainCell5 = new MenuCell(\"Clear the menu\",null, null, new MenuSelectionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onTriggered(TriggerSource trigger) {\n-\t\t\t\tLog.i(TAG, \"Clearing Menu. Source: \"+ trigger.toString());\n-\t\t\t\t// Clear this thing\n-\t\t\t\tsdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n-\t\t\t\tshowAlert(\"Menu Cleared\");\n-\t\t\t}\n-\t\t});\n+\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n+\t\tint clickCounter1 = 0;\n+\t\tint clickCounter2 = 0;\n+\t\tpublic UIStreamingDisplay(Context context, Display display) {\n+\t\t\tsuper(context, display);\n+\t\t}\n \n-\t\t// Send the entire menu off to be created\n-\t\tsdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n-\t}\n+\t\t@Override\n+\t\tprotected void onCreate(Bundle savedInstanceState) {\n+\t\t\tsuper.onCreate(savedInstanceState);\n+\t\t\tsetContentView(R.layout.ui_streaming_layout);\n \n-\t/**\n-\t * Will speak a sample welcome message\n-\t */\n-\tprivate void performWelcomeSpeak(){\n-\t\tsdlManager.sendRPC(new Speak(TTSChunkFactory.createSimpleTTSChunks(WELCOME_SPEAK)));\n-\t}\n \n-\t/**\n-\t * Use the Screen Manager to set the initial screen text and set the image.\n-\t * Because we are setting multiple items, we will call beginTransaction() first,\n-\t * and finish with commit() when we are done.\n-\t */\n-\tprivate void performWelcomeShow() {\n-\t\tsdlManager.getScreenManager().beginTransaction();\n-\t\tsdlManager.getScreenManager().setTextField1(APP_NAME);\n-\t\tsdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n-\t\tsdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n-\t\tsdlManager.getScreenManager().commit(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tif (success){\n-\t\t\t\t\tLog.i(TAG, \"welcome show successful\");\n+\t\t\tfinal Button button1 = findViewById(R.id.button_top_left);\n+\t\t\tfinal Button button2 = findViewById(R.id.button_bottom_right);\n+\t\t\tfinal TextView counter1 = findViewById(R.id.button_top_left_counter);\n+\t\t\tfinal TextView counter2 = findViewById(R.id.button_bottom_right_counter);\n+            button1.setOnTouchListener(new View.OnTouchListener() {", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\nindex 834e8fd38..0b83e0842 100755\n--- a/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n+++ b/android/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n\n@@ -7,396 +7,446 @@ import android.app.NotificationManager;\n import android.app.Service;\n import android.content.Context;\n import android.content.Intent;\n-import android.net.Uri;\n import android.os.Build;\n-import android.os.Bundle;\n import android.os.IBinder;\n import android.util.Log;\n-import android.view.Display;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.TextView;\n-import android.widget.Toast;\n-import android.widget.VideoView;\n-\n-import com.jakewharton.rxrelay2.PublishRelay;\n+\n import com.smartdevicelink.managers.CompletionListener;\n import com.smartdevicelink.managers.SdlManager;\n import com.smartdevicelink.managers.SdlManagerListener;\n import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n import com.smartdevicelink.managers.lifecycle.LifecycleConfigurationUpdate;\n+import com.smartdevicelink.managers.screen.OnButtonListener;\n import com.smartdevicelink.managers.screen.choiceset.ChoiceCell;\n-import com.smartdevicelink.managers.video.resolution.AspectRatio;\n-import com.smartdevicelink.managers.video.resolution.Resolution;\n-import com.smartdevicelink.managers.video.resolution.VideoStreamingRange;\n+import com.smartdevicelink.managers.screen.choiceset.ChoiceSet;\n+import com.smartdevicelink.managers.screen.choiceset.ChoiceSetSelectionListener;\n+import com.smartdevicelink.managers.screen.menu.MenuCell;\n+import com.smartdevicelink.managers.screen.menu.MenuSelectionListener;\n+import com.smartdevicelink.managers.screen.menu.VoiceCommand;\n+import com.smartdevicelink.managers.screen.menu.VoiceCommandSelectionListener;\n import com.smartdevicelink.protocol.enums.FunctionID;\n import com.smartdevicelink.proxy.RPCNotification;\n-import com.smartdevicelink.proxy.TTSChunkFactory;\n+import com.smartdevicelink.proxy.rpc.Alert;\n+import com.smartdevicelink.proxy.rpc.OnButtonEvent;\n+import com.smartdevicelink.proxy.rpc.OnButtonPress;\n import com.smartdevicelink.proxy.rpc.OnHMIStatus;\n+import com.smartdevicelink.proxy.rpc.Speak;\n+import com.smartdevicelink.proxy.rpc.TTSChunk;\n import com.smartdevicelink.proxy.rpc.enums.AppHMIType;\n+import com.smartdevicelink.proxy.rpc.enums.ButtonName;\n import com.smartdevicelink.proxy.rpc.enums.FileType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n+import com.smartdevicelink.proxy.rpc.enums.InteractionMode;\n import com.smartdevicelink.proxy.rpc.enums.Language;\n+import com.smartdevicelink.proxy.rpc.enums.MenuLayout;\n+import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.enums.TriggerSource;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n-import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.transport.BaseTransportConfig;\n import com.smartdevicelink.transport.MultiplexTransportConfig;\n import com.smartdevicelink.transport.TCPTransportConfig;\n import com.smartdevicelink.util.DebugTool;\n \n-import java.util.HashMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n import java.util.Vector;\n \n-import io.reactivex.functions.Consumer;\n-\n public class SdlService extends Service {\n \n-\tprivate static final String TAG \t\t\t\t\t= \"SDL Service\";\n-\n-\tprivate static final String APP_NAME \t\t\t\t= \"Hello Sdl\";\n-\tprivate static final String APP_NAME_ES \t\t\t= \"Hola Sdl\";\n-\tprivate static final String APP_NAME_FR \t\t\t= \"Bonjour Sdl\";\n-\tprivate static final String APP_ID \t\t\t\t\t= \"8678309\";\n-\n-\tprivate static final String ICON_FILENAME \t\t\t= \"hello_sdl_icon.png\";\n-\tprivate static final String SDL_IMAGE_FILENAME  \t= \"sdl_full_image.png\";\n-\n-\tprivate static final String WELCOME_SHOW \t\t\t= \"Welcome to HelloSDL\";\n-\tprivate static final String WELCOME_SPEAK \t\t\t= \"Welcome to Hello S D L\";\n-\n-\tprivate static final String TEST_COMMAND_NAME \t\t= \"Test Command\";\n-\n-\tprivate static final int FOREGROUND_SERVICE_ID = 111;\n-\n-\t// TCP/IP transport config\n-\t// The default port is 12345\n-\t// The IP is of the machine that is running SDL Core\n-\tprivate static final int TCP_PORT = 12345;\n-\tprivate static final String DEV_MACHINE_IP_ADDRESS = \"192.168.0.104\";\n-\n-\t// variable to create and call functions of the SyncProxy\n-\tprivate SdlManager sdlManager = null;\n-\tprivate List<ChoiceCell> choiceCellList;\n-\tMap<FunctionID, OnRPCNotificationListener> onRPCNotificationListenerMap = new HashMap<>();\n-\tpublic static final PublishRelay<MainActivity.STREAM_ENUM> relay = PublishRelay.create();\n-\n-\t@Override\n-\tpublic IBinder onBind(Intent intent) {\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic void onCreate() {\n-\t\tLog.d(TAG, \"onCreate\");\n-\t\tsuper.onCreate();\n-\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tenterForeground();\n-\t\t}\n-\t}\n-\n-\t// Helper method to let the service enter foreground mode\n-\t@SuppressLint(\"NewApi\")\n-\tpublic void enterForeground() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tNotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n-\t\t\tNotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n-\t\t\tif (notificationManager != null) {\n-\t\t\t\tnotificationManager.createNotificationChannel(channel);\n-\t\t\t\tNotification serviceNotification = new Notification.Builder(this, channel.getId())\n-\t\t\t\t\t\t.setContentTitle(\"Connected through SDL\")\n-\t\t\t\t\t\t.setSmallIcon(R.drawable.ic_sdl)\n-\t\t\t\t\t\t.build();\n-\t\t\t\tstartForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic int onStartCommand(Intent intent, int flags, int startId) {\n-\t\tString ip = intent.getStringExtra(MainActivity.IP);\n-\t\tint port = intent.getIntExtra(MainActivity.PORT, 12345);\n-\t\tstartProxy(port, ip);\n-\n-\t\trelay.doOnNext(new Consumer<MainActivity.STREAM_ENUM>() {\n-\t\t\t@Override\n-\t\t\tpublic void accept(MainActivity.STREAM_ENUM stream_enum) throws Exception {\n-\t\t\t\tstartStreaming(stream_enum);\n-\t\t\t}\n-\t\t}).subscribe();\n-\t\treturn START_STICKY;\n-\t}\n-\n-\t@Override\n-\tpublic void onDestroy() {\n-\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-\t\t\tstopForeground(true);\n-\t\t}\n-\n-\t\tif (sdlManager != null) {\n-\t\t\tsdlManager.dispose();\n-\t\t}\n-\n-\t\tsuper.onDestroy();\n-\t}\n-\n-\tprivate void startStreaming(final MainActivity.STREAM_ENUM value) {\n-\t\tif (sdlManager.getVideoStreamManager() != null) {\n-\t\t\tsdlManager.getVideoStreamManager().start(new CompletionListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\tif (success) {\n-\t\t\t\t\t\tClass myClass;\n-\t\t\t\t\t\tif (value.equals(MainActivity.STREAM_ENUM.START_STREAMING)) {\n-\t\t\t\t\t\t\tmyClass = MyDisplay.class;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmyClass = UIStreamingDisplay.class;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tVideoStreamingRange.Builder builder = new VideoStreamingRange.Builder();\n-\t\t\t\t\t\tbuilder\n-\t\t\t\t\t\t\t\t.setMaxSupportedResolution(new Resolution(800, 480))\n-\t\t\t\t\t\t\t\t.setMinSupportedResolution(new Resolution(400, 200))\n-\t\t\t\t\t\t\t\t.setAspectRatio(new AspectRatio(1., 6.))\n-\t\t\t\t\t\t\t\t.setMaxScreenDiagonal(20.);\n-\t\t\t\t\t\tVideoStreamingRange range = builder.build();\n-\t\t\t\t\t\tsdlManager.getVideoStreamManager().startRemoteDisplayStream(getApplicationContext(), myClass, null, false, range);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tLog.e(TAG, \"Failed to start video streaming manager\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n-\tprivate void startProxy(int port, String ip) {\n-\t\t// This logic is to select the correct transport and security levels defined in the selected build flavor\n-\t\t// Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n-\t\t// Typically in your app, you will only set one of these.\n-\t\tif (sdlManager == null) {\n-\t\t\tLog.i(TAG, \"Starting SDL Proxy\");\n-\t\t\t// Enable DebugTool for debug build type\n-\t\t\tif (BuildConfig.DEBUG){\n-\t\t\t\tDebugTool.enableDebugTool();\n-\t\t\t}\n-\t\t\tBaseTransportConfig transport = null;\n-\t\t\tif (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n-\t\t\t\tint securityLevel;\n-\t\t\t\tif (BuildConfig.SECURITY.equals(\"HIGH\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"MED\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n-\t\t\t\t} else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n-\t\t\t\t} else {\n-\t\t\t\t\tsecurityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n-\t\t\t\t}\n-\t\t\t\ttransport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n-\t\t\t\ttransport = new TCPTransportConfig(port, ip, true);\n-\t\t\t} else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n-\t\t\t\tMultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n-\t\t\t\tmtc.setRequiresHighBandwidth(true);\n-\t\t\t\ttransport = mtc;\n-\t\t\t}\n-\n-\t\t\t// The app type to be used\n-\t\t\tVector<AppHMIType> appType = new Vector<>();\n-\t\t\tappType.add(AppHMIType.NAVIGATION);\n-\n-\t\t\t// The manager listener helps you know when certain events that pertain to the SDL Manager happen\n-\t\t\t// Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n-\t\t\tSdlManagerListener listener = new SdlManagerListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onStart() {\n-\t\t\t\t\t// HMI Status Listener\n-//\t\t\t\t\tsdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-//\t\t\t\t\t\t@Override\n-//\t\t\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-//\t\t\t\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus)notification;\n-//\t\t\t\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-//\t\t\t\t\t\t\t\treturn;\n-//\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t\tif (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n-//\t\t\t\t\t\t\t\tsetVoiceCommands();\n-//\t\t\t\t\t\t\t\tsendMenus();\n-//\t\t\t\t\t\t\t\tperformWelcomeSpeak();\n-//\t\t\t\t\t\t\t\tperformWelcomeShow();\n-//\t\t\t\t\t\t\t\tpreloadChoices();\n-//\t\t\t\t\t\t\t\tsubscribeToButtons();\n-//\t\t\t\t\t\t\t}\n-//\t\t\t\t\t\t}\n-//\t\t\t\t\t});\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onDestroy() {\n-\t\t\t\t\tSdlService.this.stopSelf();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info, Exception e) {\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n-\t\t\t\t\tboolean isNeedUpdate = false;\n-\t\t\t\t\tString appName = APP_NAME;\n-\t\t\t\t\tString ttsName = APP_NAME;\n-\t\t\t\t\tswitch (language) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tttsName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tswitch (hmiLanguage) {\n-\t\t\t\t\t\tcase ES_MX:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_ES;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase FR_CA:\n-\t\t\t\t\t\t\tisNeedUpdate = true;\n-\t\t\t\t\t\t\tappName = APP_NAME_FR;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (isNeedUpdate) {\n-\t\t\t\t\t\treturn new LifecycleConfigurationUpdate(appName, null, TTSChunkFactory.createSimpleTTSChunks(ttsName), null);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t\t// Create App Icon, this is set in the SdlManager builder\n-\t\t\tSdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n-\n-\t\t\tonRPCNotificationListenerMap.put(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\t\t\tOnHMIStatus status = (OnHMIStatus) notification;\n-\t\t\t\t\tif (status != null && status.getHmiLevel() == HMILevel.HMI_NONE) {\n-\t\t\t\t\t\t//Stop the stream\n-\t\t\t\t\t\tif (sdlManager.getVideoStreamManager() != null && sdlManager.getVideoStreamManager().isStreaming()) {\n-\t\t\t\t\t\t\tLog.d(\"OnHmiStatus\", \"stop streaming\");\n-\t\t\t\t\t\t\tsdlManager.getVideoStreamManager().stopStreaming(false);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\t// The manager builder sets options for your session\n-\t\t\tSdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n-\t\t\tbuilder.setAppTypes(appType);\n-\t\t\tbuilder.setTransportType(transport);\n-\t\t\tbuilder.setAppIcon(appIcon);\n-\t\t\tbuilder.setRPCNotificationListeners(onRPCNotificationListenerMap);\n-\t\t\tsdlManager = builder.build();\n-\t\t\tsdlManager.start();\n-\t\t}\n-\t}\n-\n-\tpublic static class UIStreamingDisplay extends SdlRemoteDisplay {\n-\t\tint clickCounter1 = 0;\n-\t\tint clickCounter2 = 0;\n-\t\tpublic UIStreamingDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.ui_streaming_layout);\n-\n-\n-\t\t\tfinal Button button1 = findViewById(R.id.button_top_left);\n-\t\t\tfinal Button button2 = findViewById(R.id.button_bottom_right);\n-\t\t\tfinal TextView counter1 = findViewById(R.id.button_top_left_counter);\n-\t\t\tfinal TextView counter2 = findViewById(R.id.button_bottom_right_counter);\n-            button1.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter1.setText(\"Click!!! \" + ++clickCounter1);\n-\t\t\t\t\tint location [] = new int[2];\n-                    button1.getLocationInWindow(location);\n-                    //counter1.append(\"\\nButton size: \" + button1.getWidth() + \"x\" + button1.getHeight());\n-\t\t\t\t\t//textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\n-            button2.setOnTouchListener(new View.OnTouchListener() {\n+    private static final String TAG = \"SDL Service\";\n+\n+    private static final String APP_NAME = \"Hello Sdl\";\n+    private static final String APP_NAME_ES = \"Hola Sdl\";\n+    private static final String APP_NAME_FR = \"Bonjour Sdl\";\n+    private static final String APP_ID = \"8678309\";\n+\n+    private static final String ICON_FILENAME = \"hello_sdl_icon.png\";\n+    private static final String SDL_IMAGE_FILENAME = \"sdl_full_image.png\";\n+\n+    private static final String WELCOME_SHOW = \"Welcome to HelloSDL\";\n+    private static final String WELCOME_SPEAK = \"Welcome to Hello S D L\";\n+\n+    private static final String TEST_COMMAND_NAME = \"Test Command\";\n+\n+    private static final int FOREGROUND_SERVICE_ID = 111;\n+\n+    // TCP/IP transport config\n+    // The default port is 12345\n+    // The IP is of the machine that is running SDL Core\n+    private static final int TCP_PORT = 12247;\n+    private static final String DEV_MACHINE_IP_ADDRESS = \"m.sdl.tools\";\n+\n+    // variable to create and call functions of the SyncProxy\n+    private SdlManager sdlManager = null;\n+    private List<ChoiceCell> choiceCellList;\n+\n+    @Override\n+    public IBinder onBind(Intent intent) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void onCreate() {\n+        Log.d(TAG, \"onCreate\");\n+        super.onCreate();\n+\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            enterForeground();\n+        }\n+    }\n+\n+    // Helper method to let the service enter foreground mode\n+    @SuppressLint(\"NewApi\")\n+    public void enterForeground() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            NotificationChannel channel = new NotificationChannel(APP_ID, \"SdlService\", NotificationManager.IMPORTANCE_DEFAULT);\n+            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n+            if (notificationManager != null) {\n+                notificationManager.createNotificationChannel(channel);\n+                Notification serviceNotification = new Notification.Builder(this, channel.getId())\n+                        .setContentTitle(\"Connected through SDL\")\n+                        .setSmallIcon(R.drawable.ic_sdl)\n+                        .build();\n+                startForeground(FOREGROUND_SERVICE_ID, serviceNotification);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int onStartCommand(Intent intent, int flags, int startId) {\n+        startProxy();\n+        return START_STICKY;\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n+            stopForeground(true);\n+        }\n+\n+        if (sdlManager != null) {\n+            sdlManager.dispose();\n+        }\n+\n+        super.onDestroy();\n+    }\n+\n+    private void startProxy() {\n+        // This logic is to select the correct transport and security levels defined in the selected build flavor\n+        // Build flavors are selected by the \"build variants\" tab typically located in the bottom left of Android Studio\n+        // Typically in your app, you will only set one of these.\n+        if (sdlManager == null) {\n+            Log.i(TAG, \"Starting SDL Proxy\");\n+            // Enable DebugTool for debug build type\n+            if (BuildConfig.DEBUG) {\n+                DebugTool.enableDebugTool();\n+            }\n+            BaseTransportConfig transport = null;\n+            if (BuildConfig.TRANSPORT.equals(\"MULTI\")) {\n+                int securityLevel;\n+                if (BuildConfig.SECURITY.equals(\"HIGH\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_HIGH;\n+                } else if (BuildConfig.SECURITY.equals(\"MED\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_MED;\n+                } else if (BuildConfig.SECURITY.equals(\"LOW\")) {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_LOW;\n+                } else {\n+                    securityLevel = MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF;\n+                }\n+                transport = new MultiplexTransportConfig(this, APP_ID, securityLevel);\n+            } else if (BuildConfig.TRANSPORT.equals(\"TCP\")) {\n+                transport = new TCPTransportConfig(TCP_PORT, DEV_MACHINE_IP_ADDRESS, true);\n+            } else if (BuildConfig.TRANSPORT.equals(\"MULTI_HB\")) {\n+                MultiplexTransportConfig mtc = new MultiplexTransportConfig(this, APP_ID, MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n+                mtc.setRequiresHighBandwidth(true);\n+                transport = mtc;\n+            }\n+\n+            // The app type to be used\n+            Vector<AppHMIType> appType = new Vector<>();\n+            appType.add(AppHMIType.DEFAULT);\n+\n+            // The manager listener helps you know when certain events that pertain to the SDL Manager happen\n+            // Here we will listen for ON_HMI_STATUS and ON_COMMAND notifications\n+            SdlManagerListener listener = new SdlManagerListener() {\n+                @Override\n+                public void onStart() {\n+                    // HMI Status Listener\n+                    sdlManager.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, new OnRPCNotificationListener() {\n+                        @Override\n+                        public void onNotified(RPCNotification notification) {\n+                            OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                            if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                                return;\n+                            }\n+                            if (onHMIStatus.getHmiLevel() == HMILevel.HMI_FULL && onHMIStatus.getFirstRun()) {\n+                                setVoiceCommands();\n+                                sendMenus();\n+                                performWelcomeSpeak();\n+                                performWelcomeShow();\n+                                preloadChoices();\n+                                subscribeToButtons();\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void onDestroy() {\n+                    SdlService.this.stopSelf();\n+                }\n+\n+                @Override\n+                public void onError(String info, Exception e) {\n+                }\n+\n+                @Override\n+                public LifecycleConfigurationUpdate managerShouldUpdateLifecycle(Language language, Language hmiLanguage) {\n+                    boolean isNeedUpdate = false;\n+                    String appName = APP_NAME;\n+                    String ttsName = APP_NAME;\n+                    switch (language) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            ttsName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    switch (hmiLanguage) {\n+                        case ES_MX:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_ES;\n+                            break;\n+                        case FR_CA:\n+                            isNeedUpdate = true;\n+                            appName = APP_NAME_FR;\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                    if (isNeedUpdate) {\n+                        Vector<TTSChunk> chunks = new Vector<>(Collections.singletonList(new TTSChunk(ttsName, SpeechCapabilities.TEXT)));\n+                        return new LifecycleConfigurationUpdate(appName, null, chunks, null);\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+            };\n+\n+            // Create App Icon, this is set in the SdlManager builder\n+            SdlArtwork appIcon = new SdlArtwork(ICON_FILENAME, FileType.GRAPHIC_PNG, R.mipmap.ic_launcher, true);\n+\n+            // The manager builder sets options for your session\n+            SdlManager.Builder builder = new SdlManager.Builder(this, APP_ID, APP_NAME, listener);\n+            builder.setAppTypes(appType);\n+            builder.setTransportType(transport);\n+            builder.setAppIcon(appIcon);\n+            sdlManager = builder.build();\n+            sdlManager.start();\n+        }\n+    }\n+\n+    /**\n+     * Send some voice commands\n+     */\n+    private void setVoiceCommands() {\n+\n+        List<String> list1 = Collections.singletonList(\"Command One\");\n+        List<String> list2 = Collections.singletonList(\"Command two\");\n+\n+        VoiceCommand voiceCommand1 = new VoiceCommand(list1, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 1 triggered\");\n+            }\n+        });\n+\n+        VoiceCommand voiceCommand2 = new VoiceCommand(list2, new VoiceCommandSelectionListener() {\n+            @Override\n+            public void onVoiceCommandSelected() {\n+                Log.i(TAG, \"Voice Command 2 triggered\");\n+            }\n+        });\n+\n+        sdlManager.getScreenManager().setVoiceCommands(Arrays.asList(voiceCommand1, voiceCommand2));\n+    }\n+\n+    /**\n+     * Add menus for the app on SDL.\n+     */\n+    private void sendMenus() {\n+\n+        // some arts\n+        SdlArtwork livio = new SdlArtwork(\"livio\", FileType.GRAPHIC_PNG, R.drawable.sdl, false);\n+\n+        // some voice commands\n+        List<String> voice2 = Collections.singletonList(\"Cell two\");\n+\n+        MenuCell mainCell1 = new MenuCell(\"Test Cell 1 (speak)\", livio, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 1 triggered. Source: \" + trigger.toString());\n+                showTest();\n+            }\n+        });\n+\n+        MenuCell mainCell2 = new MenuCell(\"Test Cell 2\", null, voice2, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Test cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // SUB MENU\n+\n+        MenuCell subCell1 = new MenuCell(\"SubCell 1\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 1 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        MenuCell subCell2 = new MenuCell(\"SubCell 2\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Sub cell 2 triggered. Source: \" + trigger.toString());\n+            }\n+        });\n+\n+        // sub menu parent cell\n+        MenuCell mainCell3 = new MenuCell(\"Test Cell 3 (sub menu)\", MenuLayout.LIST, null, Arrays.asList(subCell1, subCell2));\n+\n+        MenuCell mainCell4 = new MenuCell(\"Show Perform Interaction\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                showPerformInteraction();\n+            }\n+        });\n+\n+        MenuCell mainCell5 = new MenuCell(\"Clear the menu\", null, null, new MenuSelectionListener() {\n+            @Override\n+            public void onTriggered(TriggerSource trigger) {\n+                Log.i(TAG, \"Clearing Menu. Source: \" + trigger.toString());\n+                // Clear this thing\n+                sdlManager.getScreenManager().setMenu(Collections.<MenuCell>emptyList());\n+                showAlert(\"Menu Cleared\");\n+            }\n+        });\n+\n+        // Send the entire menu off to be created\n+        sdlManager.getScreenManager().setMenu(Arrays.asList(mainCell1, mainCell2, mainCell3, mainCell4, mainCell5));\n+    }\n+\n+    /**\n+     * Will speak a sample welcome message\n+     */\n+    private void performWelcomeSpeak() {\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(WELCOME_SPEAK, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    /**\n+     * Use the Screen Manager to set the initial screen text and set the image.\n+     * Because we are setting multiple items, we will call beginTransaction() first,\n+     * and finish with commit() when we are done.\n+     */\n+    private void performWelcomeShow() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(APP_NAME);\n+        sdlManager.getScreenManager().setTextField2(WELCOME_SHOW);\n+        sdlManager.getScreenManager().setPrimaryGraphic(new SdlArtwork(SDL_IMAGE_FILENAME, FileType.GRAPHIC_PNG, R.drawable.sdl, true));\n+        sdlManager.getScreenManager().commit(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                if (success) {\n+                    Log.i(TAG, \"welcome show successful\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Attempts to Subscribe to all preset buttons\n+     */\n+    private void subscribeToButtons() {\n+        ButtonName[] buttonNames = {ButtonName.PLAY_PAUSE, ButtonName.SEEKLEFT, ButtonName.SEEKRIGHT, ButtonName.AC_MAX, ButtonName.AC, ButtonName.RECIRCULATE,\n+                ButtonName.FAN_UP, ButtonName.FAN_DOWN, ButtonName.TEMP_UP, ButtonName.TEMP_DOWN, ButtonName.FAN_DOWN, ButtonName.DEFROST_MAX, ButtonName.DEFROST_REAR, ButtonName.DEFROST,\n+                ButtonName.UPPER_VENT, ButtonName.LOWER_VENT, ButtonName.VOLUME_UP, ButtonName.VOLUME_DOWN, ButtonName.EJECT, ButtonName.SOURCE, ButtonName.SHUFFLE, ButtonName.REPEAT};\n+\n+        OnButtonListener onButtonListener = new OnButtonListener() {\n+            @Override\n+            public void onPress(ButtonName buttonName, OnButtonPress buttonPress) {\n+                sdlManager.getScreenManager().setTextField1(buttonName + \" pressed\");\n+            }\n+\n+            @Override\n+            public void onEvent(ButtonName buttonName, OnButtonEvent buttonEvent) {\n+                sdlManager.getScreenManager().setTextField2(buttonName + \" \" + buttonEvent.getButtonEventMode());\n+            }\n+\n+            @Override\n+            public void onError(String info) {\n+                Log.i(TAG, \"onError: \" + info);\n+            }\n+        };\n+\n+        for (ButtonName buttonName : buttonNames) {\n+            sdlManager.getScreenManager().addButtonListener(buttonName, onButtonListener);\n+        }\n+    }\n+\n+    /**\n+     * Will show a sample test message on screen as well as speak a sample test message\n+     */\n+    private void showTest() {\n+        sdlManager.getScreenManager().beginTransaction();\n+        sdlManager.getScreenManager().setTextField1(\"Test Cell 1 has been selected\");\n+        sdlManager.getScreenManager().setTextField2(\"\");\n+        sdlManager.getScreenManager().commit(null);\n+\n+        List<TTSChunk> chunks = Collections.singletonList(new TTSChunk(TEST_COMMAND_NAME, SpeechCapabilities.TEXT));\n+        sdlManager.sendRPC(new Speak(chunks));\n+    }\n+\n+    private void showAlert(String text) {\n+        Alert alert = new Alert();\n+        alert.setAlertText1(text);\n+        alert.setDuration(5000);\n+        sdlManager.sendRPC(alert);\n+    }\n+\n+    // Choice Set\n+\n+    private void preloadChoices() {\n+        ChoiceCell cell1 = new ChoiceCell(\"Item 1\");\n+        ChoiceCell cell2 = new ChoiceCell(\"Item 2\");\n+        ChoiceCell cell3 = new ChoiceCell(\"Item 3\");\n+        choiceCellList = new ArrayList<>(Arrays.asList(cell1, cell2, cell3));\n+        sdlManager.getScreenManager().preloadChoices(choiceCellList, null);\n+    }\n+\n+    private void showPerformInteraction() {\n+        if (choiceCellList != null) {\n+            ChoiceSet choiceSet = new ChoiceSet(\"Choose an Item from the list\", choiceCellList, new ChoiceSetSelectionListener() {\n+                @Override\n+                public void onChoiceSelected(ChoiceCell choiceCell, TriggerSource triggerSource, int rowIndex) {\n+                    showAlert(choiceCell.getText() + \" was selected\");\n+                }\n+\n                 @Override\n-                public boolean onTouch(View view, MotionEvent motionEvent) {\n-\n-                    counter2.setText(\"Click!!! \" + ++clickCounter2);\n-                    int location [] = new int[2];\n-                    button2.getLocationInWindow(location);\n-                    //counter2.append(\"\\nButton size: \" + button.getWidth() + \"x\" + button.getHeight());\n-                    //textView.append(\"\\nButton location: \" + location[0] + \",\" + location[1]);\n-                    return false;\n+                public void onError(String error) {\n+                    Log.e(TAG, \"There was an error showing the perform interaction: \" + error);\n                 }\n             });\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n-\t}\n-\n-\tpublic static class MyDisplay extends SdlRemoteDisplay {\n-\t\tpublic MyDisplay(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(R.layout.streaming_layout);\n-\n-\n-\t\t\tString videoUri = \"android.resource://\" + getContext().getPackageName() + \"/\" + R.raw.sdl;\n-\t\t\tfinal VideoView videoView = findViewById(R.id.videoView);\n-\t\t\tvideoView.setOnTouchListener(new View.OnTouchListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic boolean onTouch(View view, MotionEvent motionEvent) {\n-\t\t\t\t\tint[] location = new int[2];\n-\t\t\t\t\tvideoView.getLocationInWindow(location);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"View size \" + videoView.getWidth() + \"x\" + videoView.getHeight());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Location \" + location[0] + \" \" + location[1]);\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Count: \" + motionEvent.getPointerCount());\n-\t\t\t\t\tLog.i(\"convertTouch\", \"Click(\" + motionEvent.getX() + \" \" + motionEvent.getY() + \" Raw \" + motionEvent.getRawX() + \" \" + motionEvent.getRawY());\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t});\n-\t\t\tvideoView.setVideoURI(Uri.parse(videoUri));\n-\t\t\tvideoView.start();\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tToast.makeText(getContext(),\n-\t\t\t\t\tString.format(\"Remote view new width and height (%s, %s)\", width, height),\n-\t\t\t\t\tToast.LENGTH_SHORT\n-\t\t\t).show();\n-\t\t}\n+            sdlManager.getScreenManager().presentChoiceSet(choiceSet, InteractionMode.MANUAL_ONLY);\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0ODQxNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474848415", "bodyText": "@kostyaBoss On lines 71 and 72, can you rename these variables using camel case format?\nSo it would become:\nprivate int predefinedWidth = 1920;\nprivate int predefinedHeight = 1080;", "author": "santhanamk", "createdAt": "2020-08-21T18:03:35Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java", "diffHunk": "@@ -66,6 +68,9 @@\n     private Boolean initPassed = false;\n     private final Object STREAMING_LOCK = new Object();\n \n+    private int predefined_width = 1920;\n+    private int predefined_height = 1080;\n+\n     // Codec-specific data (SPS and PPS)", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\nindex ffb7ec883..664e1a605 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/encoder/VirtualDisplayEncoder.java\n\n@@ -68,9 +66,8 @@ public class VirtualDisplayEncoder {\n     private Boolean initPassed = false;\n     private final Object STREAMING_LOCK = new Object();\n \n-    private int predefined_width = 1920;\n-    private int predefined_height = 1080;\n-\n+    private int predefinedWidth = 1920;\n+    private int predefinedHeight = 1080;\n     // Codec-specific data (SPS and PPS)\n     private byte[] mH264CodecSpecificData = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0OTE3MA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474849170", "bodyText": "@kostyaBoss You can remove the unused import on line 48.", "author": "santhanamk", "createdAt": "2020-08-21T18:05:13Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -45,20 +45,26 @@\n import com.smartdevicelink.managers.BaseSubManager;\n import com.smartdevicelink.managers.CompletionListener;\n import com.smartdevicelink.managers.StreamingStateMachine;\n+import com.smartdevicelink.managers.video.resolution.AspectRatio;", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExNzQ3Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r477117476", "bodyText": "@sanhanamk, I don't think we should do it, otherwise the AspectRatio structure which was rolled back according to your suggestion will not work in this file", "author": "kboskin", "createdAt": "2020-08-26T08:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0OTE3MA=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 76114d5bd..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -40,21 +40,22 @@ import android.view.Display;\n import android.view.InputDevice;\n import android.view.MotionEvent;\n \n-import com.smartdevicelink.SdlConnection.SdlSession;\n+import androidx.annotation.RestrictTo;\n+\n import com.smartdevicelink.encoder.VirtualDisplayEncoder;\n import com.smartdevicelink.managers.BaseSubManager;\n import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n import com.smartdevicelink.managers.StreamingStateMachine;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.protocol.ISdlServiceListener;\n import com.smartdevicelink.managers.video.resolution.AspectRatio;\n import com.smartdevicelink.managers.video.resolution.Resolution;\n import com.smartdevicelink.managers.video.resolution.VideoStreamingRange;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n import com.smartdevicelink.protocol.enums.FunctionID;\n import com.smartdevicelink.protocol.enums.SessionType;\n import com.smartdevicelink.proxy.RPCNotification;\n-import com.smartdevicelink.proxy.interfaces.ISdl;\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n-import com.smartdevicelink.proxy.interfaces.OnSystemCapabilityListener;\n import com.smartdevicelink.proxy.rpc.AppCapability;\n import com.smartdevicelink.proxy.rpc.DisplayCapabilities;\n import com.smartdevicelink.proxy.rpc.ImageResolution;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk5MDIxMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r474990210", "bodyText": "@kostyaBoss I see that you have the AspectRatio class defined which has minAspectRatio and maxAspectRatio.\nYou can replace Double minAspectRatio and Double maxAspectRatio with the AspectRatio class.", "author": "santhanamk", "createdAt": "2020-08-21T22:07:41Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.smartdevicelink.managers.video.resolution;\n+\n+public class VideoStreamingRange {\n+    private Resolution minResolution;\n+    private Resolution maxResolution;\n+    private Double minScreenDiagonal;\n+    private Double minAspectRatio;", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\nindex 564dd24f1..6f5f06c31 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/resolution/VideoStreamingRange.java\n\n@@ -4,21 +4,18 @@ public class VideoStreamingRange {\n     private Resolution minResolution;\n     private Resolution maxResolution;\n     private Double minScreenDiagonal;\n-    private Double minAspectRatio;\n-    private Double maxAspectRatio;\n+    private AspectRatio aspectRatio;\n \n     public VideoStreamingRange(\n             Resolution minResolution,\n             Resolution maxResolution,\n             Double minScreenDiagonal,\n-            Double minAspectRatio,\n-            Double maxAspectRatio\n+            AspectRatio aspectRatio\n     ) {\n         this.minResolution = minResolution;\n         this.maxResolution = maxResolution;\n         this.minScreenDiagonal = minScreenDiagonal;\n-        this.minAspectRatio = minAspectRatio;\n-        this.maxAspectRatio = maxAspectRatio;\n+        this.aspectRatio = aspectRatio;\n     }\n \n     private VideoStreamingRange() { }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwMDgzMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r475000832", "bodyText": "You can remove the touchEventOccured variable on line 72.  You assign it later on line 104, but it is not being used.", "author": "santhanamk", "createdAt": "2020-08-21T22:48:41Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java", "diffHunk": "@@ -69,6 +70,7 @@\n \tpublic static final String TAG = \"VideoStreamManagerTests\";\n \tprivate Context mTestContext;\n \tprivate static boolean touchEventOccured = false;", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\nindex abd07cbb2..79c3d6240 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n\n@@ -67,479 +68,472 @@ import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentat\n  */\n @RunWith(AndroidJUnit4.class)\n public class VideoStreamManagerTests {\n-\tpublic static final String TAG = \"VideoStreamManagerTests\";\n-\tprivate Context mTestContext;\n-\tprivate static boolean touchEventOccured = false;\n-\tprivate static boolean viewResizedCalled = false;\n-\n-\t// SETUP / HELPERS\n-\n-\t@Before\n-\tpublic void setUp() throws Exception{\n-\t\tmTestContext = getInstrumentation().getContext();\n-\t}\n-\n-\t// TEST CLASSES\n-\n-\tpublic static class TestPresentation extends SdlRemoteDisplay {\n-\t\tView simulatedView = new View(this.getContext());\n-\n-\t\tpublic TestPresentation(Context context, Display display) {\n-\t\t\tsuper(context, display);\n-\t\t}\n-\n-\t\t@Override\n-\t\tprotected void onCreate(Bundle savedInstanceState) {\n-\t\t\tsuper.onCreate(savedInstanceState);\n-\t\t\tsetContentView(simulatedView);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onViewResized(int width, int height) {\n-\t\t\tviewResizedCalled = true;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean onTouchEvent(@NonNull MotionEvent event) {\n-\t\t\ttouchEventOccured = true;\n-\t\t\treturn super.onTouchEvent(event);\n-\t\t}\n-\t}\n-\n-\t// TESTS\n-\n-\t@Test\n-\tpublic void testInitialization(){\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn(new Version(5,1,0));\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tAnswer<Void> onAddServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tSessionType sessionType = (SessionType) args[0];\n-\t\t\t\tISdlServiceListener sdlServiceListener = (ISdlServiceListener) args[1];\n-\t\t\t\tassertEquals(sessionType, SessionType.NAV);\n-\t\t\t\tassertNotNull(sdlServiceListener);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddServiceListener).when(internalInterface).addServiceListener(any(SessionType.class), any(ISdlServiceListener.class));\n-\n-\t\tVideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tassertTrue(success);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Test\n-\tpublic void testHMILevelNotFull(){\n-\t\tfinal ISdl internalInterface = mock(ISdl.class);\n-\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn((new Version(5,0,0)));\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\twhen(internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n-\n-\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tboolean encrypted = false;\n-\t\t\t\tvideoStreamManager.startStreaming(params, encrypted);\n-\t\t\t\tverify(internalInterface, times(0)).startVideoService(params, encrypted);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Test\n-\tpublic void testRemoteDisplayStream(){\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tfinal Set<Object> listenerSet = new HashSet<>();\n-\n-\t\twhen(internalInterface.getProtocolVersion()).thenReturn(new Version(5,0,0));\n-\t\twhen(internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n-\n-\t\tAnswer<Void> onGetCapability = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tOnSystemCapabilityListener systemCapabilityListener = (OnSystemCapabilityListener) args[1];\n-\t\t\t\tsystemCapabilityListener.onCapabilityRetrieved(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onGetCapability).when(internalInterface).getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class));\n-\n-\t\tAnswer<Void> onAddServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddServiceListener).when(internalInterface).addServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n-\n-\t\tfinal OnRPCNotificationListener[] hmiListener = {null};\n-\n-\t\tAnswer<Void> onAddHMIListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\thmiListener[0] = (OnRPCNotificationListener) args[1];\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onAddTouchListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.add(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddTouchListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onRemoveRPCNotificationListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.remove(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n-\t\tdoAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n-\n-\t\tAnswer<Void> onRemoveServiceListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\tlistenerSet.remove(args[1]);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onRemoveServiceListener).when(internalInterface).removeServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n-\n-\t\twhen(internalInterface.startVideoStream(anyBoolean(), any(VideoStreamingParameters.class))).thenReturn(new IVideoStreamListener() {\n-\t\t\t@Override\n-\t\t\tpublic void sendFrame(byte[] data, int offset, int length, long presentationTimeUs) throws ArrayIndexOutOfBoundsException {}\n-\t\t\t@Override\n-\t\t\tpublic void sendFrame(ByteBuffer data, long presentationTimeUs) {}\n-\t\t});\n-\n-\t\twhen(internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\n-\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tassertTrue(success);\n-\t\t\t\tassertTrue(listenerSet.size() == 3);\n-\n-\t\t\t\tOnHMIStatus fullNotification = new OnHMIStatus();\n-\t\t\t\tfullNotification.setHmiLevel(HMILevel.HMI_FULL);\n-\t\t\t\thmiListener[0].onNotified(fullNotification);\n-\n-\t\t\t\tvideoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n-\t\t\t\t//assertTrue(touchEventOccured);\n-\n-\t\t\t\tassertTrue(listenerSet.isEmpty());\n-\t\t\t}\n-\t\t});\n-\n-\t}\n-\n-\t@Test\n-\tpublic void testOnViewResized() {\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\n-\t\tfinal OnRPCNotificationListener[] hmiListener = {null};\n-\n-\t\tAnswer<Void> onAddHMIListener = new Answer<Void>() {\n-\t\t\t@Override\n-\t\t\tpublic Void answer(InvocationOnMock invocation) {\n-\t\t\t\tObject[] args = invocation.getArguments();\n-\t\t\t\thmiListener[0] = (OnRPCNotificationListener) args[1];\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\n-\t\tdoAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n-\n-\t\tfinal VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tvideoStreamManager.start(new CompletionListener() {\n-\t\t\t@Override\n-\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\tassertTrue(success);\n-\t\t\t\tOnHMIStatus fullNotification = new OnHMIStatus();\n-\t\t\t\tfullNotification.setHmiLevel(HMILevel.HMI_FULL);\n-\t\t\t\thmiListener[0].onNotified(fullNotification);\n-\n-\t\t\t\tvideoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n-\n-\t\t\t\tField privateStringField = null;\n-\t\t\t\ttry {\n-\t\t\t\t\tprivateStringField = VideoStreamManager.class.\n-\t\t\t\t\t\t\tgetDeclaredField(\"sdlRemoteDisplay\");\n-\t\t\t\t} catch (NoSuchFieldException e) { e.printStackTrace(); }\n-\t\t\t\tprivateStringField.setAccessible(true);\n-\n-\t\t\t\tSdlRemoteDisplay display = null;\n-\t\t\t\ttry {\n-\t\t\t\t\tdisplay = (SdlRemoteDisplay) privateStringField.get(videoStreamManager);\n-\t\t\t\t} catch (IllegalAccessException e) { e.printStackTrace(); }\n-\t\t\t\tdisplay.onViewResized(100, 100);\n-\n-\t\t\t\tassertTrue(viewResizedCalled);\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t@Test\n-\tpublic void testConvertTouchEvent() {\n-\t\tISdl internalInterface = mock(ISdl.class);\n-\n-\t\tRegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n-\t\tVehicleType mockVehicleType = new VehicleType();\n-\t\tmockVehicleType.setMake(\"Ford\");\n-\t\tmockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n-\t\twhen(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n-\n-\t\tVideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n-\t\tList<MotionEvent> motionEventList;\n-\t\tlong e1TS = 1558124390L, e2TS = 1558125390L, e3TS = 1558126390L;\n-\t\tint e1x = 50, e1y = 100, e2x = 150, e2y = 200, e3x = 250, e3y = 300;\n-\t\tint e1Id = 100, e2Id = 101, e3Id = 102;\n-\t\tint movingStep = 10;\n-\t\tOnTouchEvent testOnTouchEvent;\n-\t\tMotionEvent motionEvent;\n-\t\tTouchEvent touchEvent1 = new TouchEvent(e1Id, Collections.singletonList(e1TS), Collections.singletonList(new TouchCoord(e1x, e1y)));\n-\t\tTouchEvent touchEvent2 = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x, e2y)));\n-\t\tTouchEvent touchEvent2AfterMovingPointer = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x + movingStep, e2y + movingStep)));\n-\t\tTouchEvent touchEvent3 = new TouchEvent(e3Id, Collections.singletonList(e3TS), Collections.singletonList(new TouchCoord(e3x, e3y)));\n-\n-\n-\n-\t\t/////////////////////////////////////////////////// First OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+    public static final String TAG = \"VideoStreamManagerTests\";\n+    private Context mTestContext;\n+    private static boolean touchEventOccured = false;\n+    private static boolean viewResizedCalled = false;\n \n+    // SETUP / HELPERS\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n-\n+    @Before\n+    public void setUp() throws Exception {\n+        mTestContext = getInstrumentation().getContext();\n+    }\n \n-\t\t// Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(1);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    // TEST CLASSES\n \n+    public static class TestPresentation extends SdlRemoteDisplay {\n+        View simulatedView = new View(this.getContext());\n \n+        public TestPresentation(Context context, Display display) {\n+            super(context, display);\n+        }\n \n-\t\t/////////////////////////////////////////////////// Second OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        @Override\n+        protected void onCreate(Bundle savedInstanceState) {\n+            super.onCreate(savedInstanceState);\n+            setContentView(simulatedView);\n+        }\n \n+        @Override\n+        public void onViewResized(int width, int height) {\n+            viewResizedCalled = true;\n+        }\n \n-\t\t// First MotionEvent should be ACTION_POINTER_DOWN and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        @Override\n+        public boolean onTouchEvent(@NonNull MotionEvent event) {\n+            touchEventOccured = true;\n+            return super.onTouchEvent(event);\n+        }\n+    }\n \n+    // TESTS\n \n+    @Test\n+    public void testInitialization() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getProtocolVersion()).thenReturn(new Version(5, 1, 0));\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        Answer<Void> onAddServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                SessionType sessionType = (SessionType) args[0];\n+                ISdlServiceListener sdlServiceListener = (ISdlServiceListener) args[1];\n+                assertEquals(sessionType, SessionType.NAV);\n+                assertNotNull(sdlServiceListener);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddServiceListener).when(internalInterface).addServiceListener(any(SessionType.class), any(ISdlServiceListener.class));\n \n-\t\t/////////////////////////////////////////////////// Third OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.MOVE, Arrays.asList(touchEvent2AfterMovingPointer));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+            }\n+        });\n+    }\n \n+    @Test\n+    public void testHMILevelNotFull() {\n+        final ISdl internalInterface = mock(ISdl.class);\n+\n+        SystemCapabilityManager systemCapabilityManager = mock(SystemCapabilityManager.class);\n+        doReturn(systemCapabilityManager).when(internalInterface).getSystemCapabilityManager();\n+\n+        when(internalInterface.getProtocolVersion()).thenReturn((new Version(5, 0, 0)));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        when(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                boolean encrypted = false;\n+                videoStreamManager.startStreaming(params, encrypted);\n+                verify(internalInterface, times(0)).startVideoService(params, encrypted, false);\n+            }\n+        });\n+    }\n \n-\t\t// First MotionEvent should be ACTION_MOVE and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_MOVE, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    @Test\n+    public void testRemoteDisplayStream() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n+\n+        final Set<Object> listenerSet = new HashSet<>();\n+\n+        when(internalInterface.getProtocolVersion()).thenReturn(new Version(5, 0, 0));\n+\n+        SystemCapabilityManager systemCapabilityManager = mock(SystemCapabilityManager.class);\n+        doReturn(systemCapabilityManager).when(internalInterface).getSystemCapabilityManager();\n+        when(systemCapabilityManager.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)).thenReturn(true);\n+\n+        Answer<Void> onGetCapability = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnSystemCapabilityListener systemCapabilityListener = (OnSystemCapabilityListener) args[1];\n+                systemCapabilityListener.onCapabilityRetrieved(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onGetCapability).when(systemCapabilityManager).getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class), anyBoolean());\n+\n+        Answer<Void> onAddServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddServiceListener).when(internalInterface).addServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n+\n+        final OnRPCNotificationListener[] hmiListener = {null};\n+\n+        Answer<Void> onAddHMIListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                hmiListener[0] = (OnRPCNotificationListener) args[1];\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onAddTouchListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.add(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddTouchListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onRemoveRPCNotificationListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.remove(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+        doAnswer(onRemoveRPCNotificationListener).when(internalInterface).removeOnRPCNotificationListener(eq(FunctionID.ON_TOUCH_EVENT), any(OnRPCNotificationListener.class));\n+\n+        Answer<Void> onRemoveServiceListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                listenerSet.remove(args[1]);\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onRemoveServiceListener).when(internalInterface).removeServiceListener(eq(SessionType.NAV), any(ISdlServiceListener.class));\n+\n+        when(systemCapabilityManager.getCapability(eq(SystemCapabilityType.VIDEO_STREAMING), any(OnSystemCapabilityListener.class), anyBoolean())).thenReturn(TestValues.GENERAL_VIDEOSTREAMINGCAPABILITY);\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+                assertTrue(listenerSet.size() == 3);\n+\n+                OnHMIStatus fullNotification = new OnHMIStatus();\n+                fullNotification.setHmiLevel(HMILevel.HMI_FULL);\n+                hmiListener[0].onNotified(fullNotification);\n+\n+                videoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n+                assertTrue(touchEventOccured);\n+                videoStreamManager.dispose();\n+                assertTrue(listenerSet.isEmpty());\n+            }\n+        });\n \n+    }\n \n+    @Test\n+    public void testOnViewResized() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n+\n+        final OnRPCNotificationListener[] hmiListener = {null};\n+\n+        Answer<Void> onAddHMIListener = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                hmiListener[0] = (OnRPCNotificationListener) args[1];\n+                return null;\n+            }\n+        };\n+\n+        doAnswer(onAddHMIListener).when(internalInterface).addOnRPCNotificationListener(eq(FunctionID.ON_HMI_STATUS), any(OnRPCNotificationListener.class));\n+\n+        final VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        videoStreamManager.start(new CompletionListener() {\n+            @Override\n+            public void onComplete(boolean success) {\n+                assertTrue(success);\n+                OnHMIStatus fullNotification = new OnHMIStatus();\n+                fullNotification.setHmiLevel(HMILevel.HMI_FULL);\n+                hmiListener[0].onNotified(fullNotification);\n+\n+                videoStreamManager.startRemoteDisplayStream(mTestContext, TestPresentation.class, null, false);\n+\n+                Field sdlRemoteDisplayField = null;\n+                try {\n+                    sdlRemoteDisplayField =\n+                            VideoStreamManager.class.getDeclaredField(\"sdlRemoteDisplay\");\n+                } catch (NoSuchFieldException e) { e.printStackTrace(); }\n+                sdlRemoteDisplayField.setAccessible(true);\n+\n+                SdlRemoteDisplay display = null;\n+                try {\n+                    display = (SdlRemoteDisplay) sdlRemoteDisplayField.get(videoStreamManager);\n+                } catch (IllegalAccessException e) { e.printStackTrace(); }\n+                display.onViewResized(100, 100);\n+\n+                assertTrue(viewResizedCalled);\n+            }\n+        });\n+    }\n \n-\t\t/////////////////////////////////////////////////// Fourth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent2AfterMovingPointer));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+    @Test\n+    public void testConvertTouchEvent() {\n+        ISdl internalInterface = mock(ISdl.class);\n+        when(internalInterface.getSystemCapabilityManager()).thenReturn(mock(SystemCapabilityManager.class));\n \n+        RegisterAppInterfaceResponse mockRegisterAppInterfaceResponse = new RegisterAppInterfaceResponse();\n+        VehicleType mockVehicleType = new VehicleType();\n+        mockVehicleType.setMake(\"Ford\");\n+        mockRegisterAppInterfaceResponse.setVehicleType(mockVehicleType);\n+        when(internalInterface.getRegisterAppInterfaceResponse()).thenReturn(mockRegisterAppInterfaceResponse);\n \n-\t\t// First MotionEvent should be ACTION_POINTER_UP and have 3 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(3, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(2)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(2)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        VideoStreamManager videoStreamManager = new VideoStreamManager(internalInterface);\n+        List<MotionEvent> motionEventList;\n+        long e1TS = 1558124390L, e2TS = 1558125390L, e3TS = 1558126390L;\n+        int e1x = 50, e1y = 100, e2x = 150, e2y = 200, e3x = 250, e3y = 300;\n+        int e1Id = 100, e2Id = 101, e3Id = 102;\n+        int movingStep = 10;\n+        OnTouchEvent testOnTouchEvent;\n+        MotionEvent motionEvent;\n+        TouchEvent touchEvent1 = new TouchEvent(e1Id, Collections.singletonList(e1TS), Collections.singletonList(new TouchCoord(e1x, e1y)));\n+        TouchEvent touchEvent2 = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x, e2y)));\n+        TouchEvent touchEvent2AfterMovingPointer = new TouchEvent(e2Id, Collections.singletonList(e2TS), Collections.singletonList(new TouchCoord(e2x + movingStep, e2y + movingStep)));\n+        TouchEvent touchEvent3 = new TouchEvent(e3Id, Collections.singletonList(e3TS), Collections.singletonList(new TouchCoord(e3x, e3y)));\n \n \n+        /////////////////////////////////////////////////// First OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t/////////////////////////////////////////////////// Fifth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n \n-\t\t// First MotionEvent should be ACTION_POINTER_UP and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e3x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e3y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        // Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n+        motionEvent = motionEventList.get(1);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t/////////////////////////////////////////////////// Sixth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        /////////////////////////////////////////////////// Second OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t// First MotionEvent should be ACTION_UP and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        // First MotionEvent should be ACTION_POINTER_DOWN and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Third OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.MOVE, Arrays.asList(touchEvent2AfterMovingPointer));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n+        // First MotionEvent should be ACTION_MOVE and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_MOVE, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Fourth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent2AfterMovingPointer));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t/////////////////////////////////////////////////// Seventh OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        // First MotionEvent should be ACTION_POINTER_UP and have 3 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(3, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x + movingStep, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y + movingStep, Math.round(motionEvent.getY(1)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(2)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(2)));\n+        assertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Fifth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n \n+        // First MotionEvent should be ACTION_POINTER_UP and have 2 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e3x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e3y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n-\t\t// Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(1);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        /////////////////////////////////////////////////// Sixth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t/////////////////////////////////////////////////// Eighth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.CANCEL, Arrays.asList(touchEvent3));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        // First MotionEvent should be ACTION_UP and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t// First MotionEvent should be ACTION_CANCEL and have 2 pointers\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(2, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(e2x, Math.round(motionEvent.getX(1)));\n-\t\tassertEquals(e2y, Math.round(motionEvent.getY(1)));\n-\t\tassertEquals(MotionEvent.ACTION_CANCEL, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        /////////////////////////////////////////////////// Seventh OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1, touchEvent2));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+\n+\n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n+\n+\n+        // Second MotionEvent should be ACTION_POINTER_DOWN and have 2 pointers\n+        motionEvent = motionEventList.get(1);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_POINTER_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+        /////////////////////////////////////////////////// Eighth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.CANCEL, Arrays.asList(touchEvent3));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n+        // First MotionEvent should be ACTION_CANCEL and have 2 pointers\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(2, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(e2x, Math.round(motionEvent.getX(1)));\n+        assertEquals(e2y, Math.round(motionEvent.getY(1)));\n+        assertEquals(MotionEvent.ACTION_CANCEL, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n-\t\t/////////////////////////////////////////////////// Ninth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n+        /////////////////////////////////////////////////// Ninth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.BEGIN, Arrays.asList(touchEvent1));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n-\t\t// First MotionEvent should be ACTION_DOWN and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n+        // First MotionEvent should be ACTION_DOWN and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_DOWN, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n-\t\t/////////////////////////////////////////////////// Tenth OnTouchEvent Notification ///////////////////////////////////////////////////\n-\t\ttestOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent1));\n-\t\tmotionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n+        /////////////////////////////////////////////////// Tenth OnTouchEvent Notification ///////////////////////////////////////////////////\n+        testOnTouchEvent = new OnTouchEvent(TouchType.END, Arrays.asList(touchEvent1));\n+        motionEventList = videoStreamManager.convertTouchEvent(testOnTouchEvent);\n \n \n-\t\t// First MotionEvent should be ACTION_UP and have 1 pointer\n-\t\tmotionEvent = motionEventList.get(0);\n-\t\tassertEquals(1, motionEvent.getPointerCount());\n-\t\tassertEquals(e1x, Math.round(motionEvent.getX(0)));\n-\t\tassertEquals(e1y, Math.round(motionEvent.getY(0)));\n-\t\tassertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n-\t\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-\t}\n+        // First MotionEvent should be ACTION_UP and have 1 pointer\n+        motionEvent = motionEventList.get(0);\n+        assertEquals(1, motionEvent.getPointerCount());\n+        assertEquals(e1x, Math.round(motionEvent.getX(0)));\n+        assertEquals(e1y, Math.round(motionEvent.getY(0)));\n+        assertEquals(MotionEvent.ACTION_UP, motionEvent.getActionMasked());\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    }\n \n-\t@Test\n+    @Test\n     public void testConvertTouchEvent_Scale_1() {\n         assertMotionEventWithScale(800, 480, 1.0f);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwMjA3OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r475002078", "bodyText": "@kostyaBoss you can change ...setDiagonalScreenSize(6.); to ...setDiagonalScreenSize(GENERAL_DOUBLE);", "author": "santhanamk", "createdAt": "2020-08-21T22:53:59Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -897,11 +903,23 @@ public void onVoiceCommandSelected() {\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);\n+\n+\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n \n+\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(6.);", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 131b23947..7b3f5dc70 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -890,510 +905,516 @@ public class TestValues {\n         GENERAL_PERMISSIONITEM.setRequireEncryption(GENERAL_BOOLEAN);\n         GENERAL_PERMISSIONITEM_LIST.add(GENERAL_PERMISSIONITEM);\n \n-\t\tGENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n-\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(6.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(29.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setScale(1.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n-\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n-\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n-\n-\t\tGENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n-\n-\t\tGENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n-\t\tGENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n-\t\tGENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n-\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n-\n-\t\tGENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n-\n-\t\tList<MetadataType> exampleList = new ArrayList<>();\n-\t\texampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n-\t\texampleList.add(1, MetadataType.MEDIA_ALBUM);\n-\t\texampleList.add(2, MetadataType.MEDIA_ARTIST);\n-\n-\t\tGENERAL_METADATASTRUCT.setMainField1(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField2(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField3(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField4(exampleList);\n-\n-\t\tGENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n-\n-\t\tGENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n-\t\tGENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n-\n-\t\tGENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n-\n-\t\tGENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n-\t\tGENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n-\t\tGENERAL_LOCKSCREENCONFIG.setEnabled(true);\n-\t\tGENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n-\t\tGENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n-\t\tGENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n-\n-\t\tGENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n-\t\tGENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n-\n-\t\tGENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n-\n-\t\tGENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n-\n-\t\tGENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n-\t\tGENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n-\n-\t\tGENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n-\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n-\t\tGENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n-\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n-\t\tGENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n-\t\tGENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n-\n-\t\tGENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\tGENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n-\n-\t\ttry {\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n-\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n-\n-\t\t\tJSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n-\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_FULL);\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n-\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n-\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n-\t\t\tJSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n-\n-\t\t\tJSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n-\t\t\tJSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n-\t\t\tJSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED , GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n-\n-\t\t\tJSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n-\t\t\tJSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_TURNS.put(JSON_TURN);\n-\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n-\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n-\t    \tJSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n-\n-\t    \tJSONObject jsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\t    \tjsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n-\n-\t\t\tJSON_CHOICES.put(JSON_CHOICE);\n-\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n-\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n-\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n-\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n-\t\t\tJSON_DIDRESULTS.put(JSON_DIDRESULT);\n-\n-\t\t\tJSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSONObject jsonButton = new JSONObject();\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n-\t\t\tJSON_BUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSONObject jsonRadioControlCapabilities = new JSONObject();\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n-\n-\t\t\tJSONObject jsonClimateControlCapabilities = new JSONObject();\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n-\t\t\tJSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\t\t\tJSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n-\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n-\t\t\tJSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n-\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n-\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.STATIC);\n-\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n-\n-\t\t\tJSONObject jsonTEC = new JSONObject();\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n-\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n-\t\t\tJSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n-\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n-\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n-\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n-\t\t\tJSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n-\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n-\n-\t\t\tJSON_SEAT_LOCATIONS.put(JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n-\n-\n-\t\t} catch (JSONException e) {\n-\t\t\tLog.e(\"Test\", \"Static Json Construction Failed.\", e);\n-\t\t}\n-\t}\n+        GENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n+\n+        GENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n+        GENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n+        GENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n+\n+        GENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n+\n+        GENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n+\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n+\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n+        GENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n+\n+        GENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n+\n+        GENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n+        GENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n+        GENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n+        GENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n+\n+        GENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n+\n+        GENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n+\n+        List<MetadataType> exampleList = new ArrayList<>();\n+        exampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n+        exampleList.add(1, MetadataType.MEDIA_ALBUM);\n+        exampleList.add(2, MetadataType.MEDIA_ARTIST);\n+\n+        GENERAL_METADATASTRUCT.setMainField1(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField2(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField3(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField4(exampleList);\n+\n+        GENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n+\n+        GENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n+        GENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n+\n+        GENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n+\n+        GENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n+        GENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n+        GENERAL_LOCKSCREENCONFIG.setDisplayMode(LockScreenConfig.DISPLAY_MODE_ALWAYS);\n+        GENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n+        GENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n+        GENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n+        GENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n+        GENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n+        GENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n+        GENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n+        GENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n+        GENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n+\n+        GENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n+\n+        GENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n+        GENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n+\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n+\n+        GENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n+\n+        GENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n+\n+        GENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n+        GENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n+\n+        GENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n+        GENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n+        GENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n+\n+        GENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n+        GENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n+        GENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n+\n+        GENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n+        GENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n+        GENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n+\n+        GENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n+        GENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n+        GENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n+        GENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n+        GENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n+        GENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n+        GENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n+\n+        GENERAL_GEAR_STATUS.setActualGear(GENERAL_ACTUAL_GEAR);\n+        GENERAL_GEAR_STATUS.setTransmissionType(GENERAL_TRANSMISSION_TYPE);\n+        GENERAL_GEAR_STATUS.setUserSelectedGear(GENERAL_USER_SELECTED_GEAR);\n+\n+        GENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n+        GENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n+        GENERAL_STABILITY_CONTROL_STATUS.setEscSystem(GENERAL_ESC_SYSTEM);\n+        GENERAL_STABILITY_CONTROL_STATUS.setTrailerSwayControl(GENERAL_S_WAY_CONTROL);\n+\n+        GENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n+        GENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n+\n+        try {\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n+\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n+\n+            JSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n+            JSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n+\n+            JSON_HMILEVELS.put(HMILevel.HMI_FULL);\n+            JSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n+\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n+\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n+            JSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n+\n+            JSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n+            JSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n+            JSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n+\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n+\n+            JSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n+            JSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_TURNS.put(JSON_TURN);\n+\n+            JSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n+\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n+            JSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n+\n+            JSONObject jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+            jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n+            JSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n+            JSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n+\n+            JSON_CHOICES.put(JSON_CHOICE);\n+\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n+\n+            JSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n+\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n+\n+            JSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n+            JSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n+            JSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n+            JSON_DIDRESULTS.put(JSON_DIDRESULT);\n+\n+            JSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSONObject jsonButton = new JSONObject();\n+            jsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n+            jsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n+            JSON_BUTTONCAPABILITIES.put(jsonButton);\n+\n+            JSONObject jsonRadioControlCapabilities = new JSONObject();\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n+\n+            JSONObject jsonClimateControlCapabilities = new JSONObject();\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n+            JSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+            JSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n+\n+            JSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n+            JSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n+            JSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n+            JSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n+            JSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n+\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n+            JSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n+            JSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n+\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n+            JSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n+\n+            JSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPES.put(ImageType.STATIC);\n+\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n+\n+            JSONObject jsonTEC = new JSONObject();\n+            jsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n+\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n+            JSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n+\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n+\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n+            JSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n+\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n+            JSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n+\n+            JSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n+\n+            JSON_SEAT_LOCATIONS.put(JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n+\n+\n+        } catch (JSONException e) {\n+            Log.e(\"Test\", \"Static Json Construction Failed.\", e);\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwMjQyMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r475002423", "bodyText": "@kostyaBoss you can change ...setPixelPerInch(29.); to ...setPixelPerInch(GENERAL_DOUBLE);", "author": "santhanamk", "createdAt": "2020-08-21T22:55:23Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -897,11 +903,23 @@ public void onVoiceCommandSelected() {\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);\n+\n+\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n \n+\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(6.);\n+\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(29.);", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 131b23947..7b3f5dc70 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -890,510 +905,516 @@ public class TestValues {\n         GENERAL_PERMISSIONITEM.setRequireEncryption(GENERAL_BOOLEAN);\n         GENERAL_PERMISSIONITEM_LIST.add(GENERAL_PERMISSIONITEM);\n \n-\t\tGENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n-\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(6.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(29.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setScale(1.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n-\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n-\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n-\n-\t\tGENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n-\n-\t\tGENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n-\t\tGENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n-\t\tGENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n-\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n-\n-\t\tGENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n-\n-\t\tList<MetadataType> exampleList = new ArrayList<>();\n-\t\texampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n-\t\texampleList.add(1, MetadataType.MEDIA_ALBUM);\n-\t\texampleList.add(2, MetadataType.MEDIA_ARTIST);\n-\n-\t\tGENERAL_METADATASTRUCT.setMainField1(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField2(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField3(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField4(exampleList);\n-\n-\t\tGENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n-\n-\t\tGENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n-\t\tGENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n-\n-\t\tGENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n-\n-\t\tGENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n-\t\tGENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n-\t\tGENERAL_LOCKSCREENCONFIG.setEnabled(true);\n-\t\tGENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n-\t\tGENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n-\t\tGENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n-\n-\t\tGENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n-\t\tGENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n-\n-\t\tGENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n-\n-\t\tGENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n-\n-\t\tGENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n-\t\tGENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n-\n-\t\tGENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n-\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n-\t\tGENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n-\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n-\t\tGENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n-\t\tGENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n-\n-\t\tGENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\tGENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n-\n-\t\ttry {\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n-\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n-\n-\t\t\tJSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n-\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_FULL);\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n-\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n-\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n-\t\t\tJSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n-\n-\t\t\tJSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n-\t\t\tJSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n-\t\t\tJSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED , GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n-\n-\t\t\tJSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n-\t\t\tJSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_TURNS.put(JSON_TURN);\n-\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n-\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n-\t    \tJSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n-\n-\t    \tJSONObject jsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\t    \tjsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n-\n-\t\t\tJSON_CHOICES.put(JSON_CHOICE);\n-\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n-\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n-\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n-\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n-\t\t\tJSON_DIDRESULTS.put(JSON_DIDRESULT);\n-\n-\t\t\tJSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSONObject jsonButton = new JSONObject();\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n-\t\t\tJSON_BUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSONObject jsonRadioControlCapabilities = new JSONObject();\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n-\n-\t\t\tJSONObject jsonClimateControlCapabilities = new JSONObject();\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n-\t\t\tJSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\t\t\tJSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n-\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n-\t\t\tJSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n-\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n-\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.STATIC);\n-\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n-\n-\t\t\tJSONObject jsonTEC = new JSONObject();\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n-\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n-\t\t\tJSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n-\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n-\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n-\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n-\t\t\tJSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n-\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n-\n-\t\t\tJSON_SEAT_LOCATIONS.put(JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n-\n-\n-\t\t} catch (JSONException e) {\n-\t\t\tLog.e(\"Test\", \"Static Json Construction Failed.\", e);\n-\t\t}\n-\t}\n+        GENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n+\n+        GENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n+        GENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n+        GENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n+\n+        GENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n+\n+        GENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n+\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n+\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n+        GENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n+\n+        GENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n+\n+        GENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n+        GENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n+        GENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n+        GENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n+\n+        GENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n+\n+        GENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n+\n+        List<MetadataType> exampleList = new ArrayList<>();\n+        exampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n+        exampleList.add(1, MetadataType.MEDIA_ALBUM);\n+        exampleList.add(2, MetadataType.MEDIA_ARTIST);\n+\n+        GENERAL_METADATASTRUCT.setMainField1(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField2(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField3(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField4(exampleList);\n+\n+        GENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n+\n+        GENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n+        GENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n+\n+        GENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n+\n+        GENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n+        GENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n+        GENERAL_LOCKSCREENCONFIG.setDisplayMode(LockScreenConfig.DISPLAY_MODE_ALWAYS);\n+        GENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n+        GENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n+        GENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n+        GENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n+        GENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n+        GENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n+        GENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n+        GENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n+        GENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n+\n+        GENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n+\n+        GENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n+        GENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n+\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n+\n+        GENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n+\n+        GENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n+\n+        GENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n+        GENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n+\n+        GENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n+        GENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n+        GENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n+\n+        GENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n+        GENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n+        GENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n+\n+        GENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n+        GENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n+        GENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n+\n+        GENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n+        GENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n+        GENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n+        GENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n+        GENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n+        GENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n+        GENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n+\n+        GENERAL_GEAR_STATUS.setActualGear(GENERAL_ACTUAL_GEAR);\n+        GENERAL_GEAR_STATUS.setTransmissionType(GENERAL_TRANSMISSION_TYPE);\n+        GENERAL_GEAR_STATUS.setUserSelectedGear(GENERAL_USER_SELECTED_GEAR);\n+\n+        GENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n+        GENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n+        GENERAL_STABILITY_CONTROL_STATUS.setEscSystem(GENERAL_ESC_SYSTEM);\n+        GENERAL_STABILITY_CONTROL_STATUS.setTrailerSwayControl(GENERAL_S_WAY_CONTROL);\n+\n+        GENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n+        GENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n+\n+        try {\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n+\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n+\n+            JSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n+            JSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n+\n+            JSON_HMILEVELS.put(HMILevel.HMI_FULL);\n+            JSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n+\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n+\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n+            JSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n+\n+            JSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n+            JSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n+            JSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n+\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n+\n+            JSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n+            JSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_TURNS.put(JSON_TURN);\n+\n+            JSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n+\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n+            JSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n+\n+            JSONObject jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+            jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n+            JSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n+            JSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n+\n+            JSON_CHOICES.put(JSON_CHOICE);\n+\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n+\n+            JSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n+\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n+\n+            JSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n+            JSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n+            JSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n+            JSON_DIDRESULTS.put(JSON_DIDRESULT);\n+\n+            JSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSONObject jsonButton = new JSONObject();\n+            jsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n+            jsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n+            JSON_BUTTONCAPABILITIES.put(jsonButton);\n+\n+            JSONObject jsonRadioControlCapabilities = new JSONObject();\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n+\n+            JSONObject jsonClimateControlCapabilities = new JSONObject();\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n+            JSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+            JSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n+\n+            JSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n+            JSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n+            JSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n+            JSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n+            JSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n+\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n+            JSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n+            JSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n+\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n+            JSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n+\n+            JSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPES.put(ImageType.STATIC);\n+\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n+\n+            JSONObject jsonTEC = new JSONObject();\n+            jsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n+\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n+            JSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n+\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n+\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n+            JSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n+\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n+            JSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n+\n+            JSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n+\n+            JSON_SEAT_LOCATIONS.put(JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n+\n+\n+        } catch (JSONException e) {\n+            Log.e(\"Test\", \"Static Json Construction Failed.\", e);\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwMjgyMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r475002823", "bodyText": "@kostyaBoss you can change ...setScale(1.); to ...setScale(GENERAL_DOUBLE);", "author": "santhanamk", "createdAt": "2020-08-21T22:57:06Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -897,11 +903,23 @@ public void onVoiceCommandSelected() {\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);\n+\n+\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n \t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n \n+\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(6.);\n+\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(29.);\n+\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setScale(1.);", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 131b23947..7b3f5dc70 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -890,510 +905,516 @@ public class TestValues {\n         GENERAL_PERMISSIONITEM.setRequireEncryption(GENERAL_BOOLEAN);\n         GENERAL_PERMISSIONITEM_LIST.add(GENERAL_PERMISSIONITEM);\n \n-\t\tGENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n-\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(6.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(29.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setScale(1.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n-\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n-\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n-\n-\t\tGENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n-\n-\t\tGENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n-\t\tGENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n-\t\tGENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n-\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n-\n-\t\tGENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n-\n-\t\tList<MetadataType> exampleList = new ArrayList<>();\n-\t\texampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n-\t\texampleList.add(1, MetadataType.MEDIA_ALBUM);\n-\t\texampleList.add(2, MetadataType.MEDIA_ARTIST);\n-\n-\t\tGENERAL_METADATASTRUCT.setMainField1(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField2(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField3(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField4(exampleList);\n-\n-\t\tGENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n-\n-\t\tGENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n-\t\tGENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n-\n-\t\tGENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n-\n-\t\tGENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n-\t\tGENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n-\t\tGENERAL_LOCKSCREENCONFIG.setEnabled(true);\n-\t\tGENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n-\t\tGENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n-\t\tGENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n-\n-\t\tGENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n-\t\tGENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n-\n-\t\tGENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n-\n-\t\tGENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n-\n-\t\tGENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n-\t\tGENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n-\n-\t\tGENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n-\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n-\t\tGENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n-\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n-\t\tGENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n-\t\tGENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n-\n-\t\tGENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\tGENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n-\n-\t\ttry {\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n-\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n-\n-\t\t\tJSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n-\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_FULL);\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n-\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n-\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n-\t\t\tJSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n-\n-\t\t\tJSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n-\t\t\tJSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n-\t\t\tJSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED , GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n-\n-\t\t\tJSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n-\t\t\tJSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_TURNS.put(JSON_TURN);\n-\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n-\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n-\t    \tJSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n-\n-\t    \tJSONObject jsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\t    \tjsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n-\n-\t\t\tJSON_CHOICES.put(JSON_CHOICE);\n-\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n-\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n-\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n-\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n-\t\t\tJSON_DIDRESULTS.put(JSON_DIDRESULT);\n-\n-\t\t\tJSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSONObject jsonButton = new JSONObject();\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n-\t\t\tJSON_BUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSONObject jsonRadioControlCapabilities = new JSONObject();\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n-\n-\t\t\tJSONObject jsonClimateControlCapabilities = new JSONObject();\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n-\t\t\tJSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\t\t\tJSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n-\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n-\t\t\tJSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n-\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n-\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.STATIC);\n-\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n-\n-\t\t\tJSONObject jsonTEC = new JSONObject();\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n-\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n-\t\t\tJSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n-\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n-\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n-\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n-\t\t\tJSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n-\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n-\n-\t\t\tJSON_SEAT_LOCATIONS.put(JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n-\n-\n-\t\t} catch (JSONException e) {\n-\t\t\tLog.e(\"Test\", \"Static Json Construction Failed.\", e);\n-\t\t}\n-\t}\n+        GENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n+\n+        GENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n+        GENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n+        GENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n+\n+        GENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n+\n+        GENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n+\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n+\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n+        GENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n+\n+        GENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n+\n+        GENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n+        GENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n+        GENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n+        GENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n+\n+        GENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n+\n+        GENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n+\n+        List<MetadataType> exampleList = new ArrayList<>();\n+        exampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n+        exampleList.add(1, MetadataType.MEDIA_ALBUM);\n+        exampleList.add(2, MetadataType.MEDIA_ARTIST);\n+\n+        GENERAL_METADATASTRUCT.setMainField1(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField2(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField3(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField4(exampleList);\n+\n+        GENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n+\n+        GENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n+        GENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n+\n+        GENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n+\n+        GENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n+        GENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n+        GENERAL_LOCKSCREENCONFIG.setDisplayMode(LockScreenConfig.DISPLAY_MODE_ALWAYS);\n+        GENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n+        GENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n+        GENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n+        GENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n+        GENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n+        GENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n+        GENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n+        GENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n+        GENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n+\n+        GENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n+\n+        GENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n+        GENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n+\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n+\n+        GENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n+\n+        GENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n+\n+        GENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n+        GENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n+\n+        GENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n+        GENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n+        GENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n+\n+        GENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n+        GENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n+        GENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n+\n+        GENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n+        GENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n+        GENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n+\n+        GENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n+        GENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n+        GENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n+        GENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n+        GENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n+        GENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n+        GENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n+\n+        GENERAL_GEAR_STATUS.setActualGear(GENERAL_ACTUAL_GEAR);\n+        GENERAL_GEAR_STATUS.setTransmissionType(GENERAL_TRANSMISSION_TYPE);\n+        GENERAL_GEAR_STATUS.setUserSelectedGear(GENERAL_USER_SELECTED_GEAR);\n+\n+        GENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n+        GENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n+        GENERAL_STABILITY_CONTROL_STATUS.setEscSystem(GENERAL_ESC_SYSTEM);\n+        GENERAL_STABILITY_CONTROL_STATUS.setTrailerSwayControl(GENERAL_S_WAY_CONTROL);\n+\n+        GENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n+        GENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n+\n+        try {\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n+\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n+\n+            JSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n+            JSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n+\n+            JSON_HMILEVELS.put(HMILevel.HMI_FULL);\n+            JSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n+\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n+\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n+            JSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n+\n+            JSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n+            JSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n+            JSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n+\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n+\n+            JSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n+            JSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_TURNS.put(JSON_TURN);\n+\n+            JSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n+\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n+            JSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n+\n+            JSONObject jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+            jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n+            JSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n+            JSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n+\n+            JSON_CHOICES.put(JSON_CHOICE);\n+\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n+\n+            JSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n+\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n+\n+            JSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n+            JSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n+            JSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n+            JSON_DIDRESULTS.put(JSON_DIDRESULT);\n+\n+            JSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSONObject jsonButton = new JSONObject();\n+            jsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n+            jsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n+            JSON_BUTTONCAPABILITIES.put(jsonButton);\n+\n+            JSONObject jsonRadioControlCapabilities = new JSONObject();\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n+\n+            JSONObject jsonClimateControlCapabilities = new JSONObject();\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n+            JSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+            JSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n+\n+            JSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n+            JSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n+            JSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n+            JSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n+            JSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n+\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n+            JSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n+            JSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n+\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n+            JSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n+\n+            JSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPES.put(ImageType.STATIC);\n+\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n+\n+            JSONObject jsonTEC = new JSONObject();\n+            jsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n+\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n+            JSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n+\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n+\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n+            JSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n+\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n+            JSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n+\n+            JSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n+\n+            JSON_SEAT_LOCATIONS.put(JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n+\n+\n+        } catch (JSONException e) {\n+            Log.e(\"Test\", \"Static Json Construction Failed.\", e);\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwMzU1NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r475003554", "bodyText": "@kostyaBoss you can change ...setDiagonalScreenSize(4.); to ...setDiagonalScreenSize(GENERAL_DOUBLE);", "author": "santhanamk", "createdAt": "2020-08-21T23:00:22Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -897,11 +903,23 @@ public void onVoiceCommandSelected() {\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 131b23947..7b3f5dc70 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -890,510 +905,516 @@ public class TestValues {\n         GENERAL_PERMISSIONITEM.setRequireEncryption(GENERAL_BOOLEAN);\n         GENERAL_PERMISSIONITEM_LIST.add(GENERAL_PERMISSIONITEM);\n \n-\t\tGENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n-\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(6.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(29.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setScale(1.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n-\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n-\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n-\n-\t\tGENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n-\n-\t\tGENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n-\t\tGENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n-\t\tGENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n-\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n-\n-\t\tGENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n-\n-\t\tList<MetadataType> exampleList = new ArrayList<>();\n-\t\texampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n-\t\texampleList.add(1, MetadataType.MEDIA_ALBUM);\n-\t\texampleList.add(2, MetadataType.MEDIA_ARTIST);\n-\n-\t\tGENERAL_METADATASTRUCT.setMainField1(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField2(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField3(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField4(exampleList);\n-\n-\t\tGENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n-\n-\t\tGENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n-\t\tGENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n-\n-\t\tGENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n-\n-\t\tGENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n-\t\tGENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n-\t\tGENERAL_LOCKSCREENCONFIG.setEnabled(true);\n-\t\tGENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n-\t\tGENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n-\t\tGENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n-\n-\t\tGENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n-\t\tGENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n-\n-\t\tGENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n-\n-\t\tGENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n-\n-\t\tGENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n-\t\tGENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n-\n-\t\tGENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n-\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n-\t\tGENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n-\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n-\t\tGENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n-\t\tGENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n-\n-\t\tGENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\tGENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n-\n-\t\ttry {\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n-\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n-\n-\t\t\tJSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n-\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_FULL);\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n-\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n-\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n-\t\t\tJSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n-\n-\t\t\tJSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n-\t\t\tJSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n-\t\t\tJSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED , GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n-\n-\t\t\tJSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n-\t\t\tJSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_TURNS.put(JSON_TURN);\n-\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n-\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n-\t    \tJSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n-\n-\t    \tJSONObject jsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\t    \tjsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n-\n-\t\t\tJSON_CHOICES.put(JSON_CHOICE);\n-\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n-\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n-\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n-\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n-\t\t\tJSON_DIDRESULTS.put(JSON_DIDRESULT);\n-\n-\t\t\tJSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSONObject jsonButton = new JSONObject();\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n-\t\t\tJSON_BUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSONObject jsonRadioControlCapabilities = new JSONObject();\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n-\n-\t\t\tJSONObject jsonClimateControlCapabilities = new JSONObject();\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n-\t\t\tJSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\t\t\tJSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n-\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n-\t\t\tJSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n-\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n-\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.STATIC);\n-\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n-\n-\t\t\tJSONObject jsonTEC = new JSONObject();\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n-\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n-\t\t\tJSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n-\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n-\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n-\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n-\t\t\tJSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n-\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n-\n-\t\t\tJSON_SEAT_LOCATIONS.put(JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n-\n-\n-\t\t} catch (JSONException e) {\n-\t\t\tLog.e(\"Test\", \"Static Json Construction Failed.\", e);\n-\t\t}\n-\t}\n+        GENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n+\n+        GENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n+        GENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n+        GENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n+\n+        GENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n+\n+        GENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n+\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n+\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n+        GENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n+\n+        GENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n+\n+        GENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n+        GENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n+        GENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n+        GENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n+\n+        GENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n+\n+        GENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n+\n+        List<MetadataType> exampleList = new ArrayList<>();\n+        exampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n+        exampleList.add(1, MetadataType.MEDIA_ALBUM);\n+        exampleList.add(2, MetadataType.MEDIA_ARTIST);\n+\n+        GENERAL_METADATASTRUCT.setMainField1(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField2(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField3(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField4(exampleList);\n+\n+        GENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n+\n+        GENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n+        GENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n+\n+        GENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n+\n+        GENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n+        GENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n+        GENERAL_LOCKSCREENCONFIG.setDisplayMode(LockScreenConfig.DISPLAY_MODE_ALWAYS);\n+        GENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n+        GENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n+        GENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n+        GENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n+        GENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n+        GENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n+        GENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n+        GENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n+        GENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n+\n+        GENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n+\n+        GENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n+        GENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n+\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n+\n+        GENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n+\n+        GENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n+\n+        GENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n+        GENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n+\n+        GENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n+        GENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n+        GENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n+\n+        GENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n+        GENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n+        GENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n+\n+        GENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n+        GENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n+        GENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n+\n+        GENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n+        GENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n+        GENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n+        GENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n+        GENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n+        GENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n+        GENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n+\n+        GENERAL_GEAR_STATUS.setActualGear(GENERAL_ACTUAL_GEAR);\n+        GENERAL_GEAR_STATUS.setTransmissionType(GENERAL_TRANSMISSION_TYPE);\n+        GENERAL_GEAR_STATUS.setUserSelectedGear(GENERAL_USER_SELECTED_GEAR);\n+\n+        GENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n+        GENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n+        GENERAL_STABILITY_CONTROL_STATUS.setEscSystem(GENERAL_ESC_SYSTEM);\n+        GENERAL_STABILITY_CONTROL_STATUS.setTrailerSwayControl(GENERAL_S_WAY_CONTROL);\n+\n+        GENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n+        GENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n+\n+        try {\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n+\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n+\n+            JSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n+            JSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n+\n+            JSON_HMILEVELS.put(HMILevel.HMI_FULL);\n+            JSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n+\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n+\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n+            JSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n+\n+            JSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n+            JSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n+            JSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n+\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n+\n+            JSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n+            JSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_TURNS.put(JSON_TURN);\n+\n+            JSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n+\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n+            JSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n+\n+            JSONObject jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+            jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n+            JSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n+            JSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n+\n+            JSON_CHOICES.put(JSON_CHOICE);\n+\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n+\n+            JSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n+\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n+\n+            JSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n+            JSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n+            JSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n+            JSON_DIDRESULTS.put(JSON_DIDRESULT);\n+\n+            JSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSONObject jsonButton = new JSONObject();\n+            jsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n+            jsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n+            JSON_BUTTONCAPABILITIES.put(jsonButton);\n+\n+            JSONObject jsonRadioControlCapabilities = new JSONObject();\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n+\n+            JSONObject jsonClimateControlCapabilities = new JSONObject();\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n+            JSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+            JSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n+\n+            JSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n+            JSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n+            JSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n+            JSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n+            JSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n+\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n+            JSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n+            JSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n+\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n+            JSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n+\n+            JSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPES.put(ImageType.STATIC);\n+\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n+\n+            JSONObject jsonTEC = new JSONObject();\n+            jsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n+\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n+            JSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n+\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n+\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n+            JSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n+\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n+            JSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n+\n+            JSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n+\n+            JSON_SEAT_LOCATIONS.put(JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n+\n+\n+        } catch (JSONException e) {\n+            Log.e(\"Test\", \"Static Json Construction Failed.\", e);\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwMzc4NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r475003785", "bodyText": "@kostyaBoss you can change ...setScale(1.); to ...setScale(GENERAL_DOUBLE);", "author": "santhanamk", "createdAt": "2020-08-21T23:01:30Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -897,11 +903,23 @@ public void onVoiceCommandSelected() {\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 131b23947..7b3f5dc70 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -890,510 +905,516 @@ public class TestValues {\n         GENERAL_PERMISSIONITEM.setRequireEncryption(GENERAL_BOOLEAN);\n         GENERAL_PERMISSIONITEM_LIST.add(GENERAL_PERMISSIONITEM);\n \n-\t\tGENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n-\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(4.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(1.);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(6.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(29.);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setScale(1.);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n-\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n-\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n-\n-\t\tGENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n-\n-\t\tGENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n-\t\tGENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n-\t\tGENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n-\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n-\n-\t\tGENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n-\n-\t\tList<MetadataType> exampleList = new ArrayList<>();\n-\t\texampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n-\t\texampleList.add(1, MetadataType.MEDIA_ALBUM);\n-\t\texampleList.add(2, MetadataType.MEDIA_ARTIST);\n-\n-\t\tGENERAL_METADATASTRUCT.setMainField1(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField2(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField3(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField4(exampleList);\n-\n-\t\tGENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n-\n-\t\tGENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n-\t\tGENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n-\n-\t\tGENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n-\n-\t\tGENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n-\t\tGENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n-\t\tGENERAL_LOCKSCREENCONFIG.setEnabled(true);\n-\t\tGENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n-\t\tGENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n-\t\tGENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n-\n-\t\tGENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n-\t\tGENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n-\n-\t\tGENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n-\n-\t\tGENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n-\n-\t\tGENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n-\t\tGENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n-\n-\t\tGENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n-\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n-\t\tGENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n-\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n-\t\tGENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n-\t\tGENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n-\n-\t\tGENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\tGENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n-\n-\t\ttry {\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n-\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n-\n-\t\t\tJSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n-\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_FULL);\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n-\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n-\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n-\t\t\tJSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n-\n-\t\t\tJSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n-\t\t\tJSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n-\t\t\tJSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED , GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n-\n-\t\t\tJSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n-\t\t\tJSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_TURNS.put(JSON_TURN);\n-\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n-\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n-\t    \tJSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n-\n-\t    \tJSONObject jsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\t    \tjsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n-\n-\t\t\tJSON_CHOICES.put(JSON_CHOICE);\n-\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n-\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n-\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n-\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n-\t\t\tJSON_DIDRESULTS.put(JSON_DIDRESULT);\n-\n-\t\t\tJSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSONObject jsonButton = new JSONObject();\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n-\t\t\tJSON_BUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSONObject jsonRadioControlCapabilities = new JSONObject();\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n-\n-\t\t\tJSONObject jsonClimateControlCapabilities = new JSONObject();\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n-\t\t\tJSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\t\t\tJSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n-\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n-\t\t\tJSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n-\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n-\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.STATIC);\n-\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n-\n-\t\t\tJSONObject jsonTEC = new JSONObject();\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n-\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n-\t\t\tJSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n-\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n-\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n-\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n-\t\t\tJSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n-\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n-\n-\t\t\tJSON_SEAT_LOCATIONS.put(JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n-\n-\n-\t\t} catch (JSONException e) {\n-\t\t\tLog.e(\"Test\", \"Static Json Construction Failed.\", e);\n-\t\t}\n-\t}\n+        GENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n+\n+        GENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n+        GENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n+        GENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n+\n+        GENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n+\n+        GENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n+\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n+\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n+        GENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n+\n+        GENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n+\n+        GENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n+        GENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n+        GENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n+        GENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n+\n+        GENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n+\n+        GENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n+\n+        List<MetadataType> exampleList = new ArrayList<>();\n+        exampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n+        exampleList.add(1, MetadataType.MEDIA_ALBUM);\n+        exampleList.add(2, MetadataType.MEDIA_ARTIST);\n+\n+        GENERAL_METADATASTRUCT.setMainField1(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField2(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField3(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField4(exampleList);\n+\n+        GENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n+\n+        GENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n+        GENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n+\n+        GENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n+\n+        GENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n+        GENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n+        GENERAL_LOCKSCREENCONFIG.setDisplayMode(LockScreenConfig.DISPLAY_MODE_ALWAYS);\n+        GENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n+        GENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n+        GENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n+        GENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n+        GENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n+        GENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n+        GENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n+        GENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n+        GENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n+\n+        GENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n+\n+        GENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n+        GENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n+\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n+\n+        GENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n+\n+        GENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n+\n+        GENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n+        GENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n+\n+        GENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n+        GENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n+        GENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n+\n+        GENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n+        GENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n+        GENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n+\n+        GENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n+        GENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n+        GENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n+\n+        GENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n+        GENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n+        GENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n+        GENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n+        GENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n+        GENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n+        GENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n+\n+        GENERAL_GEAR_STATUS.setActualGear(GENERAL_ACTUAL_GEAR);\n+        GENERAL_GEAR_STATUS.setTransmissionType(GENERAL_TRANSMISSION_TYPE);\n+        GENERAL_GEAR_STATUS.setUserSelectedGear(GENERAL_USER_SELECTED_GEAR);\n+\n+        GENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n+        GENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n+        GENERAL_STABILITY_CONTROL_STATUS.setEscSystem(GENERAL_ESC_SYSTEM);\n+        GENERAL_STABILITY_CONTROL_STATUS.setTrailerSwayControl(GENERAL_S_WAY_CONTROL);\n+\n+        GENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n+        GENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n+\n+        try {\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n+\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n+\n+            JSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n+            JSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n+\n+            JSON_HMILEVELS.put(HMILevel.HMI_FULL);\n+            JSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n+\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n+\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n+            JSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n+\n+            JSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n+            JSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n+            JSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n+\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n+\n+            JSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n+            JSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_TURNS.put(JSON_TURN);\n+\n+            JSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n+\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n+            JSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n+\n+            JSONObject jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+            jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n+            JSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n+            JSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n+\n+            JSON_CHOICES.put(JSON_CHOICE);\n+\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n+\n+            JSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n+\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n+\n+            JSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n+            JSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n+            JSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n+            JSON_DIDRESULTS.put(JSON_DIDRESULT);\n+\n+            JSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSONObject jsonButton = new JSONObject();\n+            jsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n+            jsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n+            JSON_BUTTONCAPABILITIES.put(jsonButton);\n+\n+            JSONObject jsonRadioControlCapabilities = new JSONObject();\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n+\n+            JSONObject jsonClimateControlCapabilities = new JSONObject();\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n+            JSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+            JSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n+\n+            JSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n+            JSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n+            JSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n+            JSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n+            JSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n+\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n+            JSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n+            JSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n+\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n+            JSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n+\n+            JSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPES.put(ImageType.STATIC);\n+\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n+\n+            JSONObject jsonTEC = new JSONObject();\n+            jsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n+\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n+            JSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n+\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n+\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n+            JSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n+\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n+            JSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n+\n+            JSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n+\n+            JSON_SEAT_LOCATIONS.put(JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n+\n+\n+        } catch (JSONException e) {\n+            Log.e(\"Test\", \"Static Json Construction Failed.\", e);\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwNjg1NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r475006855", "bodyText": "@kostyaBoss You can replace lines 749-750 with your AspectRatio object.", "author": "santhanamk", "createdAt": "2020-08-21T23:15:48Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -603,6 +734,109 @@ void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics\n \t\treturn motionEventList;\n \t}\n \n+\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n+\t\treturn parameters;\n+\t}\n+\n+\tpublic boolean getLastCachedIsEncrypted() {\n+\t\treturn isEncrypted;\n+\t}\n+\n+\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n+\t\t\tResolution minResolution,\n+\t\t\tResolution maxResolution,\n+\t\t\tDouble minScreenDiagonal,\n+\t\t\tDouble minAspectRatio,", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcxNzU4NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r476717584", "bodyText": "@santhanamk couple of days ago, according to your request I've replaced this object with raw info, #1434 (comment)", "author": "kboskin", "createdAt": "2020-08-25T20:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwNjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc0MTE3OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r476741178", "bodyText": "@santhanamk couple of days ago, according to your request I've replaced this object with raw info, #1434 (comment)\n\nYeah that is true, but I saw that you had the AspectRatio class which has both of those fields.  If you could use that AspectRatio class you have that would be good.  If it is too much work to refactor it out, then you can leave it as it is.", "author": "santhanamk", "createdAt": "2020-08-25T21:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwNjg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex 76114d5bd..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -64,878 +65,968 @@ import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.TouchCoord;\n import com.smartdevicelink.proxy.rpc.TouchEvent;\n import com.smartdevicelink.proxy.rpc.VideoStreamingCapability;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.HMILevel;\n import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n import com.smartdevicelink.proxy.rpc.enums.TouchType;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n import com.smartdevicelink.proxy.rpc.enums.VideoStreamingState;\n import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.session.SdlSession;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.IVideoStreamListener;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n import com.smartdevicelink.streaming.video.SdlRemoteDisplay;\n import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n import com.smartdevicelink.transport.utl.TransportRecord;\n import com.smartdevicelink.util.DebugTool;\n import com.smartdevicelink.util.Version;\n \n+import java.io.IOException;\n import java.lang.ref.WeakReference;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.FutureTask;\n \n @TargetApi(19)\n public class VideoStreamManager extends BaseVideoStreamManager {\n-\tprivate static String TAG = \"VideoStreamManager\";\n-\n-\tprivate WeakReference<Context> context;\n-\tprivate volatile VirtualDisplayEncoder virtualDisplayEncoder;\n-\tprivate Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n-\tprivate SdlRemoteDisplay sdlRemoteDisplay;\n-\tprivate float[] touchScalar = {1.0f,1.0f}; //x, y\n-\tprivate HapticInterfaceManager hapticManager;\n-\tprivate SdlMotionEvent sdlMotionEvent = null;\n-\tprivate OnHMIStatus currentOnHMIStatus;\n-\tprivate StreamingStateMachine stateMachine;\n-\tprivate VideoStreamingParameters parameters;\n-\tprivate VideoStreamingCapability originalCapability;\n-\tprivate IVideoStreamListener streamListener;\n-\tprivate boolean isTransportAvailable = false;\n-\tprivate Integer majorProtocolVersion;\n-\tprivate VideoStreamingRange streamingRange;\n-\tprivate boolean hasStarted;\n-\tprivate String vehicleMake = null;\n-\tprivate boolean isEncrypted = false;\n-\tprivate boolean withPendingRestart = false;\n-\n-\t// INTERNAL INTERFACES\n-\n-\tprivate final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif (session != null && session.getAcceptedVideoParams() != null) {\n-\t\t\t\t\tparameters = session.getAcceptedVideoParams();\n-\t\t\t\t\tVideoStreamManager.this.streamListener = session.startVideoStream();\n-\t\t\t\t}\n-\n-\t\t\t\tif (VideoStreamManager.this.streamListener == null) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error starting video stream\");\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\tif(capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())){\n-\t\t\t\t\thapticManager = new HapticInterfaceManager(internalInterface);\n-\t\t\t\t}\n-\t\t\t\tcheckState();\n-\t\t\t\tstartEncoder();\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\t\thasStarted = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SdlSession session, SessionType type) {\n-\t\t\tif(SessionType.NAV.equals(type)){\n-\t\t\t\tif(sdlRemoteDisplay !=null){\n-\t\t\t\t    // TODO set withPendingRestart to default in proper place\n-\t\t\t\t\tstopStreaming(withPendingRestart);\n-\t\t\t\t}\n-\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\t\t\ttransitionToState(SETTING_UP);\n-\n-\t\t\t\tif (withPendingRestart){\n-\t\t\t\t\tVideoStreamManager manager = VideoStreamManager.this;\n-\t\t\t\t\tmanager.internalInterface.startVideoService(\n-\t\t\t\t\t\t\tmanager.getLastCachedStreamingParameters(),\n-\t\t\t\t\t\t\tmanager.isEncrypted\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceError(SdlSession session, SessionType type, String reason) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null){\n-\t\t\t\tOnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n-\t\t\t\tif (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tOnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n-\t\t\t\tcurrentOnHMIStatus = onHMIStatus;\n-\n-\t\t\t\tif (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n-\t\t\t\t\tinternalInterface.stopVideoService();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n-\t\t@Override\n-\t\tpublic void onNotified(RPCNotification notification) {\n-\t\t\tif(notification != null && sdlRemoteDisplay != null){\n-\t\t\t\tList<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent)notification);\n-\t\t\t\tif (motionEventList != null && !motionEventList.isEmpty()) {\n-\t\t\t\t\tfor (MotionEvent motionEvent : motionEventList) {\n-\t\t\t\t\t\tsdlRemoteDisplay.handleMotionEvent(motionEvent);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t};\n-\n-\tprivate final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n-\t\t@Override\n-\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\n-\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\n-\t\t\t// means only scale received\n-\t\t\tif (castedCapability.getPreferredResolution() == null &&\n-\t\t\t\t\tcastedCapability.getScale() != null &&\n-\t\t\t\t\tcastedCapability.getScale() != 0 &&\n-\t\t\t\t\tVideoStreamManager.this.parameters != null\n-\t\t\t\t\t&& VideoStreamManager.this.parameters.getResolution() != null) {\n-\t\t\t\t// set cached resolution\n-\t\t\t\tcastedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n-\t\t\t}\n-\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\tVideoStreamManager.this.withPendingRestart = true;\n-\n-\t\t\tvirtualDisplayEncoder.setStreamingParams(params);\n-\t\t\tstopStreaming(true);\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onError(String info) { }\n-\t};\n-\n-\t// MANAGER APIs\n-\tpublic VideoStreamManager(ISdl internalInterface){\n-\t\tsuper(internalInterface);\n-\n-\t\tif(internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n-\t\t\t\tinternalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n-\t\t\tvehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n-\t\t}\n-\t\tvirtualDisplayEncoder = new VirtualDisplayEncoder();\n-\n-\t\t// Listen for video service events\n-\t\tinternalInterface.addServiceListener(SessionType.NAV, serviceListener);\n-\t\t// Take care of the touch events\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t// Listen for HMILevel changes\n-\t\tinternalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t// Listen for SystemCapabilityType VIDEO_STREAMING\n-\t\tinternalInterface.addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n-\t\tstateMachine = new StreamingStateMachine();\n-\t}\n-\n-\t@Override\n-\tpublic void start(CompletionListener listener) {\n-\t\tisTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n-\t\tcheckState();\n-\t\tsuper.start(listener);\n-\t}\n-\n-\tprivate synchronized void checkState(){\n-\t\tif(this.getState() == SETTING_UP\n-\t\t\t\t&& isTransportAvailable\n-\t\t\t\t&& isHMIStateVideoStreamCapable(currentOnHMIStatus)\n-\t\t\t\t&& parameters != null){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.READY);\n-\t\t\ttransitionToState(READY);\n-\t\t}\n-\t}\n-\n-\tboolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n-\t\tHMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n-\t\tVideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n-\t\treturn (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n-\t}\n-\n-\tprivate void getVideoStreamingParams(){\n-\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5) {\n-\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\tcheckState();\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\ttransitionToState(ERROR);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}else{\n-\t\t\t//We just use default video streaming params\n-\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\tif(dispCap !=null){\n-\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t}\n-\n-\t\t\tthis.parameters = params;\n-\t\t\tcheckState();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param streamingRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, VideoStreamingRange streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tif (streamingRange != null) {\n-\t\t\tthis.streamingRange = streamingRange;\n-\t\t}\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n-\t\tif(parameters == null){\n-\t\t\tif(majorProtocolVersion >= 5) {\n-\t\t\t\tinternalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onCapabilityRetrieved(Object capability) {\n-\t\t\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\t\t\tVideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n-\t\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n-\n-\t\t\t\t\t\t// Mocks data here\n-\t\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n-\t\t\t\t\t\tparams.update(castedCapability, vehicleMake);\t//Streaming parameters are ready time to stream\n-\t\t\t\t\t\tVideoStreamManager.this.parameters = params;\n-\n-\t\t\t\t\t\tif (streamingRange != null) {\n-\t\t\t\t\t\t\t// filtering\n-\t\t\t\t\t\t\tcastedCapability.setAdditionalVideoStreamingCapabilities(\n-\t\t\t\t\t\t\t\t\tgetSupportedCapabilities(\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxResolution(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinScreenDiagonal(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMinAspectRatio(),\n-\t\t\t\t\t\t\t\t\t\t\tstreamingRange.getMaxAspectRatio(),\n-\t\t\t\t\t\t\t\t\t\t\tcastedCapability.getAdditionalVideoStreamingCapabilities()\n-\t\t\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// TODO handle??\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tOnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n-\t\t\t\t\t\tinternalInterface.sendRPC(onAppCapabilityUpdated);\n-\t\t\t\t\t\tstartStreaming(params, isEncrypted);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(String info) {\n-\t\t\t\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\t\t\t\tDebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}else{\n-\t\t\t\t//We just use default video streaming params\n-\t\t\t\tVideoStreamingParameters params = new VideoStreamingParameters();\n-\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities)internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\tif(dispCap !=null){\n-\t\t\t\t\tparams.setResolution(dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t}\n-\t\t\t\tstartStreaming(params, encrypted);\n-\t\t\t}\n-\t\t}else{\n-\t\t\tstartStreaming(parameters, encrypted);\n-\t\t}\n-\t}\n-\n-\n-\t/**\n-\t * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n-\t * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n-\t *                    VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n-\t * @param encrypted Specify true if packets on this service have to be encrypted\n-\t */\n-\tprotected void startStreaming(VideoStreamingParameters parameters, boolean encrypted){\n-\t\tthis.parameters = parameters;\n-\t\tif (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n-\t\t\tDebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n-\t\t\treturn;\n-\t\t}\n-\t\t//Start the video service\n-\t\tthis.internalInterface.startVideoService(parameters, encrypted);\n-\t}\n-\n-\t/**\n-\t * Initializes and starts the virtual display encoder and creates the remote display\n-\t */\n-\tprivate void startEncoder(){\n-\t\ttry {\n-\t\t\tif (sdlRemoteDisplay != null) {\n-\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t}\n-\n-\t\t\tvirtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n-\t\t\t//We are all set so we can start streaming at at this point\n-\t\t\tvirtualDisplayEncoder.start();\n-\t\t\t//Encoder should be up and running\n-\t\t\tcreateRemoteDisplay(virtualDisplayEncoder.getDisplay());\n-\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.STARTED);\n-\t\t\thasStarted = true;\n-\t\t} catch (Exception e) {\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming from the remote display. To restart, call\n-\t * @see #resumeStreaming()\n-\t */\n-\tpublic void stopStreaming(boolean withPendingRestart){\n-\t\tif(sdlRemoteDisplay!=null && !withPendingRestart){\n-\t\t\tsdlRemoteDisplay.stop();\n-\t\t\tthis.withPendingRestart = false;\n-\t\t}\n-\t\tif (this.isStreaming()) {\n-\t\t\tif(virtualDisplayEncoder!=null){\n-\t\t\t\tvirtualDisplayEncoder.shutDown(withPendingRestart);\n-\t\t\t}\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.PAUSED);\n-\n-\t\t\tthis.internalInterface.stopVideoService();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Resumes streaming after calling\n-\t * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n-\t * followed by a call to\n-\t * @see #stopStreaming(boolean withPendingRestart)\n-\t */\n-\tpublic void resumeStreaming(){\n-\t\tint currentState = stateMachine.getState();\n-\t\tif (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n-\t\t\tstartEncoder();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Stops streaming, ends video streaming service and removes service listeners.\n-\t */\n-\t@Override\n-\tpublic void dispose(){\n-\t\tstopStreaming(false);\n-\n-\t\thapticManager = null;\n-\t\tsdlRemoteDisplay = null;\n-\t\tparameters = null;\n-\t\tvirtualDisplayEncoder = null;\n-\t\tif (internalInterface != null) {\n-\t\t\tinternalInterface.stopVideoService();\n-\t\t\t// Remove listeners\n-\t\t\tinternalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n-\t\t\tinternalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n-\t\t}\n-\n-\n-\n-\t\tstateMachine.transitionToState(StreamingStateMachine.NONE);\n-\t\tsuper.dispose();\n-\t}\n-\n-\t// PUBLIC METHODS FOR CHECKING STATE\n-\n-\t/**\n-\t * Check if a video service is currently active\n-\t * @return boolean (true = active, false = inactive)\n-\t */\n-\tpublic boolean isServiceActive(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.READY) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STARTED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n-\t\t\t\t(stateMachine.getState() == StreamingStateMachine.PAUSED);\n-\t}\n-\n-\t/**\n-\t * Check if video is currently streaming and visible\n-\t * @return boolean (true = yes, false = no)\n-\t */\n-\tpublic boolean isStreaming(){\n-\t\treturn (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));\n-\t}\n-\n-\t/**\n-\t * Check if video streaming has been paused due to app moving to background or manually stopped\n-\t * @return boolean (true = not paused, false = paused)\n-\t */\n-\tpublic boolean isPaused(){\n-\t\treturn (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n-\t}\n-\n-\t/**\n-\t * Gets the current video streaming state as defined in @StreamingStateMachine\n-\t * @return int representing StreamingStateMachine.StreamingState\n-\t */\n-\tpublic @StreamingStateMachine.StreamingState int currentVideoStreamState(){\n-\t\treturn stateMachine.getState();\n-\t}\n-\n-\t// HELPER METHODS\n-\n-\tprivate void createRemoteDisplay(final Display disp){\n-\t\ttry{\n-\t\t\tif (disp == null){\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Dismiss the current presentation if the display has changed.\n-\t\t\tif (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n-\t\t\t\tsdlRemoteDisplay.dismissPresentation();\n-\t\t\t}\n-\n-\t\t\tFutureTask<Boolean> fTask =  new FutureTask<Boolean>( new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback(){\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onCreated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Remote display has been created.\n-\t\t\t\t\t//Now is a good time to do parsing for spatial data\n-\t\t\t\t\tVideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\t//Get touch scalars\n-\t\t\t\t\tImageResolution resolution = null;\n-\t\t\t\t\tif(internalInterface.getProtocolVersion().getMajor() >= 5){ //At this point we should already have the capability\n-\t\t\t\t\t\tVideoStreamingCapability capability = (VideoStreamingCapability) internalInterface.getCapability(SystemCapabilityType.VIDEO_STREAMING);\n-\t\t\t\t\t\tif(capability != null){\n-\t\t\t\t\t\t\tresolution = capability.getPreferredResolution();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution == null){ //Either the protocol version is too low to access video streaming caps, or they were null\n-\t\t\t\t\t\tDisplayCapabilities dispCap = (DisplayCapabilities) internalInterface.getCapability(SystemCapabilityType.DISPLAY);\n-\t\t\t\t\t\tif (dispCap != null) {\n-\t\t\t\t\t\t\tresolution = (dispCap.getScreenParams().getImageResolution());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif(resolution != null){\n-\t\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\t\tdisp.getMetrics(displayMetrics);\n-\t\t\t\t\t\tcreateTouchScalar(resolution, displayMetrics);\n+    private static final String TAG = \"VideoStreamManager\";\n+\n+    private WeakReference<Context> context;\n+    private volatile VirtualDisplayEncoder virtualDisplayEncoder;\n+    private Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n+    private SdlRemoteDisplay sdlRemoteDisplay;\n+    private final float[] touchScalar = {1.0f, 1.0f}; //x, y\n+    private HapticInterfaceManager hapticManager;\n+    private SdlMotionEvent sdlMotionEvent = null;\n+    private OnHMIStatus currentOnHMIStatus;\n+    private final StreamingStateMachine stateMachine;\n+    private VideoStreamingParameters parameters;\n+    private VideoStreamingCapability originalCapability;\n+    private IVideoStreamListener streamListener;\n+    private boolean isTransportAvailable = false;\n+    private Integer majorProtocolVersion;\n+    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private boolean hasStarted;\n+    private String vehicleMake = null;\n+    private boolean isEncrypted = false;\n+    private boolean withPendingRestart = false;\n+    private AbstractPacketizer videoPacketizer;\n+\n+    // INTERNAL INTERFACES\n+\n+    private final ISdlServiceListener serviceListener = new ISdlServiceListener() {\n+        @Override\n+        public void onServiceStarted(SdlSession session, SessionType type, boolean isEncrypted) {\n+            if (SessionType.NAV.equals(type)) {\n+                if (session != null && session.getAcceptedVideoParams() != null) {\n+                    parameters = session.getAcceptedVideoParams();\n+                    VideoStreamManager.this.streamListener = startVideoStream(session.getAcceptedVideoParams(), session);\n+                }\n+\n+                if (VideoStreamManager.this.streamListener == null) {\n+                    DebugTool.logError(TAG, \"Error starting video stream\");\n+                    stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                    return;\n+                }\n+                VideoStreamingCapability capability = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                }\n+                if (capability != null && Boolean.TRUE.equals(capability.getIsHapticSpatialDataSupported())) {\n+                    hapticManager = new HapticInterfaceManager(internalInterface);\n+                }\n+                checkState();\n+                startEncoder();\n+                stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+                hasStarted = true;\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceEnded(SdlSession session, SessionType type) {\n+            if (SessionType.NAV.equals(type)) {\n+                //stopVideoStream();\n+                if (sdlRemoteDisplay !=null){\n+                    stopStreaming(withPendingRestart);\n+                }\n+                stateMachine.transitionToState(StreamingStateMachine.NONE);\n+                transitionToState(SETTING_UP);\n+\n+                if (withPendingRestart){\n+                    VideoStreamManager manager = VideoStreamManager.this;\n+                    manager.internalInterface.startVideoService(\n+                            manager.getLastCachedStreamingParameters(),\n+                            manager.isEncrypted,\n+                            withPendingRestart\n+                    );\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onServiceError(SdlSession session, SessionType type, String reason) {\n+            DebugTool.logError(TAG, \"Unable to start video service: \" + reason);\n+            stopVideoStream();\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            transitionToState(BaseSubManager.ERROR);\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener hmiListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null) {\n+                OnHMIStatus onHMIStatus = (OnHMIStatus) notification;\n+                if (onHMIStatus.getWindowID() != null && onHMIStatus.getWindowID() != PredefinedWindows.DEFAULT_WINDOW.getValue()) {\n+                    return;\n+                }\n+                OnHMIStatus prevOnHMIStatus = currentOnHMIStatus;\n+                currentOnHMIStatus = onHMIStatus;\n+                if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+                    getVideoStreamingParams();\n+                }\n+                checkState();\n+                if (hasStarted && (isHMIStateVideoStreamCapable(prevOnHMIStatus)) && (!isHMIStateVideoStreamCapable(currentOnHMIStatus))) {\n+                    stopVideoStream();\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnRPCNotificationListener touchListener = new OnRPCNotificationListener() {\n+        @Override\n+        public void onNotified(RPCNotification notification) {\n+            if (notification != null && sdlRemoteDisplay != null) {\n+                List<MotionEvent> motionEventList = convertTouchEvent((OnTouchEvent) notification);\n+                if (motionEventList != null && !motionEventList.isEmpty()) {\n+                    for (MotionEvent motionEvent : motionEventList) {\n+                        sdlRemoteDisplay.handleMotionEvent(motionEvent);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    private final OnSystemCapabilityListener systemCapabilityListener = new OnSystemCapabilityListener() {\n+        @Override\n+        public void onCapabilityRetrieved(Object capability) {\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+\n+            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\n+            // means only scale received\n+            if (castedCapability.getPreferredResolution() == null &&\n+                    castedCapability.getScale() != null &&\n+                    castedCapability.getScale() != 0 &&\n+                    VideoStreamManager.this.parameters != null\n+                    && VideoStreamManager.this.parameters.getResolution() != null) {\n+                // set cached resolution\n+                castedCapability.setPreferredResolution(originalCapability.getPreferredResolution());\n+            }\n+            params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+            VideoStreamManager.this.parameters = params;\n+\n+            VideoStreamManager.this.withPendingRestart = true;\n+\n+            virtualDisplayEncoder.setStreamingParams(params);\n+            stopStreaming(true);\n+        }\n+\n+        @Override\n+        public void onError(String info) { }\n+    };\n+\n+    // MANAGER APIs\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public VideoStreamManager(ISdl internalInterface) {\n+        super(internalInterface);\n+\n+        if (internalInterface != null && internalInterface.getRegisterAppInterfaceResponse() != null &&\n+                internalInterface.getRegisterAppInterfaceResponse().getVehicleType() != null) {\n+            vehicleMake = internalInterface.getRegisterAppInterfaceResponse().getVehicleType().getMake();\n+        }\n+        virtualDisplayEncoder = new VirtualDisplayEncoder();\n+\n+        // Listen for video service events\n+        internalInterface.addServiceListener(SessionType.NAV, serviceListener);\n+        // Take care of the touch events\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+        // Listen for HMILevel changes\n+        internalInterface.addOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        // Listen for SystemCapabilityType VIDEO_STREAMING\n+        internalInterface.getSystemCapabilityManager().addOnSystemCapabilityListener(SystemCapabilityType.VIDEO_STREAMING, systemCapabilityListener);\n+        stateMachine = new StreamingStateMachine();\n+    }\n+\n+    @Override\n+    public void start(CompletionListener listener) {\n+        isTransportAvailable = internalInterface.isTransportForServiceAvailable(SessionType.NAV);\n+        checkState();\n+        super.start(listener);\n+    }\n+\n+    private synchronized void checkState() {\n+        if (this.getState() == SETTING_UP\n+                && isTransportAvailable\n+                && isHMIStateVideoStreamCapable(currentOnHMIStatus)\n+                && parameters != null) {\n+            stateMachine.transitionToState(StreamingStateMachine.READY);\n+            transitionToState(READY);\n+        }\n+    }\n+\n+    boolean isHMIStateVideoStreamCapable(OnHMIStatus onHMIStatus) {\n+        HMILevel hmiLevel = (onHMIStatus != null && onHMIStatus.getHmiLevel() != null) ? onHMIStatus.getHmiLevel() : HMILevel.HMI_NONE;\n+        VideoStreamingState videoStreamingState = (onHMIStatus != null && onHMIStatus.getVideoStreamingState() != null) ? onHMIStatus.getVideoStreamingState() : VideoStreamingState.STREAMABLE;\n+        return (hmiLevel.equals(HMILevel.HMI_FULL) || hmiLevel.equals(HMILevel.HMI_LIMITED)) && videoStreamingState.equals(VideoStreamingState.STREAMABLE);\n+    }\n+\n+    private void getVideoStreamingParams() {\n+        if (internalInterface.getProtocolVersion().getMajor() >= 5) {\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                    @Override\n+                    public void onCapabilityRetrieved(Object capability) {\n+                        VideoStreamingParameters params = new VideoStreamingParameters();\n+                        VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                        VideoStreamManager.this.originalCapability = castedCapability;\n+                        params.update(castedCapability, vehicleMake);//Streaming parameters are ready time to stream\n+                        VideoStreamManager.this.parameters = params;\n+                        // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                        checkState();\n+                        }\n+\n+                    @Override\n+                    public void onError(String info) {\n+                        DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                        transitionToState(ERROR);\n+                    }\n+                }, false);\n+            }\n+        } else {\n+            //We just use default video streaming params\n+            VideoStreamingParameters params = new VideoStreamingParameters();\n+            DisplayCapabilities dispCap = null;\n+            if (internalInterface.getSystemCapabilityManager() != null) {\n+                dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+            }\n+            if (dispCap != null) {\n+                params.setResolution(dispCap.getScreenParams().getImageResolution());\n+            }\n+\n+            this.parameters = params;\n+            checkState();\n+        }\n+    }\n+\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        if (parameters == null) {\n+            if (majorProtocolVersion >= 5) {\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n+                        @Override\n+                        public void onCapabilityRetrieved(Object capability) {\n+                            VideoStreamingParameters params = new VideoStreamingParameters();\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+                            VideoStreamManager.this.originalCapability = castedCapability;\n+\n+                            // Mocks data here\n+                            // castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+                            params.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+                            if (listOfStreamingRanges != null) {\n+                                // filtering\n+                                castedCapability.setAdditionalVideoStreamingCapabilities(\n+                                    getSupportedCapabilities(\n+                                            listOfStreamingRanges,\n+                                            castedCapability.getAdditionalVideoStreamingCapabilities()\n+                                    )\n+                                );\n+                            } else { }\n+                            OnAppCapabilityUpdated onAppCapabilityUpdated = new OnAppCapabilityUpdated(new AppCapability(castedCapability, AppCapabilityType.VIDEO_STREAMING));\n+                            internalInterface.sendRPC(onAppCapabilityUpdated);\n+                            startStreaming(params, isEncrypted);\n+                        }\n+\n+                        @Override\n+                        public void onError(String info) {\n+                            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+                            DebugTool.logError(TAG, \"Error retrieving video streaming capability: \" + info);\n+                        }\n+                    }, false);\n+                }\n+            } else {\n+                //We just use default video streaming params\n+                VideoStreamingParameters params = new VideoStreamingParameters();\n+                DisplayCapabilities dispCap = null;\n+                if (internalInterface.getSystemCapabilityManager() != null) {\n+                    dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                }\n+                if (dispCap != null) {\n+                    params.setResolution(dispCap.getScreenParams().getImageResolution());\n+                }\n+                startStreaming(params, encrypted);\n+            }\n+        } else {\n+            startStreaming(parameters, encrypted);\n+        }\n+    }\n+\n+\n+    /**\n+     * Starts video service, sets up encoder, haptic manager, and remote display. Begins streaming the remote display.\n+     *\n+     * @param parameters Video streaming parameters including: codec which will be used for streaming (currently, only\n+     *                   VideoStreamingCodec.H264 is accepted), height and width of the video in pixels.\n+     * @param encrypted  Specify true if packets on this service have to be encrypted\n+     */\n+    protected void startStreaming(VideoStreamingParameters parameters, boolean encrypted) {\n+        this.parameters = parameters;\n+        if (!isHMIStateVideoStreamCapable(currentOnHMIStatus)) {\n+            DebugTool.logError(TAG, \"Cannot start video service in the current HMI status\");\n+            return;\n+        }\n+        //Start the video service\n+        this.internalInterface.startVideoService(parameters, encrypted, false);\n+    }\n+\n+    /**\n+     * Initializes and starts the virtual display encoder and creates the remote display\n+     */\n+    private void startEncoder() {\n+        try {\n+            if (sdlRemoteDisplay != null) {\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+            }\n+\n+            virtualDisplayEncoder.init(this.context.get(), streamListener, parameters);\n+            //We are all set so we can start streaming at at this point\n+            virtualDisplayEncoder.start();\n+            //Encoder should be up and running\n+            createRemoteDisplay(virtualDisplayEncoder.getDisplay());\n+\n+            stateMachine.transitionToState(StreamingStateMachine.STARTED);\n+            hasStarted = true;\n+        } catch (Exception e) {\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming from the remote display. To restart, call\n+     *\n+     * @see #resumeStreaming()\n+     */\n+    public void stopStreaming(boolean withPendingRestart) {\n+        if (sdlRemoteDisplay!= null && !withPendingRestart) {\n+            sdlRemoteDisplay.stop();\n+                this.withPendingRestart = false;\n+        }\n+        if (this.isStreaming()) {\n+            if (virtualDisplayEncoder!=null){\n+                virtualDisplayEncoder.shutDown(withPendingRestart);\n+            }\n+            stateMachine.transitionToState(StreamingStateMachine.PAUSED);\n+            stopVideoStream();\n+        }\n+    }\n+\n+    /**\n+     * Resumes streaming after calling\n+     *\n+     * @see #startRemoteDisplayStream(android.content.Context, Class, com.smartdevicelink.streaming.video.VideoStreamingParameters, boolean)\n+     * followed by a call to\n+     * @see #stopStreaming(boolean withPendingRestart)\n+     */\n+    public void resumeStreaming() {\n+        int currentState = stateMachine.getState();\n+        if (currentState == StreamingStateMachine.STOPPED || currentState == StreamingStateMachine.PAUSED) {\n+            startEncoder();\n+        }\n+    }\n+\n+    /**\n+     * Stops streaming, ends video streaming service and removes service listeners.\n+     */\n+    @Override\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void dispose() {\n+        stopStreaming(false);\n+\n+        hapticManager = null;\n+        sdlRemoteDisplay = null;\n+        parameters = null;\n+        virtualDisplayEncoder = null;\n+        if (internalInterface != null) {\n+            // Remove listeners\n+            internalInterface.removeServiceListener(SessionType.NAV, serviceListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_TOUCH_EVENT, touchListener);\n+            internalInterface.removeOnRPCNotificationListener(FunctionID.ON_HMI_STATUS, hmiListener);\n+        }\n+\n+        stopVideoStream();\n+\n+\n+        stateMachine.transitionToState(StreamingStateMachine.NONE);\n+        super.dispose();\n+    }\n+\n+    // PUBLIC METHODS FOR CHECKING STATE\n+\n+    /**\n+     * Check if a video service is currently active\n+     *\n+     * @return boolean (true = active, false = inactive)\n+     */\n+    public boolean isServiceActive() {\n+        return (stateMachine.getState() == StreamingStateMachine.READY) ||\n+                (stateMachine.getState() == StreamingStateMachine.STARTED) ||\n+                (stateMachine.getState() == StreamingStateMachine.STOPPED) ||\n+                (stateMachine.getState() == StreamingStateMachine.PAUSED);\n+        }\n+\n+    /**\n+     * Check if video is currently streaming and visible\n+     *\n+     * @return boolean (true = yes, false = no)\n+     */\n+    public boolean isStreaming() {\n+        return (stateMachine.getState() == StreamingStateMachine.STARTED) && (isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Check if video streaming has been paused due to app moving to background or manually stopped\n+     *\n+     * @return boolean (true = not paused, false = paused)\n+     */\n+    public boolean isPaused() {\n+        return (hasStarted && stateMachine.getState() == StreamingStateMachine.STOPPED) || (!isHMIStateVideoStreamCapable(currentOnHMIStatus));\n+    }\n+\n+    /**\n+     * Gets the current video streaming state as defined in @StreamingStateMachine\n+     *\n+     * @return int representing StreamingStateMachine.StreamingState\n+     */\n+    public @StreamingStateMachine.StreamingState\n+    int currentVideoStreamState() {\n+        return stateMachine.getState();\n+    }\n+\n+    // HELPER METHODS\n+\n+    private void createRemoteDisplay(final Display disp) {\n+        try {\n+            if (disp == null) {\n+                return;\n+            }\n+\n+            // Dismiss the current presentation if the display has changed.\n+            if (sdlRemoteDisplay != null && sdlRemoteDisplay.getDisplay() != disp) {\n+                sdlRemoteDisplay.dismissPresentation();\n+            }\n+\n+            FutureTask<Boolean> fTask = new FutureTask<>(new SdlRemoteDisplay.Creator(context.get(), disp, sdlRemoteDisplay, remoteDisplayClass, new SdlRemoteDisplay.Callback() {\n+                @Override\n+                public void onCreated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Remote display has been created.\n+                    //Now is a good time to do parsing for spatial data\n+                    VideoStreamManager.this.sdlRemoteDisplay = remoteDisplay;\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                    //Get touch scalars\n+                    ImageResolution resolution = null;\n+                    if (internalInterface.getProtocolVersion().getMajor() >= 5) { //At this point we should already have the capability\n+                        VideoStreamingCapability capability = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            capability = (VideoStreamingCapability) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, null, false);\n+                        }\n+                        if (capability != null) {\n+                            resolution = capability.getPreferredResolution();\n+                        }\n+                    }\n+\n+                    if (resolution == null) { //Either the protocol version is too low to access video streaming caps, or they were null\n+                        DisplayCapabilities dispCap = null;\n+                        if (internalInterface.getSystemCapabilityManager() != null) {\n+                            dispCap = (DisplayCapabilities) internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.DISPLAY, null, false);\n+                        }\n+                        if (dispCap != null) {\n+                            resolution = (dispCap.getScreenParams().getImageResolution());\n+                        }\n+                    }\n+\n+                    if (resolution != null) {\n+                        DisplayMetrics displayMetrics = new DisplayMetrics();\n+                        disp.getMetrics(displayMetrics);\n+                        createTouchScalar(resolution, displayMetrics);\n                     }\n \n-\t\t\t\t\tsdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n-\t\t\t\t}\n-\n-\t\t\t\t@Override\n-\t\t\t\tpublic void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n-\t\t\t\t\t//Our view has been invalidated\n-\t\t\t\t\t//A good time to refresh spatial data\n-\t\t\t\t\tDisplayMetrics displayMetrics = new DisplayMetrics();\n-\t\t\t\t\tsdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n-\t\t\t\t\tdisplayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n-\t\t\t\t\tdisplayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n-\t\t\t\t\tcreateTouchScalar(parameters.getResolution(), displayMetrics);\n-\t\t\t\t\tif(hapticManager != null) {\n-\t\t\t\t\t\tremoteDisplay.getMainView().post(new Runnable() {\n-\t\t\t\t\t\t\t@Override\n-\t\t\t\t\t\t\tpublic void run() {\n-\t\t\t\t\t\t\t\thapticManager.refreshHapticData(remoteDisplay.getMainView());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} ));\n-\t\t\tThread showPresentation = new Thread(fTask);\n-\t\t\tshowPresentation.setName(\"RmtDispThread\");\n-\n-\t\t\tshowPresentation.start();\n-\t\t} catch (Exception ex) {\n-\t\t\tDebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n-\t\t\tif(DebugTool.isDebugEnabled()){\n-\t\t\t\tex.printStackTrace();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail){\n-\n-\t\tisTransportAvailable = videoStreamTransportAvail;\n-\n-\t\tif(internalInterface.getProtocolVersion().isNewerThan(new Version(5,1,0)) >= 0){\n-\t\t\tif(videoStreamTransportAvail){\n-\t\t\t\tcheckState();\n-\t\t\t}\n-\t\t}else{\n-\t\t\t//The protocol version doesn't support simultaneous transports.\n-\t\t\tif(!videoStreamTransportAvail){\n-\t\t\t\t//If video streaming isn't available on primary transport then it is not possible to\n-\t\t\t\t//use the video streaming manager until a complete register on a transport that\n-\t\t\t\t//supports video\n-\t\t\t\ttransitionToState(ERROR);\n-\t\t\t}\n-\t\t}\n-\t}\n+                sdlRemoteDisplay.resizeView(parameters.getResolution().getResolutionWidth(), parameters.getResolution().getResolutionHeight());\n+                }\n+\n+                @Override\n+                public void onInvalidated(final SdlRemoteDisplay remoteDisplay) {\n+                    //Our view has been invalidated\n+                    //A good time to refresh spatial data\n+                    DisplayMetrics displayMetrics = new DisplayMetrics();\n+                    sdlRemoteDisplay.getDisplay().getMetrics(displayMetrics);\n+                    displayMetrics.widthPixels =  (int) (parameters.getResolution().getResolutionWidth() * parameters.getScale());\n+                    displayMetrics.heightPixels =  (int) (parameters.getResolution().getResolutionHeight() * parameters.getScale());\n+                    createTouchScalar(parameters.getResolution(), displayMetrics);\n+                    if (hapticManager != null) {\n+                        remoteDisplay.getMainView().post(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                hapticManager.refreshHapticData(remoteDisplay.getMainView());\n+                            }\n+                        });\n+                    }\n+                }\n+            }));\n+            Thread showPresentation = new Thread(fTask);\n+            showPresentation.setName(\"RmtDispThread\");\n+\n+            showPresentation.start();\n+        } catch (Exception ex) {\n+            DebugTool.logError(TAG, \"Unable to create Virtual Display.\");\n+            if (DebugTool.isDebugEnabled()) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void onTransportUpdate(List<TransportRecord> connectedTransports, boolean audioStreamTransportAvail, boolean videoStreamTransportAvail) {\n+\n+        isTransportAvailable = videoStreamTransportAvail;\n+\n+        if (internalInterface.getProtocolVersion().isNewerThan(new Version(5, 1, 0)) >= 0) {\n+            if (videoStreamTransportAvail) {\n+                checkState();\n+            }\n+        } else {\n+            //The protocol version doesn't support simultaneous transports.\n+            if (!videoStreamTransportAvail) {\n+                //If video streaming isn't available on primary transport then it is not possible to\n+                //use the video streaming manager until a complete register on a transport that\n+                //supports video\n+                transitionToState(ERROR);\n+            }\n+        }\n+    }\n \n     void createTouchScalar(ImageResolution resolution, DisplayMetrics displayMetrics) {\n-        touchScalar[0] = ((float)displayMetrics.widthPixels) / resolution.getResolutionWidth();\n-        touchScalar[1] = ((float)displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+        touchScalar[0] = ((float) displayMetrics.widthPixels) / resolution.getResolutionWidth();\n+        touchScalar[1] = ((float) displayMetrics.heightPixels) / resolution.getResolutionHeight();\n+    }\n+\n+    List<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent) {\n+        List<MotionEvent> motionEventList = new ArrayList<>();\n+\n+        List<TouchEvent> touchEventList = onTouchEvent.getEvent();\n+        if (touchEventList == null || touchEventList.size() == 0) return null;\n+\n+        TouchType touchType = onTouchEvent.getType();\n+        if (touchType == null) {\n+            return null;\n+        }\n+\n+        if (sdlMotionEvent == null) {\n+            if (touchType == TouchType.BEGIN) {\n+                sdlMotionEvent = new SdlMotionEvent();\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        SdlMotionEvent.Pointer pointer;\n+        MotionEvent motionEvent;\n+\n+        for (TouchEvent touchEvent : touchEventList) {\n+            if (touchEvent == null || touchEvent.getId() == null) {\n+                continue;\n+            }\n+\n+            List<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n+            if (touchCoordList == null || touchCoordList.size() == 0) {\n+                continue;\n+            }\n+\n+            TouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n+            if (touchCoord == null) {\n+                continue;\n+            }\n+\n+            int motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n+            long downTime = sdlMotionEvent.downTime;\n+            long eventTime = sdlMotionEvent.eventTime;\n+            pointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n+            if (pointer != null) {\n+                pointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n+            }\n+\n+            MotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n+            MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n+\n+            for (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n+                pointerProperties[i] = new MotionEvent.PointerProperties();\n+                pointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n+                pointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n+\n+                pointerCoords[i] = new MotionEvent.PointerCoords();\n+                pointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n+                pointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n+                pointerCoords[i].orientation = 0;\n+                pointerCoords[i].pressure = 1.0f;\n+                pointerCoords[i].size = 1;\n+            }\n+\n+            motionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n+                    sdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n+                    1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n+            motionEventList.add(motionEvent);\n+\n+            if (motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL) {\n+                //If the motion event should be finished we should clear our reference\n+                sdlMotionEvent.pointers.clear();\n+                sdlMotionEvent = null;\n+                break;\n+            } else if ((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP) {\n+                sdlMotionEvent.removePointerById(touchEvent.getId());\n+            }\n+        }\n+\n+        return motionEventList;\n+    }\n+\n+    public VideoStreamingParameters getLastCachedStreamingParameters() {\n+        return parameters;\n+    }\n+\n+    private List<VideoStreamingCapability> getSupportedCapabilities(\n+            List<VideoStreamingRange> ranges,\n+            List<VideoStreamingCapability> originalAdditionalCapabilities\n+    ){\n+\n+        List<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n+\n+        VideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n+        preferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n+        preferredCapability.setPreferredResolution(new ImageResolution(\n+                parameters.getResolution().getResolutionWidth(),\n+                parameters.getResolution().getResolutionHeight())\n+        );\n+\n+        // get the first one - the Desired resolution to guarantee streaming will start\n+        validCapabilities.add(preferredCapability);\n+        for (VideoStreamingRange range: ranges) {\n+\n+            Integer constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n+            Integer constraintHeightMin = range.getMinResolution().getResolutionHeight();\n+\n+            for (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n+                double diagonal;\n+                if (capability.getPreferredResolution() == null\n+                        || capability.getPreferredResolution().getResolutionHeight() == null\n+                        || capability.getPreferredResolution().getResolutionWidth() == null) {\n+                    continue;\n+                }\n+                if (capability.getDiagonalScreenSize() == null) {\n+                    diagonal = parameters.getPreferredDiagonal();\n+                } else {\n+                    diagonal = capability.getDiagonalScreenSize();\n+                }\n+\n+                if (range.getMinScreenDiagonal() > diagonal) {\n+                    continue;\n+                }\n+\n+                if (!isAspectRatioInRange(range.getAspectRatio(), capability.getPreferredResolution())) {\n+                    if (constraintHeightMax == null && constraintHeightMin == null) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (!isImageResolutionInRange(range.getMinResolution(), range.getMaxResolution(), capability.getPreferredResolution())) {\n+                    continue;\n+                }\n+\n+                validCapabilities.add(capability);\n+            }\n+        }\n+\n+        return validCapabilities;\n     }\n \n-\tList<MotionEvent> convertTouchEvent(OnTouchEvent onTouchEvent){\n-\t\tList<MotionEvent> motionEventList = new ArrayList<MotionEvent>();\n-\n-\t\tList<TouchEvent> touchEventList = onTouchEvent.getEvent();\n-\t\tif (touchEventList == null || touchEventList.size() == 0) return null;\n-\n-\t\tTouchType touchType = onTouchEvent.getType();\n-\t\tif (touchType == null) { return null; }\n-\n-\t\tif(sdlMotionEvent == null) {\n-\t\t\tif (touchType == TouchType.BEGIN) {\n-\t\t\t\tsdlMotionEvent = new SdlMotionEvent();\n-\t\t\t} else{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tSdlMotionEvent.Pointer pointer;\n-\t\tMotionEvent motionEvent;\n-\n-\t\tfor (TouchEvent touchEvent : touchEventList) {\n-\t\t\tif (touchEvent == null || touchEvent.getId() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tList<TouchCoord> touchCoordList = touchEvent.getTouchCoordinates();\n-\t\t\tif (touchCoordList == null || touchCoordList.size() == 0) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tTouchCoord touchCoord = touchCoordList.get(touchCoordList.size() - 1);\n-\t\t\tif (touchCoord == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tint motionEventAction = sdlMotionEvent.getMotionEventAction(touchType, touchEvent);\n-\t\t\tlong downTime = sdlMotionEvent.downTime;\n-\t\t\tlong eventTime = sdlMotionEvent.eventTime;\n-\t\t\tpointer = sdlMotionEvent.getPointerById(touchEvent.getId());\n-\t\t\tif (pointer != null) {\n-\t\t\t\tpointer.setCoords(touchCoord.getX() / touchScalar[0], touchCoord.getY() / touchScalar[1]);\n-\t\t\t}\n-\n-\t\t\tMotionEvent.PointerProperties[] pointerProperties = new MotionEvent.PointerProperties[sdlMotionEvent.pointers.size()];\n-\t\t\tMotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[sdlMotionEvent.pointers.size()];\n-\n-\t\t\tfor (int i = 0; i < sdlMotionEvent.pointers.size(); i++) {\n-\t\t\t\tpointerProperties[i] = new MotionEvent.PointerProperties();\n-\t\t\t\tpointerProperties[i].id = sdlMotionEvent.getPointerByIndex(i).id;\n-\t\t\t\tpointerProperties[i].toolType = MotionEvent.TOOL_TYPE_FINGER;\n-\n-\t\t\t\tpointerCoords[i] = new MotionEvent.PointerCoords();\n-\t\t\t\tpointerCoords[i].x = sdlMotionEvent.getPointerByIndex(i).x;\n-\t\t\t\tpointerCoords[i].y = sdlMotionEvent.getPointerByIndex(i).y;\n-\t\t\t\tpointerCoords[i].orientation = 0;\n-\t\t\t\tpointerCoords[i].pressure = 1.0f;\n-\t\t\t\tpointerCoords[i].size = 1;\n-\t\t\t}\n-\n-\t\t\tmotionEvent = MotionEvent.obtain(downTime, eventTime, motionEventAction,\n-\t\t\t\t\tsdlMotionEvent.pointers.size(), pointerProperties, pointerCoords, 0, 0, 1,\n-\t\t\t\t\t1, 0, 0, InputDevice.SOURCE_TOUCHSCREEN, 0);\n-\t\t\tmotionEventList.add(motionEvent);\n-\n-\t\t\tif(motionEventAction == MotionEvent.ACTION_UP || motionEventAction == MotionEvent.ACTION_CANCEL){\n-\t\t\t\t//If the motion event should be finished we should clear our reference\n-\t\t\t\tsdlMotionEvent.pointers.clear();\n-\t\t\t\tsdlMotionEvent = null;\n-\t\t\t\tbreak;\n-\t\t\t} else if((motionEventAction & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP){\n-\t\t\t\tsdlMotionEvent.removePointerById(touchEvent.getId());\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn motionEventList;\n-\t}\n-\n-\tpublic VideoStreamingParameters getLastCachedStreamingParameters() {\n-\t\treturn parameters;\n-\t}\n-\n-\tpublic boolean getLastCachedIsEncrypted() {\n-\t\treturn isEncrypted;\n-\t}\n-\n-\tprivate List<VideoStreamingCapability> getSupportedCapabilities(\n-\t\t\tResolution minResolution,\n-\t\t\tResolution maxResolution,\n-\t\t\tDouble minScreenDiagonal,\n-\t\t\tDouble minAspectRatio,\n-\t\t\tDouble maxAspectRatio,\n-\t\t\tList<VideoStreamingCapability> originalAdditionalCapabilities\n-\t){\n-\t\tInteger constraintHeightMax = maxResolution.getResolutionHeight();\n-\t\tInteger constraintHeightMin = minResolution.getResolutionHeight();\n-\n-\t\tList<VideoStreamingCapability> validCapabilities = new ArrayList<>();\n-\n-\t\tVideoStreamingCapability preferredCapability = new VideoStreamingCapability();\n-\t\tpreferredCapability.setDiagonalScreenSize(parameters.getPreferredDiagonal());\n-\t\tpreferredCapability.setPreferredResolution(new ImageResolution(\n-\t\t\t\tparameters.getResolution().getResolutionWidth(),\n-\t\t\t\tparameters.getResolution().getResolutionHeight())\n-\t\t);\n-\n-\t\t// get the first one - the Desired resolution to guarantee streaming will start\n-\t\tvalidCapabilities.add(preferredCapability);\n-\n-\t\tfor (VideoStreamingCapability capability : originalAdditionalCapabilities) {\n-\t\t\tdouble diagonal;\n-\t\t\tif (capability.getPreferredResolution() == null\n-\t\t\t\t\t|| capability.getPreferredResolution().getResolutionHeight() == null\n-\t\t\t\t\t|| capability.getPreferredResolution().getResolutionWidth() == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tif (capability.getDiagonalScreenSize() == null ) {\n-\t\t\t\tdiagonal = parameters.getPreferredDiagonal();\n-\t\t\t} else {\n-\t\t\t\tdiagonal = capability.getDiagonalScreenSize();\n-\t\t\t}\n-\n-\t\t\tif (minScreenDiagonal > diagonal) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tif (!isAspectRatioInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tif (constraintHeightMax == null && constraintHeightMin == null) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tif (!isImageResolutionInRange(streamingRange, capability.getPreferredResolution())) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\tvalidCapabilities.add(capability);\n-\t\t}\n-\n-\t\treturn validCapabilities;\n-\t}\n-\n-\tpublic Boolean isImageResolutionInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\n-\t\tInteger constraintHeightMax = range.getMaxResolution().getResolutionHeight();\n-\t\tInteger constraintHeightMin = range.getMinResolution().getResolutionHeight();\n-\t\tInteger constraintWidthMax = range.getMaxResolution().getResolutionWidth();\n-\t\tInteger constraintWidthMin = range.getMinResolution().getResolutionWidth();\n-\t\tInteger resolutionHeight = currentResolution.getResolutionHeight();\n-\t\tInteger resolutionWidth = currentResolution.getResolutionWidth();\n-\t\tif (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null)\n-\t\t{\n-\t\t\tif (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\n-\t\t\tif (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// TODO check what if dev provided invalid constraints\n-\t\treturn true;\n-\t}\n-\n-\tpublic Boolean isAspectRatioInRange(VideoStreamingRange range, ImageResolution currentResolution) {\n-\t\tDouble aspectRatioMin = range.getMinAspectRatio();\n-\t\tDouble aspectRatioMax = range.getMaxAspectRatio();\n-\n-\t\tDouble currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n-\n-\t\tif (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n-\t\t\tif (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\t// TODO check what if dev provided invalid constraints\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * Keeps track of the current motion event for VPM\n-\t */\n-\tprivate static class SdlMotionEvent {\n-\t\tclass Pointer {\n-\t\t\tint id;\n-\t\t\tfloat x;\n-\t\t\tfloat y;\n-\t\t\tPointer (int id) {\n-\t\t\t\tthis.id = id;\n-\t\t\t\tthis.x = 0.0f;\n-\t\t\t\tthis.y = 0.0f;\n-\t\t\t}\n-\t\t\tvoid setCoords(float x, float y) {\n-\t\t\t\tthis.x = x;\n-\t\t\t\tthis.y = y;\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n-\t\tprivate long downTime;\n-\t\tprivate long downTimeOnHMI;\n-\t\tprivate long eventTime;\n-\n-\t\tSdlMotionEvent(){\n-\t\t\tdownTimeOnHMI = 0;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n-\t\t * Android MotionEvent according to this events status\n-\t\t * @param touchType The SDL TouchType that was received from the module\n-\t\t * @param touchEvent The SDL TouchEvent that was received from the module\n-\t\t * @return the correct native Android MotionEvent action to dispatch\n-\t\t */\n-\t\tsynchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent){\n-\t\t\teventTime = 0;\n-\t\t\tint motionEventAction = -1;\n-\t\t\tswitch (touchType){\n-\t\t\t\tcase BEGIN:\n-\t\t\t\t\tif(pointers.size() == 0){\n-\t\t\t\t\t\t//The motion event has just begun\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_DOWN;\n-\t\t\t\t\t\tdownTime = SystemClock.uptimeMillis();\n-\t\t\t\t\t\tdownTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n-\t\t\t\t\t\teventTime = downTime;\n-\t\t\t\t\t} else{\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\t}\n-\t\t\t\t\tpointers.add(new Pointer(touchEvent.getId()));\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase MOVE:\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_MOVE;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase END:\n-\t\t\t\t\tif(pointers.size() <= 1){\n-\t\t\t\t\t\t//The motion event has just ended\n-\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tint pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n-\t\t\t\t\t\tif (pointerIndex != -1) {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_UP;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase CANCEL:\n-\t\t\t\t\t//Assuming this cancels the entire event\n-\t\t\t\t\tmotionEventAction = MotionEvent.ACTION_CANCEL;\n-\t\t\t\t\teventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\treturn motionEventAction;\n-\t\t}\n-\n-\t\tPointer getPointerById(int id){\n-\t\t\tif (pointers != null && !pointers.isEmpty()){\n-\t\t\t\tfor (Pointer pointer : pointers){\n-\t\t\t\t\tif (pointer.id == id){\n-\t\t\t\t\t\treturn pointer;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tPointer getPointerByIndex(int index){\n-\t\t\treturn pointers.get(index);\n-\t\t}\n-\n-\t\tvoid removePointerById(int id){\n-\t\t\tpointers.remove(getPointerById(id));\n-\t\t}\n-\t}\n+    public Boolean isImageResolutionInRange(Resolution minResolution, Resolution maxResolution, ImageResolution currentResolution) {\n+\n+        Integer constraintHeightMax = maxResolution.getResolutionHeight();\n+        Integer constraintHeightMin = minResolution.getResolutionHeight();\n+        Integer constraintWidthMax = maxResolution.getResolutionWidth();\n+        Integer constraintWidthMin = minResolution.getResolutionWidth();\n+        Integer resolutionHeight = currentResolution.getResolutionHeight();\n+        Integer resolutionWidth = currentResolution.getResolutionWidth();\n+        if (currentResolution.getResolutionHeight() > 0 && currentResolution.getResolutionWidth() > 0 && constraintHeightMax != null && constraintHeightMin != null) {\n+            if (!(resolutionHeight >= constraintHeightMin && resolutionHeight <= constraintHeightMax)) {\n+                return false;\n+            }\n+\n+            if (!(resolutionWidth >= constraintWidthMin && resolutionWidth <= constraintWidthMax)) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO check what if dev provided invalid constraints\n+        return true;\n+    }\n+\n+    public Boolean isAspectRatioInRange(AspectRatio aspectRatio, ImageResolution currentResolution) {\n+        Double aspectRatioMin = aspectRatio.getMinAspectRatio();\n+        Double aspectRatioMax = aspectRatio.getMaxAspectRatio();\n+\n+        Double currentAspectRatio = Double.valueOf(currentResolution.getResolutionWidth()) / Double.valueOf(currentResolution.getResolutionHeight());\n+\n+        if (!(aspectRatioMax > aspectRatioMin && aspectRatioMin > 0)) {\n+            if (!(currentAspectRatio >= aspectRatioMin && currentAspectRatio <= aspectRatioMax)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Keeps track of the current motion event for VPM\n+     */\n+    private static class SdlMotionEvent {\n+        class Pointer {\n+            final int id;\n+            float x;\n+            float y;\n+\n+            Pointer(int id) {\n+                this.id = id;\n+                this.x = 0.0f;\n+                this.y = 0.0f;\n+            }\n+\n+            void setCoords(float x, float y) {\n+                this.x = x;\n+                this.y = y;\n+            }\n+        }\n+\n+        private final CopyOnWriteArrayList<Pointer> pointers = new CopyOnWriteArrayList<>();\n+        private long downTime;\n+        private long downTimeOnHMI;\n+        private long eventTime;\n+\n+        SdlMotionEvent() {\n+            downTimeOnHMI = 0;\n+        }\n+\n+        /**\n+         * Handles the SDL Touch Event to keep track of pointer status and returns the appropriate\n+         * Android MotionEvent according to this events status\n+         *\n+         * @param touchType  The SDL TouchType that was received from the module\n+         * @param touchEvent The SDL TouchEvent that was received from the module\n+         * @return the correct native Android MotionEvent action to dispatch\n+         */\n+        synchronized int getMotionEventAction(TouchType touchType, TouchEvent touchEvent) {\n+            eventTime = 0;\n+            int motionEventAction = -1;\n+            switch (touchType) {\n+                case BEGIN:\n+                    if (pointers.size() == 0) {\n+                        //The motion event has just begun\n+                        motionEventAction = MotionEvent.ACTION_DOWN;\n+                        downTime = SystemClock.uptimeMillis();\n+                        downTimeOnHMI = touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1);\n+                        eventTime = downTime;\n+                    } else {\n+                        motionEventAction = MotionEvent.ACTION_POINTER_DOWN | pointers.size() << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    }\n+                    pointers.add(new Pointer(touchEvent.getId()));\n+                    break;\n+                case MOVE:\n+                    motionEventAction = MotionEvent.ACTION_MOVE;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case END:\n+                    if (pointers.size() <= 1) {\n+                        //The motion event has just ended\n+                        motionEventAction = MotionEvent.ACTION_UP;\n+                    } else {\n+                        int pointerIndex = pointers.indexOf(getPointerById(touchEvent.getId()));\n+                        if (pointerIndex != -1) {\n+                            motionEventAction = MotionEvent.ACTION_POINTER_UP | pointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT;\n+                        } else {\n+                            motionEventAction = MotionEvent.ACTION_UP;\n+                        }\n+                    }\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                case CANCEL:\n+                    //Assuming this cancels the entire event\n+                    motionEventAction = MotionEvent.ACTION_CANCEL;\n+                    eventTime = downTime + touchEvent.getTimestamps().get(touchEvent.getTimestamps().size() - 1) - downTimeOnHMI;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            return motionEventAction;\n+        }\n+\n+        Pointer getPointerById(int id) {\n+            if (pointers != null && !pointers.isEmpty()) {\n+                for (Pointer pointer : pointers) {\n+                    if (pointer.id == id) {\n+                        return pointer;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        Pointer getPointerByIndex(int index) {\n+            return pointers.get(index);\n+        }\n+\n+        void removePointerById(int id) {\n+            pointers.remove(getPointerById(id));\n+        }\n+    }\n+\n+    private VideoStreamingProtocol getAcceptedProtocol(VideoStreamingParameters params) {\n+        if (params != null) {\n+            VideoStreamingFormat format = params.getFormat();\n+            if (format != null && format.getProtocol() != null) {\n+                return format.getProtocol();\n+            }\n+        }\n+        //Returns default protocol if none are found\n+        return new VideoStreamingParameters().getFormat().getProtocol();\n+\n+    }\n+\n+    protected IVideoStreamListener startVideoStream(VideoStreamingParameters params, final SdlSession session) {\n+        VideoStreamingProtocol protocol = getAcceptedProtocol(params);\n+\n+        IStreamListener iStreamListener = new IStreamListener() {\n+            @Override\n+            public void sendStreamPacket(ProtocolMessage pm) {\n+                session.sendMessage(pm);\n+            }\n+        };\n+\n+        try {\n+            switch (protocol) {\n+                case RAW: {\n+                    videoPacketizer = new StreamPacketizer(iStreamListener, null, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                case RTP: {\n+                    //FIXME why is this not an extension of StreamPacketizer?\n+                    videoPacketizer = new RTPH264Packetizer(iStreamListener, SessionType.NAV, (byte) session.getSessionId(), session);\n+                    videoPacketizer.start();\n+                    return (IVideoStreamListener) videoPacketizer;\n+                }\n+                default:\n+                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\n+                    return null;\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    protected boolean stopVideoStream() {\n+        if (videoPacketizer != null) {\n+            videoPacketizer.stop();\n+            return true;\n+        }\n+        return false;\n+    }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwNzQ0Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r475007443", "bodyText": "@kostyaBoss On line 12 you can replace @since 7.0 with @since SmartDeviceLink 7.0", "author": "santhanamk", "createdAt": "2020-08-21T23:18:46Z", "path": "base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.smartdevicelink.proxy.rpc;\n+\n+\n+import androidx.annotation.NonNull;\n+\n+import com.smartdevicelink.proxy.RPCStruct;\n+import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n+\n+import java.util.Hashtable;\n+\n+/**\n+ * @since 7.0", "originalCommit": "09efe463a0068e98e98580c794c2710313dcfa46", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\nindex 4ad1705cf..31f33125d 100644\n--- a/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n+++ b/base/src/main/java/com/smartdevicelink/proxy/rpc/AppCapability.java\n\n@@ -9,7 +9,7 @@ import com.smartdevicelink.proxy.rpc.enums.AppCapabilityType;\n import java.util.Hashtable;\n \n /**\n- * @since 7.0\n+ * @since SmartDeviceLink 7.0\n  */\n public class AppCapability extends RPCStruct {\n     public static final String KEY_APP_CAPABILITY_TYPE = \"appCapabilityType\";\n"}}, {"oid": "bdc46d2f4b5f5fc57cd47bde1da7e7fed6aea0c5", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/bdc46d2f4b5f5fc57cd47bde1da7e7fed6aea0c5", "message": "[VideoStreaming]\n     - Rollback aspect ratio\n     - Fix method naming", "committedDate": "2020-08-26T07:57:09Z", "type": "commit"}, {"oid": "be305793d96b955350d38897e95da099ba49997f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/be305793d96b955350d38897e95da099ba49997f", "message": "[VideoStreaming]\n     - Extract strings\n     - Fix naming in tests", "committedDate": "2020-08-26T08:01:29Z", "type": "commit"}, {"oid": "c6c9a1892855a84d15f968e5ea43868c2c3b3626", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c6c9a1892855a84d15f968e5ea43868c2c3b3626", "message": "[VideoStreaming]\n     - Fix id's in xml\n     - Fix tests\n     - Add javadoc to AppCapability.java\n     - Refactor imports", "committedDate": "2020-08-26T08:56:44Z", "type": "commit"}, {"oid": "eb085c052a2f54522ecb8033b1cce995bf4429b3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/eb085c052a2f54522ecb8033b1cce995bf4429b3", "message": "[VideoStreaming]\n     - Rollback original commented code", "committedDate": "2020-08-26T08:58:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1NTgwOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r477455809", "bodyText": "@kostyaBoss you can delete line 911.  It is the same as line 910.", "author": "santhanamk", "createdAt": "2020-08-26T17:07:42Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java", "diffHunk": "@@ -897,11 +903,23 @@ public void onVoiceCommandSelected() {\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n \n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);", "originalCommit": "eb085c052a2f54522ecb8033b1cce995bf4429b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDc3Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r478370776", "bodyText": "@santhanamk this is used to simulate multiple values in the list", "author": "kboskin", "createdAt": "2020-08-27T12:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1NTgwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\nindex 8cdce8463..7b3f5dc70 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n\n@@ -890,510 +905,516 @@ public class TestValues {\n         GENERAL_PERMISSIONITEM.setRequireEncryption(GENERAL_BOOLEAN);\n         GENERAL_PERMISSIONITEM_LIST.add(GENERAL_PERMISSIONITEM);\n \n-\t\tGENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n-\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n-\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\t\tGENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n-\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n-\t\tGENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n-\t\tGENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n-\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n-\t\tGENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n-\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\t\tGENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n-\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n-\t\tGENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n-\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n-\t\tGENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n-\t\tGENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n-\n-\t\tGENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n-\n-\t\tGENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n-\t\tGENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n-\t\tGENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n-\t\tGENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n-\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n-\t\tGENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n-\n-\t\tGENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n-\t\tGENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n-\n-\t\tList<MetadataType> exampleList = new ArrayList<>();\n-\t\texampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n-\t\texampleList.add(1, MetadataType.MEDIA_ALBUM);\n-\t\texampleList.add(2, MetadataType.MEDIA_ARTIST);\n-\n-\t\tGENERAL_METADATASTRUCT.setMainField1(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField2(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField3(exampleList);\n-\t\tGENERAL_METADATASTRUCT.setMainField4(exampleList);\n-\n-\t\tGENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n-\t\tGENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n-\n-\t\tGENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n-\t\tGENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n-\n-\t\tGENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n-\t\tGENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n-\n-\t\tGENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n-\t\tGENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n-\n-\t\tGENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n-\t\tGENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n-\t\tGENERAL_LOCKSCREENCONFIG.setEnabled(true);\n-\t\tGENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n-\t\tGENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n-\t\tGENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n-\t\tGENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n-\t\tGENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n-\n-\t\tGENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n-\t\tGENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n-\t\tGENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n-\t\tGENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n-\n-\t\tGENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n-\n-\t\tGENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n-\t\tGENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n-\n-\t\tGENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n-\t\tGENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n-\t\tGENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n-\t\tGENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n-\t\tGENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n-\n-\t\tGENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n-\t\tGENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n-\t\tGENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n-\t\tGENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n-\n-\t\tGENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n-\t\tGENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n-\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n-\t\tGENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n-\t\tGENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n-\n-\t\tGENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n-\t\tGENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n-\t\tGENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n-\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n-\t\tGENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n-\t\tGENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n-\t\tGENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n-\t\tGENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n-\n-\t\tGENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n-\t\tGENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n-\n-\t\tGENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n-\t\tGENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n-\n-\t\ttry {\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n-\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tJSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n-\t\t\tJSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n-\n-\t\t\tJSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n-\t\t\tJSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n-\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_FULL);\n-\t\t\tJSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n-\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n-\t\t\tJSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n-\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n-\t\t\tJSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n-\t\t\tJSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n-\n-\t\t\tJSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n-\t\t\tJSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n-\t\t\tJSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED , GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n-\t\t\tJSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n-\n-\t\t\tJSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n-\t\t\tJSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n-\t\t\tJSON_TURNS.put(JSON_TURN);\n-\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n-\t\t\tJSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n-\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n-\t    \tJSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n-\t    \tJSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n-\n-\t    \tJSONObject jsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\t    \tjsonTtsChunk = new JSONObject();\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n-\t    \tjsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n-\t    \tJSON_TTSCHUNKS.put(jsonTtsChunk);\n-\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n-\t    \tJSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n-\t\t\tJSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n-\n-\t\t\tJSON_CHOICES.put(JSON_CHOICE);\n-\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n-\t\t\tJSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n-\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n-\t\t\tJSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n-\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n-\t\t\tJSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n-\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n-\t\t\tJSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n-\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n-\t\t\tJSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n-\t\t\tJSON_DIDRESULTS.put(JSON_DIDRESULT);\n-\n-\t\t\tJSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSONObject jsonButton = new JSONObject();\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n-\t\t\tJSON_BUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSONObject jsonRadioControlCapabilities = new JSONObject();\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tJSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n-\n-\t\t\tJSONObject jsonClimateControlCapabilities = new JSONObject();\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n-\t\t\tJSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n-\n-\t\t\tjsonButton = new JSONObject();\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n-\t\t\tjsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n-\t\t\tJSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n-\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n-\t\t\tJSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n-\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n-\t\t\tJSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n-\t\t\tJSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n-\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n-\t\t\tJSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n-\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n-\t\t\tJSON_IMAGE_TYPES.put(ImageType.STATIC);\n-\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n-\t\t\tJSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n-\n-\t\t\tJSONObject jsonTEC = new JSONObject();\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n-\t\t\tjsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n-\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n-\t\t\tJSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n-\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n-\t\t\tJSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n-\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n-\t\t\tJSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n-\t\t\tJSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n-\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n-\t\t\tJSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n-\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n-\t\t\tJSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n-\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n-\t\t\tJSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n-\t\t\tJSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n-\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n-\t\t\tJSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n-\n-\t\t\tJSON_SEAT_LOCATIONS.put(JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n-\t\t\tJSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n-\n-\n-\t\t} catch (JSONException e) {\n-\t\t\tLog.e(\"Test\", \"Static Json Construction Failed.\", e);\n-\t\t}\n-\t}\n+        GENERAL_SYSTEMCAPABILITY.setSystemCapabilityType(GENERAL_SYSTEMCAPABILITYTYPE);\n+\n+        GENERAL_NAVIGATIONCAPABILITY.setSendLocationEnabled(GENERAL_BOOLEAN);\n+        GENERAL_NAVIGATIONCAPABILITY.setWayPointsEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_PHONECAPABILITY.setDialNumberEnabled(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT.setProtocol(GENERAL_VIDEOSTREAMINGPROTOCOL);\n+        GENERAL_VIDEOSTREAMINGFORMAT.setCodec(GENERAL_VIDEOSTREAMINGCODEC);\n+\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+        GENERAL_VIDEOSTREAMINGFORMAT_LIST.add(GENERAL_VIDEOSTREAMINGFORMAT);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_ADDITIONAL_CAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setScale(GENERAL_DOUBLE);\n+\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+        GENERAL_ADDITIONAL_CAPABILITY_LIST.add(GENERAL_ADDITIONAL_CAPABILITY);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setMaxBitrate(GENERAL_INT);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPreferredResolution(GENERAL_IMAGERESOLUTION);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setSupportedFormats(GENERAL_VIDEOSTREAMINGFORMAT_LIST);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setIsHapticSpatialDataSupported(GENERAL_BOOLEAN);\n+\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setDiagonalScreenSize(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setPixelPerInch(GENERAL_DOUBLE);\n+        GENERAL_VIDEOSTREAMINGCAPABILITY.setScale(GENERAL_DOUBLE);\n+        GENERAL_ADDITIONAL_CAPABILITY.setAdditionalVideoStreamingCapabilities(GENERAL_ADDITIONAL_CAPABILITY_LIST);\n+\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setFanSpeedAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDesiredTemperatureAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAcMaxEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setCirculateAirEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setAutoModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDualModeEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZoneAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setDefrostZone(GENERAL_DEFROSTZONE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_CLIMATECONTROLCAPABILITIES.setVentilationMode(GENERAL_VENTILATIONMODE_LIST);\n+        GENERAL_CLIMATECONTROLCAPABILITIES_LIST.add(GENERAL_CLIMATECONTROLCAPABILITIES);\n+\n+        GENERAL_RADIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioEnableAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioBandAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRadioFrequencyAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setHdChannelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setRdsDataAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setAvailableHDsAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setStateAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalStrengthAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES.setSignalChangeThresholdAvailable(GENERAL_BOOLEAN);\n+        GENERAL_RADIOCONTROLCAPABILITIES_LIST.add(GENERAL_RADIOCONTROLCAPABILITIES);\n+\n+        GENERAL_SEATCONTROLCAPABILITIES.setMemoryAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageCushionFirmnessAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageModeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setMassageEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeadSupportHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackTiltAngleAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setBackVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setFrontVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setVerticalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHorizontalPositionAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingLevelAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setCoolingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setHeatingEnabledAvailable(GENERAL_BOOLEAN);\n+        GENERAL_SEATCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_SEATCONTROLCAPABILITIES_LIST.add(GENERAL_SEATCONTROLCAPABILITIES);\n+\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerMaxChannelId(GENERAL_INT);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setEqualizerAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setVolumeAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setSourceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setKeepContextAvailable(GENERAL_BOOLEAN);\n+        GENERAL_AUDIOCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+        GENERAL_AUDIOCONTROLCAPABILITIES_LIST.add(GENERAL_AUDIOCONTROLCAPABILITIES);\n+\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDisplayModeUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setDistanceUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setTemperatureUnitAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMISETTINGSCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setSupportedLights(GENERAL_LIGHTCAPABILITIES_LIST);\n+        GENERAL_LIGHTCONTROLCAPABILITIES.setModuleName(GENERAL_STRING);\n+\n+        GENERAL_EQUALIZERSETTINGS.setChannelSetting(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS.setChannelName(GENERAL_STRING);\n+        GENERAL_EQUALIZERSETTINGS.setChannelId(GENERAL_INT);\n+        GENERAL_EQUALIZERSETTINGS_LIST.add(GENERAL_EQUALIZERSETTINGS);\n+\n+        GENERAL_LIGHTCAPABILITIES.setName(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTCAPABILITIES.setDensityAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES.setRGBColorSpaceAvailable(GENERAL_BOOLEAN);\n+        GENERAL_LIGHTCAPABILITIES_LIST.add(GENERAL_LIGHTCAPABILITIES);\n+\n+        GENERAL_LIGHTSTATE.setId(GENERAL_LIGHTNAME);\n+        GENERAL_LIGHTSTATE.setDensity(GENERAL_FLOAT);\n+        GENERAL_LIGHTSTATE.setStatus(GENERAL_LIGHTSTATUS);\n+        GENERAL_LIGHTSTATE.setColor(GENERAL_RGBCOLOR);\n+        GENERAL_LIGHTSTATE_LIST.add(GENERAL_LIGHTSTATE);\n+\n+        GENERAL_REMOTECONTROLCAPABILITIES.setButtonCapabilities(GENERAL_BUTTONCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setClimateControlCapabilities(GENERAL_CLIMATECONTROLCAPABILITIES_LIST);\n+        GENERAL_REMOTECONTROLCAPABILITIES.setRadioControlCapabilities(GENERAL_RADIOCONTROLCAPABILITIES_LIST);\n+\n+        GENERAL_HMICAPABILITIES.setNavigationAvilable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setVideoStreamingAvailable(GENERAL_BOOLEAN);\n+        GENERAL_HMICAPABILITIES.setPhoneCallAvilable(GENERAL_BOOLEAN);\n+\n+        List<MetadataType> exampleList = new ArrayList<>();\n+        exampleList.add(0, MetadataType.CURRENT_TEMPERATURE);\n+        exampleList.add(1, MetadataType.MEDIA_ALBUM);\n+        exampleList.add(2, MetadataType.MEDIA_ARTIST);\n+\n+        GENERAL_METADATASTRUCT.setMainField1(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField2(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField3(exampleList);\n+        GENERAL_METADATASTRUCT.setMainField4(exampleList);\n+\n+        GENERAL_RECTANGLE.setX(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setY(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setWidth(GENERAL_FLOAT);\n+        GENERAL_RECTANGLE.setHeight(GENERAL_FLOAT);\n+\n+        GENERAL_HAPTIC_RECT.setId(GENERAL_INTEGER);\n+        GENERAL_HAPTIC_RECT.setRect(GENERAL_RECTANGLE);\n+\n+        GENERAL_RGBCOLOR.setRed(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setGreen(GENERAL_INTEGER);\n+        GENERAL_RGBCOLOR.setBlue(GENERAL_INTEGER);\n+\n+        GENERAL_NIGHTCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_NIGHTCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_DAYCOLORSCHEME.setPrimaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setSecondaryColor(GENERAL_RGBCOLOR);\n+        GENERAL_DAYCOLORSCHEME.setBackgroundColor(GENERAL_RGBCOLOR);\n+\n+        GENERAL_LOCKSCREENCONFIG.setAppIcon(R.drawable.sdl_lockscreen_icon);\n+        GENERAL_LOCKSCREENCONFIG.setBackgroundColor(Color.BLUE);\n+        GENERAL_LOCKSCREENCONFIG.setDisplayMode(LockScreenConfig.DISPLAY_MODE_ALWAYS);\n+        GENERAL_LOCKSCREENCONFIG.setCustomView(R.layout.activity_sdllock_screen);\n+        GENERAL_CLOUDAPPPROPERTIES.setNicknames(GENERAL_STRING_LIST);\n+        GENERAL_CLOUDAPPPROPERTIES.setAppID(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setEnabled(GENERAL_BOOLEAN);\n+        GENERAL_CLOUDAPPPROPERTIES.setAuthToken(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setCloudTransportType(GENERAL_STRING);\n+        GENERAL_CLOUDAPPPROPERTIES.setHybridAppPreference(GENERAL_HYBRID_APP_PREFERENCE);\n+        GENERAL_CLOUDAPPPROPERTIES.setEndpoint(GENERAL_STRING);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setWeatherForLocationSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setCurrentForecastSupported(GENERAL_BOOLEAN);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMultidayForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxMinutelyForecastAmount(GENERAL_INTEGER);\n+        GENERAL_WEATHER_SERVICE_MANIFEST.setMaxHourlyForecastAmount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEMANIFEST.setWeatherServiceManifest(GENERAL_WEATHER_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setServiceName(GENERAL_STRING);\n+        GENERAL_APPSERVICEMANIFEST.setServiceIcon(GENERAL_IMAGE);\n+        GENERAL_APPSERVICEMANIFEST.setRpcSpecVersion(GENERAL_SDLMSGVERSION);\n+        GENERAL_APPSERVICEMANIFEST.setMediaServiceManifest(GENERAL_MEDIA_SERVICE_MANIFEST);\n+        GENERAL_APPSERVICEMANIFEST.setHandledRpcs(GENERAL_FUNCTION_ID_LIST);\n+        GENERAL_APPSERVICEMANIFEST.setAllowAppConsumers(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICEMANIFEST.setServiceType(GENERAL_STRING);\n+\n+        GENERAL_NAVIGATION_SERVICE_MANIFEST.setAcceptsWayPoints(GENERAL_BOOLEAN);\n+\n+        GENERAL_APPSERVICERECORD.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICERECORD.setServiceManifest(GENERAL_APPSERVICEMANIFEST);\n+        GENERAL_APPSERVICERECORD.setServiceActive(GENERAL_BOOLEAN);\n+        GENERAL_APPSERVICERECORD.setServicePublished(GENERAL_BOOLEAN);\n+\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdatedAppServiceRecord(GENERAL_APPSERVICERECORD);\n+        GENERAL_APP_SERVICE_CAPABILITY.setUpdateReason(GENERAL_SERVICE_UPDATE_REASON);\n+\n+        GENERAL_APP_SERVICE_CAPABILITIES.setAppServices(GENERAL_APPSERVICECAPABILITY_LIST);\n+\n+        GENERAL_DATETIME.setDay(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMilliSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setMonth(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setSecond(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzHour(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setTzMinute(TestValues.GENERAL_INT);\n+        GENERAL_DATETIME.setYear(TestValues.GENERAL_INT);\n+\n+        GENERAL_WEATHERDATA.setCurrentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureHigh(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setTemperatureLow(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setApparentTemperature(GENERAL_TEMPERATURE);\n+        GENERAL_WEATHERDATA.setWeatherSummary(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setTime(GENERAL_DATETIME);\n+        GENERAL_WEATHERDATA.setHumidity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setCloudCover(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setMoonPhase(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setWindGust(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWindSpeed(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setNearestStormBearing(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setNearestStormDistance(GENERAL_INTEGER);\n+        GENERAL_WEATHERDATA.setPrecipAccumulation(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipIntensity(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipProbability(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setPrecipType(GENERAL_STRING);\n+        GENERAL_WEATHERDATA.setVisibility(GENERAL_FLOAT);\n+        GENERAL_WEATHERDATA.setWeatherIcon(GENERAL_IMAGE);\n+\n+        GENERAL_WEATHERALERT.setTitle(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setSummary(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setExpires(GENERAL_DATETIME);\n+        GENERAL_WEATHERALERT.setRegions(GENERAL_STRING_LIST);\n+        GENERAL_WEATHERALERT.setSeverity(GENERAL_STRING);\n+        GENERAL_WEATHERALERT.setTimeIssued(GENERAL_DATETIME);\n+\n+        GENERAL_WEATHERSERVICEDATA.setLocation(GENERAL_LOCATIONDETAILS);\n+        GENERAL_WEATHERSERVICEDATA.setCurrentForecast(GENERAL_WEATHERDATA);\n+        GENERAL_WEATHERSERVICEDATA.setMinuteForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setHourlyForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setMultidayForecast(GENERAL_WEATHERDATA_LIST);\n+        GENERAL_WEATHERSERVICEDATA.setAlerts(GENERAL_WEATHERALERT_LIST);\n+\n+        GENERAL_MEDIASERVICEDATA.setMediaType(GENERAL_MEDIATYPE);\n+        GENERAL_MEDIASERVICEDATA.setMediaTitle(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaArtist(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setMediaAlbum(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setPlaylistName(GENERAL_STRING);\n+        GENERAL_MEDIASERVICEDATA.setIsExplicit(GENERAL_BOOLEAN);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setTrackPlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackProgress(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueuePlaybackDuration(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueCurrentTrackNumber(GENERAL_INTEGER);\n+        GENERAL_MEDIASERVICEDATA.setQueueTotalTrackCount(GENERAL_INTEGER);\n+\n+        GENERAL_APPSERVICEDATA.setServiceType(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setServiceID(GENERAL_STRING);\n+        GENERAL_APPSERVICEDATA.setWeatherServiceData(GENERAL_WEATHERSERVICEDATA);\n+        GENERAL_APPSERVICEDATA.setMediaServiceData(GENERAL_MEDIASERVICEDATA);\n+\n+        GENERAL_NAVIGATION_INSTRUCTION.setLocationDetails(GENERAL_LOCATIONDETAILS);\n+        GENERAL_NAVIGATION_INSTRUCTION.setAction(GENERAL_NAVIGATIONACTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setEta(GENERAL_DATETIME);\n+        GENERAL_NAVIGATION_INSTRUCTION.setBearing(GENERAL_INTEGER);\n+        GENERAL_NAVIGATION_INSTRUCTION.setJunctionType(GENERAL_NAVIGATION_JUNCTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDrivingSide(GENERAL_DIRECTION);\n+        GENERAL_NAVIGATION_INSTRUCTION.setDetails(GENERAL_STRING);\n+        GENERAL_NAVIGATION_INSTRUCTION.setImage(GENERAL_IMAGE);\n+        GENERAL_MODULE_INFO.setModuleId(TestValues.GENERAL_STRING);\n+        GENERAL_MODULE_INFO.setModuleLocation(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setModuleServiceArea(TestValues.GENERAL_GRID);\n+        GENERAL_MODULE_INFO.setMultipleAccessAllowance(TestValues.GENERAL_BOOLEAN);\n+\n+        GENERAL_GEAR_STATUS.setActualGear(GENERAL_ACTUAL_GEAR);\n+        GENERAL_GEAR_STATUS.setTransmissionType(GENERAL_TRANSMISSION_TYPE);\n+        GENERAL_GEAR_STATUS.setUserSelectedGear(GENERAL_USER_SELECTED_GEAR);\n+\n+        GENERAL_WINDOW_STATUS.setLocation(TestValues.GENERAL_GRID);\n+        GENERAL_WINDOW_STATUS.setState(TestValues.GENERAL_WINDOW_STATE);\n+        GENERAL_STABILITY_CONTROL_STATUS.setEscSystem(GENERAL_ESC_SYSTEM);\n+        GENERAL_STABILITY_CONTROL_STATUS.setTrailerSwayControl(GENERAL_S_WAY_CONTROL);\n+\n+        GENERAL_APP_CAPABILITY.setVideoStreamingCapability(GENERAL_VIDEOSTREAMINGCAPABILITY);\n+        GENERAL_APP_CAPABILITY.setAppCapabilityType(GENERAL_APP_CAPABILITY_TYPE);\n+\n+        try {\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, GENERAL_HMILEVEL_LIST);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, GENERAL_HMILEVEL_LIST);\n+\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            JSON_PCMSTREAMCAPABILITIES.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_TOUCHEVENTCAPABILITIES.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_HEIGHT, GENERAL_INT);\n+            JSON_IMAGERESOLUTION.put(ImageResolution.KEY_RESOLUTION_WIDTH, GENERAL_INT);\n+\n+            JSON_CHOICE.put(Choice.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_TERTIARY_TEXT, GENERAL_STRING);\n+            JSON_CHOICE.put(Choice.KEY_CHOICE_ID, GENERAL_INT);\n+            JSON_CHOICE.put(Choice.KEY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_SECONDARY_IMAGE, JSON_IMAGE);\n+            JSON_CHOICE.put(Choice.KEY_VR_COMMANDS, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPE_SUPPORTED.put(ImageType.STATIC);\n+\n+            JSON_HMILEVELS.put(HMILevel.HMI_FULL);\n+            JSON_HMILEVELS.put(HMILevel.HMI_BACKGROUND);\n+\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_ALLOWED, JSON_HMILEVELS);\n+            JSON_HMIPERMISSIONS.put(HMIPermissions.KEY_USER_DISALLOWED, JSON_HMILEVELS);\n+\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_ALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_PARAMETERPERMISSIONS.put(ParameterPermissions.KEY_USER_DISALLOWED, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_HMI_PERMISSIONS, JSON_HMIPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_PARAMETER_PERMISSIONS, JSON_PARAMETERPERMISSIONS);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_RPC_NAME, GENERAL_STRING);\n+            JSON_PERMISSIONITEM.put(PermissionItem.KEY_REQUIRE_ENCRYPTION, GENERAL_BOOLEAN);\n+            JSON_PERMISSIONITEMS.put(JSON_PERMISSIONITEM);\n+\n+            JSON_IMAGE.put(Image.KEY_IMAGE_TYPE, GENERAL_IMAGETYPE);\n+            JSON_IMAGE.put(Image.KEY_VALUE, GENERAL_STRING);\n+            JSON_IMAGE.put(Image.KEY_IS_TEMPLATE, GENERAL_BOOLEAN);\n+\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IS_HIGHLIGHTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SOFT_BUTTON_ID, GENERAL_INT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_SYSTEM_ACTION, SystemAction.STEAL_FOCUS);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TEXT, GENERAL_STRING);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_TYPE, SoftButtonType.SBT_TEXT);\n+            JSON_SOFTBUTTON.put(SoftButton.KEY_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_SOFTBUTTONS.put(JSON_SOFTBUTTON);\n+\n+            JSON_TURN.put(Turn.KEY_NAVIGATION_TEXT, GENERAL_STRING);\n+            JSON_TURN.put(Turn.KEY_TURN_IMAGE, GENERAL_IMAGE.serializeJSON());\n+            JSON_TURNS.put(JSON_TURN);\n+\n+            JSON_MENUPARAMS.put(MenuParams.KEY_MENU_NAME, GENERAL_STRING);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_PARENT_ID, GENERAL_INT);\n+            JSON_MENUPARAMS.put(MenuParams.KEY_POSITION, GENERAL_INT);\n+\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_TEXT, GENERAL_STRING);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_IMAGE, JSON_IMAGE);\n+            JSON_VRHELPITEM.put(VrHelpItem.KEY_POSITION, GENERAL_INT);\n+            JSON_VRHELPITEMS.put(JSON_VRHELPITEM);\n+\n+            JSONObject jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Welcome to the jungle\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+            jsonTtsChunk = new JSONObject();\n+            jsonTtsChunk.put(TTSChunk.KEY_TEXT, \"Say a command\");\n+            jsonTtsChunk.put(TTSChunk.KEY_TYPE, SpeechCapabilities.TEXT);\n+            JSON_TTSCHUNKS.put(jsonTtsChunk);\n+\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_AUTO_COMPLETE_TEXT, GENERAL_STRING);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYPRESS_MODE, KeypressMode.SINGLE_KEYPRESS);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_KEYBOARD_LAYOUT, KeyboardLayout.QWERTY);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LANGUAGE, Language.EN_US);\n+            JSON_KEYBOARDPROPERTIES.put(KeyboardProperties.KEY_LIMITED_CHARACTER_LIST, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+\n+            JSON_STARTTIME.put(StartTime.KEY_HOURS, GENERAL_STARTTIME.getHours());\n+            JSON_STARTTIME.put(StartTime.KEY_MINUTES, GENERAL_STARTTIME.getMinutes());\n+            JSON_STARTTIME.put(StartTime.KEY_SECONDS, GENERAL_STARTTIME.getSeconds());\n+\n+            JSON_CHOICES.put(JSON_CHOICE);\n+\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_CARRIER, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_FIRMWARE_REV, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_HARDWARE, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_MAX_NUMBER_RFCOMM_PORTS, GENERAL_INT);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS, GENERAL_STRING);\n+            JSON_DEVICEINFO.put(DeviceInfo.KEY_OS_VERSION, GENERAL_STRING);\n+\n+            JSON_RGBCOLOR.put(RGBColor.KEY_RED, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_GREEN, GENERAL_INT);\n+            JSON_RGBCOLOR.put(RGBColor.KEY_BLUE, GENERAL_INT);\n+\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_DAYCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_PRIMARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_SECONDARY_COLOR, JSON_RGBCOLOR);\n+            JSON_NIGHTCOLORSCHEME.put(TemplateColorScheme.KEY_BACKGROUND_COLOR, JSON_RGBCOLOR);\n+\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MAJOR_VERSION, GENERAL_INT);\n+            JSON_SDLMSGVERSION.put(SdlMsgVersion.KEY_MINOR_VERSION, GENERAL_INT);\n+\n+            JSON_DIDRESULT.put(DIDResult.KEY_DATA, GENERAL_STRING);\n+            JSON_DIDRESULT.put(DIDResult.KEY_DID_LOCATION, GENERAL_INT);\n+            JSON_DIDRESULT.put(DIDResult.KEY_RESULT_CODE, VehicleDataResultCode.SUCCESS);\n+            JSON_DIDRESULTS.put(JSON_DIDRESULT);\n+\n+            JSON_PRESETBANKCAPABILITIES.put(PresetBankCapabilities.KEY_ON_SCREEN_PRESETS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSONObject jsonButton = new JSONObject();\n+            jsonButton.put(ButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, false);\n+            jsonButton.put(ButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(ButtonCapabilities.KEY_NAME, ButtonName.SEEKRIGHT);\n+            JSON_BUTTONCAPABILITIES.put(jsonButton);\n+\n+            JSONObject jsonRadioControlCapabilities = new JSONObject();\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_BAND_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RADIO_FREQUENCY_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_HD_CHANNEL_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_RDS_DATA_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_AVAILABLE_HDS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_STATE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_STRENGTH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonRadioControlCapabilities.put(RadioControlCapabilities.KEY_SIGNAL_CHANGE_THRESHOLD_AVAILABLE, GENERAL_BOOLEAN);\n+            JSON_RADIOCONTROLCAPABILITIES.put(jsonRadioControlCapabilities);\n+\n+            JSONObject jsonClimateControlCapabilities = new JSONObject();\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_MODULE_NAME, GENERAL_STRING);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_FAN_SPEED_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DESIRED_TEMPERATURE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AC_MAX_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_CIRCULATE_AIR_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_AUTO_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DUAL_MODE_ENABLE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_DEFROST_ZONE, GENERAL_DEFROSTZONE_LIST);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonClimateControlCapabilities.put(ClimateControlCapabilities.KEY_VENTILATION_MODE, GENERAL_VENTILATIONMODE_LIST);\n+            JSON_CLIMATECONTROLCAPABILITIES.put(jsonClimateControlCapabilities);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(SoftButtonCapabilities.KEY_LONG_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_SHORT_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_UP_DOWN_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonButton.put(SoftButtonCapabilities.KEY_IMAGE_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_SOFTBUTTONCAPABILITIES.put(jsonButton);\n+\n+            jsonButton = new JSONObject();\n+            jsonButton.put(AudioPassThruCapabilities.KEY_AUDIO_TYPE, GENERAL_AUDIOTYPE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_BITS_PER_SAMPLE, GENERAL_BITSPERSAMPLE);\n+            jsonButton.put(AudioPassThruCapabilities.KEY_SAMPLING_RATE, GENERAL_SAMPLINGRATE);\n+            JSON_AUDIOPASSTHRUCAPABILITIES.put(jsonButton);\n+\n+            JSON_TEXTFIELD.put(TextField.KEY_CHARACTER_SET, CharacterSet.CID1SET);\n+            JSON_TEXTFIELD.put(TextField.KEY_NAME, TextFieldName.ETA);\n+            JSON_TEXTFIELD.put(TextField.KEY_ROWS, GENERAL_INT);\n+            JSON_TEXTFIELD.put(TextField.KEY_WIDTH, GENERAL_INT);\n+            JSON_TEXTFIELDS.put(JSON_TEXTFIELD);\n+\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_IMAGEFIELD.put(ImageField.KEY_IMAGE_TYPE_SUPPORTED, JsonUtils.createJsonArray(TestValues.GENERAL_FILETYPE_LIST));\n+            JSON_IMAGEFIELD.put(ImageField.KEY_NAME, ImageFieldName.graphic);\n+            JSON_IMAGEFIELDS.put(JSON_IMAGEFIELD);\n+\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_TYPE, GENERAL_WINDOWTYPE);\n+            JSON_WINDOW_TYPE_CAPABILITIES.put(WindowTypeCapabilities.KEY_MAXIMUM_NUMBER_OF_WINDOWS, GENERAL_INT);\n+            JSON_WINDOW_TYPE_CAPABILITIES_LIST.put(JSON_WINDOW_TYPE_CAPABILITIES);\n+\n+            JSON_IMAGE_TYPES.put(ImageType.DYNAMIC);\n+            JSON_IMAGE_TYPES.put(ImageType.STATIC);\n+\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_WINDOW_ID, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_IMAGE_TYPE_SUPPORTED, JSON_IMAGE_TYPES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_BUTTON_CAPABILITIES, JSON_BUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITY.put(WindowCapability.KEY_SOFT_BUTTON_CAPABILITIES, JSON_SOFTBUTTONCAPABILITIES);\n+            JSON_WINDOW_CAPABILITIES.put(JSON_WINDOW_CAPABILITY);\n+\n+            JSONObject jsonTEC = new JSONObject();\n+            jsonTEC.put(TouchEventCapabilities.KEY_DOUBLE_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_MULTI_TOUCH_AVAILABLE, GENERAL_BOOLEAN);\n+            jsonTEC.put(TouchEventCapabilities.KEY_PRESS_AVAILABLE, GENERAL_BOOLEAN);\n+\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_RESOLUTION, JSON_IMAGERESOLUTION);\n+            JSON_SCREENPARAMS.put(ScreenParams.KEY_TOUCH_EVENT_AVAILABLE, jsonTEC);\n+\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_TYPE, GENERAL_DISPLAYTYPE);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_GRAPHIC_SUPPORTED, GENERAL_BOOLEAN);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_IMAGE_FIELDS, JSON_IMAGEFIELDS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_MEDIA_CLOCK_FORMATS, JsonUtils.createJsonArray(GENERAL_MEDIACLOCKFORMAT_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_NUM_CUSTOM_PRESETS_AVAILABLE, GENERAL_INT);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_SCREEN_PARAMS, JSON_SCREENPARAMS);\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEMPLATES_AVAILABLE, JsonUtils.createJsonArray(GENERAL_STRING_LIST));\n+            JSON_DISPLAYCAPABILITIES.put(DisplayCapabilities.KEY_TEXT_FIELDS, JSON_TEXTFIELDS);\n+\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_DISPLAY_NAME, GENERAL_STRING);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_TYPE_SUPPORTED, JSON_WINDOW_TYPE_CAPABILITIES_LIST);\n+            JSON_DISPLAYCAPABILITY.put(DisplayCapability.KEY_WINDOW_CAPABILITIES, JSON_WINDOW_CAPABILITIES);\n+            JSON_DISPLAYCAPABILITY_LIST.put(JSON_DISPLAYCAPABILITY);\n+\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTS_DYNAMIC_SUB_MENUS, GENERAL_BOOLEAN);\n+            JSON_DYNAMICUPDATECAPABILITIES.put(DynamicUpdateCapabilities.KEY_SUPPORTED_DYNAMIC_IMAGE_FIELD_NAMES, JsonUtils.createJsonArray(Collections.singletonList(GENERAL_IMAGEFIELDNAME)));\n+\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_X, GENERAL_INT);\n+            JSON_TOUCHCOORD.put(TouchCoord.KEY_Y, GENERAL_INT);\n+            JSON_TOUCHCOORDS.put(JSON_TOUCHCOORD);\n+\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_C, JSON_TOUCHCOORDS);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_ID, GENERAL_INT);\n+            JSON_TOUCHEVENT.put(TouchEvent.KEY_TS, JsonUtils.createJsonArray(GENERAL_LONG_LIST));\n+            JSON_TOUCHEVENTS.put(JSON_TOUCHEVENT);\n+\n+            JSON_TEXTFIELDTYPES.put(MetadataType.CURRENT_TEMPERATURE);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ALBUM);\n+            JSON_TEXTFIELDTYPES.put(MetadataType.MEDIA_ARTIST);\n+\n+            JSON_SEAT_LOCATIONS.put(JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_ID, TestValues.GENERAL_STRING);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_LOCATION, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MODULE_SERVICE_AREA, TestValues.JSON_GRID);\n+            JSON_MODULE_INFO.put(ModuleInfo.KEY_MULTIPLE_ACCESS_ALLOWED, TestValues.GENERAL_BOOLEAN);\n+\n+\n+        } catch (JSONException e) {\n+            Log.e(\"Test\", \"Static Json Construction Failed.\", e);\n+        }\n+    }\n }\n"}}, {"oid": "baf78986c6f754e62ebe8e5b230a0b4fa5e76a9f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/baf78986c6f754e62ebe8e5b230a0b4fa5e76a9f", "message": "[VideoStreaming]\n     - Add tests", "committedDate": "2020-08-27T17:58:12Z", "type": "commit"}, {"oid": "5a066b88ac054c6d1debcab98be010d8d7ebd153", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/5a066b88ac054c6d1debcab98be010d8d7ebd153", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/hello_sdl_android/build.gradle\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "committedDate": "2020-08-27T18:03:10Z", "type": "commit"}, {"oid": "4c09868c3a1a268cdd6260a4dc7ca0c35a03b3dc", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/4c09868c3a1a268cdd6260a4dc7ca0c35a03b3dc", "message": "[VideoStreaming]\n     - Fix compilation errors", "committedDate": "2020-08-27T18:05:41Z", "type": "commit"}, {"oid": "93860747ae3712a943374a997e65432f30c7e0e1", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/93860747ae3712a943374a997e65432f30c7e0e1", "message": "[VideoStreaming]\n     - Fix compilation errors", "committedDate": "2020-08-27T18:08:08Z", "type": "commit"}, {"oid": "710cff0d397e4ce5b8d098612f845d3bea0e4386", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/710cff0d397e4ce5b8d098612f845d3bea0e4386", "message": "[VideoStreaming]\n     - Fix errors", "committedDate": "2020-08-27T18:12:46Z", "type": "commit"}, {"oid": "1e33dee9384251f7f7f1a581c802a36e6b7b3ba8", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/1e33dee9384251f7f7f1a581c802a36e6b7b3ba8", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/proxy/SdlProxyBase.java\n#\tbase/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n#\tbase/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "committedDate": "2020-09-10T16:42:23Z", "type": "commit"}, {"oid": "622a5163d32974b466fad7feefda0cbb4d0f16a6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/622a5163d32974b466fad7feefda0cbb4d0f16a6", "message": "[VideoStreaming]\n- Fix streaming flow after refactoring", "committedDate": "2020-09-10T17:28:41Z", "type": "commit"}, {"oid": "02b3f68123bf45a1ea906150545fcb707f69fa62", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/02b3f68123bf45a1ea906150545fcb707f69fa62", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "committedDate": "2020-09-10T17:42:41Z", "type": "commit"}, {"oid": "2005b83caad04cffe274768277afd1fb102db964", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/2005b83caad04cffe274768277afd1fb102db964", "message": "[VideoStreaming]\n- Fix compilation errors on merge conflicts", "committedDate": "2020-09-10T17:47:19Z", "type": "commit"}, {"oid": "8b8dc5aec4ee34e61305a65d3ce6dbeac639ef4a", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8b8dc5aec4ee34e61305a65d3ce6dbeac639ef4a", "message": "[VideoStreaming]\n- Fix tests", "committedDate": "2020-09-21T11:22:40Z", "type": "commit"}, {"oid": "af31063c4a6eaef66df277ba84b6c865593b90e3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/af31063c4a6eaef66df277ba84b6c865593b90e3", "message": "[VideoStreaming]\n- Applied portrait/landscape logic", "committedDate": "2020-09-25T09:14:56Z", "type": "commit"}, {"oid": "94e1d8abd3a4520faa52d68d852cd15592b3956b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/94e1d8abd3a4520faa52d68d852cd15592b3956b", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/managers/lifecycle/SystemCapabilityManagerTests.java\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/TestValues.java\n#\tandroid/sdl_android/src/androidTest/java/com/smartdevicelink/test/rpc/datatypes/VideoStreamingCapabilityTests.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/streaming/video/SdlRemoteDisplay.java\n#\tbase/src/main/java/com/smartdevicelink/managers/ISdl.java\n#\tbase/src/main/java/com/smartdevicelink/managers/StreamingStateMachine.java\n#\tbase/src/main/java/com/smartdevicelink/managers/lifecycle/BaseSystemCapabilityManager.java\n#\tbase/src/main/java/com/smartdevicelink/proxy/rpc/VideoStreamingCapability.java\n#\tbase/src/main/java/com/smartdevicelink/streaming/video/VideoStreamingParameters.java", "committedDate": "2020-09-28T10:34:21Z", "type": "commit"}, {"oid": "2d25e4dce948a695cbd707e8a312547e04f57ddc", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/2d25e4dce948a695cbd707e8a312547e04f57ddc", "message": "[VideoStreaming]\n- Update subscribtion management after merge\n- Fix errors\n- Update tests", "committedDate": "2020-09-28T11:49:50Z", "type": "commit"}, {"oid": "307aac6a75f198a557d3058960955a75486afbe4", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/307aac6a75f198a557d3058960955a75486afbe4", "message": "[VideoStreaming]\n- Fix tests", "committedDate": "2020-09-29T12:07:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgzOTU4MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r501839581", "bodyText": "@kostyaBoss I would rename streamingRange to listOfStreamingRanges on line114.", "author": "santhanamk", "createdAt": "2020-10-08T16:06:52Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -94,17 +100,22 @@\n     private WeakReference<Context> context;\n     private volatile VirtualDisplayEncoder virtualDisplayEncoder;\n     private Class<? extends SdlRemoteDisplay> remoteDisplayClass = null;\n-    private SdlRemoteDisplay remoteDisplay;\n+    private SdlRemoteDisplay sdlRemoteDisplay;\n     private final float[] touchScalar = {1.0f, 1.0f}; //x, y\n     private HapticInterfaceManager hapticManager;\n     private SdlMotionEvent sdlMotionEvent = null;\n     private OnHMIStatus currentOnHMIStatus;\n     private final StreamingStateMachine stateMachine;\n     private VideoStreamingParameters parameters;\n+\tprivate VideoStreamingCapability originalCapability;\n     private IVideoStreamListener streamListener;\n     private boolean isTransportAvailable = false;\n-    private boolean hasStarted;\n+    private Integer majorProtocolVersion;\n+\tprivate List<VideoStreamingRange> streamingRange;", "originalCommit": "307aac6a75f198a557d3058960955a75486afbe4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex eef7079a0..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -107,15 +108,15 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n     private OnHMIStatus currentOnHMIStatus;\n     private final StreamingStateMachine stateMachine;\n     private VideoStreamingParameters parameters;\n-\tprivate VideoStreamingCapability originalCapability;\n+    private VideoStreamingCapability originalCapability;\n     private IVideoStreamListener streamListener;\n     private boolean isTransportAvailable = false;\n     private Integer majorProtocolVersion;\n-\tprivate List<VideoStreamingRange> streamingRange;\n-\tprivate boolean hasStarted;\n+    private List<VideoStreamingRange> listOfStreamingRanges;\n+    private boolean hasStarted;\n     private String vehicleMake = null;\n-\tprivate boolean isEncrypted = false;\n-\tprivate boolean withPendingRestart = false;\n+    private boolean isEncrypted = false;\n+    private boolean withPendingRestart = false;\n     private AbstractPacketizer videoPacketizer;\n \n     // INTERNAL INTERFACES\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg0MTcwNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r501841704", "bodyText": "@kostyaBoss I would swap lines 339 and 340 since landscapeRange is passed into the method before portraitRange.", "author": "santhanamk", "createdAt": "2020-10-08T16:10:00Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -282,27 +335,89 @@ public void onError(String info) {\n      * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n      *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n      *                           works best for the currently connected module.\n-     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-     */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n-            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n-            return;\n-        }\n+\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+\t * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.", "originalCommit": "307aac6a75f198a557d3058960955a75486afbe4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex eef7079a0..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -335,59 +335,60 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n      *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n      *                           works best for the currently connected module.\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n         if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n         configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n-\t\tboolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-\t\tif(majorProtocolVersion >= 5 && !isCapabilitySupported){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tif (streamingRange != null) {\n-\t\t\tthis.streamingRange = streamingRange;\n-\t\t}\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n         if (parameters == null) {\n             if (majorProtocolVersion >= 5) {\n                 if (internalInterface.getSystemCapabilityManager() != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg0MjcwMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r501842701", "bodyText": "@kostyaBoss  I would rename this parameter from streamingRange to listOfStreamingRanges.", "author": "santhanamk", "createdAt": "2020-10-08T16:11:36Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -282,27 +335,89 @@ public void onError(String info) {\n      * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n      *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n      *                           works best for the currently connected module.\n-     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-     */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n-            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n-            return;\n-        }\n+\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+\t * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+\t * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+\t */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n+\t\tif(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n+\t\t\treturn;\n+\t\t}\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+\t\t\tgetVideoStreamingParams();\n+\t\t}\n+\t\tcheckState();\n+\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n+\t}\n+\t/**\n+\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+\t * @param context a context that can be used to create the remote display\n+\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+\t *                   works best for the currently connected module.\n+\t *\n+\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+\t */\n+\t@Deprecated\n+\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+\t\tboolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+\t\tif(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+\t\t\tgetVideoStreamingParams();\n+\t\t}\n+\t\tcheckState();\n+\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n+\t}\n+\n+\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> streamingRange) {", "originalCommit": "307aac6a75f198a557d3058960955a75486afbe4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex eef7079a0..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -335,59 +335,60 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n      *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n      *                           works best for the currently connected module.\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n         if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n         configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n-\t\tboolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-\t\tif(majorProtocolVersion >= 5 && !isCapabilitySupported){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tif (streamingRange != null) {\n-\t\t\tthis.streamingRange = streamingRange;\n-\t\t}\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n         if (parameters == null) {\n             if (majorProtocolVersion >= 5) {\n                 if (internalInterface.getSystemCapabilityManager() != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg0NTU2OA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r501845568", "bodyText": "@kostyaBoss on line 410 you can change this from streamingRange to listOfStreamingRanges.", "author": "santhanamk", "createdAt": "2020-10-08T16:15:52Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java", "diffHunk": "@@ -282,27 +335,89 @@ public void onError(String info) {\n      * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n      *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n      *                           works best for the currently connected module.\n-     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-     */\n-    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted) {\n-        this.context = new WeakReference<>(context);\n-        this.remoteDisplayClass = remoteDisplayClass;\n-        int majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-        if (majorProtocolVersion >= 5 && !isCapabilitySupported) {\n-            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n-            return;\n-        }\n+\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+\t * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+\t * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+\t */\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n+\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n+\t\tif(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n+\t\t\treturn;\n+\t\t}\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+\t\t\tgetVideoStreamingParams();\n+\t\t}\n+\t\tcheckState();\n+\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n+\t}\n+\t/**\n+\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+\t * @param context a context that can be used to create the remote display\n+\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+\t *                   works best for the currently connected module.\n+\t *\n+\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+\t */\n+\t@Deprecated\n+\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n+\t\tboolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+\t\tif(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+\t\t\tgetVideoStreamingParams();\n+\t\t}\n+\t\tcheckState();\n+\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n+\t}\n+\n+\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> streamingRange) {\n+\t\tthis.context = new WeakReference<>(context);\n+\t\tthis.remoteDisplayClass = remoteDisplayClass;\n+\t\tthis.isEncrypted = encrypted;\n+\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+\t\tif (streamingRange != null) {\n+\t\t\tthis.streamingRange = streamingRange;\n+\t\t}\n+\t}\n+\n+\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n         if (parameters == null) {\n             if (majorProtocolVersion >= 5) {\n                 if (internalInterface.getSystemCapabilityManager() != null) {\n                     internalInterface.getSystemCapabilityManager().getCapability(SystemCapabilityType.VIDEO_STREAMING, new OnSystemCapabilityListener() {\n                         @Override\n                         public void onCapabilityRetrieved(Object capability) {\n                             VideoStreamingParameters params = new VideoStreamingParameters();\n-                            params.update((VideoStreamingCapability) capability, vehicleMake);    //Streaming parameters are ready time to stream\n-                            startStreaming(params, encrypted);\n+                            VideoStreamingCapability castedCapability = ((VideoStreamingCapability)capability);\n+\t\t\t\t\t\tVideoStreamManager.this.originalCapability = castedCapability;\n+\n+\t\t\t\t\t\t// Mocks data here\n+\t\t\t\t\t\t// castedCapability.setAdditionalVideoStreamingCapabilities(getMockedAdditionalCapabilities());\n+\t\t\t\t\t\tparams.update(castedCapability, vehicleMake);    //Streaming parameters are ready time to stream\n+                            VideoStreamManager.this.parameters = params;\n+\n+\t\t\t\t\t\tif (streamingRange != null) {\n+\t\t\t\t\t\t\t// filtering\n+\t\t\t\t\t\t\tcastedCapability.setAdditionalVideoStreamingCapabilities(\n+\t\t\t\t\t\t\t\t\tgetSupportedCapabilities(\n+\t\t\t\t\t\t\t\t\t\t\tstreamingRange,", "originalCommit": "307aac6a75f198a557d3058960955a75486afbe4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\nindex eef7079a0..88bedb673 100644\n--- a/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n+++ b/android/sdl_android/src/main/java/com/smartdevicelink/managers/video/VideoStreamManager.java\n\n@@ -335,59 +335,60 @@ public class VideoStreamManager extends BaseVideoStreamManager {\n      * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n      *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n      *                           works best for the currently connected module.\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n-\t */\n+     * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     * @param landscapeRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     * @param portraitRange constraints for vehicle display : aspect ratio, min/max resolutions, max diagonal size.\n+     */\n     public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted, VideoStreamingRange landscapeRange, VideoStreamingRange portraitRange) {\n-\t\tconfigureGlobalParameters(context, remoteDisplayClass, isEncrypted, streamingRange);\n-\t\tif(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n+        Collections.addAll(listOfStreamingRanges, portraitRange, landscapeRange);\n+        configureGlobalParameters(context, remoteDisplayClass, isEncrypted, listOfStreamingRanges);\n+        if(majorProtocolVersion >= 5 && !internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING)){\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n         if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\t/**\n-\t * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n-\t * @param context a context that can be used to create the remote display\n-\t * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n-\t * @param parameters streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n-\t *                   If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n-\t *                   works best for the currently connected module.\n-\t *\n-\t * @param encrypted a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n-\t */\n-\t@Deprecated\n-\tpublic void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+    /**\n+     * Starts streaming a remote display to the module if there is a connected session. This method of streaming requires the device to be on API level 19 or higher\n+     *\n+     * @param context            a context that can be used to create the remote display\n+     * @param remoteDisplayClass class object of the remote display. This class will be used to create an instance of the remote display and will be projected to the module\n+     * @param parameters         streaming parameters to be used when streaming. If null is sent in, the default/optimized options will be used.\n+     *                           If you are unsure about what parameters to be used it is best to just send null and let the system determine what\n+     *                           works best for the currently connected module.\n+     * @param encrypted          a flag of if the stream should be encrypted. Only set if you have a supplied encryption library that the module can understand.\n+     */\n+    @Deprecated\n+    public void startRemoteDisplayStream(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, VideoStreamingParameters parameters, final boolean encrypted){\n         configureGlobalParameters(context, remoteDisplayClass, isEncrypted, null);\n-\t\tboolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n-\t\tif(majorProtocolVersion >= 5 && !isCapabilitySupported){\n-\t\t\tDebugTool.logError(TAG, \"Video streaming not supported on this module\");\n-\t\t\tstateMachine.transitionToState(StreamingStateMachine.ERROR);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n-\t\t\tgetVideoStreamingParams();\n-\t\t}\n-\t\tcheckState();\n-\t\tprocessCapabilitiesWithPendingStart(encrypted, parameters);\n-\t}\n-\n-\tprivate void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> streamingRange) {\n-\t\tthis.context = new WeakReference<>(context);\n-\t\tthis.remoteDisplayClass = remoteDisplayClass;\n-\t\tthis.isEncrypted = encrypted;\n-\t\tthis.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n-\t\tif (streamingRange != null) {\n-\t\t\tthis.streamingRange = streamingRange;\n-\t\t}\n-\t}\n-\n-\tprivate void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n+        boolean isCapabilitySupported = internalInterface.getSystemCapabilityManager() != null && internalInterface.getSystemCapabilityManager().isCapabilitySupported(SystemCapabilityType.VIDEO_STREAMING);\n+        if(majorProtocolVersion >= 5 && !isCapabilitySupported){\n+            DebugTool.logError(TAG, \"Video streaming not supported on this module\");\n+            stateMachine.transitionToState(StreamingStateMachine.ERROR);\n+            return;\n+        }\n+        if (!HMILevel.HMI_NONE.equals(currentOnHMIStatus.getHmiLevel()) && VideoStreamManager.this.parameters == null) {\n+            getVideoStreamingParams();\n+        }\n+        checkState();\n+        processCapabilitiesWithPendingStart(encrypted, parameters);\n+    }\n+\n+    private void configureGlobalParameters(Context context, Class<? extends SdlRemoteDisplay> remoteDisplayClass, boolean encrypted, List<VideoStreamingRange> listOfStreamingRange) {\n+        this.context = new WeakReference<>(context);\n+        this.remoteDisplayClass = remoteDisplayClass;\n+        this.isEncrypted = encrypted;\n+        this.majorProtocolVersion = internalInterface.getProtocolVersion().getMajor();\n+        if (listOfStreamingRange != null) {\n+            this.listOfStreamingRanges = listOfStreamingRange;\n+        }\n+    }\n+\n+    private void processCapabilitiesWithPendingStart(boolean encrypted, VideoStreamingParameters parameters){\n         if (parameters == null) {\n             if (majorProtocolVersion >= 5) {\n                 if (internalInterface.getSystemCapabilityManager() != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1MjE4Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r501852183", "bodyText": "@kostyaBoss Given that changes were made to VideoStreamManager.java, do changes need to be made to VideoStreamManagerTests.java?", "author": "santhanamk", "createdAt": "2020-10-08T16:25:53Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java", "diffHunk": "@@ -21,6 +21,7 @@\n import com.smartdevicelink.proxy.rpc.OnHMIStatus;\n import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.RegisterAppInterfaceResponse;\n+import com.smartdevicelink.proxy.rpc.SdlMsgVersion;", "originalCommit": "307aac6a75f198a557d3058960955a75486afbe4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjkxNjIzMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1434#discussion_r502916231", "bodyText": "@santhanamk, I don't think so, we've made just formatting changes", "author": "kboskin", "createdAt": "2020-10-11T13:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1MjE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6c587df8e627e07a209f4893f1c2fb08faebf401", "chunk": "diff --git a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\nindex 2b4a16136..79c3d6240 100644\n--- a/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n+++ b/android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/video/VideoStreamManagerTests.java\n\n@@ -21,7 +21,6 @@ import com.smartdevicelink.proxy.rpc.ImageResolution;\n import com.smartdevicelink.proxy.rpc.OnHMIStatus;\n import com.smartdevicelink.proxy.rpc.OnTouchEvent;\n import com.smartdevicelink.proxy.rpc.RegisterAppInterfaceResponse;\n-import com.smartdevicelink.proxy.rpc.SdlMsgVersion;\n import com.smartdevicelink.proxy.rpc.TouchCoord;\n import com.smartdevicelink.proxy.rpc.TouchEvent;\n import com.smartdevicelink.proxy.rpc.VehicleType;\n"}}, {"oid": "6ef3090bbd48ad096722ec8e0fd7aec30138c79e", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/6ef3090bbd48ad096722ec8e0fd7aec30138c79e", "message": "[VideoStreaming]\n- Fix naming\n- Fix comments code", "committedDate": "2020-10-11T13:31:50Z", "type": "commit"}, {"oid": "06c58187c197218c6fae6a5a3a89dbdd8f194926", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/06c58187c197218c6fae6a5a3a89dbdd8f194926", "message": "Merge branch 'develop' into feature/0296_possibility_to_update_video_streaming_capabilities\n\n# Conflicts:\n#\tandroid/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/MainActivity.java\n#\tandroid/hello_sdl_android/src/main/java/com/sdl/hellosdlandroid/SdlService.java\n#\tandroid/hello_sdl_android/src/main/res/layout/activity_main.xml", "committedDate": "2020-11-11T09:15:33Z", "type": "commit"}, {"oid": "5303319b363a0d3f773cdf3bc2bc38ab1f497113", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/5303319b363a0d3f773cdf3bc2bc38ab1f497113", "message": "[0296]\n- Example rollback", "committedDate": "2020-11-13T12:22:36Z", "type": "commit"}, {"oid": "c5e6c269ee8935a3711ad1d5ab5af77f30e540e6", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c5e6c269ee8935a3711ad1d5ab5af77f30e540e6", "message": "[0296]\n- Codestyle fix", "committedDate": "2020-11-13T12:48:46Z", "type": "commit"}, {"oid": "ac3c9a392f6d37b536569b62a89f9dc2b43a33bf", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ac3c9a392f6d37b536569b62a89f9dc2b43a33bf", "message": "[0296]\n- Codestyle fix", "committedDate": "2020-11-13T12:55:12Z", "type": "commit"}, {"oid": "891f8a8cdf8c8448676c208b9392c17122de9ca4", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/891f8a8cdf8c8448676c208b9392c17122de9ca4", "message": "[0296]\n- Codestyle fix", "committedDate": "2020-11-13T13:11:12Z", "type": "commit"}]}