{"pr_number": 2345, "pr_title": "Datastore - support custom maps", "pr_createdAt": "2020-04-29T20:32:07Z", "pr_url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2345", "timeline": [{"oid": "d930071e474cb20af67882cf369ba8c8b3970b73", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/d930071e474cb20af67882cf369ba8c8b3970b73", "message": "support custom maps", "committedDate": "2020-04-29T20:29:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzOTI3NA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2345#discussion_r418239274", "bodyText": "Technically, it's a breaking change. Can we just overload with a new method that has an additional argument?\nThis especially seems to make sense because you sometimes call the method with null typeInformation.\nAlso, can we rename typeInformation to mapTypeInformation?\nIf you're getting the type information for the whole map, why do you need the key and value type information? Maybe it would be easier if the caller just passed the map they wanted to fill with results?", "author": "meltsufin", "createdAt": "2020-04-30T19:28:20Z", "path": "spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DatastoreEntityConverter.java", "diffHunk": "@@ -42,15 +42,16 @@\n \n \t/**\n \t * Read the entity as a {@link Map}.\n+\t * @param <T> the type of the key in the map\n+\t * @param <R> the type of the value in the map\n \t * @param keyType the key type of the map to be read.\n \t * @param componentType the value type of the map, into which each field value will be\n \t * converted.\n \t * @param entity the entity from Cloud Datastore.\n-\t * @param <T> the type of the key in the map\n-\t * @param <R> the type of the value in the map\n+\t * @param typeInformation the actual type of the map\n \t * @return a Map where the key values are the field names and the values the field\n \t * values.\n \t */\n \t<T, R> Map<T, R> readAsMap(Class<T> keyType, TypeInformation<R> componentType,\n-\t\t\tBaseEntity entity);\n+\t\t\tBaseEntity entity, TypeInformation typeInformation);", "originalCommit": "d930071e474cb20af67882cf369ba8c8b3970b73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c131cf29c987d867c79d15e45c7f9e73cd10b80", "chunk": "diff --git a/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DatastoreEntityConverter.java b/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DatastoreEntityConverter.java\nindex 43ce49136..d872d91e2 100644\n--- a/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DatastoreEntityConverter.java\n+++ b/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DatastoreEntityConverter.java\n\n@@ -44,14 +44,24 @@ public interface DatastoreEntityConverter extends\n \t * Read the entity as a {@link Map}.\n \t * @param <T> the type of the key in the map\n \t * @param <R> the type of the value in the map\n+\t * @param entity the entity from Cloud Datastore.\n+\t * @param mapTypeInformation the actual type of the map\n+\t * @return a Map where the key values are the field names and the values the field\n+\t * values.\n+\t */\n+\t<T, R> Map<T, R> readAsMap(BaseEntity entity, TypeInformation mapTypeInformation);\n+\n+\t/**\n+\t * Read the entity as a {@link Map} when the map type is unknown.\n+\t * @param <T> the type of the key in the map\n+\t * @param <R> the type of the value in the map\n \t * @param keyType the key type of the map to be read.\n \t * @param componentType the value type of the map, into which each field value will be\n \t * converted.\n \t * @param entity the entity from Cloud Datastore.\n-\t * @param typeInformation the actual type of the map\n \t * @return a Map where the key values are the field names and the values the field\n \t * values.\n \t */\n \t<T, R> Map<T, R> readAsMap(Class<T> keyType, TypeInformation<R> componentType,\n-\t\t\tBaseEntity entity, TypeInformation typeInformation);\n+\t\t\tBaseEntity entity);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NDY1OQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2345#discussion_r418244659", "bodyText": "This just doesn't seem right. Can we put the burden on the caller to create the map?", "author": "meltsufin", "createdAt": "2020-04-30T19:39:12Z", "path": "spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DefaultDatastoreEntityConverter.java", "diffHunk": "@@ -79,11 +81,23 @@ public ReadWriteConversions getConversions() {\n \n \t@Override\n \tpublic <T, R> Map<T, R> readAsMap(Class<T> keyType, TypeInformation<R> componentType,\n-\t\t\tBaseEntity entity) {\n+\t\t\tBaseEntity entity, TypeInformation typeInformation) {\n \t\tif (entity == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tMap<T, R> result = new HashMap<>();\n+\t\tObject customMap = null;\n+\t\tif (typeInformation != null && !typeInformation.getType().isInterface()) {\n+\t\t\ttry {\n+\t\t\t\tcustomMap = ((Constructor<?>) typeInformation.getType().getConstructor()).newInstance();", "originalCommit": "d930071e474cb20af67882cf369ba8c8b3970b73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0MjUxNg==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2345#discussion_r418342516", "bodyText": "Could you elaborate why it doesn't seem right?", "author": "dmitry-s", "createdAt": "2020-04-30T23:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NDY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NzY0Nw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2345#discussion_r418357647", "bodyText": "I think if the caller has to create it, it will perhaps be inconsistent with the other cases.", "author": "ashesfall", "createdAt": "2020-05-01T00:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NDY1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "4c131cf29c987d867c79d15e45c7f9e73cd10b80", "chunk": "diff --git a/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DefaultDatastoreEntityConverter.java b/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DefaultDatastoreEntityConverter.java\nindex 796c6f4ec..e616e29d1 100644\n--- a/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DefaultDatastoreEntityConverter.java\n+++ b/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/core/convert/DefaultDatastoreEntityConverter.java\n\n@@ -80,36 +82,48 @@ public class DefaultDatastoreEntityConverter implements DatastoreEntityConverter\n \t}\n \n \t@Override\n-\tpublic <T, R> Map<T, R> readAsMap(Class<T> keyType, TypeInformation<R> componentType,\n-\t\t\tBaseEntity entity, TypeInformation typeInformation) {\n+\tpublic <T, R> Map<T, R> readAsMap(BaseEntity entity, TypeInformation mapTypeInformation) {\n+\t\tAssert.notNull(mapTypeInformation, \"mapTypeInformation can't be null\");\n \t\tif (entity == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tObject customMap = null;\n-\t\tif (typeInformation != null && !typeInformation.getType().isInterface()) {\n+\t\tMap<T, R> result;\n+\t\tif (!mapTypeInformation.getType().isInterface()) {\n \t\t\ttry {\n-\t\t\t\tcustomMap = ((Constructor<?>) typeInformation.getType().getConstructor()).newInstance();\n+\t\t\t\tresult = (Map<T, R>) ((Constructor<?>) mapTypeInformation.getType().getConstructor()).newInstance();\n \t\t\t}\n-\t\t\tcatch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n+\t\t\tcatch (Exception e) {\n \t\t\t\tthrow new DatastoreDataException(\"Unable to create an instance of a custom map type: \"\n-\t\t\t\t\t\t+ typeInformation.getType()\n+\t\t\t\t\t\t+ mapTypeInformation.getType()\n \t\t\t\t\t\t+ \" (make sure the class is public and has a public no-args constructor)\", e);\n \t\t\t}\n \t\t}\n+\t\telse {\n+\t\t\tresult = new HashMap<>();\n+\t\t}\n \n-\t\tMap<T, R> result = customMap != null ? (Map<T, R>) customMap : new HashMap<>();\n \t\tEntityPropertyValueProvider propertyValueProvider = new EntityPropertyValueProvider(\n \t\t\t\tentity, this.conversions);\n \t\tSet<String> fieldNames = entity.getNames();\n \t\tfor (String field : fieldNames) {\n-\t\t\tresult.put(this.conversions.convertOnRead(field, null, keyType),\n+\t\t\tresult.put(this.conversions.convertOnRead(field, NOT_EMBEDDED, mapTypeInformation.getComponentType()),\n \t\t\t\t\tpropertyValueProvider.getPropertyValue(field,\n-\t\t\t\t\t\t\tEmbeddedType.of(componentType),\n-\t\t\t\t\t\t\tcomponentType));\n+\t\t\t\t\t\t\tEmbeddedType.of(mapTypeInformation.getMapValueType()),\n+\t\t\t\t\t\t\tmapTypeInformation.getMapValueType()));\n \t\t}\n \t\treturn result;\n \t}\n \n+\t@Override\n+\tpublic <T, R> Map<T, R> readAsMap(Class<T> keyType, TypeInformation<R> componentType,\n+\t\t\tBaseEntity entity) {\n+\t\tif (entity == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tMap<T, R> result = new HashMap<>();\n+\t\treturn readAsMap(entity, ClassTypeInformation.from(result.getClass()));\n+\t}\n+\n \t@Override\n \t@SuppressWarnings(\"unchecked\")\n \tpublic <R> R read(Class<R> aClass, BaseEntity entity) {\n"}}, {"oid": "3ed7f3d7191acc2d9b1b861e50097dfe7e43c1da", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/3ed7f3d7191acc2d9b1b861e50097dfe7e43c1da", "message": "Merge branch 'master' of github.com:spring-cloud/spring-cloud-gcp into datastore-custom-map", "committedDate": "2020-05-01T15:47:09Z", "type": "commit"}, {"oid": "4c131cf29c987d867c79d15e45c7f9e73cd10b80", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/4c131cf29c987d867c79d15e45c7f9e73cd10b80", "message": "PR comments", "committedDate": "2020-05-01T16:43:47Z", "type": "commit"}]}