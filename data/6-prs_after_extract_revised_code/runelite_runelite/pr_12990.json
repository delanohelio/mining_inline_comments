{"pr_number": 12990, "pr_title": "opponentinfo: make health bar more active", "pr_createdAt": "2020-12-29T01:39:48Z", "pr_url": "https://github.com/runelite/runelite/pull/12990", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3MDcxMw==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556070713", "bodyText": "Reverse these indentation changes\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tname = \"Opponent Information\",\n          \n          \n            \n            \t\tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n          \n          \n            \n            \t\ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}\n          \n          \n            \n            \tname = \"Opponent Information\",\n          \n          \n            \n            \tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n          \n          \n            \n            \ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}", "author": "Nightfirecat", "createdAt": "2021-01-12T20:31:44Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -51,9 +51,9 @@\n import net.runelite.http.api.hiscore.HiscoreEndpoint;\n \n @PluginDescriptor(\n-\tname = \"Opponent Information\",\n-\tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n-\ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}\n+\t\tname = \"Opponent Information\",\n+\t\tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n+\t\ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 152ca24ac..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -51,9 +53,9 @@ import net.runelite.client.ui.overlay.OverlayManager;\n import net.runelite.http.api.hiscore.HiscoreEndpoint;\n \n @PluginDescriptor(\n-\t\tname = \"Opponent Information\",\n-\t\tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n-\t\ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}\n+\tname = \"Opponent Information\",\n+\tdescription = \"Show name and hitpoints information about the NPC you are fighting\",\n+\ttags = {\"combat\", \"health\", \"hitpoints\", \"npcs\", \"overlay\"}\n )\n public class OpponentInfoPlugin extends Plugin\n {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3MjE3OA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556072178", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t|| !menuEntryAdded.getOption().equals(\"Attack\")\n          \n          \n            \n            \t\t\t\t|| !config.showOpponentsInMenu())\n          \n          \n            \n            \t\t\t|| !menuEntryAdded.getOption().equals(\"Attack\")\n          \n          \n            \n            \t\t\t|| !config.showOpponentsInMenu())", "author": "Nightfirecat", "createdAt": "2021-01-12T20:33:50Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)\n+\t\t{\n+\t\t\tActor opponent = player.getInteracting();\n \n-\t\tlastOpponent = opponent;\n+\t\t\tif (target != null && opponent == null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = source;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (opponent != lastOpponent)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n+\t\t}\n \t}\n \n \t@Subscribe\n \tpublic void onGameTick(GameTick gameTick)\n \t{\n-\t\tif (lastOpponent != null\n-\t\t\t&& lastTime != null\n-\t\t\t&& client.getLocalPlayer().getInteracting() == null)\n+\t\tif (lastTime != null \n+\t\t\t&& Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)\n \t\t{\n-\t\t\tif (Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)\n-\t\t\t{\n-\t\t\t\tlastOpponent = null;\n-\t\t\t}\n+\t\t\tlastOpponent = null;\n+\t\t\tlastTime = null;\n \t\t}\n \t}\n \n \t@Subscribe\n \tpublic void onMenuEntryAdded(MenuEntryAdded menuEntryAdded)\n \t{\n \t\tif (menuEntryAdded.getType() != MenuAction.NPC_SECOND_OPTION.getId()\n-\t\t\t|| !menuEntryAdded.getOption().equals(\"Attack\")\n-\t\t\t|| !config.showOpponentsInMenu())\n+\t\t\t\t|| !menuEntryAdded.getOption().equals(\"Attack\")\n+\t\t\t\t|| !config.showOpponentsInMenu())", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 152ca24ac..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -134,7 +138,9 @@ public class OpponentInfoPlugin extends Plugin\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3ODgzMg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556078832", "bodyText": "Indent by only one level\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t|| source == lastOpponent)\n          \n          \n            \n            \t\t\t|| source == lastOpponent)", "author": "Nightfirecat", "createdAt": "2021-01-12T20:44:30Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 152ca24ac..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -134,7 +138,9 @@ public class OpponentInfoPlugin extends Plugin\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3OTE5Mg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556079192", "bodyText": "Indent by only one level\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t&& lastOpponent.getInteracting() != player)\n          \n          \n            \n            \t\t\t\t&& lastOpponent.getInteracting() != player)", "author": "Nightfirecat", "createdAt": "2021-01-12T20:44:49Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 152ca24ac..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -134,7 +138,9 @@ public class OpponentInfoPlugin extends Plugin\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA3OTQ4OA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556079488", "bodyText": "The trailing space here is causing the CI failure\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (lastTime != null \n          \n          \n            \n            \t\tif (lastTime != null", "author": "Nightfirecat", "createdAt": "2021-01-12T20:45:05Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)\n+\t\t{\n+\t\t\tActor opponent = player.getInteracting();\n \n-\t\tlastOpponent = opponent;\n+\t\t\tif (target != null && opponent == null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = source;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (opponent != lastOpponent)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n+\t\t}\n \t}\n \n \t@Subscribe\n \tpublic void onGameTick(GameTick gameTick)\n \t{\n-\t\tif (lastOpponent != null\n-\t\t\t&& lastTime != null\n-\t\t\t&& client.getLocalPlayer().getInteracting() == null)\n+\t\tif (lastTime != null ", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 152ca24ac..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -134,7 +138,9 @@ public class OpponentInfoPlugin extends Plugin\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEwOTE1OA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556109158", "bodyText": "Why is this nulled here now?", "author": "Nightfirecat", "createdAt": "2021-01-12T21:33:13Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)\n+\t\t{\n+\t\t\tActor opponent = player.getInteracting();\n \n-\t\tlastOpponent = opponent;\n+\t\t\tif (target != null && opponent == null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = source;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (opponent != lastOpponent)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n+\t\t}\n \t}\n \n \t@Subscribe\n \tpublic void onGameTick(GameTick gameTick)\n \t{\n-\t\tif (lastOpponent != null\n-\t\t\t&& lastTime != null\n-\t\t\t&& client.getLocalPlayer().getInteracting() == null)\n+\t\tif (lastTime != null \n+\t\t\t&& Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)\n \t\t{\n-\t\t\tif (Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)\n-\t\t\t{\n-\t\t\t\tlastOpponent = null;\n-\t\t\t}\n+\t\t\tlastOpponent = null;\n+\t\t\tlastTime = null;", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAzOTI4MA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r557039280", "bodyText": "Hello, so, in the current version of the plugin, it checks whether the player is interacting with an NPC on line 158 as part of determining whether to hide the health bar after WAIT time has passed or not.  Since my goal is to have the health bar visible while the player isn't technically interacting with the NPC but is still damaging it with recoil/cannon, I instead made lastTime null when it hasn't been set to a value in onInteractingChanged.  Otherwise, it would hide the health bar every tick after the initial WAIT time has passed.", "author": "chaticon", "createdAt": "2021-01-14T04:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEwOTE1OA=="}], "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 152ca24ac..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -134,7 +138,9 @@ public class OpponentInfoPlugin extends Plugin\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjEwOTIwNQ==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r556109205", "bodyText": "Why is this nulled here now?", "author": "Nightfirecat", "createdAt": "2021-01-12T21:33:19Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,42 +134,55 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player\n+\t\t\t\t|| source == lastOpponent)\n+\t\t{\n+\t\t\tActor opponent = player.getInteracting();\n \n-\t\tlastOpponent = opponent;\n+\t\t\tif (target != null && opponent == null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = source;\n+\t\t\t\tlastTime = null;", "originalCommit": "1ed1619d24f5443c64f12d680c9dea3cc269eda4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 152ca24ac..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -134,7 +138,9 @@ public class OpponentInfoPlugin extends Plugin\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMTE4Nw==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561601187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            import java.time.Clock;", "author": "Nightfirecat", "createdAt": "2021-01-21T04:52:05Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -26,6 +26,8 @@\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Provides;\n+\n+import java.time.Clock;", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 8dab0b107..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -25,9 +26,8 @@\n  */\n package net.runelite.client.plugins.opponentinfo;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.inject.Provides;\n-\n-import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.EnumSet;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMTM3Nw==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561601377", "bodyText": "This should be @VisibleForTesting as the getter should not be used otherwise.", "author": "Nightfirecat", "createdAt": "2021-01-21T04:52:47Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -80,6 +82,7 @@\n \t@Getter(AccessLevel.PACKAGE)\n \tprivate Actor lastOpponent;\n \n+\t@Getter(AccessLevel.PACKAGE)\n \tprivate Instant lastTime;", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 8dab0b107..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -82,6 +82,7 @@ public class OpponentInfoPlugin extends Plugin\n \t@Getter(AccessLevel.PACKAGE)\n \tprivate Actor lastOpponent;\n \n+\t@VisibleForTesting\n \t@Getter(AccessLevel.PACKAGE)\n \tprivate Instant lastTime;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMTkyNg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561601926", "bodyText": "This will be clearer with each definition on its own line.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n          \n          \n            \n            \t\tfinal Player player = client.getLocalPlayer();\n          \n          \n            \n            \t\tfinal Actor source = event.getSource();\n          \n          \n            \n            \t\tfinal Actor target = event.getTarget();", "author": "Nightfirecat", "createdAt": "2021-01-21T04:55:00Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,33 +137,46 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 8dab0b107..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -137,7 +138,9 @@ public class OpponentInfoPlugin extends Plugin\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMjMwMg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561602302", "bodyText": "This is missing copyright header", "author": "Nightfirecat", "createdAt": "2021-01-21T04:56:21Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 865018fcb..40d2abd54 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,199 +1,238 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Guice;\n import com.google.inject.Inject;\n import com.google.inject.testing.fieldbinder.Bind;\n import com.google.inject.testing.fieldbinder.BoundFieldModule;\n-import net.runelite.api.*;\n+import net.runelite.api.Client;\n import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n import org.junit.Before;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.Test;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import org.mockito.junit.MockitoJUnitRunner;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import org.mockito.Mock;\n \n @RunWith(MockitoJUnitRunner.class)\n public class OpponentInfoPluginTest\n {\n-    @Mock\n-    @Bind\n-    Client client;\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig opponentInfoConfig;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n \n-    @Mock\n-    @Bind\n-    OverlayManager overlayManager;\n+\t@Inject\n+\tOpponentInfoPlugin opponentInfoPlugin;\n \n-    @Mock\n-    @Bind\n-    OpponentInfoConfig opponentInfoConfig;\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\t}\n \n-    @Mock\n-    @Bind\n-    OpponentInfoOverlay opponentInfoOverlay;\n+\t/*\n+\t * Verify that the current opponent in multi is always the npc that the player is attacking\n+\t */\n+\t@Test\n+\tpublic void testAttackingEnemyInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-    @Mock\n-    @Bind\n-    PlayerComparisonOverlay playerComparisonOverlay;\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    @Inject\n-    OpponentInfoPlugin opponentInfoPlugin;\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-    @Before\n-    public void before()\n-    {\n-        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n-    }\n+\t\t// some npc attacks the player\n+\t\tInteractingChanged aggroEnemy = new InteractingChanged(aggro, localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-    /*\n-     * Verify that the current opponent in multi is always the npc that the player is attacking\n-     */\n-    @Test\n-    public void testAttackingEnemyInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggro, opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player attacks a different npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(attacked);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, attacked));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify the attacked npc is now considered the current opponent\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacks them back\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\t\t// verify that the current opponent is still the attacked npc\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks a different npc\n-        when(thePlayer.getInteracting()).thenReturn(attacked);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n-        // the npc attacks them back\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\t\t// the player is attacked by an aggressive npc while attacking a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-        // verify that the current opponent is now the attacked npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by an aggressive npc while attacking a different npc\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacking the player that is not the current opponent attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the npc attacking the player that is not the current opponent attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\t\t// the npc the player is attacking, the current opponent, attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n+\t}\n \n-        // the npc the player is attacking, the current opponent, attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc while the player is not attacking anything\n+\t */\n+\t@Test\n+\tpublic void testIdleInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc while the player is not attacking anything\n-     */\n-    @Test\n-    public void testIdleInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggroFirst, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\t\t// the player is attacked by a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\t\t// verify that the current opponent is the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by a different npc\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\t\t// an npc that is not the current opponent targets another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n \n-        // verify that the current opponent is the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that the current opponent is still the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // an npc that is not the current opponent targets another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\t\t// the current opponent switches targets to another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n \n-        // verify that the current opponent is still the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n \n-        // the current opponent switches targets to another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc in singles\n+\t */\n+\t@Test\n+\tpublic void testSingles()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC npc = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc in singles\n-     */\n-    @Test\n-    public void testSingles() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC playerNPC = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the attacking npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc stops attacking the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify that the attacking npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the player attacks the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(npc);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, npc));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks the npc\n-        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n-        // the npc attacks them back\n-        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc attacks them back\n+\t\twhen(npc.getInteracting()).thenReturn(localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that the attacked npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n-        // verify that the hp bar will no longer be hidden\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the attacked npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the hp bar will no longer be hidden\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the player stops attacking the npc\n-        when(thePlayer.getInteracting()).thenReturn(null);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player stops attacking the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(null);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-        // verify that the hp bar will not be hidden (because the npc is still attacking the player)\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the hp bar will not be hidden (because the npc is still attacking the player)\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the npc attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, otherPlayer));\n+\t\t// the npc attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, otherPlayer));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the other player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the npc stops attacking the other player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify there is still no opponent\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\t// verify there is still no opponent\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMjU4MA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561602580", "bodyText": "Imports should be ordered alphabetically and have no empty lines (don't separate static and non-static imports). Also, don't use star imports: https://github.com/runelite/runelite/wiki/Code-Conventions#imports", "author": "Nightfirecat", "createdAt": "2021-01-21T04:57:24Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 865018fcb..40d2abd54 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,199 +1,238 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Guice;\n import com.google.inject.Inject;\n import com.google.inject.testing.fieldbinder.Bind;\n import com.google.inject.testing.fieldbinder.BoundFieldModule;\n-import net.runelite.api.*;\n+import net.runelite.api.Client;\n import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n import org.junit.Before;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.Test;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import org.mockito.junit.MockitoJUnitRunner;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import org.mockito.Mock;\n \n @RunWith(MockitoJUnitRunner.class)\n public class OpponentInfoPluginTest\n {\n-    @Mock\n-    @Bind\n-    Client client;\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig opponentInfoConfig;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n \n-    @Mock\n-    @Bind\n-    OverlayManager overlayManager;\n+\t@Inject\n+\tOpponentInfoPlugin opponentInfoPlugin;\n \n-    @Mock\n-    @Bind\n-    OpponentInfoConfig opponentInfoConfig;\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\t}\n \n-    @Mock\n-    @Bind\n-    OpponentInfoOverlay opponentInfoOverlay;\n+\t/*\n+\t * Verify that the current opponent in multi is always the npc that the player is attacking\n+\t */\n+\t@Test\n+\tpublic void testAttackingEnemyInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-    @Mock\n-    @Bind\n-    PlayerComparisonOverlay playerComparisonOverlay;\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    @Inject\n-    OpponentInfoPlugin opponentInfoPlugin;\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-    @Before\n-    public void before()\n-    {\n-        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n-    }\n+\t\t// some npc attacks the player\n+\t\tInteractingChanged aggroEnemy = new InteractingChanged(aggro, localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-    /*\n-     * Verify that the current opponent in multi is always the npc that the player is attacking\n-     */\n-    @Test\n-    public void testAttackingEnemyInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggro, opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player attacks a different npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(attacked);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, attacked));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify the attacked npc is now considered the current opponent\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacks them back\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\t\t// verify that the current opponent is still the attacked npc\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks a different npc\n-        when(thePlayer.getInteracting()).thenReturn(attacked);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n-        // the npc attacks them back\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\t\t// the player is attacked by an aggressive npc while attacking a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-        // verify that the current opponent is now the attacked npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by an aggressive npc while attacking a different npc\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacking the player that is not the current opponent attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the npc attacking the player that is not the current opponent attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\t\t// the npc the player is attacking, the current opponent, attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n+\t}\n \n-        // the npc the player is attacking, the current opponent, attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc while the player is not attacking anything\n+\t */\n+\t@Test\n+\tpublic void testIdleInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc while the player is not attacking anything\n-     */\n-    @Test\n-    public void testIdleInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggroFirst, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\t\t// the player is attacked by a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\t\t// verify that the current opponent is the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by a different npc\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\t\t// an npc that is not the current opponent targets another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n \n-        // verify that the current opponent is the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that the current opponent is still the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // an npc that is not the current opponent targets another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\t\t// the current opponent switches targets to another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n \n-        // verify that the current opponent is still the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n \n-        // the current opponent switches targets to another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc in singles\n+\t */\n+\t@Test\n+\tpublic void testSingles()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC npc = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc in singles\n-     */\n-    @Test\n-    public void testSingles() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC playerNPC = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the attacking npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc stops attacking the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify that the attacking npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the player attacks the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(npc);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, npc));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks the npc\n-        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n-        // the npc attacks them back\n-        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc attacks them back\n+\t\twhen(npc.getInteracting()).thenReturn(localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that the attacked npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n-        // verify that the hp bar will no longer be hidden\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the attacked npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the hp bar will no longer be hidden\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the player stops attacking the npc\n-        when(thePlayer.getInteracting()).thenReturn(null);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player stops attacking the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(null);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-        // verify that the hp bar will not be hidden (because the npc is still attacking the player)\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the hp bar will not be hidden (because the npc is still attacking the player)\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the npc attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, otherPlayer));\n+\t\t// the npc attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, otherPlayer));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the other player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the npc stops attacking the other player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify there is still no opponent\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\t// verify there is still no opponent\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwMjgxNg==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561602816", "bodyText": "Refer to our code conventions--we use tabs for indentation rather than spaces. Our code conventions page provides a brief guide for setting up auto-formatting with IntelliJ.", "author": "Nightfirecat", "createdAt": "2021-01-21T04:58:03Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 865018fcb..40d2abd54 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,199 +1,238 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Guice;\n import com.google.inject.Inject;\n import com.google.inject.testing.fieldbinder.Bind;\n import com.google.inject.testing.fieldbinder.BoundFieldModule;\n-import net.runelite.api.*;\n+import net.runelite.api.Client;\n import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n import org.junit.Before;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.Test;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import org.mockito.junit.MockitoJUnitRunner;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import org.mockito.Mock;\n \n @RunWith(MockitoJUnitRunner.class)\n public class OpponentInfoPluginTest\n {\n-    @Mock\n-    @Bind\n-    Client client;\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig opponentInfoConfig;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n \n-    @Mock\n-    @Bind\n-    OverlayManager overlayManager;\n+\t@Inject\n+\tOpponentInfoPlugin opponentInfoPlugin;\n \n-    @Mock\n-    @Bind\n-    OpponentInfoConfig opponentInfoConfig;\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\t}\n \n-    @Mock\n-    @Bind\n-    OpponentInfoOverlay opponentInfoOverlay;\n+\t/*\n+\t * Verify that the current opponent in multi is always the npc that the player is attacking\n+\t */\n+\t@Test\n+\tpublic void testAttackingEnemyInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-    @Mock\n-    @Bind\n-    PlayerComparisonOverlay playerComparisonOverlay;\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    @Inject\n-    OpponentInfoPlugin opponentInfoPlugin;\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-    @Before\n-    public void before()\n-    {\n-        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n-    }\n+\t\t// some npc attacks the player\n+\t\tInteractingChanged aggroEnemy = new InteractingChanged(aggro, localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-    /*\n-     * Verify that the current opponent in multi is always the npc that the player is attacking\n-     */\n-    @Test\n-    public void testAttackingEnemyInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggro, opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player attacks a different npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(attacked);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, attacked));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify the attacked npc is now considered the current opponent\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacks them back\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\t\t// verify that the current opponent is still the attacked npc\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks a different npc\n-        when(thePlayer.getInteracting()).thenReturn(attacked);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n-        // the npc attacks them back\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\t\t// the player is attacked by an aggressive npc while attacking a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-        // verify that the current opponent is now the attacked npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by an aggressive npc while attacking a different npc\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacking the player that is not the current opponent attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the npc attacking the player that is not the current opponent attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\t\t// the npc the player is attacking, the current opponent, attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n+\t}\n \n-        // the npc the player is attacking, the current opponent, attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc while the player is not attacking anything\n+\t */\n+\t@Test\n+\tpublic void testIdleInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc while the player is not attacking anything\n-     */\n-    @Test\n-    public void testIdleInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggroFirst, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\t\t// the player is attacked by a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\t\t// verify that the current opponent is the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by a different npc\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\t\t// an npc that is not the current opponent targets another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n \n-        // verify that the current opponent is the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that the current opponent is still the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // an npc that is not the current opponent targets another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\t\t// the current opponent switches targets to another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n \n-        // verify that the current opponent is still the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n \n-        // the current opponent switches targets to another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc in singles\n+\t */\n+\t@Test\n+\tpublic void testSingles()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC npc = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc in singles\n-     */\n-    @Test\n-    public void testSingles() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC playerNPC = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the attacking npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc stops attacking the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify that the attacking npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the player attacks the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(npc);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, npc));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks the npc\n-        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n-        // the npc attacks them back\n-        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc attacks them back\n+\t\twhen(npc.getInteracting()).thenReturn(localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that the attacked npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n-        // verify that the hp bar will no longer be hidden\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the attacked npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the hp bar will no longer be hidden\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the player stops attacking the npc\n-        when(thePlayer.getInteracting()).thenReturn(null);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player stops attacking the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(null);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-        // verify that the hp bar will not be hidden (because the npc is still attacking the player)\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the hp bar will not be hidden (because the npc is still attacking the player)\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the npc attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, otherPlayer));\n+\t\t// the npc attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, otherPlayer));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the other player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the npc stops attacking the other player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify there is still no opponent\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\t// verify there is still no opponent\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwNDA4NA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561604084", "bodyText": "We generally use the name localPlayer for the local player\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n          \n          \n            \n                    Player localPlayer = mock(Player.class), otherPlayer = mock(Player.class);", "author": "Nightfirecat", "createdAt": "2021-01-21T05:02:41Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 865018fcb..40d2abd54 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,199 +1,238 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Guice;\n import com.google.inject.Inject;\n import com.google.inject.testing.fieldbinder.Bind;\n import com.google.inject.testing.fieldbinder.BoundFieldModule;\n-import net.runelite.api.*;\n+import net.runelite.api.Client;\n import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n import org.junit.Before;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.Test;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import org.mockito.junit.MockitoJUnitRunner;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import org.mockito.Mock;\n \n @RunWith(MockitoJUnitRunner.class)\n public class OpponentInfoPluginTest\n {\n-    @Mock\n-    @Bind\n-    Client client;\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig opponentInfoConfig;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n \n-    @Mock\n-    @Bind\n-    OverlayManager overlayManager;\n+\t@Inject\n+\tOpponentInfoPlugin opponentInfoPlugin;\n \n-    @Mock\n-    @Bind\n-    OpponentInfoConfig opponentInfoConfig;\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\t}\n \n-    @Mock\n-    @Bind\n-    OpponentInfoOverlay opponentInfoOverlay;\n+\t/*\n+\t * Verify that the current opponent in multi is always the npc that the player is attacking\n+\t */\n+\t@Test\n+\tpublic void testAttackingEnemyInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-    @Mock\n-    @Bind\n-    PlayerComparisonOverlay playerComparisonOverlay;\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    @Inject\n-    OpponentInfoPlugin opponentInfoPlugin;\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-    @Before\n-    public void before()\n-    {\n-        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n-    }\n+\t\t// some npc attacks the player\n+\t\tInteractingChanged aggroEnemy = new InteractingChanged(aggro, localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-    /*\n-     * Verify that the current opponent in multi is always the npc that the player is attacking\n-     */\n-    @Test\n-    public void testAttackingEnemyInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggro, opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player attacks a different npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(attacked);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, attacked));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify the attacked npc is now considered the current opponent\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacks them back\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\t\t// verify that the current opponent is still the attacked npc\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks a different npc\n-        when(thePlayer.getInteracting()).thenReturn(attacked);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n-        // the npc attacks them back\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\t\t// the player is attacked by an aggressive npc while attacking a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-        // verify that the current opponent is now the attacked npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by an aggressive npc while attacking a different npc\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacking the player that is not the current opponent attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the npc attacking the player that is not the current opponent attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\t\t// the npc the player is attacking, the current opponent, attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n+\t}\n \n-        // the npc the player is attacking, the current opponent, attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc while the player is not attacking anything\n+\t */\n+\t@Test\n+\tpublic void testIdleInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc while the player is not attacking anything\n-     */\n-    @Test\n-    public void testIdleInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggroFirst, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\t\t// the player is attacked by a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\t\t// verify that the current opponent is the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by a different npc\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\t\t// an npc that is not the current opponent targets another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n \n-        // verify that the current opponent is the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that the current opponent is still the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // an npc that is not the current opponent targets another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\t\t// the current opponent switches targets to another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n \n-        // verify that the current opponent is still the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n \n-        // the current opponent switches targets to another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc in singles\n+\t */\n+\t@Test\n+\tpublic void testSingles()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC npc = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc in singles\n-     */\n-    @Test\n-    public void testSingles() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC playerNPC = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the attacking npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc stops attacking the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify that the attacking npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the player attacks the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(npc);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, npc));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks the npc\n-        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n-        // the npc attacks them back\n-        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc attacks them back\n+\t\twhen(npc.getInteracting()).thenReturn(localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that the attacked npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n-        // verify that the hp bar will no longer be hidden\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the attacked npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the hp bar will no longer be hidden\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the player stops attacking the npc\n-        when(thePlayer.getInteracting()).thenReturn(null);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player stops attacking the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(null);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-        // verify that the hp bar will not be hidden (because the npc is still attacking the player)\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the hp bar will not be hidden (because the npc is still attacking the player)\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the npc attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, otherPlayer));\n+\t\t// the npc attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, otherPlayer));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the other player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the npc stops attacking the other player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify there is still no opponent\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\t// verify there is still no opponent\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwNDY2NQ==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561604665", "bodyText": "Shouldn't there be another assert between these verifying attacked is now the last opponent?", "author": "Nightfirecat", "createdAt": "2021-01-21T05:05:01Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\n+        // the player attacks a different npc\n+        when(thePlayer.getInteracting()).thenReturn(attacked);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n+        // the npc attacks them back\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 865018fcb..40d2abd54 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,199 +1,238 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Guice;\n import com.google.inject.Inject;\n import com.google.inject.testing.fieldbinder.Bind;\n import com.google.inject.testing.fieldbinder.BoundFieldModule;\n-import net.runelite.api.*;\n+import net.runelite.api.Client;\n import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n import org.junit.Before;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.Test;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import org.mockito.junit.MockitoJUnitRunner;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import org.mockito.Mock;\n \n @RunWith(MockitoJUnitRunner.class)\n public class OpponentInfoPluginTest\n {\n-    @Mock\n-    @Bind\n-    Client client;\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig opponentInfoConfig;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n \n-    @Mock\n-    @Bind\n-    OverlayManager overlayManager;\n+\t@Inject\n+\tOpponentInfoPlugin opponentInfoPlugin;\n \n-    @Mock\n-    @Bind\n-    OpponentInfoConfig opponentInfoConfig;\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\t}\n \n-    @Mock\n-    @Bind\n-    OpponentInfoOverlay opponentInfoOverlay;\n+\t/*\n+\t * Verify that the current opponent in multi is always the npc that the player is attacking\n+\t */\n+\t@Test\n+\tpublic void testAttackingEnemyInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-    @Mock\n-    @Bind\n-    PlayerComparisonOverlay playerComparisonOverlay;\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    @Inject\n-    OpponentInfoPlugin opponentInfoPlugin;\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-    @Before\n-    public void before()\n-    {\n-        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n-    }\n+\t\t// some npc attacks the player\n+\t\tInteractingChanged aggroEnemy = new InteractingChanged(aggro, localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-    /*\n-     * Verify that the current opponent in multi is always the npc that the player is attacking\n-     */\n-    @Test\n-    public void testAttackingEnemyInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggro, opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player attacks a different npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(attacked);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, attacked));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify the attacked npc is now considered the current opponent\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacks them back\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\t\t// verify that the current opponent is still the attacked npc\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks a different npc\n-        when(thePlayer.getInteracting()).thenReturn(attacked);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n-        // the npc attacks them back\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\t\t// the player is attacked by an aggressive npc while attacking a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-        // verify that the current opponent is now the attacked npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by an aggressive npc while attacking a different npc\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacking the player that is not the current opponent attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the npc attacking the player that is not the current opponent attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\t\t// the npc the player is attacking, the current opponent, attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n+\t}\n \n-        // the npc the player is attacking, the current opponent, attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc while the player is not attacking anything\n+\t */\n+\t@Test\n+\tpublic void testIdleInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc while the player is not attacking anything\n-     */\n-    @Test\n-    public void testIdleInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggroFirst, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\t\t// the player is attacked by a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\t\t// verify that the current opponent is the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by a different npc\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\t\t// an npc that is not the current opponent targets another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n \n-        // verify that the current opponent is the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that the current opponent is still the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // an npc that is not the current opponent targets another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\t\t// the current opponent switches targets to another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n \n-        // verify that the current opponent is still the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n \n-        // the current opponent switches targets to another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc in singles\n+\t */\n+\t@Test\n+\tpublic void testSingles()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC npc = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc in singles\n-     */\n-    @Test\n-    public void testSingles() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC playerNPC = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the attacking npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc stops attacking the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify that the attacking npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the player attacks the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(npc);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, npc));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks the npc\n-        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n-        // the npc attacks them back\n-        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc attacks them back\n+\t\twhen(npc.getInteracting()).thenReturn(localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that the attacked npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n-        // verify that the hp bar will no longer be hidden\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the attacked npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the hp bar will no longer be hidden\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the player stops attacking the npc\n-        when(thePlayer.getInteracting()).thenReturn(null);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player stops attacking the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(null);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-        // verify that the hp bar will not be hidden (because the npc is still attacking the player)\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the hp bar will not be hidden (because the npc is still attacking the player)\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the npc attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, otherPlayer));\n+\t\t// the npc attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, otherPlayer));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the other player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the npc stops attacking the other player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify there is still no opponent\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\t// verify there is still no opponent\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwOTU2MA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561609560", "bodyText": "It looks like this line is not covered in the added tests. What case does this cover?", "author": "Nightfirecat", "createdAt": "2021-01-21T05:21:54Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,33 +137,46 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n+\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n \n-\t\tActor opponent = event.getTarget();\n-\n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQxOTIyMA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r563419220", "bodyText": "This prevents the hp bar disappearing in the case where the player attacks an npc, then stops attacking anything, but the npc hasn't stopped attacking the player.  There actually is a test for it on line 184.  (Now line 219 as of today)", "author": "chaticon", "createdAt": "2021-01-25T01:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwOTU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExMTU3MQ==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r569111571", "bodyText": "That isn't what this condition is written to be though, nor is it what that test is testing.\nThis condition, combined with all the parent conditions, works out to be:\nif (source == player && target == null && lastOpponent != null && lastOpponent.getInteracting() != player)\nThat is, when the player stops interacting with an NPC which is not attacking the player. That is why, despite the test being written to test the scenario you described, this line is not being covered by tests. I highly recommend running the tests in IntelliJ using the \"Run Test with Coverage\" button and checking to see which lines of the plugin (most importantly the changed lines) have test coverage. That is how I identified that this lastTime = Instant.now(); call is never executed by the tests.", "author": "Nightfirecat", "createdAt": "2021-02-03T03:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwOTU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTkwNjI1MA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r569906250", "bodyText": "Sorry, I explained poorly.  What I meant was exactly what you described, I was just explaining what happens when the condition is false.  It is designed so that in the case I mentioned, where the player stops attacking an npc, but the npc is still attacking the player, the condition is false, so the hp bar stays visible.  That's why when\u2014as you've described\u2014the player stops interacting with an npc that isn't attacking the player, the condition is true.  The result of that is, as you would expect, the hp bar is set to disappear after WAIT time.  In the test, I was testing that case where the condition is false.  I've added a test where the condition is true now.", "author": "chaticon", "createdAt": "2021-02-04T02:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYwOTU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 8dab0b107..9dfe87616 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -137,7 +138,9 @@ public class OpponentInfoPlugin extends Plugin\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tActor player = client.getLocalPlayer(), source = event.getSource(), target = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYxMDgwNw==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561610807", "bodyText": "Same here, shouldn't there be another assert between these verifying playerNPC is now the last opponent?", "author": "Nightfirecat", "createdAt": "2021-01-21T05:26:07Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\n+        // the player attacks a different npc\n+        when(thePlayer.getInteracting()).thenReturn(attacked);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n+        // the npc attacks them back\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\n+        // verify that the current opponent is now the attacked npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the player is attacked by an aggressive npc while attacking a different npc\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the npc attacking the player that is not the current opponent attacks a different player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the npc the player is attacking, the current opponent, attacks a different player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+    }\n+\n+    /*\n+     * Verify that the current opponent is the expected npc while the player is not attacking anything\n+     */\n+    @Test\n+    public void testIdleInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\n+        // the player is attacked by a different npc\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\n+        // verify that the current opponent is the most recent aggressor\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\n+        // an npc that is not the current opponent targets another player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\n+        // verify that the current opponent is still the most recent aggressor\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\n+        // the current opponent switches targets to another player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\n+        // verify that there is no longer an opponent\n+        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+    }\n+\n+    /*\n+     * Verify that the current opponent is the expected npc in singles\n+     */\n+    @Test\n+    public void testSingles() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC playerNPC = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\n+        // verify that the attacking npc is the current opponent\n+        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\n+        // the npc stops attacking the player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\n+        // verify that there is no longer an opponent\n+        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\n+        // the player attacks the npc\n+        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n+        // the npc attacks them back\n+        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 865018fcb..40d2abd54 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,199 +1,238 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Guice;\n import com.google.inject.Inject;\n import com.google.inject.testing.fieldbinder.Bind;\n import com.google.inject.testing.fieldbinder.BoundFieldModule;\n-import net.runelite.api.*;\n+import net.runelite.api.Client;\n import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n import org.junit.Before;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.Test;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import org.mockito.junit.MockitoJUnitRunner;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import org.mockito.Mock;\n \n @RunWith(MockitoJUnitRunner.class)\n public class OpponentInfoPluginTest\n {\n-    @Mock\n-    @Bind\n-    Client client;\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig opponentInfoConfig;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n \n-    @Mock\n-    @Bind\n-    OverlayManager overlayManager;\n+\t@Inject\n+\tOpponentInfoPlugin opponentInfoPlugin;\n \n-    @Mock\n-    @Bind\n-    OpponentInfoConfig opponentInfoConfig;\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\t}\n \n-    @Mock\n-    @Bind\n-    OpponentInfoOverlay opponentInfoOverlay;\n+\t/*\n+\t * Verify that the current opponent in multi is always the npc that the player is attacking\n+\t */\n+\t@Test\n+\tpublic void testAttackingEnemyInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-    @Mock\n-    @Bind\n-    PlayerComparisonOverlay playerComparisonOverlay;\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    @Inject\n-    OpponentInfoPlugin opponentInfoPlugin;\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-    @Before\n-    public void before()\n-    {\n-        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n-    }\n+\t\t// some npc attacks the player\n+\t\tInteractingChanged aggroEnemy = new InteractingChanged(aggro, localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-    /*\n-     * Verify that the current opponent in multi is always the npc that the player is attacking\n-     */\n-    @Test\n-    public void testAttackingEnemyInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggro, opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player attacks a different npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(attacked);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, attacked));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify the attacked npc is now considered the current opponent\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacks them back\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\t\t// verify that the current opponent is still the attacked npc\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks a different npc\n-        when(thePlayer.getInteracting()).thenReturn(attacked);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n-        // the npc attacks them back\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\t\t// the player is attacked by an aggressive npc while attacking a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-        // verify that the current opponent is now the attacked npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by an aggressive npc while attacking a different npc\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacking the player that is not the current opponent attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the npc attacking the player that is not the current opponent attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\t\t// the npc the player is attacking, the current opponent, attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n+\t}\n \n-        // the npc the player is attacking, the current opponent, attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc while the player is not attacking anything\n+\t */\n+\t@Test\n+\tpublic void testIdleInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc while the player is not attacking anything\n-     */\n-    @Test\n-    public void testIdleInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggroFirst, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\t\t// the player is attacked by a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\t\t// verify that the current opponent is the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by a different npc\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\t\t// an npc that is not the current opponent targets another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n \n-        // verify that the current opponent is the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that the current opponent is still the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // an npc that is not the current opponent targets another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\t\t// the current opponent switches targets to another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n \n-        // verify that the current opponent is still the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n \n-        // the current opponent switches targets to another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc in singles\n+\t */\n+\t@Test\n+\tpublic void testSingles()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC npc = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc in singles\n-     */\n-    @Test\n-    public void testSingles() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC playerNPC = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the attacking npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc stops attacking the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify that the attacking npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the player attacks the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(npc);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, npc));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks the npc\n-        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n-        // the npc attacks them back\n-        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc attacks them back\n+\t\twhen(npc.getInteracting()).thenReturn(localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that the attacked npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n-        // verify that the hp bar will no longer be hidden\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the attacked npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the hp bar will no longer be hidden\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the player stops attacking the npc\n-        when(thePlayer.getInteracting()).thenReturn(null);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player stops attacking the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(null);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-        // verify that the hp bar will not be hidden (because the npc is still attacking the player)\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the hp bar will not be hidden (because the npc is still attacking the player)\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the npc attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, otherPlayer));\n+\t\t// the npc attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, otherPlayer));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the other player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the npc stops attacking the other player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify there is still no opponent\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\t// verify there is still no opponent\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYxMDg2NA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561610864", "bodyText": "This is a very confusing var name. Couldn't we just call this npc?", "author": "Nightfirecat", "createdAt": "2021-01-21T05:26:22Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\n+        // the player attacks a different npc\n+        when(thePlayer.getInteracting()).thenReturn(attacked);\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n+        // the npc attacks them back\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\n+        // verify that the current opponent is now the attacked npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the player is attacked by an aggressive npc while attacking a different npc\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the npc attacking the player that is not the current opponent attacks a different player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\n+        // the npc the player is attacking, the current opponent, attacks a different player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\n+        // verify that the current opponent is still the npc the player is attacking\n+        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+    }\n+\n+    /*\n+     * Verify that the current opponent is the expected npc while the player is not attacking anything\n+     */\n+    @Test\n+    public void testIdleInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\n+        // the player is attacked by a different npc\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\n+        // verify that the current opponent is the most recent aggressor\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\n+        // an npc that is not the current opponent targets another player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\n+        // verify that the current opponent is still the most recent aggressor\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\n+        // the current opponent switches targets to another player\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\n+        // verify that there is no longer an opponent\n+        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+    }\n+\n+    /*\n+     * Verify that the current opponent is the expected npc in singles\n+     */\n+    @Test\n+    public void testSingles() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC playerNPC = mock(NPC.class);", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQyNTYzMQ==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r563425631", "bodyText": "You're right, at one point I was using two npcs and I just never changed the name when I removed one of them.", "author": "chaticon", "createdAt": "2021-01-25T01:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYxMDg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 865018fcb..40d2abd54 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,199 +1,238 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Guice;\n import com.google.inject.Inject;\n import com.google.inject.testing.fieldbinder.Bind;\n import com.google.inject.testing.fieldbinder.BoundFieldModule;\n-import net.runelite.api.*;\n+import net.runelite.api.Client;\n import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n import org.junit.Before;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.Test;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import org.mockito.junit.MockitoJUnitRunner;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import org.mockito.Mock;\n \n @RunWith(MockitoJUnitRunner.class)\n public class OpponentInfoPluginTest\n {\n-    @Mock\n-    @Bind\n-    Client client;\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig opponentInfoConfig;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n \n-    @Mock\n-    @Bind\n-    OverlayManager overlayManager;\n+\t@Inject\n+\tOpponentInfoPlugin opponentInfoPlugin;\n \n-    @Mock\n-    @Bind\n-    OpponentInfoConfig opponentInfoConfig;\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\t}\n \n-    @Mock\n-    @Bind\n-    OpponentInfoOverlay opponentInfoOverlay;\n+\t/*\n+\t * Verify that the current opponent in multi is always the npc that the player is attacking\n+\t */\n+\t@Test\n+\tpublic void testAttackingEnemyInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-    @Mock\n-    @Bind\n-    PlayerComparisonOverlay playerComparisonOverlay;\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    @Inject\n-    OpponentInfoPlugin opponentInfoPlugin;\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-    @Before\n-    public void before()\n-    {\n-        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n-    }\n+\t\t// some npc attacks the player\n+\t\tInteractingChanged aggroEnemy = new InteractingChanged(aggro, localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-    /*\n-     * Verify that the current opponent in multi is always the npc that the player is attacking\n-     */\n-    @Test\n-    public void testAttackingEnemyInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggro, opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player attacks a different npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(attacked);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, attacked));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify the attacked npc is now considered the current opponent\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacks them back\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\t\t// verify that the current opponent is still the attacked npc\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks a different npc\n-        when(thePlayer.getInteracting()).thenReturn(attacked);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n-        // the npc attacks them back\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\t\t// the player is attacked by an aggressive npc while attacking a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-        // verify that the current opponent is now the attacked npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by an aggressive npc while attacking a different npc\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacking the player that is not the current opponent attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the npc attacking the player that is not the current opponent attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\t\t// the npc the player is attacking, the current opponent, attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n+\t}\n \n-        // the npc the player is attacking, the current opponent, attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc while the player is not attacking anything\n+\t */\n+\t@Test\n+\tpublic void testIdleInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc while the player is not attacking anything\n-     */\n-    @Test\n-    public void testIdleInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggroFirst, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\t\t// the player is attacked by a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\t\t// verify that the current opponent is the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by a different npc\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\t\t// an npc that is not the current opponent targets another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n \n-        // verify that the current opponent is the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that the current opponent is still the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // an npc that is not the current opponent targets another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\t\t// the current opponent switches targets to another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n \n-        // verify that the current opponent is still the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n \n-        // the current opponent switches targets to another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc in singles\n+\t */\n+\t@Test\n+\tpublic void testSingles()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC npc = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc in singles\n-     */\n-    @Test\n-    public void testSingles() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC playerNPC = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the attacking npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc stops attacking the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify that the attacking npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the player attacks the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(npc);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, npc));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks the npc\n-        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n-        // the npc attacks them back\n-        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc attacks them back\n+\t\twhen(npc.getInteracting()).thenReturn(localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that the attacked npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n-        // verify that the hp bar will no longer be hidden\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the attacked npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the hp bar will no longer be hidden\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the player stops attacking the npc\n-        when(thePlayer.getInteracting()).thenReturn(null);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player stops attacking the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(null);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-        // verify that the hp bar will not be hidden (because the npc is still attacking the player)\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the hp bar will not be hidden (because the npc is still attacking the player)\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the npc attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, otherPlayer));\n+\t\t// the npc attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, otherPlayer));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the other player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the npc stops attacking the other player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify there is still no opponent\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\t// verify there is still no opponent\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTYxMzMxNA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r561613314", "bodyText": "FYI, the argument order for assertions is assertSame(expected, actual), so every assertion has the parameters in reverse order.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n          \n          \n            \n                    assertSame(opponentInfoPlugin.getLastOpponent(), aggro);", "author": "Nightfirecat", "createdAt": "2021-01-21T05:34:45Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.*;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+    @Mock\n+    @Bind\n+    Client client;\n+\n+    @Mock\n+    @Bind\n+    OverlayManager overlayManager;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoConfig opponentInfoConfig;\n+\n+    @Mock\n+    @Bind\n+    OpponentInfoOverlay opponentInfoOverlay;\n+\n+    @Mock\n+    @Bind\n+    PlayerComparisonOverlay playerComparisonOverlay;\n+\n+    @Inject\n+    OpponentInfoPlugin opponentInfoPlugin;\n+\n+    @Before\n+    public void before()\n+    {\n+        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+    }\n+\n+    /*\n+     * Verify that the current opponent in multi is always the npc that the player is attacking\n+     */\n+    @Test\n+    public void testAttackingEnemyInMulti() {\n+        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\n+        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\n+        // verify that there is currently no opponent\n+        assertNull(opponentInfoPlugin.getLastOpponent());\n+\n+        // some npc attacks the player\n+        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n+        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\n+        // verify that the current opponent is the aggressive npc\n+        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);", "originalCommit": "0561947d5a3e4d3c3a321885ef48d43a963acf94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "687ed3f416090ccc3cada49910416cd658b8ca89", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 865018fcb..40d2abd54 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,199 +1,238 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n package net.runelite.client.plugins.opponentinfo;\n \n import com.google.inject.Guice;\n import com.google.inject.Inject;\n import com.google.inject.testing.fieldbinder.Bind;\n import com.google.inject.testing.fieldbinder.BoundFieldModule;\n-import net.runelite.api.*;\n+import net.runelite.api.Client;\n import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n import org.junit.Before;\n-import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mock;\n+import org.junit.Test;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import org.mockito.junit.MockitoJUnitRunner;\n-\n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import org.mockito.Mock;\n \n @RunWith(MockitoJUnitRunner.class)\n public class OpponentInfoPluginTest\n {\n-    @Mock\n-    @Bind\n-    Client client;\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig opponentInfoConfig;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n \n-    @Mock\n-    @Bind\n-    OverlayManager overlayManager;\n+\t@Inject\n+\tOpponentInfoPlugin opponentInfoPlugin;\n \n-    @Mock\n-    @Bind\n-    OpponentInfoConfig opponentInfoConfig;\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\t}\n \n-    @Mock\n-    @Bind\n-    OpponentInfoOverlay opponentInfoOverlay;\n+\t/*\n+\t * Verify that the current opponent in multi is always the npc that the player is attacking\n+\t */\n+\t@Test\n+\tpublic void testAttackingEnemyInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-    @Mock\n-    @Bind\n-    PlayerComparisonOverlay playerComparisonOverlay;\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    @Inject\n-    OpponentInfoPlugin opponentInfoPlugin;\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-    @Before\n-    public void before()\n-    {\n-        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n-    }\n+\t\t// some npc attacks the player\n+\t\tInteractingChanged aggroEnemy = new InteractingChanged(aggro, localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-    /*\n-     * Verify that the current opponent in multi is always the npc that the player is attacking\n-     */\n-    @Test\n-    public void testAttackingEnemyInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggro = mock(NPC.class), attacked = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggro, opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player attacks a different npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(attacked);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, attacked));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify the attacked npc is now considered the current opponent\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        InteractingChanged aggroEnemy = new InteractingChanged(aggro, thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacks them back\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggro);\n+\t\t// verify that the current opponent is still the attacked npc\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks a different npc\n-        when(thePlayer.getInteracting()).thenReturn(attacked);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, attacked));\n-        // the npc attacks them back\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, thePlayer));\n+\t\t// the player is attacked by an aggressive npc while attacking a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(aggroEnemy);\n \n-        // verify that the current opponent is now the attacked npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by an aggressive npc while attacking a different npc\n-        opponentInfoPlugin.onInteractingChanged(aggroEnemy);\n+\t\t// the npc attacking the player that is not the current opponent attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n \n-        // the npc attacking the player that is not the current opponent attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggro, otherPlayer));\n+\t\t// the npc the player is attacking, the current opponent, attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n+\t\t// verify that the current opponent is still the npc the player is attacking\n+\t\tassertSame(attacked, opponentInfoPlugin.getLastOpponent());\n+\t}\n \n-        // the npc the player is attacking, the current opponent, attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(attacked, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc while the player is not attacking anything\n+\t */\n+\t@Test\n+\tpublic void testIdleInMulti()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that the current opponent is still the npc the player is attacking\n-        assertSame(opponentInfoPlugin.getLastOpponent(), attacked);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc while the player is not attacking anything\n-     */\n-    @Test\n-    public void testIdleInMulti() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC aggroFirst = mock(NPC.class), aggroRecent = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the current opponent is the aggressive npc\n+\t\tassertSame(aggroFirst, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, thePlayer));\n+\t\t// the player is attacked by a different npc\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, localPlayer));\n \n-        // verify that the current opponent is the aggressive npc\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroFirst);\n+\t\t// verify that the current opponent is the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // the player is attacked by a different npc\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, thePlayer));\n+\t\t// an npc that is not the current opponent targets another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n \n-        // verify that the current opponent is the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that the current opponent is still the most recent aggressor\n+\t\tassertSame(aggroRecent, opponentInfoPlugin.getLastOpponent());\n \n-        // an npc that is not the current opponent targets another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroFirst, otherPlayer));\n+\t\t// the current opponent switches targets to another player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n \n-        // verify that the current opponent is still the most recent aggressor\n-        assertSame(opponentInfoPlugin.getLastOpponent(), aggroRecent);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n \n-        // the current opponent switches targets to another player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(aggroRecent, otherPlayer));\n+\t/*\n+\t * Verify that the current opponent is the expected npc in singles\n+\t */\n+\t@Test\n+\tpublic void testSingles()\n+\t{\n+\t\tPlayer localPlayer = mock(Player.class), otherPlayer = mock(Player.class);\n+\t\tNPC npc = mock(NPC.class);\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-    /*\n-     * Verify that the current opponent is the expected npc in singles\n-     */\n-    @Test\n-    public void testSingles() {\n-        Player thePlayer = mock(Player.class), otherPlayer = mock(Player.class);\n-        NPC playerNPC = mock(NPC.class);\n-        when(client.getLocalPlayer()).thenReturn(thePlayer);\n+\t\t// verify that there is currently no opponent\n+\t\tassertNull(opponentInfoPlugin.getLastOpponent());\n \n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// some npc attacks the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that there is currently no opponent\n-        assertNull(opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the attacking npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // some npc attacks the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc stops attacking the player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify that the attacking npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the player attacks the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(npc);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, npc));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n \n-        // the player attacks the npc\n-        when(thePlayer.getInteracting()).thenReturn(playerNPC);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, playerNPC));\n-        // the npc attacks them back\n-        when(playerNPC.getInteracting()).thenReturn(thePlayer);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, thePlayer));\n+\t\t// the npc attacks them back\n+\t\twhen(npc.getInteracting()).thenReturn(localPlayer);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, localPlayer));\n \n-        // verify that the attacked npc is the current opponent\n-        assertSame(opponentInfoPlugin.getLastOpponent(), playerNPC);\n-        // verify that the hp bar will no longer be hidden\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the attacked npc is the current opponent\n+\t\tassertSame(npc, opponentInfoPlugin.getLastOpponent());\n+\t\t// verify that the hp bar will no longer be hidden\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the player stops attacking the npc\n-        when(thePlayer.getInteracting()).thenReturn(null);\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(thePlayer, null));\n+\t\t// the player stops attacking the npc\n+\t\twhen(localPlayer.getInteracting()).thenReturn(null);\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(localPlayer, null));\n \n-        // verify that the hp bar will not be hidden (because the npc is still attacking the player)\n-        assertNull(opponentInfoPlugin.getLastTime());\n+\t\t// verify that the hp bar will not be hidden (because the npc is still attacking the player)\n+\t\tassertNull(opponentInfoPlugin.getLastTime());\n \n-        // the npc attacks a different player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, otherPlayer));\n+\t\t// the npc attacks a different player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, otherPlayer));\n \n-        // verify that there is no longer an opponent\n-        // (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t\t// verify that there is no longer an opponent\n+\t\t// (if lastTime is not null, then the lastOpponent will become null after OpponentInfoPlugin.WAIT time)\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n \n-        // the npc stops attacking the other player\n-        opponentInfoPlugin.onInteractingChanged(new InteractingChanged(playerNPC, null));\n+\t\t// the npc stops attacking the other player\n+\t\topponentInfoPlugin.onInteractingChanged(new InteractingChanged(npc, null));\n \n-        // verify there is still no opponent\n-        assertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n-    }\n+\t\t// verify there is still no opponent\n+\t\tassertTrue(opponentInfoPlugin.getLastTime() != null || opponentInfoPlugin.getLastOpponent() == null);\n+\t}\n }\n"}}, {"oid": "687ed3f416090ccc3cada49910416cd658b8ca89", "url": "https://github.com/runelite/runelite/commit/687ed3f416090ccc3cada49910416cd658b8ca89", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-02-03T03:45:51Z", "type": "forcePushed"}, {"oid": "ec074325d9962ad9d890634c44b037e476301614", "url": "https://github.com/runelite/runelite/commit/ec074325d9962ad9d890634c44b037e476301614", "message": "opponent info: Add simple interaction tests", "committedDate": "2021-02-10T06:58:27Z", "type": "commit"}, {"oid": "4537d451d0bf6fe6e79468a2376eba5494360bd8", "url": "https://github.com/runelite/runelite/commit/4537d451d0bf6fe6e79468a2376eba5494360bd8", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-02-10T07:09:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTQ1MTI1OA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r581451258", "bodyText": "These tests aren't quite right; they test the behaviour of the current OpponentInfo, but not this one.  This one continues to track the lastOpponent for as long as the player is attacking or being attacked.  So, in testNpcInteractions for example, line 91 should be assertSame(npc, plugin.getLastOpponent()), because the player is being attacked by npc.  Then, on lines 96-97, the last opponent is being remembered for 5 seconds.  Finally, on line 113, even though the player has stopped attacking npc, npc is still attacking the player, so plugin.getLastTime() should be null.", "author": "chaticon", "createdAt": "2021-02-23T22:58:24Z", "path": "runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this\n+ *    list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright notice,\n+ *    this list of conditions and the following disclaimer in the documentation\n+ *    and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package net.runelite.client.plugins.opponentinfo;\n+\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.testing.fieldbinder.Bind;\n+import com.google.inject.testing.fieldbinder.BoundFieldModule;\n+import net.runelite.api.Actor;\n+import net.runelite.api.Client;\n+import net.runelite.api.events.InteractingChanged;\n+import net.runelite.api.NPC;\n+import net.runelite.api.Player;\n+import net.runelite.client.ui.overlay.OverlayManager;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.Test;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.Mock;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OpponentInfoPluginTest\n+{\n+\t@Mock\n+\t@Bind\n+\tClient client;\n+\n+\t@Mock\n+\t@Bind\n+\tOverlayManager overlayManager;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoConfig config;\n+\n+\t@Mock\n+\t@Bind\n+\tOpponentInfoOverlay opponentInfoOverlay;\n+\n+\t@Mock\n+\t@Bind\n+\tPlayerComparisonOverlay playerComparisonOverlay;\n+\n+\t@Inject\n+\tOpponentInfoPlugin plugin;\n+\n+\tprivate final Player localPlayer = mock(Player.class);\n+\n+\t@Before\n+\tpublic void before()\n+\t{\n+\t\tGuice.createInjector(BoundFieldModule.of(this)).injectMembers(this);\n+\n+\t\twhen(client.getLocalPlayer()).thenReturn(localPlayer);\n+\t}\n+\n+\t@Test\n+\tpublic void testNpcInteractions()\n+\t{\n+\t\tfinal NPC npc = mock(NPC.class);\n+\n+\t\tinteractingChanged(npc, localPlayer);\n+\n+\t\tassertNull(plugin.getLastOpponent());", "originalCommit": "ec074325d9962ad9d890634c44b037e476301614", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dc0e901cc5f3ee43846797a3399fa064492c38c", "chunk": "diff --git a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\nindex 4b213bde9..e288170d8 100644\n--- a/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n+++ b/runelite-client/src/test/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPluginTest.java\n\n@@ -1,5 +1,6 @@\n /*\n  * Copyright (c) 2021, Jordan Atwood <jordan.atwood423@gmail.com>\n+ * Copyright (c) 2021, Andre Araya <araya.andre7@gmail.com>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE1NTcxOA==", "url": "https://github.com/runelite/runelite/pull/12990#discussion_r584155718", "bodyText": "Can the case of target == player && opponent != null && opponent != lastOpponent ever happen? You have 4 different paths here:\n\ntarget == player && opponent == null\ntarget == player && opponent != null && opponent != lastOpponent <-- does this happen?\ntarget != player && source == lastOpponent && target == player ... obviously this cannot happen\ntarget != player && source == lastOpponent && opponent != lastOpponent\n\nI think this can't happen because it would require something to attack you while you were attacking something that also wasn't your opponent. And I don't think you can be attacking something which isn't your opponent.\nIf so, this can just be split I think into two separate ifs\nif (target == player && opponent == null) {\n// Case of something attacking you when you aren't in combat\n}\nelse if (source == lastOpponent && opponent != lastOpponent) {\n// Case of something attacking you switching off while you are not attacking it\n}", "author": "Adam-", "createdAt": "2021-02-27T16:45:14Z", "path": "runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java", "diffHunk": "@@ -134,33 +138,48 @@ else if (worldType.contains(WorldType.LEAGUE))\n \t@Subscribe\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n-\t\tif (event.getSource() != client.getLocalPlayer())\n-\t\t{\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tActor opponent = event.getTarget();\n+\t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor source = event.getSource();\n+\t\tfinal Actor target = event.getTarget();\n \n-\t\tif (opponent == null)\n+\t\tif (source == player)\n \t\t{\n-\t\t\tlastTime = Instant.now();\n-\t\t\treturn;\n+\t\t\tif (target != null)\n+\t\t\t{\n+\t\t\t\tlastOpponent = target;\n+\t\t\t\tlastTime = null;\n+\t\t\t}\n+\t\t\telse if (lastOpponent != null\n+\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t{\n+\t\t\t\tlastTime = Instant.now();\n+\t\t\t}\n \t\t}\n+\t\telse if (target == player", "originalCommit": "4537d451d0bf6fe6e79468a2376eba5494360bd8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dc0e901cc5f3ee43846797a3399fa064492c38c", "chunk": "diff --git a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\nindex 8429d1499..52732ceb3 100644\n--- a/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n+++ b/runelite-client/src/main/java/net/runelite/client/plugins/opponentinfo/OpponentInfoPlugin.java\n\n@@ -139,36 +139,34 @@ public class OpponentInfoPlugin extends Plugin\n \tpublic void onInteractingChanged(InteractingChanged event)\n \t{\n \t\tfinal Actor player = client.getLocalPlayer();\n+\t\tfinal Actor opponent = player.getInteracting();\n \t\tfinal Actor source = event.getSource();\n \t\tfinal Actor target = event.getTarget();\n \n \t\tif (source == player)\n \t\t{\n+\t\t\t// You have attacked an enemy\n \t\t\tif (target != null)\n \t\t\t{\n \t\t\t\tlastOpponent = target;\n \t\t\t\tlastTime = null;\n \t\t\t}\n-\t\t\telse if (lastOpponent != null\n-\t\t\t\t&& lastOpponent.getInteracting() != player)\n+\t\t\t// You have stopped attacking an enemy which is not attacking you\n+\t\t\telse if (lastOpponent != null && lastOpponent.getInteracting() != player)\n \t\t\t{\n \t\t\t\tlastTime = Instant.now();\n \t\t\t}\n \t\t}\n-\t\telse if (target == player\n-\t\t\t|| source == lastOpponent)\n+\t\t// You are attacked while not attacking anything\n+\t\telse if (target == player && opponent == null)\n \t\t{\n-\t\t\tActor opponent = player.getInteracting();\n-\n-\t\t\tif (target == player && opponent == null)\n-\t\t\t{\n-\t\t\t\tlastOpponent = source;\n-\t\t\t\tlastTime = null;\n-\t\t\t}\n-\t\t\telse if (opponent != lastOpponent)\n-\t\t\t{\n-\t\t\t\tlastTime = Instant.now();\n-\t\t\t}\n+\t\t\tlastOpponent = source;\n+\t\t\tlastTime = null;\n+\t\t}\n+\t\t// An enemy which was previously attacking you (which you were not attacking back) has changed its target\n+\t\telse if (source == lastOpponent && opponent != lastOpponent)\n+\t\t{\n+\t\t\tlastTime = Instant.now();\n \t\t}\n \t}\n \n"}}, {"oid": "6dc0e901cc5f3ee43846797a3399fa064492c38c", "url": "https://github.com/runelite/runelite/commit/6dc0e901cc5f3ee43846797a3399fa064492c38c", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-03-02T06:57:47Z", "type": "forcePushed"}, {"oid": "8311eeb0e3b066b81cdde3b9958bab15a5e8fef2", "url": "https://github.com/runelite/runelite/commit/8311eeb0e3b066b81cdde3b9958bab15a5e8fef2", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-03-02T07:01:37Z", "type": "commit"}, {"oid": "8311eeb0e3b066b81cdde3b9958bab15a5e8fef2", "url": "https://github.com/runelite/runelite/commit/8311eeb0e3b066b81cdde3b9958bab15a5e8fef2", "message": "opponentinfo: Show health bar of actors attacking the player", "committedDate": "2021-03-02T07:01:37Z", "type": "forcePushed"}]}