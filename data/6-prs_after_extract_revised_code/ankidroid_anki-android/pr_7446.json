{"pr_number": 7446, "pr_title": "Cache result of a part of _availClozeOrds", "pr_createdAt": "2020-10-23T08:22:45Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/7446", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNjE3NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/7446#discussion_r510906175", "bodyText": "cache coherency question: is it possible to change the question in some way via note editor or similar after it has been entered in this cache, such that the field still exists, and did have a cloze but no longer has a cloze, yet comes back in the return array here still because it was not knocked out of the cache after edit?", "author": "mikehardy", "createdAt": "2020-10-23T14:02:49Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Models.java", "diffHunk": "@@ -1105,18 +1105,28 @@ private void _updateRequired(Model m) {\n         return _availClozeOrds(m, sflds, true);\n     }\n \n+    /**\n+     * Cache of getNamesOfFieldsContainingCloze\n+     * Computing hash of string is costly. However, hash is cashed in the string object, so this virtually ensure that\n+     * given a card type, we don't nede to recompute the hash.\n+     */\n+    private static HashMap<String, List<String>> namesOfFieldsContainingClozeCache = new HashMap<>();\n+\n     /** The name of all fields that are used as cloze in the question.\n      * It is not guaranteed that the field found are actually the name of any field of the note type.*/\n     @VisibleForTesting\n     protected static List<String> getNamesOfFieldsContainingCloze(String question) {\n-        List<String> matches = new ArrayList<>();\n-        for (Pattern pattern : new Pattern[]{fClozePattern1, fClozePattern2}) {\n-             Matcher mm = pattern.matcher(question);\n-             while (mm.find()) {\n-                 matches.add(mm.group(1));\n-             }\n+        if (! namesOfFieldsContainingClozeCache.containsKey(question)) {", "originalCommit": "c22a7183f2f778ef9064faa9947cbb6c00a1b4da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwOTU0Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/7446#discussion_r510909546", "bodyText": "I really have trouble understanding your question. Seems unusually long. I'll answer with informations that may hopefully answer.\nYou may note that this method is static and takes a simple string, the question template. It does not consider whether something is really a field or note. If the template contains {{cloze:foobar}}, then it adds foobar to the list, whether or not foobar is actually a field. The caller will process the list and figure out what is and what is not a field. That's not a problem, because what takes a lot of time is regexp, matching pattern. Filtering a list is quick.", "author": "Arthur-Milchior", "createdAt": "2020-10-23T14:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5MzI2OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/7446#discussion_r511493268", "bodyText": "Ah I see, so in order for the cache to become incorrect (contain a stale entry) the question itself would have to change, at which point the String argument question would have a question.hashCode that's different so it would no longer match. If I understand that correctly then this could work.\nMy only fear now then is that question templates can get quite large, keeping a static cache of them could result in a great deal of memory use. If you only need the original question template string to do the regex the first time, and then after that you are just using it as a key, perhaps you could make the key the hashCode of the string itself, and check based on it directly? Then the map would only be storing hashcodes instead of user-supplied / unbounded data?", "author": "mikehardy", "createdAt": "2020-10-24T17:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5NDU2Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/7446#discussion_r511494566", "bodyText": "I do not share you fear. Question template can be large, indeed. However, the string saved in the cache are in a card type in a note type in the model manager. That means that saving the string does not actually takes more space.\nOf course, if a string no longer exists (e.g. it is changed, card type removed, etc...) then this keep the string in memory, so I should actually use a WeakHashMap\nUsing the hash value as entry is theoretically a bad idea; it would only work if we assume that no two strings ever get the same hash value... which is clearly realistic. Hashing of string is not a secure hashing, so an adversary could create collision if they try, but I don't believe we should try to consider this kind of problems", "author": "Arthur-Milchior", "createdAt": "2020-10-24T17:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5NTAzNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/7446#discussion_r511495035", "bodyText": "Agreed we are not worried about hash collisions, And yes, if Strings are immutable and passed by reference as they are in Java, and they are stored elsewhere then this should consume more memory, with your change to WeakHashMap I think my fears are all addressed", "author": "mikehardy", "createdAt": "2020-10-24T17:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNjE3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "46e55588b73c236b2acd0ef475f5747200573efa", "chunk": "diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Models.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Models.java\nindex 641edc1d1..0690bccc7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Models.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Models.java\n\n@@ -1069,77 +1129,49 @@ public class Models {\n             int ord = sr.getInt(0);\n             String type = sr.getString(1);\n             JSONArray req = sr.getJSONArray(2);\n-\n-            switch (type) {\n-                case REQ_NONE:\n-                    // unsatisfiable template\n-                    continue;\n-                case REQ_ALL:\n-                    // AND requirement?\n-                    for (int j = 0; j < req.length(); j++) {\n-                        int idx = req.getInt(j);\n-                        if (fields[idx] == null || fields[idx].length() == 0) {\n-                            // missing and was required\n-                            continue templates;\n-                        }\n-                    }\n-                    avail.add(ord);\n-                    continue;\n-                case REQ_ANY:\n-                    // OR requirement?\n-                    for (int j = 0; j < req.length(); j++) {\n-                        int idx = req.getInt(j);\n-                        if (fields[idx] != null && fields[idx].length() != 0) {\n-                            // missing and was required\n-                            avail.add(ord);\n-                            continue templates;\n-                        }\n-                    }\n-                }\n+            if (!emptyStandardCard(type, req, fields)) {\n+                avail.add(ord);\n+            }\n         }\n         return avail;\n     }\n \n \n-    public ArrayList<Integer> _availClozeOrds(Model m, String[] sflds) {\n-        return _availClozeOrds(m, sflds, true);\n-    }\n-\n     /**\n-     * Cache of getNamesOfFieldsContainingCloze\n-     * Computing hash of string is costly. However, hash is cashed in the string object, so this virtually ensure that\n-     * given a card type, we don't nede to recompute the hash.\n+     * @param m A note type with cloze\n+     * @param sflds The fields of a note of type m. (Assume the size of the array is the number of fields)\n+     * @return The indexes (in increasing order) of cards that should be generated according to req rules.\n      */\n-    private static HashMap<String, List<String>> namesOfFieldsContainingClozeCache = new HashMap<>();\n-\n-    /** The name of all fields that are used as cloze in the question.\n-     * It is not guaranteed that the field found are actually the name of any field of the note type.*/\n-    @VisibleForTesting\n-    protected static List<String> getNamesOfFieldsContainingCloze(String question) {\n-        if (! namesOfFieldsContainingClozeCache.containsKey(question)) {\n-            List<String> matches = new ArrayList<>();\n-            for (Pattern pattern : new Pattern[] {fClozePattern1, fClozePattern2}) {\n-                Matcher mm = pattern.matcher(question);\n-                while (mm.find()) {\n-                    matches.add(mm.group(1));\n-                }\n-            }\n-            namesOfFieldsContainingClozeCache.put(question, matches);\n-        }\n-        return namesOfFieldsContainingClozeCache.get(question);\n+    public static ArrayList<Integer> _availClozeOrds(Model m, String[] sflds) {\n+        return _availClozeOrds(m, sflds, true);\n     }\n \n-    public ArrayList<Integer> _availClozeOrds(Model m, String[] sflds, boolean allowEmpty) {\n+\n+    /**\n+     * @param m A note type with cloze\n+     * @param sflds The fields of a note of type m. (Assume the size of the array is the number of fields)\n+     * @param allowEmpty Whether we allow to generate at least one card even if they are all empty\n+     * @return The indexes (in increasing order) of cards that should be generated according to req rules.\n+     * If empty is not allowed, it will contains ord 1.*/\n+    public static ArrayList<Integer> _availClozeOrds(Model m, String[] sflds, boolean allowEmpty) {\n         Map<String, Pair<Integer, JSONObject>> map = fieldMap(m);\n         String question = m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\");\n         Set<Integer> ords = new HashSet<>();\n-        List<String> matches = getNamesOfFieldsContainingCloze(question);\n+        List<String> matches = new ArrayList<>();\n+        Matcher mm = fClozePattern1.matcher(question);\n+        while (mm.find()) {\n+            matches.add(mm.group(1));\n+        }\n+        mm = fClozePattern2.matcher(question);\n+        while (mm.find()) {\n+            matches.add(mm.group(1));\n+        }\n         for (String fname : matches) {\n             if (!map.containsKey(fname)) {\n                 continue;\n             }\n             int ord = map.get(fname).first;\n-            Matcher mm = fClozeOrdPattern.matcher(sflds[ord]);\n+            mm = fClozeOrdPattern.matcher(sflds[ord]);\n             while (mm.find()) {\n                 ords.add(Integer.parseInt(mm.group(1)) - 1);\n             }\n"}}, {"oid": "46e55588b73c236b2acd0ef475f5747200573efa", "url": "https://github.com/ankidroid/Anki-Android/commit/46e55588b73c236b2acd0ef475f5747200573efa", "message": "NF: extracting a variable", "committedDate": "2020-10-24T17:21:21Z", "type": "commit"}, {"oid": "374deaf7237c25fe84863f5758a859af19f8f4a7", "url": "https://github.com/ankidroid/Anki-Android/commit/374deaf7237c25fe84863f5758a859af19f8f4a7", "message": "NF: factorize duplicated code", "committedDate": "2020-10-24T17:21:21Z", "type": "commit"}, {"oid": "0ab105384a476e0b6d3616cbe3a1fd504a36f7c8", "url": "https://github.com/ankidroid/Anki-Android/commit/0ab105384a476e0b6d3616cbe3a1fd504a36f7c8", "message": "NF: extract getNamesOfFieldContainingCloze", "committedDate": "2020-10-24T17:28:47Z", "type": "commit"}, {"oid": "603f2020fe3794ceaf285cfc09007b284242ca53", "url": "https://github.com/ankidroid/Anki-Android/commit/603f2020fe3794ceaf285cfc09007b284242ca53", "message": "NF: cache getNamesOfFieldsContainingCloze", "committedDate": "2020-10-24T17:28:48Z", "type": "commit"}, {"oid": "603f2020fe3794ceaf285cfc09007b284242ca53", "url": "https://github.com/ankidroid/Anki-Android/commit/603f2020fe3794ceaf285cfc09007b284242ca53", "message": "NF: cache getNamesOfFieldsContainingCloze", "committedDate": "2020-10-24T17:28:48Z", "type": "forcePushed"}]}