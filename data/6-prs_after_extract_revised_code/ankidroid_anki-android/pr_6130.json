{"pr_number": 6130, "pr_title": "Allow conditional field inside itself", "pr_createdAt": "2020-05-08T18:24:28Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6130", "timeline": [{"oid": "c9ce008a58d21fb77e73073e03a7c887f8dddd30", "url": "https://github.com/ankidroid/Anki-Android/commit/c9ce008a58d21fb77e73073e03a7c887f8dddd30", "message": "Add template parsing unit test", "committedDate": "2020-05-08T19:09:56Z", "type": "forcePushed"}, {"oid": "63b6383d9a6a8832ef89ad3ad2bf341ae3a3402d", "url": "https://github.com/ankidroid/Anki-Android/commit/63b6383d9a6a8832ef89ad3ad2bf341ae3a3402d", "message": "Add template parsing unit test", "committedDate": "2020-05-08T19:32:27Z", "type": "forcePushed"}, {"oid": "9c0c501aa5b29dacb1748655444c3b66cf166059", "url": "https://github.com/ankidroid/Anki-Android/commit/9c0c501aa5b29dacb1748655444c3b66cf166059", "message": "Add template parsing unit test", "committedDate": "2020-05-08T19:33:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzY4Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422347682", "bodyText": "PERF: can this be modified so we're not calling StringBuffer.toString on each iteration?", "author": "david-allison-1", "createdAt": "2020-05-08T20:06:41Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);\n+                if (!field_is_empty) {\n+                    if (section.charAt(2) != '^') {\n+                        replacer = render_sections(inner, context);\n+                    }\n+                } else if (field_is_empty && section.charAt(2) == '^') {\n                     replacer = render_sections(inner, context);\n                 }\n-            } else if (field_is_empty && section.charAt(2) == '^') {\n-                replacer = render_sections(inner, context);\n+                match.appendReplacement(sb, Matcher.quoteReplacement(replacer));\n             }\n-            match.appendReplacement(sb, Matcher.quoteReplacement(replacer));\n-        }\n-        match.appendTail(sb);\n-        return sb.toString();\n+            match.appendTail(sb);\n+            template = sb.toString();", "originalCommit": "9c0c501aa5b29dacb1748655444c3b66cf166059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzk4OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422393988", "bodyText": "I don't believe we can. I don't believe it's a problem either.\nIt is not a problem because there is a single iteration normally. The only case where there is multiple iteration is when a conditional contains itself, or when a conditional contains the start/end of another conditional and the end/start is outside of the conditional. I.e. either the example which cause this PR to existence, or something which is even more broken.\nBoth cases were already broken without my change, and only worked sometime only for some specific combination of fields being filled/empty.\nThe reason why I can not avoid using toString is that I want to run a regexp over the string. I can not run the regexp over a buffer.\nI would like to emphasize that reverting #6073 would probably not increase the performance. The previous code didn't even use buffer, and just called String.replace as many time as they were fields and conditional.", "author": "Arthur-Milchior", "createdAt": "2020-05-08T21:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5NjQyMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422396422", "bodyText": "Sounds good to me", "author": "david-allison-1", "createdAt": "2020-05-08T22:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzY4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "793136a6ead8961b338f2a390b61b8d181a6fa5f", "chunk": "diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java b/AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java\nindex 8ada7e63d..cad1f5335 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java\n\n@@ -158,8 +158,8 @@ public class Template {\n \n                 if (!field_is_empty) {\n                     it = Utils.stripHTMLMedia(it).trim();\n+                    field_is_empty = TextUtils.isEmpty(it);\n                 }\n-                field_is_empty = TextUtils.isEmpty(it);\n                 if (!field_is_empty) {\n                     if (section.charAt(2) != '^') {\n                         replacer = render_sections(inner, context);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk1Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422361957", "bodyText": "Nit: Move up one line for clarity", "author": "david-allison-1", "createdAt": "2020-05-08T20:38:33Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);", "originalCommit": "b5f9dd8480f017bf7476b722fdacca45f0df1f76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5MTYyMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422391621", "bodyText": "I don't understand what you mean here. What should I move ?", "author": "Arthur-Milchior", "createdAt": "2020-05-08T21:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5MzI2Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422393263", "bodyText": "field_is_empty/it is only mutated if the branch is taken, you can move it inside the if statement for clarity.", "author": "david-allison-1", "createdAt": "2020-05-08T21:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTQ0NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422399444", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-05-08T22:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "793136a6ead8961b338f2a390b61b8d181a6fa5f", "chunk": "diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java b/AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java\nindex 8ada7e63d..cad1f5335 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java\n\n@@ -158,8 +158,8 @@ public class Template {\n \n                 if (!field_is_empty) {\n                     it = Utils.stripHTMLMedia(it).trim();\n+                    field_is_empty = TextUtils.isEmpty(it);\n                 }\n-                field_is_empty = TextUtils.isEmpty(it);\n                 if (!field_is_empty) {\n                     if (section.charAt(2) != '^') {\n                         replacer = render_sections(inner, context);\n"}}, {"oid": "793136a6ead8961b338f2a390b61b8d181a6fa5f", "url": "https://github.com/ankidroid/Anki-Android/commit/793136a6ead8961b338f2a390b61b8d181a6fa5f", "message": "Add template parsing unit test", "committedDate": "2020-05-08T22:12:36Z", "type": "forcePushed"}, {"oid": "e1420a51e619e334797394a313fe4fb465ec1bac", "url": "https://github.com/ankidroid/Anki-Android/commit/e1420a51e619e334797394a313fe4fb465ec1bac", "message": "Apply render_sections until a fixpoint is reached.\n\nUsually, this should not be useful. Normally all conditionals are\nreplaced simultaneously, unless the template is so bad that computing\nsome conditional create some new conditional.\n\nAnyway, each call to render_some_section reduce the size of the string\nreturned, so it ends eventually. Note that the old code of Ankidroid\nalready also does a loop which waits for a fixpoint to occur. So it's\nsimilar to previous code; except that we try to do multiple change in\nthe same buffer to win time.\n\nThis corrects #6123.\n\nAnki up to 2.1.17 does not deal correctly with a conditional field\ncontaining the same conditional field. AnkiDroid didn't\neither. However, it still worked as long as all conditions evaluates\nto true, and broke only when a condition evaluates to False. If a\ncondition evaluated to False, an error message would be raised.\n\nI am copying back this rules. All evaluations to True still products\nthe same result as before. A conditional evaluated to False produce an\nerror message.\n\nI personally am not convinced at all that this is relevant. Saying\n\"you can used a conditional nested in the same conditional only when\nall conditionals evaluate to true\" is more confusing than saying that\nthis feature is not supported. However, as I'm not the maintener and I\nbroke this feature, I correct it.", "committedDate": "2020-05-08T22:36:35Z", "type": "forcePushed"}, {"oid": "b0073e2d7ae5ab8ad22ad196e94195674642ab1a", "url": "https://github.com/ankidroid/Anki-Android/commit/b0073e2d7ae5ab8ad22ad196e94195674642ab1a", "message": "Apply render_sections until a fixpoint is reached.\n\nUsually, this should not be useful. Normally all conditionals are\nreplaced simultaneously, unless the template is so bad that computing\nsome conditional create some new conditional.\n\nAnyway, each call to render_some_section reduce the size of the string\nreturned, so it ends eventually. Note that the old code of Ankidroid\nalready also does a loop which waits for a fixpoint to occur. So it's\nsimilar to previous code; except that we try to do multiple change in\nthe same buffer to win time.\n\nThis corrects #6123.\n\nAnki up to 2.1.17 does not deal correctly with a conditional field\ncontaining the same conditional field. AnkiDroid didn't\neither. However, it still worked as long as all conditions evaluates\nto true, and broke only when a condition evaluates to False. If a\ncondition evaluated to False, an error message would be raised.\n\nI am copying back this rules. All evaluations to True still products\nthe same result as before. A conditional evaluated to False produce an\nerror message.\n\nI personally am not convinced at all that this is relevant. Saying\n\"you can used a conditional nested in the same conditional only when\nall conditionals evaluate to true\" is more confusing than saying that\nthis feature is not supported. However, as I'm not the maintener and I\nbroke this feature, I correct it.", "committedDate": "2020-05-09T08:58:24Z", "type": "forcePushed"}, {"oid": "4380284fa634cedf6eccf0de80b0572a64192927", "url": "https://github.com/ankidroid/Anki-Android/commit/4380284fa634cedf6eccf0de80b0572a64192927", "message": "Apply render_sections until a fixpoint is reached.\n\nUsually, this should not be useful. Normally all conditionals are\nreplaced simultaneously, unless the template is so bad that computing\nsome conditional create some new conditional.\n\nAnyway, each call to render_some_section reduce the size of the string\nreturned, so it ends eventually. Note that the old code of Ankidroid\nalready also does a loop which waits for a fixpoint to occur. So it's\nsimilar to previous code; except that we try to do multiple change in\nthe same buffer to win time.\n\nThis corrects #6123.\n\nAnki up to 2.1.17 does not deal correctly with a conditional field\ncontaining the same conditional field. AnkiDroid didn't\neither. However, it still worked as long as all conditions evaluates\nto true, and broke only when a condition evaluates to False. If a\ncondition evaluated to False, an error message would be raised.\n\nI am copying back this rules. All evaluations to True still products\nthe same result as before. A conditional evaluated to False produce an\nerror message.\n\nI personally am not convinced at all that this is relevant. Saying\n\"you can used a conditional nested in the same conditional only when\nall conditionals evaluate to true\" is more confusing than saying that\nthis feature is not supported. However, as I'm not the maintener and I\nbroke this feature, I correct it.", "committedDate": "2020-05-09T09:05:44Z", "type": "forcePushed"}, {"oid": "be2040601022c2a98eb710feaed82ca01bfd3b38", "url": "https://github.com/ankidroid/Anki-Android/commit/be2040601022c2a98eb710feaed82ca01bfd3b38", "message": "template: directly trim section name", "committedDate": "2020-05-09T10:31:47Z", "type": "forcePushed"}, {"oid": "310910d26751935b93a09837453f14e9f9125227", "url": "https://github.com/ankidroid/Anki-Android/commit/310910d26751935b93a09837453f14e9f9125227", "message": "template: directly trim section name", "committedDate": "2020-05-09T10:44:31Z", "type": "forcePushed"}, {"oid": "ca5049af50d415e26150ea4478064e2edca285a8", "url": "https://github.com/ankidroid/Anki-Android/commit/ca5049af50d415e26150ea4478064e2edca285a8", "message": "template: directly trim section name", "committedDate": "2020-05-09T10:48:26Z", "type": "forcePushed"}, {"oid": "0d982b38731342fb640f55945123d7ca5db68b0b", "url": "https://github.com/ankidroid/Anki-Android/commit/0d982b38731342fb640f55945123d7ca5db68b0b", "message": "Do no do recursive call to render_sections\n\nThere were useful when the rendering was done in only a single read of\nthe template.\n\nNow that the template is read an arbitrary number of time, we know\nthat the inner templates will be discovered later. Reading a string to\nsearch a pattern in it is slow, this will ensure that the inner string\nis read only twice instead of thrice when it contains no conditional.", "committedDate": "2020-05-09T11:00:50Z", "type": "forcePushed"}, {"oid": "c749c930ec253b8c2d0df085dc91e16afd08fae8", "url": "https://github.com/ankidroid/Anki-Android/commit/c749c930ec253b8c2d0df085dc91e16afd08fae8", "message": "Add template parsing unit test", "committedDate": "2020-05-09T13:30:40Z", "type": "commit"}, {"oid": "7ef3d4442a35a5c065985a21c7cde272c2eb6d91", "url": "https://github.com/ankidroid/Anki-Android/commit/7ef3d4442a35a5c065985a21c7cde272c2eb6d91", "message": "Apply render_sections until a fixpoint is reached.\n\nUsually, this should not be useful. Normally all conditionals are\nreplaced simultaneously, unless the template is so bad that computing\nsome conditional create some new conditional.\n\nAnyway, each call to render_some_section reduce the size of the string\nreturned, so it ends eventually. Note that the old code of Ankidroid\nalready also does a loop which waits for a fixpoint to occur. So it's\nsimilar to previous code; except that we try to do multiple change in\nthe same buffer to win time.\n\nThis corrects #6123.\n\nAnki up to 2.1.17 does not deal correctly with a conditional field\ncontaining the same conditional field. AnkiDroid didn't\neither. However, it still worked as long as all conditions evaluates\nto true, and broke only when a condition evaluates to False. If a\ncondition evaluated to False, an error message would be raised.\n\nI am copying back this rules. All evaluations to True still products\nthe same result as before. A conditional evaluated to False produce an\nerror message.\n\nI personally am not convinced at all that this is relevant. Saying\n\"you can used a conditional nested in the same conditional only when\nall conditionals evaluate to true\" is more confusing than saying that\nthis feature is not supported. However, as I'm not the maintener and I\nbroke this feature, I correct it.", "committedDate": "2020-05-09T13:30:40Z", "type": "commit"}, {"oid": "284fd6a765f8625195c980beb5d0dc2b671562db", "url": "https://github.com/ankidroid/Anki-Android/commit/284fd6a765f8625195c980beb5d0dc2b671562db", "message": "Do no do recursive call to render_sections\n\nThere were useful when the rendering was done in only a single read of\nthe template.\n\nNow that the template is read an arbitrary number of time, we know\nthat the inner templates will be discovered later. Reading a string to\nsearch a pattern in it is slow, this will ensure that the inner string\nis read only twice instead of thrice when it contains no conditional.", "committedDate": "2020-05-09T13:30:40Z", "type": "commit"}, {"oid": "284fd6a765f8625195c980beb5d0dc2b671562db", "url": "https://github.com/ankidroid/Anki-Android/commit/284fd6a765f8625195c980beb5d0dc2b671562db", "message": "Do no do recursive call to render_sections\n\nThere were useful when the rendering was done in only a single read of\nthe template.\n\nNow that the template is read an arbitrary number of time, we know\nthat the inner templates will be discovered later. Reading a string to\nsearch a pattern in it is slow, this will ensure that the inner string\nis read only twice instead of thrice when it contains no conditional.", "committedDate": "2020-05-09T13:30:40Z", "type": "forcePushed"}]}