{"pr_number": 1160, "pr_title": "Add config to capture stacktrace when a span duration exceeds threshold", "pr_createdAt": "2020-01-03T01:40:10Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1160", "timeline": [{"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c", "url": "https://github.com/DataDog/dd-trace-java/commit/ca4c27253d72584e06dbff28aeaf4e8c6324866c", "message": "Add config to capture stacktrace when a span duration exceeds threshold\n\n(But only when span is not errored or finished on a different thread.)\n\nUse the following config:\n```\n-Ddd.trace.span.duration.stacktrace.millis=1000\n```\n(One second is the default, 0 disables.)", "committedDate": "2020-01-03T03:32:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NDM3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362844376", "bodyText": "Long term, I'd like to get away from the use of Singletons like Config -- but for now, I think this is fine.", "author": "dougqh", "createdAt": "2020-01-03T15:15:13Z", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();", "originalCommit": "ca4c27253d72584e06dbff28aeaf4e8c6324866c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77b22327908ea67485a935187738c2e3e6b1f772", "chunk": "diff --git a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\nindex 5362533551..d1b56d6421 100644\n--- a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n+++ b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n\n@@ -98,101 +96,28 @@ public class DDSpan implements Span, MutableSpan {\n \n   private void addStacktraceIfThresholdExceeded() {\n     final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n-    if (!isError()\n-        && spanDurationStacktraceNanos > 0\n-        && durationNano.get() > spanDurationStacktraceNanos\n+    if (isError()\n+        || spanDurationStacktraceNanos <= 0\n+        || durationNano.get() <= spanDurationStacktraceNanos\n         // If this span was finished async, then the stacktrace will be less meaningful.\n-        && context.threadId == Thread.currentThread().getId()) {\n-      final Exception stacktrace = new Exception();\n-      final Writer stackString = new FilteredStringWriter();\n-      stacktrace.printStackTrace(new PrintWriter(stackString));\n-      setTag(\"slow.stack\", stackString.toString());\n+        || context.threadId != Thread.currentThread().getId()) {\n+      return;\n     }\n-  }\n-\n-  // Writer that skips the first line and lines until FILTER doesn't match.\n-  private static final class FilteredStringWriter extends Writer {\n-    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n-\n-    private final StringWriter writer = new StringWriter();\n-\n-    private State state = State.SKIP_LINE; // Skip the exception type and message\n-    private StringBuilder buffer = new StringBuilder();\n-    private int lineIndex = 0;\n-\n-    @Override\n-    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-      if ((off < 0)\n-          || (off > cbuf.length)\n-          || (len < 0)\n-          || ((off + len) > cbuf.length)\n-          || ((off + len) < 0)) {\n-        throw new IndexOutOfBoundsException();\n-      } else if (len == 0) {\n-        return;\n-      }\n-\n-      for (int i = off; i < len; i++) {\n-        switch (state) {\n-          case SKIP_LINE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.READ_LINE;\n-              lineIndex = 0;\n-            }\n-            break;\n-\n-          case READ_LINE:\n-            if (lineIndex == FILTER.length) {\n-              state = State.SKIP_LINE;\n-              buffer = new StringBuilder();\n-            } else if (cbuf[i] == FILTER[lineIndex]) {\n-              buffer.append(cbuf[i]);\n-              lineIndex++;\n-            } else {\n-              // writer.write(buffer.toString());\n-              // writer.write(cbuf[i]);\n-              // buffer = new StringBuilder();\n-              // state = State.CONTINUE;\n-              state = State.SKIP_NEXT_LINE_THEN_CONTINUE;\n-            }\n-            continue;\n-\n-          case SKIP_NEXT_LINE_THEN_CONTINUE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.CONTINUE;\n-            }\n-            break;\n-\n-          case CONTINUE:\n-            writer.write(cbuf, i, len - (i - off));\n-            return;\n-        }\n+    final StringBuilder stack = new StringBuilder();\n+    // TODO: use StackWalker api for java 9+ jvm's?\n+    boolean skipNext = true;\n+    for (final StackTraceElement element : Thread.currentThread().getStackTrace()) {\n+      final boolean tracingClass = element.getClassName().startsWith(\"datadog.opentracing.\");\n+      if (skipNext || tracingClass) {\n+        skipNext = tracingClass;\n+        continue;\n       }\n+      stack.append(\"\\tat \");\n+      stack.append(element);\n+      stack.append(\"\\n\");\n     }\n-\n-    @Override\n-    public void flush() {\n-      writer.flush();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-      writer.close();\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return buffer.toString() + writer.toString();\n-    }\n-\n-    private enum State {\n-      READ_LINE,\n-      SKIP_LINE,\n-      SKIP_NEXT_LINE_THEN_CONTINUE,\n-      CONTINUE\n-    }\n+    // Prob not worth dealing with the trailing newline.\n+    setTag(\"slow.stack\", stack.toString());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NTE2MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362845161", "bodyText": "Why not call Thread.getStackTraceElement[] instead?\nIdeally, we also use the frame walking API on newer versions of Java, but that can wait until later.", "author": "dougqh", "createdAt": "2020-01-03T15:17:23Z", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n+    if (!isError()\n+        && spanDurationStacktraceNanos > 0\n+        && durationNano.get() > spanDurationStacktraceNanos\n+        // If this span was finished async, then the stacktrace will be less meaningful.\n+        && context.threadId == Thread.currentThread().getId()) {\n+      final Exception stacktrace = new Exception();", "originalCommit": "ca4c27253d72584e06dbff28aeaf4e8c6324866c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77b22327908ea67485a935187738c2e3e6b1f772", "chunk": "diff --git a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\nindex 5362533551..d1b56d6421 100644\n--- a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n+++ b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n\n@@ -98,101 +96,28 @@ public class DDSpan implements Span, MutableSpan {\n \n   private void addStacktraceIfThresholdExceeded() {\n     final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n-    if (!isError()\n-        && spanDurationStacktraceNanos > 0\n-        && durationNano.get() > spanDurationStacktraceNanos\n+    if (isError()\n+        || spanDurationStacktraceNanos <= 0\n+        || durationNano.get() <= spanDurationStacktraceNanos\n         // If this span was finished async, then the stacktrace will be less meaningful.\n-        && context.threadId == Thread.currentThread().getId()) {\n-      final Exception stacktrace = new Exception();\n-      final Writer stackString = new FilteredStringWriter();\n-      stacktrace.printStackTrace(new PrintWriter(stackString));\n-      setTag(\"slow.stack\", stackString.toString());\n+        || context.threadId != Thread.currentThread().getId()) {\n+      return;\n     }\n-  }\n-\n-  // Writer that skips the first line and lines until FILTER doesn't match.\n-  private static final class FilteredStringWriter extends Writer {\n-    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n-\n-    private final StringWriter writer = new StringWriter();\n-\n-    private State state = State.SKIP_LINE; // Skip the exception type and message\n-    private StringBuilder buffer = new StringBuilder();\n-    private int lineIndex = 0;\n-\n-    @Override\n-    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-      if ((off < 0)\n-          || (off > cbuf.length)\n-          || (len < 0)\n-          || ((off + len) > cbuf.length)\n-          || ((off + len) < 0)) {\n-        throw new IndexOutOfBoundsException();\n-      } else if (len == 0) {\n-        return;\n-      }\n-\n-      for (int i = off; i < len; i++) {\n-        switch (state) {\n-          case SKIP_LINE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.READ_LINE;\n-              lineIndex = 0;\n-            }\n-            break;\n-\n-          case READ_LINE:\n-            if (lineIndex == FILTER.length) {\n-              state = State.SKIP_LINE;\n-              buffer = new StringBuilder();\n-            } else if (cbuf[i] == FILTER[lineIndex]) {\n-              buffer.append(cbuf[i]);\n-              lineIndex++;\n-            } else {\n-              // writer.write(buffer.toString());\n-              // writer.write(cbuf[i]);\n-              // buffer = new StringBuilder();\n-              // state = State.CONTINUE;\n-              state = State.SKIP_NEXT_LINE_THEN_CONTINUE;\n-            }\n-            continue;\n-\n-          case SKIP_NEXT_LINE_THEN_CONTINUE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.CONTINUE;\n-            }\n-            break;\n-\n-          case CONTINUE:\n-            writer.write(cbuf, i, len - (i - off));\n-            return;\n-        }\n+    final StringBuilder stack = new StringBuilder();\n+    // TODO: use StackWalker api for java 9+ jvm's?\n+    boolean skipNext = true;\n+    for (final StackTraceElement element : Thread.currentThread().getStackTrace()) {\n+      final boolean tracingClass = element.getClassName().startsWith(\"datadog.opentracing.\");\n+      if (skipNext || tracingClass) {\n+        skipNext = tracingClass;\n+        continue;\n       }\n+      stack.append(\"\\tat \");\n+      stack.append(element);\n+      stack.append(\"\\n\");\n     }\n-\n-    @Override\n-    public void flush() {\n-      writer.flush();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-      writer.close();\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return buffer.toString() + writer.toString();\n-    }\n-\n-    private enum State {\n-      READ_LINE,\n-      SKIP_LINE,\n-      SKIP_NEXT_LINE_THEN_CONTINUE,\n-      CONTINUE\n-    }\n+    // Prob not worth dealing with the trailing newline.\n+    setTag(\"slow.stack\", stack.toString());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NTU4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362845585", "bodyText": "I'd like to see a health metric for anomalous situations as well.", "author": "dougqh", "createdAt": "2020-01-03T15:18:25Z", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n+    if (!isError()", "originalCommit": "ca4c27253d72584e06dbff28aeaf4e8c6324866c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77b22327908ea67485a935187738c2e3e6b1f772", "chunk": "diff --git a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\nindex 5362533551..d1b56d6421 100644\n--- a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n+++ b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n\n@@ -98,101 +96,28 @@ public class DDSpan implements Span, MutableSpan {\n \n   private void addStacktraceIfThresholdExceeded() {\n     final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n-    if (!isError()\n-        && spanDurationStacktraceNanos > 0\n-        && durationNano.get() > spanDurationStacktraceNanos\n+    if (isError()\n+        || spanDurationStacktraceNanos <= 0\n+        || durationNano.get() <= spanDurationStacktraceNanos\n         // If this span was finished async, then the stacktrace will be less meaningful.\n-        && context.threadId == Thread.currentThread().getId()) {\n-      final Exception stacktrace = new Exception();\n-      final Writer stackString = new FilteredStringWriter();\n-      stacktrace.printStackTrace(new PrintWriter(stackString));\n-      setTag(\"slow.stack\", stackString.toString());\n+        || context.threadId != Thread.currentThread().getId()) {\n+      return;\n     }\n-  }\n-\n-  // Writer that skips the first line and lines until FILTER doesn't match.\n-  private static final class FilteredStringWriter extends Writer {\n-    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n-\n-    private final StringWriter writer = new StringWriter();\n-\n-    private State state = State.SKIP_LINE; // Skip the exception type and message\n-    private StringBuilder buffer = new StringBuilder();\n-    private int lineIndex = 0;\n-\n-    @Override\n-    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-      if ((off < 0)\n-          || (off > cbuf.length)\n-          || (len < 0)\n-          || ((off + len) > cbuf.length)\n-          || ((off + len) < 0)) {\n-        throw new IndexOutOfBoundsException();\n-      } else if (len == 0) {\n-        return;\n-      }\n-\n-      for (int i = off; i < len; i++) {\n-        switch (state) {\n-          case SKIP_LINE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.READ_LINE;\n-              lineIndex = 0;\n-            }\n-            break;\n-\n-          case READ_LINE:\n-            if (lineIndex == FILTER.length) {\n-              state = State.SKIP_LINE;\n-              buffer = new StringBuilder();\n-            } else if (cbuf[i] == FILTER[lineIndex]) {\n-              buffer.append(cbuf[i]);\n-              lineIndex++;\n-            } else {\n-              // writer.write(buffer.toString());\n-              // writer.write(cbuf[i]);\n-              // buffer = new StringBuilder();\n-              // state = State.CONTINUE;\n-              state = State.SKIP_NEXT_LINE_THEN_CONTINUE;\n-            }\n-            continue;\n-\n-          case SKIP_NEXT_LINE_THEN_CONTINUE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.CONTINUE;\n-            }\n-            break;\n-\n-          case CONTINUE:\n-            writer.write(cbuf, i, len - (i - off));\n-            return;\n-        }\n+    final StringBuilder stack = new StringBuilder();\n+    // TODO: use StackWalker api for java 9+ jvm's?\n+    boolean skipNext = true;\n+    for (final StackTraceElement element : Thread.currentThread().getStackTrace()) {\n+      final boolean tracingClass = element.getClassName().startsWith(\"datadog.opentracing.\");\n+      if (skipNext || tracingClass) {\n+        skipNext = tracingClass;\n+        continue;\n       }\n+      stack.append(\"\\tat \");\n+      stack.append(element);\n+      stack.append(\"\\n\");\n     }\n-\n-    @Override\n-    public void flush() {\n-      writer.flush();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-      writer.close();\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return buffer.toString() + writer.toString();\n-    }\n-\n-    private enum State {\n-      READ_LINE,\n-      SKIP_LINE,\n-      SKIP_NEXT_LINE_THEN_CONTINUE,\n-      CONTINUE\n-    }\n+    // Prob not worth dealing with the trailing newline.\n+    setTag(\"slow.stack\", stack.toString());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NjE3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362846179", "bodyText": "This feels like an optional behavior that might be better handled through a Listener mechanism.\nHowever, I'm fine with deferring that to a later PR.", "author": "dougqh", "createdAt": "2020-01-03T15:20:03Z", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();", "originalCommit": "ca4c27253d72584e06dbff28aeaf4e8c6324866c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77b22327908ea67485a935187738c2e3e6b1f772", "chunk": "diff --git a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\nindex 5362533551..d1b56d6421 100644\n--- a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n+++ b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n\n@@ -98,101 +96,28 @@ public class DDSpan implements Span, MutableSpan {\n \n   private void addStacktraceIfThresholdExceeded() {\n     final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n-    if (!isError()\n-        && spanDurationStacktraceNanos > 0\n-        && durationNano.get() > spanDurationStacktraceNanos\n+    if (isError()\n+        || spanDurationStacktraceNanos <= 0\n+        || durationNano.get() <= spanDurationStacktraceNanos\n         // If this span was finished async, then the stacktrace will be less meaningful.\n-        && context.threadId == Thread.currentThread().getId()) {\n-      final Exception stacktrace = new Exception();\n-      final Writer stackString = new FilteredStringWriter();\n-      stacktrace.printStackTrace(new PrintWriter(stackString));\n-      setTag(\"slow.stack\", stackString.toString());\n+        || context.threadId != Thread.currentThread().getId()) {\n+      return;\n     }\n-  }\n-\n-  // Writer that skips the first line and lines until FILTER doesn't match.\n-  private static final class FilteredStringWriter extends Writer {\n-    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n-\n-    private final StringWriter writer = new StringWriter();\n-\n-    private State state = State.SKIP_LINE; // Skip the exception type and message\n-    private StringBuilder buffer = new StringBuilder();\n-    private int lineIndex = 0;\n-\n-    @Override\n-    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-      if ((off < 0)\n-          || (off > cbuf.length)\n-          || (len < 0)\n-          || ((off + len) > cbuf.length)\n-          || ((off + len) < 0)) {\n-        throw new IndexOutOfBoundsException();\n-      } else if (len == 0) {\n-        return;\n-      }\n-\n-      for (int i = off; i < len; i++) {\n-        switch (state) {\n-          case SKIP_LINE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.READ_LINE;\n-              lineIndex = 0;\n-            }\n-            break;\n-\n-          case READ_LINE:\n-            if (lineIndex == FILTER.length) {\n-              state = State.SKIP_LINE;\n-              buffer = new StringBuilder();\n-            } else if (cbuf[i] == FILTER[lineIndex]) {\n-              buffer.append(cbuf[i]);\n-              lineIndex++;\n-            } else {\n-              // writer.write(buffer.toString());\n-              // writer.write(cbuf[i]);\n-              // buffer = new StringBuilder();\n-              // state = State.CONTINUE;\n-              state = State.SKIP_NEXT_LINE_THEN_CONTINUE;\n-            }\n-            continue;\n-\n-          case SKIP_NEXT_LINE_THEN_CONTINUE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.CONTINUE;\n-            }\n-            break;\n-\n-          case CONTINUE:\n-            writer.write(cbuf, i, len - (i - off));\n-            return;\n-        }\n+    final StringBuilder stack = new StringBuilder();\n+    // TODO: use StackWalker api for java 9+ jvm's?\n+    boolean skipNext = true;\n+    for (final StackTraceElement element : Thread.currentThread().getStackTrace()) {\n+      final boolean tracingClass = element.getClassName().startsWith(\"datadog.opentracing.\");\n+      if (skipNext || tracingClass) {\n+        skipNext = tracingClass;\n+        continue;\n       }\n+      stack.append(\"\\tat \");\n+      stack.append(element);\n+      stack.append(\"\\n\");\n     }\n-\n-    @Override\n-    public void flush() {\n-      writer.flush();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-      writer.close();\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return buffer.toString() + writer.toString();\n-    }\n-\n-    private enum State {\n-      READ_LINE,\n-      SKIP_LINE,\n-      SKIP_NEXT_LINE_THEN_CONTINUE,\n-      CONTINUE\n-    }\n+    // Prob not worth dealing with the trailing newline.\n+    setTag(\"slow.stack\", stack.toString());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NzAxMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362847013", "bodyText": "I think requesting and traversing the StackTraceElement[] would be easier to follow that filtering Writer.", "author": "dougqh", "createdAt": "2020-01-03T15:22:18Z", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n+    if (!isError()\n+        && spanDurationStacktraceNanos > 0\n+        && durationNano.get() > spanDurationStacktraceNanos\n+        // If this span was finished async, then the stacktrace will be less meaningful.\n+        && context.threadId == Thread.currentThread().getId()) {\n+      final Exception stacktrace = new Exception();\n+      final Writer stackString = new FilteredStringWriter();\n+      stacktrace.printStackTrace(new PrintWriter(stackString));\n+      setTag(\"slow.stack\", stackString.toString());\n+    }\n+  }\n+\n+  // Writer that skips the first line and lines until FILTER doesn't match.\n+  private static final class FilteredStringWriter extends Writer {\n+    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n+\n+    private final StringWriter writer = new StringWriter();\n+\n+    private State state = State.SKIP_LINE; // Skip the exception type and message\n+    private StringBuilder buffer = new StringBuilder();\n+    private int lineIndex = 0;\n+\n+    @Override\n+    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n+      if ((off < 0)", "originalCommit": "ca4c27253d72584e06dbff28aeaf4e8c6324866c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk1MzQ0NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362953445", "bodyText": "I agree. It would be also useful to make the filter configurable. There is often a lot of framework code that can be ignored. I'd even consider including only frames from my code. It worked great in mjprof", "author": "jkubrynski", "createdAt": "2020-01-03T20:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NzAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3NDYzMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r368174630", "bodyText": "For simplicity, I'm not going to make it configurable in this PR... we can evaluate that later.", "author": "tylerbenson", "createdAt": "2020-01-17T23:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NzAxMw=="}], "type": "inlineReview", "revised_code": {"commit": "77b22327908ea67485a935187738c2e3e6b1f772", "chunk": "diff --git a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\nindex 5362533551..d1b56d6421 100644\n--- a/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n+++ b/dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java\n\n@@ -98,101 +96,28 @@ public class DDSpan implements Span, MutableSpan {\n \n   private void addStacktraceIfThresholdExceeded() {\n     final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n-    if (!isError()\n-        && spanDurationStacktraceNanos > 0\n-        && durationNano.get() > spanDurationStacktraceNanos\n+    if (isError()\n+        || spanDurationStacktraceNanos <= 0\n+        || durationNano.get() <= spanDurationStacktraceNanos\n         // If this span was finished async, then the stacktrace will be less meaningful.\n-        && context.threadId == Thread.currentThread().getId()) {\n-      final Exception stacktrace = new Exception();\n-      final Writer stackString = new FilteredStringWriter();\n-      stacktrace.printStackTrace(new PrintWriter(stackString));\n-      setTag(\"slow.stack\", stackString.toString());\n+        || context.threadId != Thread.currentThread().getId()) {\n+      return;\n     }\n-  }\n-\n-  // Writer that skips the first line and lines until FILTER doesn't match.\n-  private static final class FilteredStringWriter extends Writer {\n-    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n-\n-    private final StringWriter writer = new StringWriter();\n-\n-    private State state = State.SKIP_LINE; // Skip the exception type and message\n-    private StringBuilder buffer = new StringBuilder();\n-    private int lineIndex = 0;\n-\n-    @Override\n-    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-      if ((off < 0)\n-          || (off > cbuf.length)\n-          || (len < 0)\n-          || ((off + len) > cbuf.length)\n-          || ((off + len) < 0)) {\n-        throw new IndexOutOfBoundsException();\n-      } else if (len == 0) {\n-        return;\n-      }\n-\n-      for (int i = off; i < len; i++) {\n-        switch (state) {\n-          case SKIP_LINE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.READ_LINE;\n-              lineIndex = 0;\n-            }\n-            break;\n-\n-          case READ_LINE:\n-            if (lineIndex == FILTER.length) {\n-              state = State.SKIP_LINE;\n-              buffer = new StringBuilder();\n-            } else if (cbuf[i] == FILTER[lineIndex]) {\n-              buffer.append(cbuf[i]);\n-              lineIndex++;\n-            } else {\n-              // writer.write(buffer.toString());\n-              // writer.write(cbuf[i]);\n-              // buffer = new StringBuilder();\n-              // state = State.CONTINUE;\n-              state = State.SKIP_NEXT_LINE_THEN_CONTINUE;\n-            }\n-            continue;\n-\n-          case SKIP_NEXT_LINE_THEN_CONTINUE:\n-            // Should work fine for windows \"\\r\\n\" case too.\n-            if (cbuf[i] == '\\n') {\n-              state = State.CONTINUE;\n-            }\n-            break;\n-\n-          case CONTINUE:\n-            writer.write(cbuf, i, len - (i - off));\n-            return;\n-        }\n+    final StringBuilder stack = new StringBuilder();\n+    // TODO: use StackWalker api for java 9+ jvm's?\n+    boolean skipNext = true;\n+    for (final StackTraceElement element : Thread.currentThread().getStackTrace()) {\n+      final boolean tracingClass = element.getClassName().startsWith(\"datadog.opentracing.\");\n+      if (skipNext || tracingClass) {\n+        skipNext = tracingClass;\n+        continue;\n       }\n+      stack.append(\"\\tat \");\n+      stack.append(element);\n+      stack.append(\"\\n\");\n     }\n-\n-    @Override\n-    public void flush() {\n-      writer.flush();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-      writer.close();\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return buffer.toString() + writer.toString();\n-    }\n-\n-    private enum State {\n-      READ_LINE,\n-      SKIP_LINE,\n-      SKIP_NEXT_LINE_THEN_CONTINUE,\n-      CONTINUE\n-    }\n+    // Prob not worth dealing with the trailing newline.\n+    setTag(\"slow.stack\", stack.toString());\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk1NDAyOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362954028", "bodyText": "Depending on a use-case of course, but for regular web applications 1 second is a strict setting, and many users can be flooded.", "author": "jkubrynski", "createdAt": "2020-01-03T20:40:18Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -129,6 +132,8 @@\n   private static final boolean DEFAULT_DB_CLIENT_HOST_SPLIT_BY_INSTANCE = false;\n   private static final String DEFAULT_SPLIT_BY_TAGS = \"\";\n   private static final int DEFAULT_PARTIAL_FLUSH_MIN_SPANS = 1000;\n+  private static final int DEFAULT_SPAN_DURATION_STACKTRACE_MILLIS =\n+      (int) TimeUnit.SECONDS.toMillis(1);", "originalCommit": "ca4c27253d72584e06dbff28aeaf4e8c6324866c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM2MzEzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r363363137", "bodyText": "I was trying to find a balance between a config default that is useful, but not burdensome...  My thought is that a stacktrace is expensive, but if a span is more than a second, then the cost of a stacktrace is likely not noticeable compared to the rest of the trace.  Do you have any suggestions for a different config default?", "author": "tylerbenson", "createdAt": "2020-01-06T16:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk1NDAyOA=="}], "type": "inlineReview", "revised_code": {"commit": "2b74487ed664b61c695f17dc96d10b332d726d36", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/Config.java b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\nindex 8a42429904..1160966ebd 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n\n@@ -131,6 +162,7 @@ public class Config {\n   private static final boolean DEFAULT_HTTP_CLIENT_SPLIT_BY_DOMAIN = false;\n   private static final boolean DEFAULT_DB_CLIENT_HOST_SPLIT_BY_INSTANCE = false;\n   private static final String DEFAULT_SPLIT_BY_TAGS = \"\";\n+  private static final int DEFAULT_SCOPE_DEPTH_LIMIT = 100;\n   private static final int DEFAULT_PARTIAL_FLUSH_MIN_SPANS = 1000;\n   private static final int DEFAULT_SPAN_DURATION_STACKTRACE_MILLIS =\n       (int) TimeUnit.SECONDS.toMillis(1);\n"}}, {"oid": "77b22327908ea67485a935187738c2e3e6b1f772", "url": "https://github.com/DataDog/dd-trace-java/commit/77b22327908ea67485a935187738c2e3e6b1f772", "message": "Replace FilteredStringWriter with direct StackTraceElement usage.", "committedDate": "2020-01-17T23:14:18Z", "type": "forcePushed"}, {"oid": "2b74487ed664b61c695f17dc96d10b332d726d36", "url": "https://github.com/DataDog/dd-trace-java/commit/2b74487ed664b61c695f17dc96d10b332d726d36", "message": "Add config to capture stacktrace when a span duration exceeds threshold\n\n(But only when span is not errored or finished on a different thread.)\n\nUse the following config:\n```\n-Ddd.trace.span.duration.stacktrace.millis=1000\n```\n(One second is the default, 0 disables.)", "committedDate": "2020-03-10T20:18:22Z", "type": "commit"}, {"oid": "1cbb874c7ccaf224c2def90db614b3c3791466cb", "url": "https://github.com/DataDog/dd-trace-java/commit/1cbb874c7ccaf224c2def90db614b3c3791466cb", "message": "Replace FilteredStringWriter with direct StackTraceElement usage.", "committedDate": "2020-03-10T20:18:22Z", "type": "commit"}, {"oid": "2f64edaea43ebf7feeed5a40494547da4efc29d6", "url": "https://github.com/DataDog/dd-trace-java/commit/2f64edaea43ebf7feeed5a40494547da4efc29d6", "message": "Make threshold based on average duration\n\nThis should help avoid too frequent of stacktraces when the configured threshold is a normal duration.\nAlternatively, we could make it a percentage above the average.", "committedDate": "2020-03-10T22:08:12Z", "type": "commit"}, {"oid": "2f64edaea43ebf7feeed5a40494547da4efc29d6", "url": "https://github.com/DataDog/dd-trace-java/commit/2f64edaea43ebf7feeed5a40494547da4efc29d6", "message": "Make threshold based on average duration\n\nThis should help avoid too frequent of stacktraces when the configured threshold is a normal duration.\nAlternatively, we could make it a percentage above the average.", "committedDate": "2020-03-10T22:08:12Z", "type": "forcePushed"}]}