{"pr_number": 1468, "pr_title": "JMX implementation of Profiling Session", "pr_createdAt": "2020-05-18T09:44:37Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1468", "timeline": [{"oid": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "url": "https://github.com/DataDog/dd-trace-java/commit/e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "message": "draft wiring with SamplerWriter", "committedDate": "2020-05-19T14:35:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1NDk2Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427354966", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n          \n          \n            \n              private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();", "author": "jbachorik", "createdAt": "2020-05-19T14:38:35Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTI0Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895242", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T10:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1NDk2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\nindex 02d32276e8..9981304043 100644\n--- a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n+++ b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n\n@@ -4,29 +4,29 @@ import datadog.trace.core.util.NoneThreadStackProvider;\n import datadog.trace.core.util.ThreadStackAccess;\n import datadog.trace.core.util.ThreadStackProvider;\n import datadog.trace.profiling.Session;\n-import java.lang.management.ThreadInfo;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Supplier;\n import lombok.extern.slf4j.Slf4j;\n \n @Slf4j\n public class JMXSession implements Session {\n   private final String id;\n-  private final long[] threadIds;\n+  private final List<Long> threadIds;\n   private final StackTraceSink sink;\n   private final ThreadStackProvider provider;\n   private final Map<Long, JMXSession> sessions;\n   private final AtomicInteger refCount = new AtomicInteger();\n   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n \n-  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+  public JMXSession(String id, long threadId, StackTraceSink sink, Map<Long, JMXSession> sessions) {\n     this.id = id;\n-    this.threadIds = new long[] { threadId };\n-    this.sink = sinkSupplier.get();\n+    this.threadIds = Collections.singletonList(threadId);\n+    this.sink = sink;\n     this.sessions = sessions;\n     provider = ThreadStackAccess.getCurrentThreadStackProvider();\n     if (provider instanceof NoneThreadStackProvider) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwOTk0NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427409945", "bodyText": "This looks quite suspicious - force creating an array when the session is always bound to a single thread.\nI know that it is used in the sample() method but it would feel more appropriate to have a sampler class factored out which would maintain a set of thread IDs which are supposed to be sampled (maybe wrapped as Session instances if that makes sense).", "author": "jbachorik", "createdAt": "2020-05-19T15:50:42Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+\n+  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+    this.id = id;\n+    this.threadIds = new long[] { threadId };", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTQyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895425", "bodyText": "moved to JMXSampler", "author": "jpbempel", "createdAt": "2020-05-20T10:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwOTk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\nindex 02d32276e8..9981304043 100644\n--- a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n+++ b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n\n@@ -4,29 +4,29 @@ import datadog.trace.core.util.NoneThreadStackProvider;\n import datadog.trace.core.util.ThreadStackAccess;\n import datadog.trace.core.util.ThreadStackProvider;\n import datadog.trace.profiling.Session;\n-import java.lang.management.ThreadInfo;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Supplier;\n import lombok.extern.slf4j.Slf4j;\n \n @Slf4j\n public class JMXSession implements Session {\n   private final String id;\n-  private final long[] threadIds;\n+  private final List<Long> threadIds;\n   private final StackTraceSink sink;\n   private final ThreadStackProvider provider;\n   private final Map<Long, JMXSession> sessions;\n   private final AtomicInteger refCount = new AtomicInteger();\n   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n \n-  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+  public JMXSession(String id, long threadId, StackTraceSink sink, Map<Long, JMXSession> sessions) {\n     this.id = id;\n-    this.threadIds = new long[] { threadId };\n-    this.sink = sinkSupplier.get();\n+    this.threadIds = Collections.singletonList(threadId);\n+    this.sink = sink;\n     this.sessions = sessions;\n     provider = ThreadStackAccess.getCurrentThreadStackProvider();\n     if (provider instanceof NoneThreadStackProvider) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMDc5NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427420795", "bodyText": "Passing around a map which is essentially an internal state of the JMXSessionFactory does not look really nice.\nCan't this be resolved with a session having active flag for true when refCount > 0 and a callback to the instantiating factory to notify that a session has become inactive when the flag is flipped. The factory would then do a concurrent update of the map depending on the current value of the active flag, thus preventing data race when a session is brought back to life.", "author": "jbachorik", "createdAt": "2020-05-19T16:05:47Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+\n+  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTUyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895527", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T10:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMDc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\nindex 02d32276e8..9981304043 100644\n--- a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n+++ b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n\n@@ -4,29 +4,29 @@ import datadog.trace.core.util.NoneThreadStackProvider;\n import datadog.trace.core.util.ThreadStackAccess;\n import datadog.trace.core.util.ThreadStackProvider;\n import datadog.trace.profiling.Session;\n-import java.lang.management.ThreadInfo;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Supplier;\n import lombok.extern.slf4j.Slf4j;\n \n @Slf4j\n public class JMXSession implements Session {\n   private final String id;\n-  private final long[] threadIds;\n+  private final List<Long> threadIds;\n   private final StackTraceSink sink;\n   private final ThreadStackProvider provider;\n   private final Map<Long, JMXSession> sessions;\n   private final AtomicInteger refCount = new AtomicInteger();\n   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n \n-  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+  public JMXSession(String id, long threadId, StackTraceSink sink, Map<Long, JMXSession> sessions) {\n     this.id = id;\n-    this.threadIds = new long[] { threadId };\n-    this.sink = sinkSupplier.get();\n+    this.threadIds = Collections.singletonList(threadId);\n+    this.sink = sink;\n     this.sessions = sessions;\n     provider = ThreadStackAccess.getCurrentThreadStackProvider();\n     if (provider instanceof NoneThreadStackProvider) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMTA3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427421075", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.warn(\"ThreadStack provider is oo op. It will not provide thread stacks.\");\n          \n          \n            \n                  log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");", "author": "jbachorik", "createdAt": "2020-05-19T16:06:08Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+\n+  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+    this.id = id;\n+    this.threadIds = new long[] { threadId };\n+    this.sink = sinkSupplier.get();\n+    this.sessions = sessions;\n+    provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+    if (provider instanceof NoneThreadStackProvider) {\n+      log.warn(\"ThreadStack provider is oo op. It will not provide thread stacks.\");", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTYwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895607", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T10:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMTA3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\nindex 02d32276e8..9981304043 100644\n--- a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n+++ b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n\n@@ -4,29 +4,29 @@ import datadog.trace.core.util.NoneThreadStackProvider;\n import datadog.trace.core.util.ThreadStackAccess;\n import datadog.trace.core.util.ThreadStackProvider;\n import datadog.trace.profiling.Session;\n-import java.lang.management.ThreadInfo;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Supplier;\n import lombok.extern.slf4j.Slf4j;\n \n @Slf4j\n public class JMXSession implements Session {\n   private final String id;\n-  private final long[] threadIds;\n+  private final List<Long> threadIds;\n   private final StackTraceSink sink;\n   private final ThreadStackProvider provider;\n   private final Map<Long, JMXSession> sessions;\n   private final AtomicInteger refCount = new AtomicInteger();\n   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n \n-  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+  public JMXSession(String id, long threadId, StackTraceSink sink, Map<Long, JMXSession> sessions) {\n     this.id = id;\n-    this.threadIds = new long[] { threadId };\n-    this.sink = sinkSupplier.get();\n+    this.threadIds = Collections.singletonList(threadId);\n+    this.sink = sink;\n     this.sessions = sessions;\n     provider = ThreadStackAccess.getCurrentThreadStackProvider();\n     if (provider instanceof NoneThreadStackProvider) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMjI5Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427422293", "bodyText": "A bit of bike-shedding but a name less bound to the actual implementation would be nice - something like activate or use?", "author": "jbachorik", "createdAt": "2020-05-19T16:07:53Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+\n+  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+    this.id = id;\n+    this.threadIds = new long[] { threadId };\n+    this.sink = sinkSupplier.get();\n+    this.sessions = sessions;\n+    provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+    if (provider instanceof NoneThreadStackProvider) {\n+      log.warn(\"ThreadStack provider is oo op. It will not provide thread stacks.\");\n+    }\n+    start();\n+  }\n+\n+  public void close() {\n+    sessions.computeIfPresent(threadIds[0], this::closeSession);\n+  }\n+\n+  private JMXSession closeSession(Long key, JMXSession jmxSession) {\n+    int current = jmxSession.decRefCount();\n+    if (current == 0) {\n+      executor.shutdown();\n+      byte[] buffer = sink.flush();\n+      log.info(\"Closing session, flushing {} bytes\", buffer.length);\n+      return null;\n+    }\n+    return jmxSession;\n+  }\n+\n+  void incRefCount() {", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTcwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895700", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T10:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMjI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\nindex 02d32276e8..9981304043 100644\n--- a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n+++ b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java\n\n@@ -4,29 +4,29 @@ import datadog.trace.core.util.NoneThreadStackProvider;\n import datadog.trace.core.util.ThreadStackAccess;\n import datadog.trace.core.util.ThreadStackProvider;\n import datadog.trace.profiling.Session;\n-import java.lang.management.ThreadInfo;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Supplier;\n import lombok.extern.slf4j.Slf4j;\n \n @Slf4j\n public class JMXSession implements Session {\n   private final String id;\n-  private final long[] threadIds;\n+  private final List<Long> threadIds;\n   private final StackTraceSink sink;\n   private final ThreadStackProvider provider;\n   private final Map<Long, JMXSession> sessions;\n   private final AtomicInteger refCount = new AtomicInteger();\n   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n \n-  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+  public JMXSession(String id, long threadId, StackTraceSink sink, Map<Long, JMXSession> sessions) {\n     this.id = id;\n-    this.threadIds = new long[] { threadId };\n-    this.sink = sinkSupplier.get();\n+    this.threadIds = Collections.singletonList(threadId);\n+    this.sink = sink;\n     this.sessions = sessions;\n     provider = ThreadStackAccess.getCurrentThreadStackProvider();\n     if (provider instanceof NoneThreadStackProvider) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4MDA1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r428080051", "bodyText": "Please, package private only. I guess this class should not be used outside of MLT directly.", "author": "jbachorik", "createdAt": "2020-05-20T14:55:55Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import java.lang.management.ThreadInfo;\n+import java.util.Arrays;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSampler {", "originalCommit": "1ffc830ff319a0cd49fbbff4765691a92a319c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExMzkzMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r428113932", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T15:40:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4MDA1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java\ndeleted file mode 100644\nindex 653da89b7d..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java\n+++ /dev/null\n\n@@ -1,91 +0,0 @@\n-package com.datadog.profiling.mlt;\n-\n-import datadog.trace.core.util.NoneThreadStackProvider;\n-import datadog.trace.core.util.ThreadStackAccess;\n-import datadog.trace.core.util.ThreadStackProvider;\n-import java.lang.management.ThreadInfo;\n-import java.util.Arrays;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public class JMXSampler {\n-  private final StackTraceSink sink;\n-  private final ThreadStackProvider provider;\n-  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n-  private long samplingCount;\n-  private AtomicReference<long[]> threadIds = new AtomicReference<>();\n-\n-  public JMXSampler(StackTraceSink sink) {\n-    this.sink = sink;\n-    provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-    }\n-    // TODO period as parameter\n-    executor.scheduleAtFixedRate(this::sample, 0, 10, TimeUnit.MILLISECONDS);\n-  }\n-\n-  public void shutdown() {\n-    executor.shutdown();\n-    byte[] buffer = sink.flush();\n-    log.info(\"Flushing remaining {} bytes\", buffer.length);\n-  }\n-\n-  public void addThreadId(long threadId) {\n-    long[] tmpArray;\n-    long[] prev = threadIds.get();\n-    while (prev == null) {\n-      tmpArray = new long[] {threadId};\n-      if (threadIds.compareAndSet(null, tmpArray)) {\n-        return;\n-      }\n-      prev = threadIds.get();\n-    }\n-    do {\n-      prev = threadIds.get();\n-      tmpArray = Arrays.copyOf(prev, prev.length + 1);\n-      tmpArray[tmpArray.length - 1] = threadId;\n-    } while (!threadIds.compareAndSet(prev, tmpArray));\n-  }\n-\n-  public void removeThread(long threadId) {\n-    long[] prev;\n-    long[] tmpArray;\n-    do {\n-      prev = threadIds.get();\n-      if (prev == null || prev.length == 0) {\n-        return;\n-      }\n-      int idx = 0;\n-      int size = prev.length;\n-      while (idx < size && prev[idx] != threadId) idx++;\n-      if (idx >= size) {\n-        // not found\n-        return;\n-      }\n-      tmpArray = new long[prev.length - 1];\n-      System.arraycopy(prev, 0, tmpArray, 0, idx);\n-      System.arraycopy(prev, idx + 1, tmpArray, idx, tmpArray.length - idx);\n-    } while (!threadIds.compareAndSet(prev, tmpArray));\n-  }\n-\n-  private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // TODO handle ids\n-    sink.write(null, threadInfos);\n-    samplingCount++;\n-    // TODO flushing time as parameter\n-    if (samplingCount % 100 == 0) {\n-      byte[] buffer = sink.flush();\n-      log.info(\"flushing {} bytes\", buffer.length);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4MDk3MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r428080971", "bodyText": "Can you add some comments about pre/post-conditions? Like that a thread ID will always be added so calling it multiple time will result in multiple occurrences of the same ID etc.", "author": "jbachorik", "createdAt": "2020-05-20T14:57:06Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import java.lang.management.ThreadInfo;\n+import java.util.Arrays;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSampler {\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+  private long samplingCount;\n+  private AtomicReference<long[]> threadIds = new AtomicReference<>();\n+\n+  public JMXSampler(StackTraceSink sink) {\n+    this.sink = sink;\n+    provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+    if (provider instanceof NoneThreadStackProvider) {\n+      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+    }\n+    // TODO period as parameter\n+    executor.scheduleAtFixedRate(this::sample, 0, 10, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void shutdown() {\n+    executor.shutdown();\n+    byte[] buffer = sink.flush();\n+    log.info(\"Flushing remaining {} bytes\", buffer.length);\n+  }\n+\n+  public void addThreadId(long threadId) {", "originalCommit": "1ffc830ff319a0cd49fbbff4765691a92a319c70", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java\ndeleted file mode 100644\nindex 653da89b7d..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java\n+++ /dev/null\n\n@@ -1,91 +0,0 @@\n-package com.datadog.profiling.mlt;\n-\n-import datadog.trace.core.util.NoneThreadStackProvider;\n-import datadog.trace.core.util.ThreadStackAccess;\n-import datadog.trace.core.util.ThreadStackProvider;\n-import java.lang.management.ThreadInfo;\n-import java.util.Arrays;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public class JMXSampler {\n-  private final StackTraceSink sink;\n-  private final ThreadStackProvider provider;\n-  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n-  private long samplingCount;\n-  private AtomicReference<long[]> threadIds = new AtomicReference<>();\n-\n-  public JMXSampler(StackTraceSink sink) {\n-    this.sink = sink;\n-    provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-    }\n-    // TODO period as parameter\n-    executor.scheduleAtFixedRate(this::sample, 0, 10, TimeUnit.MILLISECONDS);\n-  }\n-\n-  public void shutdown() {\n-    executor.shutdown();\n-    byte[] buffer = sink.flush();\n-    log.info(\"Flushing remaining {} bytes\", buffer.length);\n-  }\n-\n-  public void addThreadId(long threadId) {\n-    long[] tmpArray;\n-    long[] prev = threadIds.get();\n-    while (prev == null) {\n-      tmpArray = new long[] {threadId};\n-      if (threadIds.compareAndSet(null, tmpArray)) {\n-        return;\n-      }\n-      prev = threadIds.get();\n-    }\n-    do {\n-      prev = threadIds.get();\n-      tmpArray = Arrays.copyOf(prev, prev.length + 1);\n-      tmpArray[tmpArray.length - 1] = threadId;\n-    } while (!threadIds.compareAndSet(prev, tmpArray));\n-  }\n-\n-  public void removeThread(long threadId) {\n-    long[] prev;\n-    long[] tmpArray;\n-    do {\n-      prev = threadIds.get();\n-      if (prev == null || prev.length == 0) {\n-        return;\n-      }\n-      int idx = 0;\n-      int size = prev.length;\n-      while (idx < size && prev[idx] != threadId) idx++;\n-      if (idx >= size) {\n-        // not found\n-        return;\n-      }\n-      tmpArray = new long[prev.length - 1];\n-      System.arraycopy(prev, 0, tmpArray, 0, idx);\n-      System.arraycopy(prev, idx + 1, tmpArray, idx, tmpArray.length - idx);\n-    } while (!threadIds.compareAndSet(prev, tmpArray));\n-  }\n-\n-  private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // TODO handle ids\n-    sink.write(null, threadInfos);\n-    samplingCount++;\n-    // TODO flushing time as parameter\n-    if (samplingCount % 100 == 0) {\n-      byte[] buffer = sink.flush();\n-      log.info(\"flushing {} bytes\", buffer.length);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4Mzc5Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r428083792", "bodyText": "I think that the interplay between closeSession() and createSession in regards of thread safety should be documented here.\nIf I am not missing something the code is data-race free thanks to closeSession being run as the ConcurrentHashMap computation which is guaranteed to run at most once and atomically. Unfortunately, this is not a general characteristic of all ConcurrentMap types so it would be good to have it documented for future maintenance.", "author": "jbachorik", "createdAt": "2020-05-20T15:00:29Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSessionFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.profiling.Session;\n+import datadog.trace.profiling.SessionFactory;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSessionFactory implements SessionFactory {\n+  private final Map<Long, JMXSession> jmxSessions = new ConcurrentHashMap<>();\n+  private final JMXSampler sampler;\n+\n+  public JMXSessionFactory(StackTraceSink sink) {\n+    this.sampler = new JMXSampler(sink);\n+  }\n+\n+  @Override\n+  public Session createSession(String id, Thread thread) {\n+    long threadId = thread.getId();\n+    JMXSession session =\n+        jmxSessions.computeIfAbsent(threadId, key -> createNewSession(id, threadId));\n+    session.activate();\n+    return session;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    sampler.shutdown();\n+  }\n+\n+  private JMXSession createNewSession(String id, long threadId) {\n+    sampler.addThreadId(threadId);\n+    return new JMXSession(id, threadId, this::cleanup);\n+  }\n+\n+  private void cleanup(JMXSession session) {\n+    jmxSessions.computeIfPresent(session.getThreadId(), this::closeSession);\n+  }\n+\n+  private JMXSession closeSession(Long key, JMXSession jmxSession) {", "originalCommit": "1ffc830ff319a0cd49fbbff4765691a92a319c70", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSessionFactory.java b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSessionFactory.java\nindex 11d99c0a56..c80a178476 100644\n--- a/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSessionFactory.java\n+++ b/dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSessionFactory.java\n\n@@ -4,46 +4,19 @@ import datadog.trace.profiling.Session;\n import datadog.trace.profiling.SessionFactory;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n-import lombok.extern.slf4j.Slf4j;\n \n-@Slf4j\n public class JMXSessionFactory implements SessionFactory {\n+  private final StackTraceSink sink;\n   private final Map<Long, JMXSession> jmxSessions = new ConcurrentHashMap<>();\n-  private final JMXSampler sampler;\n \n   public JMXSessionFactory(StackTraceSink sink) {\n-    this.sampler = new JMXSampler(sink);\n+    this.sink = sink;\n   }\n \n-  @Override\n   public Session createSession(String id, Thread thread) {\n     long threadId = thread.getId();\n-    JMXSession session =\n-        jmxSessions.computeIfAbsent(threadId, key -> createNewSession(id, threadId));\n-    session.activate();\n+    JMXSession session = jmxSessions.computeIfAbsent(threadId, key -> new JMXSession(id, threadId, sink, jmxSessions));\n+    session.incRefCount();\n     return session;\n   }\n-\n-  @Override\n-  public void shutdown() {\n-    sampler.shutdown();\n-  }\n-\n-  private JMXSession createNewSession(String id, long threadId) {\n-    sampler.addThreadId(threadId);\n-    return new JMXSession(id, threadId, this::cleanup);\n-  }\n-\n-  private void cleanup(JMXSession session) {\n-    jmxSessions.computeIfPresent(session.getThreadId(), this::closeSession);\n-  }\n-\n-  private JMXSession closeSession(Long key, JMXSession jmxSession) {\n-    int current = jmxSession.deactivate();\n-    if (current == 0) {\n-      sampler.removeThread(jmxSession.getThreadId());\n-      return null;\n-    }\n-    return jmxSession;\n-  }\n }\n"}}, {"oid": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "url": "https://github.com/DataDog/dd-trace-java/commit/0408a6bb6c6c471e179906c7bab81363ff0cbd46", "message": "JMX implementation of Profiling Session", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "3b11f0b35a24792b396f0c746d182b95da4ba24e", "url": "https://github.com/DataDog/dd-trace-java/commit/3b11f0b35a24792b396f0c746d182b95da4ba24e", "message": "formatting", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "4cb76a8e62691cf3f9ae264b69c7ee1e36e98c8d", "url": "https://github.com/DataDog/dd-trace-java/commit/4cb76a8e62691cf3f9ae264b69c7ee1e36e98c8d", "message": "Wire with SamplerWriter", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "cd25b19872fe0fdef1902a3bed8698fe9d7d1cdd", "url": "https://github.com/DataDog/dd-trace-java/commit/cd25b19872fe0fdef1902a3bed8698fe9d7d1cdd", "message": "draft wiring with SamplerWriter", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "bb2e1a7e7b82b3edfb5fb635df1b5311c51ee11c", "url": "https://github.com/DataDog/dd-trace-java/commit/bb2e1a7e7b82b3edfb5fb635df1b5311c51ee11c", "message": "Move sampling executor to the factory", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "fbe3da5657f84da994ccd2572b4083e7f1b828c4", "url": "https://github.com/DataDog/dd-trace-java/commit/fbe3da5657f84da994ccd2572b4083e7f1b828c4", "message": "move Sampling logic to JMXSampler", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "c8c648cc3395ca016dae45bea36a5c9fd890c431", "url": "https://github.com/DataDog/dd-trace-java/commit/c8c648cc3395ca016dae45bea36a5c9fd890c431", "message": "add test", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "498d64fe777a7bf164e4ac18d11152cbb2412ef8", "url": "https://github.com/DataDog/dd-trace-java/commit/498d64fe777a7bf164e4ac18d11152cbb2412ef8", "message": "add test for Sampler", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "973e8978c4bcc0a5566aad2e4a5b18b7d39d7139", "url": "https://github.com/DataDog/dd-trace-java/commit/973e8978c4bcc0a5566aad2e4a5b18b7d39d7139", "message": "fix package name", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "5ea49ef2b9b879c33aaebe1da9eb6404672469c5", "url": "https://github.com/DataDog/dd-trace-java/commit/5ea49ef2b9b879c33aaebe1da9eb6404672469c5", "message": "add DaemonThreadFactory for sampler thread\n\nAdd comments regarding concurrenty", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "a46ff114904419dbd99c8a0f00b248f8b4fd152a", "url": "https://github.com/DataDog/dd-trace-java/commit/a46ff114904419dbd99c8a0f00b248f8b4fd152a", "message": "formatting", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "89d71eec14bc13667f71f385610a68f9d2cf6bbd", "url": "https://github.com/DataDog/dd-trace-java/commit/89d71eec14bc13667f71f385610a68f9d2cf6bbd", "message": "increase test coverage", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "b53f2c31fc382802beb5d90e961ae69e6da34f39", "url": "https://github.com/DataDog/dd-trace-java/commit/b53f2c31fc382802beb5d90e961ae69e6da34f39", "message": "improve test coverage", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "b53f2c31fc382802beb5d90e961ae69e6da34f39", "url": "https://github.com/DataDog/dd-trace-java/commit/b53f2c31fc382802beb5d90e961ae69e6da34f39", "message": "improve test coverage", "committedDate": "2020-05-20T22:14:04Z", "type": "forcePushed"}]}