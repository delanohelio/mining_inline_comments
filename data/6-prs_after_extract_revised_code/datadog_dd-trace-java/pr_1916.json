{"pr_number": 1916, "pr_title": "Add delay before Pending Trace submits to Writer", "pr_createdAt": "2020-09-25T20:10:30Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1916", "timeline": [{"oid": "c0996df6e55fa448f2ce7845b1ebc33efc323ff7", "url": "https://github.com/DataDog/dd-trace-java/commit/c0996df6e55fa448f2ce7845b1ebc33efc323ff7", "message": "Update Tests", "committedDate": "2020-09-25T20:29:24Z", "type": "forcePushed"}, {"oid": "1ea6441a6065dc5bba2c4abf633418c3b188a8a8", "url": "https://github.com/DataDog/dd-trace-java/commit/1ea6441a6065dc5bba2c4abf633418c3b188a8a8", "message": "Add small delay before writing traces", "committedDate": "2020-09-28T14:30:50Z", "type": "commit"}, {"oid": "3dfe51a55d4c17f2a43c11f0474886e227645e6a", "url": "https://github.com/DataDog/dd-trace-java/commit/3dfe51a55d4c17f2a43c11f0474886e227645e6a", "message": "Update Tests", "committedDate": "2020-09-28T14:30:50Z", "type": "commit"}, {"oid": "cd7db9725faa13d44e1f9ef3adf5bb950823d6d1", "url": "https://github.com/DataDog/dd-trace-java/commit/cd7db9725faa13d44e1f9ef3adf5bb950823d6d1", "message": "Flush PendingTrace buffer in AgentTestRunner\n\nTo improve test reliability by ensuring delayed traces don't leak between tests.", "committedDate": "2020-09-28T14:30:50Z", "type": "forcePushed"}, {"oid": "376a716c454a5bcbd86272f595c185513a019b13", "url": "https://github.com/DataDog/dd-trace-java/commit/376a716c454a5bcbd86272f595c185513a019b13", "message": "Flush PendingTrace buffer in AgentTestRunner\n\nTo improve test reliability by ensuring delayed traces don't leak between tests.", "committedDate": "2020-09-28T15:05:01Z", "type": "commit"}, {"oid": "376a716c454a5bcbd86272f595c185513a019b13", "url": "https://github.com/DataDog/dd-trace-java/commit/376a716c454a5bcbd86272f595c185513a019b13", "message": "Flush PendingTrace buffer in AgentTestRunner\n\nTo improve test reliability by ensuring delayed traces don't leak between tests.", "committedDate": "2020-09-28T15:05:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjU4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496066584", "bodyText": "This is disabled by default, I would keep it in", "author": "richardstartin", "createdAt": "2020-09-28T16:06:18Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NDUyNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496084526", "bodyText": "Actually I agree we should remove this, the cost of the measurement is probably a lot higher than what we're measuring here.", "author": "richardstartin", "createdAt": "2020-09-28T16:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NDUyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496864529", "bodyText": "I moved it elsewhere.", "author": "tylerbenson", "createdAt": "2020-09-29T16:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjU4NA=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 275add01a4..89d7710a90 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -235,10 +247,7 @@ public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements Agent\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      // FIXME: Does this still make sense to measure?\n-      try (Recording recording = tracer.writeTimer()) {\n-        PENDING_TRACE_BUFFER.enqueue(this);\n-      }\n+      pendingTraceBuffer.enqueue(this);\n     } else {\n       if (tracer.getPartialFlushMinSpans() > 0 && size() > tracer.getPartialFlushMinSpans()) {\n         try (Recording recording = tracer.writeTimer()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NzIzMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496067231", "bodyText": "Why ConcurrentLinkedQueue? Less contention? We have JCTools as a dependency now, consider using it here.", "author": "richardstartin", "createdAt": "2020-09-28T16:07:22Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NDcxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496864715", "bodyText": "done.", "author": "tylerbenson", "createdAt": "2020-09-29T16:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NzIzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2ODEwMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496068103", "bodyText": "I think we should rework this to initialise the thread in the constructor and start the thread here.", "author": "richardstartin", "createdAt": "2020-09-28T16:08:48Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NDg5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496864896", "bodyText": "done.", "author": "tylerbenson", "createdAt": "2020-09-29T16:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2ODEwMw=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MDc0NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496070744", "bodyText": "I tend to use Thread.currentThread().isInterrupted() because it doesn't clear the interrupted status, not sure this is important though.", "author": "richardstartin", "createdAt": "2020-09-28T16:12:49Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMTM3MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496121371", "bodyText": "Yes, agreed.", "author": "dougqh", "createdAt": "2020-09-28T17:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MDc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NTA2NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496865064", "bodyText": "done.", "author": "tylerbenson", "createdAt": "2020-09-29T16:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MDc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496072329", "bodyText": "I think it would be better to block (call take()) here than sleep and poll", "author": "richardstartin", "createdAt": "2020-09-28T16:15:18Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MzYwMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496073602", "bodyText": "I tried to find something like that but I don't see that method.", "author": "tylerbenson", "createdAt": "2020-09-28T16:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NzYxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496077612", "bodyText": "If you take a queue which implements java.util.concurrent.BlockingQueue it should be there. If this queue handles all traces, I think we should look at using a bounded queue to prevent unbounded growth. MpscBlockingConsumerArrayQueue used in the reporting pipeline might be a better choice.", "author": "richardstartin", "createdAt": "2020-09-28T16:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMjE3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496122173", "bodyText": "Yes, an even if we don't do a BlockingQueue, we could do wait / notify ourselves -- definitely don't want to sleep.", "author": "dougqh", "createdAt": "2020-09-28T17:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NTUyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496865529", "bodyText": "done.  Using take now that I'm using a blocking queue.", "author": "tylerbenson", "createdAt": "2020-09-29T16:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDA1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496074056", "bodyText": "if we just do this in the constructor we can't create 2 of them", "author": "richardstartin", "createdAt": "2020-09-28T16:17:52Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExOTkzNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496119934", "bodyText": "Yes, this TRACE_MONITOR feels a tad bit messy.\nConstructor might be problematic since it probably exposes a raw reference to PendingTraceBuffer.\nI also think the AtomicReference is probably overkill.  volatile + double checking would be lighter.\nDoesn't matter much here, but it is pattern we have throughout our code.\nI also don't like that this creates a Thread and then may skip starting it.\nI imagine that the backing OS resource probably isn't creating until start, but this still seems questionable for an expensive Object like Thread.", "author": "dougqh", "createdAt": "2020-09-28T17:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NjA3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496866075", "bodyText": "I've replaced with a single thread per instance.", "author": "tylerbenson", "createdAt": "2020-09-29T16:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MTExNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496081116", "bodyText": "How often will this be called? Can we reuse a timestamp here?", "author": "richardstartin", "createdAt": "2020-09-28T16:28:48Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -99,7 +111,17 @@ private PendingTrace(final CoreTracer tracer, final DDId traceId) {\n    * @return timestamp in nanoseconds\n    */\n   public long getCurrentTimeNano() {\n-    return startTimeNano + Math.max(0, Clock.currentNanoTicks() - startNanoTicks);\n+    long nanoTicks = Clock.currentNanoTicks();\n+    lastReferenced = nanoTicks;\n+    return startTimeNano + Math.max(0, nanoTicks - startNanoTicks);\n+  }\n+\n+  public void touch() {\n+    lastReferenced = Clock.currentNanoTicks();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMjgxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496102810", "bodyText": "If this is System.nanoTime() based it can overflow and should be used for relative comparisons - where are they done?", "author": "richardstartin", "createdAt": "2020-09-28T17:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MTExNg=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 275add01a4..89d7710a90 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -120,8 +130,10 @@ public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements Agent\n     lastReferenced = Clock.currentNanoTicks();\n   }\n \n-  public long getLastReferenced() {\n-    return lastReferenced;\n+  public boolean lastReferencedNanosAgo(long nanos) {\n+    long currentNanoTicks = Clock.currentNanoTicks();\n+    long age = currentNanoTicks - lastReferenced;\n+    return nanos < age;\n   }\n \n   public void registerSpan(final DDSpan span) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496082735", "bodyText": "I don't think we should do this. We are of secondary importance to the application. If we're shutting down, we need to shut down ASAP. Risking prevention of application shutdown to flush tracing data isn't right.", "author": "richardstartin", "createdAt": "2020-09-28T16:31:24Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDY2NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496110665", "bodyText": "This thread is a daemon thread so not such a big deal.", "author": "richardstartin", "createdAt": "2020-09-28T17:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMjYyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496122627", "bodyText": "I was wrong, this can indeed block shutdown despite being daemon", "author": "richardstartin", "createdAt": "2020-09-28T17:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NjM2NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496866365", "bodyText": "done.  No longer joining.", "author": "tylerbenson", "createdAt": "2020-09-29T16:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4Mzk1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496083955", "bodyText": "We can do this more efficiently with drainTo either on the BlockingQueue interface or JCTools drain method.", "author": "richardstartin", "createdAt": "2020-09-28T16:33:32Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NjUwMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496866501", "bodyText": "done", "author": "tylerbenson", "createdAt": "2020-09-29T16:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4Mzk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NDg4OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496084888", "bodyText": "We have a timestamp here - maybe we should pass it through.", "author": "richardstartin", "createdAt": "2020-09-28T16:35:05Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -102,6 +103,7 @@ public final void finish() {\n \n   @Override\n   public final void finish(final long stoptimeMicros) {\n+    context.getTrace().touch(); // Update timestamp", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA5NDI5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496094298", "bodyText": "The timestamp is a different resolution and clock type.", "author": "tylerbenson", "createdAt": "2020-09-28T16:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NDg4OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMzY5MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496103691", "bodyText": "Should this logic be encapsulated in PendingTrace so that it returns a boolean? What happens if someone unaware of this bit of logic here changes the time source it uses?", "author": "richardstartin", "createdAt": "2020-09-28T17:04:05Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNzcyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496127729", "bodyText": "Yes, mixing time sources would be quite confusing.  We probably don't want to be calling System.currentTimeMillis directly here given that we allowed sub-ing out other time sources for spans.", "author": "dougqh", "createdAt": "2020-09-28T17:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMzY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NzAwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496867007", "bodyText": "done. Logic is contained in PendingTrace now.", "author": "tylerbenson", "createdAt": "2020-09-29T16:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMzY5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496110952", "bodyText": "Rather than sleeping, would it better to await completion?", "author": "dougqh", "createdAt": "2020-09-28T17:17:24Z", "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNDIyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496124220", "bodyText": "Await what completion?", "author": "tylerbenson", "createdAt": "2020-09-28T17:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4MjQ5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496882496", "bodyText": "According to the comment, you are waiting for the reporting of a trace.  Can that be done more explicitly?", "author": "dougqh", "createdAt": "2020-09-29T16:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MTcyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498271727", "bodyText": "Unfortunately the smoke test doesn't have an option for that.  Any ideas on a better way to do so?  Add a flush to the public API?", "author": "tylerbenson", "createdAt": "2020-10-01T14:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNzA4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498407085", "bodyText": "Yes, I think adding a flush would be a better approach than sleeping.  Right now, we're just creating the potential for sporadic test failures.\nOr, maybe, we're just not asserting anything -- in which case, we don't need the sleep at all.", "author": "dougqh", "createdAt": "2020-10-01T17:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNjY5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498506698", "bodyText": "We are asserting that traces are reported.  Would you like the flush added in this PR or a separate one?", "author": "tylerbenson", "createdAt": "2020-10-01T20:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3NjgxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499776812", "bodyText": "Separate is fine.", "author": "dougqh", "createdAt": "2020-10-05T18:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496123367", "bodyText": "I think we should take out this sleep (as mentioned elsewhere), but the handling of InterruptedException here is a bit odd.\nWe might as well let it bubble up and break the containing loop.  Right now, we catch it just to reset the interrupt status and then bail the loop later.", "author": "dougqh", "createdAt": "2020-09-28T17:39:22Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();\n+        }\n+      }\n+    }\n+\n+    private void sleep() {\n+      try {\n+        Thread.sleep(SLEEP_TIME_MS);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0Mjk4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496242985", "bodyText": "I did it this way to avoid printing a lot of thrown InterruptedException's in the logs. Would you prefer the try on the outside of the loop?", "author": "tylerbenson", "createdAt": "2020-09-28T21:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MzMwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496893306", "bodyText": "Why would the InterruptedException show up in the logs?\nYou can catch inside the loop and break.\nIt would also be fine to propagate above the loop & catch there.\nBut really logs shouldn't come into play.", "author": "dougqh", "createdAt": "2020-09-29T16:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MjQ5OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498272499", "bodyText": "Without that catch, I was seeing the exception printed out quite a bit when I ran the tests.  I think the exception is printed out if it is thrown all the way to the root of the thread.", "author": "tylerbenson", "createdAt": "2020-10-01T14:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwODQxOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498508418", "bodyText": "I went ahead and moved the catch outside the loop and removed the @SneakyThrows, but it still needs to do something with the exception.  Would you prefer just ignore it since it doesn't matter if the interrupt flag is set at that point?", "author": "tylerbenson", "createdAt": "2020-10-01T20:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MzY5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499783698", "bodyText": "What else does it need to do something with the exception?  It interrupted the loop that's what it should do.  There's no requirement that we need to log or propagate.", "author": "dougqh", "createdAt": "2020-10-05T18:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496125004", "bodyText": "Given that the queue is shared, sleeping here seems questionable.  I think if a new PendingTrace comes in, we want to wake up and evaluate it.", "author": "dougqh", "createdAt": "2020-09-28T17:42:23Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NDAxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496244014", "bodyText": "The reason I sleep here is because anything new coming in is unlikely to meet the criteria of being old enough to report and we don't want to burn cycles popping off and re-adding traces.", "author": "tylerbenson", "createdAt": "2020-09-28T21:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5Njc0Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496796747", "bodyText": "The sleeping has been removed \ud83d\udc4d", "author": "richardstartin", "createdAt": "2020-09-29T15:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MTEyMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496871123", "bodyText": "@richardstartin , I still have sleep in this case.  if only one item is added to the queue, then it would run a hot loop until the time limit reached for publishing without this sleep.", "author": "tylerbenson", "createdAt": "2020-09-29T16:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MjYwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496892608", "bodyText": "Correction, I didn't quite understand that we're only sleep for the single item case.\nThat's kind of subtle and I think comments are warranted.", "author": "dougqh", "createdAt": "2020-09-29T16:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkwOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496943909", "bodyText": "Thinking about this a bit more, I think we might want to change this a bit to handle the case where several traces arrive at the same time that are all frequently delayed.  I think that's likely to come up often with async web frameworks.\nI think we might want to burn through the queue until we arrive back where we started.  Once we get back to the start, I think we might want to wait.  But honestly, I'm not entirely sure.\nI'm also concerned that we're going to be churning and creating a lot of Nodes in the Queue.  One way to fix that would to use a LinkedTransferQueue, but I think a simple size restricted BlockingQueue is probably our best choice.", "author": "dougqh", "createdAt": "2020-09-29T18:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNjU2Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496126562", "bodyText": "This comment is kind of cryptic.  And if we don't need to write, maybe, we should call a cleanUp routine directly instead.  I think that would be more clear.\nAlso, given that I don't think a PendingTrace has a definitive end, I'm curious what clean-up we are doing.", "author": "dougqh", "createdAt": "2020-09-28T17:44:59Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MjEwMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496872101", "bodyText": "I removed this for now.  I'll add it back in with a better comment later if I need.  (I can't remember which test case was failing without this.)", "author": "tylerbenson", "createdAt": "2020-09-29T16:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNjU2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODI5MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496128290", "bodyText": "This time is probably now a bit misleading.  We might want to put this to be around the actual write.", "author": "dougqh", "createdAt": "2020-09-28T17:47:54Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?\n       try (Recording recording = tracer.writeTimer()) {", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MjU0OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496872549", "bodyText": "moved.", "author": "tylerbenson", "createdAt": "2020-09-29T16:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 275add01a4..89d7710a90 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -235,10 +247,7 @@ public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements Agent\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      // FIXME: Does this still make sense to measure?\n-      try (Recording recording = tracer.writeTimer()) {\n-        PENDING_TRACE_BUFFER.enqueue(this);\n-      }\n+      pendingTraceBuffer.enqueue(this);\n     } else {\n       if (tracer.getPartialFlushMinSpans() > 0 && size() > tracer.getPartialFlushMinSpans()) {\n         try (Recording recording = tracer.writeTimer()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODc1Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496128752", "bodyText": "timer here?", "author": "dougqh", "createdAt": "2020-09-28T17:48:46Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NDE1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496144151", "bodyText": "I'm going to put the timer inside write instead.", "author": "tylerbenson", "createdAt": "2020-09-28T18:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODc1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTAwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496129000", "bodyText": "Should this have a health metric?  Should we track how many times we re-enqueue?", "author": "dougqh", "createdAt": "2020-09-28T17:49:14Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTI0OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496129249", "bodyText": "timer here?", "author": "dougqh", "createdAt": "2020-09-28T17:49:42Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MzkxMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496143913", "bodyText": "I'm going to put the timer inside write instead.", "author": "tylerbenson", "createdAt": "2020-09-28T18:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTI0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..b22f801754 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,52 +2,50 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNzc1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496137751", "bodyText": "isWritten doesn't need to be AtomicBoolean if we're going to synchronize anyway.  This could simply be a volatile.\n\nThis part doesn't have to be fixed.", "author": "dougqh", "createdAt": "2020-09-28T18:04:28Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,7 +277,7 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwOTQ3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498509476", "bodyText": "noted... this will likely go away in a future refactor anyway.  I did rename it to align with the new system.", "author": "tylerbenson", "createdAt": "2020-10-01T20:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNzc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d67779f990f36957ed9109f21abc18faabcb61dc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 275add01a4..89d7710a90 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -279,25 +288,29 @@ public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements Agent\n \n   synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {\n-      removePendingTrace();\n-      if (!isEmpty()) {\n-        int size = size();\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+      try (Recording recording = tracer.writeTimer()) {\n+        if (!isEmpty()) {\n+          int size = size();\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+          }\n+          List<DDSpan> trace = new ArrayList<>(size);\n+          trace.addAll(this);\n+          // TODO - strange that tests expect the contents\n+          //  NOT to be cleared here. Keeping the spans around\n+          //  could lead to them all being promoted by nepotism,\n+          //  whereas some of them might avoid this if they're\n+          //  dropped when we write\n+          tracer.write(trace);\n         }\n-        List<DDSpan> trace = new ArrayList<>(size);\n-        trace.addAll(this);\n-        // TODO - strange that tests expect the contents\n-        //  NOT to be cleared here. Keeping the spans around\n-        //  could lead to them all being promoted by nepotism,\n-        //  whereas some of them might avoid this if they're\n-        //  dropped when we write\n-        tracer.write(trace);\n       }\n     }\n   }\n \n   public synchronized boolean clean() {\n+    if (isWritten.get()) {\n+      return false;\n+    }\n     Reference ref;\n     int count = 0;\n     while ((ref = continuationReferenceQueue.poll()) != null) {\n"}}, {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc", "url": "https://github.com/DataDog/dd-trace-java/commit/d67779f990f36957ed9109f21abc18faabcb61dc", "message": "Various code review fixes\n\n* Switched to a blocking queue\n* Removed SpanCleaner and queued tasks directly\n* Changed thread init behavior for PendingTraceBuffer\n* Added PendingTrace.Factory to improve interactions for creation", "committedDate": "2020-09-28T21:48:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjUwNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496786505", "bodyText": "Yes, I appreciate we're dealing with technical debt pragmatically here, but it would be nice not to need to do things like this.", "author": "richardstartin", "createdAt": "2020-09-29T14:55:35Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -83,6 +83,13 @@\n   private static final String LANG_INTERPRETER_VENDOR_STATSD_TAG = \"lang_interpreter_vendor\";\n   private static final String TRACER_VERSION_STATSD_TAG = \"tracer_version\";\n \n+  // FIXME: This is static instead of instance because we don't reliably close the tracer in tests.", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjkxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496786910", "bodyText": "nice", "author": "richardstartin", "createdAt": "2020-09-29T14:56:04Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -120,8 +130,10 @@ public void touch() {\n     lastReferenced = Clock.currentNanoTicks();\n   }\n \n-  public long getLastReferenced() {\n-    return lastReferenced;\n+  public boolean lastReferencedNanosAgo(long nanos) {", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODQyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496788420", "bodyText": "I would consider making this quite a lot bigger", "author": "richardstartin", "createdAt": "2020-09-29T14:57:55Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -2,73 +2,60 @@\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwOTY4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498509685", "bodyText": "is 4096 big enough?", "author": "tylerbenson", "createdAt": "2020-10-01T20:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODQyMA=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex b22f801754..a66039251d 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -3,13 +3,11 @@ package datadog.trace.core;\n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n import java.util.concurrent.TimeUnit;\n-import lombok.SneakyThrows;\n import org.jctools.queues.MessagePassingQueue;\n import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n-  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n-  private static final int BUFFER_SIZE = 1024;\n+  private static final int BUFFER_SIZE = 1 << 12; // 4096\n \n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODkyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496788922", "bodyText": "Maybe allocate a private static final instance", "author": "richardstartin", "createdAt": "2020-09-29T14:58:35Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -2,73 +2,60 @@\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex b22f801754..a66039251d 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -3,13 +3,11 @@ package datadog.trace.core;\n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n import java.util.concurrent.TimeUnit;\n-import lombok.SneakyThrows;\n import org.jctools.queues.MessagePassingQueue;\n import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n-  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n-  private static final int BUFFER_SIZE = 1024;\n+  private static final int BUFFER_SIZE = 1 << 12; // 4096\n \n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NjEyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496796122", "bodyText": "I believe this was where the Thread.join() was, and is no longer here.", "author": "richardstartin", "createdAt": "2020-09-29T15:07:54Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import java.util.concurrent.TimeUnit;\n+import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n+  }\n+\n+  public void start() {\n+    worker.start();\n+  }\n+\n+  @Override\n+  public void close() {\n+    closed = true;", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3NDExMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496874111", "bodyText": "yep.  it's been removed.", "author": "tylerbenson", "createdAt": "2020-09-29T16:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NjEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex b22f801754..a66039251d 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -3,13 +3,11 @@ package datadog.trace.core;\n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n import java.util.concurrent.TimeUnit;\n-import lombok.SneakyThrows;\n import org.jctools.queues.MessagePassingQueue;\n import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n-  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n-  private static final int BUFFER_SIZE = 1024;\n+  private static final int BUFFER_SIZE = 1 << 12; // 4096\n \n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496812117", "bodyText": "So I'm a bit afraid that holding back traces when we actually reach zero will make all our traces back up in this buffer, while it's actually only the ones that were we don't reach zero that we need to force flush at a certain interval.\nWhat is it that we want to achieve longterm with this change?", "author": "bantonsson", "createdAt": "2020-09-29T15:26:12Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,9 +247,7 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      try (Recording recording = tracer.writeTimer()) {\n-        write();\n-      }\n+      pendingTraceBuffer.enqueue(this);", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3NjI3Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496876277", "bodyText": "The goal is to eventually remove all reference counting/continuations.  This slight async delay should cover most of the cases which would cause async work to be split up without continuations.", "author": "tylerbenson", "createdAt": "2020-09-29T16:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMwNjcyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r497306725", "bodyText": "I completely agree that we need to clean up/remove the continuations, but I'm not so sure that we should remove all forms of reference counting, since I don't see how we can validate correctness of an instrumentation without some form of strict mode during testing.", "author": "bantonsson", "createdAt": "2020-09-30T07:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxMTk1Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498511952", "bodyText": "Maybe we need to have two different types of PendingTrace.  One that does strict ref counting and another with this timeout mechanism.", "author": "tylerbenson", "createdAt": "2020-10-01T21:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 89d7710a90..8702797fcd 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -245,8 +263,11 @@ public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements Agent\n   }\n \n   private void expireReference() {\n+    if (!traceValid.get()) {\n+      return;\n+    }\n     final int count = pendingReferenceCount.decrementAndGet();\n-    if (count == 0) {\n+    if (count == 0 || rootSpanWritten.get()) {\n       pendingTraceBuffer.enqueue(this);\n     } else {\n       if (tracer.getPartialFlushMinSpans() > 0 && size() > tracer.getPartialFlushMinSpans()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NDk1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496884956", "bodyText": "Rather than doing an instanceof check on DDAgentWriter, it would make more sense to add a flush method onto the Writer.", "author": "dougqh", "createdAt": "2020-09-29T16:40:24Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -487,10 +492,19 @@ public void addScopeListener(final ScopeListener listener) {\n \n   @Override\n   public void close() {\n-    PendingTrace.close();\n+    // FIXME: can't close PENDING_TRACE_BUFFER since it is a static/shared instance.\n+    // PENDING_TRACE_BUFFER.close();\n     writer.close();\n   }\n \n+  @Override\n+  public void flush() {\n+    PENDING_TRACE_BUFFER.flush();\n+    if (writer instanceof DDAgentWriter) {", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "47106517ba07afce1ebc1a232495a0dc8c6035fc", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java b/dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java\nindex 4440ff28cc..26a06ff91e 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java\n\n@@ -500,9 +507,7 @@ public class CoreTracer implements AgentTracer.TracerAPI {\n   @Override\n   public void flush() {\n     PENDING_TRACE_BUFFER.flush();\n-    if (writer instanceof DDAgentWriter) {\n-      ((DDAgentWriter) writer).flush();\n-    }\n+    writer.flush();\n   }\n \n   private static DDScopeEventFactory createScopeEventFactory() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NjM3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496886376", "bodyText": "Should the constructor be public?", "author": "dougqh", "createdAt": "2020-09-29T16:42:41Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -26,17 +25,32 @@\n \n @Slf4j\n public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements AgentTrace {\n+  private static final long CLEAN_FREQUENCY = 1;\n \n-  static PendingTrace create(final CoreTracer tracer, final DDId traceId) {\n-    final PendingTrace pendingTrace = new PendingTrace(tracer, traceId);\n-    pendingTrace.addPendingTrace();\n-    return pendingTrace;\n-  }\n+  public static class Factory {\n+    private final CoreTracer tracer;\n+    private final PendingTraceBuffer pendingTraceBuffer;\n+\n+    public Factory(CoreTracer tracer, PendingTraceBuffer pendingTraceBuffer) {", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNTc1MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498515750", "bodyText": "Changed to package visible.", "author": "tylerbenson", "createdAt": "2020-10-01T21:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NjM3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 89d7710a90..8702797fcd 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -24,19 +24,19 @@ import java.util.concurrent.atomic.AtomicReference;\n import lombok.extern.slf4j.Slf4j;\n \n @Slf4j\n-public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements AgentTrace {\n+public class PendingTrace implements AgentTrace {\n   private static final long CLEAN_FREQUENCY = 1;\n \n-  public static class Factory {\n+  static class Factory {\n     private final CoreTracer tracer;\n     private final PendingTraceBuffer pendingTraceBuffer;\n \n-    public Factory(CoreTracer tracer, PendingTraceBuffer pendingTraceBuffer) {\n+    Factory(CoreTracer tracer, PendingTraceBuffer pendingTraceBuffer) {\n       this.tracer = tracer;\n       this.pendingTraceBuffer = pendingTraceBuffer;\n     }\n \n-    public PendingTrace create(final DDId traceId) {\n+    PendingTrace create(final DDId traceId) {\n       final PendingTrace pendingTrace = new PendingTrace(tracer, traceId, pendingTraceBuffer);\n       AgentTaskScheduler.INSTANCE.weakScheduleAtFixedRate(\n           PendingTraceCleanerTask.INSTANCE,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496888309", "bodyText": "Okay, so short-circuit clean-up if we've already written.\nI still need clarification on the lifecycle of PendingTrace object to understand if this is correct.", "author": "dougqh", "createdAt": "2020-09-29T16:45:41Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,27 +286,31 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {\n-      removePendingTrace();\n-      if (!isEmpty()) {\n-        int size = size();\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+      try (Recording recording = tracer.writeTimer()) {\n+        if (!isEmpty()) {\n+          int size = size();\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+          }\n+          List<DDSpan> trace = new ArrayList<>(size);\n+          trace.addAll(this);\n+          // TODO - strange that tests expect the contents\n+          //  NOT to be cleared here. Keeping the spans around\n+          //  could lead to them all being promoted by nepotism,\n+          //  whereas some of them might avoid this if they're\n+          //  dropped when we write\n+          tracer.write(trace);\n         }\n-        List<DDSpan> trace = new ArrayList<>(size);\n-        trace.addAll(this);\n-        // TODO - strange that tests expect the contents\n-        //  NOT to be cleared here. Keeping the spans around\n-        //  could lead to them all being promoted by nepotism,\n-        //  whereas some of them might avoid this if they're\n-        //  dropped when we write\n-        tracer.write(trace);\n       }\n     }\n   }\n \n   public synchronized boolean clean() {\n+    if (isWritten.get()) {", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NzE0Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496897147", "bodyText": "Since I am putting each individual PendingTrace into the AgentTaskScheduler with no way to cancel those tasks when they're done (it relies on GC to discard the tasks), this seemed like a good way to reduce that impact.", "author": "tylerbenson", "createdAt": "2020-09-29T16:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwNDQ1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496904456", "bodyText": "To answer the question about the partial flush, that is reported as a separate list of spans and association with the pending trace is no longer needed.\nI think there is a good question about late arriving spans that I need to consider further.", "author": "tylerbenson", "createdAt": "2020-09-29T17:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNjg0NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498516844", "bodyText": "I removed this short circuit and fixed the late arrival flush.  The clean method will be removed in the future when we no longer track all the references.", "author": "tylerbenson", "createdAt": "2020-10-01T21:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 89d7710a90..8702797fcd 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -287,30 +308,28 @@ public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements Agent\n   }\n \n   synchronized void write() {\n-    if (isWritten.compareAndSet(false, true)) {\n+    rootSpanWritten.set(true);\n+    if (!finishedSpans.isEmpty()) {\n       try (Recording recording = tracer.writeTimer()) {\n-        if (!isEmpty()) {\n-          int size = size();\n-          if (log.isDebugEnabled()) {\n-            log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n-          }\n-          List<DDSpan> trace = new ArrayList<>(size);\n-          trace.addAll(this);\n-          // TODO - strange that tests expect the contents\n-          //  NOT to be cleared here. Keeping the spans around\n-          //  could lead to them all being promoted by nepotism,\n-          //  whereas some of them might avoid this if they're\n-          //  dropped when we write\n-          tracer.write(trace);\n+        int size = size();\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+        }\n+        List<DDSpan> trace = new ArrayList<>(size);\n+\n+        final Iterator<DDSpan> it = finishedSpans.iterator();\n+        while (it.hasNext()) {\n+          final DDSpan span = it.next();\n+          trace.add(span);\n+          completedSpanCount.decrementAndGet();\n+          it.remove();\n         }\n+        tracer.write(trace);\n       }\n     }\n   }\n \n   public synchronized boolean clean() {\n-    if (isWritten.get()) {\n-      return false;\n-    }\n     Reference ref;\n     int count = 0;\n     while ((ref = continuationReferenceQueue.poll()) != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMzQyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496923425", "bodyText": "Can PENDING_TRACE_BUFFER.close raise an exception?\nIf so, this should have a try / finally.\nGenerally, I'd just assume closing logic, should do try / finally for each step for safety.", "author": "dougqh", "createdAt": "2020-09-29T17:42:17Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -334,13 +357,15 @@ private void removePendingTrace() {\n   }\n \n   static void initialize() {\n+    PENDING_TRACE_BUFFER.start();\n     final SpanCleaner oldCleaner = SPAN_CLEANER.getAndSet(new SpanCleaner());\n     if (oldCleaner != null) {\n       oldCleaner.close();\n     }\n   }\n \n   static void close() {\n+    PENDING_TRACE_BUFFER.close();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwODI3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498408276", "bodyText": "I need this question answered.  Or, I need this to be fixed to approve.", "author": "dougqh", "createdAt": "2020-10-01T17:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMzQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNDM5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498504398", "bodyText": "that close method only calls interrupt() on the worker thread with no blocking, so this should not throw any exceptions.", "author": "tylerbenson", "createdAt": "2020-10-01T20:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMzQyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 275add01a4..8702797fcd 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -331,84 +362,17 @@ public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements Agent\n     return count > 0;\n   }\n \n-  @Override\n-  public void addFirst(final DDSpan span) {\n-    super.addFirst(span);\n-    completedSpanCount.incrementAndGet();\n-  }\n-\n-  @Override\n   public int size() {\n     return completedSpanCount.get();\n   }\n \n-  private void addPendingTrace() {\n-    final SpanCleaner cleaner = SPAN_CLEANER.get();\n-    if (cleaner != null) {\n-      cleaner.pendingTraces.add(this);\n-    }\n-  }\n-\n-  private void removePendingTrace() {\n-    final SpanCleaner cleaner = SPAN_CLEANER.get();\n-    if (cleaner != null) {\n-      cleaner.pendingTraces.remove(this);\n-    }\n-  }\n-\n-  static void initialize() {\n-    PENDING_TRACE_BUFFER.start();\n-    final SpanCleaner oldCleaner = SPAN_CLEANER.getAndSet(new SpanCleaner());\n-    if (oldCleaner != null) {\n-      oldCleaner.close();\n-    }\n-  }\n-\n-  static void close() {\n-    PENDING_TRACE_BUFFER.close();\n-    final SpanCleaner cleaner = SPAN_CLEANER.getAndSet(null);\n-    if (cleaner != null) {\n-      cleaner.close();\n-    }\n-  }\n-\n-  // FIXME: it should be possible to simplify this logic and avoid having SpanCleaner and\n-  // SpanCleanerTask\n-  private static class SpanCleaner implements Runnable, Closeable {\n-    private static final long CLEAN_FREQUENCY = 1;\n-\n-    private final Set<PendingTrace> pendingTraces =\n-        Collections.newSetFromMap(new ConcurrentHashMap<PendingTrace, Boolean>());\n-\n-    public SpanCleaner() {\n-      AgentTaskScheduler.INSTANCE.weakScheduleAtFixedRate(\n-          SpanCleanerTask.INSTANCE, this, 0, CLEAN_FREQUENCY, TimeUnit.SECONDS);\n-    }\n-\n-    @Override\n-    public void run() {\n-      for (final PendingTrace trace : pendingTraces) {\n-        trace.clean();\n-      }\n-    }\n-\n-    @Override\n-    public void close() {\n-      // Make sure that whatever was left over gets cleaned up\n-      run();\n-    }\n-  }\n-\n-  /*\n-   * Important to use explicit class to avoid implicit hard references to cleaners from within executor.\n-   */\n-  private static class SpanCleanerTask implements Task<SpanCleaner> {\n+  private static class PendingTraceCleanerTask implements Task<PendingTrace> {\n \n-    static final SpanCleanerTask INSTANCE = new SpanCleanerTask();\n+    static final PendingTraceCleanerTask INSTANCE = new PendingTraceCleanerTask();\n \n     @Override\n-    public void run(final SpanCleaner target) {\n-      target.run();\n+    public void run(final PendingTrace target) {\n+      target.clean();\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI5NDgzNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r497294834", "bodyText": "I have a hard time following the wider implications of these changes. Will this mean that in the future when all reference counting is removed, we will flush any Trace with a Span that does work for longer than, or takes longer to  start than FORCE_SEND_DELAY_MS, which is currently 5 ms, and not report any more spans that happen after that or what will happen? I mean work taking more than 5 ms is not uncommon.", "author": "bantonsson", "createdAt": "2020-09-30T07:23:43Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import java.util.concurrent.TimeUnit;\n+import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n+  }\n+\n+  public void start() {\n+    worker.start();\n+  }\n+\n+  @Override\n+  public void close() {\n+    closed = true;\n+    worker.interrupt();\n+  }\n+\n+  public void flush() {\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!closed && !Thread.currentThread().isInterrupted()) {\n+\n+        PendingTrace pendingTrace = queue.take(); // block until available.\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {", "originalCommit": "d67779f990f36957ed9109f21abc18faabcb61dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyNjYwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498426606", "bodyText": "Yes, I think this might be a bit aggressive.  Clearly, we have to cap how long we wait to send, but I don't think 5ms of inactivity is a long enough delay -- and I think it ends up needlessly churning the queue.\nI think what we might want to do is...\n1 - Put trace in a ready state when the root span finishes\n1a - If we're in a ready state and there are no outstanding spans or continuations, we send\n1b - If we're in a ready state and there are outstanding spans or continuations, we delay 1s with up to 3 delays\n2 - Once the root is released, the PendingTrace (or a new PendingTrace for the same trace ID) goes back into a ready state when a span is finished\n2a - the new batch is implicitly a partial batch & should go into the delayed state\n3 - Partial flushes - are a variation on case 2 above, but before the root has been finished\nAs for the delay queue, I think I'm inclined towards a priority queue sorted by the time we should next check the element.  It could also be approximate.  We could create chunks by 250ms time buckets or something similar.\nI'll also repeat that I think is really important that this change documents how the pipeline works.  Both in the PR -- and in comments or a doc in the repository.", "author": "dougqh", "createdAt": "2020-10-01T18:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI5NDgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex b22f801754..a66039251d 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -3,13 +3,11 @@ package datadog.trace.core;\n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n import java.util.concurrent.TimeUnit;\n-import lombok.SneakyThrows;\n import org.jctools.queues.MessagePassingQueue;\n import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n-  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n-  private static final int BUFFER_SIZE = 1024;\n+  private static final int BUFFER_SIZE = 1 << 12; // 4096\n \n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMDUyNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498410526", "bodyText": "I suppose we only have one but I think AtomicReference might overkill.  volatile + double checking would be sufficient.  We can leave this as is.", "author": "dougqh", "createdAt": "2020-10-01T17:36:48Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwMzc0NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498503744", "bodyText": "This is out of date... I updated this a few days ago.", "author": "tylerbenson", "createdAt": "2020-10-01T20:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMDUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\nindex ee50f0c4b8..a66039251d 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java\n\n@@ -2,102 +2,78 @@ package datadog.trace.core;\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  private static final int BUFFER_SIZE = 1 << 12; // 4096\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n   }\n \n   private final class Worker implements Runnable {\n \n-    @SneakyThrows\n     @Override\n     public void run() {\n-      while (!Thread.interrupted()) {\n-        PendingTrace pendingTrace = queue.poll();\n-\n-        if (pendingTrace == null) {\n-          // Queue is empty.  Lets sleep and try again.\n-          sleep();\n-          continue;\n-        }\n-\n-        if (pendingTrace.isEmpty()) {\n-          // \"write\" it out to allow cleanup.\n-          pendingTrace.write();\n-          continue;\n-        }\n-\n-        DDSpan rootSpan = pendingTrace.getRootSpan();\n-\n-        long finishTimestampMillis =\n-            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n-        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n-          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n-          pendingTrace.write();\n-          continue;\n-        }\n-\n-        long currentNanoTicks = Clock.currentNanoTicks();\n-        long lastReferenced = pendingTrace.getLastReferenced();\n-        long delta = currentNanoTicks - lastReferenced;\n-\n-        if (SEND_DELAY_NS <= delta) {\n-          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n-          pendingTrace.write();\n-        } else {\n-          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n-          queue.add(pendingTrace);\n-          sleep();\n-        }\n-      }\n-    }\n-\n-    private void sleep() {\n       try {\n-        Thread.sleep(SLEEP_TIME_MS);\n+        while (!closed && !Thread.currentThread().isInterrupted()) {\n+\n+          PendingTrace pendingTrace = queue.take(); // block until available.\n+\n+          long oldestFinishedTime = pendingTrace.oldestFinishedTime();\n+\n+          long finishTimestampMillis = TimeUnit.NANOSECONDS.toMillis(oldestFinishedTime);\n+          if (finishTimestampMillis <= System.currentTimeMillis() - FORCE_SEND_DELAY_MS) {\n+            // Root span is getting old. We need to send the trace to avoid being discarded by\n+            // agent.\n+            pendingTrace.write();\n+            continue;\n+          }\n+\n+          if (pendingTrace.lastReferencedNanosAgo(SEND_DELAY_NS)) {\n+            // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+            pendingTrace.write();\n+          } else {\n+            // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+            enqueue(pendingTrace);\n+            Thread.sleep(SLEEP_TIME_MS);\n+          }\n+        }\n       } catch (InterruptedException e) {\n         Thread.currentThread().interrupt();\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODI4MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498468281", "bodyText": "I think the raciness of lastReferenced is fine, but I think this warrants a comment.", "author": "dougqh", "createdAt": "2020-10-01T19:28:59Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -99,7 +111,17 @@ private PendingTrace(final CoreTracer tracer, final DDId traceId) {\n    * @return timestamp in nanoseconds\n    */\n   public long getCurrentTimeNano() {\n-    return startTimeNano + Math.max(0, Clock.currentNanoTicks() - startNanoTicks);\n+    long nanoTicks = Clock.currentNanoTicks();\n+    lastReferenced = nanoTicks;\n+    return startTimeNano + Math.max(0, nanoTicks - startNanoTicks);\n+  }\n+\n+  public void touch() {\n+    lastReferenced = Clock.currentNanoTicks();", "originalCommit": "376a716c454a5bcbd86272f595c185513a019b13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNzYyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498517627", "bodyText": "could you be more specific?", "author": "tylerbenson", "createdAt": "2020-10-01T21:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODI4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "370050a84cd5b770df8bdfe56807cce6d95db62e", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\nindex 275add01a4..8702797fcd 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java\n\n@@ -120,8 +139,10 @@ public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements Agent\n     lastReferenced = Clock.currentNanoTicks();\n   }\n \n-  public long getLastReferenced() {\n-    return lastReferenced;\n+  public boolean lastReferencedNanosAgo(long nanos) {\n+    long currentNanoTicks = Clock.currentNanoTicks();\n+    long age = currentNanoTicks - lastReferenced;\n+    return nanos < age;\n   }\n \n   public void registerSpan(final DDSpan span) {\n"}}, {"oid": "370050a84cd5b770df8bdfe56807cce6d95db62e", "url": "https://github.com/DataDog/dd-trace-java/commit/370050a84cd5b770df8bdfe56807cce6d95db62e", "message": "Fix handling for late arrival of spans\n\nMore code review fixes\n* Make PendingTrace.Factory package private\n* Increase buffer size\n* Various cleanup", "committedDate": "2020-10-01T20:41:16Z", "type": "commit"}, {"oid": "d75d7d2ffa76f4328a96b24ce3f3ab1e4d880c55", "url": "https://github.com/DataDog/dd-trace-java/commit/d75d7d2ffa76f4328a96b24ce3f3ab1e4d880c55", "message": "Merge branch 'master' into tyler/pending-trace-delay\n\n# Conflicts:\n#\tdd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "committedDate": "2020-10-01T20:43:32Z", "type": "commit"}, {"oid": "47106517ba07afce1ebc1a232495a0dc8c6035fc", "url": "https://github.com/DataDog/dd-trace-java/commit/47106517ba07afce1ebc1a232495a0dc8c6035fc", "message": "More review and test fixes.", "committedDate": "2020-10-01T21:34:45Z", "type": "commit"}, {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2", "url": "https://github.com/DataDog/dd-trace-java/commit/7678312cfab45090d2fbd460c30c803ef87a57c2", "message": "Allow immediate writes if no remaining pending references\n\nUpdate the tests... was more complicated to test PendingTraceBuffer since it now requires continuations for root to be delayed.\n\nI removed the test that verifies the trace discarded if span GC'd because it is unreliable... the trace gets buffered and success depends on if GC cleaning happens before the buffer timeout expires.", "committedDate": "2020-10-02T20:44:16Z", "type": "commit"}, {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2", "url": "https://github.com/DataDog/dd-trace-java/commit/7678312cfab45090d2fbd460c30c803ef87a57c2", "message": "Allow immediate writes if no remaining pending references\n\nUpdate the tests... was more complicated to test PendingTraceBuffer since it now requires continuations for root to be delayed.\n\nI removed the test that verifies the trace discarded if span GC'd because it is unreliable... the trace gets buffered and success depends on if GC cleaning happens before the buffer timeout expires.", "committedDate": "2020-10-02T20:44:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MTc4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499781785", "bodyText": "Does this need a try / finally?  What's expected to happen with the writer if PendingTraceBuffer.flush raises an exception.", "author": "dougqh", "createdAt": "2020-10-05T18:11:42Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -494,10 +499,17 @@ public void addScopeListener(final ScopeListener listener) {\n \n   @Override\n   public void close() {\n-    PendingTrace.close();\n+    // FIXME: can't close PENDING_TRACE_BUFFER since it is a static/shared instance.\n+    // PENDING_TRACE_BUFFER.close();\n     writer.close();\n   }\n \n+  @Override\n+  public void flush() {\n+    PENDING_TRACE_BUFFER.flush();", "originalCommit": "7678312cfab45090d2fbd460c30c803ef87a57c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNzU1NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499807554", "bodyText": "It doesn't declare any exceptions to be thrown (unless the drain destination is null, which is hardcoded so it shouldn't).  I don't have a problem adding one just in case though.\nDo you want me to add that?", "author": "tylerbenson", "createdAt": "2020-10-05T18:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MTc4NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwODA2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499808067", "bodyText": "I think this probably needs some elaboration -- not necessarily as header doc, but I'm expect more documentation inside PendingTrace & PendingTraceBuffer.  I'd like a better high-level view of the overall flow that someone can read without reading over all the code to understand what's happening.", "author": "dougqh", "createdAt": "2020-10-05T19:00:48Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -23,6 +23,24 @@\n import java.util.concurrent.atomic.AtomicReference;\n import lombok.extern.slf4j.Slf4j;\n \n+/**\n+ * This class implements the following data flow rules when a Span is finished:", "originalCommit": "7678312cfab45090d2fbd460c30c803ef87a57c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NzgzNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499857836", "bodyText": "That's what I tried to do with this comment.  Provide enough context at the conditions to understand what is going on.", "author": "tylerbenson", "createdAt": "2020-10-05T20:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwODA2Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "7c7ec7b10698a41e0fe2eb3c722d4efb63cfed69", "url": "https://github.com/DataDog/dd-trace-java/commit/7c7ec7b10698a41e0fe2eb3c722d4efb63cfed69", "message": "Another comment", "committedDate": "2020-10-05T20:37:52Z", "type": "commit"}, {"oid": "4fd9d71140df330d2dc1018a5b35e1c341829fd1", "url": "https://github.com/DataDog/dd-trace-java/commit/4fd9d71140df330d2dc1018a5b35e1c341829fd1", "message": "Merge branch 'master' into tyler/pending-trace-delay", "committedDate": "2020-10-05T20:38:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzMzA2Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r500033063", "bodyText": "I know I'm late to the game, but I noticed this while rebasing my branch on top of latest master, and you can most definitely have a continuation on a root span, so this is not correct. The effect is that a number of tests run noticeably slower (as in I can see it on the test counter incrementing slowly), and the new tests that didn't wait now needs to wait for the tracer.", "author": "bantonsson", "createdAt": "2020-10-06T06:28:25Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -203,45 +269,34 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n     synchronized (continuation) {\n       if (continuation.isRegistered()) {\n         continuation.cancel(weakContinuations);\n-        expireReference();\n+        expireReference(false);", "originalCommit": "4fd9d71140df330d2dc1018a5b35e1c341829fd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MjM3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r500192376", "bodyText": "Opened a PR #1955", "author": "bantonsson", "createdAt": "2020-10-06T11:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzMzA2Mw=="}], "type": "inlineReview", "revised_code": null}]}