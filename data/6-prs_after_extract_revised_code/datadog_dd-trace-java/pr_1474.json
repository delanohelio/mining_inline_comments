{"pr_number": 1474, "pr_title": "Add simple percentage based TraceProfilingScopeManager", "pr_createdAt": "2020-05-19T20:46:34Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1474", "timeline": [{"oid": "984af7e63e08734faba4bc900ea514132fdfa07c", "url": "https://github.com/DataDog/dd-trace-java/commit/984af7e63e08734faba4bc900ea514132fdfa07c", "message": "Add simple percentage based TraceProfilingScopeManager\n\nAnd associated config.  If not configured, the heuristical model is used.\n\nAlso add some accessor methods to the AgentSpan interface to gain access to the trace/span ids.", "committedDate": "2020-05-19T20:43:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyODQxOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1474#discussion_r427628418", "bodyText": "This is a Bernoulli trial - you evaluate this condition once for every span and should sample roughly percent of the time. What you could do to eliminate any overhead except when you profile is generate the number of unsuccessful trials - the number of spans you won't sample - there should be between two sampled spans.\nThe number of unsuccessful trials between two successes is geometrically distributed and you can approximate it with Math.log(ThreadLocalRandom.current().nextDouble())/Math.log(1 - percent) + 1.\nConcretely, this would introduce variables long nextSampledSpan = Math.log(ThreadLocalRandom.current().nextDouble())/Math.log(1 - percent) + 1 and long spanCount = 0. On each span, increment spanCount. If spanCount == nextSampledSpan, sample and update (nextSampledSpan += Math.log(ThreadLocalRandom.current().nextDouble())/Math.log(1 - percent) + 1). If nextSampledSpan != spanCount, you do literally nothing except bump a counter; the overhead is tiny unless you're actually going to do some useful work (activate the profiler).", "author": "richardstartin", "createdAt": "2020-05-19T22:07:38Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/TraceProfilingScopeManager.java", "diffHunk": "@@ -21,62 +23,106 @@ protected Boolean initialValue() {\n         }\n       };\n \n-  private final TraceStatsCollector statsCollector;\n-  private final RateLimiter rateLimiter = RateLimiter.create(ACTIVATIONS_PER_SECOND);\n-  private volatile long lastProfileTimestamp = System.nanoTime();\n+  protected final RateLimiter rateLimiter = RateLimiter.create(ACTIVATIONS_PER_SECOND);\n \n-  public TraceProfilingScopeManager(\n-      final TraceStatsCollector statsCollector, final ScopeInterceptor delegate) {\n+  private TraceProfilingScopeManager(final ScopeInterceptor delegate) {\n     super(delegate);\n-    this.statsCollector = statsCollector;\n   }\n \n-  @Override\n-  public Scope handleSpan(final AgentSpan span) {\n-    if (IS_THREAD_PROFILING.get() // don't need to waste a permit if so.\n-        || !(span instanceof DDSpan)\n-        || !maybeInteresting((DDSpan) span)\n-        || !acquireProfilePermit()) {\n-      // We don't want to wrap the scope for profiling.\n-      return delegate.handleSpan(span);\n+  public static TraceProfilingScopeManager create(\n+      final Double methodTraceSampleRate,\n+      final TraceStatsCollector statsCollector,\n+      final ScopeInterceptor delegate) {\n+    if (methodTraceSampleRate != null) {\n+      return new Percentage(methodTraceSampleRate, delegate);\n     }\n-    lastProfileTimestamp = System.nanoTime();\n-    return new TraceProfilingScope(delegate.handleSpan(span));\n+    return new Heuristical(statsCollector, delegate);\n   }\n \n-  private boolean maybeInteresting(final DDSpan span) {\n-    final Histogram traceStats = statsCollector.getTraceStats(span);\n-    if (traceStats == null) {\n-      // No historical data for this trace yet.\n-      return false;\n-    }\n-    final Histogram overallStats = statsCollector.getOverallStats();\n+  private static class Percentage extends TraceProfilingScopeManager {\n+    private static final BigDecimal TRACE_ID_MAX_AS_BIG_DECIMAL =\n+        new BigDecimal(CoreTracer.TRACE_ID_MAX);\n+\n+    private final BigInteger cutoff;\n \n-    final long traceAverage = traceStats.getValueAtPercentile(50);\n-    final long overall80 = overallStats.getValueAtPercentile(80);\n-    if (overall80 < traceAverage) {\n-      // This trace is likely to be slower than most, so lets profile it.\n-      return true;\n+    private Percentage(final double percent, final ScopeInterceptor delegate) {\n+      super(delegate);\n+      assert 0 <= percent && percent <= 1;\n+      cutoff = new BigDecimal(percent).multiply(TRACE_ID_MAX_AS_BIG_DECIMAL).toBigInteger();\n     }\n \n-    final long traceCount = traceStats.getTotalCount();\n-    final long overallCount = overallStats.getTotalCount();\n-    if (3 < traceCount && traceCount < (overallCount * .9)) {\n-      // This is an uncommon trace (but not unique), so lets profile it.\n-      return true;\n+    @Override\n+    public Scope handleSpan(final AgentSpan span) {\n+      if (IS_THREAD_PROFILING.get() // don't need to waste a permit if so.\n+          || !shouldSample(span.getLocalRootSpan())) {\n+        // Do we want to apply rate limiting?\n+        // We don't want to wrap the scope for profiling.\n+        return delegate.handleSpan(span);\n+      }\n+      return new TraceProfilingScope(delegate.handleSpan(span));\n     }\n \n-    if (lastProfileTimestamp + MAX_NANOSECONDS_BETWEEN_ACTIVATIONS < System.nanoTime()) {\n-      // It's been a while since we last profiled, so lets take one now.\n-      // Due to the multi-threaded nature here, we will likely have multiple threads enter here\n-      // but they will still be subject to the rate limiter following.\n-      return true;\n+    private boolean shouldSample(final AgentSpan span) {\n+      return span.getTraceId().compareTo(cutoff) <= 0;", "originalCommit": "984af7e63e08734faba4bc900ea514132fdfa07c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE1MDUxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1474#discussion_r428150512", "bodyText": "I think this is a good idea and something we should revisit if we decide to keep this code.  For now I can't implement it with minimal changes and maintain the consistent trace evaluation feature by using the trace id. I don't expect this class to be widely used in the public, so I'd rather keep the impact small.", "author": "tylerbenson", "createdAt": "2020-05-20T16:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyODQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "0d4c7d5bd1d1dbe9c6a63bf77e4e17e7e3c036ff", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/core/scopemanager/TraceProfilingScopeManager.java b/dd-trace-core/src/main/java/datadog/trace/core/scopemanager/TraceProfilingScopeManager.java\nindex a606da06bd..758b1f14ad 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/core/scopemanager/TraceProfilingScopeManager.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/core/scopemanager/TraceProfilingScopeManager.java\n\n@@ -80,6 +81,7 @@ public abstract class TraceProfilingScopeManager extends ScopeInterceptor.Delega\n     @Override\n     public Scope handleSpan(final AgentSpan span) {\n       if (IS_THREAD_PROFILING.get() // don't need to waste a permit if so.\n+          || span instanceof AgentTracer.NoopAgentSpan\n           || !maybeInteresting(span.getLocalRootSpan())\n           || !acquireProfilePermit()) {\n         // We don't want to wrap the scope for profiling.\n"}}, {"oid": "0d4c7d5bd1d1dbe9c6a63bf77e4e17e7e3c036ff", "url": "https://github.com/DataDog/dd-trace-java/commit/0d4c7d5bd1d1dbe9c6a63bf77e4e17e7e3c036ff", "message": "Skip evaluation of NoopSpans.", "committedDate": "2020-05-20T16:18:48Z", "type": "commit"}, {"oid": "5dddfda71df343a01719748a9296815407c76543", "url": "https://github.com/DataDog/dd-trace-java/commit/5dddfda71df343a01719748a9296815407c76543", "message": "move handleSpan to parent and add shouldProfile abstract method.", "committedDate": "2020-05-20T19:51:50Z", "type": "commit"}]}