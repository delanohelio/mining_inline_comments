{"pr_number": 2053, "pr_title": "rxJava 2 instrumentation", "pr_createdAt": "2020-11-05T15:02:49Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2053", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518883891", "bodyText": "I'm not sure about this pattern. Especially given that the spans are being null checked anyway elsewhere, I think it's better to ensure that we always use the same span type.", "author": "richardstartin", "createdAt": "2020-11-06T17:03:21Z", "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {", "originalCommit": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5MDIyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518890220", "bodyText": "This approach is based on the current reactor instrumentation - the idea is that we capture any active span at the time of construction and carry it with the reactive component to use as the parent of any follow-on work.", "author": "mcculls", "createdAt": "2020-11-06T17:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5MjIyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518892222", "bodyText": "But I think it's better to do the null check rather than potentially carry around a differently typed span.", "author": "richardstartin", "createdAt": "2020-11-06T17:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5OTc3MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518899770", "bodyText": "You mean just not use noopSpan() at all here? Sure, I can look at that - I assume we'd also want to make the same change to reactor if it works as it uses noopSpan() in the same pattern at the moment.", "author": "mcculls", "createdAt": "2020-11-06T17:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkwMjIxMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518902213", "bodyText": "Exactly. We must do the null check elsewhere anyway, and I'd prefer to keep the code we're injecting monomorphic wherever possible.", "author": "richardstartin", "createdAt": "2020-11-06T17:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b23907e9844ee467061dc75a69464406629fa8c", "chunk": "diff --git a/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java b/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\nindex 2d2b38a95a..adf4f58ccb 100644\n--- a/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\n+++ b/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\n\n@@ -1,5 +1,7 @@\n package datadog.trace.instrumentation.rxjava2;\n \n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n import static java.util.Collections.singletonMap;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NDU2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518884567", "bodyText": "e.g. this really be an instanceof NoopSpan check, but I think it's much better to do a null check and use just one span type.", "author": "richardstartin", "createdAt": "2020-11-06T17:04:38Z", "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {\n+        span = AgentTracer.noopSpan();\n+      }\n+      InstrumentationContext.get(Flowable.class, AgentSpan.class).put(thiz, span);\n+    }\n+  }\n+\n+  public static class SubscribeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope openScope(\n+        @Advice.This final Flowable<?> thiz,\n+        @Advice.Argument(value = 0, readOnly = false) Subscriber<?> observer) {\n+      if (observer != null) {\n+        AgentSpan span = InstrumentationContext.get(Flowable.class, AgentSpan.class).get(thiz);\n+        if (span != null) {", "originalCommit": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5MjQ1Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518892457", "bodyText": "This follows the reactor approach of using the captured span to wrap around any follow-on work, so instanceof NoopSpan would not be correct here as you'd then miss most of the cases we want to track. Note that we're not creating our own spans here - the goal is to try and carry the context with the reactive work.", "author": "mcculls", "createdAt": "2020-11-06T17:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NDU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5NjAwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518896007", "bodyText": "You're not injecting a null span elsewhere but a NoOpSpan (and, yes, I understand that the intent here is context propagation).", "author": "richardstartin", "createdAt": "2020-11-06T17:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NDU2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7b23907e9844ee467061dc75a69464406629fa8c", "chunk": "diff --git a/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java b/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\nindex 2d2b38a95a..adf4f58ccb 100644\n--- a/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\n+++ b/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\n\n@@ -1,5 +1,7 @@\n package datadog.trace.instrumentation.rxjava2;\n \n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n import static java.util.Collections.singletonMap;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NTEyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518885122", "bodyText": "Rather than injecting the span, I would prefer for this to be State or ConcurrentState holding a Continuation, which at the very least makes it possible to write deterministic tests", "author": "richardstartin", "createdAt": "2020-11-06T17:05:37Z", "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());", "originalCommit": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5NTkxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518895915", "bodyText": "I'd have to look into how that would work for the test scenarios - right now this is modelled as closely as possible to the reactor approach, which also stores spans. (ie. is there a reason the reactor approach stores spans instead of state - should that approach also be changed?)", "author": "mcculls", "createdAt": "2020-11-06T17:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkwMjcxOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518902718", "bodyText": "I think that's worth looking in to, there is some inconsistency in asynchronous instrumentations but it's also not an area which has been bullet proof historically.", "author": "richardstartin", "createdAt": "2020-11-06T17:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk4NjY5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r522986698", "bodyText": "I ran into a few issues using State/ConcurrentState so I'd prefer to merge this using the original approach and then iterate on it. I've also added a range of tests based on the ones from reactor which should help with future refactoring.", "author": "mcculls", "createdAt": "2020-11-13T14:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NTEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "7b23907e9844ee467061dc75a69464406629fa8c", "chunk": "diff --git a/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java b/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\nindex 2d2b38a95a..adf4f58ccb 100644\n--- a/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\n+++ b/dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java\n\n@@ -1,5 +1,7 @@\n package datadog.trace.instrumentation.rxjava2;\n \n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n import static java.util.Collections.singletonMap;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n"}}, {"oid": "7b23907e9844ee467061dc75a69464406629fa8c", "url": "https://github.com/DataDog/dd-trace-java/commit/7b23907e9844ee467061dc75a69464406629fa8c", "message": "Remove use of noopSpan", "committedDate": "2020-11-12T14:38:11Z", "type": "forcePushed"}, {"oid": "099a571bb27d92f2376d0ae3d125f1583f3adcb2", "url": "https://github.com/DataDog/dd-trace-java/commit/099a571bb27d92f2376d0ae3d125f1583f3adcb2", "message": "Instrumentation cleanup", "committedDate": "2020-11-12T20:03:10Z", "type": "forcePushed"}, {"oid": "45895be044cc65846e3edd2e822d2c323b38610b", "url": "https://github.com/DataDog/dd-trace-java/commit/45895be044cc65846e3edd2e822d2c323b38610b", "message": "rxJava propagation spike", "committedDate": "2020-11-13T12:33:45Z", "type": "commit"}, {"oid": "2851ab3d55f068813d788ddf48dd521ed3c54814", "url": "https://github.com/DataDog/dd-trace-java/commit/2851ab3d55f068813d788ddf48dd521ed3c54814", "message": "Remove use of noopSpan", "committedDate": "2020-11-13T12:33:45Z", "type": "commit"}, {"oid": "b705f6ddf2da5dee2c5624090e4d06bbf9734d07", "url": "https://github.com/DataDog/dd-trace-java/commit/b705f6ddf2da5dee2c5624090e4d06bbf9734d07", "message": "Cleanup wrappers", "committedDate": "2020-11-13T12:33:45Z", "type": "commit"}, {"oid": "083c5bd909f2fbe61be8317ab9014b82c04d14aa", "url": "https://github.com/DataDog/dd-trace-java/commit/083c5bd909f2fbe61be8317ab9014b82c04d14aa", "message": "Instrumentation cleanup", "committedDate": "2020-11-13T12:33:45Z", "type": "commit"}, {"oid": "a9d2417fb6ed9d0e26d95044d47700d0a075dd2e", "url": "https://github.com/DataDog/dd-trace-java/commit/a9d2417fb6ed9d0e26d95044d47700d0a075dd2e", "message": "Documentation", "committedDate": "2020-11-13T12:33:45Z", "type": "commit"}, {"oid": "b926501047396aa8b0f4ed99de8d8715fc7d3d09", "url": "https://github.com/DataDog/dd-trace-java/commit/b926501047396aa8b0f4ed99de8d8715fc7d3d09", "message": "m", "committedDate": "2020-11-13T12:33:46Z", "type": "forcePushed"}, {"oid": "1866354cf3c681052f302a3b5df3ea630798c773", "url": "https://github.com/DataDog/dd-trace-java/commit/1866354cf3c681052f302a3b5df3ea630798c773", "message": "RxJava2 tests (based on reactor tests)", "committedDate": "2020-11-13T12:43:10Z", "type": "commit"}, {"oid": "1866354cf3c681052f302a3b5df3ea630798c773", "url": "https://github.com/DataDog/dd-trace-java/commit/1866354cf3c681052f302a3b5df3ea630798c773", "message": "RxJava2 tests (based on reactor tests)", "committedDate": "2020-11-13T12:43:10Z", "type": "forcePushed"}]}