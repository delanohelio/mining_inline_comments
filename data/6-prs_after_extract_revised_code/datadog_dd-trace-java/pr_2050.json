{"pr_number": 2050, "pr_title": "Akka Actor and Akka HTTP bindAndHandle instrumentation", "pr_createdAt": "2020-11-04T14:49:53Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2050", "timeline": [{"oid": "a2a8a8acce98b8bf30461e952c9c9a1745096511", "url": "https://github.com/DataDog/dd-trace-java/commit/a2a8a8acce98b8bf30461e952c9c9a1745096511", "message": "Clean up and expand akka-http server tests", "committedDate": "2020-11-05T14:15:31Z", "type": "forcePushed"}, {"oid": "89649cd1c01645602d7452b8e880649fde7bae80", "url": "https://github.com/DataDog/dd-trace-java/commit/89649cd1c01645602d7452b8e880649fde7bae80", "message": "Clean up and expand akka-http client instrumentation and tests", "committedDate": "2020-11-09T11:51:07Z", "type": "forcePushed"}, {"oid": "7eac56abbc9a95ac3068144992a4467cda4f63b8", "url": "https://github.com/DataDog/dd-trace-java/commit/7eac56abbc9a95ac3068144992a4467cda4f63b8", "message": "Clean up and expand akka-http client instrumentation and tests", "committedDate": "2020-11-09T16:58:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY0OTE0Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520649146", "bodyText": "This seems rather scary and will likely result in unexpected bugs elsewhere.  Do you know why this is necessary?", "author": "tylerbenson", "createdAt": "2020-11-10T15:25:48Z", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaActorCellInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.actor.ActorCell\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n+  }\n+\n+  public static class InvokeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n+      TraceScope scope =\n+          AdviceUtils.startTaskScope(\n+              InstrumentationContext.get(Envelope.class, State.class), envelope);\n+      if (scope != null) {\n+        return scope;\n+      }\n+      // If there is no scope created from the envelope, we create our own noopSpan to make sure\n+      // that we can close all scopes up until this position after exit.\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      return activateSpan(span, false);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(@Advice.Enter TraceScope scope) {\n+      // Clean up any leaking scopes from akka-streams/akka-http et.c.\n+      TraceScope activeScope = activeScope();\n+      while (activeScope != null && activeScope != scope) {\n+        activeScope.close();\n+        activeScope = activeScope();\n+      }\n+      while (activeScope == scope) {\n+        scope.close();\n+        activeScope = activeScope();\n+      }\n+    }\n+  }", "originalCommit": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MjczNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521272736", "bodyText": "There are two things here. One is the intentional leak in the akka-http server instrumentation that you commented on, and the second is just plain defensive programming. There should never ever be anything left on the scope stack after the actor has processed a message.", "author": "bantonsson", "createdAt": "2020-11-11T10:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY0OTE0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f18e63868a377500da2bf6f1a42c72a5860793c4", "chunk": "diff --git a/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java b/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java\nindex 667c37776f..d9322ace89 100644\n--- a/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java\n+++ b/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java\n\n@@ -43,6 +43,17 @@ public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n     return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n   }\n \n+  /**\n+   * This instrumentation is defensive and closes all scopes on the scope stack that were not there\n+   * when we started processing this actor message. The reason for that is twofold.\n+   *\n+   * <p>1) An actor is self contained, and driven by a thread that could serve many other purposes,\n+   * and a scope should not leak out after a message has been processed.\n+   *\n+   * <p>2) We rely on this cleanup mechanism to be able to intentionally leak the scope in the\n+   * {@code AkkaHttpServerInstrumentation} so that it propagates to the user provided request\n+   * handling code that will execute on the same thread in the same actor.\n+   */\n   public static class InvokeAdvice {\n     @Advice.OnMethodEnter(suppress = Throwable.class)\n     public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2NzQ2MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520667460", "bodyText": "lol... zis", "author": "tylerbenson", "createdAt": "2020-11-10T15:48:54Z", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaEnvelopeInstrumentation.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaEnvelopeInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaEnvelopeInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.Envelope\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isConstructor(), getClass().getName() + \"$ConstructAdvice\");\n+  }\n+\n+  public static class ConstructAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void afterInit(@Advice.This Envelope zis) {", "originalCommit": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4MDE1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520680155", "bodyText": "Same concern applies here.", "author": "tylerbenson", "createdAt": "2020-11-10T16:05:00Z", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaMailboxInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.ExcludeFilterProvider;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaMailboxInstrumentation extends Instrumenter.Default\n+    implements ExcludeFilterProvider {\n+\n+  public AkkaMailboxInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.Mailbox\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod().and(named(\"run\")), getClass().getName() + \"$SuppressMailboxRunAdvice\");\n+  }\n+\n+  @Override\n+  public Map<ExcludeFilter.ExcludeType, ? extends Collection<String>> excludedClasses() {\n+    List<String> excludedClass = singletonList(\"akka.dispatch.MailBox\");\n+    EnumMap<ExcludeFilter.ExcludeType, Collection<String>> excludedTypes =\n+        new EnumMap<>(ExcludeFilter.ExcludeType.class);\n+    excludedTypes.put(ExcludeFilter.ExcludeType.RUNNABLE, excludedClass);\n+    excludedTypes.put(ExcludeFilter.ExcludeType.FORK_JOIN_TASK, excludedClass);\n+    return excludedTypes;\n+  }\n+\n+  public static final class SuppressMailboxRunAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope enter() {\n+      // Create our own noopSpan to make sure that we close all scopes up until this\n+      // position after exit\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      return activateSpan(span, false);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(@Advice.Enter final AgentScope scope) {\n+      // Clean up any leaking scopes from akka-streams/akka-http et.c.\n+      TraceScope activeScope = activeScope();\n+      while (activeScope != null && activeScope != scope) {\n+        activeScope.close();\n+        activeScope = activeScope();\n+      }\n+      while (activeScope == scope) {\n+        scope.close();\n+        activeScope = activeScope();\n+      }\n+    }", "originalCommit": "fe143a7916cfe72851921b105dbdfa41db303cfd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f18e63868a377500da2bf6f1a42c72a5860793c4", "chunk": "diff --git a/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaMailboxInstrumentation.java b/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaMailboxInstrumentation.java\nindex 88466fc36e..bbb582c3dc 100644\n--- a/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaMailboxInstrumentation.java\n+++ b/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaMailboxInstrumentation.java\n\n@@ -53,6 +53,17 @@ public class AkkaMailboxInstrumentation extends Instrumenter.Default\n     return excludedTypes;\n   }\n \n+  /**\n+   * This instrumentation is defensive and closes all scopes on the scope stack that were not there\n+   * when we started processing this actor mailbox. The reason for that is twofold.\n+   *\n+   * <p>1) An actor is self contained, and driven by a thread that could serve many other purposes,\n+   * and a scope should not leak out after a mailbox has been processed.\n+   *\n+   * <p>2) We rely on this cleanup mechanism to be able to intentionally leak the scope in the\n+   * {@code AkkaHttpServerInstrumentation} so that it propagates to the user provided request\n+   * handling code that will execute on the same thread in the same actor.\n+   */\n   public static final class SuppressMailboxRunAdvice {\n     @Advice.OnMethodEnter(suppress = Throwable.class)\n     public static AgentScope enter() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzExMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520833112", "bodyText": "This seems rather odd.", "author": "tylerbenson", "createdAt": "2020-11-10T19:50:17Z", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();", "originalCommit": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI4NzEwMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521287101", "bodyText": "Yes, maybe I should start a blank span and scope instead, in the code below.", "author": "bantonsson", "createdAt": "2020-11-11T11:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzExMg=="}], "type": "inlineReview", "revised_code": {"commit": "eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "chunk": "diff --git a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\nindex 35db1d75e5..fe9fa451ac 100644\n--- a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n+++ b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n\n@@ -115,177 +125,79 @@ public final class AkkaHttpServerInstrumentation extends Instrumenter.Default {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        scope.setAsyncPropagation(false);\n+      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogServerRequestResponseFlowWrapper\n-      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n-    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n-    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n-    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n-    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n-    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n-        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n+  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n+    private final Function1<HttpRequest, HttpResponse> userHandler;\n \n-    private final int pipeliningLimit;\n-    private final AgentScope DUMMY_SCOPE;\n-\n-    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n-      this.pipeliningLimit = settings.getPipeliningLimit();\n-      AgentSpan span = new AgentTracer.NoopAgentSpan();\n-      // Create a dummy scope that we can store in the queue if we can't create a scope\n-      DUMMY_SCOPE = activateSpan(span, false);\n-      DUMMY_SCOPE.close();\n+    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n+      this.userHandler = userHandler;\n     }\n \n     @Override\n-    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n-      return shape;\n+    public HttpResponse apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      try {\n+        final HttpResponse response = userHandler.apply(request);\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), response);\n+        return response;\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n     }\n+  }\n \n-    @Override\n-    public Attributes initialAttributes() {\n-      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n+  public static class DatadogAsyncWrapper\n+      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n+    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n+    private final ExecutionContext executionContext;\n+\n+    public DatadogAsyncWrapper(\n+        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n+        final ExecutionContext executionContext) {\n+      this.userHandler = userHandler;\n+      this.executionContext = executionContext;\n     }\n \n     @Override\n-    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n-      return new GraphStageLogic(shape) {\n-        {\n-          // The request/response is guaranteed to be in order according to the docs at\n-          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n-          // and there can never be more outstanding requests than the pipeliningLimit\n-          // that this connection was created with. This means that we can safely\n-          // close the span at the front of the queue when we receive the response\n-          // from the user code, since it will match up to the request for that span.\n-          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n-\n-          // This is where the request comes in from the server and TCP layer\n-          setHandler(\n-              requestInlet,\n-              new AbstractInHandler() {\n+    public Future<HttpResponse> apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      Future<HttpResponse> futureResponse = null;\n+      try {\n+        futureResponse = userHandler.apply(request);\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n+      final Future<HttpResponse> wrapped =\n+          futureResponse.transform(\n+              new AbstractFunction1<HttpResponse, HttpResponse>() {\n                 @Override\n-                public void onPush() throws Exception {\n-                  final HttpRequest request = grab(requestInlet);\n-                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-                  if (scope != null) {\n-                    scopes.add(scope);\n-                  } else {\n-                    scopes.add(DUMMY_SCOPE);\n-                  }\n-                  push(requestOutlet, request);\n-                  // Since we haven't instrumented the akka stream state machine, we can't rely\n-                  // on spans and scopes being propagated during the push and pull of the\n-                  // element. Instead we let the scope leak intentionally here and clean it\n-                  // up when the user response comes back, or in the actor message processing\n-                  // instrumentation that drives this state machine.\n+                public HttpResponse apply(final HttpResponse response) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                  return response;\n                 }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  complete(requestOutlet);\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  fail(requestOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the requests goes out to the user code\n-          setHandler(\n-              requestOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(requestInlet);\n-                }\n-\n-                @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more requests to the user code so stop receiving them\n-                  cancel(requestInlet);\n-                }\n-              });\n-\n-          // This is where the response comes back from the user code\n-          setHandler(\n-              responseInlet,\n-              new AbstractInHandler() {\n-                @Override\n-                public void onPush() throws Exception {\n-                  final HttpResponse response = grab(responseInlet);\n-                  final AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                    // Check if the active scope is still the scope from when the request came in,\n-                    // and close it. If it's not, then it will be cleaned up actor message\n-                    // processing instrumentation that drives this state machine\n-                    TraceScope activeScope = activeScope();\n-                    if (activeScope == scope) {\n-                      scope.close();\n-                    }\n-                  }\n-                  push(responseOutlet, response);\n-                }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  AgentScope scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  completeStage();\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception {\n-                  AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    // Mark the span as failed\n-                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n-                  }\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  fail(responseOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the response goes back to the server and TCP layer\n-          setHandler(\n-              responseOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(responseInlet);\n-                }\n-\n+              },\n+              new AbstractFunction1<Throwable, Throwable>() {\n                 @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more responses to the server and TCP layer so stop\n-                  // receiving them\n-                  cancel(responseInlet);\n+                public Throwable apply(final Throwable t) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), t);\n+                  return t;\n                 }\n-              });\n-        }\n-      };\n+              },\n+              executionContext);\n+      scope.close();\n+      return wrapped;\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzYxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520833612", "bodyText": "use noopSpan() instead.", "author": "tylerbenson", "createdAt": "2020-11-10T19:51:10Z", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "originalCommit": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzc1Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520837757", "bodyText": "Or maybe even AgentTracer.NoopAgentScope.INSTANCE instead.", "author": "tylerbenson", "createdAt": "2020-11-10T19:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI4OTI4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521289285", "bodyText": "Yes, I could definitely reuse the AgentTracer.NoopAgentScope.INSTANCE", "author": "bantonsson", "createdAt": "2020-11-11T11:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzYxMg=="}], "type": "inlineReview", "revised_code": {"commit": "eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "chunk": "diff --git a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\nindex 35db1d75e5..fe9fa451ac 100644\n--- a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n+++ b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n\n@@ -115,177 +125,79 @@ public final class AkkaHttpServerInstrumentation extends Instrumenter.Default {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        scope.setAsyncPropagation(false);\n+      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogServerRequestResponseFlowWrapper\n-      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n-    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n-    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n-    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n-    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n-    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n-        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n+  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n+    private final Function1<HttpRequest, HttpResponse> userHandler;\n \n-    private final int pipeliningLimit;\n-    private final AgentScope DUMMY_SCOPE;\n-\n-    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n-      this.pipeliningLimit = settings.getPipeliningLimit();\n-      AgentSpan span = new AgentTracer.NoopAgentSpan();\n-      // Create a dummy scope that we can store in the queue if we can't create a scope\n-      DUMMY_SCOPE = activateSpan(span, false);\n-      DUMMY_SCOPE.close();\n+    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n+      this.userHandler = userHandler;\n     }\n \n     @Override\n-    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n-      return shape;\n+    public HttpResponse apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      try {\n+        final HttpResponse response = userHandler.apply(request);\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), response);\n+        return response;\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n     }\n+  }\n \n-    @Override\n-    public Attributes initialAttributes() {\n-      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n+  public static class DatadogAsyncWrapper\n+      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n+    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n+    private final ExecutionContext executionContext;\n+\n+    public DatadogAsyncWrapper(\n+        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n+        final ExecutionContext executionContext) {\n+      this.userHandler = userHandler;\n+      this.executionContext = executionContext;\n     }\n \n     @Override\n-    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n-      return new GraphStageLogic(shape) {\n-        {\n-          // The request/response is guaranteed to be in order according to the docs at\n-          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n-          // and there can never be more outstanding requests than the pipeliningLimit\n-          // that this connection was created with. This means that we can safely\n-          // close the span at the front of the queue when we receive the response\n-          // from the user code, since it will match up to the request for that span.\n-          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n-\n-          // This is where the request comes in from the server and TCP layer\n-          setHandler(\n-              requestInlet,\n-              new AbstractInHandler() {\n+    public Future<HttpResponse> apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      Future<HttpResponse> futureResponse = null;\n+      try {\n+        futureResponse = userHandler.apply(request);\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n+      final Future<HttpResponse> wrapped =\n+          futureResponse.transform(\n+              new AbstractFunction1<HttpResponse, HttpResponse>() {\n                 @Override\n-                public void onPush() throws Exception {\n-                  final HttpRequest request = grab(requestInlet);\n-                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-                  if (scope != null) {\n-                    scopes.add(scope);\n-                  } else {\n-                    scopes.add(DUMMY_SCOPE);\n-                  }\n-                  push(requestOutlet, request);\n-                  // Since we haven't instrumented the akka stream state machine, we can't rely\n-                  // on spans and scopes being propagated during the push and pull of the\n-                  // element. Instead we let the scope leak intentionally here and clean it\n-                  // up when the user response comes back, or in the actor message processing\n-                  // instrumentation that drives this state machine.\n+                public HttpResponse apply(final HttpResponse response) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                  return response;\n                 }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  complete(requestOutlet);\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  fail(requestOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the requests goes out to the user code\n-          setHandler(\n-              requestOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(requestInlet);\n-                }\n-\n-                @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more requests to the user code so stop receiving them\n-                  cancel(requestInlet);\n-                }\n-              });\n-\n-          // This is where the response comes back from the user code\n-          setHandler(\n-              responseInlet,\n-              new AbstractInHandler() {\n-                @Override\n-                public void onPush() throws Exception {\n-                  final HttpResponse response = grab(responseInlet);\n-                  final AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                    // Check if the active scope is still the scope from when the request came in,\n-                    // and close it. If it's not, then it will be cleaned up actor message\n-                    // processing instrumentation that drives this state machine\n-                    TraceScope activeScope = activeScope();\n-                    if (activeScope == scope) {\n-                      scope.close();\n-                    }\n-                  }\n-                  push(responseOutlet, response);\n-                }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  AgentScope scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  completeStage();\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception {\n-                  AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    // Mark the span as failed\n-                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n-                  }\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  fail(responseOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the response goes back to the server and TCP layer\n-          setHandler(\n-              responseOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(responseInlet);\n-                }\n-\n+              },\n+              new AbstractFunction1<Throwable, Throwable>() {\n                 @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more responses to the server and TCP layer so stop\n-                  // receiving them\n-                  cancel(responseInlet);\n+                public Throwable apply(final Throwable t) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), t);\n+                  return t;\n                 }\n-              });\n-        }\n-      };\n+              },\n+              executionContext);\n+      scope.close();\n+      return wrapped;\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520839251", "bodyText": "This seems to be needed because the request handler which creates the span is separate from the response handler that finishes the span, so this queue is used to correlate the scopes?", "author": "tylerbenson", "createdAt": "2020-11-10T20:01:08Z", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);", "originalCommit": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI4NTgxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521285819", "bodyText": "Yes, the queue is used to correlate the scopes. Its use ties in to the comment below about the state machine.", "author": "bantonsson", "createdAt": "2020-11-11T11:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNDQyNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521534424", "bodyText": "it seems very surprising to me that the calls are guaranteed to be in the same order.  Maybe I don't have the right mental model, but assume that you have a request come in that takes a long time, followed by a bunch of fast requests.  How does that actually keep the right order?", "author": "tylerbenson", "createdAt": "2020-11-11T17:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwNTQ3Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521605472", "bodyText": "In reference to the order, what I gathered from observing the behavior is that a new instance of the graph stage logic is created for each connection", "author": "devinsba", "createdAt": "2020-11-11T20:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2NDA3MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521864071", "bodyText": "Yes, exactly. There is a separate instance of the logic for each connection, and the in connection request order is guaranteed by the server flow machinery. I'll add this to the comments.", "author": "bantonsson", "createdAt": "2020-11-12T06:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "chunk": "diff --git a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\nindex 35db1d75e5..fe9fa451ac 100644\n--- a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n+++ b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n\n@@ -115,177 +125,79 @@ public final class AkkaHttpServerInstrumentation extends Instrumenter.Default {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        scope.setAsyncPropagation(false);\n+      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogServerRequestResponseFlowWrapper\n-      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n-    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n-    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n-    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n-    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n-    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n-        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n+  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n+    private final Function1<HttpRequest, HttpResponse> userHandler;\n \n-    private final int pipeliningLimit;\n-    private final AgentScope DUMMY_SCOPE;\n-\n-    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n-      this.pipeliningLimit = settings.getPipeliningLimit();\n-      AgentSpan span = new AgentTracer.NoopAgentSpan();\n-      // Create a dummy scope that we can store in the queue if we can't create a scope\n-      DUMMY_SCOPE = activateSpan(span, false);\n-      DUMMY_SCOPE.close();\n+    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n+      this.userHandler = userHandler;\n     }\n \n     @Override\n-    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n-      return shape;\n+    public HttpResponse apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      try {\n+        final HttpResponse response = userHandler.apply(request);\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), response);\n+        return response;\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n     }\n+  }\n \n-    @Override\n-    public Attributes initialAttributes() {\n-      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n+  public static class DatadogAsyncWrapper\n+      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n+    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n+    private final ExecutionContext executionContext;\n+\n+    public DatadogAsyncWrapper(\n+        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n+        final ExecutionContext executionContext) {\n+      this.userHandler = userHandler;\n+      this.executionContext = executionContext;\n     }\n \n     @Override\n-    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n-      return new GraphStageLogic(shape) {\n-        {\n-          // The request/response is guaranteed to be in order according to the docs at\n-          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n-          // and there can never be more outstanding requests than the pipeliningLimit\n-          // that this connection was created with. This means that we can safely\n-          // close the span at the front of the queue when we receive the response\n-          // from the user code, since it will match up to the request for that span.\n-          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n-\n-          // This is where the request comes in from the server and TCP layer\n-          setHandler(\n-              requestInlet,\n-              new AbstractInHandler() {\n+    public Future<HttpResponse> apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      Future<HttpResponse> futureResponse = null;\n+      try {\n+        futureResponse = userHandler.apply(request);\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n+      final Future<HttpResponse> wrapped =\n+          futureResponse.transform(\n+              new AbstractFunction1<HttpResponse, HttpResponse>() {\n                 @Override\n-                public void onPush() throws Exception {\n-                  final HttpRequest request = grab(requestInlet);\n-                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-                  if (scope != null) {\n-                    scopes.add(scope);\n-                  } else {\n-                    scopes.add(DUMMY_SCOPE);\n-                  }\n-                  push(requestOutlet, request);\n-                  // Since we haven't instrumented the akka stream state machine, we can't rely\n-                  // on spans and scopes being propagated during the push and pull of the\n-                  // element. Instead we let the scope leak intentionally here and clean it\n-                  // up when the user response comes back, or in the actor message processing\n-                  // instrumentation that drives this state machine.\n+                public HttpResponse apply(final HttpResponse response) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                  return response;\n                 }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  complete(requestOutlet);\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  fail(requestOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the requests goes out to the user code\n-          setHandler(\n-              requestOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(requestInlet);\n-                }\n-\n-                @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more requests to the user code so stop receiving them\n-                  cancel(requestInlet);\n-                }\n-              });\n-\n-          // This is where the response comes back from the user code\n-          setHandler(\n-              responseInlet,\n-              new AbstractInHandler() {\n-                @Override\n-                public void onPush() throws Exception {\n-                  final HttpResponse response = grab(responseInlet);\n-                  final AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                    // Check if the active scope is still the scope from when the request came in,\n-                    // and close it. If it's not, then it will be cleaned up actor message\n-                    // processing instrumentation that drives this state machine\n-                    TraceScope activeScope = activeScope();\n-                    if (activeScope == scope) {\n-                      scope.close();\n-                    }\n-                  }\n-                  push(responseOutlet, response);\n-                }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  AgentScope scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  completeStage();\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception {\n-                  AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    // Mark the span as failed\n-                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n-                  }\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  fail(responseOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the response goes back to the server and TCP layer\n-          setHandler(\n-              responseOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(responseInlet);\n-                }\n-\n+              },\n+              new AbstractFunction1<Throwable, Throwable>() {\n                 @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more responses to the server and TCP layer so stop\n-                  // receiving them\n-                  cancel(responseInlet);\n+                public Throwable apply(final Throwable t) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), t);\n+                  return t;\n                 }\n-              });\n-        }\n-      };\n+              },\n+              executionContext);\n+      scope.close();\n+      return wrapped;\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MDkxOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520840918", "bodyText": "This is interesting.  I guess this is the reason you need that logic to clear the scope stack.  I don't think I understand though why the scope can't be closed after the push.", "author": "tylerbenson", "createdAt": "2020-11-10T20:04:11Z", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.", "originalCommit": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MTM2MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521271360", "bodyText": "So akka streams are run by a state machine, and the only thing you know after the push is that this specific element has been put in the slot representing the requestOutlet. Nothing more has happened, and no request handling code has run yet. If we close the scope at that point, there will be nothing in the scope. Since the whole stream machinery has been fused we can be certain that this element will be picked up by the same thread that is running this onPush method, and then the request handling code will be run. If the request handling code completes synchronously, then the handler for the responseInlet will close the scope directly in that onPush method. Otherwise the scope will be closed by the actor messaging instrumentation cleaning the scope stack.\nI'll add a more detailed comment about how things work.\nI'll write a", "author": "bantonsson", "createdAt": "2020-11-11T10:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MDkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "chunk": "diff --git a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\nindex 35db1d75e5..fe9fa451ac 100644\n--- a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n+++ b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n\n@@ -115,177 +125,79 @@ public final class AkkaHttpServerInstrumentation extends Instrumenter.Default {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        scope.setAsyncPropagation(false);\n+      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogServerRequestResponseFlowWrapper\n-      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n-    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n-    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n-    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n-    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n-    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n-        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n+  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n+    private final Function1<HttpRequest, HttpResponse> userHandler;\n \n-    private final int pipeliningLimit;\n-    private final AgentScope DUMMY_SCOPE;\n-\n-    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n-      this.pipeliningLimit = settings.getPipeliningLimit();\n-      AgentSpan span = new AgentTracer.NoopAgentSpan();\n-      // Create a dummy scope that we can store in the queue if we can't create a scope\n-      DUMMY_SCOPE = activateSpan(span, false);\n-      DUMMY_SCOPE.close();\n+    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n+      this.userHandler = userHandler;\n     }\n \n     @Override\n-    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n-      return shape;\n+    public HttpResponse apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      try {\n+        final HttpResponse response = userHandler.apply(request);\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), response);\n+        return response;\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n     }\n+  }\n \n-    @Override\n-    public Attributes initialAttributes() {\n-      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n+  public static class DatadogAsyncWrapper\n+      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n+    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n+    private final ExecutionContext executionContext;\n+\n+    public DatadogAsyncWrapper(\n+        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n+        final ExecutionContext executionContext) {\n+      this.userHandler = userHandler;\n+      this.executionContext = executionContext;\n     }\n \n     @Override\n-    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n-      return new GraphStageLogic(shape) {\n-        {\n-          // The request/response is guaranteed to be in order according to the docs at\n-          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n-          // and there can never be more outstanding requests than the pipeliningLimit\n-          // that this connection was created with. This means that we can safely\n-          // close the span at the front of the queue when we receive the response\n-          // from the user code, since it will match up to the request for that span.\n-          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n-\n-          // This is where the request comes in from the server and TCP layer\n-          setHandler(\n-              requestInlet,\n-              new AbstractInHandler() {\n+    public Future<HttpResponse> apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      Future<HttpResponse> futureResponse = null;\n+      try {\n+        futureResponse = userHandler.apply(request);\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n+      final Future<HttpResponse> wrapped =\n+          futureResponse.transform(\n+              new AbstractFunction1<HttpResponse, HttpResponse>() {\n                 @Override\n-                public void onPush() throws Exception {\n-                  final HttpRequest request = grab(requestInlet);\n-                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-                  if (scope != null) {\n-                    scopes.add(scope);\n-                  } else {\n-                    scopes.add(DUMMY_SCOPE);\n-                  }\n-                  push(requestOutlet, request);\n-                  // Since we haven't instrumented the akka stream state machine, we can't rely\n-                  // on spans and scopes being propagated during the push and pull of the\n-                  // element. Instead we let the scope leak intentionally here and clean it\n-                  // up when the user response comes back, or in the actor message processing\n-                  // instrumentation that drives this state machine.\n+                public HttpResponse apply(final HttpResponse response) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                  return response;\n                 }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  complete(requestOutlet);\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  fail(requestOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the requests goes out to the user code\n-          setHandler(\n-              requestOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(requestInlet);\n-                }\n-\n-                @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more requests to the user code so stop receiving them\n-                  cancel(requestInlet);\n-                }\n-              });\n-\n-          // This is where the response comes back from the user code\n-          setHandler(\n-              responseInlet,\n-              new AbstractInHandler() {\n-                @Override\n-                public void onPush() throws Exception {\n-                  final HttpResponse response = grab(responseInlet);\n-                  final AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                    // Check if the active scope is still the scope from when the request came in,\n-                    // and close it. If it's not, then it will be cleaned up actor message\n-                    // processing instrumentation that drives this state machine\n-                    TraceScope activeScope = activeScope();\n-                    if (activeScope == scope) {\n-                      scope.close();\n-                    }\n-                  }\n-                  push(responseOutlet, response);\n-                }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  AgentScope scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  completeStage();\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception {\n-                  AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    // Mark the span as failed\n-                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n-                  }\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  fail(responseOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the response goes back to the server and TCP layer\n-          setHandler(\n-              responseOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(responseInlet);\n-                }\n-\n+              },\n+              new AbstractFunction1<Throwable, Throwable>() {\n                 @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more responses to the server and TCP layer so stop\n-                  // receiving them\n-                  cancel(responseInlet);\n+                public Throwable apply(final Throwable t) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), t);\n+                  return t;\n                 }\n-              });\n-        }\n-      };\n+              },\n+              executionContext);\n+      scope.close();\n+      return wrapped;\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDU1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520914553", "bodyText": "Since the span is started when the request comes into the server, it would seem more logical to me to have it finish when it is returning the response to the server.  In practice I don't think there will be much difference though... just an incongruity.", "author": "tylerbenson", "createdAt": "2020-11-10T22:28:11Z", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.\n                 }\n-              },\n-              new AbstractFunction1<Throwable, Throwable>() {\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  complete(requestOutlet);\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  fail(requestOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the requests goes out to the user code\n+          setHandler(\n+              requestOutlet,\n+              new AbstractOutHandler() {\n+                @Override\n+                public void onPull() throws Exception {\n+                  pull(requestInlet);\n+                }\n+\n+                @Override\n+                public void onDownstreamFinish() throws Exception {\n+                  // We can not send out any more requests to the user code so stop receiving them\n+                  cancel(requestInlet);\n+                }\n+              });\n+\n+          // This is where the response comes back from the user code\n+          setHandler(\n+              responseInlet,\n+              new AbstractInHandler() {\n+                @Override\n+                public void onPush() throws Exception {\n+                  final HttpResponse response = grab(responseInlet);\n+                  final AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                    // Check if the active scope is still the scope from when the request came in,\n+                    // and close it. If it's not, then it will be cleaned up actor message\n+                    // processing instrumentation that drives this state machine\n+                    TraceScope activeScope = activeScope();\n+                    if (activeScope == scope) {\n+                      scope.close();\n+                    }\n+                  }\n+                  push(responseOutlet, response);\n+                }\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  AgentScope scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  completeStage();\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception {\n+                  AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    // Mark the span as failed\n+                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n+                  }\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  fail(responseOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the response goes back to the server and TCP layer", "originalCommit": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5MjI5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521292296", "bodyText": "Yeah, it might better reflect the timing if the server is under load, or is saturating its bandwidth.", "author": "bantonsson", "createdAt": "2020-11-11T11:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0NzAwNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r522247004", "bodyText": "So putting my thinking cap back on I realized that this is not  where the response goes back, but rather where the server machinery says that it can receive another response and the actual moving of the response from the user supplied code to the server code happens where it is right now. I'll update the comment.", "author": "bantonsson", "createdAt": "2020-11-12T16:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDU1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "chunk": "diff --git a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\nindex 35db1d75e5..fe9fa451ac 100644\n--- a/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n+++ b/dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java\n\n@@ -115,177 +125,79 @@ public final class AkkaHttpServerInstrumentation extends Instrumenter.Default {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        scope.setAsyncPropagation(false);\n+      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogServerRequestResponseFlowWrapper\n-      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n-    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n-    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n-    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n-    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n-    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n-        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n+  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n+    private final Function1<HttpRequest, HttpResponse> userHandler;\n \n-    private final int pipeliningLimit;\n-    private final AgentScope DUMMY_SCOPE;\n-\n-    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n-      this.pipeliningLimit = settings.getPipeliningLimit();\n-      AgentSpan span = new AgentTracer.NoopAgentSpan();\n-      // Create a dummy scope that we can store in the queue if we can't create a scope\n-      DUMMY_SCOPE = activateSpan(span, false);\n-      DUMMY_SCOPE.close();\n+    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n+      this.userHandler = userHandler;\n     }\n \n     @Override\n-    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n-      return shape;\n+    public HttpResponse apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      try {\n+        final HttpResponse response = userHandler.apply(request);\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), response);\n+        return response;\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n     }\n+  }\n \n-    @Override\n-    public Attributes initialAttributes() {\n-      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n+  public static class DatadogAsyncWrapper\n+      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n+    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n+    private final ExecutionContext executionContext;\n+\n+    public DatadogAsyncWrapper(\n+        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n+        final ExecutionContext executionContext) {\n+      this.userHandler = userHandler;\n+      this.executionContext = executionContext;\n     }\n \n     @Override\n-    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n-      return new GraphStageLogic(shape) {\n-        {\n-          // The request/response is guaranteed to be in order according to the docs at\n-          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n-          // and there can never be more outstanding requests than the pipeliningLimit\n-          // that this connection was created with. This means that we can safely\n-          // close the span at the front of the queue when we receive the response\n-          // from the user code, since it will match up to the request for that span.\n-          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n-\n-          // This is where the request comes in from the server and TCP layer\n-          setHandler(\n-              requestInlet,\n-              new AbstractInHandler() {\n+    public Future<HttpResponse> apply(final HttpRequest request) {\n+      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+      Future<HttpResponse> futureResponse = null;\n+      try {\n+        futureResponse = userHandler.apply(request);\n+      } catch (final Throwable t) {\n+        scope.close();\n+        DatadogWrapperHelper.finishSpan(scope.span(), t);\n+        throw t;\n+      }\n+      final Future<HttpResponse> wrapped =\n+          futureResponse.transform(\n+              new AbstractFunction1<HttpResponse, HttpResponse>() {\n                 @Override\n-                public void onPush() throws Exception {\n-                  final HttpRequest request = grab(requestInlet);\n-                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-                  if (scope != null) {\n-                    scopes.add(scope);\n-                  } else {\n-                    scopes.add(DUMMY_SCOPE);\n-                  }\n-                  push(requestOutlet, request);\n-                  // Since we haven't instrumented the akka stream state machine, we can't rely\n-                  // on spans and scopes being propagated during the push and pull of the\n-                  // element. Instead we let the scope leak intentionally here and clean it\n-                  // up when the user response comes back, or in the actor message processing\n-                  // instrumentation that drives this state machine.\n+                public HttpResponse apply(final HttpResponse response) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                  return response;\n                 }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  complete(requestOutlet);\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n-                  // We will not receive any more requests from the server and TCP layer so stop\n-                  // sending them\n-                  fail(requestOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the requests goes out to the user code\n-          setHandler(\n-              requestOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(requestInlet);\n-                }\n-\n-                @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more requests to the user code so stop receiving them\n-                  cancel(requestInlet);\n-                }\n-              });\n-\n-          // This is where the response comes back from the user code\n-          setHandler(\n-              responseInlet,\n-              new AbstractInHandler() {\n-                @Override\n-                public void onPush() throws Exception {\n-                  final HttpResponse response = grab(responseInlet);\n-                  final AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                    // Check if the active scope is still the scope from when the request came in,\n-                    // and close it. If it's not, then it will be cleaned up actor message\n-                    // processing instrumentation that drives this state machine\n-                    TraceScope activeScope = activeScope();\n-                    if (activeScope == scope) {\n-                      scope.close();\n-                    }\n-                  }\n-                  push(responseOutlet, response);\n-                }\n-\n-                @Override\n-                public void onUpstreamFinish() throws Exception {\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  AgentScope scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  completeStage();\n-                }\n-\n-                @Override\n-                public void onUpstreamFailure(final Throwable ex) throws Exception {\n-                  AgentScope scope = scopes.poll();\n-                  if (scope != null && scope != DUMMY_SCOPE) {\n-                    // Mark the span as failed\n-                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n-                  }\n-                  // We will not receive any more responses from the user code, so clean up any\n-                  // remaining spans\n-                  scope = scopes.poll();\n-                  while (scope != null) {\n-                    if (scope != DUMMY_SCOPE) {\n-                      scope.span().finish();\n-                    }\n-                    scope = scopes.poll();\n-                  }\n-                  fail(responseOutlet, ex);\n-                }\n-              });\n-\n-          // This is where the response goes back to the server and TCP layer\n-          setHandler(\n-              responseOutlet,\n-              new AbstractOutHandler() {\n-                @Override\n-                public void onPull() throws Exception {\n-                  pull(responseInlet);\n-                }\n-\n+              },\n+              new AbstractFunction1<Throwable, Throwable>() {\n                 @Override\n-                public void onDownstreamFinish() throws Exception {\n-                  // We can not send out any more responses to the server and TCP layer so stop\n-                  // receiving them\n-                  cancel(responseInlet);\n+                public Throwable apply(final Throwable t) {\n+                  DatadogWrapperHelper.finishSpan(scope.span(), t);\n+                  return t;\n                 }\n-              });\n-        }\n-      };\n+              },\n+              executionContext);\n+      scope.close();\n+      return wrapped;\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwMjcwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521602708", "bodyText": "AgentTracer.noopSpan() would be better here", "author": "devinsba", "createdAt": "2020-11-11T19:55:33Z", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaActorCellInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.actor.ActorCell\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n+  }\n+\n+  public static class InvokeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n+      TraceScope scope =\n+          AdviceUtils.startTaskScope(\n+              InstrumentationContext.get(Envelope.class, State.class), envelope);\n+      if (scope != null) {\n+        return scope;\n+      }\n+      // If there is no scope created from the envelope, we create our own noopSpan to make sure\n+      // that we can close all scopes up until this position after exit.\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "originalCommit": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2MzU4Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521863587", "bodyText": "The reason that I construct a new span instance is that I want to minimize the chance that the cleaning code messes up the scope stack reference count for any scope that is active when we come in to this code, and using the AgentTracer.noopSpan() could easily do that since I can't distinguish between this span/scope and any that was active when calling this method.", "author": "bantonsson", "createdAt": "2020-11-12T06:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwMjcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "f18e63868a377500da2bf6f1a42c72a5860793c4", "chunk": "diff --git a/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java b/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java\nindex 667c37776f..d9322ace89 100644\n--- a/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java\n+++ b/dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java\n\n@@ -43,6 +43,17 @@ public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n     return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n   }\n \n+  /**\n+   * This instrumentation is defensive and closes all scopes on the scope stack that were not there\n+   * when we started processing this actor message. The reason for that is twofold.\n+   *\n+   * <p>1) An actor is self contained, and driven by a thread that could serve many other purposes,\n+   * and a scope should not leak out after a message has been processed.\n+   *\n+   * <p>2) We rely on this cleanup mechanism to be able to intentionally leak the scope in the\n+   * {@code AkkaHttpServerInstrumentation} so that it propagates to the user provided request\n+   * handling code that will execute on the same thread in the same actor.\n+   */\n   public static class InvokeAdvice {\n     @Advice.OnMethodEnter(suppress = Throwable.class)\n     public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n"}}, {"oid": "eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "url": "https://github.com/DataDog/dd-trace-java/commit/eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "message": "Instrument akka-actor messaging", "committedDate": "2020-11-12T16:51:23Z", "type": "commit"}, {"oid": "d77faecbf07767c204b5906abef03f8628881fdd", "url": "https://github.com/DataDog/dd-trace-java/commit/d77faecbf07767c204b5906abef03f8628881fdd", "message": "Instrument akka-http bindAndHandle", "committedDate": "2020-11-12T16:51:23Z", "type": "commit"}, {"oid": "b2db316dd5362aead035dddb9de63ea5fbdc99fc", "url": "https://github.com/DataDog/dd-trace-java/commit/b2db316dd5362aead035dddb9de63ea5fbdc99fc", "message": "Clean up and expand akka-http server tests", "committedDate": "2020-11-12T16:51:24Z", "type": "commit"}, {"oid": "1a7522a031c4f5a6057ad3458ac10b75a13bc099", "url": "https://github.com/DataDog/dd-trace-java/commit/1a7522a031c4f5a6057ad3458ac10b75a13bc099", "message": "Clean up and expand akka-http client instrumentation and tests", "committedDate": "2020-11-12T16:51:24Z", "type": "commit"}, {"oid": "ba0b58a290d9cac6586637d0380e1e842e110b6f", "url": "https://github.com/DataDog/dd-trace-java/commit/ba0b58a290d9cac6586637d0380e1e842e110b6f", "message": "Add debug logging to TraceStructureWriter", "committedDate": "2020-11-12T16:51:24Z", "type": "commit"}, {"oid": "f18e63868a377500da2bf6f1a42c72a5860793c4", "url": "https://github.com/DataDog/dd-trace-java/commit/f18e63868a377500da2bf6f1a42c72a5860793c4", "message": "Remove unnecessary code and add comments to instrumentations", "committedDate": "2020-11-12T16:51:24Z", "type": "commit"}, {"oid": "f18e63868a377500da2bf6f1a42c72a5860793c4", "url": "https://github.com/DataDog/dd-trace-java/commit/f18e63868a377500da2bf6f1a42c72a5860793c4", "message": "Remove unnecessary code and add comments to instrumentations", "committedDate": "2020-11-12T16:51:24Z", "type": "forcePushed"}]}