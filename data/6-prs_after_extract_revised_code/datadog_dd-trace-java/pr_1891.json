{"pr_number": 1891, "pr_title": "Make it possible to switch log level during runtime", "pr_createdAt": "2020-09-21T13:10:31Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1891", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MjU4MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1891#discussion_r492052581", "bodyText": "I'm not sure if this will justify its complexity. Firstly, setting the log level is going to be very rare, certainly rare enough for a volatile write. Secondly, I'd wager a bet that over 99% of users run on x86, where I don't think there's any benefit of getOpaque over get", "author": "richardstartin", "createdAt": "2020-09-21T13:39:59Z", "path": "dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package datadog.trace.logging.ddlogger;\n+\n+import datadog.trace.logging.LogLevel;\n+import datadog.trace.logging.LogLevelSwitcher;\n+import datadog.trace.logging.LoggerHelper;\n+import datadog.trace.logging.LoggerHelperFactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Marker;\n+\n+public final class SwitchableLogLevelFactory extends LoggerHelperFactory\n+    implements LogLevelSwitcher {\n+  private final LoggerHelperFactory delegate;\n+  private final AtomicReference<LogLevel> override;\n+\n+  public SwitchableLogLevelFactory(LoggerHelperFactory delegate) {\n+    this(new AtomicReference<LogLevel>(), delegate);\n+  }\n+\n+  public SwitchableLogLevelFactory(\n+      AtomicReference<LogLevel> override, LoggerHelperFactory delegate) {\n+    this.delegate = delegate;\n+    this.override = override;\n+  }\n+\n+  @Override\n+  public void switchLevel(LogLevel level) {\n+    Opaque.setLevel(override, level);\n+  }\n+\n+  @Override\n+  public void restore() {\n+    Opaque.setLevel(override, null);\n+  }\n+\n+  private static final class Opaque {", "originalCommit": "5518a4e077372468432ad4815ce349d7a5ff151b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA3MDg3Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1891#discussion_r492070877", "bodyText": "Ok, fine. That was probably a bit premature. I'll remove it.\nIt was mostly the read I was concerned about, and I'm likely colored by rust on ARM, where it would make a difference.", "author": "bantonsson", "createdAt": "2020-09-21T14:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MjU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEwOTY1OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1891#discussion_r492109659", "bodyText": "On ARM it would definitely be worthwhile, along with applying the same treatment to all other qualifying volatile reads in the code base.", "author": "richardstartin", "createdAt": "2020-09-21T14:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MjU4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "8cfe4fe3ee824e7f658d3492a5043674464d8926", "chunk": "diff --git a/dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java b/dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java\nindex 25ef459071..f9817566f7 100644\n--- a/dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java\n+++ b/dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java\n\n@@ -4,93 +4,36 @@ import datadog.trace.logging.LogLevel;\n import datadog.trace.logging.LogLevelSwitcher;\n import datadog.trace.logging.LoggerHelper;\n import datadog.trace.logging.LoggerHelperFactory;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.atomic.AtomicReference;\n import org.slf4j.Marker;\n \n public final class SwitchableLogLevelFactory extends LoggerHelperFactory\n     implements LogLevelSwitcher {\n   private final LoggerHelperFactory delegate;\n-  private final AtomicReference<LogLevel> override;\n+  private volatile LogLevel override = null;\n \n   public SwitchableLogLevelFactory(LoggerHelperFactory delegate) {\n-    this(new AtomicReference<LogLevel>(), delegate);\n-  }\n-\n-  public SwitchableLogLevelFactory(\n-      AtomicReference<LogLevel> override, LoggerHelperFactory delegate) {\n     this.delegate = delegate;\n-    this.override = override;\n   }\n \n   @Override\n   public void switchLevel(LogLevel level) {\n-    Opaque.setLevel(override, level);\n+    override = level;\n   }\n \n   @Override\n   public void restore() {\n-    Opaque.setLevel(override, null);\n-  }\n-\n-  private static final class Opaque {\n-    // Try to get handles to `getOpaque` and `setOpaque` since the reading and writing\n-    // of the override level does not need any  guarantees of memory ordering between\n-    // threads, and those should be the fastest.\n-    private static final MethodHandle GET;\n-    private static final MethodHandle SET;\n-\n-    static {\n-      MethodHandles.Lookup l = MethodHandles.publicLookup();\n-      Class<?> arClass = AtomicReference.class;\n-      Class<?> oClass = Object.class;\n-      MethodHandle get = null;\n-      MethodHandle set = null;\n-      try {\n-        get = l.findVirtual(arClass, \"getOpaque\", MethodType.methodType(oClass));\n-        set = l.findVirtual(arClass, \"setOpaque\", MethodType.methodType(void.class, oClass));\n-      } catch (Throwable t1) {\n-        try {\n-          get = l.findVirtual(arClass, \"get\", MethodType.methodType(oClass));\n-          set = l.findVirtual(arClass, \"lazySet\", MethodType.methodType(void.class, oClass));\n-        } catch (Throwable t2) {\n-          throw new ExceptionInInitializerError(t2);\n-        }\n-      }\n-      GET = get;\n-      SET = set;\n-    }\n-\n-    private static LogLevel getLevel(AtomicReference<LogLevel> ar) {\n-      try {\n-        return (LogLevel) GET.invoke(ar);\n-      } catch (Throwable t) {\n-        return ar.get();\n-      }\n-    }\n-\n-    private static void setLevel(AtomicReference<LogLevel> ar, LogLevel level) {\n-      try {\n-        SET.invoke(ar, (Object) level);\n-      } catch (Throwable t) {\n-        ar.lazySet(level);\n-      }\n-    }\n+    override = null;\n   }\n \n   @Override\n   public LoggerHelper loggerHelperForName(String name) {\n-    return new Helper(override, delegate.loggerHelperForName(name));\n+    return new Helper(delegate.loggerHelperForName(name));\n   }\n \n-  static final class Helper extends LoggerHelper {\n-    private final AtomicReference<LogLevel> override;\n+  final class Helper extends LoggerHelper {\n     private final LoggerHelper delegate;\n \n-    private Helper(AtomicReference<LogLevel> override, LoggerHelper delegate) {\n-      this.override = override;\n+    private Helper(LoggerHelper delegate) {\n       this.delegate = delegate;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1NDAzNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1891#discussion_r492054036", "bodyText": "I think this could just be volatile LogLevel override without appreciable overhead, in fact it might be a little bit faster in the overwhelmingly common case (reads on x86) by removing indirection.", "author": "richardstartin", "createdAt": "2020-09-21T13:41:53Z", "path": "dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package datadog.trace.logging.ddlogger;\n+\n+import datadog.trace.logging.LogLevel;\n+import datadog.trace.logging.LogLevelSwitcher;\n+import datadog.trace.logging.LoggerHelper;\n+import datadog.trace.logging.LoggerHelperFactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.slf4j.Marker;\n+\n+public final class SwitchableLogLevelFactory extends LoggerHelperFactory\n+    implements LogLevelSwitcher {\n+  private final LoggerHelperFactory delegate;\n+  private final AtomicReference<LogLevel> override;", "originalCommit": "5518a4e077372468432ad4815ce349d7a5ff151b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA3MzM1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1891#discussion_r492073355", "bodyText": "Yeah, I'll switch things around and skip the AtomicReference.", "author": "bantonsson", "createdAt": "2020-09-21T14:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1NDAzNg=="}], "type": "inlineReview", "revised_code": {"commit": "8cfe4fe3ee824e7f658d3492a5043674464d8926", "chunk": "diff --git a/dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java b/dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java\nindex 25ef459071..f9817566f7 100644\n--- a/dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java\n+++ b/dd-java-agent/agent-logging/src/main/java/datadog/trace/logging/ddlogger/SwitchableLogLevelFactory.java\n\n@@ -4,93 +4,36 @@ import datadog.trace.logging.LogLevel;\n import datadog.trace.logging.LogLevelSwitcher;\n import datadog.trace.logging.LoggerHelper;\n import datadog.trace.logging.LoggerHelperFactory;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.atomic.AtomicReference;\n import org.slf4j.Marker;\n \n public final class SwitchableLogLevelFactory extends LoggerHelperFactory\n     implements LogLevelSwitcher {\n   private final LoggerHelperFactory delegate;\n-  private final AtomicReference<LogLevel> override;\n+  private volatile LogLevel override = null;\n \n   public SwitchableLogLevelFactory(LoggerHelperFactory delegate) {\n-    this(new AtomicReference<LogLevel>(), delegate);\n-  }\n-\n-  public SwitchableLogLevelFactory(\n-      AtomicReference<LogLevel> override, LoggerHelperFactory delegate) {\n     this.delegate = delegate;\n-    this.override = override;\n   }\n \n   @Override\n   public void switchLevel(LogLevel level) {\n-    Opaque.setLevel(override, level);\n+    override = level;\n   }\n \n   @Override\n   public void restore() {\n-    Opaque.setLevel(override, null);\n-  }\n-\n-  private static final class Opaque {\n-    // Try to get handles to `getOpaque` and `setOpaque` since the reading and writing\n-    // of the override level does not need any  guarantees of memory ordering between\n-    // threads, and those should be the fastest.\n-    private static final MethodHandle GET;\n-    private static final MethodHandle SET;\n-\n-    static {\n-      MethodHandles.Lookup l = MethodHandles.publicLookup();\n-      Class<?> arClass = AtomicReference.class;\n-      Class<?> oClass = Object.class;\n-      MethodHandle get = null;\n-      MethodHandle set = null;\n-      try {\n-        get = l.findVirtual(arClass, \"getOpaque\", MethodType.methodType(oClass));\n-        set = l.findVirtual(arClass, \"setOpaque\", MethodType.methodType(void.class, oClass));\n-      } catch (Throwable t1) {\n-        try {\n-          get = l.findVirtual(arClass, \"get\", MethodType.methodType(oClass));\n-          set = l.findVirtual(arClass, \"lazySet\", MethodType.methodType(void.class, oClass));\n-        } catch (Throwable t2) {\n-          throw new ExceptionInInitializerError(t2);\n-        }\n-      }\n-      GET = get;\n-      SET = set;\n-    }\n-\n-    private static LogLevel getLevel(AtomicReference<LogLevel> ar) {\n-      try {\n-        return (LogLevel) GET.invoke(ar);\n-      } catch (Throwable t) {\n-        return ar.get();\n-      }\n-    }\n-\n-    private static void setLevel(AtomicReference<LogLevel> ar, LogLevel level) {\n-      try {\n-        SET.invoke(ar, (Object) level);\n-      } catch (Throwable t) {\n-        ar.lazySet(level);\n-      }\n-    }\n+    override = null;\n   }\n \n   @Override\n   public LoggerHelper loggerHelperForName(String name) {\n-    return new Helper(override, delegate.loggerHelperForName(name));\n+    return new Helper(delegate.loggerHelperForName(name));\n   }\n \n-  static final class Helper extends LoggerHelper {\n-    private final AtomicReference<LogLevel> override;\n+  final class Helper extends LoggerHelper {\n     private final LoggerHelper delegate;\n \n-    private Helper(AtomicReference<LogLevel> override, LoggerHelper delegate) {\n-      this.override = override;\n+    private Helper(LoggerHelper delegate) {\n       this.delegate = delegate;\n     }\n \n"}}, {"oid": "a7fd5396ab63fbe54ce7cb8a6d9bd138e35e9359", "url": "https://github.com/DataDog/dd-trace-java/commit/a7fd5396ab63fbe54ce7cb8a6d9bd138e35e9359", "message": "Make it possible to switch log level during runtime", "committedDate": "2020-09-22T14:14:25Z", "type": "commit"}, {"oid": "8cfe4fe3ee824e7f658d3492a5043674464d8926", "url": "https://github.com/DataDog/dd-trace-java/commit/8cfe4fe3ee824e7f658d3492a5043674464d8926", "message": "Simplification based on review", "committedDate": "2020-09-22T14:14:34Z", "type": "commit"}, {"oid": "8cfe4fe3ee824e7f658d3492a5043674464d8926", "url": "https://github.com/DataDog/dd-trace-java/commit/8cfe4fe3ee824e7f658d3492a5043674464d8926", "message": "Simplification based on review", "committedDate": "2020-09-22T14:14:34Z", "type": "forcePushed"}]}