{"pr_number": 1297, "pr_title": "Add exception sampling event", "pr_createdAt": "2020-03-05T18:38:45Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1297", "timeline": [{"oid": "30f278768eb4b940365d7c01b952d4ca89ce7824", "url": "https://github.com/DataDog/dd-trace-java/commit/30f278768eb4b940365d7c01b952d4ca89ce7824", "message": "Merge remote-tracking branch 'origin/jb/PROF-581_exceptions_sampler' into jb/PROF-581_exceptions_sampler", "committedDate": "2020-04-20T12:32:09Z", "type": "commit"}, {"oid": "44ed263bf67ef1cdfa666e0333b1905be79a4f4f", "url": "https://github.com/DataDog/dd-trace-java/commit/44ed263bf67ef1cdfa666e0333b1905be79a4f4f", "message": "Make format check happy", "committedDate": "2020-04-20T12:58:48Z", "type": "commit"}, {"oid": "df2a2a6e39f66c7911675fc9afe6885b5c717a4e", "url": "https://github.com/DataDog/dd-trace-java/commit/df2a2a6e39f66c7911675fc9afe6885b5c717a4e", "message": "Can not check for JFR in 'defaultEnabled()'.\nJFR presence flag is set only later in the constructor, after 'defaultEnabled()' has already been called.", "committedDate": "2020-04-20T13:47:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxODcyMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398518721", "bodyText": "I do not think this is used.", "author": "mar-kolya", "createdAt": "2020-03-26T12:02:44Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}", "originalCommit": "2996cbc230692a8ae398480d74104d5215ec4b12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzNDg5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398534896", "bodyText": "That's a case of callbacks :) Not necessarily 100% used. I can use it in the test to make sure the number of callbacks equals the number of samples though.", "author": "jbachorik", "createdAt": "2020-03-26T12:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxODcyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex 97e05ba3b6..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,222 +1,121 @@\n package com.datadog.profiling.exceptions;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n+import java.util.concurrent.atomic.LongAdder;\n \n /**\n  * A streaming (non-remembering) sampler.\n  *\n  * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n- * fashion. It is also using constant updates of the estimated event set per window such that it can\n- * vary the expected sampling interval (how many events are between two samples in average) to cover\n- * the events within one window by approximately the number of requested samples per window. Due to\n- * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n- * show the variability being around 20%) and it must be understood that the expected number of\n- * samples per window is not a hard/precise limit.\n+ * fashion. For this it divides the timeline into 'sampling windows' of constant duration. Each\n+ * sampling window targets a constant number of samples which are scattered randomly (uniform\n+ * distribution) throughout the window duration and once the window is over the real stats of\n+ * incoming events and the number of gathered samples is used to recompute the target probability to\n+ * use in the following window.\n+ *\n+ * <p>This will guarantee, if the windows are not excessively large, that the sampler will be able\n+ * to adjust to the changes in the rate of incoming events.\n+ *\n+ * <p>However, there might so rapid changes in incoming events rate that we will optimistically use\n+ * all allowed samples well before the current window has elapsed or, on the other end of the\n+ * spectrum, there will be to few incoming events and the sampler will not be able to generate the\n+ * target number of samples.\n+ *\n+ * <p>To smooth out these hicups the sampler maintains an under-sampling budget which can be used\n+ * to compensate for too rapid changes in the incoming events rate and maintain the target average\n+ * number of samples per window.\n  */\n-public class StreamingSampler {\n-  /**\n-   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n-   * window roll.\n-   */\n-  static final class SamplerState {\n-    private final AtomicLong eventCounter;\n-    // was this state created for a sampling test?\n-    private final AtomicBoolean sampledFlag;\n-    // was this state create for a window roll?\n-    private final AtomicBoolean expiredFlag;\n-    final long samples;\n-    final double threshold;\n-    final long windowStartTs;\n-    final long windowEndTs;\n-    final long windowDurationNs;\n-    final long samplesPerWindow;\n-\n-    private final Supplier<Long> tsProvider;\n-\n-    private SamplerState(\n-        final long events,\n-        final double threshold,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final long windowStartTs,\n-        final boolean sampled,\n-        final boolean expired,\n-        final Supplier<Long> tsProvider) {\n-      eventCounter = new AtomicLong(events);\n-      this.threshold = threshold;\n-      this.samples = samples;\n+class StreamingSampler {\n \n-      this.windowDurationNs = windowDurationNs;\n-      this.windowStartTs = windowStartTs;\n-      windowEndTs = windowStartTs + windowDurationNs;\n-      this.samplesPerWindow = samplesPerWindow;\n-      this.tsProvider = tsProvider;\n-      sampledFlag = new AtomicBoolean(sampled);\n-      expiredFlag = new AtomicBoolean(expired);\n-    }\n-\n-    SamplerState(\n-        final long events,\n-        final long interval,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final Supplier<Long> tsProvider) {\n-      this(\n-          events,\n-          computeThreshold(samplesPerWindow, samples, interval),\n-          samples,\n-          samplesPerWindow,\n-          windowDurationNs,\n-          tsProvider.get(),\n-          false,\n-          false,\n-          tsProvider);\n-    }\n+  /*\n+   * Number of windows to look back when computing carried over budget.\n+   * This value is `approximate' since we use EMA to keep running average.\n+   */\n+  private static final int CARRIED_OVER_BUDGET_LOOK_BACK = 16;\n \n-    SamplerState trySample() {\n-      final long tested = eventCounter.incrementAndGet();\n-      // test a uniformly distributed random number against the current threshold\n-      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-      final long ts = tsProvider.get();\n-      // a state is expired if the current time stamp is beyond the expected window end time stamp\n-      final boolean isExpired = ts > windowEndTs;\n-      if (isSampled || isExpired) {\n-        /*\n-         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n-         */\n-        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n-        /*\n-         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n-         * in one sampling window.\n-         */\n-        final long interval =\n-            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n-        // generate a new derived immutable state\n-        return new SamplerState(\n-            isExpired ? 0 : tested,\n-            computeThreshold(samplesPerWindow, samples, interval),\n-            isExpired ? 0 : samples + 1,\n-            samplesPerWindow,\n-            windowDurationNs,\n-            isExpired ? ts : windowStartTs,\n-            isSampled,\n-            isExpired,\n-            tsProvider);\n-      }\n-      return this;\n+    void addTest() {\n+      testCounter.increment();\n     }\n \n-    /**\n-     * Checks whether the state was created for a sampling test.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     sampling test\n-     */\n-    boolean sampled() {\n-      return sampledFlag.getAndSet(false);\n+    boolean addSample(final long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0)) < limit;\n     }\n+  }\n \n-    /**\n-     * Checks whether the state was created for a window roll.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     window roll\n-     */\n-    boolean expired() {\n-      return expiredFlag.getAndSet(false);\n-    }\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n \n-    /**\n-     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n-     * to test a uniformly distributed random number to decide whether the current test should yield\n-     * sample or not.\n-     */\n-    private static double computeThreshold(\n-        final long samplesPerWindow, final long samples, final long interval) {\n-      /*\n-       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n-       * expected sample per window.\n-       */\n-      final long samplesDiff = samplesPerWindow - samples;\n-      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+  private final AtomicReference<Counts> countsRef;\n \n-      /*\n-       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n-       * the next 'x' tests.\n-       */\n-      return 1 - Math.pow(1 - p, interval + 1);\n-    }\n+  // these attributes need to be volatile since they are accessed from user threds as well as the\n+  // maintenance one\n+  private volatile double probability = 1d;\n+  private volatile long samplesBudget;\n \n-    @Override\n-    public String toString() {\n-      return \"SamplerState{\"\n-          + \"eventCount=\"\n-          + eventCounter.get()\n-          + \", samples=\"\n-          + samples\n-          + \", threshold=\"\n-          + threshold\n-          + \", windowStartTs=\"\n-          + windowStartTs\n-          + \", windowEndTs=\"\n-          + windowEndTs\n-          + \", windowDurationNs=\"\n-          + windowDurationNs\n-          + \", samplesPerWindow=\"\n-          + samplesPerWindow\n-          + \", sampledFlag=\"\n-          + sampledFlag\n-          + '}';\n-    }\n-  }\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgSamples;\n \n-  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+  private final double budgetAlpha;\n \n   /**\n    * Create a new sampler instance\n    *\n-   * @param samplingWindowDuration the sampling window duration\n-   * @param slidingWindowUnit the time unit for the sampling window duration\n-   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n-   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   * @param taskExecutor common task executor to use for periodic rolls\n    */\n-  public StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int maxSamplesInWindow,\n-      final int initialInterval) {\n-    this(\n-        samplingWindowDuration,\n-        slidingWindowUnit,\n-        maxSamplesInWindow,\n-        initialInterval,\n-        System::nanoTime);\n-  }\n-\n   StreamingSampler(\n-      final long windowDurationNs,\n-      final TimeUnit windowDurationUnit,\n+      final Duration windowDuration,\n       final int samplesPerWindow,\n-      final int initialInterval,\n-      final Supplier<Long> tsProvider) {\n-    stateRef.set(\n-        new SamplerState(\n-            0,\n-            initialInterval,\n-            0L,\n-            samplesPerWindow,\n-            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n-            tsProvider));\n+      final int lookback,\n+      final CommonTaskExecutor taskExecutor) {\n+\n+    this.samplesPerWindow = samplesPerWindow;\n+    samplesBudget = samplesPerWindow + CARRIED_OVER_BUDGET_LOOK_BACK * samplesPerWindow;\n+    emaAlpha = computeIntervalAlpha(lookback);\n+    budgetAlpha = computeIntervalAlpha(CARRIED_OVER_BUDGET_LOOK_BACK);\n+    countsRef = new AtomicReference<>(new Counts());\n+\n+    taskExecutor.scheduleAtFixedRate(\n+        RollWindowTask.INSTANCE,\n+        this,\n+        windowDuration.toNanos(),\n+        windowDuration.toNanos(),\n+        TimeUnit.NANOSECONDS,\n+        \"exception sampling window roll\");\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, CommonTaskExecutor.INSTANCE);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398520108", "bodyText": "I think this can be removed: I do not think it provides any actual testing value.\nIn your tests you already control number of windows, so if window rolling is busted your sampling averages will be busted as well. This just seems to introduce unnecessary complexity to the code.", "author": "mar-kolya", "createdAt": "2020-03-26T12:05:22Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}\n+\n+  /**\n+   * A custom callback to observe rolling of the sampling window. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after rolling the window\n+   */\n+  protected void onWindowRoll(final SamplerState state) {}", "originalCommit": "2996cbc230692a8ae398480d74104d5215ec4b12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzNjQzMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398536433", "bodyText": "Actually it does provide a value - in the test I am using simulated clock with random spread within a variability interval and can not guarantee that the requested number of windows will correspond to the observed number of windows. That's where this callback comes handy.\nAlso, I am not sure that an empty callback definition adds a lot of complexity.", "author": "jbachorik", "createdAt": "2020-03-26T12:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzODUzNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398538536", "bodyText": "I think that unit tests testing/viewing internals of implementation is actually not write way to test. So eventhough this in of itself doesn't add much of a complexity - needing it suggests that our tests could be expanded to actually give us confidence that our implementation is correct without looking at the guts.", "author": "mar-kolya", "createdAt": "2020-03-26T12:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NjMyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r399296322", "bodyText": "Removed", "author": "jbachorik", "createdAt": "2020-03-27T14:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex 97e05ba3b6..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,222 +1,121 @@\n package com.datadog.profiling.exceptions;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n+import java.util.concurrent.atomic.LongAdder;\n \n /**\n  * A streaming (non-remembering) sampler.\n  *\n  * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n- * fashion. It is also using constant updates of the estimated event set per window such that it can\n- * vary the expected sampling interval (how many events are between two samples in average) to cover\n- * the events within one window by approximately the number of requested samples per window. Due to\n- * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n- * show the variability being around 20%) and it must be understood that the expected number of\n- * samples per window is not a hard/precise limit.\n+ * fashion. For this it divides the timeline into 'sampling windows' of constant duration. Each\n+ * sampling window targets a constant number of samples which are scattered randomly (uniform\n+ * distribution) throughout the window duration and once the window is over the real stats of\n+ * incoming events and the number of gathered samples is used to recompute the target probability to\n+ * use in the following window.\n+ *\n+ * <p>This will guarantee, if the windows are not excessively large, that the sampler will be able\n+ * to adjust to the changes in the rate of incoming events.\n+ *\n+ * <p>However, there might so rapid changes in incoming events rate that we will optimistically use\n+ * all allowed samples well before the current window has elapsed or, on the other end of the\n+ * spectrum, there will be to few incoming events and the sampler will not be able to generate the\n+ * target number of samples.\n+ *\n+ * <p>To smooth out these hicups the sampler maintains an under-sampling budget which can be used\n+ * to compensate for too rapid changes in the incoming events rate and maintain the target average\n+ * number of samples per window.\n  */\n-public class StreamingSampler {\n-  /**\n-   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n-   * window roll.\n-   */\n-  static final class SamplerState {\n-    private final AtomicLong eventCounter;\n-    // was this state created for a sampling test?\n-    private final AtomicBoolean sampledFlag;\n-    // was this state create for a window roll?\n-    private final AtomicBoolean expiredFlag;\n-    final long samples;\n-    final double threshold;\n-    final long windowStartTs;\n-    final long windowEndTs;\n-    final long windowDurationNs;\n-    final long samplesPerWindow;\n-\n-    private final Supplier<Long> tsProvider;\n-\n-    private SamplerState(\n-        final long events,\n-        final double threshold,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final long windowStartTs,\n-        final boolean sampled,\n-        final boolean expired,\n-        final Supplier<Long> tsProvider) {\n-      eventCounter = new AtomicLong(events);\n-      this.threshold = threshold;\n-      this.samples = samples;\n+class StreamingSampler {\n \n-      this.windowDurationNs = windowDurationNs;\n-      this.windowStartTs = windowStartTs;\n-      windowEndTs = windowStartTs + windowDurationNs;\n-      this.samplesPerWindow = samplesPerWindow;\n-      this.tsProvider = tsProvider;\n-      sampledFlag = new AtomicBoolean(sampled);\n-      expiredFlag = new AtomicBoolean(expired);\n-    }\n-\n-    SamplerState(\n-        final long events,\n-        final long interval,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final Supplier<Long> tsProvider) {\n-      this(\n-          events,\n-          computeThreshold(samplesPerWindow, samples, interval),\n-          samples,\n-          samplesPerWindow,\n-          windowDurationNs,\n-          tsProvider.get(),\n-          false,\n-          false,\n-          tsProvider);\n-    }\n+  /*\n+   * Number of windows to look back when computing carried over budget.\n+   * This value is `approximate' since we use EMA to keep running average.\n+   */\n+  private static final int CARRIED_OVER_BUDGET_LOOK_BACK = 16;\n \n-    SamplerState trySample() {\n-      final long tested = eventCounter.incrementAndGet();\n-      // test a uniformly distributed random number against the current threshold\n-      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-      final long ts = tsProvider.get();\n-      // a state is expired if the current time stamp is beyond the expected window end time stamp\n-      final boolean isExpired = ts > windowEndTs;\n-      if (isSampled || isExpired) {\n-        /*\n-         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n-         */\n-        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n-        /*\n-         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n-         * in one sampling window.\n-         */\n-        final long interval =\n-            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n-        // generate a new derived immutable state\n-        return new SamplerState(\n-            isExpired ? 0 : tested,\n-            computeThreshold(samplesPerWindow, samples, interval),\n-            isExpired ? 0 : samples + 1,\n-            samplesPerWindow,\n-            windowDurationNs,\n-            isExpired ? ts : windowStartTs,\n-            isSampled,\n-            isExpired,\n-            tsProvider);\n-      }\n-      return this;\n+    void addTest() {\n+      testCounter.increment();\n     }\n \n-    /**\n-     * Checks whether the state was created for a sampling test.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     sampling test\n-     */\n-    boolean sampled() {\n-      return sampledFlag.getAndSet(false);\n+    boolean addSample(final long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0)) < limit;\n     }\n+  }\n \n-    /**\n-     * Checks whether the state was created for a window roll.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     window roll\n-     */\n-    boolean expired() {\n-      return expiredFlag.getAndSet(false);\n-    }\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n \n-    /**\n-     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n-     * to test a uniformly distributed random number to decide whether the current test should yield\n-     * sample or not.\n-     */\n-    private static double computeThreshold(\n-        final long samplesPerWindow, final long samples, final long interval) {\n-      /*\n-       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n-       * expected sample per window.\n-       */\n-      final long samplesDiff = samplesPerWindow - samples;\n-      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+  private final AtomicReference<Counts> countsRef;\n \n-      /*\n-       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n-       * the next 'x' tests.\n-       */\n-      return 1 - Math.pow(1 - p, interval + 1);\n-    }\n+  // these attributes need to be volatile since they are accessed from user threds as well as the\n+  // maintenance one\n+  private volatile double probability = 1d;\n+  private volatile long samplesBudget;\n \n-    @Override\n-    public String toString() {\n-      return \"SamplerState{\"\n-          + \"eventCount=\"\n-          + eventCounter.get()\n-          + \", samples=\"\n-          + samples\n-          + \", threshold=\"\n-          + threshold\n-          + \", windowStartTs=\"\n-          + windowStartTs\n-          + \", windowEndTs=\"\n-          + windowEndTs\n-          + \", windowDurationNs=\"\n-          + windowDurationNs\n-          + \", samplesPerWindow=\"\n-          + samplesPerWindow\n-          + \", sampledFlag=\"\n-          + sampledFlag\n-          + '}';\n-    }\n-  }\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgSamples;\n \n-  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+  private final double budgetAlpha;\n \n   /**\n    * Create a new sampler instance\n    *\n-   * @param samplingWindowDuration the sampling window duration\n-   * @param slidingWindowUnit the time unit for the sampling window duration\n-   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n-   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   * @param taskExecutor common task executor to use for periodic rolls\n    */\n-  public StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int maxSamplesInWindow,\n-      final int initialInterval) {\n-    this(\n-        samplingWindowDuration,\n-        slidingWindowUnit,\n-        maxSamplesInWindow,\n-        initialInterval,\n-        System::nanoTime);\n-  }\n-\n   StreamingSampler(\n-      final long windowDurationNs,\n-      final TimeUnit windowDurationUnit,\n+      final Duration windowDuration,\n       final int samplesPerWindow,\n-      final int initialInterval,\n-      final Supplier<Long> tsProvider) {\n-    stateRef.set(\n-        new SamplerState(\n-            0,\n-            initialInterval,\n-            0L,\n-            samplesPerWindow,\n-            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n-            tsProvider));\n+      final int lookback,\n+      final CommonTaskExecutor taskExecutor) {\n+\n+    this.samplesPerWindow = samplesPerWindow;\n+    samplesBudget = samplesPerWindow + CARRIED_OVER_BUDGET_LOOK_BACK * samplesPerWindow;\n+    emaAlpha = computeIntervalAlpha(lookback);\n+    budgetAlpha = computeIntervalAlpha(CARRIED_OVER_BUDGET_LOOK_BACK);\n+    countsRef = new AtomicReference<>(new Counts());\n+\n+    taskExecutor.scheduleAtFixedRate(\n+        RollWindowTask.INSTANCE,\n+        this,\n+        windowDuration.toNanos(),\n+        windowDuration.toNanos(),\n+        TimeUnit.NANOSECONDS,\n+        \"exception sampling window roll\");\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, CommonTaskExecutor.INSTANCE);\n   }\n \n   /**\n"}}, {"oid": "a89c17e57c49c861f046007160809a324fb5b1cd", "url": "https://github.com/DataDog/dd-trace-java/commit/a89c17e57c49c861f046007160809a324fb5b1cd", "message": "Update dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle\n\nCo-Authored-By: Nikolay Martynov <mar.kolya@gmail.com>", "committedDate": "2020-03-26T12:37:52Z", "type": "commit"}, {"oid": "d76a589d75f6ca6a2c057cfbe1d50cb4b9d0c7bf", "url": "https://github.com/DataDog/dd-trace-java/commit/d76a589d75f6ca6a2c057cfbe1d50cb4b9d0c7bf", "message": "Make sure sampler tests are run", "committedDate": "2020-03-26T13:14:18Z", "type": "commit"}, {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d", "url": "https://github.com/DataDog/dd-trace-java/commit/e5346fc729bb847e5cf1c704581328b3a368d44d", "message": "Merge pull request #1343 from DataDog/mar-kolya/sampler-fix-tests\n\nsampler fix tests", "committedDate": "2020-03-26T13:32:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU4NTIxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398585212", "bodyText": "Thanks for all the comment - this code is much easier to understand this way!", "author": "mar-kolya", "createdAt": "2020-03-26T13:48:29Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */", "originalCommit": "e5346fc729bb847e5cf1c704581328b3a368d44d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex 97e05ba3b6..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,222 +1,121 @@\n package com.datadog.profiling.exceptions;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n+import java.util.concurrent.atomic.LongAdder;\n \n /**\n  * A streaming (non-remembering) sampler.\n  *\n  * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n- * fashion. It is also using constant updates of the estimated event set per window such that it can\n- * vary the expected sampling interval (how many events are between two samples in average) to cover\n- * the events within one window by approximately the number of requested samples per window. Due to\n- * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n- * show the variability being around 20%) and it must be understood that the expected number of\n- * samples per window is not a hard/precise limit.\n+ * fashion. For this it divides the timeline into 'sampling windows' of constant duration. Each\n+ * sampling window targets a constant number of samples which are scattered randomly (uniform\n+ * distribution) throughout the window duration and once the window is over the real stats of\n+ * incoming events and the number of gathered samples is used to recompute the target probability to\n+ * use in the following window.\n+ *\n+ * <p>This will guarantee, if the windows are not excessively large, that the sampler will be able\n+ * to adjust to the changes in the rate of incoming events.\n+ *\n+ * <p>However, there might so rapid changes in incoming events rate that we will optimistically use\n+ * all allowed samples well before the current window has elapsed or, on the other end of the\n+ * spectrum, there will be to few incoming events and the sampler will not be able to generate the\n+ * target number of samples.\n+ *\n+ * <p>To smooth out these hicups the sampler maintains an under-sampling budget which can be used\n+ * to compensate for too rapid changes in the incoming events rate and maintain the target average\n+ * number of samples per window.\n  */\n-public class StreamingSampler {\n-  /**\n-   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n-   * window roll.\n-   */\n-  static final class SamplerState {\n-    private final AtomicLong eventCounter;\n-    // was this state created for a sampling test?\n-    private final AtomicBoolean sampledFlag;\n-    // was this state create for a window roll?\n-    private final AtomicBoolean expiredFlag;\n-    final long samples;\n-    final double threshold;\n-    final long windowStartTs;\n-    final long windowEndTs;\n-    final long windowDurationNs;\n-    final long samplesPerWindow;\n-\n-    private final Supplier<Long> tsProvider;\n-\n-    private SamplerState(\n-        final long events,\n-        final double threshold,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final long windowStartTs,\n-        final boolean sampled,\n-        final boolean expired,\n-        final Supplier<Long> tsProvider) {\n-      eventCounter = new AtomicLong(events);\n-      this.threshold = threshold;\n-      this.samples = samples;\n+class StreamingSampler {\n \n-      this.windowDurationNs = windowDurationNs;\n-      this.windowStartTs = windowStartTs;\n-      windowEndTs = windowStartTs + windowDurationNs;\n-      this.samplesPerWindow = samplesPerWindow;\n-      this.tsProvider = tsProvider;\n-      sampledFlag = new AtomicBoolean(sampled);\n-      expiredFlag = new AtomicBoolean(expired);\n-    }\n-\n-    SamplerState(\n-        final long events,\n-        final long interval,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final Supplier<Long> tsProvider) {\n-      this(\n-          events,\n-          computeThreshold(samplesPerWindow, samples, interval),\n-          samples,\n-          samplesPerWindow,\n-          windowDurationNs,\n-          tsProvider.get(),\n-          false,\n-          false,\n-          tsProvider);\n-    }\n+  /*\n+   * Number of windows to look back when computing carried over budget.\n+   * This value is `approximate' since we use EMA to keep running average.\n+   */\n+  private static final int CARRIED_OVER_BUDGET_LOOK_BACK = 16;\n \n-    SamplerState trySample() {\n-      final long tested = eventCounter.incrementAndGet();\n-      // test a uniformly distributed random number against the current threshold\n-      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-      final long ts = tsProvider.get();\n-      // a state is expired if the current time stamp is beyond the expected window end time stamp\n-      final boolean isExpired = ts > windowEndTs;\n-      if (isSampled || isExpired) {\n-        /*\n-         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n-         */\n-        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n-        /*\n-         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n-         * in one sampling window.\n-         */\n-        final long interval =\n-            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n-        // generate a new derived immutable state\n-        return new SamplerState(\n-            isExpired ? 0 : tested,\n-            computeThreshold(samplesPerWindow, samples, interval),\n-            isExpired ? 0 : samples + 1,\n-            samplesPerWindow,\n-            windowDurationNs,\n-            isExpired ? ts : windowStartTs,\n-            isSampled,\n-            isExpired,\n-            tsProvider);\n-      }\n-      return this;\n+    void addTest() {\n+      testCounter.increment();\n     }\n \n-    /**\n-     * Checks whether the state was created for a sampling test.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     sampling test\n-     */\n-    boolean sampled() {\n-      return sampledFlag.getAndSet(false);\n+    boolean addSample(final long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0)) < limit;\n     }\n+  }\n \n-    /**\n-     * Checks whether the state was created for a window roll.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     window roll\n-     */\n-    boolean expired() {\n-      return expiredFlag.getAndSet(false);\n-    }\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n \n-    /**\n-     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n-     * to test a uniformly distributed random number to decide whether the current test should yield\n-     * sample or not.\n-     */\n-    private static double computeThreshold(\n-        final long samplesPerWindow, final long samples, final long interval) {\n-      /*\n-       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n-       * expected sample per window.\n-       */\n-      final long samplesDiff = samplesPerWindow - samples;\n-      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+  private final AtomicReference<Counts> countsRef;\n \n-      /*\n-       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n-       * the next 'x' tests.\n-       */\n-      return 1 - Math.pow(1 - p, interval + 1);\n-    }\n+  // these attributes need to be volatile since they are accessed from user threds as well as the\n+  // maintenance one\n+  private volatile double probability = 1d;\n+  private volatile long samplesBudget;\n \n-    @Override\n-    public String toString() {\n-      return \"SamplerState{\"\n-          + \"eventCount=\"\n-          + eventCounter.get()\n-          + \", samples=\"\n-          + samples\n-          + \", threshold=\"\n-          + threshold\n-          + \", windowStartTs=\"\n-          + windowStartTs\n-          + \", windowEndTs=\"\n-          + windowEndTs\n-          + \", windowDurationNs=\"\n-          + windowDurationNs\n-          + \", samplesPerWindow=\"\n-          + samplesPerWindow\n-          + \", sampledFlag=\"\n-          + sampledFlag\n-          + '}';\n-    }\n-  }\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgSamples;\n \n-  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+  private final double budgetAlpha;\n \n   /**\n    * Create a new sampler instance\n    *\n-   * @param samplingWindowDuration the sampling window duration\n-   * @param slidingWindowUnit the time unit for the sampling window duration\n-   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n-   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   * @param taskExecutor common task executor to use for periodic rolls\n    */\n-  public StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int maxSamplesInWindow,\n-      final int initialInterval) {\n-    this(\n-        samplingWindowDuration,\n-        slidingWindowUnit,\n-        maxSamplesInWindow,\n-        initialInterval,\n-        System::nanoTime);\n-  }\n-\n   StreamingSampler(\n-      final long windowDurationNs,\n-      final TimeUnit windowDurationUnit,\n+      final Duration windowDuration,\n       final int samplesPerWindow,\n-      final int initialInterval,\n-      final Supplier<Long> tsProvider) {\n-    stateRef.set(\n-        new SamplerState(\n-            0,\n-            initialInterval,\n-            0L,\n-            samplesPerWindow,\n-            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n-            tsProvider));\n+      final int lookback,\n+      final CommonTaskExecutor taskExecutor) {\n+\n+    this.samplesPerWindow = samplesPerWindow;\n+    samplesBudget = samplesPerWindow + CARRIED_OVER_BUDGET_LOOK_BACK * samplesPerWindow;\n+    emaAlpha = computeIntervalAlpha(lookback);\n+    budgetAlpha = computeIntervalAlpha(CARRIED_OVER_BUDGET_LOOK_BACK);\n+    countsRef = new AtomicReference<>(new Counts());\n+\n+    taskExecutor.scheduleAtFixedRate(\n+        RollWindowTask.INSTANCE,\n+        this,\n+        windowDuration.toNanos(),\n+        windowDuration.toNanos(),\n+        TimeUnit.NANOSECONDS,\n+        \"exception sampling window roll\");\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, CommonTaskExecutor.INSTANCE);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU4NjUyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398586525", "bodyText": "I think there is a bug here: you use threshold from the end of the window in the beginning of the next window.\nIn worst (best?) case scenario if all your guesses were correct then in the end of the window threshold will be zero - this is not what you want in the beginning.", "author": "mar-kolya", "createdAt": "2020-03-26T13:50:04Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),", "originalCommit": "e5346fc729bb847e5cf1c704581328b3a368d44d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex 97e05ba3b6..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,222 +1,121 @@\n package com.datadog.profiling.exceptions;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n+import java.util.concurrent.atomic.LongAdder;\n \n /**\n  * A streaming (non-remembering) sampler.\n  *\n  * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n- * fashion. It is also using constant updates of the estimated event set per window such that it can\n- * vary the expected sampling interval (how many events are between two samples in average) to cover\n- * the events within one window by approximately the number of requested samples per window. Due to\n- * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n- * show the variability being around 20%) and it must be understood that the expected number of\n- * samples per window is not a hard/precise limit.\n+ * fashion. For this it divides the timeline into 'sampling windows' of constant duration. Each\n+ * sampling window targets a constant number of samples which are scattered randomly (uniform\n+ * distribution) throughout the window duration and once the window is over the real stats of\n+ * incoming events and the number of gathered samples is used to recompute the target probability to\n+ * use in the following window.\n+ *\n+ * <p>This will guarantee, if the windows are not excessively large, that the sampler will be able\n+ * to adjust to the changes in the rate of incoming events.\n+ *\n+ * <p>However, there might so rapid changes in incoming events rate that we will optimistically use\n+ * all allowed samples well before the current window has elapsed or, on the other end of the\n+ * spectrum, there will be to few incoming events and the sampler will not be able to generate the\n+ * target number of samples.\n+ *\n+ * <p>To smooth out these hicups the sampler maintains an under-sampling budget which can be used\n+ * to compensate for too rapid changes in the incoming events rate and maintain the target average\n+ * number of samples per window.\n  */\n-public class StreamingSampler {\n-  /**\n-   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n-   * window roll.\n-   */\n-  static final class SamplerState {\n-    private final AtomicLong eventCounter;\n-    // was this state created for a sampling test?\n-    private final AtomicBoolean sampledFlag;\n-    // was this state create for a window roll?\n-    private final AtomicBoolean expiredFlag;\n-    final long samples;\n-    final double threshold;\n-    final long windowStartTs;\n-    final long windowEndTs;\n-    final long windowDurationNs;\n-    final long samplesPerWindow;\n-\n-    private final Supplier<Long> tsProvider;\n-\n-    private SamplerState(\n-        final long events,\n-        final double threshold,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final long windowStartTs,\n-        final boolean sampled,\n-        final boolean expired,\n-        final Supplier<Long> tsProvider) {\n-      eventCounter = new AtomicLong(events);\n-      this.threshold = threshold;\n-      this.samples = samples;\n+class StreamingSampler {\n \n-      this.windowDurationNs = windowDurationNs;\n-      this.windowStartTs = windowStartTs;\n-      windowEndTs = windowStartTs + windowDurationNs;\n-      this.samplesPerWindow = samplesPerWindow;\n-      this.tsProvider = tsProvider;\n-      sampledFlag = new AtomicBoolean(sampled);\n-      expiredFlag = new AtomicBoolean(expired);\n-    }\n-\n-    SamplerState(\n-        final long events,\n-        final long interval,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final Supplier<Long> tsProvider) {\n-      this(\n-          events,\n-          computeThreshold(samplesPerWindow, samples, interval),\n-          samples,\n-          samplesPerWindow,\n-          windowDurationNs,\n-          tsProvider.get(),\n-          false,\n-          false,\n-          tsProvider);\n-    }\n+  /*\n+   * Number of windows to look back when computing carried over budget.\n+   * This value is `approximate' since we use EMA to keep running average.\n+   */\n+  private static final int CARRIED_OVER_BUDGET_LOOK_BACK = 16;\n \n-    SamplerState trySample() {\n-      final long tested = eventCounter.incrementAndGet();\n-      // test a uniformly distributed random number against the current threshold\n-      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-      final long ts = tsProvider.get();\n-      // a state is expired if the current time stamp is beyond the expected window end time stamp\n-      final boolean isExpired = ts > windowEndTs;\n-      if (isSampled || isExpired) {\n-        /*\n-         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n-         */\n-        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n-        /*\n-         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n-         * in one sampling window.\n-         */\n-        final long interval =\n-            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n-        // generate a new derived immutable state\n-        return new SamplerState(\n-            isExpired ? 0 : tested,\n-            computeThreshold(samplesPerWindow, samples, interval),\n-            isExpired ? 0 : samples + 1,\n-            samplesPerWindow,\n-            windowDurationNs,\n-            isExpired ? ts : windowStartTs,\n-            isSampled,\n-            isExpired,\n-            tsProvider);\n-      }\n-      return this;\n+    void addTest() {\n+      testCounter.increment();\n     }\n \n-    /**\n-     * Checks whether the state was created for a sampling test.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     sampling test\n-     */\n-    boolean sampled() {\n-      return sampledFlag.getAndSet(false);\n+    boolean addSample(final long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0)) < limit;\n     }\n+  }\n \n-    /**\n-     * Checks whether the state was created for a window roll.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     window roll\n-     */\n-    boolean expired() {\n-      return expiredFlag.getAndSet(false);\n-    }\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n \n-    /**\n-     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n-     * to test a uniformly distributed random number to decide whether the current test should yield\n-     * sample or not.\n-     */\n-    private static double computeThreshold(\n-        final long samplesPerWindow, final long samples, final long interval) {\n-      /*\n-       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n-       * expected sample per window.\n-       */\n-      final long samplesDiff = samplesPerWindow - samples;\n-      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+  private final AtomicReference<Counts> countsRef;\n \n-      /*\n-       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n-       * the next 'x' tests.\n-       */\n-      return 1 - Math.pow(1 - p, interval + 1);\n-    }\n+  // these attributes need to be volatile since they are accessed from user threds as well as the\n+  // maintenance one\n+  private volatile double probability = 1d;\n+  private volatile long samplesBudget;\n \n-    @Override\n-    public String toString() {\n-      return \"SamplerState{\"\n-          + \"eventCount=\"\n-          + eventCounter.get()\n-          + \", samples=\"\n-          + samples\n-          + \", threshold=\"\n-          + threshold\n-          + \", windowStartTs=\"\n-          + windowStartTs\n-          + \", windowEndTs=\"\n-          + windowEndTs\n-          + \", windowDurationNs=\"\n-          + windowDurationNs\n-          + \", samplesPerWindow=\"\n-          + samplesPerWindow\n-          + \", sampledFlag=\"\n-          + sampledFlag\n-          + '}';\n-    }\n-  }\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgSamples;\n \n-  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+  private final double budgetAlpha;\n \n   /**\n    * Create a new sampler instance\n    *\n-   * @param samplingWindowDuration the sampling window duration\n-   * @param slidingWindowUnit the time unit for the sampling window duration\n-   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n-   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   * @param taskExecutor common task executor to use for periodic rolls\n    */\n-  public StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int maxSamplesInWindow,\n-      final int initialInterval) {\n-    this(\n-        samplingWindowDuration,\n-        slidingWindowUnit,\n-        maxSamplesInWindow,\n-        initialInterval,\n-        System::nanoTime);\n-  }\n-\n   StreamingSampler(\n-      final long windowDurationNs,\n-      final TimeUnit windowDurationUnit,\n+      final Duration windowDuration,\n       final int samplesPerWindow,\n-      final int initialInterval,\n-      final Supplier<Long> tsProvider) {\n-    stateRef.set(\n-        new SamplerState(\n-            0,\n-            initialInterval,\n-            0L,\n-            samplesPerWindow,\n-            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n-            tsProvider));\n+      final int lookback,\n+      final CommonTaskExecutor taskExecutor) {\n+\n+    this.samplesPerWindow = samplesPerWindow;\n+    samplesBudget = samplesPerWindow + CARRIED_OVER_BUDGET_LOOK_BACK * samplesPerWindow;\n+    emaAlpha = computeIntervalAlpha(lookback);\n+    budgetAlpha = computeIntervalAlpha(CARRIED_OVER_BUDGET_LOOK_BACK);\n+    countsRef = new AtomicReference<>(new Counts());\n+\n+    taskExecutor.scheduleAtFixedRate(\n+        RollWindowTask.INSTANCE,\n+        this,\n+        windowDuration.toNanos(),\n+        windowDuration.toNanos(),\n+        TimeUnit.NANOSECONDS,\n+        \"exception sampling window roll\");\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, CommonTaskExecutor.INSTANCE);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5Njg5Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398596893", "bodyText": "This is called in AtomicReference#updateAndGet and AtomicReference#updateAndGet may call supplier multiple times resulting in over-count. AtomicReference#updateAndGet wants supplier to be side-effect-free.", "author": "mar-kolya", "createdAt": "2020-03-26T14:03:17Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();", "originalCommit": "e5346fc729bb847e5cf1c704581328b3a368d44d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NjY5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r399296694", "bodyText": "Correct. Changed the implementation to use synchronized block instead.", "author": "jbachorik", "createdAt": "2020-03-27T14:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5Njg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex 97e05ba3b6..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,222 +1,121 @@\n package com.datadog.profiling.exceptions;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n+import java.util.concurrent.atomic.LongAdder;\n \n /**\n  * A streaming (non-remembering) sampler.\n  *\n  * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n- * fashion. It is also using constant updates of the estimated event set per window such that it can\n- * vary the expected sampling interval (how many events are between two samples in average) to cover\n- * the events within one window by approximately the number of requested samples per window. Due to\n- * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n- * show the variability being around 20%) and it must be understood that the expected number of\n- * samples per window is not a hard/precise limit.\n+ * fashion. For this it divides the timeline into 'sampling windows' of constant duration. Each\n+ * sampling window targets a constant number of samples which are scattered randomly (uniform\n+ * distribution) throughout the window duration and once the window is over the real stats of\n+ * incoming events and the number of gathered samples is used to recompute the target probability to\n+ * use in the following window.\n+ *\n+ * <p>This will guarantee, if the windows are not excessively large, that the sampler will be able\n+ * to adjust to the changes in the rate of incoming events.\n+ *\n+ * <p>However, there might so rapid changes in incoming events rate that we will optimistically use\n+ * all allowed samples well before the current window has elapsed or, on the other end of the\n+ * spectrum, there will be to few incoming events and the sampler will not be able to generate the\n+ * target number of samples.\n+ *\n+ * <p>To smooth out these hicups the sampler maintains an under-sampling budget which can be used\n+ * to compensate for too rapid changes in the incoming events rate and maintain the target average\n+ * number of samples per window.\n  */\n-public class StreamingSampler {\n-  /**\n-   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n-   * window roll.\n-   */\n-  static final class SamplerState {\n-    private final AtomicLong eventCounter;\n-    // was this state created for a sampling test?\n-    private final AtomicBoolean sampledFlag;\n-    // was this state create for a window roll?\n-    private final AtomicBoolean expiredFlag;\n-    final long samples;\n-    final double threshold;\n-    final long windowStartTs;\n-    final long windowEndTs;\n-    final long windowDurationNs;\n-    final long samplesPerWindow;\n-\n-    private final Supplier<Long> tsProvider;\n-\n-    private SamplerState(\n-        final long events,\n-        final double threshold,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final long windowStartTs,\n-        final boolean sampled,\n-        final boolean expired,\n-        final Supplier<Long> tsProvider) {\n-      eventCounter = new AtomicLong(events);\n-      this.threshold = threshold;\n-      this.samples = samples;\n+class StreamingSampler {\n \n-      this.windowDurationNs = windowDurationNs;\n-      this.windowStartTs = windowStartTs;\n-      windowEndTs = windowStartTs + windowDurationNs;\n-      this.samplesPerWindow = samplesPerWindow;\n-      this.tsProvider = tsProvider;\n-      sampledFlag = new AtomicBoolean(sampled);\n-      expiredFlag = new AtomicBoolean(expired);\n-    }\n-\n-    SamplerState(\n-        final long events,\n-        final long interval,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final Supplier<Long> tsProvider) {\n-      this(\n-          events,\n-          computeThreshold(samplesPerWindow, samples, interval),\n-          samples,\n-          samplesPerWindow,\n-          windowDurationNs,\n-          tsProvider.get(),\n-          false,\n-          false,\n-          tsProvider);\n-    }\n+  /*\n+   * Number of windows to look back when computing carried over budget.\n+   * This value is `approximate' since we use EMA to keep running average.\n+   */\n+  private static final int CARRIED_OVER_BUDGET_LOOK_BACK = 16;\n \n-    SamplerState trySample() {\n-      final long tested = eventCounter.incrementAndGet();\n-      // test a uniformly distributed random number against the current threshold\n-      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-      final long ts = tsProvider.get();\n-      // a state is expired if the current time stamp is beyond the expected window end time stamp\n-      final boolean isExpired = ts > windowEndTs;\n-      if (isSampled || isExpired) {\n-        /*\n-         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n-         */\n-        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n-        /*\n-         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n-         * in one sampling window.\n-         */\n-        final long interval =\n-            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n-        // generate a new derived immutable state\n-        return new SamplerState(\n-            isExpired ? 0 : tested,\n-            computeThreshold(samplesPerWindow, samples, interval),\n-            isExpired ? 0 : samples + 1,\n-            samplesPerWindow,\n-            windowDurationNs,\n-            isExpired ? ts : windowStartTs,\n-            isSampled,\n-            isExpired,\n-            tsProvider);\n-      }\n-      return this;\n+    void addTest() {\n+      testCounter.increment();\n     }\n \n-    /**\n-     * Checks whether the state was created for a sampling test.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     sampling test\n-     */\n-    boolean sampled() {\n-      return sampledFlag.getAndSet(false);\n+    boolean addSample(final long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0)) < limit;\n     }\n+  }\n \n-    /**\n-     * Checks whether the state was created for a window roll.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     window roll\n-     */\n-    boolean expired() {\n-      return expiredFlag.getAndSet(false);\n-    }\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n \n-    /**\n-     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n-     * to test a uniformly distributed random number to decide whether the current test should yield\n-     * sample or not.\n-     */\n-    private static double computeThreshold(\n-        final long samplesPerWindow, final long samples, final long interval) {\n-      /*\n-       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n-       * expected sample per window.\n-       */\n-      final long samplesDiff = samplesPerWindow - samples;\n-      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+  private final AtomicReference<Counts> countsRef;\n \n-      /*\n-       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n-       * the next 'x' tests.\n-       */\n-      return 1 - Math.pow(1 - p, interval + 1);\n-    }\n+  // these attributes need to be volatile since they are accessed from user threds as well as the\n+  // maintenance one\n+  private volatile double probability = 1d;\n+  private volatile long samplesBudget;\n \n-    @Override\n-    public String toString() {\n-      return \"SamplerState{\"\n-          + \"eventCount=\"\n-          + eventCounter.get()\n-          + \", samples=\"\n-          + samples\n-          + \", threshold=\"\n-          + threshold\n-          + \", windowStartTs=\"\n-          + windowStartTs\n-          + \", windowEndTs=\"\n-          + windowEndTs\n-          + \", windowDurationNs=\"\n-          + windowDurationNs\n-          + \", samplesPerWindow=\"\n-          + samplesPerWindow\n-          + \", sampledFlag=\"\n-          + sampledFlag\n-          + '}';\n-    }\n-  }\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgSamples;\n \n-  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+  private final double budgetAlpha;\n \n   /**\n    * Create a new sampler instance\n    *\n-   * @param samplingWindowDuration the sampling window duration\n-   * @param slidingWindowUnit the time unit for the sampling window duration\n-   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n-   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   * @param taskExecutor common task executor to use for periodic rolls\n    */\n-  public StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int maxSamplesInWindow,\n-      final int initialInterval) {\n-    this(\n-        samplingWindowDuration,\n-        slidingWindowUnit,\n-        maxSamplesInWindow,\n-        initialInterval,\n-        System::nanoTime);\n-  }\n-\n   StreamingSampler(\n-      final long windowDurationNs,\n-      final TimeUnit windowDurationUnit,\n+      final Duration windowDuration,\n       final int samplesPerWindow,\n-      final int initialInterval,\n-      final Supplier<Long> tsProvider) {\n-    stateRef.set(\n-        new SamplerState(\n-            0,\n-            initialInterval,\n-            0L,\n-            samplesPerWindow,\n-            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n-            tsProvider));\n+      final int lookback,\n+      final CommonTaskExecutor taskExecutor) {\n+\n+    this.samplesPerWindow = samplesPerWindow;\n+    samplesBudget = samplesPerWindow + CARRIED_OVER_BUDGET_LOOK_BACK * samplesPerWindow;\n+    emaAlpha = computeIntervalAlpha(lookback);\n+    budgetAlpha = computeIntervalAlpha(CARRIED_OVER_BUDGET_LOOK_BACK);\n+    countsRef = new AtomicReference<>(new Counts());\n+\n+    taskExecutor.scheduleAtFixedRate(\n+        RollWindowTask.INSTANCE,\n+        this,\n+        windowDuration.toNanos(),\n+        windowDuration.toNanos(),\n+        TimeUnit.NANOSECONDS,\n+        \"exception sampling window roll\");\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, CommonTaskExecutor.INSTANCE);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5NzcwMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398597701", "bodyText": "I guess this is a technicality, but I do not think object containing AtomicLong and modifying it can be called 'immutable' :)", "author": "mar-kolya", "createdAt": "2020-03-26T14:04:24Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or", "originalCommit": "e5346fc729bb847e5cf1c704581328b3a368d44d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex 97e05ba3b6..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,222 +1,121 @@\n package com.datadog.profiling.exceptions;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n+import java.util.concurrent.atomic.LongAdder;\n \n /**\n  * A streaming (non-remembering) sampler.\n  *\n  * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n- * fashion. It is also using constant updates of the estimated event set per window such that it can\n- * vary the expected sampling interval (how many events are between two samples in average) to cover\n- * the events within one window by approximately the number of requested samples per window. Due to\n- * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n- * show the variability being around 20%) and it must be understood that the expected number of\n- * samples per window is not a hard/precise limit.\n+ * fashion. For this it divides the timeline into 'sampling windows' of constant duration. Each\n+ * sampling window targets a constant number of samples which are scattered randomly (uniform\n+ * distribution) throughout the window duration and once the window is over the real stats of\n+ * incoming events and the number of gathered samples is used to recompute the target probability to\n+ * use in the following window.\n+ *\n+ * <p>This will guarantee, if the windows are not excessively large, that the sampler will be able\n+ * to adjust to the changes in the rate of incoming events.\n+ *\n+ * <p>However, there might so rapid changes in incoming events rate that we will optimistically use\n+ * all allowed samples well before the current window has elapsed or, on the other end of the\n+ * spectrum, there will be to few incoming events and the sampler will not be able to generate the\n+ * target number of samples.\n+ *\n+ * <p>To smooth out these hicups the sampler maintains an under-sampling budget which can be used\n+ * to compensate for too rapid changes in the incoming events rate and maintain the target average\n+ * number of samples per window.\n  */\n-public class StreamingSampler {\n-  /**\n-   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n-   * window roll.\n-   */\n-  static final class SamplerState {\n-    private final AtomicLong eventCounter;\n-    // was this state created for a sampling test?\n-    private final AtomicBoolean sampledFlag;\n-    // was this state create for a window roll?\n-    private final AtomicBoolean expiredFlag;\n-    final long samples;\n-    final double threshold;\n-    final long windowStartTs;\n-    final long windowEndTs;\n-    final long windowDurationNs;\n-    final long samplesPerWindow;\n-\n-    private final Supplier<Long> tsProvider;\n-\n-    private SamplerState(\n-        final long events,\n-        final double threshold,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final long windowStartTs,\n-        final boolean sampled,\n-        final boolean expired,\n-        final Supplier<Long> tsProvider) {\n-      eventCounter = new AtomicLong(events);\n-      this.threshold = threshold;\n-      this.samples = samples;\n+class StreamingSampler {\n \n-      this.windowDurationNs = windowDurationNs;\n-      this.windowStartTs = windowStartTs;\n-      windowEndTs = windowStartTs + windowDurationNs;\n-      this.samplesPerWindow = samplesPerWindow;\n-      this.tsProvider = tsProvider;\n-      sampledFlag = new AtomicBoolean(sampled);\n-      expiredFlag = new AtomicBoolean(expired);\n-    }\n-\n-    SamplerState(\n-        final long events,\n-        final long interval,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final Supplier<Long> tsProvider) {\n-      this(\n-          events,\n-          computeThreshold(samplesPerWindow, samples, interval),\n-          samples,\n-          samplesPerWindow,\n-          windowDurationNs,\n-          tsProvider.get(),\n-          false,\n-          false,\n-          tsProvider);\n-    }\n+  /*\n+   * Number of windows to look back when computing carried over budget.\n+   * This value is `approximate' since we use EMA to keep running average.\n+   */\n+  private static final int CARRIED_OVER_BUDGET_LOOK_BACK = 16;\n \n-    SamplerState trySample() {\n-      final long tested = eventCounter.incrementAndGet();\n-      // test a uniformly distributed random number against the current threshold\n-      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-      final long ts = tsProvider.get();\n-      // a state is expired if the current time stamp is beyond the expected window end time stamp\n-      final boolean isExpired = ts > windowEndTs;\n-      if (isSampled || isExpired) {\n-        /*\n-         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n-         */\n-        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n-        /*\n-         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n-         * in one sampling window.\n-         */\n-        final long interval =\n-            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n-        // generate a new derived immutable state\n-        return new SamplerState(\n-            isExpired ? 0 : tested,\n-            computeThreshold(samplesPerWindow, samples, interval),\n-            isExpired ? 0 : samples + 1,\n-            samplesPerWindow,\n-            windowDurationNs,\n-            isExpired ? ts : windowStartTs,\n-            isSampled,\n-            isExpired,\n-            tsProvider);\n-      }\n-      return this;\n+    void addTest() {\n+      testCounter.increment();\n     }\n \n-    /**\n-     * Checks whether the state was created for a sampling test.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     sampling test\n-     */\n-    boolean sampled() {\n-      return sampledFlag.getAndSet(false);\n+    boolean addSample(final long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0)) < limit;\n     }\n+  }\n \n-    /**\n-     * Checks whether the state was created for a window roll.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     window roll\n-     */\n-    boolean expired() {\n-      return expiredFlag.getAndSet(false);\n-    }\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n \n-    /**\n-     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n-     * to test a uniformly distributed random number to decide whether the current test should yield\n-     * sample or not.\n-     */\n-    private static double computeThreshold(\n-        final long samplesPerWindow, final long samples, final long interval) {\n-      /*\n-       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n-       * expected sample per window.\n-       */\n-      final long samplesDiff = samplesPerWindow - samples;\n-      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+  private final AtomicReference<Counts> countsRef;\n \n-      /*\n-       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n-       * the next 'x' tests.\n-       */\n-      return 1 - Math.pow(1 - p, interval + 1);\n-    }\n+  // these attributes need to be volatile since they are accessed from user threds as well as the\n+  // maintenance one\n+  private volatile double probability = 1d;\n+  private volatile long samplesBudget;\n \n-    @Override\n-    public String toString() {\n-      return \"SamplerState{\"\n-          + \"eventCount=\"\n-          + eventCounter.get()\n-          + \", samples=\"\n-          + samples\n-          + \", threshold=\"\n-          + threshold\n-          + \", windowStartTs=\"\n-          + windowStartTs\n-          + \", windowEndTs=\"\n-          + windowEndTs\n-          + \", windowDurationNs=\"\n-          + windowDurationNs\n-          + \", samplesPerWindow=\"\n-          + samplesPerWindow\n-          + \", sampledFlag=\"\n-          + sampledFlag\n-          + '}';\n-    }\n-  }\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgSamples;\n \n-  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+  private final double budgetAlpha;\n \n   /**\n    * Create a new sampler instance\n    *\n-   * @param samplingWindowDuration the sampling window duration\n-   * @param slidingWindowUnit the time unit for the sampling window duration\n-   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n-   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   * @param taskExecutor common task executor to use for periodic rolls\n    */\n-  public StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int maxSamplesInWindow,\n-      final int initialInterval) {\n-    this(\n-        samplingWindowDuration,\n-        slidingWindowUnit,\n-        maxSamplesInWindow,\n-        initialInterval,\n-        System::nanoTime);\n-  }\n-\n   StreamingSampler(\n-      final long windowDurationNs,\n-      final TimeUnit windowDurationUnit,\n+      final Duration windowDuration,\n       final int samplesPerWindow,\n-      final int initialInterval,\n-      final Supplier<Long> tsProvider) {\n-    stateRef.set(\n-        new SamplerState(\n-            0,\n-            initialInterval,\n-            0L,\n-            samplesPerWindow,\n-            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n-            tsProvider));\n+      final int lookback,\n+      final CommonTaskExecutor taskExecutor) {\n+\n+    this.samplesPerWindow = samplesPerWindow;\n+    samplesBudget = samplesPerWindow + CARRIED_OVER_BUDGET_LOOK_BACK * samplesPerWindow;\n+    emaAlpha = computeIntervalAlpha(lookback);\n+    budgetAlpha = computeIntervalAlpha(CARRIED_OVER_BUDGET_LOOK_BACK);\n+    countsRef = new AtomicReference<>(new Counts());\n+\n+    taskExecutor.scheduleAtFixedRate(\n+        RollWindowTask.INSTANCE,\n+        this,\n+        windowDuration.toNanos(),\n+        windowDuration.toNanos(),\n+        TimeUnit.NANOSECONDS,\n+        \"exception sampling window roll\");\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, CommonTaskExecutor.INSTANCE);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5OTAzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398599037", "bodyText": "I would suggest naming like eventsSeen and eventsSampled used throughout", "author": "mar-kolya", "createdAt": "2020-03-26T14:06:17Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;", "originalCommit": "e5346fc729bb847e5cf1c704581328b3a368d44d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex 97e05ba3b6..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,222 +1,121 @@\n package com.datadog.profiling.exceptions;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n+import java.util.concurrent.atomic.LongAdder;\n \n /**\n  * A streaming (non-remembering) sampler.\n  *\n  * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n- * fashion. It is also using constant updates of the estimated event set per window such that it can\n- * vary the expected sampling interval (how many events are between two samples in average) to cover\n- * the events within one window by approximately the number of requested samples per window. Due to\n- * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n- * show the variability being around 20%) and it must be understood that the expected number of\n- * samples per window is not a hard/precise limit.\n+ * fashion. For this it divides the timeline into 'sampling windows' of constant duration. Each\n+ * sampling window targets a constant number of samples which are scattered randomly (uniform\n+ * distribution) throughout the window duration and once the window is over the real stats of\n+ * incoming events and the number of gathered samples is used to recompute the target probability to\n+ * use in the following window.\n+ *\n+ * <p>This will guarantee, if the windows are not excessively large, that the sampler will be able\n+ * to adjust to the changes in the rate of incoming events.\n+ *\n+ * <p>However, there might so rapid changes in incoming events rate that we will optimistically use\n+ * all allowed samples well before the current window has elapsed or, on the other end of the\n+ * spectrum, there will be to few incoming events and the sampler will not be able to generate the\n+ * target number of samples.\n+ *\n+ * <p>To smooth out these hicups the sampler maintains an under-sampling budget which can be used\n+ * to compensate for too rapid changes in the incoming events rate and maintain the target average\n+ * number of samples per window.\n  */\n-public class StreamingSampler {\n-  /**\n-   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n-   * window roll.\n-   */\n-  static final class SamplerState {\n-    private final AtomicLong eventCounter;\n-    // was this state created for a sampling test?\n-    private final AtomicBoolean sampledFlag;\n-    // was this state create for a window roll?\n-    private final AtomicBoolean expiredFlag;\n-    final long samples;\n-    final double threshold;\n-    final long windowStartTs;\n-    final long windowEndTs;\n-    final long windowDurationNs;\n-    final long samplesPerWindow;\n-\n-    private final Supplier<Long> tsProvider;\n-\n-    private SamplerState(\n-        final long events,\n-        final double threshold,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final long windowStartTs,\n-        final boolean sampled,\n-        final boolean expired,\n-        final Supplier<Long> tsProvider) {\n-      eventCounter = new AtomicLong(events);\n-      this.threshold = threshold;\n-      this.samples = samples;\n+class StreamingSampler {\n \n-      this.windowDurationNs = windowDurationNs;\n-      this.windowStartTs = windowStartTs;\n-      windowEndTs = windowStartTs + windowDurationNs;\n-      this.samplesPerWindow = samplesPerWindow;\n-      this.tsProvider = tsProvider;\n-      sampledFlag = new AtomicBoolean(sampled);\n-      expiredFlag = new AtomicBoolean(expired);\n-    }\n-\n-    SamplerState(\n-        final long events,\n-        final long interval,\n-        final long samples,\n-        final long samplesPerWindow,\n-        final long windowDurationNs,\n-        final Supplier<Long> tsProvider) {\n-      this(\n-          events,\n-          computeThreshold(samplesPerWindow, samples, interval),\n-          samples,\n-          samplesPerWindow,\n-          windowDurationNs,\n-          tsProvider.get(),\n-          false,\n-          false,\n-          tsProvider);\n-    }\n+  /*\n+   * Number of windows to look back when computing carried over budget.\n+   * This value is `approximate' since we use EMA to keep running average.\n+   */\n+  private static final int CARRIED_OVER_BUDGET_LOOK_BACK = 16;\n \n-    SamplerState trySample() {\n-      final long tested = eventCounter.incrementAndGet();\n-      // test a uniformly distributed random number against the current threshold\n-      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-      final long ts = tsProvider.get();\n-      // a state is expired if the current time stamp is beyond the expected window end time stamp\n-      final boolean isExpired = ts > windowEndTs;\n-      if (isSampled || isExpired) {\n-        /*\n-         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n-         */\n-        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n-        /*\n-         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n-         * in one sampling window.\n-         */\n-        final long interval =\n-            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n-        // generate a new derived immutable state\n-        return new SamplerState(\n-            isExpired ? 0 : tested,\n-            computeThreshold(samplesPerWindow, samples, interval),\n-            isExpired ? 0 : samples + 1,\n-            samplesPerWindow,\n-            windowDurationNs,\n-            isExpired ? ts : windowStartTs,\n-            isSampled,\n-            isExpired,\n-            tsProvider);\n-      }\n-      return this;\n+    void addTest() {\n+      testCounter.increment();\n     }\n \n-    /**\n-     * Checks whether the state was created for a sampling test.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     sampling test\n-     */\n-    boolean sampled() {\n-      return sampledFlag.getAndSet(false);\n+    boolean addSample(final long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0)) < limit;\n     }\n+  }\n \n-    /**\n-     * Checks whether the state was created for a window roll.<br>\n-     * After this method is invoked all subsequent invocations will return {@literal false}\n-     *\n-     * @return {@literal true} only if this is the first invocation and the state was created for a\n-     *     window roll\n-     */\n-    boolean expired() {\n-      return expiredFlag.getAndSet(false);\n-    }\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n \n-    /**\n-     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n-     * to test a uniformly distributed random number to decide whether the current test should yield\n-     * sample or not.\n-     */\n-    private static double computeThreshold(\n-        final long samplesPerWindow, final long samples, final long interval) {\n-      /*\n-       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n-       * expected sample per window.\n-       */\n-      final long samplesDiff = samplesPerWindow - samples;\n-      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+  private final AtomicReference<Counts> countsRef;\n \n-      /*\n-       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n-       * the next 'x' tests.\n-       */\n-      return 1 - Math.pow(1 - p, interval + 1);\n-    }\n+  // these attributes need to be volatile since they are accessed from user threds as well as the\n+  // maintenance one\n+  private volatile double probability = 1d;\n+  private volatile long samplesBudget;\n \n-    @Override\n-    public String toString() {\n-      return \"SamplerState{\"\n-          + \"eventCount=\"\n-          + eventCounter.get()\n-          + \", samples=\"\n-          + samples\n-          + \", threshold=\"\n-          + threshold\n-          + \", windowStartTs=\"\n-          + windowStartTs\n-          + \", windowEndTs=\"\n-          + windowEndTs\n-          + \", windowDurationNs=\"\n-          + windowDurationNs\n-          + \", samplesPerWindow=\"\n-          + samplesPerWindow\n-          + \", sampledFlag=\"\n-          + sampledFlag\n-          + '}';\n-    }\n-  }\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgSamples;\n \n-  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+  private final double budgetAlpha;\n \n   /**\n    * Create a new sampler instance\n    *\n-   * @param samplingWindowDuration the sampling window duration\n-   * @param slidingWindowUnit the time unit for the sampling window duration\n-   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n-   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   * @param taskExecutor common task executor to use for periodic rolls\n    */\n-  public StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int maxSamplesInWindow,\n-      final int initialInterval) {\n-    this(\n-        samplingWindowDuration,\n-        slidingWindowUnit,\n-        maxSamplesInWindow,\n-        initialInterval,\n-        System::nanoTime);\n-  }\n-\n   StreamingSampler(\n-      final long windowDurationNs,\n-      final TimeUnit windowDurationUnit,\n+      final Duration windowDuration,\n       final int samplesPerWindow,\n-      final int initialInterval,\n-      final Supplier<Long> tsProvider) {\n-    stateRef.set(\n-        new SamplerState(\n-            0,\n-            initialInterval,\n-            0L,\n-            samplesPerWindow,\n-            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n-            tsProvider));\n+      final int lookback,\n+      final CommonTaskExecutor taskExecutor) {\n+\n+    this.samplesPerWindow = samplesPerWindow;\n+    samplesBudget = samplesPerWindow + CARRIED_OVER_BUDGET_LOOK_BACK * samplesPerWindow;\n+    emaAlpha = computeIntervalAlpha(lookback);\n+    budgetAlpha = computeIntervalAlpha(CARRIED_OVER_BUDGET_LOOK_BACK);\n+    countsRef = new AtomicReference<>(new Counts());\n+\n+    taskExecutor.scheduleAtFixedRate(\n+        RollWindowTask.INSTANCE,\n+        this,\n+        windowDuration.toNanos(),\n+        windowDuration.toNanos(),\n+        TimeUnit.NANOSECONDS,\n+        \"exception sampling window roll\");\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, CommonTaskExecutor.INSTANCE);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYxOTAyNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398619024", "bodyText": "naming of all three variables here could really use some improvement - I'm not sure I can really follow intent here", "author": "mar-kolya", "createdAt": "2020-03-26T14:32:01Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;", "originalCommit": "e5346fc729bb847e5cf1c704581328b3a368d44d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYyOTAxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398629019", "bodyText": "Also, if Im reading intent correctly here you would want Math.abs", "author": "mar-kolya", "createdAt": "2020-03-26T14:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYxOTAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NzAwOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r399297009", "bodyText": "Fixed", "author": "jbachorik", "createdAt": "2020-03-27T14:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYxOTAyNA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\nindex c87bde1f70..ae07ea9d48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n\n@@ -1,116 +1,490 @@\n package com.datadog.profiling.exceptions;\n \n+import static java.lang.Math.abs;\n+import static java.lang.Math.round;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Supplier;\n-import java.util.stream.Stream;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n \n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n class StreamingSamplerTest {\n-  private static final class TimestampProvider implements Supplier<Long> {\n-    private final Random rnd = new Random();\n-    private final AtomicLong ts = new AtomicLong(0L);\n-    private final int step;\n-    private final double stdDev;\n-\n-    TimestampProvider(\n-        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n-      final long totalDuration =\n-          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n-      step =\n-          (int)\n-              TimeUnit.MILLISECONDS.convert(\n-                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n-      this.stdDev = stdDev;\n+\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n+\n+  /** Generates windows with numbers of events according to Poisson distribution */\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  /**\n+   * Generates bursty windows - some of the windows have extremely low number of events while the\n+   * others have very hight number of events.\n+   */\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    /**\n+     * @param burstProbability the probability of burst window happening\n+     * @param nonBurstEvents number of events in non-burst window\n+     * @param burstEvents number of events in burst window\n+     */\n+    BurstingWindowsEventsSupplier(\n+        final double burstProbability, final int nonBurstEvents, final int burstEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = nonBurstEvents;\n+      this.maxEvents = burstEvents;\n     }\n \n     @Override\n-    public Long get() {\n-      final double diff =\n-          Math.max(\n-              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n-              1); // at least 1ns progress\n-      return ts.getAndAdd(Math.round(diff));\n-    }\n-  }\n-\n-  @ParameterizedTest(name = \"{index}\")\n-  @MethodSource(\"samplerParams\")\n-  void sample(\n-      final int threadCnt,\n-      final int windowDuration,\n-      final int samplesPerWindow,\n-      final int totalWindows,\n-      final int hits,\n-      final double clockStdDev)\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  /** Generates windows with constant number of events. */\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    /** @param events number of events per window */\n+    ConstantWindowsEventsSupplier(final int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  /** Generates a pre-configured repeating sequence of window events */\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    /** @param windowEvents an array of number of events per each window in the sequence */\n+    RepeatingWindowsEventsSupplier(final int... windowEvents) {\n+      this.eventsCounts = Arrays.copyOf(windowEvents, windowEvents.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static class WindowSamplingResult {\n+    final int events;\n+    final int samples;\n+    final double sampleIndexSkew;\n+\n+    WindowSamplingResult(int events, int samples, double sampleIndexSkew) {\n+      this.events = events;\n+      this.samples = samples;\n+      this.sampleIndexSkew = sampleIndexSkew;\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+  private static final int WINDOWS = 120;\n+  private static final int SAMPLES_PER_WINDOW = 100;\n+  private static final int LOOKBACK = 30;\n+\n+  @Mock CommonTaskExecutor taskExecutor;\n+  @Captor ArgumentCaptor<Task<StreamingSampler>> rollWindowTaskCaptor;\n+  @Captor ArgumentCaptor<StreamingSampler> rollWindowTargetCaptor;\n+  @Mock ScheduledFuture scheduledFuture;\n+\n+  @BeforeEach\n+  public void setup() {\n+    when(taskExecutor.scheduleAtFixedRate(\n+            rollWindowTaskCaptor.capture(),\n+            rollWindowTargetCaptor.capture(),\n+            eq(WINDOW_DURATION.toNanos()),\n+            eq(WINDOW_DURATION.toNanos()),\n+            same(TimeUnit.NANOSECONDS),\n+            any()))\n+        .thenReturn(scheduledFuture);\n+  }\n+\n+  @Test\n+  public void testBurstLowProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.1d, 5, 5000), 40);\n+  }\n+\n+  @Test\n+  public void testBurstHighProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.8d, 5, 5000), 20);\n+  }\n+\n+  @Test\n+  public void testPoissonLowFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonMidFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(283), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonHighFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(1013), 15);\n+  }\n+\n+  @Test\n+  public void testConstantVeryLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(1), 10);\n+  }\n+\n+  @Test\n+  public void testConstantLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testConstantMediumLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(713), 15);\n+  }\n+\n+  @Test\n+  public void testConstantHighLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(5211), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingSemiRandom() throws Exception {\n+    testSampler(\n+        new RepeatingWindowsEventsSupplier(180, 200, 0, 0, 0, 1500, 1000, 430, 200, 115, 115, 900),\n+        15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithBurst() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(1000, 0, 1000, 0, 1000, 0), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithLow() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(0, 1000, 0, 1000, 0, 1000), 15);\n+  }\n+\n+  private void testSampler(final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent)\n       throws Exception {\n+    int iterations =\n+        Integer.parseInt(\n+            System.getProperty(\"com.datadog.profiling.exceptions.test-iterations\", \"1\"));\n+    for (int i = 0; i < iterations; i++) {\n+      testSamplerInline(windowEventsSupplier, maxErrorPercent);\n+      for (int numOfThreads = 1; numOfThreads <= 64; numOfThreads *= 2) {\n+        testSamplerConcurrently(numOfThreads, windowEventsSupplier, maxErrorPercent);\n+      }\n+    }\n+  }\n+\n+  private void testSamplerInline(\n+      final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent) {\n+    log.info(\n+        \"> mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}%\",\n+        windowEventsSupplier, WINDOWS, SAMPLES_PER_WINDOW, LOOKBACK, maxErrorPercent);\n+    final StreamingSampler sampler =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    // simulate event generation and sampling for the given number of sampling windows\n+    final long expectedSamples = WINDOWS * SAMPLES_PER_WINDOW;\n+\n+    long allSamples = 0L;\n+    long allEvents = 0L;\n+\n+    final double[] samplesPerWindow = new double[WINDOWS];\n+    final double[] sampleIndexSkewPerWindow = new double[WINDOWS];\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final long samplesBase = 0L;\n+      WindowSamplingResult result = generateWindowEventsAndSample(windowEventsSupplier, sampler);\n+      samplesPerWindow[w] =\n+          (1 - abs((result.samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+      sampleIndexSkewPerWindow[w] = result.sampleIndexSkew;\n+      allSamples += result.samples;\n+      allEvents += result.events;\n+\n+      rollWindow();\n+    }\n+\n+    /*\n+     * Turn all events into samples if their number is <= than the expected number of samples.\n+     */\n+    final double targetSamples = Math.min(allEvents, expectedSamples);\n+\n+    /*\n+     * Calculate the percentual error based on the expected and the observed number of samples.\n+     */\n+    final double percentualError = round(((targetSamples - allSamples) / targetSamples) * 100);\n+\n+    reportSampleStatistics(samplesPerWindow, targetSamples, percentualError);\n+    reportSampleIndexSkew(sampleIndexSkewPerWindow);\n+\n+    assertTrue(\n+        abs(percentualError) <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + allSamples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n \n-    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n-    final TimestampProvider tsProvider =\n-        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n-    final StreamingSampler instance =\n-        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n-          @Override\n-          protected void onWindowRoll(final SamplerState state) {\n-            windowCounter.incrementAndGet();\n-          }\n-        };\n-\n-    final AtomicInteger allCnt = new AtomicInteger(0);\n-    final Thread[] threads = new Thread[threadCnt];\n-    System.out.println(\n-        \"==> windows: \"\n-            + totalWindows\n-            + \", threads: \"\n-            + threadCnt\n-            + \", clockDev: \"\n-            + clockStdDev\n-            + \", samplesPerWindow: \"\n-            + samplesPerWindow);\n-    for (int j = 0; j < threads.length; j++) {\n-      threads[j] =\n-          new Thread(\n-              () -> {\n-                int cnt = 0;\n-                for (long i = 0; i < hits; i++) {\n-                  if (instance.sample()) {\n-                    cnt += 1;\n-                  }\n-                }\n-                allCnt.addAndGet(cnt);\n-              });\n-      threads[j].start();\n-    }\n-    for (final Thread thread : threads) {\n-      thread.join();\n-    }\n-    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n-    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n-    System.out.println();\n-    final double dev = perWindow - samplesPerWindow;\n-    Assertions.assertTrue(\n-        dev <= 0.2d * samplesPerWindow,\n-        allCnt.get() + \" <= (\" + samplesPerWindow + \" * \" + totalWindows + \") [\" + threadCnt + ']');\n-  }\n-\n-  private static Stream<Arguments> samplerParams() {\n-    final List<Arguments> args = new ArrayList<>();\n-    for (int threadCnt = 1; threadCnt < 64; threadCnt *= 2) {\n-      for (int windows = 1; windows <= 16; windows *= 2) {\n-        for (int samples = 5; samples <= 40; samples *= 2) {\n-          args.add(Arguments.of(threadCnt, 10, samples * 10, windows, 511, 0.001d));\n-          args.add(Arguments.of(threadCnt, 10, samples, windows, 511, 0.5d));\n-          args.add(Arguments.of(threadCnt, 10, samples, windows, 511, 1d));\n-        }\n+  private void reportSampleStatistics(\n+      double[] samplesPerWindow, double targetSamples, double percentualError) {\n+    final double samplesPerWindowMean = MEAN.evaluate(samplesPerWindow);\n+    final double samplesPerWindowStdev =\n+        STANDARD_DEVIATION.evaluate(samplesPerWindow, samplesPerWindowMean);\n+\n+    log.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {})\",\n+        samplesPerWindowMean,\n+        samplesPerWindowStdev,\n+        targetSamples);\n+\n+    log.info(\"\\t percentual error = {}%\", percentualError);\n+  }\n+\n+  private void reportSampleIndexSkew(double[] sampleIndexSkewPerWindow) {\n+    Pair<Double, Double> skewIndicators = calculateSkewIndicators(sampleIndexSkewPerWindow);\n+    log.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        round(skewIndicators.getFirst() * 100), round(skewIndicators.getSecond() * 100));\n+  }\n+\n+  /**\n+   * Simulate the number of events per window. Perform sampling and capture the number of observed\n+   * events and samples.\n+   *\n+   * @param windowEventsSupplier events generator implementation\n+   * @param sampler sampler instance\n+   * @return a {@linkplain WindowSamplingResult} instance capturing the number of observed events,\n+   *     samples and the sample index skew\n+   */\n+  private WindowSamplingResult generateWindowEventsAndSample(\n+      Supplier<Integer> windowEventsSupplier, StreamingSampler sampler) {\n+    List<Integer> sampleIndices = new ArrayList<>();\n+    int samples = 0;\n+    int events = windowEventsSupplier.get();\n+    for (int i = 0; i < events; i++) {\n+      if (sampler.sample()) {\n+        sampleIndices.add(i);\n+        samples++;\n       }\n     }\n-    return args.stream();\n+    double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+    double sampleIndexSkew = events != 0 ? sampleIndexMean / events : 0;\n+    return new WindowSamplingResult(events, samples, sampleIndexSkew);\n+  }\n+\n+  /**\n+   * Calculate the sample index skew boundaries. A 'sample index skew' is defined as the distance of\n+   * the average sample index in each window from the mean event index in the same window. Given the\n+   * range of the event indices 1..N, the event index mean M calculated as (N - 1)/2 and the sample\n+   * index mean S the skew K is calculated as 'K = M - S'. This gives the skew range of &lt;-0.5,\n+   * 0.5&gt;.\n+   *\n+   * <p>If the samples are spread out completely regularly the skew would be 0. If the beginning of\n+   * the window is favored the skew would be negative and if the tail of the window is favored the\n+   * skew would be positive.\n+   *\n+   * @param sampleIndexSkewPerWindow the index skew per window\n+   * @return a min-max boundaries for the sample index skew\n+   */\n+  private Pair<Double, Double> calculateSkewIndicators(double[] sampleIndexSkewPerWindow) {\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (final double skew : sampleIndexSkewPerWindow) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    final int positiveCount = sampleIndexSkewPerWindow.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkewPerWindow.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+    return new Pair<>(skewNegativeAvg, skewPositiveAvg);\n+  }\n+\n+  private static double[] toDoubleArray(final List<? extends Number> data) {\n+    return data.stream().mapToDouble(Number::doubleValue).toArray();\n+  }\n+\n+  private void testSamplerConcurrently(\n+      final int threadCount,\n+      final Supplier<Integer> windowEventsSupplier,\n+      final int maxErrorPercent)\n+      throws Exception {\n+    log.info(\n+        \"> threads: {}, mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        WINDOWS,\n+        SAMPLES_PER_WINDOW,\n+        LOOKBACK,\n+        maxErrorPercent);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+    final long expectedSamples = SAMPLES_PER_WINDOW * WINDOWS;\n+    final AtomicLong allSamples = new AtomicLong(0);\n+    final AtomicLong receivedEvents = new AtomicLong(0);\n+\n+    final StreamingSampler sampler =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final Thread[] threads = new Thread[threadCount];\n+      for (int i = 0; i < threadCount; i++) {\n+        threads[i] =\n+            new Thread(\n+                () -> {\n+                  WindowSamplingResult samplingResult =\n+                      generateWindowEventsAndSample(windowEventsSupplier, sampler);\n+                  allSamples.addAndGet(samplingResult.samples);\n+                  receivedEvents.addAndGet(samplingResult.events);\n+                });\n+      }\n+\n+      for (final Thread t : threads) {\n+        t.start();\n+      }\n+      for (final Thread t : threads) {\n+        t.join();\n+      }\n+      rollWindow();\n+    }\n+\n+    final long samples = allSamples.get();\n+    /*\n+     * Turn all events into samples if their number is <= than the expected number of samples.\n+     */\n+    final long targetSamples = Math.min(expectedSamples, receivedEvents.get());\n+    /*\n+     * Calculate the percentual error based on the expected and the observed number of samples.\n+     */\n+    final int percentualError = round(((targetSamples - samples) / (float) targetSamples) * 100);\n+    log.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        abs(percentualError) <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private void rollWindow() {\n+    rollWindowTaskCaptor.getValue().run(rollWindowTargetCaptor.getValue());\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMjkzMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398632933", "bodyText": "Message should provide an easy insight into what had failed - currently calculation in the message is very different from calculation in the test meaning that when things fail we do not see how far off we are", "author": "mar-kolya", "createdAt": "2020-03-26T14:49:59Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;\n+    Assertions.assertTrue(\n+        dev <= 0.2d * samplesPerWindow,\n+        allCnt.get() + \" <= (\" + samplesPerWindow + \" * \" + totalWindows + \") [\" + threadCnt + ']');", "originalCommit": "e5346fc729bb847e5cf1c704581328b3a368d44d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NzE0OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r399297148", "bodyText": "Message changed", "author": "jbachorik", "createdAt": "2020-03-27T14:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMjkzMw=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\nindex c87bde1f70..ae07ea9d48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n\n@@ -1,116 +1,490 @@\n package com.datadog.profiling.exceptions;\n \n+import static java.lang.Math.abs;\n+import static java.lang.Math.round;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Supplier;\n-import java.util.stream.Stream;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n \n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n class StreamingSamplerTest {\n-  private static final class TimestampProvider implements Supplier<Long> {\n-    private final Random rnd = new Random();\n-    private final AtomicLong ts = new AtomicLong(0L);\n-    private final int step;\n-    private final double stdDev;\n-\n-    TimestampProvider(\n-        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n-      final long totalDuration =\n-          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n-      step =\n-          (int)\n-              TimeUnit.MILLISECONDS.convert(\n-                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n-      this.stdDev = stdDev;\n+\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n+\n+  /** Generates windows with numbers of events according to Poisson distribution */\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  /**\n+   * Generates bursty windows - some of the windows have extremely low number of events while the\n+   * others have very hight number of events.\n+   */\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    /**\n+     * @param burstProbability the probability of burst window happening\n+     * @param nonBurstEvents number of events in non-burst window\n+     * @param burstEvents number of events in burst window\n+     */\n+    BurstingWindowsEventsSupplier(\n+        final double burstProbability, final int nonBurstEvents, final int burstEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = nonBurstEvents;\n+      this.maxEvents = burstEvents;\n     }\n \n     @Override\n-    public Long get() {\n-      final double diff =\n-          Math.max(\n-              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n-              1); // at least 1ns progress\n-      return ts.getAndAdd(Math.round(diff));\n-    }\n-  }\n-\n-  @ParameterizedTest(name = \"{index}\")\n-  @MethodSource(\"samplerParams\")\n-  void sample(\n-      final int threadCnt,\n-      final int windowDuration,\n-      final int samplesPerWindow,\n-      final int totalWindows,\n-      final int hits,\n-      final double clockStdDev)\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  /** Generates windows with constant number of events. */\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    /** @param events number of events per window */\n+    ConstantWindowsEventsSupplier(final int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  /** Generates a pre-configured repeating sequence of window events */\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    /** @param windowEvents an array of number of events per each window in the sequence */\n+    RepeatingWindowsEventsSupplier(final int... windowEvents) {\n+      this.eventsCounts = Arrays.copyOf(windowEvents, windowEvents.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static class WindowSamplingResult {\n+    final int events;\n+    final int samples;\n+    final double sampleIndexSkew;\n+\n+    WindowSamplingResult(int events, int samples, double sampleIndexSkew) {\n+      this.events = events;\n+      this.samples = samples;\n+      this.sampleIndexSkew = sampleIndexSkew;\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+  private static final int WINDOWS = 120;\n+  private static final int SAMPLES_PER_WINDOW = 100;\n+  private static final int LOOKBACK = 30;\n+\n+  @Mock CommonTaskExecutor taskExecutor;\n+  @Captor ArgumentCaptor<Task<StreamingSampler>> rollWindowTaskCaptor;\n+  @Captor ArgumentCaptor<StreamingSampler> rollWindowTargetCaptor;\n+  @Mock ScheduledFuture scheduledFuture;\n+\n+  @BeforeEach\n+  public void setup() {\n+    when(taskExecutor.scheduleAtFixedRate(\n+            rollWindowTaskCaptor.capture(),\n+            rollWindowTargetCaptor.capture(),\n+            eq(WINDOW_DURATION.toNanos()),\n+            eq(WINDOW_DURATION.toNanos()),\n+            same(TimeUnit.NANOSECONDS),\n+            any()))\n+        .thenReturn(scheduledFuture);\n+  }\n+\n+  @Test\n+  public void testBurstLowProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.1d, 5, 5000), 40);\n+  }\n+\n+  @Test\n+  public void testBurstHighProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.8d, 5, 5000), 20);\n+  }\n+\n+  @Test\n+  public void testPoissonLowFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonMidFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(283), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonHighFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(1013), 15);\n+  }\n+\n+  @Test\n+  public void testConstantVeryLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(1), 10);\n+  }\n+\n+  @Test\n+  public void testConstantLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testConstantMediumLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(713), 15);\n+  }\n+\n+  @Test\n+  public void testConstantHighLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(5211), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingSemiRandom() throws Exception {\n+    testSampler(\n+        new RepeatingWindowsEventsSupplier(180, 200, 0, 0, 0, 1500, 1000, 430, 200, 115, 115, 900),\n+        15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithBurst() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(1000, 0, 1000, 0, 1000, 0), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithLow() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(0, 1000, 0, 1000, 0, 1000), 15);\n+  }\n+\n+  private void testSampler(final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent)\n       throws Exception {\n+    int iterations =\n+        Integer.parseInt(\n+            System.getProperty(\"com.datadog.profiling.exceptions.test-iterations\", \"1\"));\n+    for (int i = 0; i < iterations; i++) {\n+      testSamplerInline(windowEventsSupplier, maxErrorPercent);\n+      for (int numOfThreads = 1; numOfThreads <= 64; numOfThreads *= 2) {\n+        testSamplerConcurrently(numOfThreads, windowEventsSupplier, maxErrorPercent);\n+      }\n+    }\n+  }\n+\n+  private void testSamplerInline(\n+      final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent) {\n+    log.info(\n+        \"> mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}%\",\n+        windowEventsSupplier, WINDOWS, SAMPLES_PER_WINDOW, LOOKBACK, maxErrorPercent);\n+    final StreamingSampler sampler =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    // simulate event generation and sampling for the given number of sampling windows\n+    final long expectedSamples = WINDOWS * SAMPLES_PER_WINDOW;\n+\n+    long allSamples = 0L;\n+    long allEvents = 0L;\n+\n+    final double[] samplesPerWindow = new double[WINDOWS];\n+    final double[] sampleIndexSkewPerWindow = new double[WINDOWS];\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final long samplesBase = 0L;\n+      WindowSamplingResult result = generateWindowEventsAndSample(windowEventsSupplier, sampler);\n+      samplesPerWindow[w] =\n+          (1 - abs((result.samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+      sampleIndexSkewPerWindow[w] = result.sampleIndexSkew;\n+      allSamples += result.samples;\n+      allEvents += result.events;\n+\n+      rollWindow();\n+    }\n+\n+    /*\n+     * Turn all events into samples if their number is <= than the expected number of samples.\n+     */\n+    final double targetSamples = Math.min(allEvents, expectedSamples);\n+\n+    /*\n+     * Calculate the percentual error based on the expected and the observed number of samples.\n+     */\n+    final double percentualError = round(((targetSamples - allSamples) / targetSamples) * 100);\n+\n+    reportSampleStatistics(samplesPerWindow, targetSamples, percentualError);\n+    reportSampleIndexSkew(sampleIndexSkewPerWindow);\n+\n+    assertTrue(\n+        abs(percentualError) <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + allSamples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n \n-    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n-    final TimestampProvider tsProvider =\n-        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n-    final StreamingSampler instance =\n-        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n-          @Override\n-          protected void onWindowRoll(final SamplerState state) {\n-            windowCounter.incrementAndGet();\n-          }\n-        };\n-\n-    final AtomicInteger allCnt = new AtomicInteger(0);\n-    final Thread[] threads = new Thread[threadCnt];\n-    System.out.println(\n-        \"==> windows: \"\n-            + totalWindows\n-            + \", threads: \"\n-            + threadCnt\n-            + \", clockDev: \"\n-            + clockStdDev\n-            + \", samplesPerWindow: \"\n-            + samplesPerWindow);\n-    for (int j = 0; j < threads.length; j++) {\n-      threads[j] =\n-          new Thread(\n-              () -> {\n-                int cnt = 0;\n-                for (long i = 0; i < hits; i++) {\n-                  if (instance.sample()) {\n-                    cnt += 1;\n-                  }\n-                }\n-                allCnt.addAndGet(cnt);\n-              });\n-      threads[j].start();\n-    }\n-    for (final Thread thread : threads) {\n-      thread.join();\n-    }\n-    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n-    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n-    System.out.println();\n-    final double dev = perWindow - samplesPerWindow;\n-    Assertions.assertTrue(\n-        dev <= 0.2d * samplesPerWindow,\n-        allCnt.get() + \" <= (\" + samplesPerWindow + \" * \" + totalWindows + \") [\" + threadCnt + ']');\n-  }\n-\n-  private static Stream<Arguments> samplerParams() {\n-    final List<Arguments> args = new ArrayList<>();\n-    for (int threadCnt = 1; threadCnt < 64; threadCnt *= 2) {\n-      for (int windows = 1; windows <= 16; windows *= 2) {\n-        for (int samples = 5; samples <= 40; samples *= 2) {\n-          args.add(Arguments.of(threadCnt, 10, samples * 10, windows, 511, 0.001d));\n-          args.add(Arguments.of(threadCnt, 10, samples, windows, 511, 0.5d));\n-          args.add(Arguments.of(threadCnt, 10, samples, windows, 511, 1d));\n-        }\n+  private void reportSampleStatistics(\n+      double[] samplesPerWindow, double targetSamples, double percentualError) {\n+    final double samplesPerWindowMean = MEAN.evaluate(samplesPerWindow);\n+    final double samplesPerWindowStdev =\n+        STANDARD_DEVIATION.evaluate(samplesPerWindow, samplesPerWindowMean);\n+\n+    log.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {})\",\n+        samplesPerWindowMean,\n+        samplesPerWindowStdev,\n+        targetSamples);\n+\n+    log.info(\"\\t percentual error = {}%\", percentualError);\n+  }\n+\n+  private void reportSampleIndexSkew(double[] sampleIndexSkewPerWindow) {\n+    Pair<Double, Double> skewIndicators = calculateSkewIndicators(sampleIndexSkewPerWindow);\n+    log.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        round(skewIndicators.getFirst() * 100), round(skewIndicators.getSecond() * 100));\n+  }\n+\n+  /**\n+   * Simulate the number of events per window. Perform sampling and capture the number of observed\n+   * events and samples.\n+   *\n+   * @param windowEventsSupplier events generator implementation\n+   * @param sampler sampler instance\n+   * @return a {@linkplain WindowSamplingResult} instance capturing the number of observed events,\n+   *     samples and the sample index skew\n+   */\n+  private WindowSamplingResult generateWindowEventsAndSample(\n+      Supplier<Integer> windowEventsSupplier, StreamingSampler sampler) {\n+    List<Integer> sampleIndices = new ArrayList<>();\n+    int samples = 0;\n+    int events = windowEventsSupplier.get();\n+    for (int i = 0; i < events; i++) {\n+      if (sampler.sample()) {\n+        sampleIndices.add(i);\n+        samples++;\n       }\n     }\n-    return args.stream();\n+    double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+    double sampleIndexSkew = events != 0 ? sampleIndexMean / events : 0;\n+    return new WindowSamplingResult(events, samples, sampleIndexSkew);\n+  }\n+\n+  /**\n+   * Calculate the sample index skew boundaries. A 'sample index skew' is defined as the distance of\n+   * the average sample index in each window from the mean event index in the same window. Given the\n+   * range of the event indices 1..N, the event index mean M calculated as (N - 1)/2 and the sample\n+   * index mean S the skew K is calculated as 'K = M - S'. This gives the skew range of &lt;-0.5,\n+   * 0.5&gt;.\n+   *\n+   * <p>If the samples are spread out completely regularly the skew would be 0. If the beginning of\n+   * the window is favored the skew would be negative and if the tail of the window is favored the\n+   * skew would be positive.\n+   *\n+   * @param sampleIndexSkewPerWindow the index skew per window\n+   * @return a min-max boundaries for the sample index skew\n+   */\n+  private Pair<Double, Double> calculateSkewIndicators(double[] sampleIndexSkewPerWindow) {\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (final double skew : sampleIndexSkewPerWindow) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    final int positiveCount = sampleIndexSkewPerWindow.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkewPerWindow.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+    return new Pair<>(skewNegativeAvg, skewPositiveAvg);\n+  }\n+\n+  private static double[] toDoubleArray(final List<? extends Number> data) {\n+    return data.stream().mapToDouble(Number::doubleValue).toArray();\n+  }\n+\n+  private void testSamplerConcurrently(\n+      final int threadCount,\n+      final Supplier<Integer> windowEventsSupplier,\n+      final int maxErrorPercent)\n+      throws Exception {\n+    log.info(\n+        \"> threads: {}, mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        WINDOWS,\n+        SAMPLES_PER_WINDOW,\n+        LOOKBACK,\n+        maxErrorPercent);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+    final long expectedSamples = SAMPLES_PER_WINDOW * WINDOWS;\n+    final AtomicLong allSamples = new AtomicLong(0);\n+    final AtomicLong receivedEvents = new AtomicLong(0);\n+\n+    final StreamingSampler sampler =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final Thread[] threads = new Thread[threadCount];\n+      for (int i = 0; i < threadCount; i++) {\n+        threads[i] =\n+            new Thread(\n+                () -> {\n+                  WindowSamplingResult samplingResult =\n+                      generateWindowEventsAndSample(windowEventsSupplier, sampler);\n+                  allSamples.addAndGet(samplingResult.samples);\n+                  receivedEvents.addAndGet(samplingResult.events);\n+                });\n+      }\n+\n+      for (final Thread t : threads) {\n+        t.start();\n+      }\n+      for (final Thread t : threads) {\n+        t.join();\n+      }\n+      rollWindow();\n+    }\n+\n+    final long samples = allSamples.get();\n+    /*\n+     * Turn all events into samples if their number is <= than the expected number of samples.\n+     */\n+    final long targetSamples = Math.min(expectedSamples, receivedEvents.get());\n+    /*\n+     * Calculate the percentual error based on the expected and the observed number of samples.\n+     */\n+    final int percentualError = round(((targetSamples - samples) / (float) targetSamples) * 100);\n+    log.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        abs(percentualError) <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private void rollWindow() {\n+    rollWindowTaskCaptor.getValue().run(rollWindowTargetCaptor.getValue());\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzOTUxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398639514", "bodyText": "Using three different time units in same function seems... excessive... especially considering that this is a test.\nWould it make sense to use nanoseconds everywhere? Or maybe even Instant since we are aiming for java8 anyway?", "author": "mar-kolya", "createdAt": "2020-03-26T14:58:16Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(", "originalCommit": "e5346fc729bb847e5cf1c704581328b3a368d44d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\nindex c87bde1f70..ae07ea9d48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n\n@@ -1,116 +1,490 @@\n package com.datadog.profiling.exceptions;\n \n+import static java.lang.Math.abs;\n+import static java.lang.Math.round;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Supplier;\n-import java.util.stream.Stream;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n \n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n class StreamingSamplerTest {\n-  private static final class TimestampProvider implements Supplier<Long> {\n-    private final Random rnd = new Random();\n-    private final AtomicLong ts = new AtomicLong(0L);\n-    private final int step;\n-    private final double stdDev;\n-\n-    TimestampProvider(\n-        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n-      final long totalDuration =\n-          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n-      step =\n-          (int)\n-              TimeUnit.MILLISECONDS.convert(\n-                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n-      this.stdDev = stdDev;\n+\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n+\n+  /** Generates windows with numbers of events according to Poisson distribution */\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  /**\n+   * Generates bursty windows - some of the windows have extremely low number of events while the\n+   * others have very hight number of events.\n+   */\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    /**\n+     * @param burstProbability the probability of burst window happening\n+     * @param nonBurstEvents number of events in non-burst window\n+     * @param burstEvents number of events in burst window\n+     */\n+    BurstingWindowsEventsSupplier(\n+        final double burstProbability, final int nonBurstEvents, final int burstEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = nonBurstEvents;\n+      this.maxEvents = burstEvents;\n     }\n \n     @Override\n-    public Long get() {\n-      final double diff =\n-          Math.max(\n-              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n-              1); // at least 1ns progress\n-      return ts.getAndAdd(Math.round(diff));\n-    }\n-  }\n-\n-  @ParameterizedTest(name = \"{index}\")\n-  @MethodSource(\"samplerParams\")\n-  void sample(\n-      final int threadCnt,\n-      final int windowDuration,\n-      final int samplesPerWindow,\n-      final int totalWindows,\n-      final int hits,\n-      final double clockStdDev)\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  /** Generates windows with constant number of events. */\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    /** @param events number of events per window */\n+    ConstantWindowsEventsSupplier(final int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  /** Generates a pre-configured repeating sequence of window events */\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    /** @param windowEvents an array of number of events per each window in the sequence */\n+    RepeatingWindowsEventsSupplier(final int... windowEvents) {\n+      this.eventsCounts = Arrays.copyOf(windowEvents, windowEvents.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static class WindowSamplingResult {\n+    final int events;\n+    final int samples;\n+    final double sampleIndexSkew;\n+\n+    WindowSamplingResult(int events, int samples, double sampleIndexSkew) {\n+      this.events = events;\n+      this.samples = samples;\n+      this.sampleIndexSkew = sampleIndexSkew;\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+  private static final int WINDOWS = 120;\n+  private static final int SAMPLES_PER_WINDOW = 100;\n+  private static final int LOOKBACK = 30;\n+\n+  @Mock CommonTaskExecutor taskExecutor;\n+  @Captor ArgumentCaptor<Task<StreamingSampler>> rollWindowTaskCaptor;\n+  @Captor ArgumentCaptor<StreamingSampler> rollWindowTargetCaptor;\n+  @Mock ScheduledFuture scheduledFuture;\n+\n+  @BeforeEach\n+  public void setup() {\n+    when(taskExecutor.scheduleAtFixedRate(\n+            rollWindowTaskCaptor.capture(),\n+            rollWindowTargetCaptor.capture(),\n+            eq(WINDOW_DURATION.toNanos()),\n+            eq(WINDOW_DURATION.toNanos()),\n+            same(TimeUnit.NANOSECONDS),\n+            any()))\n+        .thenReturn(scheduledFuture);\n+  }\n+\n+  @Test\n+  public void testBurstLowProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.1d, 5, 5000), 40);\n+  }\n+\n+  @Test\n+  public void testBurstHighProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.8d, 5, 5000), 20);\n+  }\n+\n+  @Test\n+  public void testPoissonLowFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonMidFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(283), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonHighFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(1013), 15);\n+  }\n+\n+  @Test\n+  public void testConstantVeryLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(1), 10);\n+  }\n+\n+  @Test\n+  public void testConstantLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testConstantMediumLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(713), 15);\n+  }\n+\n+  @Test\n+  public void testConstantHighLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(5211), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingSemiRandom() throws Exception {\n+    testSampler(\n+        new RepeatingWindowsEventsSupplier(180, 200, 0, 0, 0, 1500, 1000, 430, 200, 115, 115, 900),\n+        15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithBurst() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(1000, 0, 1000, 0, 1000, 0), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithLow() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(0, 1000, 0, 1000, 0, 1000), 15);\n+  }\n+\n+  private void testSampler(final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent)\n       throws Exception {\n+    int iterations =\n+        Integer.parseInt(\n+            System.getProperty(\"com.datadog.profiling.exceptions.test-iterations\", \"1\"));\n+    for (int i = 0; i < iterations; i++) {\n+      testSamplerInline(windowEventsSupplier, maxErrorPercent);\n+      for (int numOfThreads = 1; numOfThreads <= 64; numOfThreads *= 2) {\n+        testSamplerConcurrently(numOfThreads, windowEventsSupplier, maxErrorPercent);\n+      }\n+    }\n+  }\n+\n+  private void testSamplerInline(\n+      final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent) {\n+    log.info(\n+        \"> mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}%\",\n+        windowEventsSupplier, WINDOWS, SAMPLES_PER_WINDOW, LOOKBACK, maxErrorPercent);\n+    final StreamingSampler sampler =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    // simulate event generation and sampling for the given number of sampling windows\n+    final long expectedSamples = WINDOWS * SAMPLES_PER_WINDOW;\n+\n+    long allSamples = 0L;\n+    long allEvents = 0L;\n+\n+    final double[] samplesPerWindow = new double[WINDOWS];\n+    final double[] sampleIndexSkewPerWindow = new double[WINDOWS];\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final long samplesBase = 0L;\n+      WindowSamplingResult result = generateWindowEventsAndSample(windowEventsSupplier, sampler);\n+      samplesPerWindow[w] =\n+          (1 - abs((result.samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+      sampleIndexSkewPerWindow[w] = result.sampleIndexSkew;\n+      allSamples += result.samples;\n+      allEvents += result.events;\n+\n+      rollWindow();\n+    }\n+\n+    /*\n+     * Turn all events into samples if their number is <= than the expected number of samples.\n+     */\n+    final double targetSamples = Math.min(allEvents, expectedSamples);\n+\n+    /*\n+     * Calculate the percentual error based on the expected and the observed number of samples.\n+     */\n+    final double percentualError = round(((targetSamples - allSamples) / targetSamples) * 100);\n+\n+    reportSampleStatistics(samplesPerWindow, targetSamples, percentualError);\n+    reportSampleIndexSkew(sampleIndexSkewPerWindow);\n+\n+    assertTrue(\n+        abs(percentualError) <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + allSamples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n \n-    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n-    final TimestampProvider tsProvider =\n-        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n-    final StreamingSampler instance =\n-        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n-          @Override\n-          protected void onWindowRoll(final SamplerState state) {\n-            windowCounter.incrementAndGet();\n-          }\n-        };\n-\n-    final AtomicInteger allCnt = new AtomicInteger(0);\n-    final Thread[] threads = new Thread[threadCnt];\n-    System.out.println(\n-        \"==> windows: \"\n-            + totalWindows\n-            + \", threads: \"\n-            + threadCnt\n-            + \", clockDev: \"\n-            + clockStdDev\n-            + \", samplesPerWindow: \"\n-            + samplesPerWindow);\n-    for (int j = 0; j < threads.length; j++) {\n-      threads[j] =\n-          new Thread(\n-              () -> {\n-                int cnt = 0;\n-                for (long i = 0; i < hits; i++) {\n-                  if (instance.sample()) {\n-                    cnt += 1;\n-                  }\n-                }\n-                allCnt.addAndGet(cnt);\n-              });\n-      threads[j].start();\n-    }\n-    for (final Thread thread : threads) {\n-      thread.join();\n-    }\n-    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n-    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n-    System.out.println();\n-    final double dev = perWindow - samplesPerWindow;\n-    Assertions.assertTrue(\n-        dev <= 0.2d * samplesPerWindow,\n-        allCnt.get() + \" <= (\" + samplesPerWindow + \" * \" + totalWindows + \") [\" + threadCnt + ']');\n-  }\n-\n-  private static Stream<Arguments> samplerParams() {\n-    final List<Arguments> args = new ArrayList<>();\n-    for (int threadCnt = 1; threadCnt < 64; threadCnt *= 2) {\n-      for (int windows = 1; windows <= 16; windows *= 2) {\n-        for (int samples = 5; samples <= 40; samples *= 2) {\n-          args.add(Arguments.of(threadCnt, 10, samples * 10, windows, 511, 0.001d));\n-          args.add(Arguments.of(threadCnt, 10, samples, windows, 511, 0.5d));\n-          args.add(Arguments.of(threadCnt, 10, samples, windows, 511, 1d));\n-        }\n+  private void reportSampleStatistics(\n+      double[] samplesPerWindow, double targetSamples, double percentualError) {\n+    final double samplesPerWindowMean = MEAN.evaluate(samplesPerWindow);\n+    final double samplesPerWindowStdev =\n+        STANDARD_DEVIATION.evaluate(samplesPerWindow, samplesPerWindowMean);\n+\n+    log.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {})\",\n+        samplesPerWindowMean,\n+        samplesPerWindowStdev,\n+        targetSamples);\n+\n+    log.info(\"\\t percentual error = {}%\", percentualError);\n+  }\n+\n+  private void reportSampleIndexSkew(double[] sampleIndexSkewPerWindow) {\n+    Pair<Double, Double> skewIndicators = calculateSkewIndicators(sampleIndexSkewPerWindow);\n+    log.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        round(skewIndicators.getFirst() * 100), round(skewIndicators.getSecond() * 100));\n+  }\n+\n+  /**\n+   * Simulate the number of events per window. Perform sampling and capture the number of observed\n+   * events and samples.\n+   *\n+   * @param windowEventsSupplier events generator implementation\n+   * @param sampler sampler instance\n+   * @return a {@linkplain WindowSamplingResult} instance capturing the number of observed events,\n+   *     samples and the sample index skew\n+   */\n+  private WindowSamplingResult generateWindowEventsAndSample(\n+      Supplier<Integer> windowEventsSupplier, StreamingSampler sampler) {\n+    List<Integer> sampleIndices = new ArrayList<>();\n+    int samples = 0;\n+    int events = windowEventsSupplier.get();\n+    for (int i = 0; i < events; i++) {\n+      if (sampler.sample()) {\n+        sampleIndices.add(i);\n+        samples++;\n       }\n     }\n-    return args.stream();\n+    double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+    double sampleIndexSkew = events != 0 ? sampleIndexMean / events : 0;\n+    return new WindowSamplingResult(events, samples, sampleIndexSkew);\n+  }\n+\n+  /**\n+   * Calculate the sample index skew boundaries. A 'sample index skew' is defined as the distance of\n+   * the average sample index in each window from the mean event index in the same window. Given the\n+   * range of the event indices 1..N, the event index mean M calculated as (N - 1)/2 and the sample\n+   * index mean S the skew K is calculated as 'K = M - S'. This gives the skew range of &lt;-0.5,\n+   * 0.5&gt;.\n+   *\n+   * <p>If the samples are spread out completely regularly the skew would be 0. If the beginning of\n+   * the window is favored the skew would be negative and if the tail of the window is favored the\n+   * skew would be positive.\n+   *\n+   * @param sampleIndexSkewPerWindow the index skew per window\n+   * @return a min-max boundaries for the sample index skew\n+   */\n+  private Pair<Double, Double> calculateSkewIndicators(double[] sampleIndexSkewPerWindow) {\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (final double skew : sampleIndexSkewPerWindow) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    final int positiveCount = sampleIndexSkewPerWindow.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkewPerWindow.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+    return new Pair<>(skewNegativeAvg, skewPositiveAvg);\n+  }\n+\n+  private static double[] toDoubleArray(final List<? extends Number> data) {\n+    return data.stream().mapToDouble(Number::doubleValue).toArray();\n+  }\n+\n+  private void testSamplerConcurrently(\n+      final int threadCount,\n+      final Supplier<Integer> windowEventsSupplier,\n+      final int maxErrorPercent)\n+      throws Exception {\n+    log.info(\n+        \"> threads: {}, mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        WINDOWS,\n+        SAMPLES_PER_WINDOW,\n+        LOOKBACK,\n+        maxErrorPercent);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+    final long expectedSamples = SAMPLES_PER_WINDOW * WINDOWS;\n+    final AtomicLong allSamples = new AtomicLong(0);\n+    final AtomicLong receivedEvents = new AtomicLong(0);\n+\n+    final StreamingSampler sampler =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final Thread[] threads = new Thread[threadCount];\n+      for (int i = 0; i < threadCount; i++) {\n+        threads[i] =\n+            new Thread(\n+                () -> {\n+                  WindowSamplingResult samplingResult =\n+                      generateWindowEventsAndSample(windowEventsSupplier, sampler);\n+                  allSamples.addAndGet(samplingResult.samples);\n+                  receivedEvents.addAndGet(samplingResult.events);\n+                });\n+      }\n+\n+      for (final Thread t : threads) {\n+        t.start();\n+      }\n+      for (final Thread t : threads) {\n+        t.join();\n+      }\n+      rollWindow();\n+    }\n+\n+    final long samples = allSamples.get();\n+    /*\n+     * Turn all events into samples if their number is <= than the expected number of samples.\n+     */\n+    final long targetSamples = Math.min(expectedSamples, receivedEvents.get());\n+    /*\n+     * Calculate the percentual error based on the expected and the observed number of samples.\n+     */\n+    final int percentualError = round(((targetSamples - samples) / (float) targetSamples) * 100);\n+    log.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        abs(percentualError) <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private void rollWindow() {\n+    rollWindowTaskCaptor.getValue().run(rollWindowTargetCaptor.getValue());\n   }\n }\n"}}, {"oid": "50a817811d66aadfa0201924a73d66ff514c2fca", "url": "https://github.com/DataDog/dd-trace-java/commit/50a817811d66aadfa0201924a73d66ff514c2fca", "message": "Clean up unused code", "committedDate": "2020-03-27T12:11:23Z", "type": "commit"}, {"oid": "a580fc157aa71fe9ab6650fa0dcb562ed213470a", "url": "https://github.com/DataDog/dd-trace-java/commit/a580fc157aa71fe9ab6650fa0dcb562ed213470a", "message": "Change compatibility", "committedDate": "2020-03-27T12:11:42Z", "type": "commit"}, {"oid": "6879c0fc1ab030a63bfed827980cb9d56711bbb3", "url": "https://github.com/DataDog/dd-trace-java/commit/6879c0fc1ab030a63bfed827980cb9d56711bbb3", "message": "A complete change in the sampler implementation.\nUsing adaptive interval with random jitter to provide the required guarantees about the total number of samples per certain time.", "committedDate": "2020-03-27T12:13:21Z", "type": "commit"}, {"oid": "415ccd9599a377e671848a9bc548c52e8ff78db7", "url": "https://github.com/DataDog/dd-trace-java/commit/415ccd9599a377e671848a9bc548c52e8ff78db7", "message": "Use Duration instead of a combination of a number and TimeUnit", "committedDate": "2020-03-27T14:33:22Z", "type": "commit"}, {"oid": "0371c85e886731376f0f135acd48d23e7021e6b2", "url": "https://github.com/DataDog/dd-trace-java/commit/0371c85e886731376f0f135acd48d23e7021e6b2", "message": "Remove non-existent helper class", "committedDate": "2020-03-27T14:53:20Z", "type": "commit"}, {"oid": "6fafac3714934c1aae2da7600948436b735c909f", "url": "https://github.com/DataDog/dd-trace-java/commit/6fafac3714934c1aae2da7600948436b735c909f", "message": "Replace synchronized block with try-lock", "committedDate": "2020-03-27T16:05:21Z", "type": "commit"}, {"oid": "8c6a0d77ec696a4cde1f274ff315f5bad159203a", "url": "https://github.com/DataDog/dd-trace-java/commit/8c6a0d77ec696a4cde1f274ff315f5bad159203a", "message": "Make gradle happier", "committedDate": "2020-03-27T18:13:45Z", "type": "commit"}, {"oid": "67e846f01f262299fa68a653d06d222e7f2bd258", "url": "https://github.com/DataDog/dd-trace-java/commit/67e846f01f262299fa68a653d06d222e7f2bd258", "message": "Some WIP on sampler\n\nJust ideas, not ready to use", "committedDate": "2020-03-30T00:18:59Z", "type": "commit"}, {"oid": "35cc75bfe0d0293dff66d5fb5cf62b56424cd222", "url": "https://github.com/DataDog/dd-trace-java/commit/35cc75bfe0d0293dff66d5fb5cf62b56424cd222", "message": "Improve uniform sampler\n\nAdd idea of 'budget' from previous windows to reduce amount of\nclamping.\nMake uniform samper 'default'.", "committedDate": "2020-03-30T13:39:20Z", "type": "commit"}, {"oid": "04bc9d349e6ad2ddc71839596290e34b9510b4b6", "url": "https://github.com/DataDog/dd-trace-java/commit/04bc9d349e6ad2ddc71839596290e34b9510b4b6", "message": "Follow-up changes to exception profiling", "committedDate": "2020-03-30T17:24:13Z", "type": "commit"}, {"oid": "b5cad9715de5045bc4a40d7fe8aa4654b10e20f2", "url": "https://github.com/DataDog/dd-trace-java/commit/b5cad9715de5045bc4a40d7fe8aa4654b10e20f2", "message": "Fix codenarc violations", "committedDate": "2020-03-31T13:58:58Z", "type": "commit"}, {"oid": "0c7141b7c51d1a7626932706523a065320154c45", "url": "https://github.com/DataDog/dd-trace-java/commit/0c7141b7c51d1a7626932706523a065320154c45", "message": "Add exponential timestamp provider", "committedDate": "2020-03-31T14:00:04Z", "type": "commit"}, {"oid": "38dc8ca0462293f2f3f3622da692805b865e1b17", "url": "https://github.com/DataDog/dd-trace-java/commit/38dc8ca0462293f2f3f3622da692805b865e1b17", "message": "Simplify EMA calculation", "committedDate": "2020-03-31T14:00:28Z", "type": "commit"}, {"oid": "e5c6fed2903713620a6998d297039c7ae51cadfc", "url": "https://github.com/DataDog/dd-trace-java/commit/e5c6fed2903713620a6998d297039c7ae51cadfc", "message": "Tune the budgeting to provide better error margins", "committedDate": "2020-04-01T14:24:50Z", "type": "commit"}, {"oid": "2547c8389a72a876a82f7649325a5908da37f935", "url": "https://github.com/DataDog/dd-trace-java/commit/2547c8389a72a876a82f7649325a5908da37f935", "message": "Clean up the EMA for budget.\nRemove the cut-off test and leave it for later.", "committedDate": "2020-04-01T17:46:10Z", "type": "commit"}, {"oid": "6c4d3ce0c18f1878d146df867980bd926130488c", "url": "https://github.com/DataDog/dd-trace-java/commit/6c4d3ce0c18f1878d146df867980bd926130488c", "message": "Allow specifying target lookback for sampler", "committedDate": "2020-04-02T11:41:29Z", "type": "commit"}, {"oid": "d326004bf642c19bb5539c31ce4c8d2fde709622", "url": "https://github.com/DataDog/dd-trace-java/commit/d326004bf642c19bb5539c31ce4c8d2fde709622", "message": "Increase the number of retries for intermittent test failures", "committedDate": "2020-04-03T13:29:19Z", "type": "commit"}, {"oid": "7ac450113ffc9c271047ae7fe578ab7e31ebb1d8", "url": "https://github.com/DataDog/dd-trace-java/commit/7ac450113ffc9c271047ae7fe578ab7e31ebb1d8", "message": "Rework sampler implementation to use a separate window maintenance thread", "committedDate": "2020-04-07T18:54:20Z", "type": "commit"}, {"oid": "375864eddd9eada9a34fe0bf2f1281cbf8337fab", "url": "https://github.com/DataDog/dd-trace-java/commit/375864eddd9eada9a34fe0bf2f1281cbf8337fab", "message": "Merge remote-tracking branch 'origin/master' into jb/PROF-581_exceptions_sampler\n\n# Conflicts:\n#\tdd-trace-api/src/main/java/datadog/trace/api/Config.java", "committedDate": "2020-04-08T09:04:09Z", "type": "commit"}, {"oid": "e51c1486c229f62ddf5b35a3ef05ce9f4963e57e", "url": "https://github.com/DataDog/dd-trace-java/commit/e51c1486c229f62ddf5b35a3ef05ce9f4963e57e", "message": "Rename sampler limit config option.\nAlso remove other unused sampler options.", "committedDate": "2020-04-08T09:09:27Z", "type": "commit"}, {"oid": "e1befa547207ff63fe6b07c2c4163f3afd4f6ec0", "url": "https://github.com/DataDog/dd-trace-java/commit/e1befa547207ff63fe6b07c2c4163f3afd4f6ec0", "message": "Use custom Pair class instead of Map.Entry", "committedDate": "2020-04-08T09:12:20Z", "type": "commit"}, {"oid": "f8fd519e8d17b88aff942ffa0dec0f008a84aea0", "url": "https://github.com/DataDog/dd-trace-java/commit/f8fd519e8d17b88aff942ffa0dec0f008a84aea0", "message": "Make ExceptionInstrumentation final", "committedDate": "2020-04-08T09:13:09Z", "type": "commit"}, {"oid": "4500f989783a5fbabca54b3211880a0d2041711b", "url": "https://github.com/DataDog/dd-trace-java/commit/4500f989783a5fbabca54b3211880a0d2041711b", "message": "Improve javadoc location", "committedDate": "2020-04-08T09:13:32Z", "type": "commit"}, {"oid": "90c7248ce860aa3ff21cd0c68ca611d5e1c2f689", "url": "https://github.com/DataDog/dd-trace-java/commit/90c7248ce860aa3ff21cd0c68ca611d5e1c2f689", "message": "Placate the formatting check", "committedDate": "2020-04-08T09:36:43Z", "type": "commit"}, {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f", "url": "https://github.com/DataDog/dd-trace-java/commit/38fdffaa8f7073dc8ad443c01db854786022a54f", "message": "Update instrumentation helper classes", "committedDate": "2020-04-08T10:07:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTExMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405459112", "bodyText": "would it make sense to load our event classes instead - to be 100% sure we can do that when exception is actually thrown?..", "author": "mar-kolya", "createdAt": "2020-04-08T11:40:01Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     */\n+\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMTI1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406421256", "bodyText": "Sure, why not.", "author": "jbachorik", "createdAt": "2020-04-09T19:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5NjI0Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407496242", "bodyText": "Apparently we cannot do this :)\nPlease consider #1363", "author": "mar-kolya", "createdAt": "2020-04-13T14:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTExMg=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex 04d50d3f95..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,11 +1,15 @@\n package datadog.exceptions.instrumentation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.is;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MDczMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405460731", "bodyText": "Please make this a constant with javadoc into why this is the value it is", "author": "mar-kolya", "createdAt": "2020-04-08T11:43:15Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import jdk.jfr.EventType;\n+\n+final class ExceptionSampler {\n+  private static final int SAMPLING_WINDOW_DURATION_SEC = 1;\n+  private final StreamingSampler sampler;\n+  private final EventType exceptionSampleType;\n+\n+  ExceptionSampler(final Config config) {\n+    this(\n+        getSamplingWindowDuration(), // fixed 1sec sampling window\n+        getSamplesPerWindow(config));\n+  }\n+\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, 60);", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\nindex 5162d58c7a..c2e74d404e 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\n\n@@ -6,34 +6,43 @@ import java.time.temporal.ChronoUnit;\n import jdk.jfr.EventType;\n \n final class ExceptionSampler {\n-  private static final int SAMPLING_WINDOW_DURATION_SEC = 1;\n+  /*\n+   * Fixed 0.5 second sampling window.\n+   * Logic in StreamingSampler relies on sampling window being small compared to (in our case) recording duration:\n+   * sampler may overshoot on one given window but should average to samplesPerWindow in the long run.\n+   */\n+  private static final Duration SAMPLING_WINDOW = Duration.of(500, ChronoUnit.MILLIS);\n+\n   private final StreamingSampler sampler;\n   private final EventType exceptionSampleType;\n \n   ExceptionSampler(final Config config) {\n-    this(\n-        getSamplingWindowDuration(), // fixed 1sec sampling window\n-        getSamplesPerWindow(config));\n+    this(SAMPLING_WINDOW, getSamplesPerWindow(config), samplingWindowsPerRecording(config));\n   }\n \n-  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow) {\n-    sampler = new StreamingSampler(windowDuration, samplesPerWindow, 60);\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, lookback);\n     exceptionSampleType = EventType.getEventType(ExceptionSampleEvent.class);\n   }\n \n-  private static Duration getSamplingWindowDuration() {\n-    return Duration.of(SAMPLING_WINDOW_DURATION_SEC, ChronoUnit.SECONDS);\n+  private static int samplingWindowsPerRecording(final Config config) {\n+    /*\n+     * Java8 doesn't have dividedBy#Duration so we have to implement poor man's version.\n+     * None of these durations should be big enough to warrant dealing with bigints.\n+     * We also do not care about nanoseconds here.\n+     */\n+    return (int)\n+        Math.min(\n+            Duration.of(config.getProfilingUploadPeriod(), ChronoUnit.SECONDS).toMillis()\n+                / SAMPLING_WINDOW.toMillis(),\n+            Integer.MAX_VALUE);\n   }\n \n-  private static int getSamplesPerWindow(Config config) {\n-    return (int)Math.min(config.getProfilingExceptionSampleLimit() / Duration.of(config.getProfilingUploadPeriod(), ChronoUnit.SECONDS).dividedBy(getSamplingWindowDuration()), Integer.MAX_VALUE);\n+  private static int getSamplesPerWindow(final Config config) {\n+    return config.getProfilingExceptionSampleLimit() / samplingWindowsPerRecording(config);\n   }\n \n   boolean sample() {\n-    return sampler.sample();\n-  }\n-\n-  boolean isEnabled() {\n-    return exceptionSampleType.isEnabled();\n+    return exceptionSampleType.isEnabled() && sampler.sample();\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MDg3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405460876", "bodyText": "you can make this a constant and remove this method", "author": "mar-kolya", "createdAt": "2020-04-08T11:43:31Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import jdk.jfr.EventType;\n+\n+final class ExceptionSampler {\n+  private static final int SAMPLING_WINDOW_DURATION_SEC = 1;\n+  private final StreamingSampler sampler;\n+  private final EventType exceptionSampleType;\n+\n+  ExceptionSampler(final Config config) {\n+    this(\n+        getSamplingWindowDuration(), // fixed 1sec sampling window\n+        getSamplesPerWindow(config));\n+  }\n+\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, 60);\n+    exceptionSampleType = EventType.getEventType(ExceptionSampleEvent.class);\n+  }\n+\n+  private static Duration getSamplingWindowDuration() {\n+    return Duration.of(SAMPLING_WINDOW_DURATION_SEC, ChronoUnit.SECONDS);", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\nindex 5162d58c7a..c2e74d404e 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\n\n@@ -6,34 +6,43 @@ import java.time.temporal.ChronoUnit;\n import jdk.jfr.EventType;\n \n final class ExceptionSampler {\n-  private static final int SAMPLING_WINDOW_DURATION_SEC = 1;\n+  /*\n+   * Fixed 0.5 second sampling window.\n+   * Logic in StreamingSampler relies on sampling window being small compared to (in our case) recording duration:\n+   * sampler may overshoot on one given window but should average to samplesPerWindow in the long run.\n+   */\n+  private static final Duration SAMPLING_WINDOW = Duration.of(500, ChronoUnit.MILLIS);\n+\n   private final StreamingSampler sampler;\n   private final EventType exceptionSampleType;\n \n   ExceptionSampler(final Config config) {\n-    this(\n-        getSamplingWindowDuration(), // fixed 1sec sampling window\n-        getSamplesPerWindow(config));\n+    this(SAMPLING_WINDOW, getSamplesPerWindow(config), samplingWindowsPerRecording(config));\n   }\n \n-  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow) {\n-    sampler = new StreamingSampler(windowDuration, samplesPerWindow, 60);\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, lookback);\n     exceptionSampleType = EventType.getEventType(ExceptionSampleEvent.class);\n   }\n \n-  private static Duration getSamplingWindowDuration() {\n-    return Duration.of(SAMPLING_WINDOW_DURATION_SEC, ChronoUnit.SECONDS);\n+  private static int samplingWindowsPerRecording(final Config config) {\n+    /*\n+     * Java8 doesn't have dividedBy#Duration so we have to implement poor man's version.\n+     * None of these durations should be big enough to warrant dealing with bigints.\n+     * We also do not care about nanoseconds here.\n+     */\n+    return (int)\n+        Math.min(\n+            Duration.of(config.getProfilingUploadPeriod(), ChronoUnit.SECONDS).toMillis()\n+                / SAMPLING_WINDOW.toMillis(),\n+            Integer.MAX_VALUE);\n   }\n \n-  private static int getSamplesPerWindow(Config config) {\n-    return (int)Math.min(config.getProfilingExceptionSampleLimit() / Duration.of(config.getProfilingUploadPeriod(), ChronoUnit.SECONDS).dividedBy(getSamplingWindowDuration()), Integer.MAX_VALUE);\n+  private static int getSamplesPerWindow(final Config config) {\n+    return config.getProfilingExceptionSampleLimit() / samplingWindowsPerRecording(config);\n   }\n \n   boolean sample() {\n-    return sampler.sample();\n-  }\n-\n-  boolean isEnabled() {\n-    return exceptionSampleType.isEnabled();\n+    return exceptionSampleType.isEnabled() && sampler.sample();\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MTI5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405461297", "bodyText": "One more magic number - please constantify and document", "author": "mar-kolya", "createdAt": "2020-04-08T11:44:21Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex c6864011e3..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,9 +1,7 @@\n package com.datadog.profiling.exceptions;\n \n import datadog.common.exec.CommonTaskExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2Mzc0Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405463746", "bodyText": "you could make addSample return boolean to make this less awkward", "author": "mar-kolya", "createdAt": "2020-04-08T11:48:56Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex c6864011e3..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,9 +1,7 @@\n package com.datadog.profiling.exceptions;\n \n import datadog.common.exec.CommonTaskExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTcxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405465719", "bodyText": "I'm not sure that you can extrapolate burst budget with EMA. The whole point of burst budget is to react to short bursts, the whole point of EMA is not to react to that.", "author": "mar-kolya", "createdAt": "2020-04-08T11:52:45Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;\n+    }\n+\n+    return false;\n+  }\n+\n+  // package private access for the tests\n+  final void rollWindow() {\n+    windowCount = Math.min(windowCount + 1, lookback);\n+\n+    /*\n+     * Atomically replace the Counts instance such that sample requests during window maintenance will be\n+     * using the newly created counts instead of the ones currently processed by the maintenance routine.\n+     */\n+\n+    Counts counts = countsRef.getAndSet(new Counts());\n+    final long totalCount = counts.testCounter.sum();\n+    final long sampledCount = counts.sampleCounter.get();\n+\n+    long sampleBudget = samplesPerWindow - sampledCount;\n+    avgBudget = Double.isNaN(avgBudget) ? sampleBudget : avgBudget + emaAlpha * (sampleBudget - avgBudget);\n+    targetSamples = samplesPerWindow + Math.round(Math.max(avgBudget, 0) * windowCount);", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NzE2MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405467161", "bodyText": "I can change that back - but didn't see any difference in results.", "author": "jbachorik", "createdAt": "2020-04-08T11:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTcxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex c6864011e3..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,9 +1,7 @@\n package com.datadog.profiling.exceptions;\n \n import datadog.common.exec.CommonTaskExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2Njg1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405466855", "bodyText": "These two are unused", "author": "mar-kolya", "createdAt": "2020-04-08T11:54:37Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -190,6 +195,11 @@\n   public static final int DEFAULT_PROFILING_UPLOAD_TIMEOUT = 30; // seconds\n   public static final String DEFAULT_PROFILING_UPLOAD_COMPRESSION = \"on\";\n   public static final int DEFAULT_PROFILING_PROXY_PORT = 8080;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT = 10_000;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW = 1;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES = 100;", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/Config.java b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\nindex d446f0791f..326f0f973b 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n\n@@ -195,9 +200,7 @@ public class Config {\n   public static final int DEFAULT_PROFILING_UPLOAD_TIMEOUT = 30; // seconds\n   public static final String DEFAULT_PROFILING_UPLOAD_COMPRESSION = \"on\";\n   public static final int DEFAULT_PROFILING_PROXY_PORT = 8080;\n-  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT = 10_000;\n-  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW = 1;\n-  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES = 100;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLE_LIMIT = 10_000;\n   public static final int DEFAULT_PROFILING_EXCEPTION_HISTOGRAM_TOP_ITEMS = 50;\n   public static final int DEFAULT_PROFILING_EXCEPTION_HISTOGRAM_MAX_COLLECTION_SIZE = 10000;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NzAwOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405467009", "bodyText": "this should bre renamed to DEFAULT_PROFILING_EXCEPTION_SAMPLE_LIMIT", "author": "mar-kolya", "createdAt": "2020-04-08T11:54:53Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -190,6 +195,11 @@\n   public static final int DEFAULT_PROFILING_UPLOAD_TIMEOUT = 30; // seconds\n   public static final String DEFAULT_PROFILING_UPLOAD_COMPRESSION = \"on\";\n   public static final int DEFAULT_PROFILING_PROXY_PORT = 8080;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT = 10_000;", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/Config.java b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\nindex d446f0791f..326f0f973b 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n\n@@ -195,9 +200,7 @@ public class Config {\n   public static final int DEFAULT_PROFILING_UPLOAD_TIMEOUT = 30; // seconds\n   public static final String DEFAULT_PROFILING_UPLOAD_COMPRESSION = \"on\";\n   public static final int DEFAULT_PROFILING_PROXY_PORT = 8080;\n-  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT = 10_000;\n-  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW = 1;\n-  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES = 100;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLE_LIMIT = 10_000;\n   public static final int DEFAULT_PROFILING_EXCEPTION_HISTOGRAM_TOP_ITEMS = 50;\n   public static final int DEFAULT_PROFILING_EXCEPTION_HISTOGRAM_MAX_COLLECTION_SIZE = 10000;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3MDczMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405470733", "bodyText": "it seems to be these should be available in some library", "author": "mar-kolya", "createdAt": "2020-04-08T12:01:42Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    BurstingWindowsEventsSupplier(double burstProbability, int minEvents, int maxEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = minEvents;\n+      this.maxEvents = maxEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return rnd.nextDouble() <= burstProbability ? maxEvents : minEvents;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    ConstantWindowsEventsSupplier(int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    RepeatingWindowsEventsSupplier(int... eventsCounts) {\n+      this.eventsCounts = Arrays.copyOf(eventsCounts, eventsCounts.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParams\")\n+  public void testSampler(\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    long expectedSamples = windows * samplesPerWindow;\n+\n+    long samples = 0L;\n+\n+    int[] totalParts = new int[windows];\n+    double[] sampledParts = new double[windows];\n+    double[] sampleIndexSkew = new double[windows];\n+    for (int w = 0; w < windows; w++) {\n+      List<Integer> sampleIndices = new ArrayList<>();\n+      long samplesBase = samples;\n+      int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalParts[w] = events;\n+      sampledParts[w] =\n+          (1 - Math.abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      double sampleIndexMean = calculateMean(sampleIndices);\n+      sampleIndexSkew[w] = events != 0 ? sampleIndexMean / events : 0;\n+      instance.rollWindow();\n+    }\n+    double sampledPartMean = calculateMean(sampledParts);\n+    double sampledPartStdev = calculateStddev(sampledParts, sampledPartMean);\n+    double totalPartMean = calculateMean(totalParts);\n+\n+    double correctionFactor = Math.min(((totalPartMean * windows) / expectedSamples), 1);\n+    double targetSamples = expectedSamples * correctionFactor;\n+    double percentualError =\n+        Math.round(Math.abs(((targetSamples - samples) / targetSamples)) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (double skew : sampleIndexSkew) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    int positiveCount = sampleIndexSkew.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkew.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+\n+    LOGGER.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {}\",\n+        sampledPartMean * expectedSamples,\n+        sampledPartStdev * expectedSamples,\n+        (sampledPartMean * windows) / correctionFactor + \")\");\n+    LOGGER.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        Math.round(skewNegativeAvg * 100), Math.round(skewPositiveAvg * 100));\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParamsConcurrency\")\n+  public void testSamplerConcurrency(\n+      int threadCount,\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> threads: {}, mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+\n+    long expectedSamples = samplesPerWindow * windows;\n+    AtomicLong allSamples = new AtomicLong(0);\n+    Thread[] threads = new Thread[threadCount];\n+\n+    Phaser phaser = new Phaser(threadCount + 1);\n+\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    for (int i = 0; i < threadCount; i++) {\n+      threads[i] =\n+          new Thread(\n+              () -> {\n+                for (int w = 0; w < windows; w++) {\n+                  int events = windowEventsSupplier.get();\n+                  for (int e = 0; e < events; e++) {\n+                    if (instance.sample()) {\n+                      allSamples.incrementAndGet();\n+                    }\n+                  }\n+                  /*\n+                   * Block here until window roll is initiated from other thread.\n+                   * After the roll has been started the next window data starts arriving in parallel.\n+                   */\n+                  phaser.arriveAndAwaitAdvance();\n+                }\n+              });\n+    }\n+\n+    Thread roller =\n+        new Thread(\n+            () -> {\n+              while (!Thread.currentThread().isInterrupted()) {\n+                // wait for the next window signalled from the data generating thread before\n+                // starting to roll the window\n+                phaser.arriveAndAwaitAdvance();\n+                instance.rollWindow();\n+              }\n+            });\n+    roller.start();\n+    for (Thread t : threads) {\n+      t.start();\n+    }\n+    for (Thread t : threads) {\n+      t.join();\n+    }\n+\n+    roller.interrupt();\n+\n+    long samples = allSamples.get();\n+    int percentualError =\n+        Math.round(Math.abs(((expectedSamples - samples) / (float) expectedSamples)) * 100);\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private double calculateStddev(double[] data, double average) {", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\nindex 8016906eb2..ae07ea9d48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n\n@@ -1,31 +1,57 @@\n package com.datadog.profiling.exceptions;\n \n+import static java.lang.Math.abs;\n+import static java.lang.Math.round;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n-import java.util.concurrent.Phaser;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Supplier;\n-import java.util.stream.Stream;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.math3.distribution.PoissonDistribution;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n class StreamingSamplerTest {\n \n-  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n \n+  /** Generates windows with numbers of events according to Poisson distribution */\n   private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n     private final PoissonDistribution distribution;\n \n-    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n       distribution = new PoissonDistribution(eventsPerWindowMean);\n       distribution.reseedRandomGenerator(12345671);\n     }\n"}}, {"oid": "202e86052bc76e344ac056dbca7a4b9033593306", "url": "https://github.com/DataDog/dd-trace-java/commit/202e86052bc76e344ac056dbca7a4b9033593306", "message": "Do not mess up bytecode level", "committedDate": "2020-04-08T12:04:49Z", "type": "commit"}, {"oid": "74e1ea5df9b3b14269b5cc9cdf4967e2ab0f3f0b", "url": "https://github.com/DataDog/dd-trace-java/commit/74e1ea5df9b3b14269b5cc9cdf4967e2ab0f3f0b", "message": "Clean up configs", "committedDate": "2020-04-08T12:11:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405478526", "bodyText": "would you consider injecting executor instead to avoid making rollWindow visible and make sure that parameters to scheduleAtFixedRate are correct", "author": "mar-kolya", "createdAt": "2020-04-08T12:15:38Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "originalCommit": "38fdffaa8f7073dc8ad443c01db854786022a54f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NDE3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405484175", "bodyText": "Relying on scheduled task in unit tests is very ... unwieldy. You don't want to run 1 minute per case to test the expected load, right?\nSo, injecting the executor would allow us to test that the JDK bundled executor is properly scheduling things?", "author": "jbachorik", "createdAt": "2020-04-08T12:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMzM1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405513355", "bodyText": "I was thinking more along the lines of providing mock executor that you can control through tests", "author": "mar-kolya", "createdAt": "2020-04-08T13:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDA0Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406420046", "bodyText": "I would need to create our specific interface for that since the common utility executor we have is not a ScheduledExecutorService it just delegates to it. So we would end up with a specific type which would need to be provided to the sampler - exposing the internal workings even more.\nIn addition to that we will need to implement synchronization mechanism between the data generation and window rolling which will complicate the matter a bit further.\nAll in all - I am not really convinced that this will improve things. We will just end up having fishy code in a different place.", "author": "jbachorik", "createdAt": "2020-04-09T19:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MzA5MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407643091", "bodyText": "There are two bugs in line below and third bug in constructor passing value for startWindowRolling... To this means we should have tests for this :)\nPlease consider #1363 - change to use mocks is not scary at all.", "author": "mar-kolya", "createdAt": "2020-04-13T18:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NzQ4Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407687483", "bodyText": "There is also one more potential problem here: if app blows up right after start up we may try to schedule things on dead executor and blow up too - this would be confusing to the client. We can avoid this and I suggest waiting for #1366 to just use that solution (and add some tests to it).", "author": "mar-kolya", "createdAt": "2020-04-13T20:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex c6864011e3..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,9 +1,7 @@\n package com.datadog.profiling.exceptions;\n \n import datadog.common.exec.CommonTaskExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n"}}, {"oid": "6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4", "url": "https://github.com/DataDog/dd-trace-java/commit/6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4", "message": "Bring in few more suggested changes", "committedDate": "2020-04-08T12:21:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4ODE5MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405488190", "bodyText": "It seems to me that 'expected' behaviour would be to assume there were no exceptions before sampler was created - i.e. we have 'max possible budget'.\nThis should allow you to remove this calculation. Also the added benefit we would be able to capture exception bursts right at start up", "author": "mar-kolya", "createdAt": "2020-04-08T12:32:49Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;\n+    }\n+\n+    return false;\n+  }\n+\n+  // package private access for the tests\n+  final void rollWindow() {\n+    windowCount = Math.min(windowCount + 1, lookback);", "originalCommit": "6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDIyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406420229", "bodyText": "The counter should go away. We are using the budget size only.", "author": "jbachorik", "createdAt": "2020-04-09T19:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4ODE5MA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex c6864011e3..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,9 +1,7 @@\n package com.datadog.profiling.exceptions;\n \n import datadog.common.exec.CommonTaskExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n"}}, {"oid": "0063d26fb32ab524a68920374df7c40be52175c7", "url": "https://github.com/DataDog/dd-trace-java/commit/0063d26fb32ab524a68920374df7c40be52175c7", "message": "Rename variables and use commons math to do mean and stdev", "committedDate": "2020-04-08T12:40:07Z", "type": "commit"}, {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "url": "https://github.com/DataDog/dd-trace-java/commit/2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "message": "Use forward-projecting budget calculations.\nKeep both EMA and ring buffer based calculations in place so we can run more experiments till we decide which one to use.", "committedDate": "2020-04-08T17:17:49Z", "type": "commit"}, {"oid": "b3295b5fbbc097189ea675a2d19dcc153b39661b", "url": "https://github.com/DataDog/dd-trace-java/commit/b3295b5fbbc097189ea675a2d19dcc153b39661b", "message": "Increase the error margin", "committedDate": "2020-04-08T17:34:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406415682", "bodyText": "Color me convinced! Please go ahead and remove array implementation.", "author": "mar-kolya", "createdAt": "2020-04-09T19:04:01Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  /*\n+   * We keep a 'budget' by counting number of unused samples form few last windows.\n+   * Exact value here should be on order of (but probably less than) size of the JFR chunk duration.\n+   * Another consideration to choosing this value is that we have to do linear number of operations\n+   * on resulting array every window so this value should not be too large.\n+   *\n+   * Note: we want sum of unused samples in previous windows - this is why we are using array for this and not EMA.\n+   * With EMA we would need to come up with some multiplier for and average and it's unclear how to do that.\n+   */\n+  private static final int CARRIED_OVER_ARRAY_SIZE = 16;\n+\n+  static boolean USE_EMA_BUDGET = true;", "originalCommit": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTc2Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406415766", "bodyText": "Thanks for investigating this!", "author": "mar-kolya", "createdAt": "2020-04-09T19:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDMyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406420322", "bodyText": "thanks!", "author": "jbachorik", "createdAt": "2020-04-09T19:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NjE3NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407686174", "bodyText": "Should be done in #1363", "author": "mar-kolya", "createdAt": "2020-04-13T19:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\nindex 598f6957e4..454b515b48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java\n\n@@ -1,11 +1,8 @@\n package com.datadog.profiling.exceptions;\n \n import datadog.common.exec.CommonTaskExecutor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n-import java.util.Arrays;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxOTgwOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406419809", "bodyText": "To be honest - I do not think this makes @ParameterizedTest justified... What do you link about just having a private test function and multiple @Test for each element here?\nI think this would make things clearer and provide an opportunity for comments about why we do these tests because currently this seems somewhat unclear.", "author": "mar-kolya", "createdAt": "2020-04-09T19:12:22Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    BurstingWindowsEventsSupplier(double burstProbability, int minEvents, int maxEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = minEvents;\n+      this.maxEvents = maxEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    ConstantWindowsEventsSupplier(int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    RepeatingWindowsEventsSupplier(int... eventsCounts) {\n+      this.eventsCounts = Arrays.copyOf(eventsCounts, eventsCounts.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParams\")\n+  public void testSampler(\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    long expectedSamples = windows * samplesPerWindow;\n+\n+    long samples = 0L;\n+\n+    double[] totalEventsPerWindow = new double[windows];\n+    double[] sampledEventsPerWindow = new double[windows];\n+    double[] sampleIndexSkewPerWindow = new double[windows];\n+    for (int w = 0; w < windows; w++) {\n+      List<Integer> sampleIndices = new ArrayList<>();\n+      long samplesBase = samples;\n+      int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalEventsPerWindow[w] = events;\n+      sampledEventsPerWindow[w] =\n+          (1 - Math.abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+      sampleIndexSkewPerWindow[w] = events != 0 ? sampleIndexMean / events : 0;\n+      instance.rollWindow();\n+    }\n+    double sampledEventsPerWindowMean = MEAN.evaluate(sampledEventsPerWindow);\n+    double sampledEventsPerWindowStdev =\n+        STANDARD_DEVIATION.evaluate(sampledEventsPerWindow, sampledEventsPerWindowMean);\n+    double totalEventsPerWindowMean = MEAN.evaluate(totalEventsPerWindow);\n+\n+    double correctionFactor = Math.min(((totalEventsPerWindowMean * windows) / expectedSamples), 1);\n+    double targetSamples = expectedSamples * correctionFactor;\n+    double percentualError =\n+        Math.round(Math.abs(((targetSamples - samples) / targetSamples)) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (double skew : sampleIndexSkewPerWindow) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    int positiveCount = sampleIndexSkewPerWindow.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkewPerWindow.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+\n+    LOGGER.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {}\",\n+        sampledEventsPerWindowMean * expectedSamples,\n+        sampledEventsPerWindowStdev * expectedSamples,\n+        (sampledEventsPerWindowMean * windows) / correctionFactor + \")\");\n+    LOGGER.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        Math.round(skewNegativeAvg * 100), Math.round(skewPositiveAvg * 100));\n+    LOGGER.info(\n+        \"\\t percentual error = {}%\", Math.signum(samples - targetSamples) * percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static double[] toDoubleArray(List<? extends Number> data) {\n+    double[] rslt = new double[data.size()];\n+    int index = 0;\n+    for (Number n : data) {\n+      rslt[index++] = n.doubleValue();\n+    }\n+    return rslt;\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParamsConcurrency\")\n+  public void testSamplerConcurrency(\n+      int threadCount,\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> threads: {}, mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+\n+    long expectedSamples = samplesPerWindow * windows;\n+    AtomicLong allSamples = new AtomicLong(0);\n+    Thread[] threads = new Thread[threadCount];\n+\n+    Phaser phaser = new Phaser(threadCount + 1);\n+\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    for (int i = 0; i < threadCount; i++) {\n+      threads[i] =\n+          new Thread(\n+              () -> {\n+                for (int w = 0; w < windows; w++) {\n+                  int events = windowEventsSupplier.get();\n+                  for (int e = 0; e < events; e++) {\n+                    if (instance.sample()) {\n+                      allSamples.incrementAndGet();\n+                    }\n+                  }\n+                  /*\n+                   * Block here until window roll is initiated from other thread.\n+                   * After the roll has been started the next window data starts arriving in parallel.\n+                   */\n+                  phaser.arriveAndAwaitAdvance();\n+                }\n+              });\n+    }\n+\n+    Thread roller =\n+        new Thread(\n+            () -> {\n+              while (!Thread.currentThread().isInterrupted()) {\n+                // wait for the next window signalled from the data generating thread before\n+                // starting to roll the window\n+                phaser.arriveAndAwaitAdvance();\n+                instance.rollWindow();\n+              }\n+            });\n+    roller.start();\n+    for (Thread t : threads) {\n+      t.start();\n+    }\n+    for (Thread t : threads) {\n+      t.join();\n+    }\n+\n+    roller.interrupt();\n+\n+    long samples = allSamples.get();\n+    int percentualError =\n+        Math.round(Math.abs(((expectedSamples - samples) / (float) expectedSamples)) * 100);\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static Stream<Arguments> samplerParams() {", "originalCommit": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDk3Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406420972", "bodyText": "Possible. With the smaller number of hand-crafted test data sets it is really much more suitable to have specialized cases.", "author": "jbachorik", "createdAt": "2020-04-09T19:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxOTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NDY1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r408264653", "bodyText": "Parametrized tests were converted to single test cases.", "author": "jbachorik", "createdAt": "2020-04-14T16:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxOTgwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\nindex 5ff35752c9..ae07ea9d48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n\n@@ -1,33 +1,57 @@\n package com.datadog.profiling.exceptions;\n \n+import static java.lang.Math.abs;\n+import static java.lang.Math.round;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n-import java.util.concurrent.Phaser;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Supplier;\n-import java.util.stream.Stream;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.math3.distribution.PoissonDistribution;\n import org.apache.commons.math3.stat.descriptive.moment.Mean;\n import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n class StreamingSamplerTest {\n \n-  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n \n+  /** Generates windows with numbers of events according to Poisson distribution */\n   private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n     private final PoissonDistribution distribution;\n \n-    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n       distribution = new PoissonDistribution(eventsPerWindowMean);\n       distribution.reseedRandomGenerator(12345671);\n     }\n"}}, {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "url": "https://github.com/DataDog/dd-trace-java/commit/2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "message": "Use forward-projecting budget calculations.\nKeep both EMA and ring buffer based calculations in place so we can run more experiments till we decide which one to use.", "committedDate": "2020-04-08T17:17:49Z", "type": "forcePushed"}, {"oid": "744f668b3454f77ad85b215ac1387e40308f02fe", "url": "https://github.com/DataDog/dd-trace-java/commit/744f668b3454f77ad85b215ac1387e40308f02fe", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler", "committedDate": "2020-04-13T12:39:26Z", "type": "commit"}, {"oid": "ed25c98ab37c4c176f81483986fac45756cebce3", "url": "https://github.com/DataDog/dd-trace-java/commit/ed25c98ab37c4c176f81483986fac45756cebce3", "message": "Simplify code a bit", "committedDate": "2020-04-13T13:59:16Z", "type": "commit"}, {"oid": "3fd1fa9d82de06b4a7add2ddf8defb7ed424a845", "url": "https://github.com/DataDog/dd-trace-java/commit/3fd1fa9d82de06b4a7add2ddf8defb7ed424a845", "message": "Make gradle happy", "committedDate": "2020-04-13T13:59:27Z", "type": "commit"}, {"oid": "b39b37db7e3d27de23f725c7751e06c7b5089273", "url": "https://github.com/DataDog/dd-trace-java/commit/b39b37db7e3d27de23f725c7751e06c7b5089273", "message": "Load our event classe to make sure they are loading fine\n\nTo avoid accidentally breaking customer code by instrumentation.", "committedDate": "2020-04-13T14:06:56Z", "type": "commit"}, {"oid": "873ca2209ec1f3352a95562890c7bcf976bb78c9", "url": "https://github.com/DataDog/dd-trace-java/commit/873ca2209ec1f3352a95562890c7bcf976bb78c9", "message": "Revert change to load our exception event class\n\nWe cannot do this because it is not visible on apps classloader after\ninstrumentation has been applied.", "committedDate": "2020-04-13T14:50:27Z", "type": "commit"}, {"oid": "556e96e1e5c649d2a854e89eb84e951de4750eae", "url": "https://github.com/DataDog/dd-trace-java/commit/556e96e1e5c649d2a854e89eb84e951de4750eae", "message": "Add exception cause information to exception event", "committedDate": "2020-04-13T14:50:34Z", "type": "commit"}, {"oid": "dc689f037c7644db5aaf21eaec1b324c2be2aa34", "url": "https://github.com/DataDog/dd-trace-java/commit/dc689f037c7644db5aaf21eaec1b324c2be2aa34", "message": "Remove array based EMA calculations", "committedDate": "2020-04-13T16:52:28Z", "type": "commit"}, {"oid": "62765c9d0b9b1b7602f440176819246df8402fae", "url": "https://github.com/DataDog/dd-trace-java/commit/62765c9d0b9b1b7602f440176819246df8402fae", "message": "Minor tests cleanup", "committedDate": "2020-04-13T17:09:46Z", "type": "commit"}, {"oid": "c927438b79f3159dad9a92d074977c90506914e5", "url": "https://github.com/DataDog/dd-trace-java/commit/c927438b79f3159dad9a92d074977c90506914e5", "message": "Define mockito dependency", "committedDate": "2020-04-13T17:46:43Z", "type": "commit"}, {"oid": "3889014026f62fdf4a1dde6f5ffe87c239f164e0", "url": "https://github.com/DataDog/dd-trace-java/commit/3889014026f62fdf4a1dde6f5ffe87c239f164e0", "message": "Inject common executor into ExceptionSampler\n\nOriginal implementation had bugs in it which were not covered with tests.", "committedDate": "2020-04-13T18:38:12Z", "type": "commit"}, {"oid": "0dc63c7e382b033636e6ed336ea2997e9b80149f", "url": "https://github.com/DataDog/dd-trace-java/commit/0dc63c7e382b033636e6ed336ea2997e9b80149f", "message": "Simnplify sampler tests\n\nRunning multiple threads blocked on phaser should have exactly the\nsame effect as just starting new threads on each iteration - which is simpler.", "committedDate": "2020-04-13T18:43:47Z", "type": "commit"}, {"oid": "7438b588f79dac662e9be75a382d063f0ff10acd", "url": "https://github.com/DataDog/dd-trace-java/commit/7438b588f79dac662e9be75a382d063f0ff10acd", "message": "Use sfl4j", "committedDate": "2020-04-13T18:47:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzM4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407563384", "bodyText": "This fails on CI quite often: https://circleci.com/gh/DataDog/dd-trace-java/53540", "author": "mar-kolya", "createdAt": "2020-04-13T16:14:22Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {", "originalCommit": "744f668b3454f77ad85b215ac1387e40308f02fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3OTQzMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407979432", "bodyText": "I don't see any related test failures there - bunch of CustomLogManager related tests failing and ProfilingIntegrationContinuousProfilesTest failing on Zulu8", "author": "jbachorik", "createdAt": "2020-04-14T09:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDc4MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r408294780", "bodyText": "I have adjusted the expected error margins.\nAlso, ran tests several 100s of iterations without breaking those margins. So, let's keep our fingers crossed that it is enough (statistics is a ...)", "author": "jbachorik", "createdAt": "2020-04-14T17:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzM4NA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\nindex 5ff35752c9..ae07ea9d48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n\n@@ -1,33 +1,57 @@\n package com.datadog.profiling.exceptions;\n \n+import static java.lang.Math.abs;\n+import static java.lang.Math.round;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n \n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n-import java.util.concurrent.Phaser;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Supplier;\n-import java.util.stream.Stream;\n+import lombok.extern.slf4j.Slf4j;\n import org.apache.commons.math3.distribution.PoissonDistribution;\n import org.apache.commons.math3.stat.descriptive.moment.Mean;\n import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n class StreamingSamplerTest {\n \n-  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n \n+  /** Generates windows with numbers of events according to Poisson distribution */\n   private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n     private final PoissonDistribution distribution;\n \n-    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n       distribution = new PoissonDistribution(eventsPerWindowMean);\n       distribution.reseedRandomGenerator(12345671);\n     }\n"}}, {"oid": "f5494804e58f5c355ed7e1c36e4719bac27e360c", "url": "https://github.com/DataDog/dd-trace-java/commit/f5494804e58f5c355ed7e1c36e4719bac27e360c", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler", "committedDate": "2020-04-13T23:30:39Z", "type": "commit"}, {"oid": "b560c7a39574aa65fbb5b9b51aaa491994d21776", "url": "https://github.com/DataDog/dd-trace-java/commit/b560c7a39574aa65fbb5b9b51aaa491994d21776", "message": "Merge branch 'jb/PROF-581_exceptions_sampler' into mar-kolya/exception-sampler-changes", "committedDate": "2020-04-13T23:31:23Z", "type": "commit"}, {"oid": "cb1c15bf2302b7b84235c4b2481978e7878dfdad", "url": "https://github.com/DataDog/dd-trace-java/commit/cb1c15bf2302b7b84235c4b2481978e7878dfdad", "message": "Use new safe periodic tasks", "committedDate": "2020-04-14T01:05:56Z", "type": "commit"}, {"oid": "47a3241988dd541e3803387a87c8ce49e448711f", "url": "https://github.com/DataDog/dd-trace-java/commit/47a3241988dd541e3803387a87c8ce49e448711f", "message": "Make gradle happy temporarily\n\nAdd temporary fix to gradle to make things compile.\nWill have to open another PR to make things beautiful.", "committedDate": "2020-04-14T01:27:05Z", "type": "commit"}, {"oid": "0bc73d5452a8293d54958ff8dd46e319d0511a1e", "url": "https://github.com/DataDog/dd-trace-java/commit/0bc73d5452a8293d54958ff8dd46e319d0511a1e", "message": "javadoc fix\n\nCo-Authored-By: Jaroslav Bachorik <jaroslav.bachorik@datadoghq.com>", "committedDate": "2020-04-14T11:14:01Z", "type": "commit"}, {"oid": "1068a7e2a5810f0e822537c37d85c0cba490a54c", "url": "https://github.com/DataDog/dd-trace-java/commit/1068a7e2a5810f0e822537c37d85c0cba490a54c", "message": "Add sourceset for java11\n\nwithout it changing java version affects whole project", "committedDate": "2020-04-14T11:42:01Z", "type": "commit"}, {"oid": "a72093e2367f4b0e18a87213b815ab33e896f858", "url": "https://github.com/DataDog/dd-trace-java/commit/a72093e2367f4b0e18a87213b815ab33e896f858", "message": "Remove exception cause\n\nwe will have to think more about this", "committedDate": "2020-04-14T11:42:01Z", "type": "commit"}, {"oid": "1d67989280a267cbd6b9672ff2acb9174e9c2ad1", "url": "https://github.com/DataDog/dd-trace-java/commit/1d67989280a267cbd6b9672ff2acb9174e9c2ad1", "message": "Merge pull request #1363 from DataDog/mar-kolya/exception-sampler-changes\n\nexception sampler changes", "committedDate": "2020-04-14T11:47:32Z", "type": "commit"}, {"oid": "3ab3d3fffce2b79bfc949b93db5d104bce822179", "url": "https://github.com/DataDog/dd-trace-java/commit/3ab3d3fffce2b79bfc949b93db5d104bce822179", "message": "Fix java version in exceptions instrumentation", "committedDate": "2020-04-14T12:53:31Z", "type": "commit"}, {"oid": "dc854c799b294d119ca29cac0fd0b418619c8a89", "url": "https://github.com/DataDog/dd-trace-java/commit/dc854c799b294d119ca29cac0fd0b418619c8a89", "message": "Do not use Java11 only APIs\n\nWe want things working on Java8", "committedDate": "2020-04-14T13:22:53Z", "type": "commit"}, {"oid": "96f47c5e56f4cfac516346a265f15e20cb69dbce", "url": "https://github.com/DataDog/dd-trace-java/commit/96f47c5e56f4cfac516346a265f15e20cb69dbce", "message": "Merge pull request #1368 from DataDog/mar-kolya/fix-exception-instrumentation-java-version\n\nfix exception instrumentation java version", "committedDate": "2020-04-14T14:04:04Z", "type": "commit"}, {"oid": "334b106de70881e3b91b79d3e248b5690e65d3b8", "url": "https://github.com/DataDog/dd-trace-java/commit/334b106de70881e3b91b79d3e248b5690e65d3b8", "message": "Merge branch 'jb/PROF-581_exceptions_sampler' of github.com:DataDog/dd-trace-java into jb/PROF-581_exceptions_sampler", "committedDate": "2020-04-14T14:20:51Z", "type": "commit"}, {"oid": "5c1b6620bf08e7b172cdfa0de4025802be451a55", "url": "https://github.com/DataDog/dd-trace-java/commit/5c1b6620bf08e7b172cdfa0de4025802be451a55", "message": "Merge branch 'mar-kolya/add-thread-utils-to-bootstrap' into mar-kolya/fix-thread-utils-dependency", "committedDate": "2020-04-14T15:59:04Z", "type": "commit"}, {"oid": "74350c3b20443fb3ea102e04ffca1c219b623a59", "url": "https://github.com/DataDog/dd-trace-java/commit/74350c3b20443fb3ea102e04ffca1c219b623a59", "message": "Undo packaging hack", "committedDate": "2020-04-14T16:01:04Z", "type": "commit"}, {"oid": "8bb199a333a2fc6a6e3790bdb54436959b4c1efa", "url": "https://github.com/DataDog/dd-trace-java/commit/8bb199a333a2fc6a6e3790bdb54436959b4c1efa", "message": "Transform parametrized tests into separate test cases.\nAdd 'benchmark' mode to allow exploring reliability boundaries.", "committedDate": "2020-04-14T16:05:58Z", "type": "commit"}, {"oid": "70ce151de74b0697b2cd0e75bfe1e3b8e113a651", "url": "https://github.com/DataDog/dd-trace-java/commit/70ce151de74b0697b2cd0e75bfe1e3b8e113a651", "message": "Decrease the sampling window size.\nAt least in the simulated env in tests the smaller window size has positive effect on the overall error margin.", "committedDate": "2020-04-14T16:16:41Z", "type": "commit"}, {"oid": "24ce87dc59c099314c90fca586452d8ada017946", "url": "https://github.com/DataDog/dd-trace-java/commit/24ce87dc59c099314c90fca586452d8ada017946", "message": "Add comments", "committedDate": "2020-04-14T16:25:33Z", "type": "commit"}, {"oid": "b59c196f3bef4067caab828433e541aef6517a7a", "url": "https://github.com/DataDog/dd-trace-java/commit/b59c196f3bef4067caab828433e541aef6517a7a", "message": "Merge pull request #1372 from DataDog/mar-kolya/fix-thread-utils-dependency\n\nfix thread utils dependency", "committedDate": "2020-04-14T16:28:09Z", "type": "commit"}, {"oid": "879c3c06db63d4b8f01129bf251878853fe06ac9", "url": "https://github.com/DataDog/dd-trace-java/commit/879c3c06db63d4b8f01129bf251878853fe06ac9", "message": "Fix duration calculation", "committedDate": "2020-04-14T16:52:57Z", "type": "commit"}, {"oid": "9458fa8a6a10e6e7a362744d758473887e03ce5f", "url": "https://github.com/DataDog/dd-trace-java/commit/9458fa8a6a10e6e7a362744d758473887e03ce5f", "message": "Merge remote-tracking branch 'origin/jb/PROF-581_exceptions_sampler' into jb/PROF-581_exceptions_sampler", "committedDate": "2020-04-14T17:00:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NzM0Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r408297346", "bodyText": "It would be nice to have more comments in this function - it is somewhat long and there a a lot of non obvious local variables", "author": "mar-kolya", "createdAt": "2020-04-14T17:06:52Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,424 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static java.lang.Math.abs;\n+import static java.lang.Math.min;\n+import static java.lang.Math.round;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n+class StreamingSamplerTest {\n+\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n+\n+  /** Generates windows with numbers of events according to Poisson distribution */\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  /**\n+   * Generates bursty windows - some of the windows have extremely low number of events while the\n+   * others have very hight number of events.\n+   */\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    /**\n+     * @param burstProbability the probability of burst window happening\n+     * @param nonBurstEvents number of events in non-burst window\n+     * @param burstEvents number of events in burst window\n+     */\n+    BurstingWindowsEventsSupplier(\n+        final double burstProbability, final int nonBurstEvents, final int burstEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = nonBurstEvents;\n+      this.maxEvents = burstEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  /** Generates windows with constant number of events. */\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    /** @param events number of events per window */\n+    ConstantWindowsEventsSupplier(final int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  /** Generates a pre-configured repeating sequence of window events */\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    /** @param windowEvents an array of number of events per each window in the sequence */\n+    RepeatingWindowsEventsSupplier(final int... windowEvents) {\n+      this.eventsCounts = Arrays.copyOf(windowEvents, windowEvents.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+  private static final int WINDOWS = 120;\n+  private static final int SAMPLES_PER_WINDOW = 100;\n+  private static final int LOOKBACK = 30;\n+\n+  @Mock CommonTaskExecutor taskExecutor;\n+  @Captor ArgumentCaptor<Task<StreamingSampler>> rollWindowTaskCaptor;\n+  @Captor ArgumentCaptor<StreamingSampler> rollWindowTargetCaptor;\n+  @Mock ScheduledFuture scheduledFuture;\n+\n+  @BeforeEach\n+  public void setup() {\n+    when(taskExecutor.scheduleAtFixedRate(\n+            rollWindowTaskCaptor.capture(),\n+            rollWindowTargetCaptor.capture(),\n+            eq(WINDOW_DURATION.toNanos()),\n+            eq(WINDOW_DURATION.toNanos()),\n+            same(TimeUnit.NANOSECONDS),\n+            any()))\n+        .thenReturn(scheduledFuture);\n+  }\n+\n+  @Test\n+  public void testBurstLowProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.1d, 5, 5000), 40);\n+  }\n+\n+  @Test\n+  public void testBurstHighProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.8d, 5, 5000), 20);\n+  }\n+\n+  @Test\n+  public void testPoissonLowFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonMidFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(283), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonHighFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(1013), 15);\n+  }\n+\n+  @Test\n+  public void testConstantVeryLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(1), 10);\n+  }\n+\n+  @Test\n+  public void testConstantLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testConstantMediumLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(713), 15);\n+  }\n+\n+  @Test\n+  public void testConstantHighLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(5211), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingSemiRandom() throws Exception {\n+    testSampler(\n+        new RepeatingWindowsEventsSupplier(180, 200, 0, 0, 0, 1500, 1000, 430, 200, 115, 115, 900),\n+        15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithBurst() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(1000, 0, 1000, 0, 1000, 0), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithLow() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(0, 1000, 0, 1000, 0, 1000), 15);\n+  }\n+\n+  private void testSampler(final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent)\n+      throws Exception {\n+    int iterations =\n+        Integer.parseInt(\n+            System.getProperty(\"com.datadog.profiling.exceptions.test-iterations\", \"1\"));\n+    for (int i = 0; i < iterations; i++) {\n+      testSamplerInline(windowEventsSupplier, maxErrorPercent);\n+      for (int numOfThreads = 1; numOfThreads <= 64; numOfThreads *= 2) {\n+        testSamplerConcurrently(numOfThreads, windowEventsSupplier, maxErrorPercent);\n+      }\n+    }\n+  }\n+\n+  private void testSamplerInline(\n+      final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent) {\n+    log.info(\n+        \"> mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}%\",\n+        windowEventsSupplier, WINDOWS, SAMPLES_PER_WINDOW, LOOKBACK, maxErrorPercent);\n+    final StreamingSampler instance =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    final long expectedSamples = WINDOWS * SAMPLES_PER_WINDOW;\n+\n+    long samples = 0L;\n+\n+    final double[] totalEventsPerWindow = new double[WINDOWS];\n+    final double[] sampledEventsPerWindow = new double[WINDOWS];\n+    final double[] sampleIndexSkewPerWindow = new double[WINDOWS];\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final List<Integer> sampleIndices = new ArrayList<>();\n+      final long samplesBase = samples;\n+      final int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalEventsPerWindow[w] = events;\n+      sampledEventsPerWindow[w] =\n+          (1 - abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      final double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+      sampleIndexSkewPerWindow[w] = events != 0 ? sampleIndexMean / events : 0;\n+      rollWindow();\n+    }\n+    final double sampledEventsPerWindowMean = MEAN.evaluate(sampledEventsPerWindow);\n+    final double sampledEventsPerWindowStddev =\n+        STANDARD_DEVIATION.evaluate(sampledEventsPerWindow, sampledEventsPerWindowMean);\n+    final double totalEventsPerWindowMean = MEAN.evaluate(totalEventsPerWindow);\n+\n+    final double correctionFactor =\n+        min(((totalEventsPerWindowMean * WINDOWS) / expectedSamples), 1);\n+    final double targetSamples = expectedSamples * correctionFactor;\n+    final double percentualError = round(((targetSamples - samples) / targetSamples) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;", "originalCommit": "9458fa8a6a10e6e7a362744d758473887e03ce5f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\nindex 06056acb2e..ae07ea9d48 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java\n\n@@ -1,7 +1,6 @@\n package com.datadog.profiling.exceptions;\n \n import static java.lang.Math.abs;\n-import static java.lang.Math.min;\n import static java.lang.Math.round;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n"}}, {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e", "url": "https://github.com/DataDog/dd-trace-java/commit/3b485fbe522292d4361bcc32f323bdf372a1029e", "message": "Improve test structure and add comments", "committedDate": "2020-04-15T10:29:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0ODQ0NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410348444", "bodyText": "This isn't really doing anything different from ClassLoaderMatcher.hasClassesNamed().  I don't think you can get a resource from the bootstrap classpath...", "author": "tylerbenson", "createdAt": "2020-04-17T16:53:23Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.", "originalCommit": "3b485fbe522292d4361bcc32f323bdf372a1029e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2Mjg1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410362851", "bodyText": "ClassLoaderMatcher.hasClassNamed() does not event try to use ClassLoader.getSystemClassLoader() - bottom line, I was not able to make ClassLoaderMatcher.hasClassNamed() work and tracked that down to \n  \n    \n      dd-trace-java/dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/ClassLoaderMatcher.java\n    \n    \n         Line 135\n      in\n      5aeca66\n    \n    \n    \n    \n\n        \n          \n           if (cl == BOOTSTRAP_CLASSLOADER) {", "author": "jbachorik", "createdAt": "2020-04-17T17:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0ODQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex b710bbd040..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,11 +1,15 @@\n package datadog.exceptions.instrumentation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.is;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410351365", "bodyText": "Can you add a defaultEnabled class returning false (to disable by default) or at least hasJfr?", "author": "tylerbenson", "createdAt": "2020-04-17T16:58:36Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {", "originalCommit": "3b485fbe522292d4361bcc32f323bdf372a1029e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MjM3Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411262377", "bodyText": "Well, the idea was to have this instrumentation on by default if JFR was available.\n@thegreystone Any comments?", "author": "jbachorik", "createdAt": "2020-04-20T10:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI4NTgyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411285827", "bodyText": "The whole point of subsampling the exceptions is that we want it enabled by default.", "author": "thegreystone", "createdAt": "2020-04-20T10:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI4NjU2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411286567", "bodyText": "That said, if the profiler isn't enabled, it can of course be disabled.", "author": "thegreystone", "createdAt": "2020-04-20T11:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5NDYyMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411394621", "bodyText": "Yes, I understand you want it enabled by default, but often times with high impact instrumentation we disable by default in one release, allow customers to validate it, then enable it by default in a subsequent release.", "author": "tylerbenson", "createdAt": "2020-04-20T13:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex b710bbd040..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,11 +1,15 @@\n package datadog.exceptions.instrumentation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.is;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352102", "bodyText": "static import ElementMatchers.* and change to a ternary?", "author": "tylerbenson", "createdAt": "2020-04-17T16:59:58Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();", "originalCommit": "3b485fbe522292d4361bcc32f323bdf372a1029e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE3OTkwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411179908", "bodyText": "I used to be yelled at for doing a wildcard import :) But sure, why not?", "author": "jbachorik", "createdAt": "2020-04-20T08:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5MDQwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411290400", "bodyText": "I think our default setting still replaces static imports with specific one, so although I'd agree  with using static imports more, I'm not sure about wildcard imports - mainly from the perspective that it will be noise in somebody elses commit when it will be replaced...", "author": "mar-kolya", "createdAt": "2020-04-20T11:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzODU5NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411338595", "bodyText": "Ok, I added the static imports.\nBut conversion to ternary is problematic - in short, javac type inference for ternary operator is rather stupid and will fail to infer the correct type, leading to unchecked cast etc. IMO, having and explicit if is the lesser evil (especially since the ternary form would be compiled down to the same bytecode).", "author": "jbachorik", "createdAt": "2020-04-20T12:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5OTQwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411399407", "bodyText": "sorry for the confusion... I didn't want actual wildcard imports, I just phrased it this way in the review under the assumption it would be replaced automatically to non-wildcard.\nEither way, this isn't a big deal, but thanks for looking into it.", "author": "tylerbenson", "createdAt": "2020-04-20T13:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex b710bbd040..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,11 +1,15 @@\n package datadog.exceptions.instrumentation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.is;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjQzOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352438", "bodyText": "Same suggestion here... (static import and ternary)", "author": "tylerbenson", "createdAt": "2020-04-17T17:00:32Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    if (hasJfr) {\n+      return Collections.singletonMap(\n+          isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");\n+    }\n+    return Collections.emptyMap();", "originalCommit": "3b485fbe522292d4361bcc32f323bdf372a1029e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex b710bbd040..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,11 +1,15 @@\n package datadog.exceptions.instrumentation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.is;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjkzMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352933", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");\n          \n          \n            \n                      isConstructor(), packageName + \".ExceptionAdvice\");", "author": "tylerbenson", "createdAt": "2020-04-17T17:01:30Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    if (hasJfr) {\n+      return Collections.singletonMap(\n+          isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");", "originalCommit": "3b485fbe522292d4361bcc32f323bdf372a1029e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex b710bbd040..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,11 +1,15 @@\n package datadog.exceptions.instrumentation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.is;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410356902", "bodyText": "Since this doesn't have the java 7 compatibility requirement, should this use LongAdder instead?", "author": "tylerbenson", "createdAt": "2020-04-17T17:09:38Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();", "originalCommit": "3b485fbe522292d4361bcc32f323bdf372a1029e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NTMwMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410365303", "bodyText": "Yes. Possible.", "author": "jbachorik", "createdAt": "2020-04-17T17:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0ODIyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411348222", "bodyText": "Actually, in order to improve the 'first hit' behavior it is necessary for this to stay AtomicLong", "author": "jbachorik", "createdAt": "2020-04-20T12:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQwMzQ5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411403496", "bodyText": "I'm not familiar with that problem.  Could you elaborate?", "author": "tylerbenson", "createdAt": "2020-04-20T14:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQwODU2NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411408564", "bodyText": "LongAdder.increment() does not return neither the previous or the current value - mostly because of how it is internally implemented, keeping thread local separate data buckets which will get combined only when LongAdder.sum() is called. Combining the separate data buckets is not particularly cheap and should not be done too often.\nBut in order to improve the 'first hit' precision I need to be able to get the counter value before the increment. This is impossible to do with LongAdder in any sane way.", "author": "jbachorik", "createdAt": "2020-04-20T14:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\nindex aef0162041..07eeec785c 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\n\n@@ -8,8 +8,19 @@ import lombok.extern.slf4j.Slf4j;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.LongAdder;\n import java.util.stream.Stream;\n \n+/**\n+ * A simple exception type histogram implementation.<br>\n+ * It tracks a fixed number of exception types and for each of them it keeps the number of instances created since\n+ * the last {@linkplain ExceptionHistogram#emit()} call (or creating a new {@linkplain ExceptionHistogram} instance\n+ * if {@linkplain ExceptionHistogram#emit()} hasn't been called yet).<br>\n+ *\n+ * An {@linkplain ExceptionHistogram} instance is registered with JFR to call {@linkplain ExceptionHistogram#emit()}\n+ * method at chunk end, as specified in {@linkplain ExceptionCountEvent} class. This callback will then emit a number\n+ * of {@linkplain ExceptionCountEvent} events.\n+ */\n @Slf4j\n public class ExceptionHistogram {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1ODA5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410358097", "bodyText": "I think a class comment here would be helpful.", "author": "tylerbenson", "createdAt": "2020-04-17T17:11:53Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {", "originalCommit": "3b485fbe522292d4361bcc32f323bdf372a1029e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\nindex aef0162041..07eeec785c 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\n\n@@ -8,8 +8,19 @@ import lombok.extern.slf4j.Slf4j;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.LongAdder;\n import java.util.stream.Stream;\n \n+/**\n+ * A simple exception type histogram implementation.<br>\n+ * It tracks a fixed number of exception types and for each of them it keeps the number of instances created since\n+ * the last {@linkplain ExceptionHistogram#emit()} call (or creating a new {@linkplain ExceptionHistogram} instance\n+ * if {@linkplain ExceptionHistogram#emit()} hasn't been called yet).<br>\n+ *\n+ * An {@linkplain ExceptionHistogram} instance is registered with JFR to call {@linkplain ExceptionHistogram#emit()}\n+ * method at chunk end, as specified in {@linkplain ExceptionCountEvent} class. This callback will then emit a number\n+ * of {@linkplain ExceptionCountEvent} events.\n+ */\n @Slf4j\n public class ExceptionHistogram {\n \n"}}, {"oid": "62ead6ed0dfa653dd1cf5226b171e74db8db0e7b", "url": "https://github.com/DataDog/dd-trace-java/commit/62ead6ed0dfa653dd1cf5226b171e74db8db0e7b", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler\n\n# Conflicts:\n#\tdd-smoke-tests/profiling-integration-tests/src/main/java/datadog/smoketest/profiling/ProfilingTestApplication.java\n#\tdd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy\n#\tgradle/dependencies.gradle", "committedDate": "2020-04-20T10:07:18Z", "type": "commit"}, {"oid": "9e4a69fe9b89e063aaa27e3a1ba6bf1c08740228", "url": "https://github.com/DataDog/dd-trace-java/commit/9e4a69fe9b89e063aaa27e3a1ba6bf1c08740228", "message": "Update dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\nCo-Authored-By: Tyler Benson <tyler.benson@datadoghq.com>", "committedDate": "2020-04-20T10:18:58Z", "type": "commit"}, {"oid": "0806f03b9172bbe4d897d9409285048c28263030", "url": "https://github.com/DataDog/dd-trace-java/commit/0806f03b9172bbe4d897d9409285048c28263030", "message": "Improve docs and test coverage of ExceptionHistogram", "committedDate": "2020-04-20T12:24:11Z", "type": "commit"}, {"oid": "cfde6e32fb0f5b6170e8ed6124c53f678c6e2ea4", "url": "https://github.com/DataDog/dd-trace-java/commit/cfde6e32fb0f5b6170e8ed6124c53f678c6e2ea4", "message": "Add static imports for ElementMatchers", "committedDate": "2020-04-20T12:31:57Z", "type": "commit"}, {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a", "url": "https://github.com/DataDog/dd-trace-java/commit/6d2c32779b5fcedaa8355245a2700324d0d85b3a", "message": "PROF-581: Add exception sampling event\n\nIn order to reduce the number of exception events which can become quite overwhelming a statistical sampling is employed to pick semi-random exceptions and generate events only for those. The sampling rate is adaptive and ensures that the number of events in an average recording will converge to a finite, not very large number.", "committedDate": "2020-03-05T16:51:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyODU5Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389028593", "bodyText": "I think generally style of this repo avoids shortened variable names like this - and I feel it would be easy on everybody if style is preserved :)", "author": "mar-kolya", "createdAt": "2020-03-06T17:06:12Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);", "originalCommit": "6d2c32779b5fcedaa8355245a2700324d0d85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNzYxNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389037617", "bodyText": "\ud83d\udc4d", "author": "jbachorik", "createdAt": "2020-03-06T17:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyODU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java\nindex 5f0a7bf106..be3f2b0817 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java\n\n@@ -1,15 +1,27 @@\n package datadog.exceptions.instrumentation;\n \n-import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n-import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import com.datadog.profiling.exceptions.ExceptionProfiling;\n+import com.datadog.profiling.exceptions.ExceptionSampleEvent;\n import net.bytebuddy.asm.Advice;\n \n public class ExceptionAdvice {\n   @Advice.OnMethodExit(suppress = Throwable.class)\n   public static void onExit(@Advice.This final Exception e) {\n-    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n-    if (ese != null && ese.shouldCommit()) {\n-      ese.commit();\n+    /*\n+     * We may get into a situation when this is called before ExceptionProfiling had a chance\n+     * to fully initialize. So despite the fact that this returns static singleton this may\n+     * return null sometimes.\n+     */\n+    if (ExceptionProfiling.getInstance() == null) {\n+      return;\n+    }\n+    /*\n+     * JFR will assign the stacktrace depending on the place where the event is committed.\n+     * Therefore we need to commit the event here, right in the 'Exception' constructor\n+     */\n+    final ExceptionSampleEvent event = ExceptionProfiling.getInstance().process(e);\n+    if (event != null && event.shouldCommit()) {\n+      event.commit();\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMDE1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389030156", "bodyText": "I have a strong feeling you should not need this and you should be able to use ExceptionEventSampler from advice directly.", "author": "mar-kolya", "createdAt": "2020-03-06T17:09:10Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package datadog.exceptions.jfr;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionEventSampler;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+\n+/**\n+ * A simple accessor bridge implementation.\n+ * {@linkplain datadog.exceptions.instrumentation.ExceptionAdvice} can only access classes declared by {@linkplain Instrumenter.Default#helperClassNames()}\n+ * but these helper classes are loaded per the instrumented class classloader - hence it may be loaded multiple times.\n+ * However, the {@linkplain ExceptionEventSampler} instance must be a singleton within the context of JVM. Therefore it is\n+ * not possible to use that class directly as a helper and it needs to be accessed via this bridge.\n+ */\n+public class ExceptionEventSamplerBridge {", "originalCommit": "6d2c32779b5fcedaa8355245a2700324d0d85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNzg1Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389037857", "bodyText": "I will re-check. I had problems using that class and that's why I came up with the bridge.", "author": "jbachorik", "createdAt": "2020-03-06T17:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMDE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NTkyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389085922", "bodyText": "Ok. It is gone. Not sure what exactly was my problem when I tried that originally but now the helper class from bootstrap behaves as expected and there is no more need for the extra bridge class.", "author": "jbachorik", "createdAt": "2020-03-06T19:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMDE1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java\ndeleted file mode 100644\nindex 7285c51b5b..0000000000\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java\n+++ /dev/null\n\n@@ -1,18 +0,0 @@\n-package datadog.exceptions.jfr;\n-\n-import datadog.trace.agent.tooling.Instrumenter;\n-import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionEventSampler;\n-import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n-\n-/**\n- * A simple accessor bridge implementation.\n- * {@linkplain datadog.exceptions.instrumentation.ExceptionAdvice} can only access classes declared by {@linkplain Instrumenter.Default#helperClassNames()}\n- * but these helper classes are loaded per the instrumented class classloader - hence it may be loaded multiple times.\n- * However, the {@linkplain ExceptionEventSampler} instance must be a singleton within the context of JVM. Therefore it is\n- * not possible to use that class directly as a helper and it needs to be accessed via this bridge.\n- */\n-public class ExceptionEventSamplerBridge {\n-  public static ExceptionSampleEvent sample(Exception e) {\n-    return ExceptionEventSampler.sample(e);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMzA4MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389033081", "bodyText": "Could you please make sure you follow settings in https://github.com/DataDog/dd-trace-java/blob/master/CONTRIBUTING.md to avoid stray changes when someone else edits this code.", "author": "mar-kolya", "createdAt": "2020-03-06T17:14:49Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;", "originalCommit": "6d2c32779b5fcedaa8355245a2700324d0d85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2OTI4OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390969288", "bodyText": "Done. However, the recommended 'On Save' action is applying different formatting than Google java format so I now need to re-run googleJavaFormat task before each commit to revert unwanted format changes :/", "author": "jbachorik", "createdAt": "2020-03-11T13:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMzA4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex c6a890b65f..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,40 +1,83 @@\n package datadog.exceptions.instrumentation;\n \n-import static net.bytebuddy.matcher.ElementMatchers.*;\n+import static net.bytebuddy.matcher.ElementMatchers.is;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n import net.bytebuddy.matcher.ElementMatchers;\n \n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n @AutoService(Instrumenter.class)\n-public class ExceptionInstrumentation extends Instrumenter.Default {\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n   public ExceptionInstrumentation() {\n     super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n   }\n \n   @Override\n-  protected boolean defaultEnabled() {\n-    return true;\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n   }\n \n   @Override\n   public ElementMatcher<? super TypeDescription> typeMatcher() {\n-    return ElementMatchers.is(Exception.class);\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return is(Exception.class);\n+    }\n+    return none();\n   }\n \n   @Override\n   public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    return Collections.singletonMap(\n-        isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");\n+    if (hasJfr) {\n+      return Collections.singletonMap(\n+          isConstructor(), packageName + \".ExceptionAdvice\");\n+    }\n+    return Collections.emptyMap();\n   }\n \n   @Override\n-  public String[] helperClassNames() {\n-    return new String[] {\"datadog.exceptions.jfr.ExceptionEventSamplerBridge\"};\n+  protected boolean defaultEnabled() {\n+    return hasJfr && Config.get().isProfilingEnabled();\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389035308", "bodyText": "I think it may not make sense to split sampling (and event creation) into one place and commit into another...\nYou might as well put the whole thing into ExceptionEventSampler.sample(e) - and potentially rename it accordingly.", "author": "mar-kolya", "createdAt": "2020-03-06T17:19:12Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n+    if (ese != null && ese.shouldCommit()) {\n+      ese.commit();\n+    }", "originalCommit": "6d2c32779b5fcedaa8355245a2700324d0d85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzODUwOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389038509", "bodyText": "In fact you can take this further and make different implementations of ExceptionEventSampler.sample(e) that are 'JVM-agnostic' and use correct one...\nThis way ur instrumentation will not depend on any non java7 classes directly - and among other things will not produce odd exceptions when run under java7", "author": "mar-kolya", "createdAt": "2020-03-06T17:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzODU1OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389038559", "bodyText": "Yeah, started with that. Unfortunately, JFR fills in the stacktrace at the place where the event is committed. When I did that in the sampler I had misleading stacktraces so I had to split it like this :(", "author": "jbachorik", "createdAt": "2020-03-06T17:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0MDc4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389040785", "bodyText": "Would you mind commenting that for posterity?", "author": "mar-kolya", "createdAt": "2020-03-06T17:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0MzAxMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389043011", "bodyText": "Sure. It is not really clear why it must done as it is ...", "author": "jbachorik", "createdAt": "2020-03-06T17:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java\nindex 5f0a7bf106..be3f2b0817 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java\n\n@@ -1,15 +1,27 @@\n package datadog.exceptions.instrumentation;\n \n-import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n-import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import com.datadog.profiling.exceptions.ExceptionProfiling;\n+import com.datadog.profiling.exceptions.ExceptionSampleEvent;\n import net.bytebuddy.asm.Advice;\n \n public class ExceptionAdvice {\n   @Advice.OnMethodExit(suppress = Throwable.class)\n   public static void onExit(@Advice.This final Exception e) {\n-    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n-    if (ese != null && ese.shouldCommit()) {\n-      ese.commit();\n+    /*\n+     * We may get into a situation when this is called before ExceptionProfiling had a chance\n+     * to fully initialize. So despite the fact that this returns static singleton this may\n+     * return null sometimes.\n+     */\n+    if (ExceptionProfiling.getInstance() == null) {\n+      return;\n+    }\n+    /*\n+     * JFR will assign the stacktrace depending on the place where the event is committed.\n+     * Therefore we need to commit the event here, right in the 'Exception' constructor\n+     */\n+    final ExceptionSampleEvent event = ExceptionProfiling.getInstance().process(e);\n+    if (event != null && event.shouldCommit()) {\n+      event.commit();\n     }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389043854", "bodyText": "This would mean that bootstrap would need to see classes from dd-trace-ot - this seem wrong.\nInstead you may want to consider having essentially a wrapper class on bootstrap level that has a 'field' that is initialized into correct sampling implementation by initialization code in some other place - probably when apm starts up or something.", "author": "mar-kolya", "createdAt": "2020-03-06T17:35:58Z", "path": "dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package datadog.trace.bootstrap.instrumentation.jfr.exceptions;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.AdaptiveIntervalSampler;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception event sampler. Uses {@linkplain Config} class to configure a\n+ * {@linkplain AdaptiveIntervalSampler} instance using either system properties, environment or\n+ * properties override.\n+ */\n+public final class ExceptionEventSampler {\n+  private static final int TIME_WINDOW_SECS;\n+  private static final int MAX_WINDOW_SAMPLES;\n+\n+  private static final AdaptiveIntervalSampler SAMPLER;\n+  private static final int SAMPLER_INTERVAL;\n+  private static final EventType EXCEPTION_SAMPLE_EVENT_TYPE;\n+\n+  static {\n+    Config cfg = Config.get();", "originalCommit": "6d2c32779b5fcedaa8355245a2700324d0d85b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NjE4Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389046182", "bodyText": "agent-bootstrap already depends on dd-trace-api\ndependencies {\n  compile project(':dd-trace-api')\n  compile project(':dd-java-agent:agent-jfr-bootstrap')\n  compile deps.opentracing\n  compile deps.slf4j\n  compile group: 'org.slf4j', name: 'slf4j-simple', version: versions.slf4j\n  // ^ Generally a bad idea for libraries, but we're shadowing.\n}\n\nDo you think it may cause problems? I am running it in dev and there does not seem to be any errors.", "author": "jbachorik", "createdAt": "2020-03-06T17:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NDA0Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390484043", "bodyText": "Not putting the support classes to bootstrap any more.", "author": "jbachorik", "createdAt": "2020-03-10T17:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMjM3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390522376", "bodyText": "Removed from bootstrap", "author": "jbachorik", "createdAt": "2020-03-10T18:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java b/dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java\ndeleted file mode 100644\nindex e76883569f..0000000000\n--- a/dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java\n+++ /dev/null\n\n@@ -1,64 +0,0 @@\n-package datadog.trace.bootstrap.instrumentation.jfr.exceptions;\n-\n-import datadog.trace.api.Config;\n-import datadog.trace.bootstrap.AdaptiveIntervalSampler;\n-import jdk.jfr.EventType;\n-import jdk.jfr.FlightRecorder;\n-import jdk.jfr.FlightRecorderListener;\n-import jdk.jfr.Recording;\n-import jdk.jfr.RecordingState;\n-\n-/**\n- * JVM-wide singleton exception event sampler. Uses {@linkplain Config} class to configure a\n- * {@linkplain AdaptiveIntervalSampler} instance using either system properties, environment or\n- * properties override.\n- */\n-public final class ExceptionEventSampler {\n-  private static final int TIME_WINDOW_SECS;\n-  private static final int MAX_WINDOW_SAMPLES;\n-\n-  private static final AdaptiveIntervalSampler SAMPLER;\n-  private static final int SAMPLER_INTERVAL;\n-  private static final EventType EXCEPTION_SAMPLE_EVENT_TYPE;\n-\n-  static {\n-    Config cfg = Config.get();\n-    SAMPLER_INTERVAL = cfg.getProfilingExceptionSamplerInterval();\n-    TIME_WINDOW_SECS = cfg.getProfilingExceptionSamplerTimeWindow();\n-    MAX_WINDOW_SAMPLES = cfg.getProfilingExceptionSamplerMaxSamples();\n-    SAMPLER =\n-        new AdaptiveIntervalSampler(\n-            \"exceptions\", SAMPLER_INTERVAL, TIME_WINDOW_SECS * 1000, MAX_WINDOW_SAMPLES);\n-    EXCEPTION_SAMPLE_EVENT_TYPE = EventType.getEventType(ExceptionSampleEvent.class);\n-\n-    FlightRecorderListener listener =\n-        new FlightRecorderListener() {\n-          @Override\n-          public void recordingStateChanged(Recording recording) {\n-            if (recording.getState() == RecordingState.STOPPED) {\n-              SAMPLER.reset();\n-            }\n-          }\n-        };\n-    FlightRecorder.addListener(listener);\n-  }\n-\n-  public static ExceptionSampleEvent sample(Exception e) {\n-    if (EXCEPTION_SAMPLE_EVENT_TYPE.isEnabled() && SAMPLER.sample()) {\n-      return new ExceptionSampleEvent(e);\n-    }\n-    return null;\n-  }\n-\n-  public static int getInterval() {\n-    return SAMPLER_INTERVAL;\n-  }\n-\n-  public static int getMaxWindowSamples() {\n-    return MAX_WINDOW_SAMPLES;\n-  }\n-\n-  public static long getTimeWindowMs() {\n-    return TIME_WINDOW_SECS * 1000;\n-  }\n-}\n"}}, {"oid": "35e43687a950566378edcdba6256e88cadcdcb02", "url": "https://github.com/DataDog/dd-trace-java/commit/35e43687a950566378edcdba6256e88cadcdcb02", "message": "Add initial impl of exception histogram event", "committedDate": "2020-03-06T19:01:49Z", "type": "commit"}, {"oid": "54b9d41f7116ff7c16b8285f71ed1013473dc693", "url": "https://github.com/DataDog/dd-trace-java/commit/54b9d41f7116ff7c16b8285f71ed1013473dc693", "message": "Implementation cleanup", "committedDate": "2020-03-09T19:17:25Z", "type": "commit"}, {"oid": "fac58e0e03efaca4f7f5ceaec2adbbab1540f508", "url": "https://github.com/DataDog/dd-trace-java/commit/fac58e0e03efaca4f7f5ceaec2adbbab1540f508", "message": "Debugging failing integration test", "committedDate": "2020-03-10T11:24:04Z", "type": "commit"}, {"oid": "fac58e0e03efaca4f7f5ceaec2adbbab1540f508", "url": "https://github.com/DataDog/dd-trace-java/commit/fac58e0e03efaca4f7f5ceaec2adbbab1540f508", "message": "Debugging failing integration test", "committedDate": "2020-03-10T11:24:04Z", "type": "forcePushed"}, {"oid": "751897f197dfe76b558220bfdc5d139e7a22f7fb", "url": "https://github.com/DataDog/dd-trace-java/commit/751897f197dfe76b558220bfdc5d139e7a22f7fb", "message": "Restructure the code to avoid adding v.52 classes to bootstrap", "committedDate": "2020-03-10T15:55:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390462828", "bodyText": "Why Exception and not Throwable?", "author": "tylerbenson", "createdAt": "2020-03-10T16:53:20Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+  }\n+\n+  @Override\n+  protected boolean defaultEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return new String[] {\n+      \"com.datadog.profiling.exceptions.AdaptiveIntervalSampler\",\n+      \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$ValueVisitor\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$Singleton\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return ElementMatchers.is(Exception.class);", "originalCommit": "751897f197dfe76b558220bfdc5d139e7a22f7fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NDYzMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390484630", "bodyText": "We do not want to instrument Errors - we are already tracking them by the native JFR event(s)", "author": "jbachorik", "createdAt": "2020-03-10T17:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NTIzNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390485235", "bodyText": "ok.  A comment in this class to that effect might be beneficial.", "author": "tylerbenson", "createdAt": "2020-03-10T17:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgyNTMzMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390825331", "bodyText": "Comment added", "author": "jbachorik", "createdAt": "2020-03-11T09:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex 08f39c5d82..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,27 +1,40 @@\n package datadog.exceptions.instrumentation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.is;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n-import lombok.extern.slf4j.Slf4j;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n import net.bytebuddy.matcher.ElementMatchers;\n \n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n @AutoService(Instrumenter.class)\n-@Slf4j\n-public class ExceptionInstrumentation extends Instrumenter.Default {\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n   public ExceptionInstrumentation() {\n     super(\"exceptions\");\n-  }\n-\n-  @Override\n-  protected boolean defaultEnabled() {\n-    return true;\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n   }\n \n   @Override\n"}}, {"oid": "1ebcf717d1f3ed13961406a4d6231a959a58ffb2", "url": "https://github.com/DataDog/dd-trace-java/commit/1ebcf717d1f3ed13961406a4d6231a959a58ffb2", "message": "Appease muzzle and lower the chance of intermittent failure in adaptive sampler test", "committedDate": "2020-03-10T17:19:34Z", "type": "commit"}, {"oid": "a92597e40157d774d88813ba36292ffe5d24a6e4", "url": "https://github.com/DataDog/dd-trace-java/commit/a92597e40157d774d88813ba36292ffe5d24a6e4", "message": "Do not use acronyms as variable names", "committedDate": "2020-03-10T17:23:02Z", "type": "commit"}, {"oid": "600c3d8933d7d90a74dc5945aba6c47cad2fde46", "url": "https://github.com/DataDog/dd-trace-java/commit/600c3d8933d7d90a74dc5945aba6c47cad2fde46", "message": "Add comment about java.lang.Exception instrumentation", "committedDate": "2020-03-10T17:34:53Z", "type": "commit"}, {"oid": "048bcb514bd72f8dc2927fe6026cfc18a343e061", "url": "https://github.com/DataDog/dd-trace-java/commit/048bcb514bd72f8dc2927fe6026cfc18a343e061", "message": "Formatting changes", "committedDate": "2020-03-10T17:36:27Z", "type": "commit"}, {"oid": "60b496a3e3b03b864019d50f4fffcd1eef201671", "url": "https://github.com/DataDog/dd-trace-java/commit/60b496a3e3b03b864019d50f4fffcd1eef201671", "message": "Disable AdaptiveIntervalSamplerTest in CI", "committedDate": "2020-03-10T18:01:38Z", "type": "commit"}, {"oid": "cbcfe5e1f5fb07e9e4d3730a6407110897f603fa", "url": "https://github.com/DataDog/dd-trace-java/commit/cbcfe5e1f5fb07e9e4d3730a6407110897f603fa", "message": "Update docs", "committedDate": "2020-03-11T09:07:20Z", "type": "commit"}, {"oid": "33359432ff42293c7aea81ea1bafba993bf021f2", "url": "https://github.com/DataDog/dd-trace-java/commit/33359432ff42293c7aea81ea1bafba993bf021f2", "message": "Impose hard limit on number of samples", "committedDate": "2020-03-11T09:34:53Z", "type": "commit"}, {"oid": "fd37c07c8a800ff85770c17575411bd5e2bea102", "url": "https://github.com/DataDog/dd-trace-java/commit/fd37c07c8a800ff85770c17575411bd5e2bea102", "message": "Formatting changes", "committedDate": "2020-03-11T09:39:48Z", "type": "commit"}, {"oid": "568b50978d76134f1a902c1c512102507687faec", "url": "https://github.com/DataDog/dd-trace-java/commit/568b50978d76134f1a902c1c512102507687faec", "message": "Simplify the exception profiling enablement checks", "committedDate": "2020-03-11T10:19:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3MDUxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394470514", "bodyText": "I do not think other options are using similar suffixes... you may want to drop it and just have a comment for now. After this is released we will just update docs.", "author": "mar-kolya", "createdAt": "2020-03-18T16:15:14Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -127,6 +127,13 @@\n   public static final String PROFILING_PROXY_PORT = \"profiling.proxy.port\";\n   public static final String PROFILING_PROXY_USERNAME = \"profiling.proxy.username\";\n   public static final String PROFILING_PROXY_PASSWORD = \"profiling.proxy.password\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_INTERVAL =\n+      \"profiling.exception-sampler.interval\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_MAX_SAMPLES =\n+      \"profiling.exception-sampler.max-samples\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_TIME_WINDOW =\n+      \"profiling.exception-sampler.time-window.sec\";", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAxODM5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398018396", "bodyText": "Done", "author": "jbachorik", "createdAt": "2020-03-25T17:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3MDUxNA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/Config.java b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\nindex f1d9c04219..326f0f973b 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n\n@@ -127,20 +141,20 @@ public class Config {\n   public static final String PROFILING_PROXY_PORT = \"profiling.proxy.port\";\n   public static final String PROFILING_PROXY_USERNAME = \"profiling.proxy.username\";\n   public static final String PROFILING_PROXY_PASSWORD = \"profiling.proxy.password\";\n-  public static final String PROFILING_EXCEPTION_SAMPLER_INTERVAL =\n-      \"profiling.exception-sampler.interval\";\n-  public static final String PROFILING_EXCEPTION_SAMPLER_MAX_SAMPLES =\n-      \"profiling.exception-sampler.max-samples\";\n-  public static final String PROFILING_EXCEPTION_SAMPLER_TIME_WINDOW =\n-      \"profiling.exception-sampler.time-window.sec\";\n-  public static final String PROFILING_EXCEPTION_HISTO_MAX = \"profiling.exception-hist.max\";\n+  public static final String PROFILING_EXCEPTION_SAMPLE_LIMIT = \"profiling.exception.sample.limit\";\n+  public static final String PROFILING_EXCEPTION_HISTOGRAM_TOP_ITEMS =\n+      \"profiling.exception.histogram.top-items\";\n+  public static final String PROFILING_EXCEPTION_HISTOGRAM_MAX_COLLECTION_SIZE =\n+      \"profiling.exception.histogram.max-collection-size\";\n \n   public static final String RUNTIME_ID_TAG = \"runtime-id\";\n-  public static final String SERVICE_TAG = \"service\";\n+  public static final String SERVICE = \"service\";\n+  public static final String SERVICE_TAG = SERVICE;\n   public static final String HOST_TAG = \"host\";\n   public static final String LANGUAGE_TAG_KEY = \"language\";\n   public static final String LANGUAGE_TAG_VALUE = \"jvm\";\n \n+  public static final String DEFAULT_SITE = \"datadoghq.com\";\n   public static final String DEFAULT_SERVICE_NAME = \"unnamed-java-app\";\n \n   private static final boolean DEFAULT_TRACE_ENABLED = true;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTIxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394481214", "bodyText": "Blowing up in advice might not be a very good strategy... Would it be possible to gracefully skip exception handling instead?", "author": "mar-kolya", "createdAt": "2020-03-18T16:30:29Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {\n+    ExceptionProfiling.config = config;\n+  }\n+\n+  /**\n+   * Get a pre-configured shared instance. !!! BEFORE FIRST CALL OF THIS METHOD {@linkplain\n+   * ExceptionProfiling#init(Config)} MUST HAVE BEEN INVOKED\n+   *\n+   * @return the shared instance\n+   * @throws NullPointerException if {@linkplain ExceptionProfiling#init(Config)} has not been\n+   *     called yet\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    assert config != null;", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4OTkwNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394489905", "bodyText": "IDK. The idea was that this should blow up during development or staging, etc. - since it is depending solely on calling init(config) in right order. If it is silently ignored there is a good chance no one will ever inspect the logs and notice that we exception profiling is not working because of this.", "author": "jbachorik", "createdAt": "2020-03-18T16:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMzA2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394523067", "bodyText": "We should have integration test that verifies that exception events are being written. This assertion is likely (and hopefully) ignored by @Advice.OnMethodExit(suppress = Throwable.class) - so as things currently stay I do not think it is useful anyway...", "author": "mar-kolya", "createdAt": "2020-03-18T17:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java\ndeleted file mode 100644\nindex a205d030f0..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java\n+++ /dev/null\n\n@@ -1,82 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import datadog.trace.api.Config;\n-import jdk.jfr.FlightRecorder;\n-import jdk.jfr.FlightRecorderListener;\n-import jdk.jfr.Recording;\n-import jdk.jfr.RecordingState;\n-\n-/**\n- * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n- * itself using either system properties, environment or properties override.\n- */\n-public final class ExceptionProfiling {\n-  private static volatile Config config = null;\n-\n-  private static final class Singleton {\n-    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n-  }\n-\n-  /**\n-   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n-   * - otherwise that call will crash\n-   *\n-   * @param config the system configuration\n-   */\n-  public static void init(final Config config) {\n-    ExceptionProfiling.config = config;\n-  }\n-\n-  /**\n-   * Get a pre-configured shared instance. !!! BEFORE FIRST CALL OF THIS METHOD {@linkplain\n-   * ExceptionProfiling#init(Config)} MUST HAVE BEEN INVOKED\n-   *\n-   * @return the shared instance\n-   * @throws NullPointerException if {@linkplain ExceptionProfiling#init(Config)} has not been\n-   *     called yet\n-   */\n-  public static ExceptionProfiling getInstance() {\n-    assert config != null;\n-    return ExceptionProfiling.Singleton.INSTANCE;\n-  }\n-\n-  private final ExceptionHistogram histogram;\n-  private final ExceptionSampler sampler;\n-\n-  private ExceptionProfiling() {\n-    this(new ExceptionSampler(config), new ExceptionHistogram(config));\n-  }\n-\n-  ExceptionProfiling(final ExceptionSampler sampler, final ExceptionHistogram histogram) {\n-    this.sampler = sampler;\n-    this.histogram = histogram;\n-\n-    FlightRecorder.addListener(\n-        new FlightRecorderListener() {\n-          @Override\n-          public void recordingStateChanged(final Recording recording) {\n-            if (recording.getState() == RecordingState.STOPPED) {\n-              sampler.reset();\n-            }\n-          }\n-        });\n-  }\n-\n-  public ExceptionSampleEvent process(final Exception e) {\n-    // always record the exception in histogram\n-    final boolean firstHit = histogram.record(e);\n-\n-    if (sampler.isEnabled()) {\n-      /*\n-       * If the histogram hasn't contained that particular exception type up till now then 'firstHit' == true\n-       * and the sample event should be emitted regardless of the sampling result.\n-       * We need a non-short-circuiting OR such that 'sampler.sample()' is called regardless of value\n-       * of 'firstHit'.\n-       */\n-      if (firstHit | sampler.sample()) {\n-        return new ExceptionSampleEvent(e);\n-      }\n-    }\n-    return null;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394482612", "bodyText": "Do you need this statically separately? Presumably you have a singleton instance - can you have non static config there and have a non static init method?", "author": "mar-kolya", "createdAt": "2020-03-18T16:32:35Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDE0Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394484146", "bodyText": "I think if you make this non static you can get rid off Singleton class", "author": "mar-kolya", "createdAt": "2020-03-18T16:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MzcxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394493715", "bodyText": "IDK - I need to configure it in the controller and use from advice - and it needs to be a JVM wide singleton there. From my experiments it seems that Config is not accessible from the advice.", "author": "jbachorik", "createdAt": "2020-03-18T16:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyNDQyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394524420", "bodyText": "ExceptionProfiling.getInstance().process(e) in advice and ExceptionProfiling.getInstance().init(config) in controller should get you there, no?\nYou do not need to store reference to config when calling init - you can fetch and store values...", "author": "mar-kolya", "createdAt": "2020-03-18T17:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java\ndeleted file mode 100644\nindex a205d030f0..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java\n+++ /dev/null\n\n@@ -1,82 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import datadog.trace.api.Config;\n-import jdk.jfr.FlightRecorder;\n-import jdk.jfr.FlightRecorderListener;\n-import jdk.jfr.Recording;\n-import jdk.jfr.RecordingState;\n-\n-/**\n- * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n- * itself using either system properties, environment or properties override.\n- */\n-public final class ExceptionProfiling {\n-  private static volatile Config config = null;\n-\n-  private static final class Singleton {\n-    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n-  }\n-\n-  /**\n-   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n-   * - otherwise that call will crash\n-   *\n-   * @param config the system configuration\n-   */\n-  public static void init(final Config config) {\n-    ExceptionProfiling.config = config;\n-  }\n-\n-  /**\n-   * Get a pre-configured shared instance. !!! BEFORE FIRST CALL OF THIS METHOD {@linkplain\n-   * ExceptionProfiling#init(Config)} MUST HAVE BEEN INVOKED\n-   *\n-   * @return the shared instance\n-   * @throws NullPointerException if {@linkplain ExceptionProfiling#init(Config)} has not been\n-   *     called yet\n-   */\n-  public static ExceptionProfiling getInstance() {\n-    assert config != null;\n-    return ExceptionProfiling.Singleton.INSTANCE;\n-  }\n-\n-  private final ExceptionHistogram histogram;\n-  private final ExceptionSampler sampler;\n-\n-  private ExceptionProfiling() {\n-    this(new ExceptionSampler(config), new ExceptionHistogram(config));\n-  }\n-\n-  ExceptionProfiling(final ExceptionSampler sampler, final ExceptionHistogram histogram) {\n-    this.sampler = sampler;\n-    this.histogram = histogram;\n-\n-    FlightRecorder.addListener(\n-        new FlightRecorderListener() {\n-          @Override\n-          public void recordingStateChanged(final Recording recording) {\n-            if (recording.getState() == RecordingState.STOPPED) {\n-              sampler.reset();\n-            }\n-          }\n-        });\n-  }\n-\n-  public ExceptionSampleEvent process(final Exception e) {\n-    // always record the exception in histogram\n-    final boolean firstHit = histogram.record(e);\n-\n-    if (sampler.isEnabled()) {\n-      /*\n-       * If the histogram hasn't contained that particular exception type up till now then 'firstHit' == true\n-       * and the sample event should be emitted regardless of the sampling result.\n-       * We need a non-short-circuiting OR such that 'sampler.sample()' is called regardless of value\n-       * of 'firstHit'.\n-       */\n-      if (firstHit | sampler.sample()) {\n-        return new ExceptionSampleEvent(e);\n-      }\n-    }\n-    return null;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDY1NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394484654", "bodyText": "Having hashes of unlimited size may be problematic... You may want to consider putting hard limit on this somehow.", "author": "mar-kolya", "createdAt": "2020-03-18T16:35:35Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NzQ3Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394487472", "bodyText": "Ok. Realistically, there should not be more than few thousands of entries but I will take a look at putting a hard limit there.", "author": "jbachorik", "createdAt": "2020-03-18T16:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDY1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMTkwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394521908", "bodyText": "We've had structures blowing out of control in the past - this affects apps and is hard to debug on client side - so best to avoid, maybe with some careful debug logging...", "author": "mar-kolya", "createdAt": "2020-03-18T17:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java\ndeleted file mode 100644\nindex 3280004921..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import datadog.trace.api.Config;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.LongAdder;\n-import java.util.stream.Stream;\n-import jdk.jfr.EventType;\n-import jdk.jfr.FlightRecorder;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public class ExceptionHistogram {\n-  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();\n-  private final EventType exceptionCountEventType;\n-  private final int maxTopItems;\n-  private final boolean forceEnabled;\n-\n-  @FunctionalInterface\n-  interface ValueVisitor {\n-    void visit(String key, long value);\n-  }\n-\n-  ExceptionHistogram(Config config) {\n-    this(config.getProfilingExceptionHistoMax(), false);\n-  }\n-\n-  ExceptionHistogram(int maxTopItems, boolean forceEnabled) {\n-    this.maxTopItems = maxTopItems;\n-    this.exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n-    this.forceEnabled = forceEnabled;\n-\n-    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n-  }\n-\n-  private void emit() {\n-    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n-      processAndReset(this::newExceptionCountEvent);\n-    }\n-  }\n-\n-  private void newExceptionCountEvent(String type, long count) {\n-    ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n-    if (event.shouldCommit()) {\n-      event.commit();\n-    }\n-  }\n-\n-  public boolean record(Exception exception) {\n-    if (exception == null) {\n-      return false;\n-    }\n-    return record(exception.getClass().getCanonicalName());\n-  }\n-\n-  boolean record(String typeName) {\n-    if (typeName == null) {\n-      return false;\n-    }\n-    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n-      final boolean[] firstHit = new boolean[] {false};\n-      histoMap\n-          .computeIfAbsent(\n-              typeName,\n-              k -> {\n-                try {\n-                  return new LongAdder();\n-                } finally {\n-                  firstHit[0] = true;\n-                }\n-              })\n-          .increment();\n-\n-      return firstHit[0];\n-    }\n-    return false;\n-  }\n-\n-  void processAndReset(ValueVisitor processor) {\n-    Stream<Map.Entry<String, Long>> items =\n-        histoMap\n-            .entrySet()\n-            .stream()\n-            .map(e -> entry(e.getKey(), e.getValue().sumThenReset()))\n-            .filter(e -> e.getValue() != 0)\n-            .sorted((e1, e2) -> Long.compare(e2.getValue(), e1.getValue()));\n-    if (maxTopItems > 0) {\n-      items = items.limit(maxTopItems);\n-    }\n-    items.forEach(e -> processor.visit(e.getKey(), e.getValue()));\n-  }\n-\n-  private static <K, V> Map.Entry<K, V> entry(K key, V value) {\n-    return new Map.Entry<K, V>() {\n-      @Override\n-      public K getKey() {\n-        return key;\n-      }\n-\n-      @Override\n-      public V getValue() {\n-        return value;\n-      }\n-\n-      @Override\n-      public V setValue(V v) {\n-        return value;\n-      }\n-    };\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NTY0OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394485648", "bodyText": "I was under impression this should be done in advice because otherwise event will have strange callstack. Has this changed?", "author": "mar-kolya", "createdAt": "2020-03-18T16:37:07Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();\n+  private final EventType exceptionCountEventType;\n+  private final int maxTopItems;\n+  private final boolean forceEnabled;\n+\n+  @FunctionalInterface\n+  interface ValueVisitor {\n+    void visit(String key, long value);\n+  }\n+\n+  ExceptionHistogram(Config config) {\n+    this(config.getProfilingExceptionHistoMax(), false);\n+  }\n+\n+  ExceptionHistogram(int maxTopItems, boolean forceEnabled) {\n+    this.maxTopItems = maxTopItems;\n+    this.exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    this.forceEnabled = forceEnabled;\n+\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n+  }\n+\n+  private void emit() {\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      processAndReset(this::newExceptionCountEvent);\n+    }\n+  }\n+\n+  private void newExceptionCountEvent(String type, long count) {\n+    ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n+    if (event.shouldCommit()) {\n+      event.commit();", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4Njc0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394486740", "bodyText": "This is ok since this particular event is not collecting stack trace.\nOnly events with stack traces are sensitive to the location of commit", "author": "jbachorik", "createdAt": "2020-03-18T16:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxMDk2MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394510960", "bodyText": "nm", "author": "mar-kolya", "createdAt": "2020-03-18T17:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NTY0OA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java\ndeleted file mode 100644\nindex 3280004921..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import datadog.trace.api.Config;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.LongAdder;\n-import java.util.stream.Stream;\n-import jdk.jfr.EventType;\n-import jdk.jfr.FlightRecorder;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public class ExceptionHistogram {\n-  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();\n-  private final EventType exceptionCountEventType;\n-  private final int maxTopItems;\n-  private final boolean forceEnabled;\n-\n-  @FunctionalInterface\n-  interface ValueVisitor {\n-    void visit(String key, long value);\n-  }\n-\n-  ExceptionHistogram(Config config) {\n-    this(config.getProfilingExceptionHistoMax(), false);\n-  }\n-\n-  ExceptionHistogram(int maxTopItems, boolean forceEnabled) {\n-    this.maxTopItems = maxTopItems;\n-    this.exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n-    this.forceEnabled = forceEnabled;\n-\n-    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n-  }\n-\n-  private void emit() {\n-    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n-      processAndReset(this::newExceptionCountEvent);\n-    }\n-  }\n-\n-  private void newExceptionCountEvent(String type, long count) {\n-    ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n-    if (event.shouldCommit()) {\n-      event.commit();\n-    }\n-  }\n-\n-  public boolean record(Exception exception) {\n-    if (exception == null) {\n-      return false;\n-    }\n-    return record(exception.getClass().getCanonicalName());\n-  }\n-\n-  boolean record(String typeName) {\n-    if (typeName == null) {\n-      return false;\n-    }\n-    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n-      final boolean[] firstHit = new boolean[] {false};\n-      histoMap\n-          .computeIfAbsent(\n-              typeName,\n-              k -> {\n-                try {\n-                  return new LongAdder();\n-                } finally {\n-                  firstHit[0] = true;\n-                }\n-              })\n-          .increment();\n-\n-      return firstHit[0];\n-    }\n-    return false;\n-  }\n-\n-  void processAndReset(ValueVisitor processor) {\n-    Stream<Map.Entry<String, Long>> items =\n-        histoMap\n-            .entrySet()\n-            .stream()\n-            .map(e -> entry(e.getKey(), e.getValue().sumThenReset()))\n-            .filter(e -> e.getValue() != 0)\n-            .sorted((e1, e2) -> Long.compare(e2.getValue(), e1.getValue()));\n-    if (maxTopItems > 0) {\n-      items = items.limit(maxTopItems);\n-    }\n-    items.forEach(e -> processor.visit(e.getKey(), e.getValue()));\n-  }\n-\n-  private static <K, V> Map.Entry<K, V> entry(K key, V value) {\n-    return new Map.Entry<K, V>() {\n-      @Override\n-      public K getKey() {\n-        return key;\n-      }\n-\n-      @Override\n-      public V getValue() {\n-        return value;\n-      }\n-\n-      @Override\n-      public V setValue(V v) {\n-        return value;\n-      }\n-    };\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MTc5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394491797", "bodyText": "It would be really nice to have javadoc here explaining what this does", "author": "mar-kolya", "createdAt": "2020-03-18T16:46:09Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\ndeleted file mode 100644\nindex 7f41ffcdad..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\n+++ /dev/null\n\n@@ -1,105 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public final class AdaptiveIntervalSampler {\n-  private final double stdDev;\n-  private final String id;\n-  private final int minInterval;\n-  private long interval;\n-  private final long timeWindowNs;\n-  private final long maxSamples;\n-  private final long targetSamples;\n-  private volatile long counterTop = 0L;\n-  private final AtomicLong counter;\n-  private long ts = System.nanoTime();\n-  private long sampleCounter = 0L;\n-  private final int dummyMultiplier = 1;\n-\n-  public AdaptiveIntervalSampler(\n-      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n-    this(id, minInterval, 50, timeWindowMs, maxSamples);\n-  }\n-\n-  public AdaptiveIntervalSampler(\n-      final String id,\n-      final int minInterval,\n-      final int stdDevPercent,\n-      final long timeWindowMs,\n-      final long maxSamples) {\n-    this.id = id;\n-    this.minInterval = minInterval;\n-    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n-    interval = minInterval;\n-    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n-    this.maxSamples = maxSamples;\n-    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n-    // that here\n-    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n-    counterTop = expectedHits(interval);\n-    counter = new AtomicLong(counterTop);\n-  }\n-\n-  private long expectedHits(final long interval) {\n-    return Math.max(\n-        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n-  }\n-\n-  public void reset() {\n-    log.debug(\"Sampler reset [id: {}]\", id);\n-    interval = minInterval;\n-    sampleCounter = 0L;\n-    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n-    counterTop = counterTop * dummyMultiplier;\n-  }\n-\n-  public boolean sample() {\n-    /*\n-     * All changes done by other threads before writing to 'counterTop' will be visible after this\n-     * line\n-     */\n-    long currentTop = counterTop;\n-    if (sampleCounter >= maxSamples) {\n-      // hit the hard limit; no more samples\n-      return false;\n-    }\n-    final long currentCnt = counter.decrementAndGet();\n-\n-    if (currentCnt % currentTop == 0L) {\n-      final long ts1 = System.nanoTime();\n-      // all changes done by other threads before writing to 'ts' will be visible after this line\n-      final long tDiff = ts1 - ts;\n-      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n-      final double intervalScale = projectedSamplesCnt / maxSamples;\n-      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n-      // calculate interval diff in a way it does not swing wildly\n-      final long intervalDiff =\n-          newInterval == interval\n-              ? 0\n-              : Math.round(\n-                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n-      interval = interval + intervalDiff;\n-      // write to counterTop makes all previous changes to shared data visible after counterTop is\n-      // read by other threads\n-      currentTop = expectedHits(interval);\n-      counter.addAndGet(counterTop);\n-      sampleCounter++;\n-      ts = ts1;\n-      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n-      // other\n-      // threads\n-      counterTop = currentTop;\n-\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  public String getId() {\n-    return id;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5NDA3NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394494074", "bodyText": "Stylewise I feel like keeping mutable fields separate form immutable makes things easier to understand.", "author": "mar-kolya", "createdAt": "2020-03-18T16:49:31Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\ndeleted file mode 100644\nindex 7f41ffcdad..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\n+++ /dev/null\n\n@@ -1,105 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public final class AdaptiveIntervalSampler {\n-  private final double stdDev;\n-  private final String id;\n-  private final int minInterval;\n-  private long interval;\n-  private final long timeWindowNs;\n-  private final long maxSamples;\n-  private final long targetSamples;\n-  private volatile long counterTop = 0L;\n-  private final AtomicLong counter;\n-  private long ts = System.nanoTime();\n-  private long sampleCounter = 0L;\n-  private final int dummyMultiplier = 1;\n-\n-  public AdaptiveIntervalSampler(\n-      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n-    this(id, minInterval, 50, timeWindowMs, maxSamples);\n-  }\n-\n-  public AdaptiveIntervalSampler(\n-      final String id,\n-      final int minInterval,\n-      final int stdDevPercent,\n-      final long timeWindowMs,\n-      final long maxSamples) {\n-    this.id = id;\n-    this.minInterval = minInterval;\n-    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n-    interval = minInterval;\n-    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n-    this.maxSamples = maxSamples;\n-    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n-    // that here\n-    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n-    counterTop = expectedHits(interval);\n-    counter = new AtomicLong(counterTop);\n-  }\n-\n-  private long expectedHits(final long interval) {\n-    return Math.max(\n-        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n-  }\n-\n-  public void reset() {\n-    log.debug(\"Sampler reset [id: {}]\", id);\n-    interval = minInterval;\n-    sampleCounter = 0L;\n-    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n-    counterTop = counterTop * dummyMultiplier;\n-  }\n-\n-  public boolean sample() {\n-    /*\n-     * All changes done by other threads before writing to 'counterTop' will be visible after this\n-     * line\n-     */\n-    long currentTop = counterTop;\n-    if (sampleCounter >= maxSamples) {\n-      // hit the hard limit; no more samples\n-      return false;\n-    }\n-    final long currentCnt = counter.decrementAndGet();\n-\n-    if (currentCnt % currentTop == 0L) {\n-      final long ts1 = System.nanoTime();\n-      // all changes done by other threads before writing to 'ts' will be visible after this line\n-      final long tDiff = ts1 - ts;\n-      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n-      final double intervalScale = projectedSamplesCnt / maxSamples;\n-      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n-      // calculate interval diff in a way it does not swing wildly\n-      final long intervalDiff =\n-          newInterval == interval\n-              ? 0\n-              : Math.round(\n-                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n-      interval = interval + intervalDiff;\n-      // write to counterTop makes all previous changes to shared data visible after counterTop is\n-      // read by other threads\n-      currentTop = expectedHits(interval);\n-      counter.addAndGet(counterTop);\n-      sampleCounter++;\n-      ts = ts1;\n-      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n-      // other\n-      // threads\n-      counterTop = currentTop;\n-\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  public String getId() {\n-    return id;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5OTQ5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394499497", "bodyText": "This doesn't seem to be used. Do you really need this?", "author": "mar-kolya", "createdAt": "2020-03-18T16:57:17Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }\n+    final long currentCnt = counter.decrementAndGet();\n+\n+    if (currentCnt % currentTop == 0L) {\n+      final long ts1 = System.nanoTime();\n+      // all changes done by other threads before writing to 'ts' will be visible after this line\n+      final long tDiff = ts1 - ts;\n+      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n+      final double intervalScale = projectedSamplesCnt / maxSamples;\n+      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n+      // calculate interval diff in a way it does not swing wildly\n+      final long intervalDiff =\n+          newInterval == interval\n+              ? 0\n+              : Math.round(\n+                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n+      interval = interval + intervalDiff;\n+      // write to counterTop makes all previous changes to shared data visible after counterTop is\n+      // read by other threads\n+      currentTop = expectedHits(interval);\n+      counter.addAndGet(counterTop);\n+      sampleCounter++;\n+      ts = ts1;\n+      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n+      // other\n+      // threads\n+      counterTop = currentTop;\n+\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  public String getId() {", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\ndeleted file mode 100644\nindex 7f41ffcdad..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\n+++ /dev/null\n\n@@ -1,105 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public final class AdaptiveIntervalSampler {\n-  private final double stdDev;\n-  private final String id;\n-  private final int minInterval;\n-  private long interval;\n-  private final long timeWindowNs;\n-  private final long maxSamples;\n-  private final long targetSamples;\n-  private volatile long counterTop = 0L;\n-  private final AtomicLong counter;\n-  private long ts = System.nanoTime();\n-  private long sampleCounter = 0L;\n-  private final int dummyMultiplier = 1;\n-\n-  public AdaptiveIntervalSampler(\n-      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n-    this(id, minInterval, 50, timeWindowMs, maxSamples);\n-  }\n-\n-  public AdaptiveIntervalSampler(\n-      final String id,\n-      final int minInterval,\n-      final int stdDevPercent,\n-      final long timeWindowMs,\n-      final long maxSamples) {\n-    this.id = id;\n-    this.minInterval = minInterval;\n-    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n-    interval = minInterval;\n-    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n-    this.maxSamples = maxSamples;\n-    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n-    // that here\n-    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n-    counterTop = expectedHits(interval);\n-    counter = new AtomicLong(counterTop);\n-  }\n-\n-  private long expectedHits(final long interval) {\n-    return Math.max(\n-        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n-  }\n-\n-  public void reset() {\n-    log.debug(\"Sampler reset [id: {}]\", id);\n-    interval = minInterval;\n-    sampleCounter = 0L;\n-    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n-    counterTop = counterTop * dummyMultiplier;\n-  }\n-\n-  public boolean sample() {\n-    /*\n-     * All changes done by other threads before writing to 'counterTop' will be visible after this\n-     * line\n-     */\n-    long currentTop = counterTop;\n-    if (sampleCounter >= maxSamples) {\n-      // hit the hard limit; no more samples\n-      return false;\n-    }\n-    final long currentCnt = counter.decrementAndGet();\n-\n-    if (currentCnt % currentTop == 0L) {\n-      final long ts1 = System.nanoTime();\n-      // all changes done by other threads before writing to 'ts' will be visible after this line\n-      final long tDiff = ts1 - ts;\n-      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n-      final double intervalScale = projectedSamplesCnt / maxSamples;\n-      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n-      // calculate interval diff in a way it does not swing wildly\n-      final long intervalDiff =\n-          newInterval == interval\n-              ? 0\n-              : Math.round(\n-                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n-      interval = interval + intervalDiff;\n-      // write to counterTop makes all previous changes to shared data visible after counterTop is\n-      // read by other threads\n-      currentTop = expectedHits(interval);\n-      counter.addAndGet(counterTop);\n-      sampleCounter++;\n-      ts = ts1;\n-      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n-      // other\n-      // threads\n-      counterTop = currentTop;\n-\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  public String getId() {\n-    return id;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNDM2NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394504365", "bodyText": "is this comment correct? you are not writing to counterTop here", "author": "mar-kolya", "createdAt": "2020-03-18T17:04:33Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }\n+    final long currentCnt = counter.decrementAndGet();\n+\n+    if (currentCnt % currentTop == 0L) {\n+      final long ts1 = System.nanoTime();\n+      // all changes done by other threads before writing to 'ts' will be visible after this line\n+      final long tDiff = ts1 - ts;\n+      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n+      final double intervalScale = projectedSamplesCnt / maxSamples;\n+      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n+      // calculate interval diff in a way it does not swing wildly\n+      final long intervalDiff =\n+          newInterval == interval\n+              ? 0\n+              : Math.round(\n+                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n+      interval = interval + intervalDiff;\n+      // write to counterTop makes all previous changes to shared data visible after counterTop is\n+      // read by other threads", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwOTI2Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394509262", "bodyText": "It is correct. It is explaining the connection between reading and writing to counterTop. I was pondering adding the line number of the write but then decided not do that as each change to the source file would render the comment incorrect.", "author": "jbachorik", "createdAt": "2020-03-18T17:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNDM2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMTM3MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394521371", "bodyText": "The way it is worded is still confusing (and on top of that variable naming currrentTop and counterTop is easy to misread... I'd suggest rewording this somehow. You do not have to reference specific line, you can say something like 'belowm when counterTop is saved` or something like that.", "author": "mar-kolya", "createdAt": "2020-03-18T17:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNDM2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\ndeleted file mode 100644\nindex 7f41ffcdad..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\n+++ /dev/null\n\n@@ -1,105 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public final class AdaptiveIntervalSampler {\n-  private final double stdDev;\n-  private final String id;\n-  private final int minInterval;\n-  private long interval;\n-  private final long timeWindowNs;\n-  private final long maxSamples;\n-  private final long targetSamples;\n-  private volatile long counterTop = 0L;\n-  private final AtomicLong counter;\n-  private long ts = System.nanoTime();\n-  private long sampleCounter = 0L;\n-  private final int dummyMultiplier = 1;\n-\n-  public AdaptiveIntervalSampler(\n-      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n-    this(id, minInterval, 50, timeWindowMs, maxSamples);\n-  }\n-\n-  public AdaptiveIntervalSampler(\n-      final String id,\n-      final int minInterval,\n-      final int stdDevPercent,\n-      final long timeWindowMs,\n-      final long maxSamples) {\n-    this.id = id;\n-    this.minInterval = minInterval;\n-    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n-    interval = minInterval;\n-    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n-    this.maxSamples = maxSamples;\n-    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n-    // that here\n-    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n-    counterTop = expectedHits(interval);\n-    counter = new AtomicLong(counterTop);\n-  }\n-\n-  private long expectedHits(final long interval) {\n-    return Math.max(\n-        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n-  }\n-\n-  public void reset() {\n-    log.debug(\"Sampler reset [id: {}]\", id);\n-    interval = minInterval;\n-    sampleCounter = 0L;\n-    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n-    counterTop = counterTop * dummyMultiplier;\n-  }\n-\n-  public boolean sample() {\n-    /*\n-     * All changes done by other threads before writing to 'counterTop' will be visible after this\n-     * line\n-     */\n-    long currentTop = counterTop;\n-    if (sampleCounter >= maxSamples) {\n-      // hit the hard limit; no more samples\n-      return false;\n-    }\n-    final long currentCnt = counter.decrementAndGet();\n-\n-    if (currentCnt % currentTop == 0L) {\n-      final long ts1 = System.nanoTime();\n-      // all changes done by other threads before writing to 'ts' will be visible after this line\n-      final long tDiff = ts1 - ts;\n-      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n-      final double intervalScale = projectedSamplesCnt / maxSamples;\n-      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n-      // calculate interval diff in a way it does not swing wildly\n-      final long intervalDiff =\n-          newInterval == interval\n-              ? 0\n-              : Math.round(\n-                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n-      interval = interval + intervalDiff;\n-      // write to counterTop makes all previous changes to shared data visible after counterTop is\n-      // read by other threads\n-      currentTop = expectedHits(interval);\n-      counter.addAndGet(counterTop);\n-      sampleCounter++;\n-      ts = ts1;\n-      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n-      // other\n-      // threads\n-      counterTop = currentTop;\n-\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  public String getId() {\n-    return id;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxMjM1NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394512354", "bodyText": "Wouldn't this short circuit prevent you from properly scaling sampling interval?", "author": "mar-kolya", "createdAt": "2020-03-18T17:17:03Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\ndeleted file mode 100644\nindex 7f41ffcdad..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\n+++ /dev/null\n\n@@ -1,105 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public final class AdaptiveIntervalSampler {\n-  private final double stdDev;\n-  private final String id;\n-  private final int minInterval;\n-  private long interval;\n-  private final long timeWindowNs;\n-  private final long maxSamples;\n-  private final long targetSamples;\n-  private volatile long counterTop = 0L;\n-  private final AtomicLong counter;\n-  private long ts = System.nanoTime();\n-  private long sampleCounter = 0L;\n-  private final int dummyMultiplier = 1;\n-\n-  public AdaptiveIntervalSampler(\n-      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n-    this(id, minInterval, 50, timeWindowMs, maxSamples);\n-  }\n-\n-  public AdaptiveIntervalSampler(\n-      final String id,\n-      final int minInterval,\n-      final int stdDevPercent,\n-      final long timeWindowMs,\n-      final long maxSamples) {\n-    this.id = id;\n-    this.minInterval = minInterval;\n-    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n-    interval = minInterval;\n-    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n-    this.maxSamples = maxSamples;\n-    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n-    // that here\n-    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n-    counterTop = expectedHits(interval);\n-    counter = new AtomicLong(counterTop);\n-  }\n-\n-  private long expectedHits(final long interval) {\n-    return Math.max(\n-        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n-  }\n-\n-  public void reset() {\n-    log.debug(\"Sampler reset [id: {}]\", id);\n-    interval = minInterval;\n-    sampleCounter = 0L;\n-    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n-    counterTop = counterTop * dummyMultiplier;\n-  }\n-\n-  public boolean sample() {\n-    /*\n-     * All changes done by other threads before writing to 'counterTop' will be visible after this\n-     * line\n-     */\n-    long currentTop = counterTop;\n-    if (sampleCounter >= maxSamples) {\n-      // hit the hard limit; no more samples\n-      return false;\n-    }\n-    final long currentCnt = counter.decrementAndGet();\n-\n-    if (currentCnt % currentTop == 0L) {\n-      final long ts1 = System.nanoTime();\n-      // all changes done by other threads before writing to 'ts' will be visible after this line\n-      final long tDiff = ts1 - ts;\n-      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n-      final double intervalScale = projectedSamplesCnt / maxSamples;\n-      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n-      // calculate interval diff in a way it does not swing wildly\n-      final long intervalDiff =\n-          newInterval == interval\n-              ? 0\n-              : Math.round(\n-                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n-      interval = interval + intervalDiff;\n-      // write to counterTop makes all previous changes to shared data visible after counterTop is\n-      // read by other threads\n-      currentTop = expectedHits(interval);\n-      counter.addAndGet(counterTop);\n-      sampleCounter++;\n-      ts = ts1;\n-      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n-      // other\n-      // threads\n-      counterTop = currentTop;\n-\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  public String getId() {\n-    return id;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3ODAwMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394978001", "bodyText": "As discussed offline: there might be a simpler approach to just keep expected number of exceptions per window and then randomly sample each exception with probability based on expected number of exceptions and target number of exceptions.", "author": "mar-kolya", "createdAt": "2020-03-19T12:07:09Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\ndeleted file mode 100644\nindex 7f41ffcdad..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java\n+++ /dev/null\n\n@@ -1,105 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public final class AdaptiveIntervalSampler {\n-  private final double stdDev;\n-  private final String id;\n-  private final int minInterval;\n-  private long interval;\n-  private final long timeWindowNs;\n-  private final long maxSamples;\n-  private final long targetSamples;\n-  private volatile long counterTop = 0L;\n-  private final AtomicLong counter;\n-  private long ts = System.nanoTime();\n-  private long sampleCounter = 0L;\n-  private final int dummyMultiplier = 1;\n-\n-  public AdaptiveIntervalSampler(\n-      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n-    this(id, minInterval, 50, timeWindowMs, maxSamples);\n-  }\n-\n-  public AdaptiveIntervalSampler(\n-      final String id,\n-      final int minInterval,\n-      final int stdDevPercent,\n-      final long timeWindowMs,\n-      final long maxSamples) {\n-    this.id = id;\n-    this.minInterval = minInterval;\n-    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n-    interval = minInterval;\n-    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n-    this.maxSamples = maxSamples;\n-    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n-    // that here\n-    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n-    counterTop = expectedHits(interval);\n-    counter = new AtomicLong(counterTop);\n-  }\n-\n-  private long expectedHits(final long interval) {\n-    return Math.max(\n-        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n-  }\n-\n-  public void reset() {\n-    log.debug(\"Sampler reset [id: {}]\", id);\n-    interval = minInterval;\n-    sampleCounter = 0L;\n-    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n-    counterTop = counterTop * dummyMultiplier;\n-  }\n-\n-  public boolean sample() {\n-    /*\n-     * All changes done by other threads before writing to 'counterTop' will be visible after this\n-     * line\n-     */\n-    long currentTop = counterTop;\n-    if (sampleCounter >= maxSamples) {\n-      // hit the hard limit; no more samples\n-      return false;\n-    }\n-    final long currentCnt = counter.decrementAndGet();\n-\n-    if (currentCnt % currentTop == 0L) {\n-      final long ts1 = System.nanoTime();\n-      // all changes done by other threads before writing to 'ts' will be visible after this line\n-      final long tDiff = ts1 - ts;\n-      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n-      final double intervalScale = projectedSamplesCnt / maxSamples;\n-      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n-      // calculate interval diff in a way it does not swing wildly\n-      final long intervalDiff =\n-          newInterval == interval\n-              ? 0\n-              : Math.round(\n-                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n-      interval = interval + intervalDiff;\n-      // write to counterTop makes all previous changes to shared data visible after counterTop is\n-      // read by other threads\n-      currentTop = expectedHits(interval);\n-      counter.addAndGet(counterTop);\n-      sampleCounter++;\n-      ts = ts1;\n-      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n-      // other\n-      // threads\n-      counterTop = currentTop;\n-\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  public String getId() {\n-    return id;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4MTQyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394981425", "bodyText": "Please consider using smoke test framework for this, see ProfilingTestApplication as an example.", "author": "mar-kolya", "createdAt": "2020-03-19T12:13:52Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/groovy/JfrHelper.java", "diffHunk": "@@ -0,0 +1,28 @@\n+import com.datadog.profiling.exceptions.ExceptionSampleEvent;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+public class JfrHelper {", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/test/groovy/JfrHelper.java b/dd-java-agent/instrumentation/exception-profiling/src/test/groovy/JfrHelper.java\ndeleted file mode 100644\nindex 08aa8d7530..0000000000\n--- a/dd-java-agent/instrumentation/exception-profiling/src/test/groovy/JfrHelper.java\n+++ /dev/null\n\n@@ -1,28 +0,0 @@\n-import com.datadog.profiling.exceptions.ExceptionSampleEvent;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.List;\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordingFile;\n-\n-public class JfrHelper {\n-\n-  public static Object startRecording() {\n-    final Recording recording = new Recording();\n-    recording.enable(ExceptionSampleEvent.class);\n-    recording.start();\n-    return recording;\n-  }\n-\n-  public static List<?> stopRecording(final Object object) throws IOException {\n-    final Recording recording = (Recording) object;\n-    final Path output = Files.createTempFile(\"recording\", \".jfr\");\n-    output.toFile().deleteOnExit();\n-    recording.dump(output);\n-    recording.stop();\n-    recording.close();\n-\n-    return RecordingFile.readAllEvents(output);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4NTQxNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394985417", "bodyText": "The thing here is that we compile event classes and supporting code for java11 bytecode so for JDK 8 with backported jfr we will attempt to load java11 classes into java8", "author": "mar-kolya", "createdAt": "2020-03-19T12:21:57Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    boolean jfr = false;\n+    try {\n+      /* Check only for the open-sources JFR implementation.\n+       * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+       * enhanced\n+       */\n+      Class.forName(\"jdk.jfr.Event\");\n+      jfr = true;\n+    } catch (ClassNotFoundException ignored) {\n+    }\n+    hasJfr = jfr;", "originalCommit": "568b50978d76134f1a902c1c512102507687faec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\nindex 3f8c295e96..bf34ddf529 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\n@@ -1,46 +1,40 @@\n package datadog.exceptions.instrumentation;\n \n+import static net.bytebuddy.matcher.ElementMatchers.is;\n import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.none;\n \n import com.google.auto.service.AutoService;\n import datadog.trace.agent.tooling.Instrumenter;\n import java.util.Collections;\n import java.util.Map;\n-import lombok.extern.slf4j.Slf4j;\n+\n+import datadog.trace.api.Config;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n import net.bytebuddy.matcher.ElementMatchers;\n \n-@AutoService(Instrumenter.class)\n-@Slf4j\n /**\n  * Provides instrumentation of {@linkplain Exception} constructor. <br>\n  * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n  * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n  * already.\n  */\n-public class ExceptionInstrumentation extends Instrumenter.Default {\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n   private final boolean hasJfr;\n \n   public ExceptionInstrumentation() {\n     super(\"exceptions\");\n-    boolean jfr = false;\n-    try {\n-      /* Check only for the open-sources JFR implementation.\n-       * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n-       * enhanced\n-       */\n-      Class.forName(\"jdk.jfr.Event\");\n-      jfr = true;\n-    } catch (ClassNotFoundException ignored) {\n-    }\n-    hasJfr = jfr;\n-  }\n-\n-  @Override\n-  protected boolean defaultEnabled() {\n-    return true;\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n   }\n \n   @Override\n"}}, {"oid": "10b269b046ba34c00f4c7899e727bf7e506230fd", "url": "https://github.com/DataDog/dd-trace-java/commit/10b269b046ba34c00f4c7899e727bf7e506230fd", "message": "Replace adaptive sampler with a streaming sampler implementation.", "committedDate": "2020-03-20T13:46:11Z", "type": "commit"}, {"oid": "569cfa3ccc90e32b0c881700236ddd59552b75b3", "url": "https://github.com/DataDog/dd-trace-java/commit/569cfa3ccc90e32b0c881700236ddd59552b75b3", "message": "Add exception sampling to profiling smoke test", "committedDate": "2020-03-20T16:28:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQyOTk3MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396429970", "bodyText": "Is this change intentional?", "author": "mar-kolya", "createdAt": "2020-03-23T12:57:17Z", "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/OpenJdkController.java", "diffHunk": "@@ -42,15 +43,16 @@\n    * <p>This has to be public because it is created via reflection\n    */\n   public OpenJdkController(final Config config)\n-      throws ConfigurationException, ClassNotFoundException {\n+    throws ConfigurationException, ClassNotFoundException {\n+    System.err.println(\"===> OpenJDKController start\");", "originalCommit": "569cfa3ccc90e32b0c881700236ddd59552b75b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/OpenJdkController.java b/dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/OpenJdkController.java\nindex 985b2e62cd..2ef23018e9 100644\n--- a/dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/OpenJdkController.java\n+++ b/dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/OpenJdkController.java\n\n@@ -43,8 +42,7 @@ public final class OpenJdkController implements Controller {\n    * <p>This has to be public because it is created via reflection\n    */\n   public OpenJdkController(final Config config)\n-    throws ConfigurationException, ClassNotFoundException {\n-    System.err.println(\"===> OpenJDKController start\");\n+      throws ConfigurationException, ClassNotFoundException {\n     // Make sure we can load JFR classes before declaring that we have successfully created\n     // factory and can use it.\n     Class.forName(\"jdk.jfr.Recording\");\n"}}, {"oid": "88bab1eeb8ab2e6d699b1c00618c208d640fbefe", "url": "https://github.com/DataDog/dd-trace-java/commit/88bab1eeb8ab2e6d699b1c00618c208d640fbefe", "message": "Truncate exception histogram map on chunk rotation", "committedDate": "2020-03-23T17:55:27Z", "type": "commit"}, {"oid": "a1dd7269de36549a60b327d050f71f4054ce9e8e", "url": "https://github.com/DataDog/dd-trace-java/commit/a1dd7269de36549a60b327d050f71f4054ce9e8e", "message": "Remove debug output", "committedDate": "2020-03-23T18:01:45Z", "type": "commit"}, {"oid": "41da2107f8f1a1e92a1cd05bf6324de57aa18ea6", "url": "https://github.com/DataDog/dd-trace-java/commit/41da2107f8f1a1e92a1cd05bf6324de57aa18ea6", "message": "Change the sampler implementation to CDF based", "committedDate": "2020-03-23T18:02:54Z", "type": "commit"}, {"oid": "33944845f3ba2a299c8359a879244acada65d4f8", "url": "https://github.com/DataDog/dd-trace-java/commit/33944845f3ba2a299c8359a879244acada65d4f8", "message": "Add ZULU8 support", "committedDate": "2020-03-23T18:03:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396747814", "bodyText": "Don't know if it helps but you can precompute newThreshold outside of synchronized block as it seems to rely on local values (if I am not mistaken) and do only the if and the 2 updates of long in the synchronized blocks.\nThe other approach will be: if SampleCount and threshold can fit into Integers, you can pack them into only one Long and to a single CAS ensuring atomicity :)\nBut in any cases should be proven that sync block is a real bottleneck :)", "author": "jpbempel", "createdAt": "2020-03-23T20:50:04Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -2,78 +2,167 @@\n \n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.LongAdder;\n import java.util.function.Supplier;\n \n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. Because of very non-trivial nature of this task given the hard limit on samples and the\n+ * sampler being non-remembering the actual implementation is just an approximation. It is using\n+ * rather short 'sampling windows' (few seconds at max) during which at most N samples will be\n+ * taken. This allows for predictability of the number of samples after a certain period of time T\n+ * has elapsed ~ (T / W) * N, where W is the sampling window duration.\n+ *\n+ * <p>The sampler is using exponential CDF as a base for random probing, adjusted in a way that the\n+ * probability of the <b>hit</b> goes to 0 rapidly once the sample limit was hit. The 'lambda'\n+ * parameter of the exponential distribution (or rate) is adjusted from window to window to better\n+ * reflect the expected rate considering the number of events per the sampling window and the sample\n+ * limit. Using this trick it is possible to slightly compensate for the samples being skewed,\n+ * favoring the earlier events.\n+ */\n public class StreamingSampler {\n-  private static final int SCALE = 10_000;\n+  /** Using scale to avoid floating point comparisons */\n+  private static final long SCALE = 10_000_000L;\n \n-  private final long slidingWindowDuration;\n-  private final int slidingWindowSize;\n+  private final long samplingWindowDuration;\n+  private final int samplingWindowSize;\n \n   private final Supplier<Long> timeStampSupplier;\n   private final LongAdder hitCounter = new LongAdder();\n-  private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-  private final AtomicLong slidingWindowEndTsRef;\n-  private final AtomicInteger thresholdRef;\n+  private final AtomicLong samplingWindowEndTsRef;\n+  private final AtomicLong thresholdRef;\n \n+  private long lambda;\n+  private volatile long sampleCounter = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   */\n   public StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize) {\n-    this(slidingWindowDuration, slidingWindowUnit, slidingWindowSize, System::nanoTime);\n+      final int maxSamplesInWindow) {\n+    this(samplingWindowDuration, slidingWindowUnit, maxSamplesInWindow, System::nanoTime);\n   }\n \n   StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize,\n+      final int samplingWindowSize,\n       final Supplier<Long> timeStampSupplier) {\n-    this.slidingWindowDuration =\n-        TimeUnit.NANOSECONDS.convert(slidingWindowDuration, slidingWindowUnit);\n-    this.slidingWindowSize = slidingWindowSize;\n-    slidingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.slidingWindowDuration);\n-    thresholdRef = new AtomicInteger(Math.round((1f / slidingWindowSize) * SCALE));\n+    this.samplingWindowDuration =\n+        TimeUnit.NANOSECONDS.convert(samplingWindowDuration, slidingWindowUnit);\n+    this.samplingWindowSize = samplingWindowSize;\n+    samplingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.samplingWindowDuration);\n+    lambda = 10;\n+    thresholdRef = new AtomicLong(computeThreshold(0, lambda));\n     this.timeStampSupplier = timeStampSupplier;\n   }\n \n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n   public boolean sample() {\n-    hitCounter.increment();\n-    final int threshold = thresholdRef.get();\n     boolean result = false;\n+    hitCounter.increment();\n+    final long threshold = thresholdRef.get();\n+    final long s = sampleCounter;\n     if (test(threshold)) {\n-      final long samples = sampleCounter.incrementAndGet();\n-      thresholdRef.getAndUpdate(v -> v == threshold ? getNextThreshold(samples, v) : v);\n-      result = true;\n+      long newSampleCount = -1;\n+      long newThreshold = -1;\n+      /*\n+       * Trying to do this completely lock-free leads to a very complex code which tends to blow up the hard limits.\n+       * Let's just do the sane thing and put the critical block, which is kept very minimal, into synchronized section.\n+       * For our purposes the crucial part is making sure we haven't already got sample hit for the same sample number.\n+       */\n+      synchronized (this) {\n+        if (sampleCounter == s) {\n+          newSampleCount = s + 1;\n+          newThreshold = computeThreshold(newSampleCount, lambda);\n+          thresholdRef.set(newThreshold);\n+          sampleCounter = newSampleCount;\n+          result = true;", "originalCommit": "33944845f3ba2a299c8359a879244acada65d4f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzNzU2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r397937567", "bodyText": "Well, you got me thinking and I have a solution with atomically updating sampler state working in a state machine fashion :) Looks good and no synchronization FTW :)", "author": "jbachorik", "createdAt": "2020-03-25T15:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk5ODgwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r397998807", "bodyText": "Yes, at the expense of more allocations ;-)", "author": "jpbempel", "createdAt": "2020-03-25T16:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMTEzNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398001134", "bodyText": "Yep. But we are looking at ~1-2 extra allocations per second in a sane setup - the allocation will happen only on sample or window roll. Anyway, there is nothing like a free lunch :(", "author": "jbachorik", "createdAt": "2020-03-25T16:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java\ndeleted file mode 100644\nindex ed50b06fae..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java\n+++ /dev/null\n\n@@ -1,168 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.LongAdder;\n-import java.util.function.Supplier;\n-\n-/**\n- * A streaming (non-remembering) sampler.\n- *\n- * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n- * fashion. Because of very non-trivial nature of this task given the hard limit on samples and the\n- * sampler being non-remembering the actual implementation is just an approximation. It is using\n- * rather short 'sampling windows' (few seconds at max) during which at most N samples will be\n- * taken. This allows for predictability of the number of samples after a certain period of time T\n- * has elapsed ~ (T / W) * N, where W is the sampling window duration.\n- *\n- * <p>The sampler is using exponential CDF as a base for random probing, adjusted in a way that the\n- * probability of the <b>hit</b> goes to 0 rapidly once the sample limit was hit. The 'lambda'\n- * parameter of the exponential distribution (or rate) is adjusted from window to window to better\n- * reflect the expected rate considering the number of events per the sampling window and the sample\n- * limit. Using this trick it is possible to slightly compensate for the samples being skewed,\n- * favoring the earlier events.\n- */\n-public class StreamingSampler {\n-  /** Using scale to avoid floating point comparisons */\n-  private static final long SCALE = 10_000_000L;\n-\n-  private final long samplingWindowDuration;\n-  private final int samplingWindowSize;\n-\n-  private final Supplier<Long> timeStampSupplier;\n-  private final LongAdder hitCounter = new LongAdder();\n-\n-  private final AtomicLong samplingWindowEndTsRef;\n-  private final AtomicLong thresholdRef;\n-\n-  private long lambda;\n-  private volatile long sampleCounter = 0L;\n-\n-  /**\n-   * Create a new sampler instance\n-   *\n-   * @param samplingWindowDuration the sampling window duration\n-   * @param slidingWindowUnit the time unit for the sampling window duration\n-   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n-   */\n-  public StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int maxSamplesInWindow) {\n-    this(samplingWindowDuration, slidingWindowUnit, maxSamplesInWindow, System::nanoTime);\n-  }\n-\n-  StreamingSampler(\n-      final long samplingWindowDuration,\n-      final TimeUnit slidingWindowUnit,\n-      final int samplingWindowSize,\n-      final Supplier<Long> timeStampSupplier) {\n-    this.samplingWindowDuration =\n-        TimeUnit.NANOSECONDS.convert(samplingWindowDuration, slidingWindowUnit);\n-    this.samplingWindowSize = samplingWindowSize;\n-    samplingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.samplingWindowDuration);\n-    lambda = 10;\n-    thresholdRef = new AtomicLong(computeThreshold(0, lambda));\n-    this.timeStampSupplier = timeStampSupplier;\n-  }\n-\n-  /**\n-   * Provides binary answer whether the current event is to be sampled\n-   *\n-   * @return {@literal true} if the event should be sampled\n-   */\n-  public boolean sample() {\n-    boolean result = false;\n-    hitCounter.increment();\n-    final long threshold = thresholdRef.get();\n-    final long s = sampleCounter;\n-    if (test(threshold)) {\n-      long newSampleCount = -1;\n-      long newThreshold = -1;\n-      /*\n-       * Trying to do this completely lock-free leads to a very complex code which tends to blow up the hard limits.\n-       * Let's just do the sane thing and put the critical block, which is kept very minimal, into synchronized section.\n-       * For our purposes the crucial part is making sure we haven't already got sample hit for the same sample number.\n-       */\n-      synchronized (this) {\n-        if (sampleCounter == s) {\n-          newSampleCount = s + 1;\n-          newThreshold = computeThreshold(newSampleCount, lambda);\n-          thresholdRef.set(newThreshold);\n-          sampleCounter = newSampleCount;\n-          result = true;\n-        }\n-      }\n-      // do not invoke the callback from the synchronized part to minimize time spent in locked\n-      // section\n-      if (newSampleCount != -1) {\n-        onSample(newSampleCount, threshold, newThreshold, lambda);\n-      }\n-    }\n-    tryCloseWindow(threshold);\n-    return result;\n-  }\n-\n-  private void tryCloseWindow(final long threshold) {\n-    final long ts = timeStampSupplier.get();\n-    final long tsEnd = samplingWindowEndTsRef.get();\n-    if (ts >= tsEnd) {\n-      thresholdRef.getAndUpdate(\n-          v -> {\n-            if (v == threshold) {\n-              final long hits = hitCounter.sumThenReset();\n-              if (samplingWindowEndTsRef.compareAndSet(tsEnd, ts + samplingWindowDuration)) {\n-                final long origLambda = lambda;\n-                final long newLambda = (hits - samplingWindowSize) / samplingWindowSize;\n-                synchronized (this) {\n-                  sampleCounter = 0;\n-                  lambda = newLambda;\n-                }\n-                final long newThreshold = computeThreshold(0, newLambda);\n-                onWindowEnd(threshold, newThreshold, origLambda, lambda);\n-                return newThreshold;\n-              } else {\n-                return v;\n-              }\n-            }\n-            return v;\n-          });\n-    }\n-  }\n-\n-  private long computeThreshold(final long samples, final long lambda) {\n-    // use quasi-exponential CDF to quickly converge to 0 once crossing the samplingWindowSize\n-    final double e = Math.max(1 - Math.exp((-1d * (samplingWindowSize - samples)) / lambda), 0);\n-    return Math.round(SCALE * e);\n-  }\n-\n-  private boolean test(final long value) {\n-    return ThreadLocalRandom.current().nextLong(SCALE) <= value;\n-  }\n-\n-  /**\n-   * A custom callback to observe closing of the sampling window. Mostly for debugging purposes.\n-   *\n-   * @param origThreshold threshold of the previous window\n-   * @param newThreshold threshold of the new window\n-   * @param origLambda lambda of the previous window\n-   * @param newLambda lamda of the new window\n-   */\n-  protected void onWindowEnd(\n-      final long origThreshold,\n-      final long newThreshold,\n-      final long origLambda,\n-      final long newLambda) {}\n-\n-  /**\n-   * A custom callback to observe sample event. Mostly for debugging purposes.\n-   *\n-   * @param samples the number of samples processed so far\n-   * @param origThreshold threshold used to get this sample\n-   * @param newThreshold threshold for the next sample\n-   * @param lambda the lambda used to get the sample\n-   */\n-  protected void onSample(\n-      final long samples, final long origThreshold, final long newThreshold, final long lambda) {}\n-}\n"}}, {"oid": "dd06ebd4e6cd7af210d51e71667d6db6db95a43b", "url": "https://github.com/DataDog/dd-trace-java/commit/dd06ebd4e6cd7af210d51e71667d6db6db95a43b", "message": "Multiple fixes for exception histogram\n\n* Add limit to histogram size\n* Make sure entries are removed in the same iteration they were used\n* Improve tests\n* Fix configuration object initialization\n* Add tests for new config fields", "committedDate": "2020-03-23T22:06:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NjY4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396786685", "bodyText": "This will keep entries for longer than needed. Please consider #1334", "author": "mar-kolya", "createdAt": "2020-03-23T22:09:39Z", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, AtomicLong> histoMap = new ConcurrentHashMap<>();\n+  private final EventType exceptionCountEventType;\n+  private final int maxTopItems;\n+  private final boolean forceEnabled;\n+\n+  @FunctionalInterface\n+  interface ValueVisitor {\n+    void visit(String key, long value);\n+  }\n+\n+  ExceptionHistogram(final Config config) {\n+    this(config.getProfilingExceptionHistoMax(), false);\n+  }\n+\n+  ExceptionHistogram(final int maxTopItems, final boolean forceEnabled) {\n+    this.maxTopItems = maxTopItems;\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    this.forceEnabled = forceEnabled;\n+\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n+  }\n+\n+  private void emit() {\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      processAndReset(this::newExceptionCountEvent);\n+    }\n+  }\n+\n+  private void newExceptionCountEvent(final String type, final long count) {\n+    final ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n+    if (event.shouldCommit()) {\n+      event.commit();\n+    }\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  boolean record(final String typeName) {\n+    if (typeName == null) {\n+      return false;\n+    }\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      final boolean[] firstHit = new boolean[] {false};\n+      histoMap\n+          .computeIfAbsent(\n+              typeName,\n+              k -> {\n+                try {\n+                  return new AtomicLong();\n+                } finally {\n+                  firstHit[0] = true;\n+                }\n+              })\n+          .incrementAndGet();\n+\n+      return firstHit[0];\n+    }\n+    return false;\n+  }\n+\n+  void processAndReset(final ValueVisitor processor) {\n+    Stream<Map.Entry<String, Long>> items =\n+        histoMap\n+            .entrySet()\n+            .stream()\n+            .map(e -> entry(e.getKey(), e.getValue().getAndSet(0L)))\n+            .filter(e -> e.getValue() != 0)\n+            .sorted((e1, e2) -> Long.compare(e2.getValue(), e1.getValue()));\n+    histoMap.entrySet().removeIf(e -> e.getValue().get() == 0L);", "originalCommit": "33944845f3ba2a299c8359a879244acada65d4f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java b/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java\ndeleted file mode 100644\nindex 31ad480b28..0000000000\n--- a/dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java\n+++ /dev/null\n\n@@ -1,112 +0,0 @@\n-package com.datadog.profiling.exceptions;\n-\n-import datadog.trace.api.Config;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Stream;\n-import jdk.jfr.EventType;\n-import jdk.jfr.FlightRecorder;\n-import lombok.extern.slf4j.Slf4j;\n-\n-@Slf4j\n-public class ExceptionHistogram {\n-  private final Map<String, AtomicLong> histoMap = new ConcurrentHashMap<>();\n-  private final EventType exceptionCountEventType;\n-  private final int maxTopItems;\n-  private final boolean forceEnabled;\n-\n-  @FunctionalInterface\n-  interface ValueVisitor {\n-    void visit(String key, long value);\n-  }\n-\n-  ExceptionHistogram(final Config config) {\n-    this(config.getProfilingExceptionHistoMax(), false);\n-  }\n-\n-  ExceptionHistogram(final int maxTopItems, final boolean forceEnabled) {\n-    this.maxTopItems = maxTopItems;\n-    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n-    this.forceEnabled = forceEnabled;\n-\n-    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n-  }\n-\n-  private void emit() {\n-    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n-      processAndReset(this::newExceptionCountEvent);\n-    }\n-  }\n-\n-  private void newExceptionCountEvent(final String type, final long count) {\n-    final ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n-    if (event.shouldCommit()) {\n-      event.commit();\n-    }\n-  }\n-\n-  public boolean record(final Exception exception) {\n-    if (exception == null) {\n-      return false;\n-    }\n-    return record(exception.getClass().getCanonicalName());\n-  }\n-\n-  boolean record(final String typeName) {\n-    if (typeName == null) {\n-      return false;\n-    }\n-    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n-      final boolean[] firstHit = new boolean[] {false};\n-      histoMap\n-          .computeIfAbsent(\n-              typeName,\n-              k -> {\n-                try {\n-                  return new AtomicLong();\n-                } finally {\n-                  firstHit[0] = true;\n-                }\n-              })\n-          .incrementAndGet();\n-\n-      return firstHit[0];\n-    }\n-    return false;\n-  }\n-\n-  void processAndReset(final ValueVisitor processor) {\n-    Stream<Map.Entry<String, Long>> items =\n-        histoMap\n-            .entrySet()\n-            .stream()\n-            .map(e -> entry(e.getKey(), e.getValue().getAndSet(0L)))\n-            .filter(e -> e.getValue() != 0)\n-            .sorted((e1, e2) -> Long.compare(e2.getValue(), e1.getValue()));\n-    histoMap.entrySet().removeIf(e -> e.getValue().get() == 0L);\n-    if (maxTopItems > 0) {\n-      items = items.limit(maxTopItems);\n-    }\n-    items.forEach(e -> processor.visit(e.getKey(), e.getValue()));\n-  }\n-\n-  private static <K, V> Map.Entry<K, V> entry(final K key, final V value) {\n-    return new Map.Entry<K, V>() {\n-      @Override\n-      public K getKey() {\n-        return key;\n-      }\n-\n-      @Override\n-      public V getValue() {\n-        return value;\n-      }\n-\n-      @Override\n-      public V setValue(final V v) {\n-        return value;\n-      }\n-    };\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NjkzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396786937", "bodyText": "This is wrong and test that verifies this should have been updated. Please consider #1334", "author": "mar-kolya", "createdAt": "2020-03-23T22:10:18Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -635,6 +658,20 @@ private Config(final Properties properties, final Config parent) {\n     profilingProxyPassword =\n         properties.getProperty(PROFILING_PROXY_PASSWORD, parent.profilingProxyPassword);\n \n+    profilingExceptionSamplerSlidingWindow =\n+        getPropertyIntegerValue(\n+            properties,\n+            PROFILING_EXCEPTION_SAMPLER_WINDOW,\n+            DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW);\n+    profilingExceptionSamplerSlidingWindowSamples =\n+        getPropertyIntegerValue(\n+            properties,\n+            PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES,\n+            DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES);\n+    profilingExceptionHistoMax =\n+        getPropertyIntegerValue(\n+            properties, PROFILING_EXCEPTION_HISTO_MAX, DEFAULT_PROFILING_EXCEPTION_HISTO_MAX);", "originalCommit": "33944845f3ba2a299c8359a879244acada65d4f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/Config.java b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\nindex 7216692462..326f0f973b 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/Config.java\n\n@@ -658,19 +711,20 @@ public class Config {\n     profilingProxyPassword =\n         properties.getProperty(PROFILING_PROXY_PASSWORD, parent.profilingProxyPassword);\n \n-    profilingExceptionSamplerSlidingWindow =\n+    profilingExceptionSampleLimit =\n         getPropertyIntegerValue(\n-            properties,\n-            PROFILING_EXCEPTION_SAMPLER_WINDOW,\n-            DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW);\n-    profilingExceptionSamplerSlidingWindowSamples =\n+            properties, PROFILING_EXCEPTION_SAMPLE_LIMIT, parent.profilingExceptionSampleLimit);\n+\n+    profilingExceptionHistogramTopItems =\n         getPropertyIntegerValue(\n             properties,\n-            PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES,\n-            DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES);\n-    profilingExceptionHistoMax =\n+            PROFILING_EXCEPTION_HISTOGRAM_TOP_ITEMS,\n+            parent.profilingExceptionHistogramTopItems);\n+    profilingExceptionHistogramMaxCollectionSize =\n         getPropertyIntegerValue(\n-            properties, PROFILING_EXCEPTION_HISTO_MAX, DEFAULT_PROFILING_EXCEPTION_HISTO_MAX);\n+            properties,\n+            PROFILING_EXCEPTION_HISTOGRAM_MAX_COLLECTION_SIZE,\n+            parent.profilingExceptionHistogramMaxCollectionSize);\n \n     log.debug(\"New instance: {}\", this);\n   }\n"}}, {"oid": "1c4a1c8fa65ef1d31a440b4dc99678ec0020179a", "url": "https://github.com/DataDog/dd-trace-java/commit/1c4a1c8fa65ef1d31a440b4dc99678ec0020179a", "message": "Made deregister package private", "committedDate": "2020-03-24T11:00:32Z", "type": "commit"}, {"oid": "e465dcb796d1010115774dda9729a80fc8fcdf44", "url": "https://github.com/DataDog/dd-trace-java/commit/e465dcb796d1010115774dda9729a80fc8fcdf44", "message": "Remove logging left behind by accident", "committedDate": "2020-03-24T11:01:32Z", "type": "commit"}, {"oid": "b5721f6e1edc28118e76560430322fac6f104f27", "url": "https://github.com/DataDog/dd-trace-java/commit/b5721f6e1edc28118e76560430322fac6f104f27", "message": "Count 'clipped' exceptions and provide to provide information about histogram overflow", "committedDate": "2020-03-24T11:08:25Z", "type": "commit"}, {"oid": "362006d57449f0ff57f46377f13452d6935d0b15", "url": "https://github.com/DataDog/dd-trace-java/commit/362006d57449f0ff57f46377f13452d6935d0b15", "message": "Update helper list", "committedDate": "2020-03-24T11:28:59Z", "type": "commit"}, {"oid": "88471b749c6a8a2c3ff32f142fa7465de724b927", "url": "https://github.com/DataDog/dd-trace-java/commit/88471b749c6a8a2c3ff32f142fa7465de724b927", "message": "Use enablement config for exception instrumentation", "committedDate": "2020-03-24T12:13:43Z", "type": "commit"}, {"oid": "1b619a5f6153a68bacba68077b91f3467125fae4", "url": "https://github.com/DataDog/dd-trace-java/commit/1b619a5f6153a68bacba68077b91f3467125fae4", "message": "Remove unneccessary dependency", "committedDate": "2020-03-24T12:51:23Z", "type": "commit"}, {"oid": "f8ceb258bc9dcc6a53700cf907a5b7fd69548763", "url": "https://github.com/DataDog/dd-trace-java/commit/f8ceb258bc9dcc6a53700cf907a5b7fd69548763", "message": "Make sure samplier is initialized before using it\n\nException class can be loaded and instantiated before Sampler code had\na chance to initialize. This results in advice seeing null in static\nfield - so we have to check for that.", "committedDate": "2020-03-24T12:51:32Z", "type": "commit"}, {"oid": "089ee25024525b39c5d34269f8e74d02ca99973c", "url": "https://github.com/DataDog/dd-trace-java/commit/089ee25024525b39c5d34269f8e74d02ca99973c", "message": "PROF-581: Add exception sampling event\n\nIn order to reduce the number of exception events which can become quite overwhelming a statistical sampling is employed to pick semi-random exceptions and generate events only for those. The sampling rate is adaptive and ensures that the number of events in an average recording will converge to a finite, not very large number.", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "610e4171ac6a1c8004e169c3e0724433b58e79bd", "url": "https://github.com/DataDog/dd-trace-java/commit/610e4171ac6a1c8004e169c3e0724433b58e79bd", "message": "Add initial impl of exception histogram event", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "36e9609d0eb6723df2dfba6192cffd84a6a107f8", "url": "https://github.com/DataDog/dd-trace-java/commit/36e9609d0eb6723df2dfba6192cffd84a6a107f8", "message": "Implementation cleanup", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "cb27f092710fdf6af90153fdcd7f0e5aacc3863c", "url": "https://github.com/DataDog/dd-trace-java/commit/cb27f092710fdf6af90153fdcd7f0e5aacc3863c", "message": "Debugging failing integration test", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "7f2f9dc479fe9ff2cc86f98afd2ee1af29c5fbab", "url": "https://github.com/DataDog/dd-trace-java/commit/7f2f9dc479fe9ff2cc86f98afd2ee1af29c5fbab", "message": "Restructure the code to avoid adding v.52 classes to bootstrap", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "f22b7de0b9138fa601edbe4caed379cc9bc6222c", "url": "https://github.com/DataDog/dd-trace-java/commit/f22b7de0b9138fa601edbe4caed379cc9bc6222c", "message": "Appease muzzle and lower the chance of intermittent failure in adaptive sampler test", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "003e0f37242d11a05d52941f6d0885d374edf308", "url": "https://github.com/DataDog/dd-trace-java/commit/003e0f37242d11a05d52941f6d0885d374edf308", "message": "Do not use acronyms as variable names", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "86d8a7a0a6cf24eb8a9412a424a86b3a4b2778c6", "url": "https://github.com/DataDog/dd-trace-java/commit/86d8a7a0a6cf24eb8a9412a424a86b3a4b2778c6", "message": "Add comment about java.lang.Exception instrumentation", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "55c90bd10e6d0ff0e5580a5364c4cbd9a51206ed", "url": "https://github.com/DataDog/dd-trace-java/commit/55c90bd10e6d0ff0e5580a5364c4cbd9a51206ed", "message": "Formatting changes", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "47ec13cc935aa67fe06f6b33a1d52706701fca16", "url": "https://github.com/DataDog/dd-trace-java/commit/47ec13cc935aa67fe06f6b33a1d52706701fca16", "message": "Disable AdaptiveIntervalSamplerTest in CI", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "739116dc5d274ae0666c96d6a8fdad002b6937e1", "url": "https://github.com/DataDog/dd-trace-java/commit/739116dc5d274ae0666c96d6a8fdad002b6937e1", "message": "Update docs", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "4f1e3a8996bbd2200b16700c56bd8dc39da1833c", "url": "https://github.com/DataDog/dd-trace-java/commit/4f1e3a8996bbd2200b16700c56bd8dc39da1833c", "message": "Impose hard limit on number of samples", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "3b6a1b481973a64b9c126879bd10d5d25ddac546", "url": "https://github.com/DataDog/dd-trace-java/commit/3b6a1b481973a64b9c126879bd10d5d25ddac546", "message": "Formatting changes", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "7fdb1479ca1a51f6a96ad5b53dd78ea8f5878b1a", "url": "https://github.com/DataDog/dd-trace-java/commit/7fdb1479ca1a51f6a96ad5b53dd78ea8f5878b1a", "message": "Simplify the exception profiling enablement checks", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "ea64495eae767eb902e113c08242301db6c43701", "url": "https://github.com/DataDog/dd-trace-java/commit/ea64495eae767eb902e113c08242301db6c43701", "message": "Replace adaptive sampler with a streaming sampler implementation.", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "41b69ab58975f11e44ee8d97136bc4ade2bc2d4f", "url": "https://github.com/DataDog/dd-trace-java/commit/41b69ab58975f11e44ee8d97136bc4ade2bc2d4f", "message": "Add exception sampling to profiling smoke test", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "d130cfa7e84ee893e2e65208189f08bf8e7b7a8c", "url": "https://github.com/DataDog/dd-trace-java/commit/d130cfa7e84ee893e2e65208189f08bf8e7b7a8c", "message": "Truncate exception histogram map on chunk rotation", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "713bcb702ded2b704e140ef87d16bf43d33d58b9", "url": "https://github.com/DataDog/dd-trace-java/commit/713bcb702ded2b704e140ef87d16bf43d33d58b9", "message": "Remove debug output", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "fe80d3459a3a1cbf7d0890152d48a0380959e311", "url": "https://github.com/DataDog/dd-trace-java/commit/fe80d3459a3a1cbf7d0890152d48a0380959e311", "message": "Change the sampler implementation to CDF based", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "13b44afa3a6533ed2282cce8dea99dede19acd92", "url": "https://github.com/DataDog/dd-trace-java/commit/13b44afa3a6533ed2282cce8dea99dede19acd92", "message": "Add ZULU8 support", "committedDate": "2020-03-24T13:13:12Z", "type": "commit"}, {"oid": "25a8e1231d248bdfeeb3a7ef5ab072cf786c5411", "url": "https://github.com/DataDog/dd-trace-java/commit/25a8e1231d248bdfeeb3a7ef5ab072cf786c5411", "message": "Merge remote-tracking branch 'origin/jb/PROF-581_exceptions_sampler' into jb/PROF-581_exceptions_sampler", "committedDate": "2020-03-24T13:13:35Z", "type": "commit"}, {"oid": "cb9b38aa32a599e5098a248adf2bc778ad519c69", "url": "https://github.com/DataDog/dd-trace-java/commit/cb9b38aa32a599e5098a248adf2bc778ad519c69", "message": "Merge branch 'jb/PROF-581_exceptions_sampler' into mar-kolya/exceptions-histogram-fixes", "committedDate": "2020-03-24T13:16:26Z", "type": "commit"}, {"oid": "8a43a009e95eafd06b63fd2e6ff77d859ed529eb", "url": "https://github.com/DataDog/dd-trace-java/commit/8a43a009e95eafd06b63fd2e6ff77d859ed529eb", "message": "Make compiler happy", "committedDate": "2020-03-24T13:30:37Z", "type": "commit"}, {"oid": "1b0de5efb4d7741eed8564559840bd8d5773b236", "url": "https://github.com/DataDog/dd-trace-java/commit/1b0de5efb4d7741eed8564559840bd8d5773b236", "message": "Fix timing of chunk rotation is tests", "committedDate": "2020-03-24T14:13:04Z", "type": "commit"}, {"oid": "08158dd1bc552292fc14b45334033653ad86d629", "url": "https://github.com/DataDog/dd-trace-java/commit/08158dd1bc552292fc14b45334033653ad86d629", "message": "Use geometric distribution CDF to compute next sample threshold", "committedDate": "2020-03-25T11:55:39Z", "type": "commit"}, {"oid": "e05d10a2f2529768d01aaef953db85fae6a3e453", "url": "https://github.com/DataDog/dd-trace-java/commit/e05d10a2f2529768d01aaef953db85fae6a3e453", "message": "Merge branch 'master' into mar-kolya/exceptions-histogram-fixes", "committedDate": "2020-03-25T11:58:07Z", "type": "commit"}, {"oid": "6d7e8c67f97b47bff336e0812b28014dd7b76d9c", "url": "https://github.com/DataDog/dd-trace-java/commit/6d7e8c67f97b47bff336e0812b28014dd7b76d9c", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler", "committedDate": "2020-03-25T11:58:09Z", "type": "commit"}, {"oid": "cf537c7df6bc221eca7983af01b1714ab49c3728", "url": "https://github.com/DataDog/dd-trace-java/commit/cf537c7df6bc221eca7983af01b1714ab49c3728", "message": "Fix configs", "committedDate": "2020-03-25T12:14:06Z", "type": "commit"}, {"oid": "a6313523d766c30cf95d4883a08df00329a20325", "url": "https://github.com/DataDog/dd-trace-java/commit/a6313523d766c30cf95d4883a08df00329a20325", "message": "Merge branch 'jb/PROF-581_exceptions_sampler' into mar-kolya/exceptions-histogram-fixes", "committedDate": "2020-03-25T12:50:03Z", "type": "commit"}, {"oid": "21a159568fa83d3018bc37b13a27503739c88e70", "url": "https://github.com/DataDog/dd-trace-java/commit/21a159568fa83d3018bc37b13a27503739c88e70", "message": "Add missing helper", "committedDate": "2020-03-25T14:02:40Z", "type": "commit"}, {"oid": "07ce810d262958c9c5b85b234374296dd1b08940", "url": "https://github.com/DataDog/dd-trace-java/commit/07ce810d262958c9c5b85b234374296dd1b08940", "message": "Merge pull request #1334 from DataDog/mar-kolya/exceptions-histogram-fixes\n\nMultiple fixes for exception histogram", "committedDate": "2020-03-25T14:30:11Z", "type": "commit"}, {"oid": "cc30f5d5b6f2201691b0621fce6748e08eaf3654", "url": "https://github.com/DataDog/dd-trace-java/commit/cc30f5d5b6f2201691b0621fce6748e08eaf3654", "message": "Do not cause class initialization when checking for JFR availability", "committedDate": "2020-03-25T16:42:54Z", "type": "commit"}, {"oid": "f628af8e0518fcb400386520fdf9a9e4ebc4e32f", "url": "https://github.com/DataDog/dd-trace-java/commit/f628af8e0518fcb400386520fdf9a9e4ebc4e32f", "message": "Fold exception profiling support into the instrumentation", "committedDate": "2020-03-25T16:59:19Z", "type": "commit"}, {"oid": "b9e03f5335d737f95c7504170f66f6e927b87df8", "url": "https://github.com/DataDog/dd-trace-java/commit/b9e03f5335d737f95c7504170f66f6e927b87df8", "message": "Try to fix test dependencies", "committedDate": "2020-03-25T17:58:07Z", "type": "commit"}, {"oid": "6c6a65fa5c0d22e2c57add605a87519d81b4dbe3", "url": "https://github.com/DataDog/dd-trace-java/commit/6c6a65fa5c0d22e2c57add605a87519d81b4dbe3", "message": "Maybe this will make the build pass?", "committedDate": "2020-03-25T18:26:16Z", "type": "commit"}, {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12", "url": "https://github.com/DataDog/dd-trace-java/commit/2996cbc230692a8ae398480d74104d5215ec4b12", "message": "Placate google format", "committedDate": "2020-03-25T19:04:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjA0Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398502047", "bodyText": "We should address this fix me.\nFirst of all I'm not convinced that firsthit that may be skipped is actually useful.\nAnd if we decide that it is we should update tests to make sure it actually works the way we think it does.", "author": "mar-kolya", "createdAt": "2020-03-26T11:32:00Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();\n+          } finally {\n+            firstHit[0] = true;\n+          }\n+        })\n+      .incrementAndGet();\n+\n+    // FIXME: this 'first hit' logic is confusing and untested", "originalCommit": "2996cbc230692a8ae398480d74104d5215ec4b12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjQxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398502412", "bodyText": "And it latter case we should also have a comment explaining gotchars of this aproach.", "author": "mar-kolya", "createdAt": "2020-03-26T11:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0OTExMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411349113", "bodyText": "Improved the implementation slightly and added a concurrency test (which requires opening up some methods for package private access but I really doubt there is another way to make sure the test is actually entering the critical section from 2 threads at the same time).\nAdded explaining comment as well ...", "author": "jbachorik", "createdAt": "2020-04-20T12:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjA0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\nindex dccb7b7ca9..07eeec785c 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java\n\n@@ -8,8 +8,19 @@ import lombok.extern.slf4j.Slf4j;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.LongAdder;\n import java.util.stream.Stream;\n \n+/**\n+ * A simple exception type histogram implementation.<br>\n+ * It tracks a fixed number of exception types and for each of them it keeps the number of instances created since\n+ * the last {@linkplain ExceptionHistogram#emit()} call (or creating a new {@linkplain ExceptionHistogram} instance\n+ * if {@linkplain ExceptionHistogram#emit()} hasn't been called yet).<br>\n+ *\n+ * An {@linkplain ExceptionHistogram} instance is registered with JFR to call {@linkplain ExceptionHistogram#emit()}\n+ * method at chunk end, as specified in {@linkplain ExceptionCountEvent} class. This callback will then emit a number\n+ * of {@linkplain ExceptionCountEvent} events.\n+ */\n @Slf4j\n public class ExceptionHistogram {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjc4Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398502786", "bodyText": "If we decide to keep this firstHit logic I think this code we will much more self-explanatory if we just pass firstHit intosample() call and make sample() do the right thing.", "author": "mar-kolya", "createdAt": "2020-03-26T11:33:29Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static final Config config = Config.get();\n+\n+  private static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+\n+  /**\n+   * Get a pre-configured shared instance.\n+   *\n+   * @return the shared instance\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    return ExceptionProfiling.INSTANCE;\n+  }\n+\n+  private final ExceptionHistogram histogram;\n+  private final ExceptionSampler sampler;\n+\n+  private ExceptionProfiling() {\n+    this(new ExceptionSampler(config), new ExceptionHistogram(config));\n+  }\n+\n+  ExceptionProfiling(final ExceptionSampler sampler, final ExceptionHistogram histogram) {\n+    this.sampler = sampler;\n+    this.histogram = histogram;\n+  }\n+\n+  public ExceptionSampleEvent process(final Exception e) {\n+    // always record the exception in histogram\n+    final boolean firstHit = histogram.record(e);\n+\n+    if (sampler.isEnabled()) {\n+      /*\n+       * If the histogram hasn't contained that particular exception type up till now then 'firstHit' == true\n+       * and the sample event should be emitted regardless of the sampling result.\n+       * We need a non-short-circuiting OR such that 'sampler.sample()' is called regardless of value\n+       * of 'firstHit'.\n+       */\n+      if (firstHit | sampler.sample()) {", "originalCommit": "2996cbc230692a8ae398480d74104d5215ec4b12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwNTYyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398505625", "bodyText": "Also, I think this is wrong: if we force the selection of 'first' exceptions and count them as samples we reduce sampling of all non-first events. I'm not sure this is desired.", "author": "mar-kolya", "createdAt": "2020-03-26T11:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzMjExNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398532117", "bodyText": "We haven't reached any decision in an off-line chat. Therefore I left it as it was.\n\nIf we decide to keep this firstHit logic I think this code we will much more self-explanatory if we just pass firstHit into sample() call and make sample() do the right thing.\n\nThen it will become the property of the sampler, where I am not convinced it belongs to.\n\nAlso, I think this is wrong: if we force the selection of 'first' exceptions and count them as samples we reduce sampling of all non-first events. I'm not sure this is desired.\n\nWe do not count the first exception as a sample (unless the random check passes the threshold, that is). If anything, it will slightly decrease the sampling interval in the first sampling window.", "author": "jbachorik", "createdAt": "2020-03-26T12:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjc4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java\nindex 974b83425e..7d1ecc4304 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java\n\n@@ -7,9 +7,8 @@ import datadog.trace.api.Config;\n  * itself using either system properties, environment or properties override.\n  */\n public final class ExceptionProfiling {\n-  private static final Config config = Config.get();\n \n-  private static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  private static final ExceptionProfiling INSTANCE = new ExceptionProfiling(Config.get());\n \n   /**\n    * Get a pre-configured shared instance.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMzUzNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398503535", "bodyText": "This class doesn't seem to be providing much value now :)", "author": "mar-kolya", "createdAt": "2020-03-26T11:34:49Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+final class ExceptionSampler {", "originalCommit": "2996cbc230692a8ae398480d74104d5215ec4b12", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\nindex 4c67f329e4..c2e74d404e 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java\n\n@@ -1,37 +1,48 @@\n package com.datadog.profiling.exceptions;\n \n import datadog.trace.api.Config;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n import jdk.jfr.EventType;\n \n-import java.util.concurrent.TimeUnit;\n-\n final class ExceptionSampler {\n+  /*\n+   * Fixed 0.5 second sampling window.\n+   * Logic in StreamingSampler relies on sampling window being small compared to (in our case) recording duration:\n+   * sampler may overshoot on one given window but should average to samplesPerWindow in the long run.\n+   */\n+  private static final Duration SAMPLING_WINDOW = Duration.of(500, ChronoUnit.MILLIS);\n+\n   private final StreamingSampler sampler;\n   private final EventType exceptionSampleType;\n \n   ExceptionSampler(final Config config) {\n-    this(\n-      config.getProfilingExceptionSamplerSlidingWindow(),\n-      TimeUnit.SECONDS,\n-      config.getProfilingExceptionSamplerSlidingWindowSamples(),\n-      config.getProfilingExceptionSamplerInitialInterval());\n+    this(SAMPLING_WINDOW, getSamplesPerWindow(config), samplingWindowsPerRecording(config));\n   }\n \n-  ExceptionSampler(\n-    final long windowDuration,\n-    final TimeUnit windowDurationUnit,\n-    final int samplesPerWindow,\n-    final int initialInterval) {\n-    sampler =\n-      new StreamingSampler(windowDuration, windowDurationUnit, samplesPerWindow, initialInterval);\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, lookback);\n     exceptionSampleType = EventType.getEventType(ExceptionSampleEvent.class);\n   }\n \n-  boolean sample() {\n-    return sampler.sample();\n+  private static int samplingWindowsPerRecording(final Config config) {\n+    /*\n+     * Java8 doesn't have dividedBy#Duration so we have to implement poor man's version.\n+     * None of these durations should be big enough to warrant dealing with bigints.\n+     * We also do not care about nanoseconds here.\n+     */\n+    return (int)\n+        Math.min(\n+            Duration.of(config.getProfilingUploadPeriod(), ChronoUnit.SECONDS).toMillis()\n+                / SAMPLING_WINDOW.toMillis(),\n+            Integer.MAX_VALUE);\n   }\n \n-  boolean isEnabled() {\n-    return exceptionSampleType.isEnabled();\n+  private static int getSamplesPerWindow(final Config config) {\n+    return config.getProfilingExceptionSampleLimit() / samplingWindowsPerRecording(config);\n+  }\n+\n+  boolean sample() {\n+    return exceptionSampleType.isEnabled() && sampler.sample();\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMDA0OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398510049", "bodyText": "I'm not sure I can immediately see how this would be useful.\nMaybe instead of this we could keep cause's message if cause is present?", "author": "mar-kolya", "createdAt": "2020-03-26T11:46:56Z", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.datadog.profiling.exceptions;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+@Name(\"datadog.ExceptionSample\")\n+@Label(\"ExceptionSample\")\n+@Description(\"Datadog exception sample event.\")\n+@Category(\"Datadog\")\n+public class ExceptionSampleEvent extends Event {\n+  @Label(\"Exception Type\")\n+  private String type;\n+\n+  @Label(\"Exception message\")\n+  private final String message;\n+\n+  @Label(\"Exception stackdepth\")\n+  private final int stackDepth;", "originalCommit": "2996cbc230692a8ae398480d74104d5215ec4b12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NTg4Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405455886", "bodyText": "Should we still consider storing message for the cause?", "author": "mar-kolya", "createdAt": "2020-04-08T11:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxODQ0OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407518449", "bodyText": "Please consider #1363", "author": "mar-kolya", "createdAt": "2020-04-13T14:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMDA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java\nindex a4c958ea78..76fad32eb5 100644\n--- a/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java\n+++ b/dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java\n\n@@ -12,22 +12,33 @@ import jdk.jfr.Name;\n @Category(\"Datadog\")\n public class ExceptionSampleEvent extends Event {\n   @Label(\"Exception Type\")\n-  private String type;\n+  private final String type;\n \n   @Label(\"Exception message\")\n   private final String message;\n \n+  /** JFR may truncate the stack trace - so store original length as well. */\n   @Label(\"Exception stackdepth\")\n   private final int stackDepth;\n \n-  public ExceptionSampleEvent(Exception e) {\n-    this.type = e.getClass().getName();\n-    this.message = e.getMessage();\n-    this.stackDepth = e.getStackTrace().length;\n-  }\n+  @Label(\"Sampled\")\n+  private final boolean sampled;\n+\n+  @Label(\"First occurrence\")\n+  private final boolean firstOccurrence;\n \n-  // used in tests only\n-  String getType() {\n-    return type;\n+  public ExceptionSampleEvent(\n+      final Exception e, final boolean sampled, final boolean firstOccurrence) {\n+    /*\n+     * TODO: we should have some tests for this class.\n+     * Unfortunately at the moment this is not easily possible because we cannot build tests with groovy that\n+     * are compiled against java11 SDK - this seems to be gradle-groovy interaction limitation.\n+     * Writing these tests in java seems like would introduce more noise.\n+     */\n+    type = e.getClass().getName();\n+    message = e.getMessage();\n+    stackDepth = e.getStackTrace().length;\n+    this.sampled = sampled;\n+    this.firstOccurrence = firstOccurrence;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMTE1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398511153", "bodyText": "I do not think this is used", "author": "mar-kolya", "createdAt": "2020-03-26T11:48:50Z", "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java", "diffHunk": "@@ -108,6 +108,10 @@ public boolean add(final List<DDSpan> trace) {\n     GlobalTracer.registerIfAbsent((datadog.trace.api.Tracer) TEST_TRACER);\n   }\n \n+  protected static Instrumentation getInstrumentation() {\n+    return INSTRUMENTATION;\n+  }", "originalCommit": "2996cbc230692a8ae398480d74104d5215ec4b12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzNDM0OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398534348", "bodyText": "\ud83d\udc4d", "author": "jbachorik", "createdAt": "2020-03-26T12:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMTE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "30f278768eb4b940365d7c01b952d4ca89ce7824", "chunk": "diff --git a/dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java b/dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java\nindex 6be6a5b263..06498424bc 100644\n--- a/dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java\n+++ b/dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java\n\n@@ -108,10 +108,6 @@ public abstract class AgentTestRunner extends DDSpecification {\n     GlobalTracer.registerIfAbsent((datadog.trace.api.Tracer) TEST_TRACER);\n   }\n \n-  protected static Instrumentation getInstrumentation() {\n-    return INSTRUMENTATION;\n-  }\n-\n   protected static Tracer getTestTracer() {\n     return (Tracer) TEST_TRACER;\n   }\n"}}]}