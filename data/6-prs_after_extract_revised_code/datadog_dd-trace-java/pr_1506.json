{"pr_number": 1506, "pr_title": "Switch Trace and Span id from BigInteger to DDId", "pr_createdAt": "2020-05-28T14:41:12Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1506", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431895622", "bodyText": "Since this is used for tests, can we make it package private or private instead?", "author": "devinsba", "createdAt": "2020-05-28T14:47:10Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzA5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431903098", "bodyText": "It's used for tests from all over the place, but I could also remove it and change the tests to use DDId.from(1) instead.", "author": "bantonsson", "createdAt": "2020-05-28T14:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwNjkzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431906937", "bodyText": "Groovy will automatically do the reflection required to access the field. I'm not sure that it isn't used in the couple Java tests that exist though", "author": "devinsba", "createdAt": "2020-05-28T15:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwODAwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431908000", "bodyText": "Thanks, didn't know that.", "author": "bantonsson", "createdAt": "2020-05-28T15:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431898367", "bodyText": "I think the 2 argument nextLong would be correct here. We do support negative signed longs", "author": "devinsba", "createdAt": "2020-05-28T14:50:32Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwNDk2MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431904960", "bodyText": "Yes, I wasn't sure if there was any other reason than BigInteger not handling a negative long the right way. I'll change it.", "author": "bantonsson", "createdAt": "2020-05-28T14:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNzM1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431927353", "bodyText": "The old behaviour was to generate a 63 bit, so positive, identifier though.", "author": "richardstartin", "createdAt": "2020-05-28T15:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDk0Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432304943", "bodyText": "I'll keep this as it was before to minimize the materialization of BigInteger, with a comment that it can be changed when msgpack is fixed.", "author": "bantonsson", "createdAt": "2020-05-29T07:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431930579", "bodyText": "Do we really need this? It will be extremely rare to overflow, can't we just materialise when (if) we do", "author": "richardstartin", "createdAt": "2020-05-28T15:34:12Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMzI3MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431933270", "bodyText": "Also, we will only ever need it once, so caching is questionable?", "author": "richardstartin", "createdAt": "2020-05-28T15:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTQxNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431935416", "bodyText": "Can't we need it multiple times? I mean the ParentId could be used multiple times.", "author": "bantonsson", "createdAt": "2020-05-28T15:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1NjkyNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431956926", "bodyText": "Yes, that can happen, but if the parent span of several spans is remote, the ids won't have been deduplicated.\nIf the parent is in process, the parent id will be the same instance, but until now we generated 63 bit span identifiers, so know we won't need the BigInteger.", "author": "richardstartin", "createdAt": "2020-05-28T16:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDUxMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432304511", "bodyText": "Yes, the 63 bit ids makes sure this doesn't happen for our ids. I'll keep it that way.\nSo we never start more than one span inside a span coming from the outside, but it might have a trace id that has this characteristic, and that will get reused as far as I can see. Can we leave this in until we fix msgpack? It's not that common that it will drag a BigInteger with it, and right now it bumps the object from 40 to 48 bytes on ZGC, and is a lost 4 bytes on G1?", "author": "bantonsson", "createdAt": "2020-05-29T07:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNDE4Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431934187", "bodyText": "The cast is unnecessary here, >>> will shift zero into the high bits", "author": "richardstartin", "createdAt": "2020-05-28T15:39:16Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNDc1MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431934750", "bodyText": "Could just mask with 0xFFFFFFFFL to isolate the low bits.", "author": "richardstartin", "createdAt": "2020-05-28T15:40:05Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTAzNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431935035", "bodyText": "mask unnecessary here if cast above is removed.", "author": "richardstartin", "createdAt": "2020-05-28T15:40:31Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTQwMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431935402", "bodyText": "mask unnecessary if just shifted right above without casting on line 200", "author": "richardstartin", "createdAt": "2020-05-28T15:41:02Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431936220", "bodyText": "I wonder should we be shifting the high bits right and xoring?", "author": "richardstartin", "createdAt": "2020-05-28T15:42:12Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzM5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431937397", "bodyText": "Yes, we should probably.", "author": "bantonsson", "createdAt": "2020-05-28T15:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMjU0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432012540", "bodyText": "Just call java.lang.Long#hashCode(long)?", "author": "tylerbenson", "createdAt": "2020-05-28T17:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMDYwNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432320605", "bodyText": "Well, that was 1.8, so I'll do the shift/xor thing.", "author": "bantonsson", "createdAt": "2020-05-29T08:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjYyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431936627", "bodyText": "maybe add a comment that the race condition is benign", "author": "richardstartin", "createdAt": "2020-05-28T15:42:47Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzY2MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431937661", "bodyText": "\ud83d\udc4d", "author": "bantonsson", "createdAt": "2020-05-28T15:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjYyNw=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431937143", "bodyText": "I don't think we will ever need this except at the last possible moment when we serialise", "author": "richardstartin", "createdAt": "2020-05-28T15:43:27Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {\n+      this.hex = h = Long.toHexString(this.id);\n+    }\n+    return h;\n+  }\n+\n+  /**\n+   * Returns a {@code BigInteger} representation of the 64 bit id. TODO Can be removed if msgpack\n+   * supports packUnsignedLong\n+   *\n+   * @return BigInteger representation of the 64 it id.\n+   */\n+  public BigInteger toBigInteger() {\n+    BigInteger b = this.big;\n+    if (b == null) {\n+      this.big = b = toUnsignedBigInteger(this.id);", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzODA3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431938075", "bodyText": "Yes, it's only there AFAIK.", "author": "bantonsson", "createdAt": "2020-05-28T15:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxNjM1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432016356", "bodyText": "Should we submit a PR for packUnsignedLong?", "author": "tylerbenson", "createdAt": "2020-05-28T17:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzNDYwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432034608", "bodyText": "Yes I can do that (I already have a fork).", "author": "richardstartin", "createdAt": "2020-05-28T18:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTg4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431939885", "bodyText": "can we take this off the critical path by marking it in a bitmask and checking the bitmask against zero (meaning valid) at the end?", "author": "richardstartin", "createdAt": "2020-05-28T15:47:26Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0MzM5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431943394", "bodyText": "Sure, we can just or together the ds, and if it's negative at the end it's broken. No need to say exactly which c is wrong.", "author": "bantonsson", "createdAt": "2020-05-28T15:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1MDgwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431950808", "bodyText": "even better than what I had in mind", "author": "richardstartin", "createdAt": "2020-05-28T16:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTg4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NDYxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431944612", "bodyText": "Can this be implemented the same way as JDK8 Long.compareUnsigned(i.e. add Long.MIN_VALUE to each side?", "author": "richardstartin", "createdAt": "2020-05-28T15:54:14Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java", "diffHunk": "@@ -35,7 +35,12 @@ public boolean sample(final DDSpan span) {\n     } else if (rate == 0) {\n       sampled = false;\n     } else {\n-      sampled = span.getTraceId().multiply(KNUTH_FACTOR).mod(MODULUS).compareTo(cutoff) < 0;\n+      long mod = span.getTraceId().toLong() * KNUTH_FACTOR;\n+      if (cutoff >= 0) {", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMjc0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432302740", "bodyText": "I'll take a look at it.", "author": "bantonsson", "createdAt": "2020-05-29T07:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NDYxMg=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java b/dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java\nindex ee66f47210..71db3208e4 100644\n--- a/dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java\n+++ b/dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java\n\n@@ -13,33 +13,31 @@ import lombok.extern.slf4j.Slf4j;\n public class DeterministicSampler implements RateSampler {\n   private static final long KNUTH_FACTOR = 1111111111111111111L;\n \n-  private final long cutoff;\n+  private final long cutoff; // pre-calculated for the unsigned 64 bit comparison\n   private final double rate;\n \n   public DeterministicSampler(final double rate) {\n     this.rate = rate;\n     cutoff =\n         new BigDecimal(rate)\n-            .multiply(new BigDecimal(CoreTracer.TRACE_ID_MAX))\n-            .toBigInteger()\n-            .longValue();\n+                .multiply(new BigDecimal(CoreTracer.TRACE_ID_MAX))\n+                .toBigInteger()\n+                .longValue()\n+            + Long.MIN_VALUE;\n \n     log.debug(\"Initializing the RateSampler, sampleRate: {} %\", rate * 100);\n   }\n \n   @Override\n   public boolean sample(final DDSpan span) {\n-    final boolean sampled;\n-    if (rate == 1) {\n+    boolean sampled = false;\n+    if (rate >= 1) {\n       sampled = true;\n-    } else if (rate == 0) {\n-      sampled = false;\n-    } else {\n+    } else if (rate > 0) {\n       long mod = span.getTraceId().toLong() * KNUTH_FACTOR;\n-      if (cutoff >= 0) {\n-        sampled = mod >= 0 && mod < cutoff;\n-      } else {\n-        sampled = mod < 0 && mod >= cutoff;\n+      // unsigned 64 bit comparison with pre-calculated cutoff\n+      if (mod + Long.MIN_VALUE < cutoff) {\n+        sampled = true;\n       }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NTUzMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431945531", "bodyText": "I believe this is the only time DDId.toBigInteger is called.", "author": "richardstartin", "createdAt": "2020-05-28T15:55:30Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/JsonFormatWriter.java", "diffHunk": "@@ -97,7 +98,17 @@ public void writeDouble(final byte[] key, final double value, final JsonWriter d\n   }\n \n   @Override\n-  public void writeBigInteger(\n+  public void writeId(byte[] key, DDId id, JsonWriter destination) throws IOException {\n+    // This is to keep the id output compatible with the BigInteger id for tests\n+    long l = id.toLong();\n+    if (l >= 0) {\n+      writeLong(key, l, destination);\n+    } else {\n+      writeBigInteger(key, id.toBigInteger(), destination);", "originalCommit": "9400511715b0ff3ca57ad4dc91a531d3c7c06028", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMjgwNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432302804", "bodyText": "Correct.", "author": "bantonsson", "createdAt": "2020-05-29T07:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NTUzMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMzU1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432013553", "bodyText": "Same comment here about the race condition.", "author": "tylerbenson", "createdAt": "2020-05-28T17:45:10Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {", "originalCommit": "b443e579d678d3e37b66b0cf187c085f7c451733", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NjI1OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432296259", "bodyText": "\ud83d\udc4d", "author": "bantonsson", "createdAt": "2020-05-29T07:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMzU1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex bd9ef23e73..b9b1a1cf16 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -16,7 +16,7 @@ public class DDId {\n       new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n \n   // Convenience constant used from tests\n-  public static final DDId ONE = DDId.from(1);\n+  private static final DDId ONE = DDId.from(1);\n \n   /**\n    * Generate a new unsigned 64 bit id.\n"}}, {"oid": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "url": "https://github.com/DataDog/dd-trace-java/commit/7903d8a724b0ec14124255da4b1e4bddb3a766ca", "message": "DDId changes based on review comments", "committedDate": "2020-05-29T12:13:56Z", "type": "forcePushed"}, {"oid": "15707dd317c91a78d145762569e14468e1554e2a", "url": "https://github.com/DataDog/dd-trace-java/commit/15707dd317c91a78d145762569e14468e1554e2a", "message": "DDId changes based on review comments", "committedDate": "2020-05-29T13:26:56Z", "type": "forcePushed"}, {"oid": "dd8034b4127b1632735e9bbe043e2f66be2fbf92", "url": "https://github.com/DataDog/dd-trace-java/commit/dd8034b4127b1632735e9bbe043e2f66be2fbf92", "message": "DDId changes based on review comments", "committedDate": "2020-05-29T13:59:53Z", "type": "forcePushed"}, {"oid": "fc20abc1a2938f53cd08963568ccd399f733d07f", "url": "https://github.com/DataDog/dd-trace-java/commit/fc20abc1a2938f53cd08963568ccd399f733d07f", "message": "DDId changes based on review comments", "committedDate": "2020-05-29T15:27:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMTY0Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432601647", "bodyText": "Why is this line important?", "author": "tylerbenson", "createdAt": "2020-05-29T16:32:59Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -215,43 +215,53 @@ public boolean equals(Object o) {\n \n   @Override\n   public int hashCode() {\n-    return (int) this.id;\n+    long id = this.id;", "originalCommit": "fc20abc1a2938f53cd08963568ccd399f733d07f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA4MzUzMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r433083532", "bodyText": "I don't really trust javac to be smart so I load up the this.id field first, and then use it twice in the calculation below. I double checked the generated byte code, and if I don't do this it will read up the this.id field from the object twice. That double read will most likely be optimized away at some point, but it can't hurt to be proactive.\nWith local variable               | Without local variable\n----------------------------------|----------------------------------\npublic int hashCode();            | public int hashCode();\n  Code:                           |   Code:\n   0: aload_0                     |    0: aload_0\n   1: getfield  #14 // Field id:J |    1: getfield  #14 // Field id:J\n   4: lstore_1                    |    4: aload_0\n   5: lload_1                     |    5: getfield  #14 // Field id:J\n   6: lload_1                     |    8: bipush    32\n   7: bipush    32                |   10: lushr\n   9: lushr                       |   11: lxor\n  10: lxor                        |   12: l2i\n  11: l2i                         |   13: ireturn\n  12: ireturn                     |", "author": "bantonsson", "createdAt": "2020-06-01T07:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMTY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "07bbf3dac87d70bcf5df12dc8d82b87b74ad1445", "chunk": "diff --git a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\nindex b9b1a1cf16..bd9ef23e73 100644\n--- a/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n+++ b/dd-trace-api/src/main/java/datadog/trace/api/DDId.java\n\n@@ -215,21 +215,12 @@ public class DDId {\n \n   @Override\n   public int hashCode() {\n-    long id = this.id;\n-    return (int) (id ^ (id >>> 32));\n+    return (int) this.id;\n   }\n \n-  /**\n-   * Returns the decimal string representation of the unsigned 64 bit id. The {@code String} will be\n-   * cached.\n-   *\n-   * @return decimal string\n-   */\n   @Override\n   public String toString() {\n     String s = this.str;\n-    // This race condition is intentional and benign.\n-    // The worst that can happen is that an identical value is produced and written into the field.\n     if (s == null) {\n       this.str = s = toUnsignedString(this.id);\n     }\n"}}, {"oid": "07bbf3dac87d70bcf5df12dc8d82b87b74ad1445", "url": "https://github.com/DataDog/dd-trace-java/commit/07bbf3dac87d70bcf5df12dc8d82b87b74ad1445", "message": "Switch Trace and Span id from BigInteger to DDId", "committedDate": "2020-06-01T07:38:45Z", "type": "commit"}, {"oid": "b4db5dcaa30e10ba6b5d1fafcdac868083bca693", "url": "https://github.com/DataDog/dd-trace-java/commit/b4db5dcaa30e10ba6b5d1fafcdac868083bca693", "message": "Update all tests to DDId", "committedDate": "2020-06-01T07:38:45Z", "type": "commit"}, {"oid": "67e404592f9712e3f95d775190933341fc3fe024", "url": "https://github.com/DataDog/dd-trace-java/commit/67e404592f9712e3f95d775190933341fc3fe024", "message": "DDId changes based on review comments", "committedDate": "2020-06-01T07:38:45Z", "type": "commit"}, {"oid": "67e404592f9712e3f95d775190933341fc3fe024", "url": "https://github.com/DataDog/dd-trace-java/commit/67e404592f9712e3f95d775190933341fc3fe024", "message": "DDId changes based on review comments", "committedDate": "2020-06-01T07:38:45Z", "type": "forcePushed"}]}