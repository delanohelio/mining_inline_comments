{"pr_number": 546, "pr_title": "SSLSocket: detect failure to recieve CLOSE_NOTIFY", "pr_createdAt": "2020-05-08T14:37:15Z", "pr_url": "https://github.com/dogtagpki/jss/pull/546", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NDU5OQ==", "url": "https://github.com/dogtagpki/jss/pull/546#discussion_r422184599", "bodyText": "@edewata What's your thoughts on this? org.mozilla.jss.ssl.SSLSocket doesn't implement this detection and will happily close. TLSv1.1 made it optional and Pornin seems to think its a non-issue.\nIn TLSv1.3 the new spec says on page 86:\n\nEach party MUST send a \"close_notify\" alert before closing its write\nside of the connection, unless it has already sent some error alert.\nThis does not have any effect on its read side of the connection.\nNote that this is a change from versions of TLS prior to TLS 1.3 in\nwhich implementations were required to react to a \"close_notify\" by\ndiscarding pending writes and sending an immediate \"close_notify\"\nalert of their own.  That previous requirement could cause truncation\nin the read side.  Both parties need not wait to receive a\n\"close_notify\" alert before closing their read side of the\nconnection, though doing so would introduce the possibility of\ntruncation.\n\nWhich seems to imply that we're safe to close the inbound side earlier, and that lack of a CLOSE_NOTIFY should be treated as fatal. Thoughts?", "author": "cipherboy", "createdAt": "2020-05-08T14:44:47Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -344,35 +344,64 @@ public void implCloseSelectableChannel() throws IOException {\n         // to confirm the peer got the message. Otherwise, only a single write\n         // is necessary to send our acknowledgement of the peer's alert.\n \n-        synchronized (this) {\n-            // Bypass read check.\n-            inboundClosed = false;\n-            outboundClosed = false;\n-\n-            read(empty);\n-            engine.closeOutbound();\n-            write(empty);\n-            read(empty);\n-            engine.closeInbound();\n-\n-            outboundClosed = true;\n-            inboundClosed = true;\n-        }\n+        try {\n+            synchronized (this) {\n+                // unwrap() triggers a call to PR_Read(), which in turn will\n+                // execute the received alert callback. However, PR_Read is\n+                // effectively a no-op with an empty buffer, resulting in the\n+                // callback never triggering. Use a single byte buffer instead,\n+                // discarding any data because we're closing the channel. This\n+                // should ensure we always get a callback.\n+                ByteBuffer read_one = ByteBuffer.allocate(1);\n+\n+                // Bypass read check.\n+                inboundClosed = false;\n+                outboundClosed = false;\n+\n+                read(read_one);\n+                engine.closeOutbound();\n+                write(empty);\n+\n+                int times = 0;\n+                while (!engine.isInboundDone()) {\n+                    read_one.clear();\n+                    read(read_one);\n+\n+                    times += 1;\n+                    if (times > 25) {\n+                        break;\n+                    }\n \n-        if (parent == null) {\n-            if (autoClose) {\n-                parentSocket.shutdownInput();\n-                parentSocket.shutdownOutput();\n-                parentSocket.close();\n+                    try {\n+                        Thread.sleep(times * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (!engine.isInboundDone()) {\n+                    String msg = \"Premature close of SSLSocket: peer didn't \";", "originalCommit": "3703240361b71fc3d17460ec9aeac82bc7774941", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5MDY0MA==", "url": "https://github.com/dogtagpki/jss/pull/546#discussion_r422190640", "bodyText": "Looks like sun.security.ssl.SSLSocketImpl (SunJSSE's implementation) will wait for the CLOSE_NOTIFY event if it is the one initiating the close. That's essentially the behavior here: when we receive a CLOSE_NOTIFY, we mark isInboundDone() == true inside the SSLEngine. If it hasn't been received (i.e., we just sent it), we go into the loop and wait.", "author": "cipherboy", "createdAt": "2020-05-08T14:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NDU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6dd7cab00df0c5eb62fe157ad8da8c4908b35394", "chunk": "diff --git a/org/mozilla/jss/ssl/javax/JSSSocketChannel.java b/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\nindex 3ac2290f..47b40dd6 100644\n--- a/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\n+++ b/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\n\n@@ -354,13 +354,15 @@ public class JSSSocketChannel extends SocketChannel {\n                 // should ensure we always get a callback.\n                 ByteBuffer read_one = ByteBuffer.allocate(1);\n \n+\n                 // Bypass read check.\n                 inboundClosed = false;\n-                outboundClosed = false;\n-\n                 read(read_one);\n-                engine.closeOutbound();\n-                write(empty);\n+\n+                outboundClosed = false;\n+                if (!outboundClosed) {\n+                    shutdownOutput();\n+                }\n \n                 int times = 0;\n                 while (!engine.isInboundDone()) {\n"}}, {"oid": "6dd7cab00df0c5eb62fe157ad8da8c4908b35394", "url": "https://github.com/dogtagpki/jss/commit/6dd7cab00df0c5eb62fe157ad8da8c4908b35394", "message": "SSLSocket: detect failure to recieve CLOSE_NOTIFY\n\nAn important part of the TLS protocol is the ability to detect whether\nor not the peer closed the connection or if an attacker terminated the\nconnection prematurely. In order to do this, both sides send a\nCLOSE_NOTIFY event. When this event isn't detected, raise an IOException\nto inform the application about it.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-08T14:58:17Z", "type": "forcePushed"}, {"oid": "506598717ff45a309a13772d49ffb1b530d238cb", "url": "https://github.com/dogtagpki/jss/commit/506598717ff45a309a13772d49ffb1b530d238cb", "message": "SSLSocket: detect failure to recieve CLOSE_NOTIFY\n\nAn important part of the TLS protocol is the ability to detect whether\nor not the peer closed the connection or if an attacker terminated the\nconnection prematurely. In order to do this, both sides send a\nCLOSE_NOTIFY event. When this event isn't detected, raise an IOException\nto inform the application about it.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-08T15:00:56Z", "type": "commit"}, {"oid": "506598717ff45a309a13772d49ffb1b530d238cb", "url": "https://github.com/dogtagpki/jss/commit/506598717ff45a309a13772d49ffb1b530d238cb", "message": "SSLSocket: detect failure to recieve CLOSE_NOTIFY\n\nAn important part of the TLS protocol is the ability to detect whether\nor not the peer closed the connection or if an attacker terminated the\nconnection prematurely. In order to do this, both sides send a\nCLOSE_NOTIFY event. When this event isn't detected, raise an IOException\nto inform the application about it.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-08T15:00:56Z", "type": "forcePushed"}]}