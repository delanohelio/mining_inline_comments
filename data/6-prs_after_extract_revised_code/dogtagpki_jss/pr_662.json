{"pr_number": 662, "pr_title": "Attempt to use SecretKeyFactory to rewrite keys prior to failing JSSMacSpi", "pr_createdAt": "2020-11-20T18:18:10Z", "pr_url": "https://github.com/dogtagpki/jss/pull/662", "timeline": [{"oid": "8efbf9490e575f233fff0986f1f71102b066c99b", "url": "https://github.com/dogtagpki/jss/commit/8efbf9490e575f233fff0986f1f71102b066c99b", "message": "Replace RSAPrivateKey with RSAKey\n\nPer discussion with Andrew Hughes in #java, JCA takes RSAPrivateKey to\nmean that the private exponent is extractable. Because the JCA is\ncareful to use Key most places, we might get away with making\nPK11RSAPrivateKey not implement RSAPrivateKey and instead only\nimplement RSAKey -- signalling to other providers that the private\nexponent isn't extractable.\n\nThis patch requires careful testing with SunJSSE and Dogtag PKI to\nensure we don't rely on PK11RSAPrivateKey implementing RSAPrivateKey\nsomewhere.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-11-20T17:56:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNjMxNw==", "url": "https://github.com/dogtagpki/jss/pull/662#discussion_r527906317", "bodyText": "How about something like this so we can generate more specific exception message?\nif (key instanceof SecretKeyFacade) {\n    ...\n} else if (key instanceof SymmetricKey) {\n    ...\n} else if (key.getEncoded() != null) {\n    if (manufactured instanceof SecretKeyFacade) {\n        ...\n    } else if (manufactured instanceof SymmetricKey) {\n        ...\n    } else {\n        throw new InvalidKeyException(\"Unsupported key: \" + manufactured.getClass().getName());\n    }\n} else {\n    throw new InvalidKeyException(\"Missing key data: \" + key.getClass().getName());\n}", "author": "edewata", "createdAt": "2020-11-20T18:50:45Z", "path": "org/mozilla/jss/provider/javax/crypto/JSSMacSpi.java", "diffHunk": "@@ -48,20 +54,37 @@ public void engineInit(Key key, AlgorithmParameterSpec params)\n         throws InvalidKeyException, InvalidAlgorithmParameterException\n     {\n       try {\n-        SymmetricKey real_key;\n+        SymmetricKey real_key = null;\n         if (key instanceof SecretKeyFacade) {\n             SecretKeyFacade facade = (SecretKeyFacade)key;\n             real_key = facade.key;\n         } else if (key instanceof SymmetricKey) {\n             real_key = (SymmetricKey)key;\n-        } else {\n+        } else if (key.getEncoded() != null) {\n+            SecretKeyFactory factory = SecretKeyFactory.getInstance(keyName, \"Mozilla-JSS\");\n+            SecretKeySpec spec = new SecretKeySpec(key.getEncoded(), keyName);\n+            Key manufactured = factory.generateSecret(spec);\n+            if (manufactured instanceof SecretKeyFacade) {\n+                SecretKeyFacade facade = (SecretKeyFacade)manufactured;\n+                real_key = facade.key;\n+            } else if (manufactured instanceof SymmetricKey) {\n+                real_key = (SymmetricKey)manufactured;\n+            }\n+        }\n+\n+        if (real_key == null) {\n             throw new InvalidKeyException(\"Must use a key created by JSS! Try exporting the key data and importing it via SecretKeyFactory.\");\n         }", "originalCommit": "c3a2224ea83be2012c310135f768380106144ead", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyOTk5Nw==", "url": "https://github.com/dogtagpki/jss/pull/662#discussion_r527929997", "bodyText": "Once we've imported the key to JSS, it shouldn't be unsupported any longer. It'll throw an exception (InvalidKeySpecException) if we can't import the key, or we get a valid key out.", "author": "cipherboy", "createdAt": "2020-11-20T19:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNjMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0NDI4MQ==", "url": "https://github.com/dogtagpki/jss/pull/662#discussion_r527944281", "bodyText": "@edewata  Ok this has been updated.", "author": "cipherboy", "createdAt": "2020-11-20T20:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNjMxNw=="}], "type": "inlineReview", "revised_code": {"commit": "3c5081cd479ae136b3360cce18dc5b012c739858", "chunk": "diff --git a/org/mozilla/jss/provider/javax/crypto/JSSMacSpi.java b/org/mozilla/jss/provider/javax/crypto/JSSMacSpi.java\nindex 483abc65..a7df7128 100644\n--- a/org/mozilla/jss/provider/javax/crypto/JSSMacSpi.java\n+++ b/org/mozilla/jss/provider/javax/crypto/JSSMacSpi.java\n\n@@ -69,11 +69,19 @@ public class JSSMacSpi extends javax.crypto.MacSpi {\n                 real_key = facade.key;\n             } else if (manufactured instanceof SymmetricKey) {\n                 real_key = (SymmetricKey)manufactured;\n+            } else {\n+                String msg = \"Internal error while converting key: \";\n+                msg += \"converting key via SecretKeyFactory gave \";\n+                msg += \"unrecognized manufactured key type: \";\n+                msg += manufactured.getClass.getName();\n             }\n-        }\n-\n-        if (real_key == null) {\n-            throw new InvalidKeyException(\"Must use a key created by JSS! Try exporting the key data and importing it via SecretKeyFactory.\");\n+        } else {\n+            String msg = \"Must use a key created by JSS; got \";\n+            msg += key.getClass().getName() + \". \";\n+            msg += \"Try exporting the key data and importing it via \";\n+            msg += \"SecretKeyFactory or use an exportable key type \";\n+            msg += \"so JSS can do this automatically.\";\n+            throw new InvalidKeyException(msg);\n         }\n \n         digest.initHMAC(real_key);\n"}}, {"oid": "3c5081cd479ae136b3360cce18dc5b012c739858", "url": "https://github.com/dogtagpki/jss/commit/3c5081cd479ae136b3360cce18dc5b012c739858", "message": "Allow JSSMacSpi to handle external keys\n\nIn JSSCipherSpi, if a key from another provider is passed in, we first\nattempt to export it and then import it into NSS. Only when this fails\ndo we raise an exception. This fixes a failure in JDK8 272-b10 when\nJSS is used in conjunction with SunJSSE:\n\n    javax.net.ssl.SSLHandshakeException: Could not generate secret\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.t13DeriveKey(ECDHKeyExchange.java:479)\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.deriveKey(ECDHKeyExchange.java:419)\n            at sun.security.ssl.ServerHello$T13ServerHelloProducer.produce(ServerHello.java:596)\n            at sun.security.ssl.SSLHandshake.produce(SSLHandshake.java:421)\n            at sun.security.ssl.ClientHello$T13ClientHelloConsumer.goServerHello(ClientHello.java:1152)\n            at sun.security.ssl.ClientHello$T13ClientHelloConsumer.consume(ClientHello.java:1088)\n            at sun.security.ssl.ClientHello$ClientHelloConsumer.onClientHello(ClientHello.java:725)\n            at sun.security.ssl.ClientHello$ClientHelloConsumer.consume(ClientHello.java:693)\n            at sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:377)\n            at sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:444)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:968)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:955)\n            at java.security.AccessController.doPrivileged(Native Method)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask.run(SSLEngineImpl.java:902)\n            at org.apache.tomcat.util.net.SecureNioChannel.tasks(SecureNioChannel.java:443)\n            at org.apache.tomcat.util.net.SecureNioChannel.handshakeUnwrap(SecureNioChannel.java:507)\n            at org.apache.tomcat.util.net.SecureNioChannel.handshake(SecureNioChannel.java:238)\n            at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1575)\n            at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n            at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n            at java.lang.Thread.run(Thread.java:748)\n    Caused by: java.security.InvalidKeyException: Must use a key created by JSS! Try exporting the key data and importing it via SecretKeyFactory.\n            at org.mozilla.jss.provider.javax.crypto.JSSMacSpi.engineInit(JSSMacSpi.java:58)\n            at org.mozilla.jss.provider.javax.crypto.JSSMacSpi$HmacSHA384.engineInit(JSSMacSpi.java:116)\n            at javax.crypto.Mac.init(Mac.java:413)\n            at sun.security.ssl.HKDF.extract(HKDF.java:91)\n            at sun.security.ssl.HKDF.extract(HKDF.java:119)\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.t13DeriveKey(ECDHKeyExchange.java:469)\n\nBecause JDK recently introduced a new TLS stack for TLS-1.3 support in\nJDK 8, most people will find value moving to JSS's SSLEngine instead of\ncontinuing to use SunJSSE with JSS as the crypto provider.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-11-20T20:07:13Z", "type": "forcePushed"}, {"oid": "3153d40ac74622ce791e38db33a9c515f8627ded", "url": "https://github.com/dogtagpki/jss/commit/3153d40ac74622ce791e38db33a9c515f8627ded", "message": "Allow JSSMacSpi to handle external keys\n\nIn JSSCipherSpi, if a key from another provider is passed in, we first\nattempt to export it and then import it into NSS. Only when this fails\ndo we raise an exception. This fixes a failure in JDK8 272-b10 when\nJSS is used in conjunction with SunJSSE:\n\n    javax.net.ssl.SSLHandshakeException: Could not generate secret\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.t13DeriveKey(ECDHKeyExchange.java:479)\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.deriveKey(ECDHKeyExchange.java:419)\n            at sun.security.ssl.ServerHello$T13ServerHelloProducer.produce(ServerHello.java:596)\n            at sun.security.ssl.SSLHandshake.produce(SSLHandshake.java:421)\n            at sun.security.ssl.ClientHello$T13ClientHelloConsumer.goServerHello(ClientHello.java:1152)\n            at sun.security.ssl.ClientHello$T13ClientHelloConsumer.consume(ClientHello.java:1088)\n            at sun.security.ssl.ClientHello$ClientHelloConsumer.onClientHello(ClientHello.java:725)\n            at sun.security.ssl.ClientHello$ClientHelloConsumer.consume(ClientHello.java:693)\n            at sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:377)\n            at sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:444)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:968)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:955)\n            at java.security.AccessController.doPrivileged(Native Method)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask.run(SSLEngineImpl.java:902)\n            at org.apache.tomcat.util.net.SecureNioChannel.tasks(SecureNioChannel.java:443)\n            at org.apache.tomcat.util.net.SecureNioChannel.handshakeUnwrap(SecureNioChannel.java:507)\n            at org.apache.tomcat.util.net.SecureNioChannel.handshake(SecureNioChannel.java:238)\n            at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1575)\n            at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n            at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n            at java.lang.Thread.run(Thread.java:748)\n    Caused by: java.security.InvalidKeyException: Must use a key created by JSS! Try exporting the key data and importing it via SecretKeyFactory.\n            at org.mozilla.jss.provider.javax.crypto.JSSMacSpi.engineInit(JSSMacSpi.java:58)\n            at org.mozilla.jss.provider.javax.crypto.JSSMacSpi$HmacSHA384.engineInit(JSSMacSpi.java:116)\n            at javax.crypto.Mac.init(Mac.java:413)\n            at sun.security.ssl.HKDF.extract(HKDF.java:91)\n            at sun.security.ssl.HKDF.extract(HKDF.java:119)\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.t13DeriveKey(ECDHKeyExchange.java:469)\n\nBecause JDK recently introduced a new TLS stack for TLS-1.3 support in\nJDK 8, most people will find value moving to JSS's SSLEngine instead of\ncontinuing to use SunJSSE with JSS as the crypto provider.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-11-20T20:09:28Z", "type": "forcePushed"}, {"oid": "a42a27e463dcc8ac1d690a2763f136da3bb9c3f4", "url": "https://github.com/dogtagpki/jss/commit/a42a27e463dcc8ac1d690a2763f136da3bb9c3f4", "message": "Allow JSSMacSpi to handle external keys\n\nIn JSSCipherSpi, if a key from another provider is passed in, we first\nattempt to export it and then import it into NSS. Only when this fails\ndo we raise an exception. This fixes a failure in JDK8 272-b10 when\nJSS is used in conjunction with SunJSSE:\n\n    javax.net.ssl.SSLHandshakeException: Could not generate secret\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.t13DeriveKey(ECDHKeyExchange.java:479)\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.deriveKey(ECDHKeyExchange.java:419)\n            at sun.security.ssl.ServerHello$T13ServerHelloProducer.produce(ServerHello.java:596)\n            at sun.security.ssl.SSLHandshake.produce(SSLHandshake.java:421)\n            at sun.security.ssl.ClientHello$T13ClientHelloConsumer.goServerHello(ClientHello.java:1152)\n            at sun.security.ssl.ClientHello$T13ClientHelloConsumer.consume(ClientHello.java:1088)\n            at sun.security.ssl.ClientHello$ClientHelloConsumer.onClientHello(ClientHello.java:725)\n            at sun.security.ssl.ClientHello$ClientHelloConsumer.consume(ClientHello.java:693)\n            at sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:377)\n            at sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:444)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:968)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:955)\n            at java.security.AccessController.doPrivileged(Native Method)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask.run(SSLEngineImpl.java:902)\n            at org.apache.tomcat.util.net.SecureNioChannel.tasks(SecureNioChannel.java:443)\n            at org.apache.tomcat.util.net.SecureNioChannel.handshakeUnwrap(SecureNioChannel.java:507)\n            at org.apache.tomcat.util.net.SecureNioChannel.handshake(SecureNioChannel.java:238)\n            at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1575)\n            at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n            at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n            at java.lang.Thread.run(Thread.java:748)\n    Caused by: java.security.InvalidKeyException: Must use a key created by JSS! Try exporting the key data and importing it via SecretKeyFactory.\n            at org.mozilla.jss.provider.javax.crypto.JSSMacSpi.engineInit(JSSMacSpi.java:58)\n            at org.mozilla.jss.provider.javax.crypto.JSSMacSpi$HmacSHA384.engineInit(JSSMacSpi.java:116)\n            at javax.crypto.Mac.init(Mac.java:413)\n            at sun.security.ssl.HKDF.extract(HKDF.java:91)\n            at sun.security.ssl.HKDF.extract(HKDF.java:119)\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.t13DeriveKey(ECDHKeyExchange.java:469)\n\nBecause JDK recently introduced a new TLS stack for TLS-1.3 support in\nJDK 8, most people will find value moving to JSS's SSLEngine instead of\ncontinuing to use SunJSSE with JSS as the crypto provider.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-11-20T20:10:48Z", "type": "commit"}, {"oid": "a42a27e463dcc8ac1d690a2763f136da3bb9c3f4", "url": "https://github.com/dogtagpki/jss/commit/a42a27e463dcc8ac1d690a2763f136da3bb9c3f4", "message": "Allow JSSMacSpi to handle external keys\n\nIn JSSCipherSpi, if a key from another provider is passed in, we first\nattempt to export it and then import it into NSS. Only when this fails\ndo we raise an exception. This fixes a failure in JDK8 272-b10 when\nJSS is used in conjunction with SunJSSE:\n\n    javax.net.ssl.SSLHandshakeException: Could not generate secret\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.t13DeriveKey(ECDHKeyExchange.java:479)\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.deriveKey(ECDHKeyExchange.java:419)\n            at sun.security.ssl.ServerHello$T13ServerHelloProducer.produce(ServerHello.java:596)\n            at sun.security.ssl.SSLHandshake.produce(SSLHandshake.java:421)\n            at sun.security.ssl.ClientHello$T13ClientHelloConsumer.goServerHello(ClientHello.java:1152)\n            at sun.security.ssl.ClientHello$T13ClientHelloConsumer.consume(ClientHello.java:1088)\n            at sun.security.ssl.ClientHello$ClientHelloConsumer.onClientHello(ClientHello.java:725)\n            at sun.security.ssl.ClientHello$ClientHelloConsumer.consume(ClientHello.java:693)\n            at sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:377)\n            at sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:444)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:968)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask$DelegatedAction.run(SSLEngineImpl.java:955)\n            at java.security.AccessController.doPrivileged(Native Method)\n            at sun.security.ssl.SSLEngineImpl$DelegatedTask.run(SSLEngineImpl.java:902)\n            at org.apache.tomcat.util.net.SecureNioChannel.tasks(SecureNioChannel.java:443)\n            at org.apache.tomcat.util.net.SecureNioChannel.handshakeUnwrap(SecureNioChannel.java:507)\n            at org.apache.tomcat.util.net.SecureNioChannel.handshake(SecureNioChannel.java:238)\n            at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1575)\n            at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n            at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n            at java.lang.Thread.run(Thread.java:748)\n    Caused by: java.security.InvalidKeyException: Must use a key created by JSS! Try exporting the key data and importing it via SecretKeyFactory.\n            at org.mozilla.jss.provider.javax.crypto.JSSMacSpi.engineInit(JSSMacSpi.java:58)\n            at org.mozilla.jss.provider.javax.crypto.JSSMacSpi$HmacSHA384.engineInit(JSSMacSpi.java:116)\n            at javax.crypto.Mac.init(Mac.java:413)\n            at sun.security.ssl.HKDF.extract(HKDF.java:91)\n            at sun.security.ssl.HKDF.extract(HKDF.java:119)\n            at sun.security.ssl.ECDHKeyExchange$ECDHEKAKeyDerivation.t13DeriveKey(ECDHKeyExchange.java:469)\n\nBecause JDK recently introduced a new TLS stack for TLS-1.3 support in\nJDK 8, most people will find value moving to JSS's SSLEngine instead of\ncontinuing to use SunJSSE with JSS as the crypto provider.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-11-20T20:10:48Z", "type": "forcePushed"}]}