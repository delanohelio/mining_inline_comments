{"pr_number": 625, "pr_title": "Fix hostname verification and improve JCA compatibility", "pr_createdAt": "2020-08-31T19:09:18Z", "pr_url": "https://github.com/dogtagpki/jss/pull/625", "timeline": [{"oid": "47a2447178f7cca6036d4c3f8c5a11b2f598ecb4", "url": "https://github.com/dogtagpki/jss/commit/47a2447178f7cca6036d4c3f8c5a11b2f598ecb4", "message": "Add NSS stubs for BadCertHandler\n\nThe JDK's SSL interfaces under javax.net.ssl do not provide a way for\nthe SSLSocket/SSLEngine instance to validate hostname during the\nhandshake. Instead, the accepted way of doing hostname verification\n(using a HostnameVerifier) is after the handshake is completed. This\ncauses problems with NSS, because they assume the hostname is available\nfor validation at handshake time.\n\nIn order to support this use case, when the hostname is `null` on a\nclient SSL socket, we will attach using SSL_BadCertHook and give the\nJSSEngine a chance to bypass this value.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-08-31T18:39:48Z", "type": "commit"}, {"oid": "f7811272bdfb29a0ef78d77e3a55d9ff11132eb3", "url": "https://github.com/dogtagpki/jss/commit/f7811272bdfb29a0ef78d77e3a55d9ff11132eb3", "message": "Add SSLErrors with SSL_ERROR_BAD_CERT_DOMAIN\n\nThis is the only SSLError we wish to allow through in regular JSSEngine\nclient operations.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-08-31T18:48:02Z", "type": "commit"}, {"oid": "c40aa4ed21899d789fcbf4d2179caad4c92aa67c", "url": "https://github.com/dogtagpki/jss/commit/c40aa4ed21899d789fcbf4d2179caad4c92aa67c", "message": "Bypass SSL_ERRORS_BAD_CERT_DOMAIN for JDK\n\nWhen JSSEngine is used via the provider interface, most callers won't be\naware that they're using JSSEngine. As a side effect, they won't be\nusing JSSEngine's setHostname() to validate the server's SSL\ncertificate. This means NSS has no knowledge of the hostname, throwing\nan error like:\n\n    Caused by: javax.net.ssl.SSLHandshakeException: Error duing SSL.ForceHandshake() :: SSL_ERROR_BAD_CERT_DOMAIN (-12276)\n            at org.mozilla.jss.ssl.javax.JSSEngineReferenceImpl.updateHandshakeState(JSSEngineReferenceImpl.java:856)\n            at org.mozilla.jss.ssl.javax.JSSEngineReferenceImpl.unwrap(JSSEngineReferenceImpl.java:1037)\n            at org.mozilla.jss.ssl.javax.JSSSocketChannel.read(JSSSocketChannel.java:272)\n\nWe need to provide a mechanism to bypass this by default for these\nconnections, in order to stay compatible with the JCA. This approach was\nsuggested by Bob Relyea.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-08-31T18:59:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MDYyOA==", "url": "https://github.com/dogtagpki/jss/pull/625#discussion_r480370628", "bodyText": "Just a note, the old public handler field is no longer available, so this is not a backward compatible change, but it probably doesn't matter assuming it's only used internally.", "author": "edewata", "createdAt": "2020-08-31T20:07:56Z", "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -19,9 +19,12 @@\n     public int outboundOffset;\n \n     public boolean needCertValidation;\n+    public boolean needBadCertValidation;\n+    public int badCertError;\n     public boolean handshakeComplete;\n \n-    public CertAuthHandler handler;\n+    public CertAuthHandler certAuthHandler;\n+    public BadCertHandler badCertHandler;", "originalCommit": "c40aa4ed21899d789fcbf4d2179caad4c92aa67c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwOTQxMA==", "url": "https://github.com/dogtagpki/jss/pull/625#discussion_r480409410", "bodyText": "Yeah, nss/SSLFDProxy is used mostly internally. It has to be public as earlier discussed.", "author": "cipherboy", "createdAt": "2020-08-31T21:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MDYyOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjgyMg==", "url": "https://github.com/dogtagpki/jss/pull/625#discussion_r480376822", "bodyText": "When should we use ConfigAsyncBadCertCallback as opposed to ConfigSyncBadCertCallback?", "author": "edewata", "createdAt": "2020-08-31T20:20:28Z", "path": "org/mozilla/jss/nss/SSL.java", "diffHunk": "@@ -471,10 +471,38 @@ public static int EnableAlertLogging(SSLFDProxy fd) {\n      */\n     public static native int ConfigSyncTrustManagerCertAuthCallback(SSLFDProxy fd);\n \n+    /**\n+     * Use an asynchronous bad certificate handler which allows us to approve\n+     * rejected certificates. This allows us to bypass the hostname check\n+     * failure caused by the Java socket having no knowledge of the hostname\n+     * we use for certificate validation; no HostnameVerifier is passed in.\n+     * As a result, NSS has no value for the hostname and validation will fail.\n+     *\n+     * Note: This does NOT work for server-side connections.\n+     *\n+     * See also: SSL_BadCertHook in /usr/include/nss3/ssl.h and\n+     *           JSSL_SSLFDAsyncBadCertCallback in jss/nss/SSLFDProxy.c\n+     */\n+    public static native int ConfigAsyncBadCertCallback(SSLFDProxy fd);", "originalCommit": "c40aa4ed21899d789fcbf4d2179caad4c92aa67c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MDUwOA==", "url": "https://github.com/dogtagpki/jss/pull/625#discussion_r480390508", "bodyText": "Synchronous BadCertCallback is good when the validation is short. It also is the only method that works on both client-side and server-side connections.\nAsynchronous BadCertCallback is good when the validation takes a long time and/or invokes other network requests. It works only on client-side connections (which this is).\nBecause ours is short, I went with the former.\nThe same reasoning relates to CertAuthHandler, which is already present in JSSEngine. With user-supplied TrustManagers, we check whether or not we can be async and prefer that (issuing a DelegatedTask to actually run this validation).\nIn the future, since we might include other BadCert callback hooks, we might use async, so I added this too.", "author": "cipherboy", "createdAt": "2020-08-31T20:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjgyMg=="}], "type": "inlineReview", "revised_code": null}]}