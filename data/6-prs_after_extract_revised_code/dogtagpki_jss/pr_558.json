{"pr_number": 558, "pr_title": "Add SSLSocket benchmark", "pr_createdAt": "2020-05-20T19:28:50Z", "pr_url": "https://github.com/dogtagpki/jss/pull/558", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MTUxMQ==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428271511", "bodyText": "This is probably fine to compare blocking sockets (i.e. the legacy JSS socket, the new one, JSSE socket), but if we want to compare against NGINX we might want to use the non-blocking socket (with SocketChannel) with just 1 thread.", "author": "edewata", "createdAt": "2020-05-20T19:55:56Z", "path": "org/mozilla/jss/tests/BenchmarkSSLSocket.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.mozilla.jss.tests;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.mozilla.jss.CryptoManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n+\n+/**\n+ * Utility for benchmarking the performance of SSLSocket implementations.\n+ *\n+ * This benchmark is a server-side SSLSocket benchmark for use with clients\n+ * which measure performance. This benchmark does not, itself, make any\n+ * performance measurements. For instance:\n+ * <pre>\n+ * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n+ * $ siege -c 100 -b -t 5m https://localhost:8443\n+ * $ kill %1\n+ * </pre>\n+ *\n+ * There are three supported SSLSocket implementations:\n+ *\n+ *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n+ *     name: JSS.legacy\n+ *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n+ *     name: JSS.SSLSocket\n+ *  3. sun.security's SSLSocketImpl from the current JDK.\n+ *     name: SunJSSE.SSLSocket\n+ *\n+ * It is suggested to disable all logging (for instance, via:\n+ * truncate -s 0 tools/logging.properties) in order have reproducible\n+ * results.\n+ *\n+ * This class takes four arguments when invoked:\n+ *\n+ *  1. The name of the implementation to benchmark, see above.\n+ *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n+ *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n+ *     implementations will utilize a nickname instead.\n+ *  3. The port to listen on.\n+ *  4. The size of the HTTP message to fake.\n+ *\n+ * Note that, when utilizing a JSS provider, JSS must be loaded via a\n+ * java.security. When utilizing SunJSSE, for best results, do not load\n+ * JSS via java.security.\n+ *\n+ * It is suggested to use run_test.sh from the build/ directory for this.\n+ */\n+public class BenchmarkSSLSocket {\n+    public String type;\n+    public int port;\n+    public int size;\n+    public String nickname;\n+\n+    public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n+    public String message;\n+\n+    public BenchmarkSSLSocket(String[] args) throws Exception {\n+        type = args[0];\n+        nickname = args[1];\n+        port = Integer.parseInt(args[2]);\n+        size = Integer.parseInt(args[3]);\n+\n+        headers = headers + \"Content-Length: \" + size + \"\\r\\n\";\n+\n+        StringBuilder sb = new StringBuilder(size);\n+        for (int i = 0; i < size; i++) {\n+            sb.append(\"a\");\n+        }\n+\n+        message = headers + \"\\r\\n\" + sb.toString();\n+    }\n+\n+    public ServerSocket getServerSocket() throws Exception {\n+        switch (type) {\n+            case \"JSS.legacy\": {\n+                org.mozilla.jss.ssl.SSLServerSocket sock = new org.mozilla.jss.ssl.SSLServerSocket(port);\n+                sock.setSoTimeout(0);\n+                org.mozilla.jss.ssl.SSLServerSocket.configServerSessionIDCache(0, 43200, 43200, null);\n+\n+                sock.setReuseAddress(true);\n+                sock.requestClientAuth(false);\n+                sock.requireClientAuth(org.mozilla.jss.ssl.SSLSocket.SSL_REQUIRE_NEVER);\n+                sock.setUseClientMode(false);\n+                sock.setServerCertNickname(nickname);\n+\n+                return sock;\n+            }\n+            case \"JSS.SSLSocket\": {\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NssX509\");\n+\n+                SSLContext ctx = SSLContext.getInstance(\"TLS\", \"Mozilla-JSS\");\n+                ctx.init(\n+                    kmf.getKeyManagers(),\n+                    new TrustManager[] { new JSSNativeTrustManager() },\n+                    null\n+                );\n+\n+                SSLServerSocketFactory factory = ctx.getServerSocketFactory();\n+                org.mozilla.jss.ssl.javax.JSSServerSocket sock = (org.mozilla.jss.ssl.javax.JSSServerSocket) factory.createServerSocket(port);\n+\n+                sock.setReuseAddress(true);\n+                sock.setWantClientAuth(false);\n+                sock.setNeedClientAuth(false);\n+                sock.setUseClientMode(false);\n+                sock.setCertFromAlias(nickname);\n+\n+                return sock;\n+            }\n+            case \"SunJSSE.SSLSocket\": {\n+                FileInputStream fis = new FileInputStream(nickname);\n+                KeyStore store = KeyStore.getInstance(\"PKCS12\");\n+                store.load(fis, \"m1oZilla\".toCharArray());\n+\n+                // Courtesy of https://stackoverflow.com/questions/537040/how-to-connect-to-a-secure-website-using-ssl-in-java-with-a-pkcs12-file\n+                KeyStore jks = KeyStore.getInstance(\"JKS\");\n+                jks.load(null);\n+\n+                KeyStore ks = store;\n+                for (java.util.Enumeration<String>t=ks.aliases();t.hasMoreElements();)\n+                {\n+                    String alias = t.nextElement();\n+                    System.out.println(\"@:\" + alias);\n+                    if (ks.isKeyEntry(alias)){\n+                        java.security.cert.Certificate[] a = ks.getCertificateChain(alias);\n+                        for (int i=0;i<a.length;i++)\n+                        {\n+                            java.security.cert.X509Certificate x509 = (java.security.cert.X509Certificate)a[i];\n+                            System.out.println(x509.getSubjectDN().toString());\n+                            if (i>0)\n+                                jks.setCertificateEntry(x509.getSubjectDN().toString(), x509);\n+                            System.out.println(ks.getCertificateAlias(x509));\n+                            System.out.println(\"ok\");\n+                        }\n+                    }\n+                }\n+\n+\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+                kmf.init(store, \"m1oZilla\".toCharArray());\n+                TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+                tmf.init(store);\n+\n+                SSLContext ctx = SSLContext.getInstance(\"TLS\", \"SunJSSE\");\n+                ctx.init(\n+                    kmf.getKeyManagers(),\n+                    tmf.getTrustManagers(),\n+                    null\n+                );\n+\n+                SSLServerSocketFactory factory = ctx.getServerSocketFactory();\n+                javax.net.ssl.SSLServerSocket sock = (javax.net.ssl.SSLServerSocket) factory.createServerSocket(port);\n+\n+                sock.setReuseAddress(true);\n+                sock.setWantClientAuth(false);\n+                sock.setNeedClientAuth(false);\n+                sock.setUseClientMode(false);\n+\n+                return sock;\n+            }\n+            default:\n+                throw new RuntimeException(\"Unknown socket type: `\" + type + \"` -- expected one of `JSS.SSLSocket`, `JSS.legacy`, or `SunJSSE.SSLSocket`.\");\n+        }\n+    }\n+\n+    class PeerTask implements Runnable {\n+        Socket peer;\n+        byte[] message;\n+\n+        public PeerTask(Socket peer, String message) {\n+            this.peer = peer;\n+            this.message = message.getBytes();\n+        }\n+\n+        public void run() {\n+            try {\n+                try {\n+                    // First, force a handshake\n+                    if (peer instanceof org.mozilla.jss.ssl.SSLSocket) {\n+                        org.mozilla.jss.ssl.SSLSocket sock = (org.mozilla.jss.ssl.SSLSocket) peer;\n+                        sock.setUseClientMode(false);\n+                        sock.forceHandshake();\n+                    } else if (peer instanceof javax.net.ssl.SSLSocket) {\n+                        javax.net.ssl.SSLSocket sock = (javax.net.ssl.SSLSocket) peer;\n+                        sock.setUseClientMode(false);\n+                        sock.startHandshake();\n+                    }\n+\n+                    // Consume all input data.\n+                    InputStream is = peer.getInputStream();\n+                    byte[] in_data = new byte[is.available()];\n+                    is.read(in_data);\n+\n+                    // Send our message back.\n+                    OutputStream os = peer.getOutputStream();\n+                    os.write(message);\n+                } finally {\n+                    peer.close();\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    public void run() throws Exception {\n+        try (\n+            ServerSocket server_socket = getServerSocket();\n+        ) {\n+            while (true) {\n+                Socket peer_socket = server_socket.accept();\n+                Runnable task = new PeerTask(peer_socket, message);\n+                Thread thread = new Thread(task);\n+                thread.start();", "originalCommit": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3MjIzMw==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428672233", "bodyText": "Sure -- I think we'd need a SelectorProvider, but I'm not familiar with that. If you know how to use it, do let me know! (Also, we'd only be able to compare the new JSS socket and not the old one or the SunJSSE ones).", "author": "cipherboy", "createdAt": "2020-05-21T14:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MTUxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "chunk": "diff --git a/org/mozilla/jss/tests/BenchmarkSSLSocket.java b/org/mozilla/jss/tests/BenchmarkSSLSocket.java\nindex 42473982..dcc6b8aa 100644\n--- a/org/mozilla/jss/tests/BenchmarkSSLSocket.java\n+++ b/org/mozilla/jss/tests/BenchmarkSSLSocket.java\n\n@@ -23,57 +23,24 @@ import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n /**\n  * Utility for benchmarking the performance of SSLSocket implementations.\n  *\n- * This benchmark is a server-side SSLSocket benchmark for use with clients\n- * which measure performance. This benchmark does not, itself, make any\n- * performance measurements. For instance:\n- * <pre>\n- * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n- * $ siege -c 100 -b -t 5m https://localhost:8443\n- * $ kill %1\n- * </pre>\n- *\n- * There are three supported SSLSocket implementations:\n- *\n- *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n- *     name: JSS.legacy\n- *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n- *     name: JSS.SSLSocket\n- *  3. sun.security's SSLSocketImpl from the current JDK.\n- *     name: SunJSSE.SSLSocket\n- *\n- * It is suggested to disable all logging (for instance, via:\n- * truncate -s 0 tools/logging.properties) in order have reproducible\n- * results.\n- *\n- * This class takes four arguments when invoked:\n- *\n- *  1. The name of the implementation to benchmark, see above.\n- *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n- *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n- *     implementations will utilize a nickname instead.\n- *  3. The port to listen on.\n- *  4. The size of the HTTP message to fake.\n- *\n- * Note that, when utilizing a JSS provider, JSS must be loaded via a\n- * java.security. When utilizing SunJSSE, for best results, do not load\n- * JSS via java.security.\n- *\n- * It is suggested to use run_test.sh from the build/ directory for this.\n+ * For information about using this benchmark, see the documentation in this\n+ * repo at: /docs/usage/benchmarksslsocket.md\n  */\n public class BenchmarkSSLSocket {\n     public String type;\n+    public String nickname;\n+    public String password;\n     public int port;\n     public int size;\n-    public String nickname;\n \n     public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n     public String message;\n \n-    public BenchmarkSSLSocket(String[] args) throws Exception {\n-        type = args[0];\n-        nickname = args[1];\n-        port = Integer.parseInt(args[2]);\n-        size = Integer.parseInt(args[3]);\n+    public BenchmarkSSLSocket(String type, String nickname, int port, int size) throws Exception {\n+        this.type = type;\n+        this.nickname = nickname;\n+        this.port = port;\n+        this.size = size;\n \n         headers = headers + \"Content-Length: \" + size + \"\\r\\n\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MjgwNg==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428272806", "bodyText": "I think a class constructor should normally take named params, e.g.:\npublic BenchmarkSSLSocket(String type, String nickname, int port, int size) throws Exception {\n\nCLI argument parsing should be done in main().", "author": "edewata", "createdAt": "2020-05-20T19:58:25Z", "path": "org/mozilla/jss/tests/BenchmarkSSLSocket.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.mozilla.jss.tests;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.mozilla.jss.CryptoManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n+\n+/**\n+ * Utility for benchmarking the performance of SSLSocket implementations.\n+ *\n+ * This benchmark is a server-side SSLSocket benchmark for use with clients\n+ * which measure performance. This benchmark does not, itself, make any\n+ * performance measurements. For instance:\n+ * <pre>\n+ * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n+ * $ siege -c 100 -b -t 5m https://localhost:8443\n+ * $ kill %1\n+ * </pre>\n+ *\n+ * There are three supported SSLSocket implementations:\n+ *\n+ *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n+ *     name: JSS.legacy\n+ *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n+ *     name: JSS.SSLSocket\n+ *  3. sun.security's SSLSocketImpl from the current JDK.\n+ *     name: SunJSSE.SSLSocket\n+ *\n+ * It is suggested to disable all logging (for instance, via:\n+ * truncate -s 0 tools/logging.properties) in order have reproducible\n+ * results.\n+ *\n+ * This class takes four arguments when invoked:\n+ *\n+ *  1. The name of the implementation to benchmark, see above.\n+ *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n+ *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n+ *     implementations will utilize a nickname instead.\n+ *  3. The port to listen on.\n+ *  4. The size of the HTTP message to fake.\n+ *\n+ * Note that, when utilizing a JSS provider, JSS must be loaded via a\n+ * java.security. When utilizing SunJSSE, for best results, do not load\n+ * JSS via java.security.\n+ *\n+ * It is suggested to use run_test.sh from the build/ directory for this.\n+ */\n+public class BenchmarkSSLSocket {\n+    public String type;\n+    public int port;\n+    public int size;\n+    public String nickname;\n+\n+    public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n+    public String message;\n+\n+    public BenchmarkSSLSocket(String[] args) throws Exception {\n+        type = args[0];\n+        nickname = args[1];\n+        port = Integer.parseInt(args[2]);\n+        size = Integer.parseInt(args[3]);", "originalCommit": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY3MjMzOA==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428672338", "bodyText": "Sure, I can make that change. Thanks!", "author": "cipherboy", "createdAt": "2020-05-21T14:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MjgwNg=="}], "type": "inlineReview", "revised_code": {"commit": "e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "chunk": "diff --git a/org/mozilla/jss/tests/BenchmarkSSLSocket.java b/org/mozilla/jss/tests/BenchmarkSSLSocket.java\nindex 42473982..dcc6b8aa 100644\n--- a/org/mozilla/jss/tests/BenchmarkSSLSocket.java\n+++ b/org/mozilla/jss/tests/BenchmarkSSLSocket.java\n\n@@ -23,57 +23,24 @@ import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n /**\n  * Utility for benchmarking the performance of SSLSocket implementations.\n  *\n- * This benchmark is a server-side SSLSocket benchmark for use with clients\n- * which measure performance. This benchmark does not, itself, make any\n- * performance measurements. For instance:\n- * <pre>\n- * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n- * $ siege -c 100 -b -t 5m https://localhost:8443\n- * $ kill %1\n- * </pre>\n- *\n- * There are three supported SSLSocket implementations:\n- *\n- *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n- *     name: JSS.legacy\n- *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n- *     name: JSS.SSLSocket\n- *  3. sun.security's SSLSocketImpl from the current JDK.\n- *     name: SunJSSE.SSLSocket\n- *\n- * It is suggested to disable all logging (for instance, via:\n- * truncate -s 0 tools/logging.properties) in order have reproducible\n- * results.\n- *\n- * This class takes four arguments when invoked:\n- *\n- *  1. The name of the implementation to benchmark, see above.\n- *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n- *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n- *     implementations will utilize a nickname instead.\n- *  3. The port to listen on.\n- *  4. The size of the HTTP message to fake.\n- *\n- * Note that, when utilizing a JSS provider, JSS must be loaded via a\n- * java.security. When utilizing SunJSSE, for best results, do not load\n- * JSS via java.security.\n- *\n- * It is suggested to use run_test.sh from the build/ directory for this.\n+ * For information about using this benchmark, see the documentation in this\n+ * repo at: /docs/usage/benchmarksslsocket.md\n  */\n public class BenchmarkSSLSocket {\n     public String type;\n+    public String nickname;\n+    public String password;\n     public int port;\n     public int size;\n-    public String nickname;\n \n     public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n     public String message;\n \n-    public BenchmarkSSLSocket(String[] args) throws Exception {\n-        type = args[0];\n-        nickname = args[1];\n-        port = Integer.parseInt(args[2]);\n-        size = Integer.parseInt(args[3]);\n+    public BenchmarkSSLSocket(String type, String nickname, int port, int size) throws Exception {\n+        this.type = type;\n+        this.nickname = nickname;\n+        this.port = port;\n+        this.size = size;\n \n         headers = headers + \"Content-Length: \" + size + \"\\r\\n\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NjQ3Mw==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428276473", "bodyText": "It might be better to put the above doc in a Markdown page for better visibility.", "author": "edewata", "createdAt": "2020-05-20T20:05:26Z", "path": "org/mozilla/jss/tests/BenchmarkSSLSocket.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.mozilla.jss.tests;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.mozilla.jss.CryptoManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n+\n+/**\n+ * Utility for benchmarking the performance of SSLSocket implementations.\n+ *\n+ * This benchmark is a server-side SSLSocket benchmark for use with clients\n+ * which measure performance. This benchmark does not, itself, make any\n+ * performance measurements. For instance:\n+ * <pre>\n+ * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n+ * $ siege -c 100 -b -t 5m https://localhost:8443\n+ * $ kill %1\n+ * </pre>\n+ *\n+ * There are three supported SSLSocket implementations:\n+ *\n+ *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n+ *     name: JSS.legacy\n+ *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n+ *     name: JSS.SSLSocket\n+ *  3. sun.security's SSLSocketImpl from the current JDK.\n+ *     name: SunJSSE.SSLSocket\n+ *\n+ * It is suggested to disable all logging (for instance, via:\n+ * truncate -s 0 tools/logging.properties) in order have reproducible\n+ * results.\n+ *\n+ * This class takes four arguments when invoked:\n+ *\n+ *  1. The name of the implementation to benchmark, see above.\n+ *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n+ *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n+ *     implementations will utilize a nickname instead.\n+ *  3. The port to listen on.\n+ *  4. The size of the HTTP message to fake.\n+ *\n+ * Note that, when utilizing a JSS provider, JSS must be loaded via a\n+ * java.security. When utilizing SunJSSE, for best results, do not load\n+ * JSS via java.security.\n+ *\n+ * It is suggested to use run_test.sh from the build/ directory for this.", "originalCommit": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4NjA1Nw==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428686057", "bodyText": "Hmmm... We could. But then the documentation is separate from the code and we'd have to remember to update each. This also helps people who stumble upon the code understand how to use it without having to find the relevant doc. :-) Preferences?", "author": "cipherboy", "createdAt": "2020-05-21T14:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NjQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY5NDQxNQ==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428694415", "bodyText": "I think if the doc is about how to use the class as a programmer, it can stay here as Javadoc. But if it's about using it from command line, it belongs to a separate user's guide. We can put a link from here to the doc, and probably from the doc to here as well. Would that be sufficient? Man pages are separate from the code too.", "author": "edewata", "createdAt": "2020-05-21T14:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NjQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwOTM4Mw==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428709383", "bodyText": "We probably can include the test results that you have above in the doc as well so we have some idea about the current performance.", "author": "edewata", "createdAt": "2020-05-21T15:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NjQ3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "chunk": "diff --git a/org/mozilla/jss/tests/BenchmarkSSLSocket.java b/org/mozilla/jss/tests/BenchmarkSSLSocket.java\nindex 42473982..dcc6b8aa 100644\n--- a/org/mozilla/jss/tests/BenchmarkSSLSocket.java\n+++ b/org/mozilla/jss/tests/BenchmarkSSLSocket.java\n\n@@ -23,57 +23,24 @@ import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n /**\n  * Utility for benchmarking the performance of SSLSocket implementations.\n  *\n- * This benchmark is a server-side SSLSocket benchmark for use with clients\n- * which measure performance. This benchmark does not, itself, make any\n- * performance measurements. For instance:\n- * <pre>\n- * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n- * $ siege -c 100 -b -t 5m https://localhost:8443\n- * $ kill %1\n- * </pre>\n- *\n- * There are three supported SSLSocket implementations:\n- *\n- *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n- *     name: JSS.legacy\n- *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n- *     name: JSS.SSLSocket\n- *  3. sun.security's SSLSocketImpl from the current JDK.\n- *     name: SunJSSE.SSLSocket\n- *\n- * It is suggested to disable all logging (for instance, via:\n- * truncate -s 0 tools/logging.properties) in order have reproducible\n- * results.\n- *\n- * This class takes four arguments when invoked:\n- *\n- *  1. The name of the implementation to benchmark, see above.\n- *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n- *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n- *     implementations will utilize a nickname instead.\n- *  3. The port to listen on.\n- *  4. The size of the HTTP message to fake.\n- *\n- * Note that, when utilizing a JSS provider, JSS must be loaded via a\n- * java.security. When utilizing SunJSSE, for best results, do not load\n- * JSS via java.security.\n- *\n- * It is suggested to use run_test.sh from the build/ directory for this.\n+ * For information about using this benchmark, see the documentation in this\n+ * repo at: /docs/usage/benchmarksslsocket.md\n  */\n public class BenchmarkSSLSocket {\n     public String type;\n+    public String nickname;\n+    public String password;\n     public int port;\n     public int size;\n-    public String nickname;\n \n     public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n     public String message;\n \n-    public BenchmarkSSLSocket(String[] args) throws Exception {\n-        type = args[0];\n-        nickname = args[1];\n-        port = Integer.parseInt(args[2]);\n-        size = Integer.parseInt(args[3]);\n+    public BenchmarkSSLSocket(String type, String nickname, int port, int size) throws Exception {\n+        this.type = type;\n+        this.nickname = nickname;\n+        this.port = port;\n+        this.size = size;\n \n         headers = headers + \"Content-Length: \" + size + \"\\r\\n\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyMg==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428277222", "bodyText": "The PKCS #12 password is hardcoded, so we should mention that in the doc as well, or provide a param to specify the password.", "author": "edewata", "createdAt": "2020-05-20T20:06:47Z", "path": "org/mozilla/jss/tests/BenchmarkSSLSocket.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.mozilla.jss.tests;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.mozilla.jss.CryptoManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n+\n+/**\n+ * Utility for benchmarking the performance of SSLSocket implementations.\n+ *\n+ * This benchmark is a server-side SSLSocket benchmark for use with clients\n+ * which measure performance. This benchmark does not, itself, make any\n+ * performance measurements. For instance:\n+ * <pre>\n+ * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n+ * $ siege -c 100 -b -t 5m https://localhost:8443\n+ * $ kill %1\n+ * </pre>\n+ *\n+ * There are three supported SSLSocket implementations:\n+ *\n+ *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n+ *     name: JSS.legacy\n+ *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n+ *     name: JSS.SSLSocket\n+ *  3. sun.security's SSLSocketImpl from the current JDK.\n+ *     name: SunJSSE.SSLSocket\n+ *\n+ * It is suggested to disable all logging (for instance, via:\n+ * truncate -s 0 tools/logging.properties) in order have reproducible\n+ * results.\n+ *\n+ * This class takes four arguments when invoked:\n+ *\n+ *  1. The name of the implementation to benchmark, see above.\n+ *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n+ *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n+ *     implementations will utilize a nickname instead.\n+ *  3. The port to listen on.\n+ *  4. The size of the HTTP message to fake.\n+ *\n+ * Note that, when utilizing a JSS provider, JSS must be loaded via a\n+ * java.security. When utilizing SunJSSE, for best results, do not load\n+ * JSS via java.security.\n+ *\n+ * It is suggested to use run_test.sh from the build/ directory for this.\n+ */\n+public class BenchmarkSSLSocket {\n+    public String type;\n+    public int port;\n+    public int size;\n+    public String nickname;\n+\n+    public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n+    public String message;\n+\n+    public BenchmarkSSLSocket(String[] args) throws Exception {\n+        type = args[0];\n+        nickname = args[1];\n+        port = Integer.parseInt(args[2]);\n+        size = Integer.parseInt(args[3]);\n+\n+        headers = headers + \"Content-Length: \" + size + \"\\r\\n\";\n+\n+        StringBuilder sb = new StringBuilder(size);\n+        for (int i = 0; i < size; i++) {\n+            sb.append(\"a\");\n+        }\n+\n+        message = headers + \"\\r\\n\" + sb.toString();\n+    }\n+\n+    public ServerSocket getServerSocket() throws Exception {\n+        switch (type) {\n+            case \"JSS.legacy\": {\n+                org.mozilla.jss.ssl.SSLServerSocket sock = new org.mozilla.jss.ssl.SSLServerSocket(port);\n+                sock.setSoTimeout(0);\n+                org.mozilla.jss.ssl.SSLServerSocket.configServerSessionIDCache(0, 43200, 43200, null);\n+\n+                sock.setReuseAddress(true);\n+                sock.requestClientAuth(false);\n+                sock.requireClientAuth(org.mozilla.jss.ssl.SSLSocket.SSL_REQUIRE_NEVER);\n+                sock.setUseClientMode(false);\n+                sock.setServerCertNickname(nickname);\n+\n+                return sock;\n+            }\n+            case \"JSS.SSLSocket\": {\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NssX509\");\n+\n+                SSLContext ctx = SSLContext.getInstance(\"TLS\", \"Mozilla-JSS\");\n+                ctx.init(\n+                    kmf.getKeyManagers(),\n+                    new TrustManager[] { new JSSNativeTrustManager() },\n+                    null\n+                );\n+\n+                SSLServerSocketFactory factory = ctx.getServerSocketFactory();\n+                org.mozilla.jss.ssl.javax.JSSServerSocket sock = (org.mozilla.jss.ssl.javax.JSSServerSocket) factory.createServerSocket(port);\n+\n+                sock.setReuseAddress(true);\n+                sock.setWantClientAuth(false);\n+                sock.setNeedClientAuth(false);\n+                sock.setUseClientMode(false);\n+                sock.setCertFromAlias(nickname);\n+\n+                return sock;\n+            }\n+            case \"SunJSSE.SSLSocket\": {\n+                FileInputStream fis = new FileInputStream(nickname);\n+                KeyStore store = KeyStore.getInstance(\"PKCS12\");\n+                store.load(fis, \"m1oZilla\".toCharArray());", "originalCommit": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY4MjMzNw==", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428682337", "bodyText": "Ah, I've added an optional form for the password, thanks!", "author": "cipherboy", "createdAt": "2020-05-21T14:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "chunk": "diff --git a/org/mozilla/jss/tests/BenchmarkSSLSocket.java b/org/mozilla/jss/tests/BenchmarkSSLSocket.java\nindex 42473982..dcc6b8aa 100644\n--- a/org/mozilla/jss/tests/BenchmarkSSLSocket.java\n+++ b/org/mozilla/jss/tests/BenchmarkSSLSocket.java\n\n@@ -23,57 +23,24 @@ import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n /**\n  * Utility for benchmarking the performance of SSLSocket implementations.\n  *\n- * This benchmark is a server-side SSLSocket benchmark for use with clients\n- * which measure performance. This benchmark does not, itself, make any\n- * performance measurements. For instance:\n- * <pre>\n- * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n- * $ siege -c 100 -b -t 5m https://localhost:8443\n- * $ kill %1\n- * </pre>\n- *\n- * There are three supported SSLSocket implementations:\n- *\n- *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n- *     name: JSS.legacy\n- *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n- *     name: JSS.SSLSocket\n- *  3. sun.security's SSLSocketImpl from the current JDK.\n- *     name: SunJSSE.SSLSocket\n- *\n- * It is suggested to disable all logging (for instance, via:\n- * truncate -s 0 tools/logging.properties) in order have reproducible\n- * results.\n- *\n- * This class takes four arguments when invoked:\n- *\n- *  1. The name of the implementation to benchmark, see above.\n- *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n- *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n- *     implementations will utilize a nickname instead.\n- *  3. The port to listen on.\n- *  4. The size of the HTTP message to fake.\n- *\n- * Note that, when utilizing a JSS provider, JSS must be loaded via a\n- * java.security. When utilizing SunJSSE, for best results, do not load\n- * JSS via java.security.\n- *\n- * It is suggested to use run_test.sh from the build/ directory for this.\n+ * For information about using this benchmark, see the documentation in this\n+ * repo at: /docs/usage/benchmarksslsocket.md\n  */\n public class BenchmarkSSLSocket {\n     public String type;\n+    public String nickname;\n+    public String password;\n     public int port;\n     public int size;\n-    public String nickname;\n \n     public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n     public String message;\n \n-    public BenchmarkSSLSocket(String[] args) throws Exception {\n-        type = args[0];\n-        nickname = args[1];\n-        port = Integer.parseInt(args[2]);\n-        size = Integer.parseInt(args[3]);\n+    public BenchmarkSSLSocket(String type, String nickname, int port, int size) throws Exception {\n+        this.type = type;\n+        this.nickname = nickname;\n+        this.port = port;\n+        this.size = size;\n \n         headers = headers + \"Content-Length: \" + size + \"\\r\\n\";\n \n"}}, {"oid": "e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "url": "https://github.com/dogtagpki/jss/commit/e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "message": "Add SSLSocket benchmark\n\nThis benchmark supports three providers:\n\n 1. org.mozilla.jss.ssl.SSLSocket, named JSS.legacy\n 2. org.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\n 3. the JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nDocumentation for this benchmark is available under the docs/usage\nfolder.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-21T17:19:16Z", "type": "forcePushed"}, {"oid": "132d9dd9e3e2c72bffd57da24f13874967d258d3", "url": "https://github.com/dogtagpki/jss/commit/132d9dd9e3e2c72bffd57da24f13874967d258d3", "message": "Add SSLSocket benchmark\n\nThis benchmark supports three providers:\n\n 1. org.mozilla.jss.ssl.SSLSocket, named JSS.legacy\n 2. org.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\n 3. the JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nDocumentation for this benchmark is available under the docs/usage\nfolder.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-22T15:33:38Z", "type": "commit"}, {"oid": "132d9dd9e3e2c72bffd57da24f13874967d258d3", "url": "https://github.com/dogtagpki/jss/commit/132d9dd9e3e2c72bffd57da24f13874967d258d3", "message": "Add SSLSocket benchmark\n\nThis benchmark supports three providers:\n\n 1. org.mozilla.jss.ssl.SSLSocket, named JSS.legacy\n 2. org.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\n 3. the JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nDocumentation for this benchmark is available under the docs/usage\nfolder.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-22T15:33:38Z", "type": "forcePushed"}]}