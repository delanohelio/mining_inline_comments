{"pr_number": 642, "pr_title": "JSSSocketChannel.read(): deliver all data from buffer fd", "pr_createdAt": "2020-10-09T06:27:38Z", "pr_url": "https://github.com/dogtagpki/jss/pull/642", "timeline": [{"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e", "url": "https://github.com/dogtagpki/jss/commit/5546846ce77e6664562af6b1ebf28dbc8fe0e39e", "message": "JSSSocketChannel.read(): deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved.", "committedDate": "2020-10-09T06:43:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQxMTYxMA==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502411610", "bodyText": "I wouldn't do this either.\nWe've discussed this with @edewata earlier. See #532, and #532 (comment).\nAs I understand more about this architecture... a Socket is either a blocking or non-blocking file descriptor, but a SocketChannel is non-blocking. Only in the event that a Socket is blocking will a SocketChannel be created.\nIn JSS we abuse this slightly. We use the JSSSocket as the front to SSL operations, but in order to \"do\" SSL, we use the JSSSocketChannel as an intermediary between the JSSSocket and the JSSEngine.\nNote that callers using a SocketChannel are mostly expected to do SSL operations themselves directly with a SSLEngine. There's no relevant methods in the standard to upcast a SocketChannel into a SSLSocketChannel.", "author": "cipherboy", "createdAt": "2020-10-09T13:03:07Z", "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -234,10 +234,6 @@ public JSSEngine getEngine() {\n      * @see java.net.Socket#getChannel()\n      */\n     public JSSSocketChannel getChannel() {\n-        if (parent.getChannel() == null) {", "originalCommit": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUxMDYzNw==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502510637", "bodyText": "(IOW, it is tempting to grab the underlying JSSSocketChannel, but if you truly want non-blocking sockets, you should create a non-blocking socket to begin with...)", "author": "cipherboy", "createdAt": "2020-10-09T15:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQxMTYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUxNDMwOA==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502514308", "bodyText": "OK, sure, I can drop this bit.  I added this because I first encountered this bug using the InputStream/OutputStream interface, then switched to channels to see if that helped (and that's when I made ^ that change).\nThe bug still occurs when using the InputStream/OutputStream because we hang those streams off the channel: https://github.com/dogtagpki/jss/blob/aa68098/org/mozilla/jss/ssl/javax/JSSSocket.java#L265-L284 :)", "author": "frasertweedale", "createdAt": "2020-10-09T15:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQxMTYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "5fe5d4d3c57afc83f6d37911166cd87a8544ef3d", "chunk": "diff --git a/org/mozilla/jss/ssl/javax/JSSSocket.java b/org/mozilla/jss/ssl/javax/JSSSocket.java\nindex 229ea9e9..7e2cfec0 100644\n--- a/org/mozilla/jss/ssl/javax/JSSSocket.java\n+++ b/org/mozilla/jss/ssl/javax/JSSSocket.java\n\n@@ -234,6 +234,10 @@ public class JSSSocket extends SSLSocket {\n      * @see java.net.Socket#getChannel()\n      */\n     public JSSSocketChannel getChannel() {\n+        if (parent.getChannel() == null) {\n+            return null;\n+        }\n+\n         return getInternalChannel();\n     }\n \n"}}, {"oid": "5fe5d4d3c57afc83f6d37911166cd87a8544ef3d", "url": "https://github.com/dogtagpki/jss/commit/5fe5d4d3c57afc83f6d37911166cd87a8544ef3d", "message": "JSSSocketChannel.read(): deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved.", "committedDate": "2020-10-13T02:14:28Z", "type": "forcePushed"}, {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20", "url": "https://github.com/dogtagpki/jss/commit/8ad41f9febcca7665d8d20873c19700ae4adfb20", "message": "JSSSocketChannel.read: record when input is closed\n\nWhen reading the socket channel, no special action is taken when the\nSSLEngine.unwrap() returns an SSLEngineResult with status CLOSED.\nAs a consequence, JSSSocketChannel.read() never returns -1, even\nafter the sender has closed their send end of the socket and the TLS\nclose_notify alert has been processed.  Programs that rely on the\nread() returning -1 to indicate end of data will loop forever.\n\nTo resolve, call shutdownInput() when unwrap() indicates that the\nread side of the socket is closed.  This idempotent action causes\nsubsequent invocations of read() to return -1, as required by the\nSocketChannel contract.", "committedDate": "2020-10-13T12:35:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNzczMg==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r511017732", "bodyText": "I think the same applies for write, no? We should shutdown output if the engine reports closed?", "author": "cipherboy", "createdAt": "2020-10-23T16:59:10Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;\n+                    }\n                 }\n \n                 readBuffer.flip();\n \n-                SSLEngineResult result = engine.unwrap(readBuffer, dsts, offset, length);\n-                if (result.getStatus() != SSLEngineResult.Status.OK &&\n-                    result.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW &&\n-                    result.getStatus() != SSLEngineResult.Status.CLOSED) {\n-                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                result = engine.unwrap(readBuffer, dsts, offset, length);\n+                switch (result.getStatus()) {\n+                    case CLOSED:\n+                        shutdownInput();", "originalCommit": "8ad41f9febcca7665d8d20873c19700ae4adfb20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI2OTAyNA==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r511269024", "bodyText": "@cipherboy probably?  Would you be willing to investigate and, if necessary, deal with that in a separate patch?", "author": "frasertweedale", "createdAt": "2020-10-24T02:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNzczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4MzE3Mg==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r511483172", "bodyText": "Sure, I can do that.", "author": "cipherboy", "createdAt": "2020-10-24T15:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNzczMg=="}], "type": "inlineReview", "revised_code": {"commit": "d25e12e66fcc99ba002f8bc7819bdeb8b1b1ba2f", "chunk": "diff --git a/org/mozilla/jss/ssl/javax/JSSSocketChannel.java b/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\nindex 8424885f..d322a4f8 100644\n--- a/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\n+++ b/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\n\n@@ -256,11 +256,13 @@ public class JSSSocketChannel extends SocketChannel {\n                     //\n                     // But if we did not finish the handshake and there were no\n                     // new data, we have to return here.  Calling unwrap() with\n-                    // no data, prior to handshake completion, breaks something.\n+                    // no data, prior to handshake completion, causes the\n+                    // handshake to never complete.  This might be a bug, but\n+                    // for now we have this workaround.\n                     //\n                     // Note we cannot call engine.getHandshakeStatus() to perform\n                     // this check; it is NOT a passive routine and reading it\n-                    // early actually causes the same breakage.\n+                    // early triggers the same failure.\n                     //\n                     if (!handshakeCompleted) {\n                         return decrypted > 0 ? decrypted : n;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzOTczOQ==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512039739", "bodyText": "According to https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ReadableByteChannel.html, 0 is a valid return result and we should probably set consumed and consumedChannel to null in both cases.", "author": "cipherboy", "createdAt": "2020-10-26T15:14:53Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -86,33 +88,28 @@ public void setAutoClose(boolean on) {\n         autoClose = on;\n     }\n \n-    /**\n-     * Internal helper to bound the size of a blocking read to the maximum\n-     * data available.\n-     */\n-    private int boundRead(int suggested) throws IOException {\n-        // When there's consumed data left to read, ensure we bound by the\n-        // amount available there before continuing.\n-        if (consumed != null && consumed.available() > 0) {\n-            return Math.min(consumed.available(), suggested);\n-        }\n-\n-        // By setting consumed = null when consumed no longer has bytes\n-        // available, we provide an easy check for which channel to read\n-        // from.\n-        consumed = null;\n-        consumedChannel = null;\n-\n-        // If its a non-blocking underlying socket, then return suggested;\n-        // it'll read as much as currently available.\n-        if (!isBlocking()) {\n-            return suggested;\n+    private int remoteRead() throws IOException {\n+        if (consumed != null) {\n+            int n = consumedChannel.read(readBuffer);\n+            if (n < 0) {", "originalCommit": "8ad41f9febcca7665d8d20873c19700ae4adfb20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ1NTcwOQ==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512455709", "bodyText": "0 is indeed a valid return value.  It means that zero bytes were read.  It doesn't mean end of stream was reached, so I think it's wrong to discard the consumedChannel in this case.\nBased on consumedChannel = Channels.newChannel(InputStream consumed), return value of 0 seems to be a \"can't happen\" and therefore your proposal is (vacuously) safe.  But I'd rather code to the interface than rely on these implementation details.\nIf you still feel strongly we sohuld change it, I will change it and add some commentary.", "author": "frasertweedale", "createdAt": "2020-10-27T07:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzOTczOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512053836", "bodyText": "I'm not sure I agree with this.\nWhen decrypted > 0, we obviously return decrypted.\nHowever, in the case where decrypted <= 0 (really, it must be 0), the contract of our read() call is the number of bytes decrypted, which is 0. It isn't the number of bytes read from the remote peer.\nThe best example of this is during handshake: read during handshake returns 0 if no data is present -- not because no wire data was transferred (there presumably might have been) -- but because none of it resulted in any decryptable data. (Ignoring 0RTT).\nIMO, since decrypted < 0 won't ever occur, it should be safe to return decrypted.", "author": "cipherboy", "createdAt": "2020-10-26T15:32:39Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;", "originalCommit": "8ad41f9febcca7665d8d20873c19700ae4adfb20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ2MTgyMA==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512461820", "bodyText": "The goal here is to catch the case where remoteRead() < 0 indicating end of stream.  I think this can occur if the connection gets terminated abnormally, i.e. the TLS termination alerts didn't get sent/processed (which needs to happen so inboundClosed gets set).\nIf all streams get closed \"properly\" then I agree with your proposal.  But otherwise, I want to be very careful to avoid situations where JSSSocketChannel.read() could return 0 indefinitely.\nWhat do you think about this scenario @cipherboy?  Is there a better way to handle it?", "author": "frasertweedale", "createdAt": "2020-10-27T07:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTU0OA==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512961548", "bodyText": "If remoteRead returns non-zero, shouldn't we just return remoteRead's value? When the underlying TCP connections terminate unexpectedly, IMO we should never attempt to wrap/unwrap, even if we had old or uncompacted data lying around. We should probably close the TLS SSLEngine's inbound and exit with -1, regardless of handshake status. I think then this entire nested if statement gets simplified and removed, replaced with one that always checks the remoteRead value.\nThis might require a little restructuring, as I think the close() handler doesn't yet understand that the inbound was already closed and to only close the outbound in that case (or visa-versa) but IMO it is a worthwhile improvement.\nAm I missing a case where this wouldn't be correct? I thought it was one of the core guarantees from TLS's RFC.", "author": "cipherboy", "createdAt": "2020-10-27T19:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MjkxMg==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513152912", "bodyText": "However, in the case where decrypted <= 0 (really, it must be 0), the contract of our read() call is the number of bytes decrypted, which is 0. It isn't the number of bytes read from the remote peer.\n\n\nIf remoteRead returns non-zero, shouldn't we just return remoteRead's value?\n\nThe return contract of SocketChannel.read() is number of bytes read (possibly 0) or -1 when this channel reaches end of stream.  If remoteRead() returns -1, there might still be data in readBuffer or in the engine's internal read buffer, so we can't return -1 until unwrap yields no more data.\n\nIMO we should never attempt to wrap/unwrap, even if we had old or uncompacted data lying around.\n\nDisagree.  Because there may be undecrypted data sitting in buffers waiting to be processed, we cannot even know if the closure of the parent socket's input stream is expected or abnormal.  Therefore even when remoteRead() returns -1, we have to wait until unwrap yields no more data before cleaning up and returning -1 from read().\n\nThis might require a little restructuring\n\nI'm sure the structure can be improved.  But... have I convinced you that the statements / expressions we're arguing about are at least not obviously wrong or harmful?  If so, could we merge this PR, add a regression test adapted from my test program, and go forward from there?\nOtherwise... could you write a program to demonstrate bug(s) in the code fragments we're arguing about.  I suggest it not because I'm sure my code is correct (I am not!), but because concrete demonstrations of issues provided a basis for fixing them (and then for regression tests).\ntl;dr this PR fixes some major issues (proven by the test program); there may well be problems with my approach but let's either make them concrete so I can understand and fix them, or merge this PR.", "author": "frasertweedale", "createdAt": "2020-10-28T03:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MDIxNA==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513460214", "bodyText": "Ah I'm with you now.\nI keep thinking -1 return value is only on an error -- i.e., stream incorrectly closed or was otherwise terminated.\nSince it returns -1 on mundane \"no more data for now\" things, yeah, I think this is a good. I'll go ahead and merge.", "author": "cipherboy", "createdAt": "2020-10-28T13:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwMzMwMw==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513503303", "bodyText": "@cipherboy small correction: -1 means (or is supposed to mean) \"no more data ever\", which may or may not be mundane :)", "author": "frasertweedale", "createdAt": "2020-10-28T14:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}], "type": "inlineReview", "revised_code": {"commit": "d25e12e66fcc99ba002f8bc7819bdeb8b1b1ba2f", "chunk": "diff --git a/org/mozilla/jss/ssl/javax/JSSSocketChannel.java b/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\nindex 8424885f..d322a4f8 100644\n--- a/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\n+++ b/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\n\n@@ -256,11 +256,13 @@ public class JSSSocketChannel extends SocketChannel {\n                     //\n                     // But if we did not finish the handshake and there were no\n                     // new data, we have to return here.  Calling unwrap() with\n-                    // no data, prior to handshake completion, breaks something.\n+                    // no data, prior to handshake completion, causes the\n+                    // handshake to never complete.  This might be a bug, but\n+                    // for now we have this workaround.\n                     //\n                     // Note we cannot call engine.getHandshakeStatus() to perform\n                     // this check; it is NOT a passive routine and reading it\n-                    // early actually causes the same breakage.\n+                    // early triggers the same failure.\n                     //\n                     if (!handshakeCompleted) {\n                         return decrypted > 0 ? decrypted : n;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTk4OQ==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512961989", "bodyText": "What was this failure, btw? Do you still happen to have the logs?", "author": "cipherboy", "createdAt": "2020-10-27T19:18:09Z", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform", "originalCommit": "8ad41f9febcca7665d8d20873c19700ae4adfb20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0NDc4Mg==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513144782", "bodyText": "The handshake never completes.  I am not sure the precise mechanism.  I will clarify the comment.  It may well be a bug, but I found this workaround and did not have time to investigate further.", "author": "frasertweedale", "createdAt": "2020-10-28T02:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MTA2NQ==", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513461065", "bodyText": "Interesting. I'm fairly certain we test calling getHandshakeStatus() in a conditional in the existing test suite.", "author": "cipherboy", "createdAt": "2020-10-28T13:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTk4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d25e12e66fcc99ba002f8bc7819bdeb8b1b1ba2f", "chunk": "diff --git a/org/mozilla/jss/ssl/javax/JSSSocketChannel.java b/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\nindex 8424885f..d322a4f8 100644\n--- a/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\n+++ b/org/mozilla/jss/ssl/javax/JSSSocketChannel.java\n\n@@ -256,11 +256,13 @@ public class JSSSocketChannel extends SocketChannel {\n                     //\n                     // But if we did not finish the handshake and there were no\n                     // new data, we have to return here.  Calling unwrap() with\n-                    // no data, prior to handshake completion, breaks something.\n+                    // no data, prior to handshake completion, causes the\n+                    // handshake to never complete.  This might be a bug, but\n+                    // for now we have this workaround.\n                     //\n                     // Note we cannot call engine.getHandshakeStatus() to perform\n                     // this check; it is NOT a passive routine and reading it\n-                    // early actually causes the same breakage.\n+                    // early triggers the same failure.\n                     //\n                     if (!handshakeCompleted) {\n                         return decrypted > 0 ? decrypted : n;\n"}}, {"oid": "d25e12e66fcc99ba002f8bc7819bdeb8b1b1ba2f", "url": "https://github.com/dogtagpki/jss/commit/d25e12e66fcc99ba002f8bc7819bdeb8b1b1ba2f", "message": "JSSSocketChannel.read: deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved.", "committedDate": "2020-10-28T03:09:25Z", "type": "commit"}, {"oid": "905718f2a8fb441825b51fae0f2481965456a160", "url": "https://github.com/dogtagpki/jss/commit/905718f2a8fb441825b51fae0f2481965456a160", "message": "PR.Read: return data when end of stream reached\n\nCommit 424d55639c51bca18110dcff51fb5df2e2e35a41 introduced a\nworkaround in PR.Read for a bug in NSS' PR_Read that occurs on some\nplatforms.  The bug can cause PR_Read to return a smaller amount\nthan requested, even when more data is available.  The workaround is\nto loop until we have either read the requested amount, or we\nencounter PR_WOULD_BLOCK_ERROR.\n\nUnfortunatley there is a bug in the workaround: the end of stream\ncase was not considered.  In this case, the first PR_Read reads less\nthan the requested amount, and we loop.  The next PR_Read returns 0,\nbut the \"not an error\" condition\n\n    PR_GetError() == PR_WOULD_BLOCK_ERROR && read_amount > 0\n\ndoes not admit the end of stream case (PR_GetError() == 0).  As a\nconsequence, PR.Read returns an empty byte[] and the data from the\nfinal read before end of stream are lost.\n\nTo resolve this issue, break the loop when PR_Read returns <= 0 but\nPR_GetError() returns 0.", "committedDate": "2020-10-28T03:09:25Z", "type": "commit"}, {"oid": "1efe2b3ca51cb9c323a5fd809b1d5617621b34dc", "url": "https://github.com/dogtagpki/jss/commit/1efe2b3ca51cb9c323a5fd809b1d5617621b34dc", "message": "JSSSocketChannel.read: record when input is closed\n\nWhen reading the socket channel, no special action is taken when the\nSSLEngine.unwrap() returns an SSLEngineResult with status CLOSED.\nAs a consequence, JSSSocketChannel.read() never returns -1, even\nafter the sender has closed their send end of the socket and the TLS\nclose_notify alert has been processed.  Programs that rely on the\nread() returning -1 to indicate end of data will loop forever.\n\nTo resolve, call shutdownInput() when unwrap() indicates that the\nread side of the socket is closed.  This idempotent action causes\nsubsequent invocations of read() to return -1, as required by the\nSocketChannel contract.", "committedDate": "2020-10-28T03:09:25Z", "type": "commit"}, {"oid": "1efe2b3ca51cb9c323a5fd809b1d5617621b34dc", "url": "https://github.com/dogtagpki/jss/commit/1efe2b3ca51cb9c323a5fd809b1d5617621b34dc", "message": "JSSSocketChannel.read: record when input is closed\n\nWhen reading the socket channel, no special action is taken when the\nSSLEngine.unwrap() returns an SSLEngineResult with status CLOSED.\nAs a consequence, JSSSocketChannel.read() never returns -1, even\nafter the sender has closed their send end of the socket and the TLS\nclose_notify alert has been processed.  Programs that rely on the\nread() returning -1 to indicate end of data will loop forever.\n\nTo resolve, call shutdownInput() when unwrap() indicates that the\nread side of the socket is closed.  This idempotent action causes\nsubsequent invocations of read() to return -1, as required by the\nSocketChannel contract.", "committedDate": "2020-10-28T03:09:25Z", "type": "forcePushed"}]}