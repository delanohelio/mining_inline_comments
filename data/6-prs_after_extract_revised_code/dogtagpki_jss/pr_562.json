{"pr_number": 562, "pr_title": "Remove JSSSocket wait-on-close, fix session cache creation", "pr_createdAt": "2020-05-21T15:16:38Z", "pr_url": "https://github.com/dogtagpki/jss/pull/562", "timeline": [{"oid": "318b6dcee7e03f3f4e9ecb1e7310aae30607ded2", "url": "https://github.com/dogtagpki/jss/commit/318b6dcee7e03f3f4e9ecb1e7310aae30607ded2", "message": "Don't wait for peer close confirmation\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-21T14:31:03Z", "type": "commit"}, {"oid": "f0682ecb1630be759965ca104223c4b460ff7e77", "url": "https://github.com/dogtagpki/jss/commit/f0682ecb1630be759965ca104223c4b460ff7e77", "message": "Fix race in configuring session cache\n\nWhen multiple JSSSockets and/or JSSEngines are started concurrently,\nthey will race to configure the session cache. However, the cache can\nonly be created by one thread at a time and only needs to be done once\nin the lifetime of JSS. Make JSSEngine take ownership of cache creation\nand utilize this within the legacy SSLSocket as well.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-21T15:18:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMjM0NQ==", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428732345", "bodyText": "Could we throw an SSLException instead and declare it in this method? The JSSEngineReferenceImpl.beginHandshake() should have declared an SSLException so we can just let it bubble up.\nGenerally I'd rather not create a RuntimeException as the initial exception unless we can't declare the exception in the method.", "author": "edewata", "createdAt": "2020-05-21T15:35:29Z", "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "diffHunk": "@@ -249,6 +259,20 @@ protected static String errorText(int error) {\n         }\n     }\n \n+    /**\n+     * Safely initializes the session cache if not already initialized.\n+     */\n+    public static void initializeSessionCache(\n+        int maxCacheEntries, long timeout, String directory)\n+    {\n+        if (sessionCacheInitialized.compareAndSet(false, true)) {\n+            if (SSL.ConfigServerSessionIDCache(maxCacheEntries, timeout, timeout, directory) == SSL.SECFailure) {\n+                String msg = \"Unable to configure server session cache: \";\n+                msg += errorText(PR.GetError());\n+                throw new RuntimeException(msg);", "originalCommit": "f0682ecb1630be759965ca104223c4b460ff7e77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3Njk5MQ==", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428776991", "bodyText": "Sure, I think that's possible. I think originally beginHandshake() was called from updateHandshakeState() which in turn is always called from getHandshakeStatus() -- the latter declares no exceptions.", "author": "cipherboy", "createdAt": "2020-05-21T16:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMjM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4Nzk2OA==", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428787968", "bodyText": "Yeah we just need to catch one location of SSLException and re-throw as RuntimeException, but otherwise we can handle that better now.", "author": "cipherboy", "createdAt": "2020-05-21T17:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMjM0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ae4d6da1c9cf61d4031bbf53d60f02fc30720096", "chunk": "diff --git a/org/mozilla/jss/ssl/javax/JSSEngine.java b/org/mozilla/jss/ssl/javax/JSSEngine.java\nindex 114e86c6..5c67b1c3 100644\n--- a/org/mozilla/jss/ssl/javax/JSSEngine.java\n+++ b/org/mozilla/jss/ssl/javax/JSSEngine.java\n\n@@ -262,14 +262,14 @@ public abstract class JSSEngine extends javax.net.ssl.SSLEngine {\n     /**\n      * Safely initializes the session cache if not already initialized.\n      */\n-    public static void initializeSessionCache(\n-        int maxCacheEntries, long timeout, String directory)\n+    public static void initializeSessionCache(int maxCacheEntries,\n+        long timeout, String directory) throws SSLException\n     {\n         if (sessionCacheInitialized.compareAndSet(false, true)) {\n             if (SSL.ConfigServerSessionIDCache(maxCacheEntries, timeout, timeout, directory) == SSL.SECFailure) {\n                 String msg = \"Unable to configure server session cache: \";\n                 msg += errorText(PR.GetError());\n-                throw new RuntimeException(msg);\n+                throw new SSLException(msg);\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczNTU0MA==", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428735540", "bodyText": "I think this should catch SSLException. See my other comment.", "author": "edewata", "createdAt": "2020-05-21T15:40:47Z", "path": "org/mozilla/jss/ssl/SSLServerSocket.java", "diffHunk": "@@ -266,9 +267,21 @@ public void close() throws IOException {\n      *  will contain the session cache. If null is passed, the server default\n      *  is used: <code>/tmp</code> on Unix and <code>\\\\temp</code> on Windows.\n      */\n-    public static native void configServerSessionIDCache(int maxSidEntries,\n-        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory)\n-        throws SocketException;\n+    public static void configServerSessionIDCache(int maxSidEntries,\n+        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory) throws SocketException {\n+        try {\n+            JSSEngine.initializeSessionCache(maxSidEntries, ssl3EntryTimeout, cacheFileDirectory);\n+        } catch (RuntimeException re) {", "originalCommit": "f0682ecb1630be759965ca104223c4b460ff7e77", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae4d6da1c9cf61d4031bbf53d60f02fc30720096", "chunk": "diff --git a/org/mozilla/jss/ssl/SSLServerSocket.java b/org/mozilla/jss/ssl/SSLServerSocket.java\nindex 1d822208..f4aed5e4 100644\n--- a/org/mozilla/jss/ssl/SSLServerSocket.java\n+++ b/org/mozilla/jss/ssl/SSLServerSocket.java\n\n@@ -271,14 +273,14 @@ public class SSLServerSocket extends java.net.ServerSocket {\n         int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory) throws SocketException {\n         try {\n             JSSEngine.initializeSessionCache(maxSidEntries, ssl3EntryTimeout, cacheFileDirectory);\n-        } catch (RuntimeException re) {\n+        } catch (SSLException parent) {\n             // Because JSSEngine.initializeSessionCache is utilized during\n             // init of JSSengine implementations, it can only throw a\n             // RuntimeException. However, in the event it fails, we should\n             // re-throw it here as a SocketException, keeping the signature\n             // the same.\n-            SocketException se = new SSLSocketException(re.getMessage());\n-            se.addSuppressed(re);\n+            SocketException se = new SSLSocketException(parent.getMessage());\n+            se.addSuppressed(parent);\n             throw se;\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0NDM4NA==", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428744384", "bodyText": "The AtomicBoolean should work fine, but a regular boolean sessionCacheInitialized and a synchronized initializeSessionCache() probably would work as well. It's up to you, whichever simpler.", "author": "edewata", "createdAt": "2020-05-21T15:50:37Z", "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "diffHunk": "@@ -176,6 +177,15 @@\n      */\n     protected static HashMap<PK11Cert, SSLFDProxy> serverTemplates = new HashMap<PK11Cert, SSLFDProxy>();\n \n+    /**\n+     * Whether or not the session cache has been initialized already.\n+     *\n+     * A session cache must always be created in order to utilize a\n+     * server-side JSSEngine. However, NSS isn't threadsafe when creating\n+     * such a cache, so synchronize it within JSSEngine.\n+     */\n+    private final static AtomicBoolean sessionCacheInitialized = new AtomicBoolean();", "originalCommit": "f0682ecb1630be759965ca104223c4b460ff7e77", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48f2f58d74f3e54e2ca4a0b0dcb2a0ccf310d2cb", "chunk": "diff --git a/org/mozilla/jss/ssl/javax/JSSEngine.java b/org/mozilla/jss/ssl/javax/JSSEngine.java\nindex 114e86c6..7de63818 100644\n--- a/org/mozilla/jss/ssl/javax/JSSEngine.java\n+++ b/org/mozilla/jss/ssl/javax/JSSEngine.java\n\n@@ -177,15 +176,6 @@ public abstract class JSSEngine extends javax.net.ssl.SSLEngine {\n      */\n     protected static HashMap<PK11Cert, SSLFDProxy> serverTemplates = new HashMap<PK11Cert, SSLFDProxy>();\n \n-    /**\n-     * Whether or not the session cache has been initialized already.\n-     *\n-     * A session cache must always be created in order to utilize a\n-     * server-side JSSEngine. However, NSS isn't threadsafe when creating\n-     * such a cache, so synchronize it within JSSEngine.\n-     */\n-    private final static AtomicBoolean sessionCacheInitialized = new AtomicBoolean();\n-\n     /**\n      * Constructor for a JSSEngine, providing no hints for an internal\n      * session reuse strategy and no key.\n"}}, {"oid": "ae4d6da1c9cf61d4031bbf53d60f02fc30720096", "url": "https://github.com/dogtagpki/jss/commit/ae4d6da1c9cf61d4031bbf53d60f02fc30720096", "message": "Fix race in configuring session cache\n\nWhen multiple JSSSockets and/or JSSEngines are started concurrently,\nthey will race to configure the session cache. However, the cache can\nonly be created by one thread at a time and only needs to be done once\nin the lifetime of JSS. Make JSSEngine take ownership of cache creation\nand utilize this within the legacy SSLSocket as well.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-21T17:01:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg4OTkyNA==", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428889924", "bodyText": "IllegalArgumentException is a RuntimeException so it doesn't have to be declared.", "author": "edewata", "createdAt": "2020-05-21T20:16:32Z", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -196,31 +196,31 @@ private void createBufferFD() {\n         // Turn on SSL Alert Logging for the ssl_fd object.\n         int ret = SSL.EnableAlertLogging(ssl_fd);\n         if (ret == SSL.SECFailure) {\n-            throw new RuntimeException(\"JSSEngine.init(): Unable to enable SSL Alert Logging on this SSLFDProxy instance.\");\n+            throw new SSLException(\"Unable to enable SSL Alert Logging on this SSLFDProxy instance.\");\n         }\n \n         ret = SSL.EnableHandshakeCallback(ssl_fd);\n         if (ret == SSL.SECFailure) {\n-            throw new RuntimeException(\"JSSEngine.init(): Unable to enable SSL Handshake Callback on this SSLFDProxy instance.\");\n+            throw new SSLException(\"Unable to enable SSL Handshake Callback on this SSLFDProxy instance.\");\n         }\n \n         // Pass this ssl_fd to the session object so that we can use\n         // SSL methods to invalidate the session.\n     }\n \n-    private void initClient() {\n+    private void initClient() throws SSLException {\n         debug(\"JSSEngine: initClient()\");\n \n         if (cert != null && key != null) {\n             debug(\"JSSEngine.initClient(): Enabling client auth: \" + cert);\n             ssl_fd.SetClientCert(cert);\n             if (SSL.AttachClientCertCallback(ssl_fd) != SSL.SECSuccess) {\n-                throw new RuntimeException(\"JSSEngine.init(): Unable to attach client certificate auth callback.\");\n+                throw new SSLException(\"Unable to attach client certificate auth callback.\");\n             }\n         }\n     }\n \n-    private void initServer() {\n+    private void initServer() throws SSLException, IllegalArgumentException {", "originalCommit": "ae4d6da1c9cf61d4031bbf53d60f02fc30720096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48f2f58d74f3e54e2ca4a0b0dcb2a0ccf310d2cb", "chunk": "diff --git a/org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java b/org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java\nindex c64a5dcc..ce9c87d3 100644\n--- a/org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java\n+++ b/org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java\n\n@@ -220,7 +220,7 @@ public class JSSEngineReferenceImpl extends JSSEngine {\n         }\n     }\n \n-    private void initServer() throws SSLException, IllegalArgumentException {\n+    private void initServer() throws SSLException {\n         debug(\"JSSEngine: initServer()\");\n \n         // The only time cert and key are required are when we're creating a\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5MDU3Ng==", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428890576", "bodyText": "It should say SSLException instead.", "author": "edewata", "createdAt": "2020-05-21T20:17:54Z", "path": "org/mozilla/jss/ssl/SSLServerSocket.java", "diffHunk": "@@ -266,9 +269,21 @@ public void close() throws IOException {\n      *  will contain the session cache. If null is passed, the server default\n      *  is used: <code>/tmp</code> on Unix and <code>\\\\temp</code> on Windows.\n      */\n-    public static native void configServerSessionIDCache(int maxSidEntries,\n-        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory)\n-        throws SocketException;\n+    public static void configServerSessionIDCache(int maxSidEntries,\n+        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory) throws SocketException {\n+        try {\n+            JSSEngine.initializeSessionCache(maxSidEntries, ssl3EntryTimeout, cacheFileDirectory);\n+        } catch (SSLException parent) {\n+            // Because JSSEngine.initializeSessionCache is utilized during\n+            // init of JSSengine implementations, it can only throw a\n+            // RuntimeException. However, in the event it fails, we should", "originalCommit": "ae4d6da1c9cf61d4031bbf53d60f02fc30720096", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48f2f58d74f3e54e2ca4a0b0dcb2a0ccf310d2cb", "chunk": "diff --git a/org/mozilla/jss/ssl/SSLServerSocket.java b/org/mozilla/jss/ssl/SSLServerSocket.java\nindex f4aed5e4..96229266 100644\n--- a/org/mozilla/jss/ssl/SSLServerSocket.java\n+++ b/org/mozilla/jss/ssl/SSLServerSocket.java\n\n@@ -269,21 +266,9 @@ public class SSLServerSocket extends java.net.ServerSocket {\n      *  will contain the session cache. If null is passed, the server default\n      *  is used: <code>/tmp</code> on Unix and <code>\\\\temp</code> on Windows.\n      */\n-    public static void configServerSessionIDCache(int maxSidEntries,\n-        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory) throws SocketException {\n-        try {\n-            JSSEngine.initializeSessionCache(maxSidEntries, ssl3EntryTimeout, cacheFileDirectory);\n-        } catch (SSLException parent) {\n-            // Because JSSEngine.initializeSessionCache is utilized during\n-            // init of JSSengine implementations, it can only throw a\n-            // RuntimeException. However, in the event it fails, we should\n-            // re-throw it here as a SocketException, keeping the signature\n-            // the same.\n-            SocketException se = new SSLSocketException(parent.getMessage());\n-            se.addSuppressed(parent);\n-            throw se;\n-        }\n-    }\n+    public static native void configServerSessionIDCache(int maxSidEntries,\n+        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory)\n+        throws SocketException;\n \n     /**\n      * Sets the certificate to use for server authentication.\n"}}, {"oid": "48f2f58d74f3e54e2ca4a0b0dcb2a0ccf310d2cb", "url": "https://github.com/dogtagpki/jss/commit/48f2f58d74f3e54e2ca4a0b0dcb2a0ccf310d2cb", "message": "Throw SSLException in JSSEngineReferenceImpl.init\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-22T15:14:47Z", "type": "commit"}, {"oid": "bb7400619eabb0ec78224de5f23a15af9436941f", "url": "https://github.com/dogtagpki/jss/commit/bb7400619eabb0ec78224de5f23a15af9436941f", "message": "Fix race in configuring session cache\n\nWhen multiple JSSSockets and/or JSSEngines are started concurrently,\nthey will race to configure the session cache. However, the cache can\nonly be created by one thread at a time and only needs to be done once\nin the lifetime of JSS. Make JSSEngine take ownership of cache creation\nand utilize this within the legacy SSLSocket as well.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-22T15:15:35Z", "type": "commit"}, {"oid": "bb7400619eabb0ec78224de5f23a15af9436941f", "url": "https://github.com/dogtagpki/jss/commit/bb7400619eabb0ec78224de5f23a15af9436941f", "message": "Fix race in configuring session cache\n\nWhen multiple JSSSockets and/or JSSEngines are started concurrently,\nthey will race to configure the session cache. However, the cache can\nonly be created by one thread at a time and only needs to be done once\nin the lifetime of JSS. Make JSSEngine take ownership of cache creation\nand utilize this within the legacy SSLSocket as well.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "committedDate": "2020-05-22T15:15:35Z", "type": "forcePushed"}]}